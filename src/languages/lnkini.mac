TITLE LINK 10/20 - INITIALIZATION MODULE
SUBTTL	D.M.NIXON/DMN/RKH/SRM/JBC/JNG/DZN/PY/PAH/HD/RJF	5-Feb-88



;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1973,1986,1988.
; ALL RIGHTS RESERVED.
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.



SEARCH	LNKPAR,LNKLOW,OVRPAR,MACTEN,UUOSYM,SCNMAC
IFN TOPS20,< SEARCH MONSYM >	;[1407]
SALL

ENTRY	LINK
EXTERN	LNKSCN,LNKCOR,LNKLOG,.TYOCH


CUSTVR==0		;CUSTOMER VERSION
DECVER==6		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==2417		;DEC EDIT VERSION

VERSION


SEGMENT

	LOC	.JB41
	JSR	UUOTRAP
	RELOC

	.JBHSA==:0		;STARTING ADDRESS STORED IN HIGH SEGMENT
	.JB41==:41

;ACCUMULATORS

R==R1		;MUST MATCH LNKLOD DEFINITION
SUBTTL	REVISION HISTORY


;START OF VERSION 1A
;41	ADD PHYSICAL ONLY GETSEG
;45	HASH INITIAL SYMBOLS AT ASSEMBLY TIME
;46	ADD KLUDGE FEATURE
;64	HANDLE RUN LINK ALL OF CORE PROBLEM
;65	TENEX SPEEDUP
;71	MAKE ALL MESSAGE STANDARD FORM
;106	REMOVE HIORG & ONESEG
;107	CHANGE KLUDGE TO MIXFOR

;START OF VERSION 2
;135	ADD OVERLAY FACILITY
;145	IMPLEMENT USER LIBRARIES
;157	(12640) MAKE VALUE OF FORLIB BE -2 IF .FORLB =-1
;161	ADD LANGUAGE DEPENDENCY TO /USERLIB
;202	REMOVE CORE UUO BEFORE GETSEG

;START OF VERSION 2B
;225	ADD SUPPORT FOR PSECT (MACRO VERSION 51)
;230	ADD CHECK THAT LOW SEG DATA BASE IS SAME SIZE IN ALL SEGMENTS
;302	HANDLE TENEX IDDT CORRECTLY
;333	Add code to handle sucessful GETTAB return of zero
;346	INCLUDE EDIT 302 IN MAINTENANCE SOURCES.  LABEL EDIT 230.
;353	REMOVE EDIT 225

;START OF VERSION 2C
;444	Don't lose libraries defined with the USELIB macro.
;530	Define triplet flags correctly and use TXxx macros.
;557	Clean up listing for release.

;START OF VERSION 3A
;560	Release on both TOPS-10 and TOPS-20 as LINK version 3A(560)

;START OF VERSION 4
;600	Put phased lowseg code at PHAZLO; start DY area at .JBFF
;604	Support device NUL: correctly
;607	Reserve page 377 on TOPS-20 for HELPER so /HELP will work
;635	Initialize ARSIZE to .ARS.
;636	Make TTYIT and LOGIT preserve T1.
;650	Use VM on TOPS-10 if available.
;674	GETSEG other segments correctly if LINK is run from an SFD.
;677	Don't set /SYMSEG:LOW by default if loading overlays.
;706	Setup RC.NTB
;727	Set defualt symbol limt to .SYLIM
;731	SEARCH MACTEN,UUOSYM instead of C.
;732	Initialize lowest location to 400000,,0.
;750	Initialize LC.AB to LC.LB+.IWM
;765	Release on both TOPS-10 and TOPS-20 as LINK version 4(765)
;START OF VERSION 4A
;1120	Initialize OKCPUS to all known CPUs.
;1124	Make TTYIT return to a potentially execute-only high segment again.
;1126	Use ACs for GETSEG args if all 7.01 GETTABs are not available.
;1132	Initialize .LOW.'s RC.AT and RC.HL.
;1150	Call proper LNKFIO routines if a log file is opened at start-up time.
;1151	Add .JBEDV.
;1172	Don't initialize SYMLIM.
;1174	Label and clean up all error messages.
;1217	Clean up the listings for release.
;1220	Release on both TOPS-10 and TOPS-20 as version 4A(1220).

;START OF VERSION 4B
;1254	Update MAKLIB internal macro
;1300	Add code to initialize RC.LM in .ABS. and .LOW.
;1301	Do GETTAB to determine initial verbosity.
;1304	Initialize RC.MAP
;1315	Use bits for compiler type in MAKLIB definition.

;START OF VERSION 5
; Maintanence edits 1221-1377
;1400	Use OVRPAR.MAC.
;1407	Streamline initialization code on Tops20.
;1436	Use connected directory, not logged in directory PPN on TOPS-20.

;START OF VERSION 5.1
;1500-1677 Reserved for maintenance.
;1546	Use bit not compiler code at SETUSE+17.
;1736	Strip unsupported FMXFOR code.
;1744	supress loading attempt if compilation errors occurred during
;	EXECUTE command.
;2026	Update copyright and cleanup listings.
;2050	Make question mark in loading suppressed message be in column 1.
;2070	Check only right half of .JBERR - Conditionalize .SGNAM
;2075	Eliminate .SGNAM, .SGPPN, .SGDEV and add fatal error if GETTAB fails.

;Start of version 6
;2207	Initialize RC.MAP with internal psect indices 0 and 1.
;2247	Create an inferior fork.
;2254	Use new format of segment table if fake JOBDAT title.
;2300	Remove F40 and FTFORK code.
;2306	Get TOPS-20 format date and time for PDV.
;2337	Trap CFORK% JSYS errors.
;2403	New copywrite statement.
;2417	Update copywrite statement to 1988.
SUBTTL	INITIALIZE


;HERE AFTER START,  RUN, EXECUTE, LOAD OR RUN UUO

LINK:	PORTAL	.+2		;EXECUTE ONLY
	PORTAL	.+2		;CCL
	TDZA	P1,P1		;CLEAR OFFSET
	MOVEI	P1,1		;SET OFFSET
	RESET			;RESET ANY EXTERNAL I/O
	JUMPE	P1,F1		;[1744] IF NOT CCL SKIP COMP ERROR 
				;CHECK AND DON'T OUPUT MESSAGE
	HRRZ	T1,.JBERR	;[2070] get any compilation errors
	JUMPG	T1,LOASUP	;[2070] go suppress loading if any errors
	OUTSTR	CCLMES		;TELL THE WORLD WHO IS NOW RUNNING
F1:	MOVEI	T2,EZCOR+AD.FRC	;WE NEED AT LEAST THIS MUCH CORE
	CAMG	T2,.JBREL	;SEE IF WE HAVE IT
	JRST	.+3		;YES
	CORE	T2,		;NO, BUT GET IT
	  JRST	E$$IMI		;[1174] YOU LOSE
	MOVEM	P1,OFFSET	;SAFE TO STORE OFFSET NOW
	MSTIME	T1,		;GET INITIAL TIME (MORE OR LESS)
	MOVEM	T1,TIMEON	;SAVE FOR LOG FILE
IFN TOPS20,<			;[2306]
	GTAD%			;[2306] GET TOPS-20 FORMAT DATE AND TIME
	MOVEM	T1,DATIME	;[2306] SAVE IT
>;[2306] IFN TOPS20
	MOVE	T1,[ZCOR,,ZCOR+1]
	SETZB	FL,ZCOR		;CLEAR FLAGS AND CORE
	BLT	T1,EZCOR
;DO NOT CLEAR REST OF CORE SINCE MONITOR WILL DO IT
;ON FIRST TIME, AND RESTART LOGIC ON SUBSEQUENT TIMES
;THIS IS ESPECIALLY IMPORTANT IN V/M IF RUNNING IN LARGE LOW SEG
	MOVE	P,[IOWD LN.EPD,EPDP+1]	;ESTABLISH PUSH-DOWN LIST
	MOVEM	P,EPDP		;FOR EMMERGENCY WORK
	SKIPN	OFFSET		;IF NOT CCL MODE
	SETZM	.JBERR		;CLEAR COMPILER ERRORS
IFE FTSINGLE,<
	MOVSI	T1,HICODE	;NOW FOR PHASED CODE
	HRRI	T1,PHAZLO	;INTO DYNAMIC AREA
	BLT	T1,HIEND	;FOR GETSEGS ETC
	MOVEI	T1,SEGCOD	;ADDRESS OF GETSEG ROUTINE
	MOVEM	T1,NXTSEG	;WHERE OTHER SEGMENTS CAN USE IT
	MOVEI	T1,PRVSEG	;SAME BUT FOR LAST SEGMENT
	MOVEM	T1,LSTSEG

;NOW TRY TO GET WHERE WE CAME FROM (INCLUDING SFD'S) VIA GETTAB.
;IF UNAVAILABLE (OLD MONITOR), USE INFO SET UP ABOVE.

	MOVSI	T1,-<.PTMAX-.PTSFD-1>	;NUMBER OF SFD'S
	HRROI	T2,.GTRS0	;GETTAB FOR RUN FROM SFD, THIS JOB
SFDLUP:	MOVE	T3,T2		;[1126] SET UP FOR NEXT SFD
	GETTAB	T3,		;GET IT
	  JRST	NOSFD		;[1126] GETTAB FAILED, SEE WHY
	MOVEM	T3,SEGPTH+.PTSFD(T1)	;STORE THIS SFD
	ADDI	T2,1		;INCREMENT GETTAB ARG
	AOBJN	T1,SFDLUP	;[1126] LOOP FOR ALL SFD'S
	JRST	GETUFD		;[1126] GOT ALL SFDS, NOW FOR UFD


;HERE WHEN A GETTAB TO GET AN SFD FAILED.  SEE IF THE MONITOR IS TOO OLD.

NOSFD:	TRNE	T1,-1		;[1126] FAIL FIRST TIME?
	JRST	GETUFD		;[1126] NO, GOT SOME SFDS, USE NEW DATA
	MOVEI	T1,<<GETSEG T1,>&RH.ALF>;[1126] USE DATA ABOVE
	HRRM	T1,NGTSEG	;[1126] BUT NEED TO REPLACE GETSEGS
	HRRM	T1,EGTSEG	;[1126] TO REPLACE PHYSICAL ONLY BIT
	JRST	GETHSO		;[1126] GETSEG INFO DONE, PROCEED
;HERE IF THE 7.01 GETTABS WORK.  FILL IN THE REST OF THE DATA.

GETUFD:	SETZM	SEGPTH+.PTSFD(T1)	;FORCE A ZERO AFTER THE LAST SFD
	HRROI	T1,.GTRDI	;UFD OF PATH WE WERE RUN FROM
	GETTAB	T1,		;GET IT
	  JRST	E$$GTF		;[2075] CAN'T
	SKIPN	T1		;THERE?
	JRST	GETHSO		;NO, GIVE UP
	MOVEM	T1,SEGPTH+.PTPPN	;STORE UFD TO FINISH PATH BLOCK
	HRROI	T1,.GTRDV	;GET DEVICE WE WERE RUN FROM
	GETTAB	T1,		; . . .
	  JRST	E$$GTF		;[2075] CAN'T
	SKIPN	T1		;AVAILABLE?
	  JRST	E$$GTF		;[2075] NEED A DEVICE
	MOVEM	T1,SEGBLK	;YES, STORE DEVICE
	MOVEM	T1,ERRBLK	;FOR LNK999 ALSO
	HRROI	T1,.GTRFN	;[1126] THE FILE NAME WE CAME FROM
	GETTAB	T1,		;[1126] GET IT
	  JRST	E$$GTF		;[2075] CAN'T
	SKIPN	T1		;[1126] RETURN ANYTHING?
	  JRST	E$$GTF		;[2075] CAN'T
	MOVEM	T1,FSTSEG	;[1126] OK, STORE IT
	MOVEM	T1,SEGBLK+1	;[1126] FOR GETSEGS TOO
	MOVEI	T1,SEGPTH	;NOW POINT GETSEG BLOCKS TO PATH BLOCK
	MOVEM	T1,SEGBLK+4	;NORMAL GETSEG BLOCK
	MOVEM	T1,ERRBLK+4	;AND LNK999'S COPY
>;END OF IFE FTSINGLE

GETHSO:
IFE TOPS20,<
	MOVE	T1,[-2,,.GTUPM]	;[650] ORIGIN OF HIGH SEG
	GETTAB	T1,		;GET START OF HIGH SEGMENT
	  MOVSI	T1,%HISEG	;ASSUME USER KNOWS WHERE IT STARTS
	SKIPN	T1		;RETURNS ZERO IF NOT IMPLEMENTED
	MOVSI	T1,%HISEG	;USE ASSEMBLY VALUE
	HLRZ	T1,T1
	ANDCMI	T1,777		;ONLY ON A FULL PAGE
	HRRZM	T1,HIORGN	;[650] SAVE HISEG ORIGIN FOR EVERYBODY
> ;[1407] IFE TOPS20
IFN TOPS20,<
	MOVEI	T1,%HISEG	;[1407] PICK UP HISEG ORIGIN
	MOVEM	T1,HIORGN	;[1407] SAVE FOR EVERYBODY
> ;[1407] IFN TOPS20
IFE FTSINGLE,<
	ADDI	T1,.JBHDA##	;ADD OFFSET NOW
	HRRZM	T1,SEGPGN	;SAVE PAGE NUMBER
> ;END OF IFE FTSINGLE
	MOVE	T1,[JRST UUOHANDLER]
	MOVEM	T1,UUOTRAP+1	;FIELD UUOS
IFN FTVM,<
	SETOM	USEVM		;[650] ASSUME VM AVAILABLE
	MOVSI	T1,.PAGCA	;[650] CHECK ACCESS OF PAGE 0
	PAGE.	T1,		;[650] TO SEE IF PAGE. UUO'S WORK
	  SETZM	USEVM		;[650] NOPE, VM NOT AVAILABLE
	MOVEI	T1,.PAGEM	;[650] PAGE. UUO FUNCTION
	MOVEM	T1,PAGFUN	;[650] STORE FOR MONITOR
> ;END IFN FTVM
IFE TOPS20,<
	MOVE	T1,[PTHLEN-1,,PTHARG]
	SETOM	PTHARG		;-1 MEANS RETURN DEFAULT PATH
	PATH.	T1,		;GET DEFAULT PATH
	  SETZM	PTHARG		;IF ERROR, CLEAR ARGUMENT
	GETPPN	T1,		;DETERMINE THIS JOB'S PPN
	  JFCL			;(IN CASE OF JACCT)
	MOVEM	T1,MYPPN	;SAVE FOR THE FUTURE
	SKIPN	PTHDIR		;SEE IF PATH. UUO WORKED
	MOVEM	T1,PTHDIR	;NO, SIMULATE IT
> ;[1407] IFE TOPS20
IFN TOPS20,<
	SETOM	T1		;[1407] TELL US ABOUT OURSELVES
	MOVE	T2,[ XWD -21,.TEMP ]
				;[1407] PUT DETAILS IN TEMP AREA
	SETZM	T3		;[1511]
	GETJI%			;[1407] DONE
	  JFCL			;[1407] SO WE DON'T EXIST, EH?
	MOVEI	T4,.TEMP	;[1407] BASE OF JOB INFO BLOCK
	MOVE	T1,.JIDNO(T4)	;[1407] [1436] NOW WHO ARE WE?
	STPPN%			;[1407] [1436] MAKE CONNECTED DIRECTORY A PPN
	MOVEM	T2,MYPPN	;[1407] AND REMEMBER IT
	MOVEM	T2,PTHDIR	;[1407] ...
	SKIPE	.JIBAT(T4)	;[1407] RUNNING UNDER BATCH?
	SETOM	BATCH		;[1407] YES
	MOVE	T1,.JIJNO(T4)	;[1407] JOB NUMBER?
	MOVEM	T1,JOBNUM	;[1407] REMEMBER IT.
> ;[1407] IFN TOPS20

IFE TOPS20,<
	MOVNI	T1,1		;STANDARD AOBJN TEST FOR KI-10
	AOBJN	T1,.+1		;TESTS FOR HALF-WORD ADDER
	JUMPN	T1,KSET		;KA-10 IF CARRY
>;END OF IFE TOPS20
	AOS	CPUHST		;KI, KL, TOPS-20 BECOMES 1
IFE TOPS20,<
	MOVE	T1,[115,,.GTCNF]
	GETTAB	T1,		;PAGE SIZE
	  SKIPA	T1,[%CNVER]	;FAILED, USE GETTAB FOR MONITOR VERSION
	SOJA	T1,GSET		;GET MASK FOR PAGE SIZE
	GETTAB	T1,
	  SETZ	T1,		;NOT 5.06 FOR SURE
	HRRZ	T1,T1		;ONLY WANT DEC HALF
	CAIGE	T1,50511	;TEST FOR 5.06 OR LATER
	JRST	KSET		;NO, USES 1K BOUNDS
PSET:	SKIPA	T1,[777]	;AND STORE SIZE
KSET:	MOVEI	T1,1777		;KA-10 PAGE SIZE
GSET:	MOVEM	T1,.PGSIZ	;USED TO MAKE SAVE FILES ETC
>;END OF IFE TOPS20
;HERE WHEN PAGE SIZE KNOWN. DO OTHER MISC. SETUP

IFE TOPS20,<
	HRROI	T1,.GTLIM	;JOB'S TIME LIMIT AND BATCH STATUS
	GETTAB	T1,
	  JRST	.+3		;CANNOT BE BATCH JOB
	TXNE	T1,JB.LBT	;TEST FOR BATCH CONTROL
	SETOM	BATCH		;YES, IT IS
	PJOB	T1,		;GET JOB NUMBER
	HRRZM	T1,JOBNUM	;SAVE IN RIGHT HALF
> ;[1407] IFE TOPS20
IFN TOPS20,<
	MOVE	T1,JOBNUM	;[1407] JOBNUM ALREADY HAS JOB NUMBER
> ;[1407] IFN TOPS20
	MOVEI	T4,3		;PICK UP 3 CHARS
PJLOOP:	IDIVI	T1,^D10		;ONE AT A TIME
	ADDI	T2,'0'		;MAKE SIXBIT
	LSHC	T2,-6		;SAVE CHAR
	SOJG	T4,PJLOOP
	HLLM	T3,JOBNUM	;SAVE SIXBIT FOR TMP FILES
	MOVSI	T1,'DSK'	;SET UP GLOBAL DEFAULTS
	MOVEM	T1,G.DEV	;INITIAL SETTINGS
	HRLOI	T1,'REL'
	MOVEM	T1,G.EXT
	MOVEI	T3,AD.FRC	;DEFAULT VALUE
	MOVEM	T3,FRECOR	;OF SPACE TO BE LEFT IN TABLES
	MOVE	T1,HIORGN	;MAKE SURE WE NEVER EXPAND INTO HISEG
	SUBI	T1,1001		;[607] RESERVE A PAGE FOR HELPER
	MOVEM	T1,MAXCOR	; IF USER DOES NOT SET A VALUE
IFN TOPS20,<
	CORE	T1,		;GET ALL CORE IN LOW SEGMENT
	  JRST	E$$IMI		;[1174] SHOULD NEVER HAPPEN
>
IFE TOPS20,<
	SUBI	T3,3		;INCASE IT IS EXACTLY A BOUND
	IDIVI	T3,4		;NUMBER OF TABLES SETUP INITIALLY
	ADDI	T3,.IPM		;MAKE INTO BLOCK BOUND
	ANDCMI	T3,.IPM
	MOVE	P2,T3		;SAFER PLACE
	MOVX	T1,.INFIN	;[1172] INITIALIZE LOWEST LOCATION
	MOVEM	T1,LOWLOC	;[732]
>				;[2247]
;HERE TO SETUP RELOCATION TABLES ETC
;THE MAIN TABLE RC.TB CONSISTS OF POINTERS TO INDIVIDUAL CODE BLOCKS
;RC.TB GROWS AS REQUIRED. THE INDIVIDUAL BLOCKS CONTAIN
;RC.SG	SEGMENT NUMBER (INDEX TO SG.TB)
;RC.NM	6-BIT NAME OF R.C.
;RC.IV	INITIAL VALUE OF R.C.
;RC.CV	CURRENT VALUE OF R.C. (THIS IS WHAT IS ADDED TO RELOCATABLE WORD)
;RC.OF	OFFSET TO LOCATION IN CORE RELATIVE TO LC.LB OR HC.LB	;
;RC.HL	HIGHEST LOCATION LOADED INTO (NEXT R.C. AT END)
;RC.LB	WHICH SEGMENT (EITHER LC.LB OR HC.LB ADDRESS)
;RC.WD	POINTER TO START OF CODE WINDOW (LW.S1 OR LW.S2)
;RC.PG	POINTER TO END OF CODE WINDOW (LW.S1 OR LW.S2)
;RC.LM	UPPER LIMIT OF PSECT+1 (FIRST ILLEGAL ADDRESS FOR PSECT LOADING) [1300]

CORINI:	MOVEI	T1,RC.INC-2	;JUST A RANDOM NUMBER
	MOVEM	T1,RC.FRE	;NUMBER OF FREE SLOTS
	MOVEI	T1,1		;FIRST ONE IS SET NOW
	MOVEM	T1,RC.NO
	HRRZ	P1,.JBFF	;GET START OF DYNAMIC AREA
	SETOM	.JBFF		;STOP ANY ONE USING .JBFF UNTIL AUTHORISED
	MOVEI	T1,SG.TB	;MAKE SEG TAB POINT TO TABLES LIKE RC.TB
	HRLI	T1,R
	MOVEM	T1,SG.TB	;SO WE CAN REFERENCE IT THE SAME WAY
	MOVEM	P1,DY.LB	;STORE START OF  DYNAMIC AREA
	HRR	P,P1		;SETUP REAL PUSHDOWN STACK
	HRLI	P,-LN.PDL	;IN DYNAMIC AREA SO WE CAN MOVE IT
	MOVEM	P,PDP		;SAVE SO WE CAN RESET ON I/O ERRORS
	ADDI	P1,LN.PDL+1
	MOVEM	P1,IO.EMG	;USED FOR OPEN/ENTER WHEN CORE FULL
	ADDI	P1,LN.IO	;RESERVE SPACE BEFORE IT'S TOO LATE
	HRLI	P1,R		;PUT (R) IN INDEX FIELD
	MOVEM	P1,RC.MAP	;[1304] SETUP MAP FOR LOCAL PSECT NUMBERS
	ADDI	P1,RC.INC	;[1304] SAME LENGTH AS RC.TB
	MOVEM	P1,RC.NTB	;[706] SETUP PSECT ORDER TABLE
	ADDI	P1,RC.INC	;[706] SAME LENGTH AS RC.TB
	MOVEM	P1,RC.TB	;AND POINT TO TABLE OF POINTERS
	SETZ	R,		;START AT SLOT #0
	HRRZS	P1
	ADDI	P1,RC.INC
	MOVEM	P1,@RC.TB	;POINT TO SLOT #0
	MOVEM	P1,@RC.NTB	;[706] 
	MOVEI	T2,1		;[1132] SET TO LC AREA
	MOVEM	T2,RC.SG(P1)	;[1132]
	MOVEM	T2,@RC.MAP	;[2207] SET UP MAP FOR BLANK PSECT (0)
	MOVEI	T2,.JBDA	;[1132] INIT H?.S0 TO SHOW JOBDAT LOADED
	MOVEM	T2,HC.S0	;[1132] HIGHEST LOCATION NON-ZERO
	MOVEM	T2,HL.S0	;[1132] HIGHEST LOCATION SEEN
	MOVX	T1,<1,,0>	;[1300] END OF MEMORY
	MOVEM	T1,RC.LM(P1)	;[1300]
	MOVE	T2,['.ABS. ']	;NAME OF IT
	MOVEM	T2,RC.NM(P1)
;NOW BUILD .LOW. RELOCATION COUNTER

	ADDI	P1,RC.INC	;NOW FOR SLOT #1 (0')
	ADDI	R,1
	MOVEM	R,@RC.MAP	;[2207]	SET UP MAP FOR .LOW.
	MOVEM	P1,@RC.TB	;POINT TO SLOT #1
	MOVEM	P1,@RC.NTB		;[706]
	MOVEM	P1,@SG.TB	;AND IN SEGMENT TABLE
	MOVEM	R,RC.SG(P1)	;POINT TO SEG #1 (0 UPWARDS)
	MOVE	T2,['.LOW. ']	;NAME OF IT
	MOVEM	T2,RC.NM(P1)
	SETZM	RC.IV(P1)	;INITIAL VALUE OF 0
	MOVEI	T2,.JBDA	;PRESET TO 140
	MOVEM	T2,RC.CV(P1)	;CURRENT VALUE
	MOVEM	T2,RC.HL(P1)	;[1132] ALSO HIGHEST LOADED SO FAR
	MOVX	T2,AT.RP	;[2247] GET THE RELOCATABLE ATTRIBUTE
	MOVEM	T2,RC.AT(P1)	;[2247] SET AS A RELOCATABLE PSECT
	SETZM	RC.OF(P1)	;ZERO RELATIVE TO LC.LB
	MOVX	T2,<1,,0>	;[1300] END OF MEMORY
	MOVEM	T2,RC.LM(P1)	;[1300]
	MOVEI	T2,LC.LB	;POINT TO LOW SEGMENT
	MOVEM	T2,RC.LB(P1)
	MOVEI	T2,LW.S1	;POINTER TO BASE OF CORE WINDOW IN PAGING
	MOVEM	T2,RC.WD(P1)
	MOVEI	T2,UW.S1	;END OF WINDOW (PAGING IF NON-ZERO)
	MOVEM	T2,RC.PG(P1)
	ADDI	P1,RC.INC
	MOVEM	P1,DY.PT	;POINTER TO NEXT FREE LOCATION IN DY
IFE TOPS20,<
	ADDI	P1,1000		;LEAVE SOME BUFFER SPACE
>
	IORI	P1,.IPM		;GET TO A GOOD BREAK
	MOVEM	P1,DY.AB	;ACTUAL TOP IN USE
	MOVE	T2,P1		;CALCULATE FREE SPACE
	SUB	T2,DY.PT	;ABOVE DY.PT
	MOVEM	T2,DY.FR	;AND STORE
IFE TOPS20,<ADDI P1,(P2)	;ALLOCATE FREE SPACE>
IFN TOPS20,<MOVEI P1,LC.ORG-1	;ONE LESS THAN START OF CODE>
	MOVEM	P1,DY.UB	;TOP OF DYNAMIC AREA (FOR NOW)
	ADDI	P1,1		;START OF CORE AREA
;HERE TO SETUP ALL OTHER AREA BOUNDS, POINTERS ETC
	MOVEM	P1,LC.LB
	IORI	P1,.IWM		;[750] ALLOCATE FOR JOBDAT AREA
	MOVEM	P1,LC.AB
IFE TOPS20,<ADDI P1,(P2)	;SOME FREE SPACE>
IFN TOPS20,<MOVEI P1,LS.ORG-1	;ONE LESS THAN START OF SYMBOLS>
	MOVEM	P1,LC.UB
	ADDI	P1,1
	MOVEM	P1,LS.LB	;START OF LOCAL SYMBOL AREA
	ADDI	P1,ENDSYM-LSTBL+1	;NUMBER OF LOCAL SYMBOL LOCATIONS
	MOVEM	P1,LS.PT	;POINTS TO NEXT FREE LOCATION
	IORI	P1,.IPM		;NEXT BLOCK BOUND
	MOVEM	P1,LS.AB
	MOVE	T1,P1
	SUB	T1,LS.PT	;CALCULATE FREE SPACE IN LAST BLOCK
	MOVEM	T1,LS.FR
IFE TOPS20,<ADDI P1,(P2)	;SPACE>
IFN TOPS20,<MOVEI P1,GS.ORG-1	;ONE LESS THAN START OF GLOBAL SYMBOLS>
	MOVEM	P1,LS.UB
	ADDI	P1,1
	MOVEM	P1,GS.LB	;GLOBAL SYMBOL AREA
	ADDI	P1,ENDSYM-GSTBL+1	;END OF SYMBOLS
	MOVSI	T1,(POINT 18,0)	;RELATIVE PTR TO PRIME TABLE
	MOVEM	T1,PRMPTR	;SETUP PRIME NUMBER TABLE PTR
	MOVEI	T2,I.PRM	;INITIAL NUMBER
	MOVEM	T2,HT.PRM	;SET SIZE
	MOVEI	T2,<<I.PRM+.L-1>/.L*.L>	;ALLOCATE SPACE IN MULTIPLES OF .L
					;SO REHASHING DOES NOT WASTE SPACE
	HRLI	P1,P2		;INDEX USED IN TRYSYM COMPARES
	MOVEM	P1,HT.PTR	;STORE POINTER
	ADDI	P1,(T2)		;RESERVE SPACE FOR TABLE
	HRRZS	P1
	MOVEM	P1,GS.PT	;NEXT FREE LOCATION
	IORI	P1,.IPM		;NEXT BLOCK BOUND
	MOVEM	P1,GS.AB	;MARK THIS AS TAKEN
	MOVE	T2,P1
	SUB	T2,GS.PT	;SEE HOWMUCH ACTUALLY FREE
	MOVEM	T2,GS.FR	;SAVE IT
IFE TOPS20,<
	ADDI	P1,(P2)		;SOME FREE SPACE
	MOVEM	P1,GS.UB	;UPPER BOUND FOR NOW
	CAMGE	P1,.JBREL	;SEE IF ENOUGH
	JRST	.+3		;YES
	CORE	P1,		;NO, TRY FOR MORE
	  JRST	E$$IMI		;[1174] YOU LOSE
>;END IFE TOPS20
	HRRZ	P1,.JBREL	;GET TOP OF LOW SEGMENT
	MOVEM	P1,GS.UB	;AS TOP OF GLOBAL SYMBOLS
;NOW TO STORE INITIAL SYMBOLS

	MOVEI	T1,ENDSYM-LSTBL+1	;NUMBER OF LOCAL SYMBOL LOCATIONS
	MOVE	P1,LS.LB	;BASE OF LOCAL SYMBOLS
	MOVEM	T1,LSYM		;REQUIRED UNLESS /NOINITIAL
	MOVEM	T1,(P1)		;STORE IN FIRST WORD (UNUSED)
	HRLI	T1,LSTBL	;FORM BLT POINTER
	HRRI	T1,1(P1)
	BLT	T1,ENDSYM-LSTBL(P1)	;MOVE IN

	MOVEI	T1,<ENDSYM-GSTBL>/.L	;NUMBER OF GLOBAL SYMBOLS
	MOVE	P1,GS.LB	;BASE OF GLOBAL SYMBOLS
	MOVEM	T1,GSYM		;REQUIRED UNLESS /NOINITIAL
	MOVEM	T1,(P1)		;STORE IN FIRST WORD (UNUSED)
	HRLI	T1,GSTBL	;FORM BLT POINTER
	HRRI	T1,1(P1)
	BLT	T1,ENDSYM-GSTBL(P1)	;MOVE IN

	HRLI	T1,HSTBL	;FORM BLT POINTER
	HRRZ	P1,HT.PTR	;BASE OF HASH TABLE
	HRR	T1,P1
	BLT	T1,ENDHSH-HSTBL-1(P1)	;MOVE HASH TABLE
	MOVEI	T1,.HS%		;GET % TO FILL TABLE
	MOVEM	T1,HSFACT
	MOVE	T1,HT.PRM	;GET CURRENT HASH SIZE
	IMULI	T1,.HS%		;SEE HOW MUCH TO FILL
	IDIVI	T1,^D100
	SUB	T1,GSYM		;MINUS INITIAL NO.
	MOVEM	T1,HSPACE	;HASH TABLE FULL ENOUGH AT THIS  POINT
;HERE TO INIT LOG FILE IF POSSIBLE
LOGINI:	MOVEI	T1,TTYIT	;LINE BUFFERING ROUTINE FOR OUTCHRS
	MOVEM	T1,TTYSUB
	PUSHJ	P,.TYOCH##	;INCASE NO LOG FILE
	MOVEI	T1,L%W		;GET TTY ERROR CUTOFF
	MOVEM	T1,ERRLVL	;INCASE NOT SET BY USER
	MOVEI	T1,S%C		;[1174] SET UP DEFAULT SEVERITY
	SKIPE	BATCH		;HOWEVER IN BATCH MODE
	MOVEI	T1,S%B		;U LOSE MUCH SOONER
	MOVEM	T1,SEVLVL
	MOVEI	T1,L%W		;[604] NORMAL LOG FILE CUTOFF
	MOVEM	T1,LOGLVL
	MOVE	T1,[LOGIT,,TTYIT] ;[1174] IN CASE /LOG LATER
	MOVEM	T1,LOWSUB	;[1174] SO WE CAN FIND ROUTINES
	HRROI	T1,.GTWCH	;[1301] GET THE DEFAULT /MESSAGE
	GETTAB	T1,		;[1301] FROM THE MONITOR
	SETZ	T1,		;[1301] NO GETTAB
	LDB	T1,[POINTR T1,JW.WMS] ;[1301] GET THE USEFUL BITS
	SKIPN	T1		;[1301] IS THERE A DEFAULT?
	MOVX	T1,M%P!M%F	;[1301] NO, USE /VERB:MEDIUM
	TXNE	T1,M%C		;[1301] CONTINUATION ASKED FOR?
	TXO	T1,M%F		;[1301] YES, GIVE FIRST TOO
	MOVEM	T1,VERLVL	;[1301] SET THE VERBOSITY LEVEL
	MOVSI	T1,'LOG'	;SEE IF WE ALREADY HAVE A LOG DEVICE
	DEVCHR	T1,		;SKIP IF ASSIGNED
	JUMPE	T1,NOLOG	;NOT YET
	SETZM	LOGLVL		;[604] ASSUME USER WANTS ALL IF ASSIGNED LOG DEVICE
	TXNE	T1,DV.TTA	;YES, BUT IS IT USERS TTY?
	JRST	[SETOM	LOGTTY		;YES, NOT REALLY A LOG DEVICE
		JRST	LOGMSG]	;[1174] GO PRINT START OF LOG MSG
	MOVEI	T2,LN.IO	;SPACE WE NEED
	PUSHJ	P,DY.GET##	; FOR ENTER BLOCK
	MOVEM	T1,IO.PTR+RC	;STORE ADDRESS IN I/O TABLE
	MOVEI	T2,RC		;[1150] SET UP LOG FILE CHANNEL
	MOVEM	T2,IO.CHN	;[1150]   ..
	MOVX	T2,<Z RC,>	;[1150]   AND IN FORM WE CAN IOR INTO UUOS
	MOVEM	T2,I.CHN(T1)	;[1150]   ..
	MOVEI	T2,.IOASC	;ASCII MODE
	MOVEM	T2,I.MOD(T1)
	MOVSI	T2,'LOG'	;DEVICE
	MOVEM	T2,I.DEV(T1)
	MOVEI	T2,RCBUF	;BUFFER HEADER
	MOVSM	T2,I.BUF(T1)	;OUTPUT ONLY
	MOVEI	T2,LN.RIB-1	;EXTENDED ENTER
	MOVEM	T2,I.RIB(T1)
	MOVSI	T2,'LOG'	;EXTENSION
	MOVEM	T2,I.EXT(T1)
	PUSHJ	P,DVNAM.##	;[1150] SET UP DEFAULT FILE NAME
	PUSHJ	P,DVCHK.##	;[1150] MAKE SURE DEVICE CAN HANDLE I/O MODE
	PUSHJ	P,DVOPN.##	;[1150] OPEN THE LOG FILE
	PUSHJ	P,DVENT.##	;[1150] ENTER THE FILE
;HERE WITH LOG FILE OPENED AND ENTERED. ALLOW LINK TO USE IT FOR LOGGING.

	MOVEI	T1,LOGIT	;NOW WE CAN POINT TO IT
	MOVEM	T1,LOGSUB	;SET NON-ZERO
	PUSHJ	P,.TYOCH	; ALWATS EXCEPT WHEN IN SCAN
LOGMSG:
E$$LFB::.ERR.	(MS,.EC,V%L,L%I,S%I,LFB,<LINK log file begun on >) ;[1174]
	.ETC.	(DAT)		;[1174]
;	JRST	NOLOG		;NOW DO OTHER THINGS
;HERE TO INITIALIZE OTHER ODD ITEMS

NOLOG:
E$$LIN::.ERR.	(MS,,V%L,L%I,S%I,LIN,<LINK initialization>) ;[1174] NO POINT TIL NOW
	MOVEI	T1,OPENBL	;PUT ADDRESS OF INPUT I/O BLOCK
	MOVEM	T1,IO.PTR+DC	;IN I/O VECTOR INCASE OF ERRORS
	MOVEI	T1,.IOBIN	;MODE 14
	MOVEM	T1,OPENBL	;FOR INPUT DEVICE
	MOVEI	T1,DCBUF	;INPUT BUFFER HEADER
	MOVEM	T1,FSTR+1	;IN OPEN BLOCK
	MOVSI	T1,(Z DC,)	;GET CHAN# IN AC FIELD
	MOVEM	T1,OPENBL+I.CHN	;FOR OPEN/LOOKUP ETC
	MOVE	T1,[C%DEFAULT]	;DEFAULT MAP CONTENTS
	MOVEM	T1,MAPCON	;INCASE NO USER SWITCHES
	MOVEI	T1,CP.MSK	;[1120] START PROG RUNNABLE ON ALL CPU TYPES
	MOVEM	T1,OKCPUS	;[1120]   ..
IFN FTOVERLAY,<
	MOVEI	T1,.SPA		;SET DEFAULT FOR LINK 0
	MOVEM	T1,SPACE	;IN CASE USER DOES'NT
	MOVEI	T1,PH.LEN	;[1400] LENGTH OF PREAMBLE
	MOVEM	T1,PH+PH.HDR	;[1400] FOR LINK FILES
	MOVX	T1,<.ARS,,.ARS>	;[635] SET DEFAULT /ARSIZE
	MOVEM	T1,ARSIZE	;[635] IN CASE NO /ARSIZE SWITCH
	SETOM	LNKMAX		;SO WE CAN TELL LINK #0
>
IFN TOPS20,<
	MOVSI	T1,L.SYM	;ALWAYS LOAD SYMBOLS IF TENEX
	MOVEM	T1,FLAGS	;REMEMBER OVER CR-LF
>
	MOVEI	T1,START	;RESTART CODE
	HRRM	T1,.JBSA##	;SO WE GET CORRECT SEGMENT

IFN DEBSW,<
	MOVE	T1,[JRST %DDT%]	;ENTER DDT IF LOADED
>
IFE DEBSW,<
	MOVSI	T1,(POPJ	P,)	;NO DDT
>
	MOVEM	T1,ENTDDT	;WILL HANDLE DEBUG RIGHT

IFN TOPS20,<			;[2247]
;[2247] Here to set up the inferior fork.

	MOVX	T1,CR%CAP	;[2247] Give inferior some privs
	CFORK%			;[2247] Create it
	 ERNAM	CFORK%		;[2337] Catch errors
	MOVEM	T1,LC.JF	;[2247] Store the fork handle
	SETZB	T1,LW.LC	;[2247] Map from page zero
	MOVE	T2,LC.AB	;[2247] Get the top
	SUB	T2,LC.LB	;[2247] Minus bottom is size
	MOVEM	T2,UW.LC	;[2247] Store size
	PUSHJ	P,LC.IN##	;[2247] Map it in (section 0 always exists)
>;[2247] IFN TOPS20

	MOVEI	T2,USELEN	;ANY USER LIBS TO SETUP?
	JUMPE	T2,LNKSCN	;NO, SCAN FIRST COMMAND LINE
SUBTTL	SETUP USER LIBRARIES


SETUSE:	PUSHJ	P,DY.GET##	;GET SPACE WE NEED
	MOVEM	T1,USEPTR	;SETUP POINTER
	MOVE	T3,T1
	HRLI	T3,LIBTBL	;SETUP BYTE POINTER
	MOVE	T4,T1
	ADDI	T4,-1(T2)	;CALCULATE END
	BLT	T3,(T4)		;MOVE LIST
	SUBI	T2,F.LEN	;ANY MORE?
	JUMPLE	T2,LNKSCN	;NO, GO TO SCANNER
	ADDI	T1,F.LEN
	MOVEM	T1,-F.LEN(T1)	;POINT TO NEXT
	JRST	.-4		;TRY AGAIN
DEFINE MAKLIB (LANGUAGE,DEVICE,FILE,EXT,PRJ,PRG,SFD) <
	.ZZT==0			;[1315] ACCUMULATE LANGUAGE BITS
	.ZZZ==.			;REMEMBER CURRENT POSITION
	 EXP	0		;ZERO LINK WORD (NEXT LIB)
 DEFINE X (A,B,C,D)<
  IFIDN <A>,<LANGUAGE>,<
	.ZZT==.ZZT!1B<CT.'B>	;[1546] USE FOR USER DEFINED LIBRARY
 >>
 IFIDN <ALL><LANGUAGE>,<
   .ZZT==-1			;;[1315] USE FOR ALL LANGUAGES
 >
 IFB <LANGUAGE>,<
   .ZZT==-1			;;[1315] USE FOR ALL LANGUAGES
 >
 PROCESSORS
IFE .ZZT,<PRINTX ?UNKNOWN LANG. "LANGUAGE" IN USELIB MACRO ;;[1315]
	.ZZT==-1		;[1315]ASSUME ALL ON ERROR>
   EXP	.ZZT			;[1315] PROCESSOR BITS
 IFNB <DEVICE>,<<SIXBIT /DEVICE/>>
 IFB  <DEVICE>,< SIXBIT /SYS/>
		<SIXBIT /FILE/>
	EXP	-1
 IFNB <EXT>,<<SIXBIT /EXT/>!777777>
 IFB  <EXT>,<<SIXBIT /REL/>!777777>
 IFNB <PRJ>,<EXP	FX.DIR>
 IFB  <PRJ>,<EXP	0>
	EXP	0
	XWD	PRJ,PRG
 IFNB <PRJ>,<EXP	-1>
 IFB  <PRJ>,<EXP	0>
IRP	SFD,<			;GENERATE ANY SFDS
	<SIXBIT	/SFD/>
	EXP	-1
>
REPEAT	F.BFR+.ZZZ-.,<		;FILL IN BLANK SFDS
	EXP	0
>
REPEAT	F.LEN+.ZZZ-.,<		;NOW FILL IN SWITCHES (-1)
	EXP	-1
>
>
;DEFINE USER LIBRARIES BY
;MAKLIB	DEVICE,FILE,EXT,PRJ,PRJ,<SFD LIST>
LIBTBL:				;LIST OF LIBRARIES
	USELIB
USELEN==.-LIBTBL

SUBTTL	ERROR MESSAGES


CCLMES:	ASCIZ	\LINK:	Loading
\

LOASUP:	OUTSTR	[ASCIZ/LINK:
?LNKSUP Loading suppressed
/]				;[2050]

	EXIT
E$$GTF:	.OERR.	[ASCIZ/?LNKGTF	GETTAB failed while trying to get program information
/]				;[2075]
	EXIT			;[2075]

E$$IMI::.OERR.	[ASCIZ \?LNKIMI	Insufficient memory to initialize LINK
\]
	EXIT

CPOPJ:	POPJ	P,		;SOMEWHERE TO PUT IT
SUBTTL	INITIAL SYMBOLS


DEFINE SYMBOL (F,S1,S2,V)<
 IFB <F>,<
  PT.SGN!PT.SYM!PS.GLB
 >
 IFNB <F>,<
  PT.SGN!PT.SYM!PS.GLB!'F
 >
 SIXBIT \S1\
 IFB <V>,<
  IFNDEF S2,<EXTERN S2>
  EXP S2
 >
 IFNB <V>,<
  EXP	V
>>

DEFINE .JB (F,S,V)<
.%%'S:	SYMBOL	F,.JB'S,.JB'S,V
 HASH	.JB,S
>

DEFINE	JOB (F,S,V)<
%%%'S:	SYMBOL	F,JOB'S,.JB'S,V
 HASH	JOB,S
>

SALL
;ZERO ALL REQUIRED SYMBOLS
IF1,<
 DEFINE GETSYM (N) <.%'N=0>
 N=0
 REPEAT I.PRM,<GETSYM \N
  N=N+1
 >

;NOW FOR HASH MACRO (PASS1 ONLY)
 DEFINE HASH (J,S)<>
>;END IF1

;ALL WORK DONE ON PASS 2
IF2 ,<
 DEFINE HASH (J,S)<
  IFIDN <J><.JB>,<
   %%%=.%%'S
   PURGE .%%'S
  >
  IFDIF <J><.JB>,<
   %%%=%%%'S
   PURGE %%%'S
  >
  HT=(<SIXBIT /S/>)
  IFN HT-''J'',<HT=<''J''!HT>&<-1-<''J''&HT>>>
  Q=HT/I.PRM
  R=HT-Q*I.PRM
  IFGE Q-I.PRM,<Q=Q-Q/I.PRM*I.PRM>
  IFE Q,<Q=1>
  TRY=1
  ITEM Q,\R
  IFL I.PRM-TRY,<PRINTX INITIAL HASH FAILURE>
 >

 DEFINE ITEM (QT,RM) <
  IFN .%'RM,<
   R=R+Q
   IFL I.PRM-R,<R=R-R/I.PRM*I.PRM>
   IFGE I.PRM-<TRY=TRY+1>,<
    ITEM Q,\R
  >>
  IFE .%'RM,<.%'RM=HT,,%%%-GSTBL+1>
 >
>;END IF2
LSTBL:
;TITLE SYMBOLS (LOCAL FILE ONLY)
	PT.SGN!PT.EXT!PT.TTL!PT.FAK
	'JOBDAT'
	ENDSYM-LSTBL+1

	S.TTL
	'-INITI'
	'AL-SYM'

	S.TTL
	'BOLS  '
	0

	S.TTL!S.LST!S.SEG
	.JBDA			;[2254] LOW SEG ORIGIN
	.JBDA			;[2254] LOW SEG BREAK

GSTBL:
;OLD STYLE JOBDAT SYMBOLS I.E. JOBXXX
IFN .OSJOB,<			;DON'T WASTE SPACE ON OLD SYMBOLS

	JOB	,41
	JOB	,APR
	JOB	,BLT
	JOB	,CHN
IFN FTCN6,<
	JOB	,CN6
>
	JOB	,CNI
	JOB	,COR
	JOB	,DA
	JOB	,DDT
	JOB	,ERR
	JOB	,FF
	JOB	PS.DDT,HDA
	JOB	PS.DDT,HGH
	JOB	PS.DDT,HNM
	JOB	,HRL
	JOB	PS.DDT,HSM
	JOB	PS.DDT,HVR
	JOB	,INT
	JOB	,OPC
	JOB	,PFI
	JOB	,REL
	JOB	,REN
	JOB	,SA
	JOB	,SYM
	JOB	,TPC
	JOB	,USY
	JOB	,UUO
	JOB	,VER

>;END OF IFN .OSJOB
%%%BDT:	SYMBOL	PS.DDT,%JOBDT,%JOBDT
	HASH	%JO,BDT

;NEW STYLE SYMBOLS .JBXXX
	.JB	,41
	.JB	,APR
	.JB	,BLT
	.JB	,CHN
IFN FTCN6,<
	.JB	,CN6
>
	.JB	,CNI
	.JB	,COR
	.JB	,CST
	.JB	,DA
	.JB	,DDT
	.JB	,EDV,112	;[1151] VALUE HERE FOR ASSEMBLY WITH 6.03A
	.JB	,ERR
	.JB	,FF
	.JB	PS.DDT,H41
	.JB	PS.DDT,HCR
	.JB	PS.DDT,HDA
	.JB	PS.DDT,HGA
	.JB	PS.DDT,HGH
	.JB	PS.DDT,HNM
	.JB	,HRL
	.JB	PS.DDT,HRN
	.JB	PS.DDT,HSA
	.JB	PS.DDT,HSM
	.JB	PS.DDT,HVR
	.JB	,INT
	.JB	,OPC
	.JB	,OPS
	.JB	,OVL
	.JB	,PFH
	.JB	,PFI
	.JB	,REL
	.JB	,REN
	.JB	,SA
	.JB	,SYM
	.JB	,TPC
	.JB	,USY
	.JB	,UUO
	.JB	,VER


ENDSYM:!
SUBTTL	HASH TABLE


HSTBL:
IF1,<BLOCK	I.PRM>
IF2,<
 DEFINE SETVAL (N) <
	EXP	.%'N
	PURGE	.%'N
 >
 .XCREF
 N=0
 REPEAT I.PRM,<
  SETVAL \N
  N=N+1
 >
 PURGE TRY,%%%,Q,R,N,HT
 .CREF
>;END IF2
ENDHSH:!
SUBTTL	GETSEG CODE


IFE FTSINGLE,<
HICODE:
	PHASE	PHAZLO		;TOP OF FIXED DATA AREA
;HERE TO DO A GETSEG TO REQUIRED SEGMENT
;ENTERS WITH REQUIRED NAME IN T1
;GETSEG ERROR WILL CALL SEGMENT LNK999 TO HANDLE ERROR
;IF THAT FAILS A SHORT MESSAGE WILL BE OUTPUT ON TTY

SEGCOD:	SETZM	SGFLAG		;GOING FORWARDS
	EXCH	T1,SEGBLK+1	;SAVE SEGMENT NAME
	MOVEM	T1,OLDSEG	;SAVE IN
SGCOD1:	SETZM	SEGBLK+2	;CLEAR EXTENSION
	SETZM	SEGBLK+3	;AND OTHER PARAMS
	SETZM	SEGBLK+5	;AND CORE SIZE
	MOVEM	FL,SAVEAC	;NEED TO SAVE FLAGS
	MOVEM	P,SAVEAC+P	;AND P
;********************		;REMOVE WHEN MONITOR BUG IS FIXED
	MOVSI	T1,1		;GET RID OF HIGH SEGMENT FIRST
	CORE	T1,		; TO BE SURE WE HAVE ENOUGH ROOM
	  JFCL			;CAN NOT HAPPEN
;********************
	MOVEI	T1,SEGBLK	;ADDRESS OF DATA
NGTSEG:	GETSEG	T1,UU.PHY	;GET THE REQUIRED SEGMENT
	  JRST	SEGERR		;FAILED
SEGGOT:	MOVE	P,SAVEAC+P	;RESTORE P
	MOVE	FL,SAVEAC	;AND FLAGS
	MOVE	T1,OFFSET	;NORMAL OR CCL
	MOVE	T2,GTUPM	;ARG FOR GETTAB
	GETTAB	T2,		;TO FIND HIGH SEG ORIGIN
	  MOVSI	T2,%HISEG	;ASSUMED TO BE AT 400000
	SKIPN	T2		;NO NEED FOR DEFAULT ENTRY ADDRESS
				; IF NON-ZERO
	MOVSI	T2,%HISEG	;SET UP DEFAULT ADDRESS
	HLRZ	T2,T2	
	ANDCMI	T2,777		;ONLY SAVE PAGE NUMBER
	HRRZM	T2,HIORGN	;[650] SAVE FOR EVERYBODY
	ADDI	T2,.JBHDA##	;PLUS OFFSET
	MOVEM	T2,SEGPGN	;STORE IT
	MOVEI	T3,EZCOR	;SO WE CAN CHECK IF NEXT SEG IS SAME SIZE
	SKIPN	SGFLAG		;FORWARDS?
	JRST	%%ST(T2)	;YES, GO TO START CODE

	SKIPA	T3,.+1
	SAVEAC+P1,,P1
	BLT	T3,16		;RESTORE ACCS
	JRST	%%RET(T2)	;GO TO START CODE
GTUPM:	-2,,.GTUPM
OLDSEG:!	0		;STORE OLD SEG NAME
SGFLAG:!	0		;-1 IF OLDSEG WANTED
SEGPGN:!	0		;PAGE NO. OF START OF HIGH SEG

PRVSEG:	SETOM	SGFLAG		;GOING BACK
	MOVE	T1,OLDSEG	;GET NAME
	MOVEM	T1,SEGBLK+1	;STORE
	JRST	SGCOD1		;REJOIN COMMON CODE

SEGERR:	HRRM	T1,SEGBLK+2	;STORE ERROR CODE IN GETSEG BLOCK
;********************		;REMOVE WHEN MONITOR BUG IS FIXED
	MOVSI	T1,1		;GET RID OF HIGH SEGMENT FIRST
	CORE	T1,		; TO BE SURE WE HAVE ENOUGH ROOM
	  JFCL			;CAN NOT HAPPEN
;********************
	MOVEI	T1,ERRBLK	;TRY AGAIN
EGTSEG:	GETSEG	T1,UU.PHY
	  HALT			;LET MONITOR PRINT MESSAGE
	JRST	SEGGOT		;WE GOT LNK999, GO TO IT

;GETSEG BLOCK FOR LNK999
ERRBLK:	.-.		;DEVICE
	'LNK999'	;FILE NAME
	EXP	0,0,0,0	;EXT, CORE ETC

>;END IFE FTSINGLE
SUBTTL	RESTART CODE 


IFE FTSINGLE,<
;DO A RUN UUO ON FIRST SEGMENT

START:	MOVE	T1,FSTSEG	;[600] GET NAME OF INITIAL SEGMENT
	CAMN	T1,SEGBLK+1	;[600] ALREADY IN THE RIGHT SEGMENT?
	JRST	START1		;[600] RIGHT SEGMENT
	MOVEM	T1,SEGBLK+1	;STORE NAME
	SETZM	SEGBLK+2	;CLEAR EXT
	SETZM	SEGBLK+3
	SETZM	SEGBLK+5
	SKIPA	T1,.+1		;GET RID OF HIGH AND REST OF LOW SEG
		1,,.+5
	CORE	T1,		; TO BE SURE WE HAVE ENOUGH ROOM
	  JFCL			;CAN NOT HAPPEN
	MOVEI	T1,SEGBLK	;NORMAL START ADDRESS
	RUN	T1,
	  HALT			;TOO BAD
>;END IFE FTSINGLE
SUBTTL	UUO TRAP


UUOHANDLER:
	MOVEM	T1,SAVEAC+T1	;GET AN ACC
	MOVE	T1,.JBUUO	;GET UUO
	TLNN	T1,776000	;ONLY UUO 1 IS VALID
IFE FTSINGLE,<
	JRST	@SEGPGN		;ENTER HIGH SEG
>
IFN FTSINGLE,<
	JRST	%%UUO##		;WE KNOW WHERE IT IS
>
E$$IUU::.OERR.	[ASCIZ /?LNKIUU	Illegal user UUO at PC /] ;[1174]
	SOS	T2,UUOTRAP	;PC+1
	HRLO	T2,T2		;PC IN LEFT FLAG IN RIGHT
	SETZ	T1,		;RECEIVING ACC
	LSHC	T1,3		;GET NEXT CHAR
	ADDI	T1,"0"		;TURN INTO ASCII
	OUTCHR	T1
	TRNE	T2,-1		;ZERO RH WHEN DONE
	JRST	.-5
	EXIT
SUBTTL	ENTER DDT


IFN DEBSW,<
%DDT%:
IFE TOPS20,<
	SKIPN	.JBDDT		;DDT LOADED?
	POPJ	P,		;NO
>
	POP	P,.JBOPC	;SAVE PC
	PUSH	P,T1		;GET AN ACC
	OUTSTR	%DDT1
	MOVE	T1,@.JBOPC	;GET STRING PTR
	OUTSTR	@T1		;OUTPUT IT
	OUTSTR	%DDT2
	HRRZ	T1,.JBDDT	;GET DDT ADDRESS
IFN TOPS20,<
	SKIPN	T1		;REAL DDT?
	MOVEI	T1,770000	;NO, USE IDDT
>
	EXCH	T1,0(P)		;SWAP WITH CONTENTS OF T1
	POPJ	P,		;GO TO DDT

%DDT1:	ASCIZ	\
DDT:	Called from	\

%DDT2:	ASCIZ	\
\
>
SUBTTL	TTY OUTPUT LINE BUFFERING SUBROUTINE


;ROUTINE TO LOG A CHARACTER TO THE USER'S TERMINAL. USES A LINE BUFFER
;FOR SPEED. TTYIT IS THE ENTRY POINT. SAVES T1.

TTYDMP:	PUSHJ	P,TTYOUT	;[1124] OUTPUT LINE
TTYIT:	SOSGE	TTYBUF+2	;ANY SPACE LEFT
	JRST	TTYDMP		;NO, FORCE OUTPUT
	IDPB	T1,TTYBUF+1	;DEPOSIT IN LINE BUFFER
	CAIG	T1,.CHFFD	;SEE IF END-OF-LINE CHAR
	CAIGE	T1,.CHLFD
	SKIPA			;[1124] NO--JUST RETURN
	PUSHJ	P,TTYOUT	;[1124] YES--DUMP THE LINE FIRST
IFE FTSINGLE,<
TTYRET:	PUSH	P,T1		;[1124] SAVE CHAR IN T1
	MOVE	T1,SEGPGN	;[1124] GET SEGMENT ORIGIN
	ADDI	T1,%%RET	;[1124] POINT TO WHERE WE WANT TO GO
	EXCH	T1,0(P)		;[1124] SAVE GOTO ADDR, RESTORE T1
>
	POPJ	P,		;[1124] RETURN

;LOCAL ROUTINE TO DUMP THE TERMINAL BUFFER WHEN FULL OR END-OF-LINE
;CHARACTER IS SEEN. SAVES T1.

TTYOUT:	PUSH	P,T1		;[1124] SAVE PENDING CHAR
	SETZ	T1,
	IDPB	T1,TTYBUF+1	;END WITH NULL
	OUTSTR	LINBUF		;OUTPUT LINE
	MOVEI	T1,LN.CPL	;RESET
	MOVEM	T1,TTYBUF+2	;CCHAR COUNT
	SKIPA	T1,.+1
	POINT	7,LINBUF
	MOVEM	T1,TTYBUF+1	;AND BYTE PTR
	POP	P,T1		;[1124] RESTORE PENDING CHAR
	POPJ	P,		;[1124] RETURN
SUBTTL	LOG FILE OUTPUT SUBROUTINE


LOGIT:	SOSGE	RCBUF+2		;ANY SPACE LEFT
	JRST	LOGDMP		;NO
	IDPB	T1,RCBUF+1	;YES
IFE FTSINGLE,<
	JRST	TTYRET		;INCASE EXECUTE ONLY
>
IFN FTSINGLE,<
	POPJ	P,
>

LOGDMP:	OUT	RC,		;OUTPUT THIS BUFFER
	  JRST	LOGIT		;NO ERRORS
	MOVSI	T1,(POINT 0)	;NULL BYTE POINTER
	HLLM	T1,RCBUF+1	;INCASE CALLED AGAIN
	HRLOM	T1,RCBUF+2	;VERY LARGE WORD COUNT
	RELEASE	RC,		;SAVE WHAT WE HAVE
E01OEL::.OERR.	.EROEL		;[1174] LNKOEL
IFE FTSINGLE,<
	JRST	TTYRET
>
IFN FTSINGLE,<
	POPJ	P,
>

.EROEL:	.ASCIZ	<%LNKOEL	Output error on log file, file closed, load continuing
>


IFE FTSINGLE,<
HIEND==.-1
	DEPHASE


IFL LN.PLC-<HIEND-HICODE>,<
	PRINTX	?PHASED LOWSEG AREA TOO SMALL, INCREASE LN.PLC IN LNKPAR
			>
>;END IFE FTSINGLE
SUBTTL	HIGH SEGMENT PART OF RESTART CODE


;HERE TO RESTART SINGLE SEGMENT VERSION OR WHEN RESTARTING
;MULTI-SEG VERSION AND RIGHT SEGMENT IS STILL IN CORE

IFN FTSINGLE,<
START::
>
START1:
	MOVEI	T1,EZCOR	;GET RID OF JUNK IN LOW SEG
	CORE	T1,		;EASY WAY
	  JFCL			;CANNOT FAIL
	SKIPA	T1,.+1
	%LOW,,%LOW+1
	SETZM	%LOW		;CLEAR LOW SEG DATA
	BLT	T1,@.JBREL
	MOVEI	T1,LINK		;GET ORIGINAL START ADDRESS
	HRRM	T1,.JBSA	;RESET IT
	JRST	(T1)		;AND START AGAIN
SUBTTL	THE END


INILIT:	END	LINK
