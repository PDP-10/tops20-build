TITLE	LNKLOG - LOG/ERROR MODULE FOR LINK
SUBTTL	D.M.NIXON/DMN/JLd/JNG/DZN/PY/PAH/JBS/HD/RJF 5-Feb-88


;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1973,1986,1988.
; ALL RIGHTS RESERVED.
;
;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
;ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
;INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
;COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
;OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
;TRANSFERRED.
;
;
;THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
;AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
;CORPORATION.
;
;DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
;SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.


SEARCH	LNKPAR,LNKLOW,OVRPAR,MACTEN,UUOSYM,SCNMAC
IFN TOPS20,<SEARCH MONSYM>	;[2257]
SALL

ENTRY	LNKLOG
EXTERN	.TYOCH,LNKSCN,LNKERR


CUSTVR==0		;CUSTOMER VERSION
DECVER==6		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==2417		;DEC EDIT VERSION


SEGMENT
SUBTTL	REVISION HISTORY


;START OF VERSION 1A
;64	MAKE LNK999 BE USEFUL
;71	MAKE CONTINUE MESSAGE STANDARD FORM
;103	SAVE BOTH HALVES OF FL ON EDITED LOOKUP ERROR

;START OF VERSION 2
;135	ADD OVERLAY CAPABILITY
;146	(12860) MAKE S%E ENTER ERRORS FATAL (S%F)

;START OF VERSION 2B
;277	Don't clobber stack contents on editable error
;420	Always output a "[" when expected to.
;434	Don't clear OFFSET and OSCANF when doing an edit.

;START OF VERSION 2C
;464	Make .TEBLK internal for LNKLOG.
;473	Delete all .TMP files before exiting on a fatal error.
;557	Clean up the listing for release.

;START OF VERSION 3A
;560	Release on both TOPS-10 and TOPS-20 as LINK version 3A(560)

;START OF VERSION 4
;564	Make LINK assemble with MACRO 52.
;605	Use OUTSTR's to TTY whenever possible.
;625	Support .EB (Print blank line in log)
;634	Never delete input file on a fatal error.
;637	Always print the continuation error message in batch jobs.
;650	Use VM on TOPS-10 if available.
;657	Setup IO.EMG before deleting temp files on an error.
;731	SEARCH MACTEN,UUOSYM
;765	Release on both TOPS-10 and TOPS-20 as LINK version 4(765)

;START OF VERSION 4A.
;1144	Support .EN (no message specified with .ETC.).
;1174	Label and clean up all error messages. Remove most of edit 1144. Support
;	.ETC. codes RTN, NLN, XCT, BKL, DAT and NOP. Support S%C. Clean  up  the
;	listing.
;1202	Make S%E severity on code I messages work after edit 1174.
;1212	Make indexed LRE messages 7 and 10 consistent with others, fix missing
;	space in LRE messages.
;1217	Clean up the listings for release.
;1220	Release on both TOPS-10 and TOPS-20 as version 4A(1220).
;START OF VERSION 4B.
;1301	Use bits for verbosity, Don't always print prefix or tabs.
;1311	Fix problem with edit 1301.
;1331	Fix BKL to check more carefully for log file.
;START OF VERSION 5
;1400	Use OVRPAR.MAC.

;Start of Version 5.1

;1535	Invoke LNKMAP after fatal error if /MAP:ERR seen.
;2005	Get severity and level from stack if S%D used in MS.
;2026	Update copyright and cleanup listings for release.

;Start of Version 6
;2216	Type long symbols correctly.
;2257	Add generic JSYS error subroutine.
;2300	Don't get ERSTR definition from MONSYM.
;2301	Type TOPS-20 native errors and filespecs.
;2304	Change label name in JSERR.
;2323	Type case-sensitive symbols.
;2325	Add to and fix up TOPS-20 editible message table.
;2330	Put TOPS-20 editable messages in a TOPS-20 conditional.
;2351	Fix E$$UMF routine to print JSYS names.
;2403	New corporate Copywrite statement.
;2417	Update Copywrite statement to 1988.
SUBTTL	DISPATCH TABLES FOR MESSAGE CLASSES

;DISPATCH TABLE FOR MAIN MESSAGE TYPE.  THE MESSAGE TYPE IS SPECIFIED IN THE
;FIRST ARGUMENT TO THE .ERR. MACRO.

DEFINE	XXX(TYPE)<
	EXP	ER.'TYPE
>

	XALL
TYPTAB:	ERRTYPE


;DISPATCH  TABLE  FOR  CONTINUATION  MESSAGE  TYPE.  THE  CONTINUATION  TYPE  IS
;SPECIFIED IN THE FIRST ARGUMENT TO THE .ETC. MACRO.

DEFINE	XXX(TYPE)<
  ..CTRL==1				;;[1217] ASSUME CONTROL ONLY
  IFDIF <TYPE><JMP>,<IFDIF <TYPE><RTN>,<..CTRL==0>> ;;[1217] COMPILE WITH MACRO 53(1020)
  IFN ..CTRL,<
	XWD	1B18,ER'TYPE	;FLOW OF CONTROL ONLY
  >
  IFE ..CTRL,<
	EXP	ER'TYPE		;PRINT TEXT
  >
>

ER.TAB:	ETCTYPE
ERLEN==.-ER.TAB
	SALL
IF1,<PURGE ERSTR>		;[2300] So value does not come from MONSYM

SUBTTL	ENTRY FROM ERRUUO AND MESSAGE DISPATCH


IFN FTSINGLE,<
%%UUO::	PORTAL	LNKLOG		;ENTRY FROM UUO
>

LNKLOG:	MOVEM	P1,SAVEAC+P1	;SAVE P1
	MOVE	P1,[T2,,SAVEAC+T2]
	BLT	P1,SAVEAC+T4	;AND REST OF ACCS
	MOVE	P1,@UUOTRAP	;GET FIRST ERROR ARG
	JUMPGE	P1,@TYPTAB(T1)	;GO TO REQUIRED FUNCTION
	MOVE	P1,@P1		;GET A VALID ARG
	JUMPL	P1,.-1		;EVENTUALLY
	JRST	@TYPTAB(T1)	;[1174] ROUTINES RETURN TO ERRFIN BELOW

ERRFIN:	SKIPGE	PRTMSG		;[1174] DID WE PRINT ANYTHING AT ALL?
	JRST	ERRET		;[1174] NO--NO LINE TO FINISH OFF THEN
	MOVE	T1,VERLVL	;[1174] DID USER REQUEST LONG MESSAGE?
	TXNN	T1,M%C		;[1301] OR CONTINUATION PART OF MESSAGE?
	JRST	ERRFN0		;NO
	LDB	T1,VERPTR	;GET VERBOSITY LEVEL POSSIBLE
	CAIL	T1,V%L		;POSSIBLE TO HAVE MORE
	JRST	LNKERR##	;GO TO LONG ERROR MODULE
ER.FIN::			;RETURN HERE, IN OTHER SEGMENT
ERRFN0:	LDB	T2,SEVPTR	;GET SEVERITY
	CAMGE	T2,SEVLVL	;[1174] SUPPRESS ] IF MESSAGE FORCED TO FATAL
	CAIL	T2,S%W		;WAS IT
	JRST	ERRFN2		;NO, DID NOT TYPE MESSAGE
	PUSHJ	P,TTYOUT	;[1301] MESSAGE TYPED ON TTY?
	PUSHJ	P,ERRFN1	;[1301] YES, TYPE "]"
ERRFN2:	OUTVIA	.TCRLF##	;[1301] END WITH CR-LF
	JRST	ERRET		;[1301]

ERRFN1:	MOVEI	T1," "		;[1301] GET THE SPACE
	SKIPL	TABCHR		;[1301] SPACE INSERTED AFTER "["
	PUSHJ	P,.TCHAR##	;[1301] YES, PUT SPACE BEFORE "]"
	MOVEI	T1,"]"		;[1301] INFO ENDS WITH "]"
	PJRST	.TCHAR##	;[1301] OUTPUT THE BRACKET

;  ..
;  ..

;HERE WHEN THE MESSAGE HAS BEEN TYPED. SHOULD WE CONTINUE?

ERRET:	LDB	T1,SEVPTR	;GET ERROR SEVERITY
	CAML	T1,SEVLVL	;OK TO CONTINUE?
	CAXN	T1,S%C		;[1174]   ..
	  SKIPA			;[1174] YES--RETURN TO CALLER
	JRST	ERXIT		;[1174] NO--GO EXIT
	HRRZS	LOGSUB		;CLEAR FLAG
	CAIN	T1,S%E		;[1174] DO WE NEED TO EDIT THIS ERROR FIRST
	JRST	EDITER		;YES, FATAL  IF WE DON'T
	MOVE	P1,SAVEAC+P1	;RESTORE P1
	SKIPG	T1,LOGTTY	;NEED TO RESTORE LOG SUB?
	JRST	RPOPJ1		;NO
	PUSHJ	P,.TYOCH	;YES,
	SETZM	LOGTTY		;[605] BACK TO 0
RPOPJ1:	AOS	UUOTRAP
RPOPJ:	JRST	.RPOPJ##	;RETUTN TO CPOPJ


;HERE TO "EDIT" THE ERRONEOUS FILE SPECIFICATION.  THIS OCCURS WHEN A MESSAGE OF
;SEVERITY S%E IS PRINTED UNDER TIMESHARING. STORE THE STILL PENDING LIST OF SCAN
;BLOCKS IN F.EDIT, AND RETURN TO THE LNKSCN FOR THE CORRECTION LINE.

EDITER:	MOVEI	T2,1		;GET A WORD TO HOLD FL
	PUSHJ	P,DY.GET##
	MOVEM	FL,(T1)		;SO WE CAN RESTORE LATER
	HRL	T1,F.INZR	;GET THIS FILE SPEC
	MOVSM	T1,F.EDIT	;STORE IT
	SETZM	F.INZR		;CLEAR ALL TRACES
	SETZM	F.NXZR		;SO SCAN THINKS ITS A NEW LINE
	HRROI	T1,EDTMES	;[1301] GET THE PREFIX WITH TAB
	SKIPL	TABCHR		;[1301] /MESSAGE:NOPREF?
	HRROI	T1,EDTMS1	;[1301] YES, GET PREFIX WITHOUT TAB
	.XERR.			;[1301] WARN USER WHAT TO EXPECT
	JRST	LNKSCN		;NO
	PUSHJ	P,.TYOCH	;YES,
	SETZM	LOGTTY		;[605] BACK TO 0
	JRST	LNKSCN		;SCAN NEW LINE

EDTMES:	.ASCIZ	<[	Please retype the incorrect parts of the file specification]
>
EDTMS1:	.ASCIZ	<[ Please retype the incorrect parts of the file specification ]
>				;[1301]
;HERE WHEN LOG FILE GETS ERROR
;FINISH ORIGINAL MESSAGE THEN OUTPUT LOG ERROR MESSAGE

REPEAT 0,<			;NOT YET WORKING
ERRLOG:	POP	P,T1		;GET RETURN OFF STACK
	PUSH	P,UUOTRAP	;SAVE REAL RETURN ADDRESS
	PUSH	P,T1		;STACK RETURN
	MOVEI	T1,E$$OEL-1	;[1174] FAKE RETURN
	HRRM	T1,UUOTRAP	;SO WE CAN TYPE 2ND MESSAGE
	POPJ	P,		;IF NOTHING MORE IMPORTANT OCCURS

E$$OEL::PUSH	P,[RC]		;CHANNNEL #
	.ERR.	(ST,0,V%L,L%W,S%W,OEL,<Output error on log file, file closed, load continuing>)
	POP	P,T1		;GET ORIGINAL RETURN
	JRSTF	@T1		;RETURN
>;END OF REPEAT 0
SUBTTL	FATAL ERROR FINAL CLEAN-UP AND EXIT


;HERE IF FATAL NON-CONTINUABLE (E.G., NOT EDITABLE) ERROR OCCURS, AFTER PRINTING
;THE MESSAGE.  CLOSE THE LOG FILE AND DELETE ALL OF LINK'S .TMP FILES.  IF WE'RE
;UNDER  BATCH, FORCE OUT THE LONG MESSAGE IF APPLICABLE.  OTHERWISE, MERELY GIVE
;THE USER A HINT THAT THE LONG MESSAGE MAY BE TYPED IF DESIRED.

ERXIT:
	MOVE	T1,MAPSW	;[1535] /MAP:ERROR?
	CAIN	T1,$MAPER	;[1535] IF SO DO IT NOW
	PUSHJ	P,LNKMAP##	;[1535]
	MOVEI	T1,FINMES	;TELL USER WE CLOSED FILE
	SKIPE	LOGSUB		;BUT ONLY ON LOG FILE
	PUSHJ	P,.TSTRG##
	RELEASE	RC,		;CLOSE LOG FILE
	RELEASE	DC,		;[634] CLOSE REL FILE (DON'T DELETE)
	PUSH	P,P1		;SAVE A PERM AC
	MOVSI	P1,-20		;SETUP TO SCAN ALL CHANNELS
ERXIT1:	HRRZ	T1,P1		;GET THIS CHANNEL NUMBER
	DEVCHR	T1,		;FIND OUT ABOUT THE ASSOCIATED DEV
	JUMPE	T1,ERXIT2	;FORGET IT IF NONE
	MOVE	T1,IO.PTR(P1)	;SOMETHING THERE, GET IO BLOCK
	HRRZM	T1,IO.EMG	;[657] USE SAME BLOCK IN DVDEL.
	HLRZ	T1,I.EXT(T1)	;GET THE FILE EXTENSION
	CAIE	T1,'TMP'	;ONLY DELETE .TMP FILES
	JRST	ERXIT2		;NOT USER'S INPUT REL FILE ETC.
	HRRZ	T1,P1		;GOT ONE! GET I/O CHANNEL
	PUSHJ	P,DVDEL.##	;DELETE IT
	  JFCL			;IGNORE FAILURE
ERXIT2:	AOBJN	P1,ERXIT1	;LOOP OVER ALL CHANNELS
	POP	P,P1		;RESTORE PERM AC
	MOVEI	T1,M%C		;[1301] GET CONTINUATION BIT
	LDB	T2,VERPTR	;AND POSSIBLE MESSAGE VERBOSITY
	TDNN	T1,VERLVL	;[1301] NOT WANT LONG MESSAGES?
	CAIGE	T2,V%L		;OR NOTHING MORE
	EXIT
	MOVEM	T1,VERLVL	;FAKE /VER:LONG
	SETZM	LOGSUB		;FORGET LOG DEVICE
	SETZM	LOGTTY
	MOVE	T1,HIORGN	;[650] SEE WHO CALLED
	HRRZ	T1,.JBHNM(T1)	;[650]
	CAIN	T1,'999'	;[650] SOME FLAVOR OF XXX999?
	EXIT			;GIVE UP, GETSEG WILL FAIL ETC.
	MOVE	T1,TTYSUB	;MAKE SURE WE POINT TO TTY
	PUSHJ	P,.TYOCH##
	CLRBFI			;[637] CLEAR JUNK
	SKIPE	BATCH		;[637] CAN USER TYPE CONTINUE?
	JRST	LNKERR##	;[637] NO, GIVE HIM THE MESSAGE FOR FREE
	HRROI	T1,[ASCIZ	\[	Type CONTINUE for more information]\] ;[1311]
	SKIPL	TABCHR		;[1311] WITH TAB OR WITHOUT?
	HRROI	T1,[ASCIZ	\[ Type CONTINUE for more information ]\] ;[1311]
	.XERR.			;[1311] OUTPUT MESSAGE
	EXIT	1,		;MONRET
	JRST	LNKERR##	;SO CONTINUE WILL GET REST OF TEXT

FINMES:	.ASCIZ	<	[End of log file]
>
SUBTTL	MAIN ERROR MESSAGE SUBROUTINES


;ENTRY POINT FOR ASCII STRING
;CALLED BY
;	ERRUUO	ER%MS
;	ARGS

ER.MS:	SETOM	ERCHAN		;[1202] SIGNAL NO CHANNEL INVOLVED
	LDB	T1,SEVPTR	;[2005] GET THE SEVERITY
	JUMPN	T1,ER.MS1	;[2005] IT HAS ONE
	POP	P,T1		;[2005] IT'S ON THE STACK (S%D)
	DPB	T1,SEVPTR	;[2005] PUT IT IN AS THE SEVERITY
	CAIN	T1,S%C		;[2005] IS IT FATAL BUT CONTINUE?
	 MOVEI	T1,L%F		;[2005] YES, TYPE AS FATAL
	DPB	T1,LVLPTR	;[2005] STORE THE LEVEL
ER.MS1:	PUSHJ	P,CHKLVL	;[2005] OUTPUT %,? OR TIME STAMP ETC
	  JRST	ERRNXT		;[1174] NOTHING TO OUTPUT
	HRRZ	T1,P1		;ADDRESS OF MESSAGE STRING
	OUTVIA	.TSTRG##	;OUTPUT MESSAGE
	JRST	ERRNXT		;[1174] GO PROCESS .ETC. WORDS


;HERE FOR LOOKUP/ENTER/RENAME ERROR

;CALLED BY
;	PUSH	P,[CHAN#]
;	ERRUUO	ER%LRE
;	ARGS

ER.LRE:	POP	P,ERCHAN	;[1174] RESCUE CHANNEL FROM STACK
	MOVE	T4,ERCHAN	;[1174] GET CHANNEL
	MOVE	T2,IO.PTR(T4)	;GET I/O BLOCK
	HRRE	T2,I.EXT(T2)	;GET ERROR CODE
IFN TOPS20,<
	CAME	T2,[-1]		;[2301] MINUS ONE IS SPECIAL
	JUMPL	T2,ERLREN	;[2301] ALL OTHER NEGATIVE IS TOPS-20 STYLE
>;[2301] IFN TOPS20
	TXNE	P1,F%SEV	;[2301] DO WE HAVE SEVERITY?
	JRST	ERLRE2		;[2301] YES
	CAILE	T2,LRELEN	;IN RANGE?
	MOVEI	T2,LRELEN	;NO, USE DEFAULT VALUE
	HLRZ	T3,LRETAB(T2)	;PICKUP LVL FOR THIS MESSAGE
	TLNE	T4,(%ENT)	;ENTER HAS SPECIAL MESSAGES
	SKIPLE	T2		;CHANGE IF 0 OR -1
	CAIA			;NOT SPECIAL
	HLRZ	T3,ENTAB(T2)	;GET RIGHT MESSAGE
	DPB	T3,SLPTR	;[1144] STORE SEVERITY AND LEVEL
	LDB	T3,SEVPTR	;GET SEVERITY
	TXNE	T4,%ENT		;IF ENTER UUO
	CAIE	T3,S%E		;AND MARKED AS EDITABLE
	JRST	ERLRE2		;NO
	TXO	P1,F%SEV	;[1144] MARK AS FATAL
IFN TOPS20,<
	JRST	ERLRE2		;[2301] CONTINUE

;[2301] Here if TOPS-20 style error.  If input file, check the
;[2301] table of editable TOPS-20 messages.  Get the JSYS text
;[2301] for later printout.
	
ERLREN:	TXO	P1,F%LVL	;[2301] Always type TOPS-20 messages
	TXNE	P1,F%SEV	;[2301] DO WE HAVE SEVERITY?
	JRST	ERLREJ		;[2301] YES
	TXNE	T4,%ENT		;[2301] Output file?
	 JRST	ERLREF		;[2301] Yes, it's fatal
	HRRZS	T2		;[2301] Want RH only
	HRLZI	T3,T20SIZ	;[2301] Minus count of editable errors
ERLRE1:	CAMN	T2,T20TAB(T3)	;[2301] Is this editable?
	 JRST	ERLREE		;[2301] Yes, set it as such
	AOBJN	T3,ERLRE1	;[2301] No, do them all
ERLREF:	TXO	P1,F%SEV	;[2301] Mark it as fatal
	JRST	ERLREJ		;[2301] Continue
ERLREE:	MOVX	T3,S%E		;[2301]	Get severity as editable
	DPB	T3,SEVPTR	;[2301] And set it
ERLREJ:	HRROI	T1,ERRJSY	;[2301] Point to buffer
	HRLI	T2,.FHSLF	;[2301] This process
	HRLZI	T3,-ERRLEN	;[2301] Length of buffer
	ERSTR%			;[2301] Get text for the error
	 ERJMP	E$$UIE		;[2304] Catch errors within an error
	 PJRST	E$$UIE		;[2304] Error if string too long
>;[2301] IFN TOPS20		;[2301]

ERLRE2:	PUSHJ	P,CHKLVL	;[1202] OUTPUT TIME ETC
	  JRST	ERRNXT		;[1174] NOTHING TO DO
	HRRZ	T1,P1		;ADDRESS OF MESSAGE
	OUTVIA	.TSTRG##	;OUTPUT ON TTY AND/OR LOG
	OUTVIA	.TSPAC##	;[1212] PRINT SPACE BETWEEN FAILURE AND REASON
	MOVE	T4,ERCHAN	;[1202] RESTORE CHAN PLUS FLAGS
IFE FTSINGLE,<
	JUMPE	T4,ERGSEG	;GETSEG ERROR IF CHAN# 0
>

;NOW TYPE APPROPRIATE MESSAGE FOR ERROR CODE

	HRR	P1,IO.PTR(T4)	;GET POINTER TO I/O BLOCK
	HRRE	T2,I.EXT(P1)	;GET ERROR CODE
IFN TOPS20,<
	CAME	T2,[-1]		;[2301] MINUS ONE IS SPECIAL
	JUMPL	T2,ERFNOS	;[2301] ALL OTHER NEGATIVE IS TOPS-20 STYLE
>;[2301] IFN TOPS20
	CAILE	T2,LRELEN	;DO WE KNOW ABOUT IT?
	PUSHJ	P,ERLDEF	;NO SETUP DEFAULT
	SKIPGE	T1,T2		;BUT IF NEGATIVE
	ANDI	T1,<BYTE (7) 0,0,0,177,177 (1) 1>
	IORM	T1,ERRCOD	;STORE TABLE INDEX
	HRRZ	T1,LRETAB(T2)	;GET MESSAGE
	TLNE	T4,(%ENT)	;SPECIAL IF ENTER
	SKIPLE	T2		;AND 0 OR -1
	CAIA
	HRRZ	T1,ENTAB(T2)	;GET RIGHT MESSAGE
	OUTVIA	.TSTRG##	;OUTPUT IT
ERFNOS:	HRRZ	T1,P1		;[2301] POINT TO SCAN BLOCK
ERFSPC:	OUTVIA	.TEBLK		;OUTPUT LOOKUP BLOCK
IFN TOPS20,<			;[2301]
	MOVE	T2,IO.CHN	;[2301] Get back the channel
	SKIPN	T1,CHAN.JF(T2)	;[2301] Get the JFN
	JRST	ERRNXT		;[2301] No JFN
	SETZM	CHAN.JF(T2)	;[2301] Zero it
	RLJFN%			;[2301] Return the JFN
	ERNAM	(RLJFN%)	;[2301] Should not fail
>;[2301] IFN TOPS20
	JRST	ERRNXT		;[2301] See if more to do
IFE FTSINGLE,<
ERGSEG:	HRRZ	T2,SEGBLK+2	;GET ERROR CODE
	CAILE	T2,LRELEN	;RANGE CHECK
	PUSHJ	P,ERLDEF	;NO SETUP DEFAULT
	HRRZ	T1,LRETAB(T2)	;GET MESSAGE
	OUTVIA	.TSTRG##
	HRRZI	T1,SEGBLK	;POINT TO GETSEG BLOCK
	OUTVIA	.TSBLK		;OUTPUT SEGMENT BLOCK
	JRST	ERRFIN
>;END IFE FTSINGLE

ERLDEF:	PUSH	P,T2		;SAVE ERROR CODE
	MOVEI	T1,"("
	OUTVIA	.TCHAR##
	POP	P,T1
	OUTVIA	.TOCTW
	MOVEI	T2,LRELEN	;USE DEFAULT
	POPJ	P,
;INIT/OPEN ERROR
;CALLED BY
;	PUSH	P,[CHAN#]
;	ERRUUO	ER%I
;	ARGS

ER.I:	POP	P,ERCHAN	;[1174] RESCUE CHANNEL FROM STACK
	PUSHJ	P,CHKLVL	;OUTPUT % OR ?
	  JRST	ERRNXT		;[1174] NOTHING TO DO
	HRRZ	T1,P1		;GET MESSAGE
	OUTVIA	.TSTRG##
	MOVE	T4,ERCHAN	;[1202] GET CHANNEL
	HRRZ	T4,IO.PTR(T4)	;GET IO POINTER
	MOVE	T1,I.DEV(T4)
	SETZM	I.DEV(T4)	;DELETE IT INCASE TRYING TO RECOVER
	OUTVIA	.TSIXN##	;DEVICE
	OUTVIA	.TCOLN##
	JRST	ERRFIN		;RETURN OR EXIT
;STATUS CHECK ERRORS
;CALLED BY
;	PUSH	P,[CHAN#]
;	ERRUUO	ER%ST
;	ARGS

ER.ST:	POP	P,ERCHAN	;[1174] RESCUE CHANNEL FROM STACK
	PUSHJ	P,CHKLVL	;OUTPUT % OR ?
	  PJRST	ERRNXT		;[1174] NOTHING TO DO
	HRRZ	T1,P1		;GET MESSAGE
	OUTVIA	.TSTRG##
	MOVX	T1," "		;[1144] SEPARATE MESSAGE FROM REST
	OUTVIA	.TCHAR##	;[1144]   ..
	MOVEI	T1,[ASCIZ \Status \] ;[1144]
	OUTVIA	.TSTRG##
	HRLZ	T1,ERCHAN	;[1174] GET CHANNEL FOR GETSTS
	LSH	T1,5		;PUT IN AC FIELD
	IOR	T1,[GETSTS T1]	;FORM INST
	XCT	T1		;DO IT
	HRRZ	T1,T1
	OUTVIA	.TOEP##		;(XXXXXX)
	MOVEI	T1,[ASCIZ \ for file \] ;[1144]
	OUTVIA	.TSTRG##
	MOVE	T4,ERCHAN	;[1202] GET CHANNEL NUMBER
	HRRZ	T1,IO.PTR(T4)	;GET IO POINTER
	JRST	ERFSPC		;REST OF FILE SPEC
SUBTTL	CONTINUATION OF FIRST LINE DISPATCH


;HERE AFTER PROCESSING AN .ETC. FUNCTION.  IF THERE ARE NO MORE LEFT, RETURN VIA
;ERRFIN.  OTHERWISE, PROCESS THE NEXT .ETC. FUNCTION ONLY IF THE FIRST  LINE  OF
;THE MESSAGE SHOULD BE PRINTED OR IF THE .ETC. REPRESENTS FLOW-OF-CONTROL RATHER
;THAN TEXT.

ERRNXT:	TXNN	P1,.EC		;MORE TO DO?
	JRST	ERRFIN		;NO, END LINE
	LDB	T1,VSPTR	;[1144] GET VERBOSITY AND SEVERITY
	AOS	UUOTRAP		;ADVANCE RETURN POINTER
	MOVE	P1,@UUOTRAP	;GET ADDRESS OF OUTPUT INFO
	DPB	T1,VSPTR	;[1144] STORE VERBOSITY AND SEVERITY AGAIN
	SKIPLE	PRTMSG		;[1174] ARE WE SUPPOSED TO PRINT FIRST LINE?
	JRST	ERRNX1		;[1174] YES--GO STRAIGHT TO IT
	LDB	T1,LVLPTR	;[1174] NO--ONLY PROCESS CONTROL .ETC. WORDS
	SKIPL	ER.TAB(T1)	;[1174] ONE THAT PRINTS TEXT?
	JRST	ERRNXT		;[1174] NO--IGNORE IT AND GET NEXT
ERRNX1:	HRRZ	T1,P1		;[1174] GET VALUE
	TXNN	P1,.EP		;ONLY A POINTER?
	JRST	.+4		;NO, ALL SET
	CAIG	T1,P1		;IS IT ONE OF THE SAVED ONES?
	SKIPA	T1,SAVEAC(T1)	;YES, GET FROM SAVED SET
	MOVE	T1,(T1)		;NO, GET REAL VALUE
	LDB	T2,LVLPTR	;[1174] GET .ETC. TYPE CODE
	JRST	@ER.TAB(T2)	;DO CORRECT FUNCTION


;PRINT ASCII TEXT IN ASCIZ FORMAT.

ERSTR:	OUTVIA	.TSTRG##
	JRST	ERRNXT		;SEE IF MORE


;PRINT A SIXBIT WORD WITHOUT TRAILING SPACES.

ERSBX:	OUTVIA	.TSYMB		;[2216] Output potentially long symbol
	JRST	ERRNXT


;PRINT AN OCTAL FULL WORD WITHOUT LEADING ZEROS.

EROCT:	OUTVIA	.TOCTW##
	JRST	ERRNXT
;PRINT A SIGNED DECIMAL VALUE.

ERDEC:	OUTVIA	.TDECW##
	JRST	ERRNXT


;PRINT A FILE SPECIFICATION. THE ARGUMENT IS LINK'S INTERNAL CHANNEL NUMBER.

ERFSP:	HRR	P1,IO.PTR(P1)	;GET ADDRESS
	HRRZ	T1,P1		;PTR IN T1
	OUTVIA	.TEBLK
	JRST	ERRNXT


;PRINT A SINGLE ASCII CHARACTER.

ERASC:	OUTVIA	.TCHAR##
	JRST	ERRNXT


;MEMORY SIZE ARGUMENT. PRINT MEMORY SIZE IN K FOR KA'S, PAGES FOR ALL OTHERS.

ERCOR:	ADD.	T1,.PGSIZ	;[1174] ROUND UP TO MONITOR'S PAGE SIZE
	ANDCM.	T1,.PGSIZ	;[1174]   ..
	OUTVIA	.TCORW##	;[1174] .TOUTS HAS THE SMARTS
	JRST	ERRNXT		;[1174] DONE


;JUMP TO A CONTINUATION LIST OF .ETC. MACROS. CONTROL RETURNS FROM LNKLOG TO THE
;INSTRUCTIONS AFTER THE CONTINUATION LIST, NOT THE OLD LIST.  WE ALSO  SAVE  THE
;ADDRESS OF THE CURRENT .ETC. WORD SO RTN BELOW CAN USE IT.

ERJMP:	HRRZ	T2,UUOTRAP	;[1174] GET ADDRESS OF CURRENT .ETC.
	MOVEM	T2,RTNPC	;[1174] SAVE IN CASE RTN NEEDS IT
	SUBI	T1,1		;[1174] LOOK LIKE WE JUST PROCESSED PREVIOUS WORD
	HRRM	T1,UUOTRAP	;[1174]   ..
	TXO	P1,.EC		;[1174] IMPLIED CONTINUATION FOR JMP'S
	JRST	ERRNXT		;[1174]


;RETURN FROM PREVIOUS JUMP.  NOTE THAT THE .EC FLAG OF THE JUMP THAT GOT US HERE
;CONTROLS  WHETHER  THERE  ARE ANY MORE .ETC. WORDS, NOT THE .EC FLAG OF THE RTN
;FUNCTION.

ERRTN:	ADD	T1,RTNPC	;[1174] FOR CPOPJ1, ETC.
	HRRM	T1,UUOTRAP	;[1174] LOOK LIKE WE JUST PROCESSED LAST JMP
	LDB	T2,VSPTR	;[1174] SAVE ORIGINAL VERBOSITY, SEVERITY
	MOVE	P1,(T1)		;[1174] FINISH LOOKING LIKE THE JMP
	DPB	T2,VSPTR	;[1174] RESTORE ORIGINAL VERBOSITY AND SEVERITY
	JRST	ERRNXT		;[1174] DONE
;PRINT A NEW LINE.  THIS PRINTS A CRLF FOLLOWED BY THE RIGHT INDENTATION FOR THE
;DESTINATION.  FOR A REAL LOG FILE, THIS INCLUDES THE  TIME  STAMP  PLUS  LEVEL,
;SEVERITY AND MESSAGE PREFIX.  FOR A REAL TERMINAL, THIS INCLUDES A TAB FOR NOW,
;BUT SHOULD OPTIONALLY BE 2 SPACES IF LINK EVER LOOKS AT THE JOB'S MESSAGE BITS.

ERNLN:	MOVEI	T1,[ASCIZ /
			/]	;[1174] INDENT PAST TIME STAMP IN LOG FILE
	SKIPE	LOGSUB		;[1174] REAL LOG FILE?
	PUSHJ	P,.TSTRG##	;[1174] YES--PRINT IT TO JUST LOG FILE
	SKIPN	LOGTTY		;[1174] NOW, OUTPUT GOING TO TERMINAL?
	SKIPG	LOGSUB		;[1174]   ..
	  SKIPA			;[1174] YES
	JRST	ERRNXT		;[1174] NO--DONE
	SKIPL	LOGTTY		;[1174] TERMINAL A LOG FILE?
	JRST	ERNLN1		;[1174] NO--DO IT THE HARD WAY
	PUSHJ	P,ERNLN2	;[1301] PRINT CRLF AND INDENTATION
	JRST	ERRNXT		;[1174] DONE

ERNLN1:	MOVE	T1,TTYSUB	;[1174] NEW LINE ON TERMINAL--SET TO JUST TERMINAL
	PUSHJ	P,.TYOCH##	;[1174]   ..
	PUSH	P,T1		;[1174] SAVE LOG FILE ROUTINE
	PUSHJ	P,ERNLN2	;[1301] PRINT CRLF AND INDENTATION
	POP	P,T1		;[1174] RESTORE LOG FILE ROUTINE
	PUSHJ	P,.TYOCH##	;[1174]   ..
	JRST	ERRNXT		;[1174] DONE

ERNLN2:	MOVEI	T1,[ASCIZ /
	/]			;[1301] ASSUME A TAB
	SKIPL	TABCHR		;[1301] PREFIX SUPPRESSED?
	MOVEI	T1,[ASCIZ /
  /]				;[1301] YES, USE 2 SPACES
	PJRST	.TSTRG##	;[1301] SEND NEW LINE AND INDENTATION

;RELATIVE POINTER TO TRIPLET(S) IN LS AREA.

IFN .NWBLK,<
ERLSP:	SUB	T1,LW.LS	;CONVERT TO OFFSET FROM LS.LB
	JUMPL	T1,[HALT]	;ALREADY PAGED OUT
	ADD	T1,LS.LB	;CONVERT TO PHYSICAL ADDRESS
	HRR	P1,T1		;USE RH(P1) AS PHYSICAL POINTER
	MOVE	T1,1(P1)	;GET 1ST 6 CHARS
	OUTVIA	.TSIXN##	;TYPE THEM
	SKIPL	T1,(P1)		;WAS THIS A PRIMARY TRIPLET?
	HALT			;NO, ERROR
	TXNN	T1,PT.EXT	;EXTENDED TRIPLET?
	  JRST	ERRNXT		;NO, FINISHED
ERLSP1:	ADDI	P1,3		;POINT TO NEXT TRIPLET
	SKIPL	T1,(P1)		;SECONDARY?
	TXNE	T1,<-1B17>&<^-S.TTL>	;AND STILL IN NAME TRIPLETS?
	JRST	ERRNXT		;NO, QUIT
	MOVE	T1,1(P1)	;GET 1ST SIX CHARS
	OUTVIA	.TSIXN##	;TYPE THEM
	SKIPN	T1,2(P1)	;ANY MORE?
	JRST	ERRNXT		;NO, QUIT
	OUTVIA	.TSIXN##	;YES, TYPE THEM TOO
	JRST	ERLSP1		;LOOP FOR ALL SECONDARY TRIPLETS
> ;END IFN .NWBLK
;EXECUTE  AN INSTRUCTION.  THIS IS USEFUL WHEN THE SET-UP PERFORMED BY LNKLOG IS
;DESIRED, BUT A COMPLEX MESSAGE IS NEEDED.

ERXCT:	XCT	(T1)		;[1174] EXECUTE THE INSTRUCTION
	  JRST	ERRNXT		;[1174] NON-SKIP--CONTINUE NORMAL FLOW
	AOS	UUOTRAP		;[1174] SKIP--SKIP NEXT .ETC.
	JRST	ERRNXT		;[1174] DONE


;BLANK  LINE IN THE LOG FILE.  THIS IS USEFUL FOR SEPARATING SECTIONS OF THE LOG
;FILE, AS BETWEEN OVERLAY LINKS.

ERBKL:	SKIPN	LOGSUB		;[1331] LOG FILE?
	JRST	ERRNXT		;[1331] NO
	SKIPN	LOGTTY		;[1331] NOT TO TERMINAL?
	PUSHJ	P,.TCRLF##	;[1174] YES--SEND A CRLF
	JRST	ERRNXT		;[1174] DONE


;PRINT TODAY'S DATE.

ERDAT:	OUTVIA	.TDATN##	;[1174] PRINTS TODAY'S DATE
	JRST	ERRNXT		;[1174] DONE


;NO OPERATION. THIS FUNCTION IS GOOD FOR NOTHING.

ERNOP:	JRST	ERRNXT		;[1174] DONE
SUBTTL	USEFUL SUBROUTINES


;CHKLVL  CHECKS  TO  SEE  IF  THE  CURRENT  MESSAGE  SHOULD  GO TO LOG FILE, THE
;TERMINAL, OR BOTH.  IF THE MESSAGE IS DESTINED TO THE LOG FILE, A TIME STAMP IS
;PRINTED,  AND IF THE MESSAGE IS DESTINED FOR THE TERMINAL THEN THE PROPER ERROR
;CHARACTER ("?", "%" OR "[") PLUS THE LNK??? PREFIX IS PRINTED.
;
;CALL:
;	LOGSUB/	NON-ZERO IF REAL NON-CONTROLLING TERMINAL LOG FILE
;	LOGTTY/	-1 IF LOG FILE IS THE CONTROLLING TERMINAL
;SKIP RETURNS IF FIRST LINE MESSAGE SHOULD REALLY BE PRINTED SOMEWHERE, WITH:
;	LOGSUB/	<-1,,NON-ZERO> IF BOTH LOG AND TERMINAL OUTPUT REQUIRED
;	LOGTTY/	<0,,NON-ZERO> IF TERMINAL BUT NOT LOG FILE OUTPUT REQUIRED
;	PRTMSG/	-1: PRINT NOTHING; 0: ONLY PREFIX; 1: PRINT FIRST LINE TEXT
;	P1/	<ADDRESS OF FIRST LINE TEXT>

CHKLVL:	SKIPGE	T1,ERCHAN	;[1202] I/O ERROR?
	JRST	CHKLV1		;[1202] NO--SKIP EDITABLE TEST
	HRRZS	T1		;[1202] CLEAR FLAGS IN LH
	LDB	T2,SEVPTR	;[1202] GET SEVERITY
	CAXN	T2,S%E		;[1202] EDITABLE?
	CAXN	T1,DC		;[1202]   AND NOT INPUT REL FILE CHANNEL?
	JRST	CHKLV1		;[1202] YES--LEAVE EDITABLE
	MOVX	T2,S%F		;[1202] NO--NOT EDITABLE FOR NOW, MAKE FATAL
	DPB	T2,SEVPTR	;[1202] STORE SEVERITY BACK
CHKLV1:	LDB	T1,LVLPTR	;[1202] GET LIST LEVEL
	CAMGE	T1,LOGLVL	;ABOVE CUTOFF?
	JRST	CHKLV2		;NO, TRY TTY ONLY
	SKIPE	LOGTTY		;YES, THEN IS LOG = TTY?
	JRST	[MOVEI T1,1		;[1174] POSITIVE FOR FIRST LINE
		 MOVEM T1,PRTMSG	;[1174]   ..
		 JRST CHKLV4]		;OUTPUT [, % OR ? AND CODE
	SKIPN	LOGSUB		;DO WE REALLY HAVE A LOG DEVICE?
	JRST	CHKLV2		;NO, JUST TRY TTY

;HERE FOR A REAL NON-CONTROLLING TERMINAL LOG FILE.  PRINT THE TIME STAMP IN THE
;LOG FILE ONLY.  THEN SEE IF THE TERMINAL SHOULD SEE THE  MESSAGE  TOO.  IF  SO,
;PRINT THE PREFIX THERE AND CAUSE THE OUTVIA MACRO TO PRINT ALL TEXT TO BOTH.

	MOVEI	T1,1		;[1174] MARK THAT WE SHOULD PRINT THE MESSAGE
	MOVEM	T1,PRTMSG	;[1174]   ..
	PUSHJ	P,TSTAMP	;PUT TIME STAMP ON LOG FILE
	LDB	T1,LVLPTR	;GET LEVEL AGAIN
	CAMGE	T1,ERRLVL	;ABOVE ERROR CUTOFF?
	JRST	CHKLV5		;NO, NOT TO TTY
	MOVE	T1,TTYSUB	;POINT TO TTY LINE BUFFER
	PUSHJ	P,.TYOCH	;SWAP WITH LOG
	PUSH	P,T1		;SAVE IT
	PUSHJ	P,SEVTST	;USE TTY TO OUTPUT [, % OR ?
	POP	P,T1		;GET OUTPUT ROUTINE BACK
	PUSHJ	P,.TYOCH	;AS IT WAS
	HRROS	LOGSUB		;SIGNAL TO BOTH DEVICES
	JRST	CHKLV5		;NOW FOR REST OF MESSAGE
;HERE  WHEN  THERE  IS  NO REAL LOG FILE, OR THE MESSAGE TO IT IS CUT OFF DUE TO
;/LOGLEVEL:.  CHECK FOR TERMINAL OUTPUT.  IF THE MESSAGE SHOULD GO THERE,  CHECK
;FOR THE SPECIAL CASE OF THE TERMINAL BEING THE LOG FILE (TO PREVENT TIME STAMPS
;ON THE TERMINAL) THEN  PRINT  THE  ERROR  CHARACTER  AND  THE  MESSAGE  PREFIX.
;OTHERWISE, GIVE NON-SKIP RETURN SINCE NOTHING SHOULD GET PRINTED. NOTE THAT THE
;PREFIX MUST END WITH A TAB SO THAT MESSAGES WITH IMBEDDED TABS LOOK THE SAME ON
;THE TERMINAL AND IN THE LOG FILE.


CHKLV2:	LDB	T1,LVLPTR	;GET ERROR LEVEL
	CAMGE	T1,ERRLVL	;TO GO TO TTY?
	JRST	[SETOM PRTMSG		;[1174] NO--REMEMBER NOTHING TO DO
		 JRST CHKLV6]		;[1174] GO RETURN
	MOVEI	T1,1		;[1174] YES--THEN REMEMBER SOMETHING TO PRINT
	MOVEM	T1,PRTMSG	;[1174]   ..
	SKIPE	LOGTTY		;LOG = TTY?
	JRST	CHKLV4		;YES, JUST PRINT CODE AND RETURN
	HRRZ	T1,LOWSUB	;[1174] SET FOR TTY OUTPUT ONLY
	PUSHJ	P,.TYOCH	;GET OLD RETURN
	HRRZM	T1,LOGTTY	;STORE OLD RETURN

;HERE WHEN LOG FILE IS THE USER'S TERMINAL.

CHKLV4:	PUSHJ	P,SEVTST	;OUTPUT [, % OR ?

;HERE  TO  PRINT  THE MESSAGE PREFIX TO POTENTIALLY BOTH THE USER'S TERMINAL AND
;THE LOG FILE.

CHKLV5:	MOVE	T1,(P1)		;[1174] GET MESSAGE PREFIX
	MOVEM	T1,ERRCOD	;SAVE IN CASE LONG MESSAGE REQUIRED LATER
	MOVEI	T1,ERRCOD	;[1301] GET THE PREFIX
	PUSHJ	P,LOGOUT	;[1301] PRINTING ON LOG FILE?
	PUSHJ	P,.TSTRG##	;[1301] YES, OUTPUT PREFIX
	MOVE	T1,VERLVL	;[1301] GET THE VERSION LEVEL
	TXNN	T1,M%P		;[1301] PRINT THE PREFIX?
	JRST	CHKLV7		;[1301] NO
	MOVEI	T1,ERRCOD	;[1301] GET THE PREFIX
	PUSHJ	P,TTYOUT	;[1301] PRINTING ON TTY?
	PUSHJ	P,.TSTRG##	;[1301] YES
CHKLV7:	MOVE	T1,VERLVL	;[1301] GET THE VERBOSITY
	TXNN	T1,M%F		;[1301] IS FIRST LINE WANTED?
	JRST	[SETZM PRTMSG	;[1301] NO--NO FIRST LINE MSG
		 JRST CHKLV6]	;[1301] GO RETURN
	MOVX	T1,.CHTAB	;[1301] GET A TAB
	PUSHJ	P,LOGOUT	;[1301] PRINTING TO LOG FILE?
	PUSHJ	P,.TCHAR##	;[1301] YES, OUTPUT TAB
	MOVE	T1,VERLVL	;[1311] GET THE VERBOSITY BACK
	TXNN	T1,M%P		;[1301] PREFIX WANTED?
	SKIPA	T1,[" "]	;[1301] NO, GET A SPACE
	MOVX	T1,.CHTAB	;[1301] YES, GET A TAB
	PUSHJ	P,TTYOUT	;[1301] PRINTING TO TERMINAL?
	PUSHJ	P,.TCHAR##	;[1301] YES, OUTPUT TAB OR SPACE
CHKLV6:	ADDI	P1,1		;[1174] POINT TO BEGINNING OF FIRST LINE TEXT
	SKIPLE	PRTMSG		;[1174] SHOULD FIRST LINE BE PRINTED?
CPOPJ1:	AOS	(P)		;[1174] YES--SKIP RETURN
CPOPJ:	POPJ	P,		;[1174] NO--NON-SKIP RETURN
;SEVTST  PRINTS  THE  PROPER  ERROR  CHARACTER  [, % OR ? BASED ON THE MESSAGE'S
;ASSIGNED SEVERITY AND THE USER'S /SEVERITY: SWITCH.  IF THE MESSAGE  IS  FATAL,
;CLEAR  TYPE-AHEAD  FIRST.  FINALLY, PRINT THE FIRST PART OF THE MESSAGE PREFIX.
;SEVTST ASSUMES THAT IT WILL ONLY PRINT TO THE USER'S TERMINAL.

SEVTST:	LDB	T2,SEVPTR	;GET SEVERITY
	MOVEI	T1,"["		;ASSUME INFO
	CAIL	T2,S%W		;IS IT A WARNING?
	MOVEI	T1,"%"		;YES, OR WORSE
	CAML	T2,SEVLVL	;IS IT FATAL?
	MOVEI	T1,"?"		;YES, 
	SETZM	TABCHR		;[1301] CLEAR TAB CHARACTER FLAG
	CAIN	T1,"["		;IF MORE THAN INFO
	JRST	SEVTS1		;NO
	CLEARO			;CLEAR ^O
SEVTS1:	PUSHJ	P,.TCHAR##	;TYPE CHARACTER
	MOVE	T1,VERLVL	;[1301] GET VERBOSITY FLAGS
	TXNN	T1,M%P		;[1301] PREFIX WANTED?
	POPJ	P,		;[1301] NO
	SETOM	TABCHR		;[1301] YES, SET FLAG NEGATIVE
	MOVEI	T1,[ASCIZ \LNK\]
	PJRST	.TSTRG##
TTYCHK::SKIPL	LOGSUB		;ANY NEED TO DO IT?
	POPJ	P,		;NO
	PUSH	P,T1		;SAVE ENTRY TO .TOUTS
	XCT	@-1(P)		;PUT IN LOG FILE
TTYSET:	MOVE	T1,TTYSUB	;GET TTY LINE BUFFER SUB
	PUSHJ	P,.TYOCH	;INITIALIZE FOR IT
	EXCH	T1,(P)		;SWAP OUT SUB FOR ENTRY PTR
	XCT	@-1(P)		;GO TO .TOUTS
	POP	P,T1		;RESTORE OUTSUB
	AOS	(P)		;SKIP OVER XCT'ED INST
	PJRST	.TYOCH		;RESET AND RETURN
TTYOUT::SKIPE	LOGTTY		;[1301] OUTPUT TO TTY AS LOGFILE?
	POPJ	P,		;[1301] YES, JUST OUTPUT
	SKIPLE	LOGSUB		;[1301] OUTPUT TO TTY?
	JRST	CPOPJ1		;[1301] NO, DON'T OUTPUT
	PUSH	P,T1		;[1301] SAVE ENTRY TO .TOUTS
	JRST	TTYSET		;[1301] OUTPUT TO TERMINAL

LOGOUT::SKIPN	LOGTTY		;[1301] OUTPUT TO TTY AS LOGFILE?
	SKIPN	LOGSUB		;[1301] OR NOT TO LOG FILE?
	JRST	CPOPJ1		;[1301] YES, DON'T OUTPUT AS LOG
	PUSH	P,T1		;[1301] SAVE ENTRY TO .TOUTS
	XCT	@-1(P)		;[1301] OUTPUT TO LOG FILE
	POP	P,T1		;[1301] RESTORE T1	
	JRST	CPOPJ1		;[1301] RETURN

TSTAMP:	PUSHJ	P,.TTIMN##	;STANDARD TIME OUTPUT
	PUSHJ	P,.TSPAC##	;SPACE
	PUSHJ	P,.TSPAC##	;[1174] ANOTHER SPACE
	LDB	T1,LVLPTR	;GET PRINT LEVEL
	MOVEI	T2," "		;FILLER CHAR IF 1 DIGIT
	PUSHJ	P,.TDEC2##	;OUTPUT IT
	PUSHJ	P,.TSPAC##
	PUSHJ	P,.TSPAC##	;[1174] ANOTHER SPACE
	LDB	T1,SEVPTR	;ERR LEVEL
	MOVEI	T2," "
	PUSHJ	P,.TDEC2##
	MOVEI	T1,[ASCIZ /   /];[1174] FINISH WITH 3 SPACES
	PJRST	.TSTRG##	;[1174]   ..
VERPTR:	POINTR	P1,F%VER	;[1144] VERBOSITY LEVEL
SEVPTR:	POINTR	P1,F%SEV	;[1144] SEVERITY LEVEL
LVLPTR:	POINTR	P1,F%LVL	;[1144] OUTPUT MESSAGE LEVEL

VSPTR:	POINTR	P1,<F%VER!F%SEV>;[1144] VERBOSITY AND SEVERITY
SLPTR:	POINTR	P1,<F%SEV!F%LVL>;[1144] SEVERITY AND MESSAGE LEVEL
SUBTTL	EXTENSIONS TO SCAN'S .TOUTS SUBROUTINES


;.TEBLK --TYPE LOOKUP/ENTER/RENAME BLOCK (NOT SAME AS .TFBLK##)
;CALL:	MOVEI	T1,ADDR OF BLOCK
;	PUSHJ	P,.TEBLK
;USES T1-4

.TEBLK::MOVE	T4,T1		;SAVE ARGUMENT
IFN TOPS20,<
	MOVE	T1,I.CHN(T4)	;[2301] GET THE CHANNEL
	LSH	T1,-27		;[2301] AS AN INDEX
	SKIPN	T2,CHAN.JF(T1)	;[2301] IS THERE A JFN?
	 JRST	TEBLK1		;[2301] NO, PRINT IT FROM THE BLOCK
	PUSH	P,T4		;[2301] SAVE THE POINTER IN CASE ERROR
	HRROI	T1,FILBLK	;[2301] POINT TO THE FILE BLOCK
	SETZB	T3,T4		;[2301] WANT DEFAULTS
	JFNS%			;[2301] GET THE FILESPEC
	 ERJMP	TEBLK0		;[2301] DIDN'T WORK
	POP	P,T4		;[2301] FIX UP THE STACK
	MOVEI	T1,FILBLK	;[2301] GET THE BLOCK
	PJRST	.TSTRG##	;[2301] OUTPUT THE BLOCK
TEBLK0:	POP	P,T4		;[2301] RESTORE THE POINTER
TEBLK1:
>;[2301] IFN TOPS20
	MOVE	T1,I.DEV(T4)	;DEVICE
	PUSHJ	P,.TSIXN##
	PUSHJ	P,.TCOLN##
	MOVE	T1,I.NAM(T4)	;NAME
	PUSHJ	P,.TSIXN##
	HLLZ	T1,I.EXT(T4)	;EXTENSION
	MOVE	T2,I.SCN(T4)	;GET MOD WORD
	TXNE	T2,FX.NUL	;TEST FOR NULL EXTENSION (NO DOT)
	JUMPE	T1,TEBLK2	;NO EXT
	TRO	T1,'.'
	ROT	T1,-6		;PUT IN LEADING PLACE
	PUSHJ	P,.TSIXN##
TEBLK2:	MOVEI	T1,I.PPN(T4)	;POINTER TO PPN OR SFD
IFN LN.DRB,<			;ENABLED FOR SFD'S?
	MOVE	T2,(T1)		;GET UFD
	TLNE	T2,-1		;0,,+ IS A PNTR
	PJRST	.TDIRB##	;NO, JUST [PPN]
	MOVE	T1,(T1)		;GET 0,,SFDARG
	ADD	T1,[1,,2]	;POINT TO SFDDIR
>
	PJRST	.TDIRB##	;OUTPUT DIRECTORY
;.TSBLK --TYPE GETSEG BLOCK (NOT SAME AS .TFBLK##)
;CALL:	MOVEI	T1,ADDR OF BLOCK
;	PUSHJ	P,.TSBLK
;USES T1-4

.TSBLK:	MOVE	T4,T1		;SAVE ARGUMENT
	MOVE	T1,0(T4)	;DEVICE
	PUSHJ	P,.TSIXN##
	PUSHJ	P,.TCOLN##
	MOVE	T1,1(T4)	;NAME
	PUSHJ	P,.TSIXN##
	HLLZ	T1,2(T4)	;EXTENSION
	TRO	T1,'.'
	ROT	T1,-6		;PUT IN LEADING PLACE
	PUSHJ	P,.TSIXN##
	MOVEI	T1,4(T4)	;PPN
	PJRST	.TDIRB##	;OUTPUT DIRECTORY

;[2216] .TSYMB --Type potentially long symbol
.TSYMB::PUSH	P,P2		;[2323] Get an upper/lower flag
	SETZ	P2,		;[2323] In upper case mode
	TLNE	T1,770000	;[2216] Long symbol?
	 PJRST	TSYMB1		;[2216] No
	PUSH	P,P1		;[2216] Yes, get a save AC
	HLRZ	P1,T1		;[2216] Get the count
	MOVNS	P1		;[2216] Negate it
	HRLZ	P1,P1		;[2216] Put it in left half
	HRR	P1,T1		;[2216] -Length,,pointer
TSYMBL:	MOVE	T1,(P1)		;[2216] Get the next word
	PUSHJ	P,.TULCS	;[2323] Type it
	AOBJN	P1,TSYMBL	;[2216] Do the entire symbol
	POP	P,P1		;[2216] Done, restore AC
	POP	P,P2		;[2323] Restore the AC used as flag
	POPJ	P,		;[2216] Return

TSYMB1:	PUSHJ	P,.TULCS	;[2323] Type the short symbol
	POP	P,P2		;[2323] Restore the AC
	POPJ	P,		;[2323] Done

;Here to type an upper/lower case sixbit word
.TULCS::MOVE	T2,T1		;[2323] Move argument
TULC1:	JUMPE	T2,CPOPJ	;[2323] Loop until only blanks left
	MOVEI	T1,0		;[2323] Clear next character
	LSHC	T1,6		;[2323] Get next character
	CAIN	T1,'/'		;[2323] Upper case shift?
	 JRST	TULCU		;[2323] Yes
	CAIN	T1,'\'		;[2323] Lower case shift?
	 JRST	TULCL		;[2323] Yes
	ADDI	T1," "-' '	;[2323] Convert to ASCII
	JUMPE	P2,TULC2	;[2323] Don't convert if in upper case mode
	CAIL	T1,"A"		;[2323] Is it below A?
	CAILE	T1,"Z"		;[2323] Or above Z?
	CAIA			;[2323] Not alphabetic, don't convert
	ADDI	T1,"a"-"A"	;[2323] Alphabetic, convert to lower case
TULC2:	PUSHJ	P,.TCHAR##	;[2323] Type it
	JRST	TULC1		;[2323]  ..

TULCL:	SETO	P2,		;[2323] Lower case
	JRST	TULC1		;[2323] Continue

TULCU:	SETZ	P2,		;[2323] Upper case
	JRST	TULC1		;[2323] Continue

SUBTTL	COMMON .ERR. SUBROUTINES


.ERFEE::ASCIZ	\FEE\
	.ASCIZ	<ENTER error>	;[1212]
.ERFLE::ASCIZ	\FLE\
	.ASCIZ	<LOOKUP error>	;[1212]
.ERFRE::ASCIZ	\FRE\
	.ASCIZ	<RENAME error>	;[1212]
.ERGSE::ASCIZ	\GSE\
	.ASCIZ	<GETSEG error>	;[1212]
.ERNED::ASCIZ	\NED\
	.ASCIZ	<Non-existent device >
.EROFD::ASCIZ	\OFD\
	.ASCIZ	<OPEN failure for device >
.EREIF::ASCIZ	\EIF\
	.ASCIZ	<Error for input file >
.ERCNW::ASCIZ	\CNW\
	.ASCIZ	<Code not yet written at >
SUBTTL	DEFERRED SEVERITY AND LEVEL TABLE FOR INDEXED FILE ERRORS


	.ERR.	(,0,V%L,L%F,S%F,,<(2) directory full >)
ENTAB:	.ERR.	(,0,V%L,L%F,S%F,,<(0) Illegal file name >)
LRETAB:	.ERR.	(,0,V%L,L%F,S%E,,<(0) file was not found >)
	.ERR.	(,0,V%L,L%F,S%E,,<(1) no directory for project-programmer number >)
	.ERR.	(,0,V%L,L%F,S%E,,<(2) protection failure >)
	.ERR.	(,0,V%L,L%F,S%E,,<(3) file was being modified >)
	.ERR.	(,0,V%L,L%F,S%E,,<(4) rename file name already exists >)
	.ERR.	(,0,V%L,L%F,S%F,,<(5) illegal sequence of UUOs >)
	.ERR.	(,0,V%L,L%F,S%F,,<(6) bad UFD or bad RIB >)
	.ERR.	(,0,V%L,L%F,S%F,,<(7) not a saved file >)
	.ERR.	(,0,V%L,L%F,S%F,,<(10) not enough memory >)
	.ERR.	(,0,V%L,L%F,S%F,,<(11) device not available >)
	.ERR.	(,0,V%L,L%F,S%F,,<(12) no such device >)
	.ERR.	(,0,V%L,L%F,S%F,,<(13) not two reloc reg. capability >)
	.ERR.	(,0,V%L,L%F,S%E,,<(14) no room or quota exceeded >)
	.ERR.	(,0,V%L,L%F,S%E,,<(15) write lock error >)
	.ERR.	(,0,V%L,L%F,S%F,,<(16) not enough monitor table space >)
	.ERR.	(,0,V%L,L%I,S%I,,<(17) partial allocation only >)
	.ERR.	(,0,V%L,L%F,S%F,,<(20) block not free on allocation >)
	.ERR.	(,0,V%L,L%F,S%F,,<(21) can't supersede (enter) an existing directory >)
	.ERR.	(,0,V%L,L%F,S%F,,<(22) can't delete (rename) a non-empty directory >)
	.ERR.	(,0,V%L,L%F,S%E,,<(23) SFD not found >)
	.ERR.	(,0,V%L,L%F,S%E,,<(24) search list empty >)
	.ERR.	(,0,V%L,L%F,S%E,,<(25) SFD nested too deeply >)
	.ERR.	(,0,V%L,L%F,S%E,,<(26) no-create on for specified SFD path >)
	.ERR.	(,0,V%L,L%F,S%E,,<(27) segment not on swap space >)
	.ERR.	(,0,V%L,L%F,S%E,,<(30) can't update file >)
	.ERR.	(,0,V%L,L%F,S%E,,<(31) low segment overlaps high segment >)
	.ERR.	(,0,V%L,L%F,S%F,,<(32) RUN not allowed when not logged in >) ;[1174]
	.ERR.	(,0,V%L,L%F,S%F,,<(33) file still has outstanding ENQ/DEQ locks >) ;[1174]
	.ERR.	(,0,V%L,L%F,S%F,,<(34) bad EXE file directory format >) ;[1174]
	.ERR.	(,0,V%L,L%F,S%F,,<(35) EXE format files must have .EXE extension >) ;[1174]
	.ERR.	(,0,V%L,L%F,S%F,,<(36) EXE file directory is too big >) ;[1174]
	.ERR.	(,0,V%L,L%F,S%F,,<(37) network capability exceeded for TSK: >) ;[1174]
	.ERR.	(,0,V%L,L%F,S%F,,<(40) task is not available >) ;[1174]
	.ERR.	(,0,V%L,L%F,S%F,,<(41) undefined network node for TSK: >) ;[1174]

LRELEN==:.-LRETAB	;[1174] **MUST** AGREE WITH LNKERR
LREDEF:	.ERR.	(,0,V%L,L%F,S%F,,<) Unknown cause >)

IFN TOPS20,<		;[2330]
;[2301] Table of editable TOPS-20 messages.  These come only from the
;[2301] GTJFN% and OPENF% monitor calls (Except DESX8 which is forced)
;[2301] and are only for input files.

T20TAB:	GJFX4		;[2301] Invalid character in filename
	GJFX16		;[2301] No such device
	GJFX17		;[2301] No such directory name
	GJFX19		;[2325] No such file type
	GJFX18		;[2301] No such filename
	GJFX24		;[2301] File not found
	GJFX28		;[2301] Device is not on-line
	GJFX31		;[2325] Invalid wildcard designator
	GJFX34		;[2301] Invalid character "?" in filename
	GJFX35		;[2301] Directory access priviledges required
	DESX8		;[2301] File is not on disk
	DESX9		;[2301] Invalid operation for this device
	STRX09		;[2301] Prior structure mount required
	GFDBX3		;[2301] List access required
	OPNX2		;[2301] File does not exist
	OPNX3		;[2301] Read access required
	OPNX8		;[2301] Device is not on line
	OPNX9		;[2301] Invalid simultaneous access
	OPNX12		;[2301] List access required
	OPNX13		;[2301] Invalid access requested
T20SIZ=T20TAB-.
>;[2330] IFN TOPS20
SUBTTL	COMMON .ETC. SUBROUTINES


;PRINT 'DETECTED IN MODULE [SYMBOL] FROM FILE [FILE]' IF WE'RE CURRENTLY LOADING
;A MODULE. CALLED FROM  ALL  ERROR  MESSAGES  THAT  POTENTIALLY  PERTAIN  TO  A 
;PATICULAR MODULE.

.ETIMF::.ETC.	(XCT,.EC,,,,<[TRNN FL,R.LOD]>) ;[1174]
	.ETC.	(RTN)		;[1174] NO MODULE, MAYBE A SWITCH
	.ETC.	(NLN,.EC)	;[1174]
	.ETC.	(STR,.EC,,,,,<Detected in module >) ;[1174]
	.ETC.	(SBX,.EC!.EP,,,,PRGNAM) ;[1174]
	.ETC.	(STR,.EC,,,,,< from file >) ;[1174]
	.ETC.	(FSP,.EC,,,,DC) ;[1174]
	.ETC.	(RTN) ;[1174]

IFN .NWBLK,<
.ETNMF::.ETC.	(XCT,.EC,,,,<[TRNN FL,R.LOD]>) ;[1174]
	.ETC.	(RTN)		;[1174] NO MODULE, MAYBE A SWITCH
	.ETC.	(NLN,.EC)	;[1174]
	.ETC.	(STR,.EC,,,,,<Error detected in module >) ;[1174]
	.ETC.	(LSP,.EC!.EP,,,,NAMPTR) ;[1174]
	.ETC.	(STR,.EC,,,,,< from file >) ;[1174]
	.ETC.	(FSP,.EC,,,,DC) ;[1174]
	.ETC.	(RTN) ;[1174]
> ;[1174] END OF IFN .NWBLK


IFN FTOVERLAY,<
;PRINT ' LINK NUMBER n[, NAME x]'.

.ETLNN::.ETC.	(STR,.EC,,,,,< link number >) ;[1174]
	.ETC.	(DEC,.EC!.EP,,,,CS+CS.NUM) ;[1400]
	.ETC.	(XCT,.EC,,,,<[SKIPN CS+CS.LNM]>) ;[1400]
	.ETC.	(RTN)		;[1174] DON'T PRINT NAME IF NONE
	.ETC.	(STR,.EC,,,,,< name >) ;[1174]
	.ETC.	(SBX,.EC!.EP,,,,CS+CS.LNM) ;[1400]
	.ETC.	(RTN)
>
;PRINT SYMBOLS WITH VALUES.  THIS IS CALLED FROM VARIOUS PLACES, SUCH AS /ENTRY,
;/REQUEST, /UNDEFINED.  THIS IS A LOOP THAT PRINTS ALL APPLICABLE SYMBOLS  UNTIL
;DONE.
;
;CALL:
;	W1/	SIXBIT SYMBOL NAME
;	W2/	OCTAL SYMBOL VALUE
;	NXTGLB/	<PUSHJ P,LOCN>, WHERE LOCN IS NEXT SYMBOL ROUTINE
;W3  IS SAVED AND CAN BE USED FOR DATA.  THE ROUTINE REFERENCED IN NXTGLB SHOULD
;GIVE A NON-SKIP RETURN IF THERE ARE NO MORE SYMBOLS.  OTHERWISE, IT SHOULD GIVE
;A SKIP RETURN WITH W1-W3 SET UP AS ABOVE.

.ETSAV::.ETC.	(NLN,.EC)	;[1174] NEW LINE FOR NEXT SYMBOL
	.ETC.	(SBX,.EC!.EP,,,,W1) ;[1174] PRINT SYMBOL NAME
	.ETC.	(ASC,.EC,,,,.CHTAB) ;[1174]
	.ETC.	(OCT,.EC!.EP,,,,W2) ;[1174] PRINT SYMBOL VALUE
	.ETC.	(XCT,.EC,,,,NXTGLB) ;[1174] FETCH NEXT SYMBOL
	  .ETC.	(JMP,.EC,,,,.ETDON) ;[1174] NO MORE LEFT
	.ETC.	(JMP,.EC,,,,.ETSAV) ;[1174] LOOP FOR THIS ONE
.ETDON::.ETC.	(NOP)		;[1174] DONE
	POPJ	P,		;[1174] ALL DONE
SUBTTL	GENERIC JSYS ERROR HANDLER

IFN TOPS20,<			;[2257]

;
;	Subroutine to put last TOPS-20 process error string into a buffer.
;	Output the buffer with the following line during error processing:
;
;	.ETC.	(STR,,,,,ERRJSY)
;
;	Used ACs: none
;
JSERR::	SPUSH	<T1,T2,T3>	;[2257] SAVE ACS FOR A MOMENT
	HRROI	T1,ERRJSY	;[2257] POINT TO BUFFER FOR ERSTR% STRING
	MOVX	T2,<.FHSLF,,-1>	;[2257] GET OUR PROCESS,,LAST ERROR
	HRLZI	T3,-ERRLEN	;[2257] LENGTH OF ERSTR% BUFFER
	ERSTR%			;[2257] GET TEXT FOR THE ERROR
	 ERJMP	E$$UIE		;[2304] CATCH ERRORS WITHIN AN ERROR
	 PJRST	E$$UIE		;[2304] ERROR IF STRING TOO LONG
	SPOP	<T3,T2,T1>	;[2257] RESTORE ACS
	POPJ	P,		;[2257] DO USER'S ERROR HANDLING ROUTINE

E$$UIE:	.ERR.	(MS,,V%L,L%F,S%F,UIE,<Unexpected internal error during error processing>) ;[2304]


;
;	Generic JSYS error routine.  Call when all has failed and it's time
;	to die because of a JSYS error.
;
;	Call:	P2/	sixbit% JSYS name (6 chrs. max)
;	Return:	never (fatal error)
;
;	Used ACs: P1
;
E$$UMF::PUSHJ	P,JSERR		;[2257] SETUP ERROR TEXT BUFFER
	PUSH	P,P1		;[2257] SAVE P1 BEFORE USING (DON'T RESTORE)
	MOVE	P1,-1(P)	;[2257] GET PC OF FAILING JSYS
	TXZ	P1,^-<37,,-1>	;[2257] CLEAN OUT FLAG BITS
	SUBI	P1,2		;[2257] GO BACK TO JSYS ADDR
	.ERR.	(MS,.EC,V%L,L%F,S%F,UMF,<Unexpected monitor call failure for >)
	.ETC.	(SBX,.EC!.EP,,,,P2) ;[2351]
	.ETC.	(STR,.EC,,,,,< at PC >) ;[2257]
	.ETC.	(OCT,.EC!.EP,,,,P1) ;[2257]
	.ETC.	(NLN,.EC)	;[2257] NEW LINE FOR NEXT SYMBOL
	.ETC.	(STR,,,,,ERRJSY) ;[2257] TYPE ERSTR% TEXT
> ;[2257] END IFN TOPS20

LOGLIT:	END
 