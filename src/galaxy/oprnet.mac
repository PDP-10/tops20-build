	TITLE	OPRNET	ORION NETWORK SUPPORT CODE
	SUBTTL	Preliminaries

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1975, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

;*******
;THIS PROGRAM IS ONLY FOR THE -20 AT PRESENT AND IS THEREFORE COMPLETELY
;UNDER CONDITIONAL ASSEMBLY **********

	SEARCH	GLXMAC,ORNMAC
	PROLOG(OPRNET)

	ERRSET				;INIT ERROR TABLES

;Version numbers

	NETMAN==:0			;Maintenance edit number
	NETDEV==:31			;Development edit number
	VERSIN (NET)			;Generate edit number

TOPS20 <
	EXTERNAL G$HOST
	EXTERNAL LEVTAB
	EXTERNAL CHNTAB

	EXTERNAL NSPCON
	EXTERNAL NSPACT
	EXTERNAL NODNAM
	EXTERNAL SRVTBL
	EXTERNAL SRVDAT
	EXTERNAL TRMFRK
	EXTERNAL SRVACS

	SUBTTL	Table of Contents


;		Table of Contents for OPRNET
;
;
;			   Section			      Page
;   1. Preliminaries. . . . . . . . . . . . . . . . . . . . .    1
;   2. Table of Contents. . . . . . . . . . . . . . . . . . .    2
;   3. Revision history . . . . . . . . . . . . . . . . . . .    3
;   4. N$INIT . . . . . . . . . . . . . . . . . . . . . . . .    4
;   5. N$ISRV . . . . . . . . . . . . . . . . . . . . . . . .    5
;   6. N$CONN . . . . . . . . . . . . . . . . . . . . . . . .    6
;   7. N$CFRK . . . . . . . . . . . . . . . . . . . . . . . .    7
;   8. N$TERM . . . . . . . . . . . . . . . . . . . . . . . .    8
;   9. N$KFRK . . . . . . . . . . . . . . . . . . . . . . . .    9
;  10. N$INT. . . . . . . . . . . . . . . . . . . . . . . . .   10
;  11. N$PINT . . . . . . . . . . . . . . . . . . . . . . . .   11
;  12. N$ITER . . . . . . . . . . . . . . . . . . . . . . . .   12
SUBTTL	Revision history

COMMENT \

12	4.2.1361	3-Jun-82
	Check for false return after L%CENT.

*****  Release 4.2 -- begin maintenance edits  *****

*****  Release 5.0 -- begin development edits  *****

20	5.1003		4-Jan-82
	Move to new development area.  Add version vector.  Clean up
edit organization.  Update TOC.

21	5.1010		8-Feb-82
	In N$INIT, set up needed locations in CHNTAB.

*****  Release 5 -- begin maintenance edits  *****
25	Increment maintenance edit level for GALAXY 5.

*****	Release 6.0 -- begin development edits	*****

30	6.1037		26-Oct-87
	Move sources from G5: to G6:

31	6.1225		8-Mar-88
	Update copyright notice.

\   ;End of Revision History
SUBTTL	N$INIT	Initialize a server link

;THIS ROUTINE WILL TRY TO SETUP A PASSIVE TASK FOR OPERATOR
;CONNECTIONS. IF SUCCESSFUL IT WILL TURN ON NSPACT OTHERWISE
;IT WILL LEAVE IT OFF


N$INIT:: SETZM	NSPACT			;INITIALIZE NSP ACTIVE FLAG
	HRROI	S1,[ASCIZ/SRV/]		;IS THERE A SERVER
	STDEV				;SEE IF EXISTS?
	   PJRST NSPSE1			;NSP ERROR ..NO NSP
	$CALL	L%CLST			;CREATE A LIST
	MOVEM	S1,G$NETL##		;SAVE THE NETWORK LIST NUMBER
	MOVSI	P1,-NUMSRV		;NUMBER OF SERVERS
	MOVEI	P2,SRVTBL		;ADDRESS OF TABLE
	MOVEI	P3,CHNSRV		;CHANNEL DISPATCH ADDRESS
	MOVEI	S1,SRVTSK		;GET SERVER NUMBER
	SKIPE	DEBUGW			;ARE WE DEBUGGING
	MOVEI	S1,DEBSRV		;GET DEBUGGING SERVER
	$TEXT	(<-1,,SRVDAT>,<SRV:^D/S1/^0>)
INIT.1:	MOVEM	P3,SRV.CN(P2)		;SAVE THE CHANNEL NUMBER
	HRLZI	S1,IPCLEV		;Get priority level
	HLR	S1,SRVADR(P1)		;Address of connect interrupt routine
	MOVEM	S1,CHNTAB(P3)		;Set it
	HRR	S1,SRVADR(P1)		;Address of input interupt routine
	MOVEM	S1,CHNTAB+1(P3)		;Set it in channel table
	$CALL	N$ISRV			;INIT A SERVER
	MOVEI	P2,SRV.SZ(P2)		;GET THE NEXT ENTRY
	ADDI	P3,2			;2 CHANNELS PER SERVER (EDIT 2)
	AOBJN	P1,INIT.1		;TRY NEXT ONE
	MOVE	S1,[IPCLEV,,N$ITER]	;INTERRUPT ON FORK TERMINATION
	MOVEM	S1,CHNTAB+.ICIFT	;SAVE IN CHANNEL TABLE
	MOVX	S1,.FHSLF		;GET MY HANDLE
	MOVX	S2,<CHNINT!1B<.ICIFT>>	;SERVERS AND FORK TERMINATION
	AIC				;ACTIVATE THE CHANNEL
	POPJ	P,			;RETURN

SUBTTL	N$ISRV	Open the server link

;THIS ROUTINE WILL OPEN A SERVER FOR THE OPR TASK AND SAVE
;JFN AND DATA IN THE SERVER TABLE
;
;CALLED WITH P1/	SERVER ENTRY
;	     P2/	SERVER ENTRY ADDRESS

N$ISRV:	MOVX	S1,GJ%SHT!GJ%NEW	;NEW CONNECTION
	HRROI	S2,SRVDAT		;POINTER TO STRING
	GTJFN				;GET A JFN
	   PJRST NSPSE2			;CAN NOT GET A JFN
	MOVEM	S1,SRV.JF(P2)		;SAVE THE JFN
	MOVE	S2,[FLD(NETBSZ,OF%BSZ)+OF%RD+OF%WR] ;OPEN FLAGS AND SIZE
	OPENF				;TRY TO OPEN LINK
	   PJRST NSPSE3			;OPEN FAILED..RETURN
	MOVE	S1,SRV.JF(P2)		;GET THE JFN
	MOVEI	S2,.MOACN		;ATTACH TO INTERRUPT SYSTEM
	SETZM	T1			;CLEAR THE FLAG
	MOVE	T2,SRV.CN(P2)		;GET CHANNEL NUMBER
	STORE	T2,T1,MO%CDN		;SAVE FOR CONNECTS
	AOS	T2			;GET NEXT CHANNEL
	STORE	T2,T1,MO%DAV		;DATA AVAILABLE INTERRUPTS (EDIT 2)
	MTOPR				;DO THE FUNCTION
	  ERJMP	NSPSE3			;CLEAN UP
	POPJ	P,			;RETURN

;ERRORS
NSPSE3:	MOVE	S1,SRV.JF(P2)		;GET THE JFN
	TXO	S1,CZ%ABT		;SET THE ABORT BIT
	CLOSF				;CLOSE AND RELEASE THE JFN
	  JRST	.+1			;IGNORE ERRORS
NSPSE1:	
NSPSE2:
	$RETF				;ERROR..RETURN ***
SUBTTL	N$CONN	Process the NSP connect request

;THIS ROUTINE WILL PROCESS THE CONNECT THAT WAS FLAGED BY THE
;INTERRUPT AND RESET THE FLAG

N$CONN:: SKIPN	NSPCON			;CONNECT?
	$RETT				;NO..JUST RETURN
	SETZ	S1,			;CLEAR S1
	EXCH	S1,NSPCON		;RESET THE VALUE
	MOVEI	P1,NUMSRV		;GET NUMBER OF SERVERS
	MOVEI	P2,SRVTBL		;ADDRESS OF SERVER TABLE
CONN.1:	SETOM	S1			;INDICATOR
	CAME	S1,SRV.IN(P2)		;DID WE GET CONNECT
	  JRST	CONN.5			;NO..TRY NEXT ONE
	SETZM	SRV.IN(P2)		;CLEAR THE FLAG
	MOVE	S1,SRV.JF(P2)		;GET THE JFN FOR LINK
	MOVX	S2,.MORLS		;READ LINK STATUS
	MTOPR				;GET STATUS IN T1
	   ERJMP CONRE1			;BAD LINK ***
	TXNN	T1,MO%WCC		;WAITING FOR CONNECT?
	   PJRST CONN.3			;NO..TRY OTHER STATES
	MOVE	S1,SRV.JF(P2)		;GET THE JFN
	MOVEI	S2,.MORHN		;READ THE HOST NAME
	HRROI	T1,NODNAM		;PLACE TO STORE NAME
	MTOPR				;GET THE NAME
	   ERJMP CONRE3			;BAD LINK..***
	MOVEI	S1,NODNAM		;GET NODE NAME ADDRESS
	$CALL	S%SIXB			;CONVERT TO SIXBIT
	SKIPE	DEBUGW			;ARE WE DEBUGGING
	PJRST	CONN.2			;YES..IGNORE NODE CHECK
	CAMN	S2,G$HOST		;IS IT CENTRAL SITE
	   PJRST CONN.4			;CLOSE THE LINK
CONN.2:	MOVEM	S2,SRVACS+T2		;SAVE THE NODE NAME
	$CALL	N$CFRK			;CREATE THE PROCESS
;	$CALL	N$ISRV			;GET ANOTHER SERVER (EDIT 2)
	JRST	CONN.5			;TRY NEXT ENTRY
CONN.3:	PJRST	CONN.5			;IGNORE OTHER CODES FOR NOW ***
CONN.4:	MOVE	S1,SRV.JF(P2)		;GET THE JFN
	MOVEI	S2,.MOCLZ		;REFUSE THE CONNECT
	HRROI	T1,[ASCIZ/Not remote node/]
	HRLI	S2,.DCX34		;GET THE CODE
	MOVEI	T2,^D15			;15 CHARACTERS
	MTOPR				;REJECT IT
	  ERJMP	.+1			;IGNORE ERROR ***
	CLOSF				;CLOSE THE LINK
	  ERJMP .+1			;*** IGNORE ERROR
	$CALL	N$ISRV			;SETUP ANOTHER SERVER (EDIT 4)
CONN.5:	MOVEI	P2,SRV.SZ(P2)		;GET TO NEXT ENTRY
	SOJG	P1,CONN.1		;TRY NEXT ONE
	$RETT				;ALL DONE..RETURN
CONRE1:
CONRE2:
CONRE3:	$RETF				;RETURN FALSE.***
SUBTTL	N$CFRK	Create a fork and process the link


;THIS ROUTINE WILL START UP AN OPR AND PROCESS THE LINK
;AS A NORMAL OPR BUT WILL ENTER OPR AT OPRRMT

N$CFRK:: MOVE	S1,G$NETL##		;GET NET LIST NUMBER
	$CALL	L%LAST			;POSITION TO THE END
	MOVE	S1,G$NETL##		;GET THE NUMBER
	MOVEI	S2,NET.SZ		;SIZE OF AN ENTRY
	$CALL	L%CENT			;CREATE AN ENTRY
	JUMPF	CFRK.2			;Trouble in river city
	MOVE	T2,S2			;SAVE IN T2 ENTRY ADDRESS
	MOVE	S1,SRV.JF(P2)		;GET NETWORK JFN
	MOVEM	S1,SRVACS+T1		;SAVE IN AC T1..SERVER LINK
	MOVX	S1,<CR%CAP!CR%ACS>	;CAPABILITIES AND AC BLOCK
	MOVEI	S2,SRVACS		;ADDRESS OF AC BLOCK
	CFORK				;CREATE A FORK
	   JRST	CFRK.1			;ERROR..
	MOVEM	S1,NET.FK(T2)		;SAVE FORK HANDLE
	MOVEM	S1,SRV.FK(P2)		;SAVE FORK HANDLE (EDIT 2)
	MOVEM	P2,NET.SA(T2)		;SAVE SERVER TABLE ADDRESS( EDIT 2 + 7)
	MOVX	S1,GJ%SHT+GJ%OLD	;SHORT+OLD JFN
	HRROI	S2,[ASCIZ/SYS:OPR.EXE/]	;OPR PROGRAM
	SKIPE	DEBUGW			;ARE WE DEBUGGING
	HRROI	S2,[ASCIZ/OPR.EXE/]	;GET FROM LOCAL AREA
	GTJFN				;GET THE JFN
	   JRST	CFRK.2			;ERROR..
	HRL	S1,NET.FK(T2)		;GET THE FORK HANDLE
	SETZ	S2,			;CLEAR S2
	GET				;GET THE PROGRAM INTO THE PROCESS
	ERJMP	CFRK.3			;KILL FORK AND RETURN
	MOVEM	S1,NET.PG(T2)		;SAVE THE JFN OF PROGRAM
	MOVE	S1,NET.FK(T2)		;GET THE FORK HANDLE
	MOVEI	S2,1			;USE ENTRY 1 IN ENTRY VECTOR
	SFRKV				;START UP THE FORK
	ERJMP	CFRK.3			;KILL THE FORK
	MOVE	S1,SRV.JF(P2)		;GET THE JFN OF LINK
	MOVEM	S1,NET.LJ(T2)		;SAVE THE LINK IN DATA BASE
	$RETT				;RETURN
CFRK.1:
CFRK.2:	$RETF				;ERROR...***
CFRK.3:	PJRST	N$KFRK			;KILL THE PROCESS
SUBTTL	N$TERM	Terminate an inferior process

;THIS ROUTINE WILL FIND THE TERMINATED PROCESS AND RELEASE THE 
;PROCESS AND JFNS

N$TERM:: SKIPN	TRMFRK			;ANY TERMINATIONS
	$RETT				;NO..RETURN
	SETZ	S1,			;CLEAR S1
	EXCH	S1,TRMFRK		;RESET THE FLAG
	MOVE	S1,G$NETL##		;GET THE NET LIST NUMBER
	$CALL	L%FIRST			;POSITION TO THE FIRST
	JUMPF	.RETT			;JUST IGNORE..MUST BE ARCHEIVE
TERM.1:	MOVE	T2,S2			;GET THE ENTRY NUMBER
	MOVE	S1,NET.FK(T2)		;GET PROCESS HANDLE
	RFSTS				;READ FORK STATUS
	  ERJMP	TERM.2			;TRY NEXT ONE
	LOAD	S2,S1,RF%STS		;GET THE STATUS
	CAIE	S2,.RFHLT		;HALTED??
	CAIN	S2,.RFFPT		;TERMINATED
	SKIPA				;YES..
	JRST	TERM.2			;NO..TRY NEXT ONE
	$CALL	N$KFRK			;KILL THE PROCESS
TERM.2:	MOVE	S1,G$NETL##		;GET LIST NUMBER
	$CALL	L%NEXT			;GET THE NEXT ENTRY
	JUMPT	TERM.1			;O.K..CHECK IT OUT
	$RETT				;RETURN

SUBTTL	N$KFRK	Kill the current process

;THIS ROUTINE WILL DO THE APPROPRIATE FORK KILLING AND JFN
;RELEASING

N$KFRK:: MOVE	S1,G$NETL##		;GET THE LIST NUMBER
	$CALL	L%CURR			;POSITION TO CURRENT ENTRY
	SKIPT				;O.K.
	$STOP(NCS,NO CURRENT SERVER DATA BASE IN SKEW)
	MOVE	T2,S2			;PLACE ADDRESS IN T2
	MOVE	S1,NET.FK(T2)		;GET FORK HANDLE
	KFORK				;KILL THE FORK
	  ERJMP KFRK.1			;ERROR..***
	MOVE	S1,NET.PG(T2)		;JFN OF PROGRAM IN PROCESS
	RLJFN				;RELEASE THE JFN
	  JRST .+1			;IGNORE ERRORS
	MOVE	S1,NET.LJ(T2)		;GET LINK JFN
	TXO	S1,CZ%ABT		;SET THE ABORT BIT
	CLOSF				;CLOSE AND RELEASE THE JFN
	  JRST	.+1			;IGNORE ERRORS
	MOVE	P2,NET.SA(T2)		;ADDRESS OF SERVER TABLE (EDIT 2)
	MOVE	S1,G$NETL##		;GET LIST NUMBER
	$CALL	L%DENT			;DELETE THE ENTRY
	SETZM	SRV.FK(P2)		;CLEAR FORK WORD
	$CALL	N$ISRV			;INIT THE SERVER (EDIT 2)
	$RETT				;RETURN
KFRK.1:	$STOP(IPH,<INVALID PROCESS HANDLE TO KILL>)
SUBTTL	N$INT	Process connect interupts



	DEFINE	SRVINT(XX,YY,ZZ),<
N$INI'XX:: $BGINT IPCLEV		;INIT INTERRUPT LEVEL
	SETOM	NSPCON			;MARK CONNECT INTERRUPT
	SETOM	SRVTBL+SRV.IN+YY	;SET INTERRUPT OCCURRED FLAG
	$DEBRK				;EXIT FROM INTERRUPT
N$INI'ZZ:: $BGINT IPCLEV		;INIT INTERRUPT LEVEL (EDIT 2)
	MOVEI	P1,SRVTBL+YY		;GET SERVER TABLE
	JRST	N$PINP			;PROCESS INPUT INTERRUPT
	>;END SRVINT

	XX==0
	YY==0
	ZZ==1
	REPEAT	NUMSRV,<SRVINT(\XX,YY,\ZZ)
	XX==XX+2
	ZZ==XX+1
	YY==YY+SRV.SZ
	>;END GENERATION
	DEFINE	SRVMAC(XX,ZZ),<
	XWD	N$INI'XX,N$INI'ZZ
	>
SRVADR:
	XX==0
	ZZ==1
	REPEAT	NUMSRV,<SRVMAC(\XX,\ZZ)
	XX==XX+2
	ZZ==XX+1
	>
SUBTTL	N$PINT	Process a data interupt

;THIS ROUTINE WILL CHECK THE SERVER AND IF ACTIVE AND
;THERE IS DATA AVAILABLE...THEN GIVE INTERRUPT TO THE
;PROCESS ..ELSE DEBRK

N$PINP:	SKIPN	SRV.FK(P1)		;FORK EXIST?
	$DEBRK				;JUST IGNORE IT
	MOVE	S1,SRV.JF(P1)		;GET THE SERVER JFN
	MOVX	S2,.MORLS		;READ THE LINK STATUS
	SETZ	T1,			;WORD FOR STATUS
	MTOPR				;DO THE MTOPR
	ERJMP	PINT.2			;FLAG ERROR
	TXNN	T1,MO%CON		;CHECK IF CONNECTED?
	JRST	PINT.1			;NO.. FORCE INTERRUPT TO TERMINATE 
	TXNN	T1,MO%EOM		;WAS THERE DATA
	$DEBRK				;NO..IGNORE IT
PINT.1:	MOVE	S1,SRV.FK(P1)		;GET THE PROCESS HANDLE
	MOVX	S2,<1B<INPCHN>>		;INPUT CHANNEL
	IIC				;GENERATE THE INTERRUPT
	ERJMP .+1			;IGNORE...***
	$DEBRK				;EXIT FROM INTERRUPT
PINT.2:	$DEBRK				;IGNORE FOR NOW***
SUBTTL	N$ITER	Process inferior termination

;THIS ROUTINE WILL FLAG FORK TERMINATION TO BE 
;PROCESSED IN MAIN LOOP

N$ITER:	$BGINT IPCLEV			;SETUP INTERRUPT LEVEL
	SETOM TRMFRK			;SET FORK TERMINATION
	$DEBRK				;EXIT FROM INTERRUPT
>;END TOPS20
	END
