	TITLE	OPRNEB	ORION MODULE FOR PROCESSING NEBULA MESSAGES
	SUBTTL	Preliminaries

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

	SEARCH	GLXMAC,ORNMAC,QSRMAC,NEBMAC
	PROLOG(OPRNEB)

;Version numbers

	NEBMAN==:0			;Maintenance edit number
	NEBDEV==:20			;Development edit number
	VERSIN (NEB)			;Generate edit number

	Subttl	Table of Contents

;		     Table of Contents for OPRNEB
;
;				  Section		      Page
;
;
;    1. Revision history . . . . . . . . . . . . . . . . . . .   3
;    2. Global symbols . . . . . . . . . . . . . . . . . . . .   4
;    3. NEBMSG - NEBULA message dispatcher . . . . . . . . . .   5
;    4. N$RDSM - REMOTE DISMOUNT message . . . . . . . . . . .   6
;    5. N$FDSM - FROM NEBULA DISMOUNT message  . . . . . . . .   7
;    6. N$FDAK - FROM NEBULA DISMOUNT ACK message  . . . . . .   8
;    7. N$TDAK - TO NEBULA DISMOUNT ACK message  . . . . . . .   9
;    8. N$CDSM - NEBULA CANCEL DISMOUNT message  . . . . . . .  10
;    9. N$FMTS - FROM NEBULA MOUNT message . . . . . . . . . .  11
;   10. N$MESS - SHOW MESSAGES message . . . . . . . . . . . .  12
;   11. N$OPER - SHOW OPERATORS message  . . . . . . . . . . .  13
;   12. N$SHOW - REMOTE OPERATOR SHOW message  . . . . . . . .  14
;   13. N$MACS - REMOTE SHOW ACK message . . . . . . . . . . .  15
;   14. N$TEXT Process a TEXT message from a remote ORION  . .  16
;   15. N$FBLK - Find a specified message block  . . . . . . .  17
;   16. N$SQSR - Send messages to QUASAR, NEBULA and MOUNTR ro  18
;   17. BLDHDR - Build the GALAXY message header . . . . . . .  19
;   18. FINSHW - Send a SHOW MESSAGES or SHOW OPERATORS messag  20
;   19. CPYMSG - Copy an incoming message to an outgoing messa  21
;   20. GETMSG - PICK UP MESSAGE FOR SHOW MESSAGES COMMAND . .  22
;   21. N$BLDP - Build the remote .ORDSP block . . . . . . . .  23
;   22. CPYDSP - Copy the REMOTE DISPLAY block . . . . . . . .  24
;   23. NEBSTR - NEBULA message log file headers . . . . . . .  25
;   24. SHOW message code translation tables . . . . . . . . .  26
	SUBTTL	Revision history

COMMENT \

*****	Release 6.0 -- begin development edits	*****

1	6.1094		20-Nov-87
	Add OPRNEB as the ORION module that processes messages that
are processed on a remote node in the cluster and that have come from
a remote node in the cluster.

2	6.1098		22-Nov-87
	Add an entry for the OPR MOUNT STRUCTURE command to tables
NBTOQR and QRTONB.

3	6.1136		9-Dec-87
	Make routine N$FBLK global. Also, correct the way N$SQSR,
N$SMDA and N$SNEB pick up the system PID index for QUASAR, MOUNTR
and NEBULA.

4	6.1138		13-Dec-87
	Fix bugs found as a result of debugging NEBULA. Add routine N$TEXT
to process TEXT messages that originated from a remote ORION.

5	6.1142		17-Dec-87
	Add support for the SHOW STATUS TAPE/CLUSTER-NODE: and SHOW STATUS 
DISK/CLUSTER-NODE: commands.

6	6.1146		17-Dec-87
	Add support for the SHOW STATUS STRUCTURE/CLUSTER-NODE: command.

7	6.1157		4-Jan-88
	If an illegal NEBULA message type is detected or if the sender of
the NEBULA message is not privileged, then set flag word G$NERR so the remote
operator will be informed.

10	6.1158		5-Jan-88
	Change N$RDSM to send a FROM NEBULA DISMOUNT ACK (.NFDAK) instead of
a TO NEBULA DISMOUNT ACK (.NTDAK) to MOUNTR if NEBULA is not running.

11	6.1159		5-Jan-88
	Add entries for SHOW STATUS DISK, SHOW STATUS STRUCTURE and SHOW STATUS
TAPE to table NEBSTR.

12	6.1164		6-Jan-88
	Shorten the display lines in table NEBSTR.

13	6.1187		17-Feb-88
	If there are no messages for a node, change the error code from E$NNK
to E$NMN.

14	6.1197		27-Feb-88
	Don't log a FROM NEBULA DISMOUNT ACK message since the WTO message
is logged.

15	6.1205		1-Mar-88
	Change routines N$MACS and N$TEXT not to call routine SPGOUT so as to
prevent picking up a second IPCF page for the outgoing message.

16	6.1210		2-Mar-88
	Change the TO NEBULA DISMOUNT ACK message log file entry to indicate
that the message came from NEBULA instead of MOUNTR.

17	6.1225		8-Mar-88
	Update copyright notice.

20	6.1247		5-May-88
	Add support for the SHOW STATUS NETWORK-NODE and SHOW PARAMETERS
NETWORK-NODE commands.

\   ;End of Revision History
	SUBTTL	Global symbols

	EXTERN	CHKWHL			;CHECK FOR PRIVILEGES
	EXTERN	TABSRC			;TABLE ENTRY LOOKUP ROUTINE
	EXTERN	G$NEBD			;NEBULA MSG PROCESSOR ROUTINE ADR
	EXTERN	G$NACK			;NEBULA ACK FLAG
	EXTERN	G$ARG1			;ARGUMENT HOLDER
	EXTERN	G$ARG2			;ARGUMENT HOLDER
	EXTERN	G$HOST			;LOCAL NODE NAME
	EXTERN	G$NODL			;NODE LIST POINTER
	EXTERN	G$NERR			;REMOTE (NEBULA) SHOW ACK COMMAND ERROR
	EXTERN	G$NSHW			;REMOTE SHOW MESSAGE
	EXTERN	GETPAG			;GET A MESSAGE PAGE
	EXTERN	RELPAG			;RELEASE A MESSAGE PAGE
	EXTERN	QSRNAM			;QUASAR'S NAME
	EXTERN	NEBNAM			;NEBULA'S NAME
	EXTERN	MDANAM			;MOUNTR'S NAME
	EXTERN	SNDCGP			;SEND MESSAGES TO CLUSTER GALAXY PROC
	EXTERN	SNDBLK			;SAB BLOCK ADDRESS
	EXTERN	L$NEB			;LOG A NEBULA MESSAGE
	EXTERN	FNDNOD			;FIND A NODE
	EXTERN	SHWMTX			;BUILD THE LOCAL DISPLAY BLOCK
	EXTERN	SHDPBK			;LOCAL DISPLAY BLOCK ADDRESS
	EXTERN	SHODBK			;SHOW OPERATORS HEADER
	EXTERN	FNDXCT			;COMPARE MESSAGE NUMBERS
	EXTERN	CHKMSG			;CHECK FOR A MESSAGE AT A NODE
	EXTERN	MSGNOD			;BUILD A DISPLAY BLOCK FOR A NODE
	EXTERN	OPRLST			;BUILD DISPLAY BLOCK FOR AN OPERATOR
	EXTERN	BLDDPY			;MOVE MSG FROM MSG LIST TO OUTPUT PAGE
	EXTERN	FNDMSG			;LOOK FOR A MESSAGE ON ALL NODES
	EXTERN	W$ASND			;[4]SEND MESSAGE TO AN OPERATOR
	EXTERN	G$NOW			;[4]TIME THE MESSAGE WAS RECEIVED
	INTERN	NEBMSG			;NEBULA MESSAGE DISPATCHER
	INTERN	NEBSTR			;NEBULA LOG FILE HEADERS
	INTERN	QRTONB			;QUASAR TO NEBULA SHOW MESSAGE CODE
	INTERN	N$BLDP			;REMOTE DISPLAY BLOCK BUILDER
	INTERN	BLDHDR			;BUILD A REMOTE SHOW ACK MESSAGE HEADER
	INTERN	N$SNEB			;SEND A MESSAGE TO NEBULA
	INTERN	N$FBLK			;[3]FIND AN ARGUMENT BLOCK

MSGADR:	BLOCK	1			;MESSAGE PAGE RELEASED FLAG
DISBLK: BLOCK	15			;[4]REMOTE DISPLAY BLOCK

	SUBTTL	NEBMSG - NEBULA message dispatcher

;NEBMSG dispatches messages that NEBULA has involvement in.
;
;Call is:       S1/Message type
;		MI/IPCF message address
;
;Returns true:  The message was successfully processed
;Returns false: An error occurred processing the message

NEBMSG:	$CALL	CHKWHL			;CHECK THE CALLER'S PRIVILEGES
	JUMPF	[$CALL E$IPE##		  ;[7]INSUFFICIENT PRIVILEGES
		 SETOM G$NERR		  ;[7]ACK THE REMOTE REQUESTOR
		 $RET ]			  ;[7]RETURN TO THE CALLER
	MOVEI	S2,NEBTAB		;PICK UP MESSAGE DISPATCH TABLE
	$CALL	TABSRC			;PICK UP THE PROCESSOR ROUTINE ADR
	JUMPF	[$CALL E$IMT##		  ;[7]ILLEGAL MESSAGE TYPE
		 SETOM G$NERR		  ;[7]ACK THE REMOTE REQUESTOR
		 $RET ]			  ;[7]RETURN TO THE CALLER
	DMOVEM	S1,G$NEBD		;SAVE MESSAGE TYPE AND ROUTINE ADDRESS
	$CALL	GETPAG			;PICK UP A PAGE FOR OUTGOING MESSAGE
	SETZM	MSGADR			;ASSUME MESSAGE NOT RELEASED ON AN ERROR
	DMOVE	S1,G$NEBD		;PICK UP MESSAGE TYPE AND ROUTINE ADR
	$CALL	0(S2)			;PROCESS THE MESSAGE
	SKIPF				;DID AN ERROR OCCUR?
	$RET				;NO, RETURN NOW
	CAME	MO,MSGADR		;MESSAGE PAGE ALREADY RELEASED?
	$CALL	RELPAG			;NO, RELEASE THE MESSAGE PAGE
	$RETF				;RETURN TO THE CALLER

NEBTAB:	$STAB				;NEBULA MESSAGE DISPATCH TABLE

	.NRDSM,,N$RDSM			;REMOTE DISMOUNT MESSAGE
	.NFDSM,,N$FDSM			;FROM NEBULA DISMOUNT MESSAGE
	.NFDAK,,N$FDAK			;FROM NEBULA DISMOUNT ACK MESSAGE
	.NTDAK,,N$TDAK			;TO NEBULA DISMOUNT ACK MESSAGE
	.NCDSM,,N$CDSM			;NEBULA CANCEL DISMOUNT MESSAGE
	.NFMTS,,N$FMTS			;FROM NEBULA MOUNT MESSAGE

	.NMESS,,N$MESS			;SHOW MESSAGES MESSAGE
	.NSHOP,,N$OPER			;SHOW OPERATORS MESSAGE
	.NMSHS,,N$SHOW			;SHOW STATUS MESSAGE
	.NDSHT,,N$SHOW			;[5]SHOW STATUS TAPE
	.NDSHD,,N$SHOW			;[5]SHOW STATUS DISK
	.NDSTR,,N$SHOW			;[6]SHOW STATUS STRUCTURE
	.NDSCD,,N$SHOW			;SHOW CONFIGURATION MESSAGE
	.NMSHQ,,N$SHOW			;SHOW QUEUES MESSAGE
	.NMSHP,,N$SHOW			;SHOW PARAMETERS MESSAGE
	.NMSHR,,N$SHOW			;SHOW ROUTE MESSAGE
	.NMSSN,,N$SHOW			;[JCR]SHOW STATUS NETWORK-NODES
	.NMSPN,,N$SHOW			;[JCR]SHOW PARAMTERS NETWORK-NODES
	.NMACS,,N$MACS			;REMOTE SHOW ACK MESSAGE
	MT.TXT,,N$TEXT			;[4]REMOTE ORION TEXT MESSAGE
	$ETAB				

	SUBTTL	N$RDSM - REMOTE DISMOUNT message 

N$RDSM:	$CALL	L$NEB			;LOG THE MESSAGE
	$CALL	CPYMSG			;COPY THE MESSAGE TO OUTPUT MESSAGE
	MOVEI	S1,.NTDSM		;PICK UP EXPECTED MESSAGE CODE
	STORE	S1,.MSTYP(MO),MS.TYP	;PLACE IN OUTGOING MESSAGE
	$CALL	N$SNEB			;SEND THE MESSAGE TO NEBULA
	$RETIT				;RETURN ON SUCCESS SEND

;AN ERROR HAS OCCURRED - SEND MOUNTR A "FROM NEBULA DISMOUNT ACK" MESSAGE

	MOVEI	S1,.NRDAK		;[10]PICK UP THE MESSAGE CODE
	STORE	S1,.MSTYP(MO),MS.TYP	;PLACE IN THE MESSAGE
	SETZM	.MSFLG(MO)		;TURN OFF THE NEBULA BIT
	MOVX	S1,DS%FAI		;PICK UP ERROR INDICATOR
	MOVEM	S1,.OFLAG(MO)		;PLACE IN THE MESSAGE
	MOVEI	S2,2			;PICK UP THE ARGUMENT BLOCK COUNT
	MOVEM	S2,.OARGC(MO)		;PLACE IN THE MESSAGE

	MOVEI	T1,.OHDRS(MO)		;[4]POINT TO THE ASCIZ STR NAME BLOCK
	MOVEI	S1,ARG.DA(T1)		;[4]POINT TO THE ASCIZ STRUCTURE NAME
	HRLI	S1,(POINT 7,)		;[4]MAKE INTO A POINTER
	$CALL	S%SIXB			;[4]PICK UP THE SIXBIT STRUCTURE NAME
	MOVEM	S2,ARG.DA(T1)		;[4]PLACE IN THE STRUCTURE BLOCK
	MOVE	S1,[.STRLN,,.STRNM]	;[4]PICK UP THE HEADER WORD
	MOVEM	S1,ARG.HD(T1)		;[4]PLACE IN THE STRUCTURE BLOCK
	ADDI	T1,.STRLN		;[4]POINT TO THE STATUS BLOCK

	LOAD	S1,.MSTYP(MO),MS.CNT	;PICK UP THE MESSAGE LENGTH
	SUBI	S1,<.OHDRS+.STRLN>	;DETERMINE NODE BLOCKS TOTAL LENGTH
	MOVE	S2,S1			;SAVE FOR LATER
	MOVSS	S1			;PLACE BLOCK LENGTH IN EXPECTED PLACE
	HRRI	S1,.STSBK		;PICK UP BLOCK TYPE
	MOVEM	S1,ARG.HD(T1)		;PLACE BLOCK HEADER WORD IN THE MESSAGE
	
	LSH	S2,-1			;DETERMINE THE NUMBER OF NODES
	AOS	T1			;POINT PASS THE HEADER WORD

N$RD.1:	MOVE	S1,ARG.DA(T1)		;[4]PICK UP THE NODE NAME
	MOVEM	S1,ARG.HD(T1)		;[4]PLACE WHERE MOUNTR EXPECTS IT
	MOVE	S1,[ST%OER+IPCFX4]	;[4]PICK UP ERROR CODE
	MOVEM	S1,ARG.DA(T1)		;[4]PLACE WHERE MOUNTR EXPECTS IT
	ADDI	T1,.NDENM		;POINT TO THE NEXT NODE BLOCK
	SOJG	S2,N$RD.1		;UPDATE THE NEXT NODE BLOCK

	$CALL	N$SMDA			;SEND THE MESSAGE TO MOUNTR
	SKIPF				;SKIP ON MESSAGE SEND FAILURE
	MOVEM	MO,MSGADR		;INDICATE MESSAGE PAGE RELEASED

	MOVEI	S1,NEBNAM		;PICK UP NEBULA'S NAME
	MOVEM	S1,G$ARG1		;SAVE FOR THE LOG ERROR MESSAGE
	$CALL	E$IAP##			;PICK UP THE ERROR OFFSET
	SETOM	G$NACK			;DON'T SEND AN ACK TO NEBULA
	$RETF				;INDICATE AN ERROR HAS OCCURED

	SUBTTL	N$FDSM - FROM NEBULA DISMOUNT message

N$FDSM:	$CALL	L$NEB			;LOG THE MESSAGE
	$CALL	CPYMSG			;COPY THE MESSAGE INTO OUTGOING PAGE
	MOVEI	S1,.ODDSM		;PICK UP MSG CODE THAT QUASAR EXPECTS
	STORE	S1,.MSTYP(MO),MS.TYP	;PLACE IN THE MESSAGE
	$CALL	N$SQSR			;SEND THE MESSAGE TO QUASAR
	$RETIT				;RETURN ON SUCCESS

;AN ERROR OCCURRED. BUILD AND SEND THE FROM NEBULA DISMOUNT ACK MESSAGE

	MOVE	S1,[.OHDRS+.ERRSZ,,.NFDAK] ;PICK UP MESSAGE HEADER WORD
	MOVEM	S1,.MSTYP(MO)		;PLACE IN THE MESSAGE
	SETZM	.MSFLG(MO)		;ZERO OUT THE FLAG WORD
	MOVX	S1,FA%OER		;PICK UP ORION DETECTED THE ERROR
	MOVEM	S1,.OFLAG(MO)		;PLACE IN THE MESSAGE
	MOVEI	S1,1			;PICK UP THE ARGUMENT COUNT
	MOVEM	S1,.OARGC(MO)		;PLACE IN THE MESSAGE

	MOVE	S1,[.ERRSZ,,.ERRBK]	;PICK UP ERROR BLOCK HEADER WORD
	MOVEM	S1,.OHDRS+ARG.HD(MO)	;PLACE IN THE MESSAGE
	MOVEI	S1,IPCFX4		;PICK UP THE MONITOR ERROR CODE
	MOVEM	S1,.OHDRS+ARG.DA(MO)	;PLACE IN THE MESSAGE

	$CALL	N$SNEB			;SEND THE MESSAGE TO NEBULA
	SKIPF				;IF FAILED, THEN STILL HAVE PAGE
	MOVEM	MO,MSGADR		;INDICATE MESSAGE PAGE RELEASED

	MOVEI	S1,QSRNAM		;PICK UP QUASAR'S NAME ADDRESS
	MOVEM	S1,G$ARG1		;SAVE FOR THE LOG ERROR MESSAGE
	$CALL	E$IAP##			;PICK UP THE ERROR OFFSET
	SETOM	G$NACK			;DON'T SEND THE SENDER AN ACK
	$RETF				;INDICATE AN ERROR OCCURRED

	SUBTTL	N$FDAK - FROM NEBULA DISMOUNT ACK message

N$FDAK:	$CALL	CPYMSG			;COPY THE MESSAGE TO OUTGOING PAGE
	$CALL	N$SNEB			;SEND THE MESSAGE
	$RETIT				;RETURN NOW ON SUCCESS
	SETOM	G$NACK			;NO, DON'T ACK MOUNTR
	$CALL	E$IAP##			;STORE ERROR CODE
	$RET				;RETURN TO THE CALLER

	SUBTTL	N$TDAK - TO NEBULA DISMOUNT ACK message

N$TDAK:	$CALL	L$NEB			;LOG THE MESSAGE
	$CALL	CPYMSG			;COPY THE MESSAGE TO OUTGOING PAGE
	MOVEI	S1,.NRDAK		;PICK UP REMOTE DISMOUNT ACK MSG CODE
	STORE	S1,.MSTYP(MO),MS.TYP	;PLACE IN THE MESSAGE
	$CALL	N$SMDA			;SEND THE MESSAGE TO MOUNTR
	$RETIT				;RETURN NOW ON SUCCESS
	SETOM	G$NACK			;INDICATE DON'T ACK SENDER
	$CALL	E$IAP##			;STORE THE ERROR CODE IN G$ERR
	$RET				;RETURN TO THE CALLER

	SUBTTL	N$CDSM - NEBULA CANCEL DISMOUNT message

N$CDSM:	$CALL	L$NEB			;LOG THE MESSAGE
	$CALL	CPYMSG			;COPY THE MESSAGE TO OUTGOING PAGE
	$CALL	N$SNEB			;SEND THE MESSAGE
	$RETIT				;RETURN NOW ON SUCCESS
	SETOM	G$NACK			;NO, DON'T ACK MOUNTR
	$CALL	E$IAP##			;STORE THE ERROR CODE IN G$ERR
	$RET				;RETURN TO THE CALLER

	SUBTTL	N$FMTS - FROM NEBULA MOUNT message

N$FMTS:	$CALL	L$NEB			;LOG THE MESSAGE
	$CALL	CPYMSG			;COPY THE MESSAGE TO OUTGOING PAGE
	MOVEI	S1,.ODMTS		;PICK UP MSG CODE THAT QUASAR EXPECTS
	STORE	S1,.MSTYP(MO),MS.TYP	;PLACE IN THE MESSAGE
	$CALL	N$SQSR			;SEND THE MESSAGE TO QUASAR
	$RETIT				;RETURN ON SUCCESS

	MOVEI	S1,QSRNAM		;PICK UP QUASAR'S NAME ADDRESS
	MOVEM	S1,G$ARG1		;SAVE FOR THE LOG ERROR MESSAGE
	$CALL	E$IAP##			;STORE ERROR OFFSET IN G$ERR
	SETOM	G$NERR			;SEND AND LOG THE ERROR 
	$RETF				;INDICATE AN ERROR OCCURRED

	SUBTTL	N$MESS - SHOW MESSAGES message

N$MESS:	$SAVE	<P1>			;SAVE THIS AC
	MOVEI	S1,.OMDSP		;[4]]PICK UP THE MESSAGE TYPE
	$CALL	BLDHDR			;BUILD THE GALAXY MESSAGE HEADER
	MOVEI	S1,SHDPBK		;PICK UP DISPLAY HEADER ADDRESS
	$CALL	SHWMTX			;PLACE IN THE MESSAGE
	LOAD	S1,.OHDRS+ARG.HD(MI),AR.TYP ;PICK UP THE BLOCK TYPE
	CAIE	S1,.CMNOD		;IS THIS A NODE BLOCK?
	JRST	N$ME.1			;NO, CHECK FOR A NUMBER BLOCK
	MOVE	S1,.OHDRS+ARG.DA(MI)	;PICK UP THE NODE NAME
	MOVEM	S1,G$ARG1		;SAVE IN CASE OF AN ERROR
	$CALL	FNDNOD			;FIND THE NODE LIST ENTRY
	JUMPF	[MOVEI	S1,E$NNK##	  ;NODE NOT KNOWN
		 JRST	N$ME.5 ]	  ;BUILD AN ACK MESSAGE
	MOVE	S1,NOD.NM(S1)		;GET THE NODE NAME
	SETOM	G$NSHW			;INDICATE IT IS A REMOTE SHOW MESSAGE
	$CALL	MSGNOD			;OUTPUT THE MESSAGES
	JUMPF	N$ME.5			;GO INDICATE AN ERROR HAS OCCURRED
	$CALL	FINSHW			;HAVE SOME..SEND IT
	$RET				;RETURN TO THE CALLER

N$ME.1:	CAIE	S1,.CMNUM		;IS THIS A NUMBER BLOCK?
	JRST	N$ME.2			;NO, TREAT AS A <CR>
	MOVE	S1,G$HOST		;PICK UP THE LOCAL NODE NAME
	MOVEM	S1,G$ARG1		;SAVE IN CASE OF AN ERROR
	$CALL	FNDNOD			;FIND THE LOCAL NODE NAME ENTRY
	JUMPF	[MOVEI	S1,E$NNK##	  ;NODE NOT KNOWN
		 JRST	N$ME.5 ]	  ;GO INDICATE AN ERROR HAS OCCURRED
	MOVE	S1,.OHDRS+ARG.DA(MI)	;PICK UP THE MESSAGE NUMBER
	MOVEM	S1,G$ARG2		;SAVE IN CASE OF AN ERROR
	$CALL	GETMSG			;PICK UP THE MESSAGE
	JUMPF	[MOVEI	S1,E$NSM##	  ;NO SUCH MESSAGE
		 JRST	N$ME.5 ]	  ;GO INDICATE AN ERROR HAS OCCURRED
	$CALL	BLDDPY			;MOVE THE MESSAGE
	JUMPF	N$ME.5			;GO INDICATE AN ERROR HAS OCCURRED
	$CALL	FINSHW			;FINISH OFF THE MESSAGE
	$RET				;RETURN TO THE CALLER

;HERE IF JUST SHOW MESSAGES <CR>

N$ME.2:	MOVE	S1,G$HOST		;PICK UP THE LOCAL NODE NAME
	MOVEM	S1,G$ARG1		;[13]SAVE IN CASE OF AN ERROR
	$CALL	FNDNOD			;FIND THE LOCAL NODE NAME ENTRY
	JUMPF	[MOVEI	S1,E$NNK##	  ;NODE IS NOT KNOWN
		 JRST	N$ME.5 ]	  ;GO SEND AN ACK MESSAGE
	MOVE	S2,NOD.NM(S2)		;GET THE NAME
	SETZM	P1			;CLEAR MESSAGES FLAG
	MOVE	S1,G$NODL		;GET NODE LIST NUMBER
	$CALL	L%FIRST			;GET FIRST ENTRY
	JUMPF	[MOVEI	S1,E$NOM##	  ;NO OUTSTANDING MESSAGES
		 JRST	N$ME.5 ]	;GO SEND AN ACK MESSAGE
N$ME.3:	SETOM	G$NSHW			;INDICATE A REMOTE SHOW MESSAGE
	$CALL	MSGNOD			;GET MESSAGES FOR THIS NODE
	JUMPT	N$ME.4			;GO CHECK THE NEXT NODE
	CAIE	S1,E$NMN##		;[13]NO MESSAGES FOR THIS NODE?
	JRST	N$ME.5			;NO, INDICATE AN ERROR HAS OCCURRED
	SKIPA				;[4]YES, CHECK THE NEXT NODE

N$ME.4:	SETOM	P1			;MESSAGES FOUND
	MOVE	S1,G$NODL		;GET NODE LIST NUMER
	$CALL	L%NEXT			;GET NEXT ENTRY
	JUMPT	N$ME.3			;PROCESS MESSAGES
	JUMPE	P1,[MOVEI S1,E$NOM##	  ;PICK UP ERROR ROUTINE ADDRESS
		    JRST N$ME.5 ]	  ;GO INDICATE AN ERROR HAS OCCURRED
	$CALL	FINSHW			;SEND THE MESSAGE
	$RET				;RETURN TO THE CALLER

N$ME.5:	$CALL	0(S1)			;[4]PLACE ERROR OFFSET IN G$ERR
	SETOM	G$NERR			;LOG AND SEND AN ERROR ACK
	$RET				;RETURN TO THE CALLER

	SUBTTL	N$OPER - SHOW OPERATORS message

N$OPER:	$SAVE	<P1>			;SAVE THIS AC
	MOVEI	S1,.OMDSP		;[4]PICK UP THE MESSAGE TYPE
	$CALL	BLDHDR			;BUILD THE GALAXY MESSAGE HEADER
	MOVEI	S1,SHODBK		;SHOW OPERATOR TEXT
	$CALL	SHWMTX			;SHOW MESSAGE TEXT POINTER
	LOAD	S1,.OHDRS+ARG.HD(MI),AR.TYP ;PICK UP THE BLOCK TYPE
	CAIE	S1,.CMNOD		;IS THIS A NODE BLOCK?
	JRST	N$OP.1			;NO, SHOW ALL OPERATORS
	MOVE	S1,.OHDRS+ARG.DA(MI) ;PICK UP THE NODE NAME
	MOVEM	S1,G$ARG1		;SAVE IN CASE OF AN ERROR
	$CALL	FNDNOD			;VALIDATE THE NODE
	JUMPF	[MOVEI S1,E$NNK##	  ;NODE NOT KNOWN
		 JRST  N$OP.3 ]		  ;GO INDICATE AN ERROR HAS OCCURRED
	$CALL	OPRLST			;OPERATORS AT NODE
	JUMPF	[MOVEI	S1,E$NON##	  ;NO MESSAGES FOR THE NODE
		 JRST   N$OP.3 ]	  ;GO INDICATE AN ERROR HAS OCCURRED
	$CALL	FINSHW			;HAVE SOME..SEND IT
	$RET				;RETURN TO THE CALLER

N$OP.1:	SETZM	P1			;CLEAR MESSAGES FLAG
	MOVE	S1,G$NODL		;GET NODE LIST NUMBER
	$CALL	L%FIRST			;GET FIRST ENTRY
	JUMPF	[MOVEI	S1,E$NOD##	  ;NO OPERATORS DEFINED
		 JRST	N$OP.3 ]	  ;GO INDICATE AN ERROR HAS OCCURRED
N$OP.2:	$CALL	OPRLST			;OPERATORS AT NODE
	SKIPF				;NO MESSAGES SKIP FLAG SETTING
	SETOM	P1			;MESSAGES FOUND
	MOVE	S1,G$NODL		;GET NODE LIST NUMER
	$CALL	L%NEXT			;GET NEXT ENTRY
	JUMPT	N$OP.2			;PROCESS MESSAGES
	JUMPE	P1,[MOVEI S1,E$NOD##	  ;[4]NO OPERATORS DEFINED
		    JRST N$OP.3 ]	  ;GO INDICATE AN ERROR HAS OCCURRED
	$CALL	FINSHW			;YES..SEND MESSAGE
	$RET				;RETURN TO THE CALLER

N$OP.3:	$CALL	0(S1)			;PLACE ERROR OFFSET IN G$ERR
	SETOM	G$NERR			;LOG AND SEND AN ERROR ACK
	$RET				;RETURN TO THE CALLER

	SUBTTL	N$SHOW - REMOTE OPERATOR SHOW message

N$SHOW:	$CALL	L$NEB			;LOG THE MESSAGE
	$CALL	CPYMSG			;COPY THE MESSAGE TO OUTGOING PAGE
	LOAD	S1,.MSTYP(MO),MS.TYP	;PICK UP THE SHOW TYPE
	MOVEI	S2,NBTOQR		;PICK UP THEN CODE TRANSLATION TABLE
	$CALL	TABSRC			;PICK UP MESSAGE CODE QUASAR EXPECTS
	JUMPF	N$SH.1			;QUIT ON AN INVALID MESSAGE FORMAT
	STORE	S2,.MSTYP(MO),MS.TYP	;PLACE EXPECTED CODE IN THE MESSAGE
	$CALL	N$SQSR			;SEND THE MESSAGE TO QUASAR
	$RETIT				;RETURN ON SUCCESS

	MOVEI	S1,NEBNAM		;PICK UP NEBULA'S NAME ADDRESS
	MOVEM	S1,G$ARG1		;SAVE FOR THE LOG ERROR MESSAGE
	$CALL	E$IAP##			;PICK UP THE ERROR OFFSET
	$RETF				;INDICATE AN ERROR OCCURRED

N$SH.1:	$CALL	E$IFC##			;INDICATE ILLEGALLY FORMATTED MESSAGE
	$RETF				;INDICATE AN ERROR OCCURRED

	SUBTTL	N$MACS - REMOTE SHOW ACK message

N$MACS:	HRLI	S1,(MI)			;[15]ADDRESS OF THE MESSAGE
	HRRI	S1,(MO)			;[15]ADDRESS OF THE OUTGOING MESSAGE
	BLT 	S1,PAGSIZ-1(MO)		;[15]MOVE THE MESSAGE
	MOVEI	S1,.OMACS		;PICK UP THE SHOW ACK MESSAGE CODE
	STORE	S1,.MSTYP(MO),MS.TYP	;SAVE THE MESSAGE TYPE
	$CALL	L$NRSW##		;LOG THE MESSAGE
	$CALL	N$SNEB			;SEND THE MESSAGE TO NEBULA
	$RETIT				;RETURN ON SUCCESS

	MOVEI	S1,NEBNAM		;PICK UP NEBULA'S NAME ADDRESS
	MOVEM	S1,G$ARG1		;PLACE WHERE ERROR TEXT EXPECTS IT
	$CALL	E$IAP##			;PLACE ERROR OFFSET IN G$ERR
	SETOM	G$NACK			;DON'T SEND AN ACK MESSAGE TO SENDER
	$RET				;RETURN TO THE CALLER

	SUBTTL	N$TEXT  Process a TEXT message from a remote ORION

N$TEXT:	$CALL	CHKWHL			;[4]CHECK IF WHEEL
	JUMPF	E$ARP##			;[4]ERROR, RETURN
	HRLI	S1,(MI)			;[15]ADDRESS OF THE MESSAGE
	HRRI	S1,(MO)			;[15]ADDRESS OF THE OUTGOING MESSAGE
	BLT 	S1,PAGSIZ-1(MO)		;[15]MOVE THE MESSAGE
	MOVE	S1,G$NOW		;[4]PICK UP THE CURRENT TIME
	MOVEM	S1,.OHDRS+ARG.DA(MO)	;[4]PLACE IN THE REMOTE DISPLAY BLOCK
	$CALL	L$RERR##		;[4]LOG THE REMOTE TEXT MESSAGE
	$CALL	W$ASND			;[4]SEND THE MESSAGE
	$RETT				;[4]RETURN

	SUBTTL	N$FBLK - Find a specified message block

;N$FBLK is called to find a specified message block in a message
;
;Call is:       S1/Message address
;               S2/Block type code
;
;Returns true:  S1/Block address
;Returns false: Requested block type not found in the message

N$FBLK:	$SAVE	<P1,P2>			;SAVE THESE AC
	MOVE	P1,.OARGC(S1)		;PICK UP THE NUMBER OF ARGUMENT BLOCKS
	MOVEI	S1,.OHDRS(S1)		;POINT TO THE FIRST BLOCK
	
N$FB.1:	LOAD	P2,ARG.HD(S1),AR.TYP	;PICK UP THE BLOCK'S TYPE
	CAMN	S2,P2			;IS THIS THE BLOCK BEING SEARCHED FOR?
	$RETT				;YES, RETURN NOW
	LOAD	P2,ARG.HD(S1),AR.LEN	;NO, PICK UP THIS BLOCK'S LENGTH
	ADD	S1,P2			;POINT TO THE NEXT BLOCK
	SOJG	P1,N$FB.1		;CHECK THE NEXT BLOCK IF THERE IS ONE
	
	$RETF				;INDICATE BLOCK NOT FOUND

	SUBTTL	N$SQSR - Send messages to QUASAR, NEBULA and MOUNTR routines

N$SQSR:	SKIPA	S1,[SP.QSR+SI.FLG]	;PICK UP QUASAR'S PID INDEX
N$SMDA:	MOVX	S1,SP.MDA+SI.FLG	;[3]PICK UP MOUNTR'S PID INDEX
	SKIPA				;SKIP OVER PICKING UP MOUNTR'S INDEX
N$SNEB:	MOVX	S1,SP.NEB+SI.FLG	;[3]PICK UP NEBULA'S PID INDEX

	STORE	S1,SNDBLK+SAB.SI	;PLACE PID INDEX INTO SAB
	SETZM	SNDBLK+SAB.PD		;ZERO OUT THE PID WORD
	MOVEI	S2,PAGSIZ		;INDICATE THERE IS A PAGE WITH THIS MSG
	$CALL	SNDCGP			;SEND THE MESSAGE
	$RET				;PRESERVE THE T/F INDICATOR

	SUBTTL	BLDHDR - Build the GALAXY message header

;Call is: S1/Message code

BLDHDR:	STORE	S1,.MSTYP(MO),MS.TYP	;PLACE MESSAGE CODE VALUE IN MESSAGE
	DMOVE	S1,.MSFLG(MI)		;PICK UP THE FLAG AND ACK CODE WORDS
	DMOVEM	S1,.MSFLG(MO)		;PLACE IN THE MESSAGE
	MOVX	S1,WT.SJI!WT.NFO	;SUPPRESS JOB INFO + MSG FORMATTED 
	MOVEI	S2,1			;NUMBER OF ARGUMENT BLOCKS
	DMOVEM	S1,.OFLAG(MO)		;PLACE IN THE MESSAGE
	MOVEI	P3,.OHDRS(MO)		;POINT TO FIRST ARGUMENT BLOCK
	$CALL	CPYDSP			;COPY OVER THE DISPLAY BLOCK
	MOVE	S1,MI			;PICK UP ADDRESS OF INCOMING MESSAGE
	MOVEI	S2,.NDENM		;PICK UP BLOCK TYPE TO SEARCH FOR
	$CALL	N$FBLK			;FIND THE NODE BLOCK
	MOVE	S1,ARG.DA(S1)		;PICK UP THE NODE NAME
	MOVEM	S1,.OHDRS+ARG.DA(MO)	;SAVE FOR ACK AND ERROR DISPLAYS
	$RET				;RETURN TO THE CALL

	SUBTTL	FINSHW - Send a SHOW MESSAGES or SHOW OPERATORS message

FINSHW:	ANDI	P3,777			;ISOLATE THE MESSAGE LENGTH
	STORE	P3,.MSTYP(MO),MS.CNT	;PLACE IN MESSAGE
	$CALL	L$NRSW##		;LOG THE MESSAGE
	$CALL	N$SNEB			;SEND THE MESSAGE TO NEBULA
	$RETIT				;RETURN ON SUCCESS

	MOVEI	S1,NEBNAM		;PICK UP ADDRESS OF NEBULA'S NAME
	MOVEM	S1,G$ARG1		;PLACE WHERE ERROR STRING EXPECTS IT
	SETOM	G$NACK			;DON'T ACK THE SENDER
	$CALL	E$IAP			;PLACE ERROR OFFSET IN G$ERR
	$RET				;RETURN TO THE CALLER

	SUBTTL	CPYMSG - Copy an incoming message to an outgoing message

CPYMSG:	LOAD	S2,.MSTYP(MI),MS.CNT	;PICK UP THE MESSAGE LENGTH
	ADD	S2,MO			;DESTINATION ADDRESS + 1
	MOVE	S1,MO			;DESTINATION
	HRL	S1,MI			;SOURCE,,DESTINATION
	BLT	S1,-1(S2)		;COPY THE MESSAGE
	$RET				;RETURN TO THE CALLER

	SUBTTL	GETMSG - PICK UP MESSAGE FOR SHOW MESSAGES COMMAND

;GETMSG is called to pick up the message address of the message specified
;in a SHOW MESSAGES command
;
;Call is:       S1/Message number
;               S2/Node list entry address
;
;Returns true:  S1/Address of the message
;Returns false: The message was not found

GETMSG:	$SAVE	<P1,P2>			;SAVES THESE AC
	DMOVE	P1,S1			;SAVE MESSAGE NUMBER, NODE ENTRY ADR

	MOVEI	T1,MSL.ID		;PICK UP ID NUMBER OF MESSAGE
	HRRM	T1,FNDXCT		;SAVE FOR THE COMPARE
	$CALL	CHKMSG			;LOOK FOR THE MESSAGE ON LOCAL NODE
	$RETIT				;RETURN NOW IF MESSAGE WAS FOUND

	DMOVE	S1,P1			;PICK UP MSG NUMBER, NODE ENTRY ADDRESS
	MOVEI	T1,MSL.ID		;PICK UP ID NUMBER OF MESSAGE
	$CALL	FNDMSG			;LOOK FOR MESSAGE ON ALL NODES
	$RET				;PRESERVE T/F INDICATOR

	SUBTTL	N$BLDP - Build the remote .ORDSP block

N$BLDP:	$SAVE	<P1>			;SAVE THIS AC

	MOVEI	P1,DISBLK		;PICK UP ADDRESS OF THE DISPLAY BLOCK
	$TEXT	(<-1,,ARG.DA+1(P1)>,< Received message from ^N/G$HOST/::^0>)
	MOVEI	S2,ARG.DA+1(P1)		;[4]PICK UP ADDRESS OF THE MESSAGE
	HRLI	S2,(POINT 7,)		;[4]MAKE INTO A POINTER
	SETZ	S1,			;NUMBER OF CHARACTERS IN MESSAGE

N$BL.1:	ILDB	P1,S2			;PICK UP THE NEXT BYTE
	AOS	S1			;INCREMENT THE NUMBER OF CHARACTERS
	SKIPE	P1			;ANY MORE CHARACTERS?
	JRST	N$BL.1			;YES, COUNT THE NEXT ONE

	IDIVI	S1,5			;MESSAGE LENGTH IN WORDS
	SKIPE	S2			;ANY FRACTIONAL WORDS?
	AOS	S1			;YES, COUNT AS AN ENTIRE WORD
	ADDI	S1,2			;[4]INCLUDE HEADER AND UDT WORDS
	MOVSS	S1			;PLACE LENGTH IN EXPECTED PLACE
	HRRI	S1,.ORDSP		;PICK UP THE BLOCK TYPE
	MOVEM	S1,DISBLK		;PLACE IN THE MESSAGE
	$RET				;RETURN TO THE CALLER

	SUBTTL	CPYDSP - Copy the REMOTE DISPLAY block

;CPYDSP copies the built REMOTE DISPLAY block into the message being built
;
;Call is: P3/Address of the message's REMOTE DISPLAY block
;
;Returns: The REMOTE DISPLAY block has been copied into the message
;         P3/Address of the next block

CPYDSP:	MOVE	S1,P3			;PICK UP MESSAGE BLOCK ADDRESS
	HLRZ	S2,DISBLK		;PICK UP THE BLOCK LENGTH
	ADD	S2,S1			;END OF DESTINATION + 1
	HRLI	S1,DISBLK		;SOURCE,,DESTINATION
	BLT	S1,-1(S2)		;COPY THE BLOCK INTO THE MESSAGE
	MOVE	P3,S2			;[4]ADDRESS OF THE NEXT BLOCK
	$RET				;RETURN TO THE CALL

	SUBTTL	NEBSTR - NEBULA message log file headers

NEBSTR:	$STAB

	.NRDSM,,[ITEXT(<REMOTE DISMOUNT message received from MOUNTR>)]
	.NFDSM,,[ITEXT(<FROM NEBULA DISMOUNT message received from node ^N/S1/>)]
	.NFDAK,,[ITEXT(<FROM NEBULA DISMOUNT ACK message received from MOUNTR>)]
	.NTDAK,,[ITEXT(<TO NEBULA DISMOUNT ACK message received from NEBULA>)] ;[16]
	.NCDSM,,[ITEXT(<NEBULA CANCEL DISMOUNT message received from MOUNTR>)]
	.NFMTS,,[ITEXT(<FROM NEBULA MOUNT message received from node ^N/S1/>)]

	.NSHOP,,[ITEXT(<SHOW OPERATORS message received from node ^N/S1/>)]
	.NMESS,,[ITEXT(<SHOW MESSAGES message received from node ^N/S1/>)]
	.NMSHS,,[ITEXT(<SHOW STATUS message received from node ^N/S1/>)]
	.NDSTR,,[ITEXT(<SHOW STATUS STRUCTURE message received from node ^N/S1/>)]
	.NDSHD,,[ITEXT(<SHOW STATUS DISK message received from node ^N/S1/>)]
	.NDSHT,,[ITEXT(<SHOW STATUS TAPE message received from node ^N/S1/>)]
	.NMSSN,,[ITEXT(<SHOW STATUS NETWORK message received from node ^N/S1/>)]
	.NMSPN,,[ITEXT(<SHOW PARAMETER NETWORK message received from node ^N/S1/>)]
	.NDSCD,,[ITEXT(<SHOW CONFIGURATION message received from node ^N/S1/>)]	
	.NMSHQ,,[ITEXT(<SHOW QUEUES message received from node ^N/S1/>)]
	.NMSHP,,[ITEXT(<SHOW PARAMETERS message received from node ^N/S1/>)]
	.NMSHR,,[ITEXT(<SHOW ROUTE-TABLE message received from node ^N/S1/>)]

	$ETAB

	SUBTTL	SHOW message code translation tables

;NEBULA SHOW TO QUASAR SHOW

NBTOQR:	$STAB				;[4] 

	.NMSHS,,.OMSHS			;SHOW STATUS
	.NDSHT,,.ODSHT			;[5]SHOW STATUS TAPE
	.NDSHD,,.ODSHD			;[5]SHOW STATUS DISK
	.NDSTR,,.ODSTR			;[6]SHOW STATUS STRUCTURE
	.NDSCD,,.ODSCD			;SHOW CONFIGURATION
	.NMSHQ,,.OMSHQ			;SHOW QUEUES
	.NMSHP,,.OMSHP			;SHOW PARAMETERS
	.NMSHR,,.OMSHR			;SHOW ROUTE
	.NFMTS,,.ODMTS			;[2]MOUNT STRUCTURE/CLUSTER-NODE
	.NMSSN,,.OMSSN			;[JCR]SHOW STATUS NETWORK-NODE
	.NMSPN,,.OMSPN			;[JCR]SHOW PARAMETERS NETWORK-NODE

	$ETAB

;QUASAR SHOW TO NEBULA SHOW

QRTONB:	$STAB

	.OMSHS,,.NMSHS			;SHOW STATUS
	.ODSHT,,.NDSHT			;[5]SHOW STATUS TAPE
	.ODSHD,,.NDSHD			;[5]SHOW STATUS DISK
	.ODSTR,,.NDSTR			;[6]SHOW STATUS STRUCTURE
	.ODSCD,,.NDSCD			;SHOW CONFIGURATION
	.OMSHQ,,.NMSHQ			;SHOW QUEUES
	.OMSHP,,.NMSHP			;SHOW PARAMETERS
	.OMSHR,,.NMSHR			;SHOW ROUTE
	.ODMTS,,.NTMTS			;[2]MOUNT STRUCTURE/CLUSTER-NODE
	.OMSSN,,.NMSSN			;[JCR]SHOW STATUS NETWORK-NODE
	.OMSPN,,.NMSPN			;[JCR]SHOW PARAMETERS NETWORK-NODE

	$ETAB

	END

