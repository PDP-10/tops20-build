	UNIVER	GLXMAC  --  Parameter File For GLXLIB
	SUBTTL	Preliminaries

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1975, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


;This file contains symbol and macro definitions which are common to
;	all GALAXY programs.
;
;This file also acts as the administration module for other common
;	subsystems modules as they are developed.

	SEARCH	GALCNF			;SO WE CAN BE SYSTEM DEPENDENT
	SALL				;SUPRESS MACRO EXPANSIONS

IFNDEF	GLXPURE,<GLXPURE==-1>		;DEFAULT TO HIGH SEGMENT GLXLIB

DEFINE TOPS10 <IFN FTUUOS,>		;SETUP CONDITIONAL MACROS
DEFINE TOPS20 <IFN FTJSYS,>


TOPS10 <
    IF2,<
	IFE GLXPURE,<PRINTX [Building a Galaxy-10 library]>
	IFN GLXPURE,<PRINTX [Building a Galaxy-10 OTS]>
    >
	SEARCH	UUOSYM			;GET TOPS-10 SYMBOLS
>

TOPS20 <
    IF2,<
	IFE GLXPURE,<PRINTX [Building a Galaxy-20 library]>
	IFN GLXPURE,<PRINTX [Building a Galaxy-20 OTS]>
    >
	SEARCH	MONSYM			;GET TOPS-20 SYMBOLS
>

;Macro for building source vectors.  Generates two words of the form:
;	source file name	in SIXBIT
;	Maintenance edit,,Development edit  numbers

DEFINE	BLDVEC (NAME,SYM,FLAG<E>) <
	IFIDN <E><FLAG>,<EXTERNAL SYM'MAN,SYM'DEV>
	SIXBIT	/NAME/
	XWD	SYM'MAN,SYM'DEV
> ;End BLDVEC

;Macro for deciding the edit number of a module, it picks the larger of the
;two edit numbers Maintenance or Development

DEFINE	VERSIN (SYM) <
	IFG  <SYM'MAN-SYM'DEV>,<SYM'EDT==:SYM'MAN>
	IFLE <SYM'MAN-SYM'DEV>,<SYM'EDT==:SYM'DEV>
> ;End of VERSIN
; version numbers

LODLEV==2
%%.GLX==10

	GMCMAN==:0			;Maintenance edit number
	GMCDEV==:322			;Development edit number
	VERSIN (GMC)			;Generate edit number

;Macro to Generate Standard Version Word
;Assumes PFXWHO, PFXVER, PFXMIN, PFXEDT are defined.
;	VRSN. (PFX)

DEFINE VRSN.(PFX),<BYTE (3)PFX'WHO (9)PFX'VER (6)PFX'MIN (18)PFX'EDT>

	XP FTUUOS,FTUUOS		;GLOBAL-IZE SYSTEM SWITCHES
	XP FTJSYS,FTJSYS		;GOTTEN FROM GALCNF
	XP FTFTS,FTFTS

	XP	C.GALA,C.GALA		;[320]CLUSTER GALAXY OPTION
	DEFINE	CLUSTER <IFN C.GALA,>	;[320]CLUSTER GALAXY ENABLED
	DEFINE	SINGLE	<IFE C.GALA,>	;[320]CLUSTER GALAXY DISABLED

	Subttl	Table of Contents

;		     Table of Contents for GLXMAC
;
;				  Section		      Page
;
;
;    1. Revision history . . . . . . . . . . . . . . . . . . .   6
;    2. Accumulator Definitions  . . . . . . . . . . . . . . .   7
;    3. Not-known-to-DDT hardware mnemonics  . . . . . . . . .   8
;    4. JUMPx, SKIPx Instruction OPDEFS  . . . . . . . . . . .   9
;    5. ND, XP, EXT, and GLOB Macros . . . . . . . . . . . . .  10
;    6. CONT. LSTOF. LSTON. VRSN. Macro Definitions  . . . . .  11
;    7. PROLOG - Uniform assembly set up . . . . . . . . . . .  12
;    8. SYSPRM - Set system dependent parameters . . . . . . .  13
;    9. MIN and MAX - Find minimum or maximum of vector of val  14
;   10. LIBVEC - Library run-time system entry vector  . . . .  15
;   11. PG2ADR,ADR2PG Macros . . . . . . . . . . . . . . . . .  16
;   12. Standard Constants . . . . . . . . . . . . . . . . . .  17
;   13. Control Character Symbols  . . . . . . . . . . . . . .  18
;   14. Processor definitions  . . . . . . . . . . . . . . . .  19
;   15. PC word flags  . . . . . . . . . . . . . . . . . . . .  20
;   16. Field and Mask Macros  . . . . . . . . . . . . . . . .  21
;   17. MOVX . . . . . . . . . . . . . . . . . . . . . . . . .  22
;   18. CAX - COMPARE MACROS . . . . . . . . . . . . . . . . .  23
;   19. ADDX, SUBX, IMULX, MULX, IDIVX & DIVX MACROS . . . . .  24
;   20. TX - TEST MASK . . . . . . . . . . . . . . . . . . . .  25
;   21. SUBFUNCTION MACROS . . . . . . . . . . . . . . . . . .  28
;   22. DEFSTR - DEFINE DATA STRUCTURE . . . . . . . . . . . .  29
;   23. STKVAR - STACK VARIABLE FACILITY . . . . . . . . . . .  33
;   24. TRVAR - TRANSIENT VARIABLE FACILITY  . . . . . . . . .  34
;   25. SAVE MACRO DEFINITION  . . . . . . . . . . . . . . . .  36
;   26. LOAD,STORE,INCR,DECR,ZERO  . . . . . . . . . . . . . .  37
;   27. $BGINT,$DEBRK - Interrupt context switching  . . . . .  39
;   28. $BUILD,$SET,$EOB - Build pre-formed data blocks  . . .  40
;   29. $CALL,$RETT,$RETF,$RETE,$RET Uniform Call/Return Mecha  41
;   30. $GDATA Macro - Runtime System Data Area control  . . .  42
;   31. $FATAL, and $WARN Macro definitions  . . . . . . . . .  43
;   32. $STOP - Cause a STOP CODE to occur . . . . . . . . . .  44
;   33. $TEXT - Interface to the T%TEXT routine  . . . . . . .  45
;   34. $TQ MACRO DEFINITION . . . . . . . . . . . . . . . . .  51
;   35. Error processing and messages  . . . . . . . . . . . .  53
;   36. ..TEXT PARSING MACRO DEFINITION  . . . . . . . . . . .  54
;   37. ASCII TEXT STRING STORAGE MACRO DEFINITIONS  . . . . .  57
;   38. $WTO / $WTOJ / $WTOR / $ACK Macros . . . . . . . . . .  58
;   39. GALAXY system error codes  . . . . . . . . . . . . . .  62
;   40. Canonical File Information . . . . . . . . . . . . . .  63
;   41. Canonical Job Information  . . . . . . . . . . . . . .  64
;   42. I%TIMR Functions and argument block  . . . . . . . . .  65
;   43. Scanning and Command Module Symbols  . . . . . . . . .  66
;   44. THE MESSAGE HEADER . . . . . . . . . . . . . . . . . .  69
;   45. General message format . . . . . . . . . . . . . . . .  70
;   46. ACK - THE GALAXY 'ACK' MESSAGE . . . . . . . . . . . .  72
;   47. JIB - Job Information Block  . . . . . . . . . . . . .  73
	Subttl	Table of Contents (page 2)

;		     Table of Contents for GLXMAC
;
;				  Section		      Page
;
;
;   48. OBJ - Object Descriptor  . . . . . . . . . . . . . . .  74
;   49. OBJCTS MACRO . . . . . . . . . . . . . . . . . . . . .  76
;   50. FD - File Descriptor . . . . . . . . . . . . . . . . .  77
;   51. FOB - Parameter block passed to F%IOPN and F%OOPN  . .  79
;   52. FRB - Parameter block passed to F%REN for renames  . .  80
;   53. IB - Initialization Block for GALAXY programs  . . . .  81
;   54. PIB - PID block  . . . . . . . . . . . . . . . . . . .  82
;   55. SAB - Send Argument Block passed to C%SEND . . . . . .  83
;   56. MDB - Message Descriptor Block returned by C%RECV  . .  84
;   57. Special system PIDS  . . . . . . . . . . . . . . . . .  85
;   58. System Independent IPCF Codes and Constants  . . . . .  86
;   59. Program internal parameters of interest  . . . . . . .  87
;   60. $HALT - Halt a Program without Reset . . . . . . . . .  89
;   61. PDB - PARSER DESCRIPTOR BLOCK DEFINITION . . . . . . .  90
;   62. PDBDEF - PDBDEF MACRO DEFINITION . . . . . . . . . . .  91
;   63. PDB - PARSER DESCRIPTOR BLOCK  . . . . . . . . . . . .  92
;   64. COMMAND FUNCTION MACROS  . . . . . . . . . . . . . . .  93
;   65. INITIALIZE PARSER MACRO MACROS . . . . . . . . . . . .  97
;   66. .$BUILD MACRO  . . . . . . . . . . . . . . . . . . . .  98
;   67. PARSER MACROS FOR EACH FUNCTION  . . . . . . . . . . .  99
;   68. KEYWORD TABLE MACROS . . . . . . . . . . . . . . . . . 105
;   69. End of GLXMAC  . . . . . . . . . . . . . . . . . . . . 106
	SUBTTL	Revision history

COMMENT \
*****  Release 4.2 -- begin maintenance edits  *****

234	4.2.1427	8-Jul-82
	Fix defs of SZ.BUF and SZ.OBF

235	4.2.1574	2-May-84
	Add word MDB.PR to the Message Descriptor Block. This word will hold
word .IPCFC (sender's enabled capabilities word) from the packet descriptor
block.

240	4.2.1620	13-Aug-85
	Add bit definition for supersede.

*****  Release 5.0 -- begin development edits  *****

250	5.1002		28-Dec-82
	Move to new development area.  Remove need for GLXVER.  Add version
vector.  Clean up edit organization.  Update TOC.

251	5.1023		8-Apr-83
	Add a DB.IPC symbol to the debug word.

252	5.1046		21-Oct-83
	Change version number from 1 to 5.

253	5.1047		24-Oct-83
	Add symbol to indicate maximum file spec size.  MXFSPC

254	5.1063		30-Nov-83
	Add a symbol to the IB to allow for setting a system process.  Also,
add symbols to the debug word.  One to allow overriding the case of not
setting system process if a debugging world.  Another to name bit 35
as just being a debugging world.

255	5.1093		13-Feb-84
	Move GLXLIB version number and the major, minor and customer version
numbers from GLXMAC to GLXCOM.

256	5.1133		9-Apr-84
	Remove the value of GLXVRS from location 137.

257	5.1162		21-Sept-84
	Define new object type (.OTSNA) to support SNA Workstations.

260	5.1200		6-Feb-85
	Define a new bit in the initialization block, IB.NAC, which will
prevent access by inferior processes to the JFNs of a process.

*****  Release 5.0 -- begin maintenance edits  *****

265	Increment maintenance edit level for version 5 of GALAXY.

266	5.1224	SPR#20908
	Add error code, IPE.SS, for TOPS-20 error code MONX06.

*****  Release 6.0 -- begin development edits  *****

300	6.1006		5-Oct-87
	Add NEBULA support in the message header word. Define a new
message header word, the checksum word (.MSCHS)

301	6.1007		5-Oct-87
	Define the GALAXY error code ERFSM$ which corresponds to the
monitor error code CLSX3 (File still mapped).

302	6.1014		11-Oct-87
	Add printer subtypes .CLLPT (Cluster printer), .DQLPT (DQS printer)
and .LALPT (LAT printer) to .OTLPT (the printer object).

303	6.1022		19-Oct-87
	Define priorities for LPT objects such that the order of LPT objects
on QUASAR's object queue is: local, cluster, DQS and LAT.

304	6.1033		22-Oct-87
	Define an unknown remote LPT bit (.UNLPT) and an unknown remote
LPT priority (.UNPRI).

305	6.1034		23-OCT-87
	Define SEMI-OPERATOR privilege bit for MDB.
	
306	6.1037		27-Oct-87

307	6.1040		28-Oct-87
	Add queue name block (OBJ.QN) to the end of the object block.
The longer object block is of length OBJ.SQ.

310	6.1041		29-Oct-87
	Define .LOLPT as a local printer type in support of the OPR SHOW
STATUS PRINTER and SHOW PARAMETERS PRINTER commands.

311	6.1045		30-Oct-87
	Remove the checksum word .MSCHS from the GALAXY message header.
Checksumming is not necessary when using DECnet between two KLs.

312	6.1066		9-Nov-87
	Define bit PT.KEE so that if turned on in the SAB length AC
to C%SEND, then it indicates that C%SEND is not to inform GLXMEM
that the page is available.

313	6.1076		15-Nov-87
	Define SP.NEB as NEBULA's system PID

314	6.1072		16-Nov-87
	Define the TTY characteristic block, .ORTCR==113.

315	6.1096		21-Nov-87
	Define the new macros, $QACK and $QWTO, which QUASAR uses in 
reponse to messages that originated on a remote node in the cluster.

316	6.1107		1-Dec-87
	Make the $QACK and $QWTO macros skipable.

317	6.1166		14-Jan-88
	Move the .EAWTO(NHD,0) inserted by edit 315 to the end of the list
so that old programs won't break.

320	6.1183		16-Feb-88
	Define C.GALA, CLUSTER and SINGLE in support of ENABLE/DISABLE
Cluster GALAXY.

321	6.1196		27-Feb-88
	Define block .ORRFG to contain the values of words WDAOBT and WDAFLG
for WTO messages that are to be forwarded to a remote node in the cluster.

322	6.1225		8-Mar-88
	Update copyright notice.  Change PROLOG macro to do copyright binaries.

\   ;End of Revision History
SUBTTL	Accumulator Definitions

	;Pass FACT file accounting requirement along

	FTFACT==FTFACT		;From GALCNF

;THE FOLLOWING ACCUMULATOR DEFINITIONS ARE STANDARD THROUGHOUT THE
;	SUB-SYSTEMS GROUP AND MAY NOT BE CHANGED.  THE ACCUMULATORS DEFINED ARE:

	TF==0			;TRUE/FALSE REGISTER, NEVER REFERENCED DIRECTLY
				; USED BY $RETx AND JUMPT,JUMPF, SKIPT,SKIPF
	.SAC==0			;SCRATCH AC USED BY SOME NONE SKIPPABLE
				;MACROS AND SOME MACRO CALLS TO GLXCOM
				;.SAC MAY NOT BE CHANGED ON EXIT FROM A
				;CO-ROUTINE SO THAT ANY ROUTINE MAY PASS
				;A TRUE FALSE VALUE BACK TO IT'S CALLER.

	S1==1			;S1 & S2 ARE ARGUMENTS TO ROUTINES
	S2==2			;AND ARE OTHERWISE SCRATCH

	T1==3			;T1 - T4 ARE TEMPORARY REGS
	T2==4
	T3==5
	T4==6

	P1==7			;P1 - P4 ARE PRESERVED REGS
	P2==10
	P3==11
	P4==12
	.A13==13		;.A13 THRU .A16 NOT USED BY LIBRARY
	.A14==14
	.A15==15
	.A16==16

	.FP==16			;FRAME POINTER USED BY TRVAR AND ASUBR
				;MAY NOT BE CHANGED WITHIN THE SCOPE OF
				;A ROUTINE USING TRVAR OR ASUBR
				;HOWEVER -- IT IS PRESERVED OUTSIDE THE
				;SCOPE OF THESE ROUTINES

	P==17			;PUSHDOWN POINTER

;THERE ARE CO-ROUTINES DEFINED IN GLXCOM TO SAVE AND AUTOMATICALLY
;	RESTORE THE "T" AND "P" THAT ARE INVOKED BY THE SAVE MACRO
;	CALLED AS FOLLOWS:

;	$SAVE <P1,P2,P3,P4>	;TO SAVE P1-P4
;	$SAVE <T1,T2,T3,T4>	;TO SAVE T1-T4
;	$SAVE <P1>		;TO SAVE P1
;	$SAVE <P1,P2,P3>		;TO SAVE P1-P3
;	$SAVE <T1,T2>		;TO SAVE T1-T2
;	$SAVE <TF,S1>		;TO SAVE TF AND S1 FOR RETURN TO CALLER
;				;AC'S ARE AUTOMATICALLY RESTORED ON RETURN

;AC'S 13,14,15 & 16 ARE AVAILABLE TO THE COMPONENT AND MAY BE USED
;	TO ANY END WITH THE NOTEABLE EXCEPTION:

;			* * * *  N O T E  * * * *

;	AC16 IS USED AS A FRAME POINTER FOR TRVAR AND ASUBR DYNAMIC
;	VARIABLE ALLOCATION.  IT MAY NOT BE REFERENCED WITHIN THE
;	RANGE OF THE TRVAR OR ASUBR, HOWEVER IT IS PRESERVED ON RETURN
;	TO THE CALLER.

;REFER TO GLXLIB.MEM FOR A FULL DESCRIPTION OF MACROS AND AC USAGE
SUBTTL	Not-known-to-DDT hardware mnemonics


; These OPDEFs were taken from MACTEN
;
; JRST xx,
;
	OPDEF	PORTAL	[JRST 01,]	;CONCEALED ENTRY POINT JUMP
	OPDEF	JRSTF	[JRST 02,]	;JUMP RESTORING FLAGS
	OPDEF	HALT	[JRST 04,]	;JUMP, HALTING PROCESSOR
	OPDEF	XJRSTF	[JRST 05,]	;FLAG-PC-DOUBLEWORD JRSTF
	OPDEF	XJEN	[JRST 06,]	;FLAG-PC-DOUBLEWORD JEN
	OPDEF	XPCW	[JRST 07,]	;FLAG-PC-DOUBLEWORD XSFM+XJRSTF
	OPDEF	JEN	[JRST 12,]	;JRSTF ENABLING PI
	OPDEF	XSFM	[JRST 14,]	;SAVE FLAG-PC-DOUBLEWORD NO JUMP


; JFCL xx,
;
	OPDEF	JFOV	[JFCL 01,]	;JUMP ON FLOATING UNDER/OVERFLOW
	OPDEF	JCRY1	[JFCL 02,]	;JUMP ON CARRY-1
	OPDEF	JCRY0	[JFCL 04,]	;JUMP ON CARRY-0
	OPDEF	JCRY	[JFCL 06,]	;JUMP ON CARRY-0 OR CARRY-1
	OPDEF	JOV	[JFCL 10,]	;JUMP ON OVERFLOW


; JRST to a POPJ
;
	OPDEF	PJRST	[JUMPA 17,]	;PUSHJ/POPJ
					;THIS CUTE TRICK WILL ALLOW DDT
					;TO DISTINGUISH BETWEEN JRST AND
					;PJRST INSTRUCTIONS . . .


; Other random OPDEFs
;
	OPDEF	XMOVEI	[SETMI]		;EXTENDED MOVEI
	OPDEF	XHLLI	[HLLI]		;NOT YET IN MACRO
SUBTTL	JUMPx, SKIPx Instruction OPDEFS

;All subroutines which follow GALAXY conventions return a "success/failure"
; value in the register TF.  This is done by returning via one of
; the return instructions, $RETE, $RETT  or $RETF (See next page).
;The value of TRUE or FALSE which a routine returns can be tested with one
;of the following instructions, which alter program flow according to
; the value currently in TF.

; Jump to location specified if TF contains TRUE

	OPDEF	JUMPT [JUMPN]

; Jump to location specified if TF contains FALSE

	OPDEF	JUMPF [JUMPE]

; Skip the next instruction if TF contains TRUE

	OPDEF	SKIPT [SKIPN]

; Skip the next instruction if TF contains FALSE

	OPDEF 	SKIPF [SKIPE]


; Suppress DDT typeout of the above symbols
;
	.NODDT	JUMPT, JUMPF, SKIPT, SKIPF
SUBTTL	ND, XP, EXT, and GLOB Macros

;Macro to Define Symbol if not already defined
;	ND  SYMBOL,VALUE

DEFINE	ND(SYM,VAL),<IF2,<IFDEF SYM,<SYM==SYM>> IFNDEF SYM,<SYM==VAL>>


;Macro to Define a Symbol and force it INTERN
;	XP  SYMBOL,VAL,PRINT

;		Where PRINT is any Non-blank to allow printing from DDT

DEFINE	XP(SYM,VAL,PRINT),<IFB <PRINT>,<SYM==:VAL> IFNB <PRINT>,<SYM=:VAL>>

;Macro to EXTERN a Symbol if not defined in this routine
;	EXT SYMBOL

DEFINE	EXT(SYMBOL),<IRP SYMBOL,<
	IF2,<IFNDEF SYMBOL,<EXTERN SYMBOL>>>>


;Macro to EXTERN or INTERN a Symbol
;	GLOB SYMBOL

DEFINE	GLOB(SYMBOL),<IRP SYMBOL,<
	IF2,<IFDEF SYMBOL,<.IFN SYMBOL,EXTERN,<INTERN SYMBOL>>
	     IFNDEF SYMBOL,<EXTERN SYMBOL>
	     SUPPRES SYMBOL>>>
SUBTTL	CONT. LSTOF. LSTON. VRSN. Macro Definitions

;Macro to force page overflow with appropriate comments

DEFINE	CONT.(NAME)<LALL
PAGE; (NAME Continued on next page)
SALL; (NAME Continued from previous page)>


;Macros to turn on and off listings with nesting and level control
;	LSTOF.			;TURNS OFF LISTINGS ONLY
;	LSTOF. XCREF		;TURNS OFF LISTINGS AND CREF
;	LSTON.			;RESTORES LISTINGS AND CREF AT TOP LEVEL
;IF LSTIN. IS DEFINED AS .MINFI THEN ALL LISTINGS ARE ON

DEFINE	LSTOF.(FOO),<
	IFNDEF LSTIN.,LSTIN.==0		;;INITIALIZE LEVEL COUNTER
IFE LSTIN.,<
	IFIDN <XCREF><FOO>,<.XCREF>	;;CONDITIONALLY SUPPRESS CREF
		   XLIST>		;;TURN OFF LISTINGS
	LSTIN.==LSTIN.+1>		;;BUMP LIST LEVEL

DEFINE	LSTON.,<
	IFG LSTIN.,LSTIN.==LSTIN.-1	;;DECR LIST LEVEL
	IFLE LSTIN.,<.CREF		;;RESUME CREFS
		      LIST>>		;;RESUME LISTS

SUBTTL	PROLOG - Uniform assembly set up


; The PROLOG macro is used to uniformly search all the right UNV files
; and setup the listing format and STOP CODE controls.
; Call:	PROLOG	(MODULE,OTSCOD)
;
; Where: 'MODULE' represents the module name
;	 'OTSCOD' (optional) represents a GLXLIB module mnemonic
;
%%.MOD==SIXBIT/NONAME/			;;DEFAULT MODULE NAME INCASE NULL
%%.OTS==0				;;DEFAULT OTSCOD INCASE NULL

DEFINE	PROLOG	(MODULE,OTSCOD),<

	SALL				;;FOR PRETTY LISTINGS
	LSTOF. XCREF			;;TURN OFF LISTING

	LOC 0			;;[322] Set copyright in AC area
	ASCIZ \
COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1975,1988.
ALL RIGHTS RESERVED.
\				;;[322] Available to TYPE mumble.REL and .EXE
	RELOC			;;[322] Back to normal code

	%%.GLX==%%.GLX			;;RECORD VERSION NUMBER
;;	GLXVRS==GLXVRS			;;Don't need/want this anymore

	IFNB <MODULE>,<%%.MOD==SIXBIT/MODULE/> ;;MAKE NAME AVAILABLE
	IFNB <OTSCOD>,<%%.OTS==SIXBIT/OTSCOD/> ;;MAKE OTSCODE AVAILABLE

	GLOB	I%INIT			;;ENTRY POINT CALLED BY THE USER

	TOPS10	<			;;TOPS-10 ONLY
		SEARCH	UUOSYM		;;OPERATING SYSTEM SYMBOLS
		%%UUOS==%%UUOS		;;RECORD VERSION NUMBER
	>				;;END OF TOPS-10 CONDITIONAL

	TOPS20	<			;;TOPS-20 ONLY
		SEARCH	MONSYM		;;OPERATING SYSTEM SYMBOLS
;		%%MONS==%%MONS		;;RECORD VERSION NUMBER
	>				;;END OF TOPS-20 CONDITIONAL

	IFB <OTSCOD>,<			;;IF NOT A GLXLIB MODULE
		.TEXT	|,REL:GLXLIB/SEARCH/REQUIRE:I%INIT|
		DEFINE	$DATA (NAM,SIZ<1>),< ;;MACRO TO GENERATE DATA STORAGE
			NAM:	BLOCK	SIZ
		>			;;END OF $DATA MACRO
		DEFINE	CDO (X),<GLOB X> ;;MAKE ENTRY POINTS GLOBAL
		LIBVEC			;;GLOBALIZE ALL ENTRY POINTS
	>				;;END OF IFB <OTSCOD> CONDITIONAL

	IFNB <OTSCOD>,<IFDIF <OTSCOD><INI>,< ;;IF NOT GLXINI
		IFN GLXPURE,<.PSECT .HIGH.> ;;IF OTS
		IFE GLXPURE,<		;;IF LINKABLE LIBRARY
			TWOSEG	400000	;;MAKE US SHARABLE
			RELOC	0	;;DATA STORAGE STARTS HERE
			RELOC	400000	;;START LOADING THE HIGH SEGMENT
		>			;;END OF IFE GLXPURE CONDITIONAL

		DEFINE $DATA(NAM,SIZ<1>),< ;;MACRO TO GENERATE DATA STORAGE
			IFN GLXPURE,<.PSECT DATA> ;;RELOCATE TO DATA PSECT
			IFE GLXPURE,<RELOC> ;;RELOCATE TO LOW SEGMENT
			IFNDEF OTSCOD'%D,<OTSCOD'%D::! OTSCOD'%DL==:0>
			NAM:	BLOCK	SIZ
			OTSCOD'%DL==:OTSCOD'%DL+SIZ ;;COUNT WORDS
			IFN GLXPURE,<.ENDPS DATA> ;;TERMINATE PSECT REFERENCE
			IFE GLXPURE,<RELOC> ;;BACK TO THE HIGH SEG
		>			;;END OF $DATA MACRO

		IFDIF <OTSCOD><OTS>,<	;;FOR ALL BUT GLXOTS...
			DEFINE	CDO (X),<GLOB X> ;;MAKE ENTRY POINTS GLOBAL
			LIBVEC		;;GLOBALIZE ALL ENTRY POINTS
		>			;;END OF IFDIF <OTSCOD><OTS> CONDITIONAL

	>>				;;END OF IFDIF <OTSCOD><INI> CONDITIONAL

	IFNB <OTSCOD>,<IFIDN <OTSCOD><INI>,< ;;IF GLXINI
		DEFINE	$DATA (NAM,SIZ<1>),< ;;MACRO TO GENERATE DATA STORAGE
			NAM:	BLOCK	SIZ
		>			;;END OF $DATA MACRO
	>>				;;END OF IFIDN <OTSCOD><INI> CONDITIONAL

	LSTON.				;;TURN LISTINGS ON

	GLOB	<.POPJ, .RETT, .RETF>	;;SOME POPULAR RETURNS
	OPDEF	$RET	[POPJ	P,]	;;RETURN
	OPDEF	$RETT	[PJRST	.RETT]	;;RETURN TRUE
	OPDEF	$RETF	[PJRST	.RETF]	;;RETURN FALSE
	OPDEF	$RETIT	[JUMPT	.POPJ]	;;RETURN IF TRUE
	OPDEF	$RETIF	[JUMPF	.POPJ]	;;RETURN IF FALSE
	.NODDT	$RET,$RETT,$RETF,$RETIT,$RETIF
>					;;END OF PROLOG MACRO
SUBTTL	SYSPRM - Set system dependent parameters

;THE SYSPRM MACRO IS USED TO DEFINE A SYMBOL WHOSE VALUE IS DIFFERENT
;	DEPENDING ON THE OPERATING SYSTEM WHICH THE PROGRAM IS
;	BEING ASSEMBLED FOR.
;
;	THE CALL IS:
;
;	  SYSPRM   'SUBSYSTEM-NAME' , 'TOPS10 VALUE' , 'TOPS20 VALUE'


DEFINE	SYSPRM(SYMBOL,UUOS,JSYS),<
	IFNB <UUOS>,<TOPS10<SYMBOL==UUOS>>
	IFNB <JSYS>,<TOPS20<SYMBOL==JSYS>>
>  ;END DEFINE SYSPRM




SUBTTL	MIN and MAX - Find minimum or maximum of vector of values

;THE MIN AND MAX MACROS FIND THE MIN OR MAX OF THE ITEMS IN THE FIRST
;	ARGUMENT LIST.  THE SYMBOL NAMED BY THE SECOND ARGUMENT WILL BE
;	DEFINED AS THE MIN OR MAX OF THE LIST.  IF THE SECOND ARGUMENT
;	IS MISSING, "MINSIZ" OR "MAXSIZ" IS DEFINED.

DEFINE	MAX(A,B),<
	IFB <B>,<MAXSIZ==0
		IRP A,<IFG <A-MAXSIZ>,<MAXSIZ==A>>>
	IFNB <B>,<B==0
		IRP A,<IFG <A-B>,<B==A>>>
>  ;END OF DEFINE MAX

DEFINE	MIN(A,B),<
	IFB <B>,<MINSIZ==377777,,777777
		IRP A,<IFG <MINSIZ-A>,<MINSIZ==A>>>
	IFNB <B>,<B==377777,,777777
		IRP A,<IFG <B-A>,<B==A>>>
>  ;END OF DEFINE MIN
SUBTTL	LIBVEC - Library run-time system entry vector

; Each entry in this macro represents a routine or variable that must
; be made available to the OTS itself or to programs using the OTS.

; For OTS programs, each entry is declared EXTERNAL if it does not appear
; in the module itself.  For non-OTS code, the symbols are defined as offsets
; in the Library Dispatch vector as absolute symbols.  This vector
; lives in GLXOTS

; Each modules entry points are grouped together. In order to allow for
;	the addition of new routines for each module, there are blank places
;	held open.  When a new routine is added, remove one of the blank
;	occurrences of "CDO".  This will keep the vector straight and allow
;	the running of older programs without their re-compilation.

	DEFINE LIBVEC <

	  LSTOF. XCREF

	CDO	OTSINI			;;GLXOTS INITIALIZATION
	CDO	    			;;GLXCOM
	CDO	.ZPAGA
	CDO	.ZPAGN
	CDO	.ZCHNK
	CDO	.SAVE1
	CDO	.SAVE2
	CDO	.SAVE3
	CDO	.SAVE4
	CDO	.SAVET
	CDO	.SV13
	CDO	.SV14
	CDO	.SV15
	CDO	.SV16
	CDO	.RETT
	CDO	.RETF
	CDO	.RETE
	CDO	.AOS		;;USED BY INCR
	CDO	.SOS		;;USED BY DECR
	CDO	.ZERO		;;USED BY ZERO
	CDO	.POPJ		;;RETURN (CPOPJ)
	CDO	.STOP		;;STOPCODE PROCESSOR
	CDO	.SAVE8		;;SAVES P1 THRU AC16
	CDO	.STKST		;;STKVAR SUPPORT CODE
	CDO	.TRSET		;;TRVAR SUPPORT CODE
	CDO	.POPJ1		;;SKIP RETURN
	CDO	.UD2SC		;;Convert from UDT to number of seconds
	CDO	.SC2UD		;;Convert from seconds to UDT
	CDO	.CPUTY		;;RETURN CPU TYPE
	CDO
	CDO
	CDO

	CDO			;;GLXIPC
	CDO	C%RPRM
	CDO	C%INTR
	CDO	C%SEND
	CDO	C%RECV
	CDO	C%BRCV
	CDO	C%REL
	CDO	C%CPID
	CDO	C%KPID
	CDO	C%SPID
	CDO	C%MAXP
	CDO	C%PIDJ
	CDO
	CDO
	CDO
	CDO
	CDO

	CDO	      			;;GLXFIL
	CDO	F%IOPN
	CDO	F%AOPN
	CDO	F%OOPN
	CDO	F%IBYT
	CDO	F%OBYT
	CDO	F%IBUF
	CDO	F%OBUF
	CDO	F%REL
	CDO	F%DREL
	CDO	F%RREL
	CDO	F%REW
	CDO	F%POS
	CDO	F%CHKP
	CDO	F%INFO
	CDO	F%FD
	CDO	F%REN
	CDO	F%DEL
	CDO	F%FCHN
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO

	CDO	      			;;GLXMEM
	CDO	M%ACQP
	CDO	M%RELP
	CDO	M%IPSN
	CDO	M%NXPG
	CDO	M%IPRC
	CDO	M%IPRM
	CDO	M%AQNP
	CDO	M%RLNP
	CDO	M%CLNC
	CDO	M%FPGS
	CDO	M%GMEM
	CDO	M%RMEM
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO	M%GPAG
	CDO	M%RPAG
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO

	CDO	      			;;GLXTXT
	CDO	T%TEXT
	CDO	T%TTY
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO

	CDO	      			;;GLXLNK
	CDO	L%CLST
	CDO	L%DLST
	CDO	L%CENT
	CDO	L%CBFR
	CDO	L%DENT
	CDO	L%NEXT
	CDO	L%FIRS
	CDO	L%LAST
	CDO	L%PREV
	CDO	L%PREM
	CDO	L%CURR
	CDO	L%RENT
	CDO	L%SIZE
	CDO	L%APOS
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO

	CDO			;;GLXINT
	CDO	I%NOW
	CDO	I%EXIT
	CDO	I%ION
	CDO	I%IOFF
	CDO	I%SLP
	CDO	I%INT1
	CDO	I%INT2
	CDO	I%INT3
	CDO	I%TIMR
	CDO
	CDO
	CDO	I%SOPR
	CDO	I%WTO
	CDO
	CDO	I%HOST
	CDO	I%JINF
	CDO
	CDO

	CDO			;;GLXSCN
	CDO
	CDO	S%DATI
	CDO	S%SIXB
	CDO	S%CMND
	CDO	S%TBLK
	CDO	S%SCMP
	CDO	S%ERR
	CDO	S%INTR
	CDO	S%EXIT
	CDO	S%TBAD
	CDO	S%TBDL
	CDO	S%NUMI


	CDO	K%RCOC			;;GLXKBD
	CDO	K%WCOC
	CDO	K%SUET
	CDO	K%STYP
	CDO	K%TXTI
	CDO	K%SOUT
	CDO	K%BOUT
	CDO	K%BIN
	CDO	K%BACK
	CDO	K%TPOS
	CDO	K%BUFF
	CDO	K%FLSH
	CDO	K%OPEN
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	CDO
	  LSTON.
  > ;END OF LIBVEC DEFINITION
SUBTTL	PG2ADR,ADR2PG Macros

DEFINE	PG2ADR(AC),<LSH AC,^D9>

DEFINE	ADR2PG(AC),<LSH AC,-^D9>
SUBTTL	Standard Constants

.INFIN==377777,,777777		;PLUS INFINITY
.MINFI==1B0			;MINUS INFINITY
LHMASK==777777B17		;LEFT HALF
RHMASK==777777			;RIGHT HALF
FWMASK==-1			;FULL WORD


; BYTE POINTER PARTS

	BP.POS==77B5			;POSITION (BITS TO THE RIGHT)
	BP.SIZ==77B11			;SIZE OF BYTE
	BP.ADR==Z -1			;ADDRESS PORTION


; DEFINE UNIVERSAL TRUE AND FALSE CONSTANTS

	FALSE==0
	TRUE=-1

; MEMORY CONSTANTS

	PAGSIZ==^D512			;SIZE OF ONE PAGE
	MEMSIZ==^D512			;PAGES IN THE ADDRESS SPACE

; DEBUGGING CONSTANTS

	SYSPRM	DDTADR,.JBDDT,770000	;LOCATION CONTAINING START OF DDT
	SYSPRM	DEBUGW,.JBOPS,135	;SPECIAL "DEBUGGING" WORD

	DB.IPC==1B0			;Use system debugging pids
	DB.SYS==1B1			;If IB.SYS is set in IB, then set as a 
					;  system process even if debugging
	DB.NOR==1B35			;Just a plain old debugging world

	MXFSPC==^D140			; 8 for node name::
					; 7 for structure:
					;41 for <directory>
					;39 for filename
					;40 for .ext
					; 5 for ;gen
					;No space allocated for attributes
SUBTTL	Control Character Symbols

.CHNUL==000			;NULL
.CHCNA==001
.CHCNB==002
.CHCNC==003
.CHCND==004
.CHCNE==005
.CHCNF==006
.CHBEL==007			;BELL
.CHBSP==010			;BACKSPACE
.CHTAB==011			;TAB
.CHLFD==012			;LINE-FEED
.CHVTB==013			;VERTICAL TAB
.CHFFD==014			;FORM FEED
.CHCRT==015			;CARRIAGE RETURN
.CHCNN==016
.CHCNO==017
.CHCNP==020
.CHCNQ==021
.CHCNR==022
.CHCNS==023
.CHCNT==024
.CHCNU==025
.CHCNV==026
.CHCNW==027
.CHCNX==030
.CHCNY==031
.CHCNZ==032
.CHESC==033			;ESCAPE
.CHCBS==034			;CONTROL BACK SLASH
.CHCRB==035			;CONTROL RIGHT BRACKET
.CHCCF==036			;CONTROL CIRCONFLEX
.CHCUN==037			;CONTROL UNDERLINE

.CHLAB=="<"			;CHARACTERS WHICH DRIVE
.CHRAB==">"			;UP A WALL

.CHALT==175			;OLD ALTMODE
.CHAL2==176			;ALTERNATE OLD ALTMODE
.CHDEL==177			;DELETE
SUBTTL	 Processor definitions


%PDP6==0	;PDP-6  CP166 PROCESSOR
%KA10==1	;PDP-10 KA10 PROCESSOR
%KI10==2	;PDP-10 KI10 PROCESSOR
%KL10==3	;PDP-10 KL10 PROCESSOR
%KS10==4	;PDP-10 KS10 PROCESSOR
%XXXX==5	;PDP-10 XXXX PROCESSOR
SUBTTL	PC word flags


; TOPS-10 PC flags
;
PC.OVF==1B0	;OVERFLOW
PC.CY0==1B1	;CARRY 0
PC.CY1==1B2	;CARRY 1
PC.FOV==1B3	;FLOATING OVERFLOW
PC.BIS==1B4	;BYTE INCREMENT SUPPRESSION
PC.USR==1B5	;USER MODE
PC.UIO==1B6	;USER IOT MODE
PC.LIP==1B7	;LAST INSTRUCTION PUBLIC
PC.AFI==1B8	;ADDRESS FAILURE INHIBIT
PC.ATN==3B10	;APR TRAP NUMBER
PC.FUF==1B11	;FLOATING UNDERFLOW
PC.NDV==1B12	;NO DIVIDE


; TOPS-20 PC flags
;
PC%OVF==1B0	;OVERFLOW
PC%CY0==1B1	;CARRY 0
PC%CY1==1B2	;CARRY 1
PC%FOV==1B3	;FLOATING OVERFLOW
PC%BIS==1B4	;BYTE INCREMENT SUPPRESSION
PC%USR==1B5	;USER MODE
PC%UIO==1B6	;USER IOT MODE
PC%LIP==1B7	;LAST INSTRUCTION PUBLIC
PC%AFI==1B8	;ADDRESS FAILURE INHIBIT
PC%ATN==3B10	;APR TRAP NUMBER
PC%FUF==1B11	;FLOATING UNDERFLOW
PC%NDV==1B12	;NO DIVIDE
SUBTTL	Field and Mask Macros

;STANDARD MACROS

;MACROS TO HANDLE FIELD MASKS

;COMPUTE LENGTH OF MASK, I.E. LENGTH OF LEFTMOST STRING OF ONES
;REMEMBER THAT ^L DOES 'JFFO', I.E. HAS VALUE OF FIRST ONE BIT IN WORD

;COMPUTE WIDTH OF MASK, I.E. LENGTH OF LEFTMOST STRING OF ONES

DEFINE WID(MASK)<<^L<-<<MASK>_<^L<MASK>>>-1>>>

;COMPUTE POSITION OF MASK, I.E. BIT POSITION OF RIGHTMOST ONE IN MASK

DEFINE POS(MASK)<<^L<<MASK>&<-<MASK>>>>>

;CONSTRUCT BYTE POINTER TO MASK

DEFINE POINTR(LOC,MASK)<<POINT WID(MASK),LOC,POS(MASK)>>

;PUT RIGHT-JUSTIFIED VALUE INTO FIELD SPECIFIED BY MASK

DEFINE	FLD(VALUE,MASK),<<<<VALUE>B<POS(<MASK>)>>&<MASK>>>

;MAKE VALUE BE RIGHT JUSTIFIED IN WORD.

DEFINE .RTJST(VAL,MSK)<<VAL>B<^D70-POS(MSK)>>

;CONSTRUCT MASK FROM BIT AA TO BIT BB. I.E. MASKB 0,8 = 777B8

DEFINE MASKB (AA,BB)<1B<<AA>-1>-1B<BB>>

;MODULE - GIVES REMAINDER OF DEND DIVIDED BY DSOR

DEFINE MOD. (DEND,DSOR)<<DEND-<DEND/DSOR>*DSOR>>

;OLD STYLE MACTEN TYPE CALLS

;MACRO TO BUILD A MASK "WID" BITS WIDE, WITH ITS RIGHTMOST BIT
;	IN THE BIT POSITION "POS".
DEFINE MASK.(WID,POS),<<<<1_<WID>>-1>B<POS>>>


;INVSL. POSITIONS VALUE IN MASK TO BE REPLACED BY FLD(VALUE,MASK)
DEFINE	INSVL.(VALUE,MASK),<<<<VALUE>B<POS(<MASK>)>>&<MASK>>>
SUBTTL MOVX

;MOVX - LOAD AC WITH CONSTANT

DEFINE MOVX (AC,MSK)<
   ..MX1==MSK			;;EVAL EXPRESSION IF ANY
IFDEF .PSECT,<
   .IFN ..MX1,ABSOLUTE,<
	MOVE AC,[MSK]>
   .IF ..MX1,ABSOLUTE,<
	..MX2==0		;;FLAG SAYS HAVEN'T DONE IT YET
	IFE <..MX1>B53,<
	  ..MX2==1
	  MOVEI AC,..MX1>	;;LH 0, DO AS RH
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <..MX1>B17,<
	  ..MX2==1
	  MOVSI AC,(..MX1)>>	;;RH 0, DO AS LH
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <<..MX1>B53-^O777777>,<
	  ..MX2==1
	  HRROI AC,<..MX1>>>	;;LH -1
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <<..MX1>B17-^O777777B17>,<
	  ..MX2==1
	  HRLOI AC,(..MX1-^O777777)>> ;;RH -1
	IFE ..MX2,<		;;IF STILL HAVEN'T DONE IT,
	  MOVE AC,[..MX1]>	;;GIVE UP AND USE LITERAL
	>>

IFNDEF .PSECT,<
	..MX2==0		;;FLAG SAYS HAVEN'T DONE IT YET
	IFE <..MX1>B53,<
	  ..MX2==1
	  MOVEI AC,..MX1>	;;LH 0, DO AS RH
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <..MX1>B17,<
	  ..MX2==1
	  MOVSI AC,(..MX1)>>	;;RH 0, DO AS LH
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <<..MX1>B53-^O777777>,<
	  ..MX2==1
	  HRROI AC,<..MX1>>>	;;LH -1
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <<..MX1>B17-^O777777B17>,<
	  ..MX2==1
	  HRLOI AC,(..MX1-^O777777)>> ;;RH -1
	IFE ..MX2,<		;;IF STILL HAVEN'T DONE IT,
	  MOVE AC,[..MX1]>	;;GIVE UP AND USE LITERAL
>
	PURGE ..MX1,..MX2>
SUBTTL CAX - COMPARE MACROS

;CREATE THE CAX MACRO DEFINITIONS

DEFINE	..DOCX (T)<
	IRP T,<
	  DEFINE CAX'T (AC,MSK)<
	    ..CX(T,AC,MSK)>>>

	..DOCX (<,L,LE,E,G,GE,N,A>)  ;DO 8 DEFINITIONS
	PURGE ..DOCX

DEFINE	..CX(T,AC,MSK)<
	  ..CX1==MSK
	IFDEF .PSECT,<
 	.IFN ..CX1,ABSOLUTE,<
	      CAM'T AC,[MSK]>
	.IF ..CX1,ABSOLUTE,<	;;MASK IS TESTABLE
		..CX2==0	;;MARK NOT DONE
	  IFE <..CX1&^O777777B17>,<
		..CX2==1	;;LH 0 CAN DO CAI
	    CAI'T AC,MSK>
	  IFE ..CX2,<		;;MUST USE CAM
	    CAM'T AC,[MSK]>
	PURGE ..CX1,..CX2>>
	IFNDEF .PSECT,<
		..CX2==0	;;MARK NOT DONE
	  IFE <..CX1&^O777777B17>,<
		..CX2==1	;;LH 0 CAN USE CAI
	    CAI'T AC,MSK>
	  IFE ..CX2,<		;;MUST USE CAM
	    CAM'T AC,[MSK]>
	PURGE ..CX1,..CX2>>
SUBTTL	ADDX, SUBX, IMULX, MULX, IDIVX & DIVX MACROS

;ALL MACROS JUST CALL ..AS OR ..OP WHICH DO ALL THE WORK
DEFINE	 ADDX(AC,VAL) <..AS(AC,VAL,ADD,SUB)>
DEFINE	 SUBX(AC,VAL) <..AS(AC,VAL,SUB,ADD)>
DEFINE	IMULX(AC,VAL) <..OP(AC,VAL,IMUL)>
DEFINE	 MULX(AC,VAL) <..OP(AC,VAL,MUL)>
DEFINE	IDIVX(AC,VAL) <..OP(AC,VAL,IDIV)>
DEFINE	 DIVX(AC,VAL) <..OP(AC,VAL,DIV)>

DEFINE	..AS(AC,VAL,OPR,ALT)<
	   ..AS1==-<VAL>	;;GET COMPLIMENT OF VALUE
	IFDEF .PSECT,<
	.IFN ..AS1,ABSOLUTE,<
	     OPR AC,[-..AS1]>	;;MUST USE LITERAL
	.IF ..AS1,ABSOLUTE,<
		..AS2==0	;;MARK NOT DONE
	  IFE <..AS1&^O777777B17>,<
		..AS2==1	;;CAN USE ALTERNATE IMMEDIATE
	    ALT'I AC,..AS1>
	  IFE ..AS2,<
	    ..OP(AC,VAL,OPR)>	;;MUST DO IMMEDIATE OR LITERAL
	PURGE ..AS1,..AS2>>
	IFNDEF .PSECT,<
		..AS2==0	;;MARK NOT DONE
	  IFE <..AS1&^O777777B17>,<
		..AS2==1	;;CAN DO ALTERNATE IMMEDIATE
	    ALT'I AC,..AS1>
	  IFE ..AS2,<		;;MUST DO IMMEDIATE OR LITERAL
	    ..OP(AC,VAL,OPR)>
	PURGE ..AS1,..AS2>>

DEFINE	..OP(AC,VAL,OPR)<
	  ..OP1==VAL
	IFDEF .PSECT,<
 	.IFN ..OP1,ABSOLUTE,<
	      OPR AC,[..OP1]>
	.IF ..OP1,ABSOLUTE,<	;;MASK IS TESTABLE
		..OP2==0	;;MARK NOT DONE
	  IFE <..OP1&^O777777B17>,<
		..OP2==1	;;LH 0 CAN DO IMMEDIATE
	    OPR'I AC,..OP1>
	  IFE ..OP2,<		;;MUST USE LITERAL
	    OPR AC,[..OP1]>
	PURGE ..OP1,..OP2>>
	IFNDEF .PSECT,<
		..OP2==0	;;MARK NOT DONE
	  IFE <..OP1&^O777777B17>,<
		..OP2==1	;;LH 0 CAN USE IMMEDIATE
	    OPR'I AC,..OP1>
	  IFE ..OP2,<		;;MUST USE LITERAL
	    OPR AC,[..OP1]>
	PURGE ..OP1,..OP2>>
SUBTTL TX - TEST MASK

;CREATE THE TX MACRO DEFINITIONS

;THIS DOUBLE IRP CAUSES ALL COMBINATIONS OF MODIFICATION AND TESTING
;TO BE DEFINED

DEFINE ..DOTX (M,T)<
	IRP M,<
	IRP T,<
	  DEFINE TX'M'T (AC,MSK)<
		..TX(M'T,AC,<MSK>)>>>>

	..DOTX (<N,O,Z,C>,<,E,N,A>) ;DO ALL DEFINITIONS
	PURGE ..DOTX

;..TX
;ALL TX MACROS JUST CALL ..TX WHICH DOES ALL THE WORK

DEFINE ..TX(MT,AC,MSK)<
   ..TX1==MSK			;;EVAL EXPRESSION IF ANY
IFDEF .PSECT,<
   .IFN ..TX1,ABSOLUTE,<
	TD'MT AC,[MSK]>
   .IF ..TX1,ABSOLUTE,<		;;MASK MUST BE TESTABLE
	..TX2==0		;;FLAG SAYS HAVEN'T DONE IT YET
	IFE <..TX1&^O777777B17>,<
	  ..TX2==1		;;LH 0, DO AS RH
	  TR'MT AC,..TX1>
	IFE ..TX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <..TX1&^O777777>,<
	  ..TX2==1		;;RH 0, DO AS LH
	  TL'MT AC,(..TX1)>>
	IFE ..TX2,<		;;IF HAVEN'T DONE IT YET,
	  IFE <<..TX1>B53-^O777777>,< ;;IF LH ALL ONES,
	    ..TX3 (MT,AC)>>	;;TRY Z,O,C SPECIAL CASES
	IFE ..TX2,<		;;IF STILL HAVEN'T DONE IT,
	  TD'MT AC,[..TX1]>	;;MUST GIVE UP AND USE LITERAL
	PURGE ..TX1,..TX2>>
IFNDEF .PSECT,<
	..TX2==0		;;FLAG SAYS HAVEN'T DONE IT YET
	IFE <..TX1&^O777777B17>,<
	  ..TX2==1		;;LH 0, DO AS RH
	  TR'MT AC,..TX1>
	IFE ..TX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <..TX1&^O777777>,<
	  ..TX2==1		;;RH 0, DO AS LH
	  TL'MT AC,(..TX1)>>
	IFE ..TX2,<		;;IF HAVEN'T DONE IT YET,
	  IFE <<..TX1>B53-^O777777>,< ;;IF LH ALL ONES,
	    ..TX3 (MT,AC)>>	;;TRY Z,O,C SPECIAL CASES
	IFE ..TX2,<		;;IF STILL HAVEN'T DONE IT,
	  TD'MT AC,[..TX1]>	;;MUST GIVE UP AND USE LITERAL
	PURGE ..TX1,..TX2>>
;SPECIAL CASE FOR LH ALL ONES

DEFINE ..TX3 (MT,AC)<
	IFIDN <MT><Z>,<		;;IF ZEROING WANTED
	  ..TX2==1
	  ANDI AC,^-..TX1>	;;CAN DO IT WITH ANDI
	IFIDN <MT><O>,<		;;IF SET TO ONES WANTED
	  ..TX2==1
	  ORCMI AC,^-..TX1>	;;CAN DO IT WITH IORCM
	IFIDN <MT><C>,<		;;IF COMPLEMENT WANTED
	  ..TX2==1
	  EQVI AC,^-..TX1>>	;;CAN DO IT WITH EQV
;VARIENT MNEMONICS FOR TX DEFINITIONS

DEFINE IORX (AC,MSK)<
	TXO AC,<MSK>>

DEFINE ANDX (AC,MSK)<
	TXZ AC,<^-<MSK>>>

DEFINE XORX (AC,MSK)<
	TXC AC,<MSK>>
SUBTTL SUBFUNCTION MACROS

;.IF0 CONDITION, ACTION IF CONDITION 0, ACTION OTHERWISE

DEFINE .IF0 (COND,THEN,ELSE)<
	..IFT==COND		;;GET LOCAL VALUE FOR CONDITION
	IFE ..IFT,<
	THEN
	..IFT==0>		;;RESTORE IN CASE CHANGED BY NESTED .IF0
	IFN ..IFT,<
	ELSE>>

;CASE (NUMBER,<FIRST,SECOND,...,NTH>)

DEFINE .CASE (NUM,LIST)<
	..CSN==NUM
	..CSC==0
	IRP LIST,<
	IFE ..CSN-..CSC,<
	  STOPI
	  ..CAS1 (LIST)>
	..CSC==..CSC+1>>

DEFINE ..CAS1 (LIST)<
	LIST>

;TEST FOR FULL WORD, RH, LH, OR ARBITRARY BYTE

DEFINE ..TSIZ (SYM,MSK)<
	SYM==3			;;ASSUME BYTE UNLESS...
	IFE <MSK>+1,<SYM=0>	;;FULL WORD IF MASK IS -1
	IFE <MSK>-^O777777,<SYM==1> ;;RH IF MASK IS 777777
	IFE <MSK>-^O777777B17,<SYM==2>> ;;LH IF MAST IS 777777,,0

;TEST FOR LOC BEING AN AC -- SET SYM TO 1 IF AC, 0 IF NOT AC

DEFINE ..TSAC (SYM,LOC)<
	IFNDEF .PSECT,<
	SYM==0			;;ASSUME NOT AC UNLESS...
	..TSA1==<Z LOC>		;;LOOK AT LOC
	  IFE ..TSA1&^O777777777760,<SYM==1> ;;AC IF VALUE IS 0-17
	>
	IFDEF .PSECT,<
	SYM==0			;;ASSUME NOT AC UNLESS...
	..TSA1==<Z LOC>		;;LOOK AT LOC
	.IF ..TSA1,ABSOLUTE,<	;;SEE IF WE CAN TEST VALUE
	  IFE ..TSA1&^O777777777760,<SYM==1>> ;;AC IF VALUE IS 0-17
	PURGE ..TSA1>>

;FUNCTION TO TEST FOR MASK CONTAINING EXACTLY ONE BIT. RETURNS
;1 IFF LEFTMOST BIT AND RIGHTMOST BIT ARE SAME

DEFINE ..ONEB (SYM,MSK)<
	SYM==<<<-<MSK>>&<MSK>>&<1B<^L<MSK>>>>>

SUBTTL DEFSTR - DEFINE DATA STRUCTURE

;DEFINE DATA STRUCTURE
; NAM - NAME OF STRUCTURE AS USED IN CODE
; LOCN - ADDRESS OF DATA
; POS - POSITION OF DATA WITHIN WORD (RIGHTMOST BIT NUMBER)
; SIZ - SIZE OF DATA (IN BITS) WITHIN WORD

DEFINE DEFSTR (NAM,LOCN,POS,SIZ)<
	NAM==<-1B<POS>+1B<POS-SIZ>> ;;ASSIGN SYMBOL TO HOLD MASK
	IF1,<IFDEF %'NAM,<PRINTX ?NAM ALREADY DEFINED>>
	DEFINE %'NAM (OP,AC,Y,MSK)<	;;DEFINE MACRO TO HOLD LOCATION
	IFDIF <Y><>,<
	OP (<AC>,LOCN'+'Y,MSK)>
	IFIDN <Y><>,<
	OP (<AC>,LOCN''Y,MSK)>>>

;ALTERNATE FORM OF DEFSTR -- TAKES MASK INSTEAD OF POS,SIZ

DEFINE MSKSTR (NAM,LOCN,MASK)<
	NAM==MASK		;;ASSIGN SYMBOL TO HOLD MASK
	IF1,<IFDEF %'NAM,<PRINTX ?NAM ALREADY DEFINED>>
	DEFINE %'NAM (OP,AC,Y,MSK)<	;;DEFINE MACRO TO HOLD LOCATION
	IFDIF <Y><>,<
	OP (<AC>,LOCN'+'Y,MSK)>
	IFIDN <Y><>,<
	OP (<AC>,LOCN''Y,MSK)>>>

;..STR0 - PROCESS INSTANCE OF STRUCTURE USAGE, SINGLE STRUCTURE CASE.

DEFINE ..STR0 (OP,AC,STR,Y)<
	IFNDEF STR,<PRINTX STR IS NOT DEFINED
	  OP (<AC>,Y,FWMASK)>	;;RESERVE A WORD, ASSUME WORD MASK
	IFDEF STR,<
	IFNDEF %'STR,<
	  OP (<AC>,Y,STR)>	;;ASSUME NO OTHER LOCN
	IFDEF %'STR,<
	  %'STR (OP,<AC>,Y,STR)>>> ;;DO IT
;..STR1, ..STR2, ..STR3, AND ..STR4 ARE INTERNAL MACROS FOR PROCESSING
;INSTANCES OF STRUCTURE USAGE.

DEFINE ..STR1 (OP,AC,STR,Y,CLL)<
	..NS==0			;;INIT COUNT OF STR'S
	IRP STR,<..NS=..NS+1>	;;COUNT STR'S
	IFE ..NS,<PRINTX ?EMPTY STRUCTURE LIST, OP>
	IFE ..NS-1,<		;;THE ONE CASE, CAN DO FAST
	  ..STR0 (OP,<AC>,<STR>,Y)>
	IFG ..NS-1,<		;;MORE THAN ONE, DO GENERAL CASE
	..ICNS			;;INIT REMOTE MACRO
	..CNS (<CLL (OP,<AC>,,>) ;;CONS ON CALL AND FIRST ARGS
	IRP STR,<		;;DO ALL NAMES IN LIST
	  IFNDEF STR,<PRINTX STR NOT DEFINED>
	  IFDEF STR,<
	  IFNDEF %'STR,<
	  ..CNS (<,STR,Y>)>	;;ASSUME NO OTHER LOCN
	  IFDEF %'STR,<
	  %'STR (..STR2,,Y,STR)> ;;STR MACRO WILL GIVE LOCN TO ..STR2
	  ..CNS (<)>)		;;CLOSE ARG LIST
	  ..GCNS		;;DO THIS AND PREVIOUS NAME
	  ..ICNS		;;REINIT CONS
	  ..CNS (<CLL (OP,<AC>>) ;;PUT ON FIRST ARGS
	  IFNDEF %'STR,<
	  ..CNS (<,STR,Y>)>	;;ASSUME NO OTHER LOCN
	  IFDEF %'STR,<
	  %'STR (..STR2,,Y,STR)>>> ;;PUT ON THIS ARG, END IRP
	..CNS (<,,)>)		;;CLOSE ARG LIST
	..GCNS>>		;;DO LAST CALL

;..STR2 -- CALLED BY ABOVE TO APPEND STRUCTURE NAME AND LOC TO ARG LIST

DEFINE ..STR2 (AA,LOC,STR)<
	..CNS (<,STR,LOC>)>	;;CONS ON NEXT ARG PAIR

;..STR3 -- CHECK FOR ALL STRUCTURES IN SAME REGISTER

DEFINE ..STR3 (OP,AC,S1,L1,S2,L2)<
	IFDIF <L1><L2>,<
	  IFNB <L1>,<
	    OP (<AC>,L1,..MSK)	;;DO ACCUMULATED STUFF
	    IFNB <L2>,<PRINTX S1 AND S2 ARE IN DIFFERENT WORDS>>
	  ..MSK==0>		;;INIT MASK
	IFNB <L2>,<
	  ..MSK=..MSK!<S2>>>

;..STR4 -- COMPARE SUCCESSIVE ITEMS, DO SEPARATE OPERATION IF
;DIFFERENT WORDS ENCOUNTERED

DEFINE ..STR4 (OP,AC,S1,L1,S2,L2)<
	IFDIF <L1><L2>,<	;;IF THIS DIFFERENT FROM PREVIOUS
	  IFNB <L1>,<
	    OP (<AC>,L1,..MSK)>	;;DO PREVIOUS
	  ..MSK==0>		;;REINIT MASK
	IFNB <L2>,<
	  ..MSK=..MSK!<S2>>>	;;ACCUMULATE MASK

;..STR5 - SAME AS ..STR4 EXCEPT GIVES EXTRA ARG IF MORE STUFF TO
;FOLLOW.

DEFINE ..STR5 (OP,AC,S1,L1,S2,L2)<
	IFDIF <L1><L2>,<	;;IF THIS DIFFERENT FROM PREVIOUS,
	  IFNB <L1>,<
	    IFNB <L2>,<		;;IF MORE TO COME,
		OP'1 (AC,L1,..MSK)> ;;DO VERSION 1
	    IFB <L2>,<		;;IF NO MORE,
		OP'2 (AC,L1,..MSK)>> ;;DO VERSION 2
	  ..MSK==0>		;;REINIT MASK
	IFNB <L2>,<
	  ..MSK=..MSK!<S2>>>	;;ACCUMULATE MASK

;'REMOTE' MACROS USED TO BUILD UP ARG LIST

;INITIALIZE CONS -- DEFINES CONS

DEFINE ..ICNS <
   DEFINE ..CNS (%%%)<
	..CNS2 <%%%>,>

   DEFINE ..CNS2 (NEW,OLD)<
	DEFINE ..CNS (%%%)<
	  ..CNS2 <%%%>,<OLD'NEW>>>
   >

;GET CONS -- EXECUTE STRING ACCUMULATED

DEFINE ..GCNS <
   DEFINE ..CNS2 (NEW,OLD)<
	  OLD>			;;MAKE ..CNS2 DO THE STUFF
	..CNS ()>		;;GET ..CNS2 CALLED WITH THE STUFF
SUBTTL STKVAR - STACK VARIABLE FACILITY

;MACRO FOR ALLOCATING VARIABLES ON THE STACK. ITS ARGUMENT IS
;A LIST OF ITEMS.  EACH ITEM MAY BE:
; 1. A SINGLE VARIABLE WHICH WILL BE ALLOCATED ONE WORD
; 2. A VARIABLE AND SIZE PARAMETER WRITTEN AS <VAR,SIZ>.  THE
;	VARIABLE WILL BE ALLOCATED THE SPECIFIED NUMBER OF WORDS.
;RETURN FROM A SUBROUTINE USING THIS FACILITY MUST BE VIA
;RET OR RETSKP.  A DUMMY RETURN WHICH FIXES UP THE STACK IS PUT ON
;THE STACK AT THE POINT THE STKVAR IS ENCOUNTERED.
;WITHIN THE RANGE OF A STKVAR, PUSH/POP CANNOT BE USED AS THEY WILL
;CAUSE THE VARIABLES (WHICH ARE DEFINED AS RELATIVE STACK LOCATIONS)
;TO REFERENCE THE WRONG PLACE.
;TYPICAL USE:   STKVAR <AA,BB,<QQ,5>,ZZ>


DEFINE STKVAR (ARGS)<
	..STKR==10		;;REMEMBER RADIX
	RADIX 8
	..STKN==0
	IRP ARGS,<
	  .STKV1 (ARGS)>
	$CALL	.STKST
	 ..STKN,,..STKN
	RADIX ..STKR
	PURGE ..STKN,..STKR,..STKQ
   >

;INTERMEDIATE MACRO TO PEAL OFF ANGLEBRACKETS IF ANY

DEFINE .STKV1 (ARG)<
	.STKV2 (ARG)>

;INTERMEDIATE MACRO TO CALCULATE OFFSET AND COUNT VARIABLES

DEFINE .STKV2 (VAR,SIZ)<
	IFB <SIZ>,<..STKN==..STKN+1>
	IFNB <SIZ>,<..STKN==..STKN+SIZ>
	..STKQ==..STKN+1
	.STKV3 (VAR,\..STKQ)>

;INNERMOST MACRO TO DEFINE VARIABLE

DEFINE .STKV3 (VAR,LOC)<
   IFDEF VAR,<.IF VAR,SYMBOL,<PRINTX STKVAR VAR ALREADY DEFINED>>
	DEFINE VAR<-^O'LOC(P)>
	$'VAR==<Z VAR>>		;SYMBOL FOR DDT
SUBTTL TRVAR - TRANSIENT VARIABLE FACILITY

;TRANSIENT (STACK) VARIABLE FACILITY - EQUIVALENT TO STKVAR
;EXCEPT ALLOWS VARIABLES TO BE USED WITHIN LOWER LEVEL ROUTINES
;AND AFTER OTHER THINGS HAVE BEEN PUSHED ON STACK.
;N.B. USES .FP AS FRAME POINTER - MUST NOT BE CHANGED WHILE
;VARIABLES IN USE.


DEFINE TRVAR (VARS)<
	..TRR==10		;;REMEMBER CURRENT RADIX
	RADIX 8
	..NV==1			;;INIT COUNT OF STACK WORDS
	IRP VARS,<
	  .TRV1 (VARS)>		;;PROCESS LIST
	$CALL	.TRSET		;;ALLOCATE STACK SPACE, SET UP .FP
	 ..NV-1,,..NV-1
	RADIX ..TRR		;;RESTORE RADIX
	PURGE ..TRR,..NV>	;;CLEAN UP

DEFINE .TRV1 (VAR)<
	.TRV2 (VAR)>		;;PEEL OFF ANGLEBRACKETS IF ANY

DEFINE .TRV2 (NAM,SIZ)<
	.TRV3 (NAM,\..NV)	;;DEFINE VARIABLE
	IFB <SIZ>,<..NV=..NV+1>
	IFNB <SIZ>,<..NV=..NV+SIZ>>

DEFINE .TRV3 (NAM,LOC)<
   IFDEF NAM,<.IF NAM,SYMBOL,<PRINTX TRVAR NAM ALREADY DEFINED>>
	DEFINE NAM<^O'LOC(.FP)>
	$'NAM==<Z NAM>>		;;SYMBOL FOR DDT

;AC VARIABLE FACILITY

.FPAC==P1			;FIRST PRESERVED AC
.NPAC==10			;NUMBER OF PRESERVED AC'S

DEFINE ACVAR (LIST)<
	..NAC==0		;;INIT NUMBER OF ACS USED
	IRP LIST,<
	  .ACV1 (LIST)>		;;PROCESS ITEMS
	.ACV3 (\..NAC)>		;;SAVE ACS USED

DEFINE .ACV1 (ITEM)<
	.ACV2 (ITEM)>		;;PEEL OFF ANGLEBRACKETS IF ANY

DEFINE .ACV2 (NAM,SIZ)<
	NAM=.FPAC+..NAC		;;DEFINE VARIABLE
	IFB <SIZ>,<..NAC=..NAC+1>
	IFNB <SIZ>,<..NAC=..NAC+SIZ>>

DEFINE .ACV3 (N)<
	IFG N-.NPAC,<PRINTX ?TOO MANY ACS USED>
	IFLE N-4,<
	  $CALL .SAVE'N>	;;SAVE ACTUAL NUMBER USED
	IFG N-4,<
	  $CALL .SAVE8>>	;;SAVE ALL
SUBTTL	SAVE MACRO DEFINITION

;VARIABLE SAVE FACILITY -- ACCEPTS A LIST OF ARGUMENTS
;	$SAVE <LIST-OF-VARIABLES>
;AUTOMATICALLY RESTORES ALL NAMED VARIABLES ON RETURN FROM ROUTINE
;  SUPPORTS +1 OR +2 RETURNS

;IF AN APPROPRIATE CO-ROUTINE IS DEFINED IN GLXCOM FOR THE DESIRED
;AC'S IT IS USED, OTHERWISE OPEN PUSHES AND A DUMMY RESTORE ROUTINE
;ARE GENERATED.

;IF THE SAME SET OF VARIABLES IS SAVED MORE THAN ONCE IN A PROGRAM,
;THE RESTORE ROUTINE GENERATED IN THE LITERALS IS SHARED BETWEEN THE
;TWO SAVES.


DEFINE $SAVE(ARG,%L1)<
	.NVR==0			;;INITILIZE VARIABLE COUNT
	.ACM==0			;;INITIALIZE AC MASK

	IRP ARG,<		;;BUILD AC MASK AND PUSH OTHER VARIABLES
		..TSAC(.ACB,ARG)		;;IS IT AN AC?
		IFN .ACB,<.ACM==.ACM!1B<ARG>>	;;YES -- BUILD MASK
		IFE .ACB,<			;;NO -- PUSH IT
		IFE .NVR,<			;;FIRST VARIABLE?
		    CAIA			;;YES -- DO SKIP CODE
		    LSTOF.
		    JRST %L1>
		  ..PUSH(ARG,\<.NVR+1>)>>	;;PUSH IT AND BUMP COUNT

	IFN .ACM,<	;;CHECK FOR PROPER AC CO-ROUTINE
	    IFE <.ACM-17B<T4>>,<.ACM==0
				$CALL .SAVET>
	    IFE <.ACM-377B<.A16>>,<.ACM==0
				$CALL .SAVE8>
	    IFE <.ACM-17B<P4>>,<.ACM==0
				$CALL .SAVE4>
	    IFE <.ACM-7B<P3>>,<.ACM==0
				$CALL .SAVE3>
	    IFE .NVR,<	;;DON'T DO CO-ROUTINE IF OTHER VARIABLES
	    IFE <.ACM-3B<P2>>,<.ACM==0
				$CALL .SAVE2>
	    IFE <.ACM-1B<P1>>,<.ACM==0
				$CALL .SAVE1>
	    IFE <.ACM-1B<.A13>>,<.ACM==0
				$CALL .SV13>
	    IFE <.ACM-1B<.A14>>,<.ACM==0
				$CALL .SV14>
	    IFE <.ACM-1B<.A15>>,<.ACM==0
				$CALL .SV15>
	    IFE <.ACM-1B<.A16>>,<.ACM==0
				$CALL .SV16>
	    >>

	IFN .ACM,<	;;PUSH THE AC'S IF NOT DONE BY CO-ROUTINE
	    IFE .NVR,<			;;FIRST ONE?
		CAIA			;;YES -- DO SKIP CODE
		LSTOF.
		JRST %L1>

	    .ACB==0			;;START AT AC0
	REPEAT ^D16,<			;;LOOP THRU ALL 16
	    IFN <.ACM&1B<.ACB>>,<	;;WAS IT GIVEN?
		..PUSH(\.ACB,\<.NVR+1>)>;;YES -- PUSH IT
		.ACB==.ACB+1>>		;;STEP TO NEXT

	IFN .NVR,<	;;BUILD DUMMY ROUTINE TO RESTORE ALL PUSHES
	    PUSH P,[[CAIA		;;HERE FOR NON SKIP RETURN
		     AOS -.NVR(P)	;;HANDLE SKIP RETURN
	    REPEAT .NVR,<..POP(\.NVR)>	;;POP ALL THINGS STACKED
		     POPJ P,0]]>	;;RETURN TO CALLER
%L1:!	LSTON.> ;END OF $SAVE DEFINITION

	DEFINE ..PUSH(ARG,.NVX)<
		PUSH P,ARG
		DEFINE .NV'.NVX<ARG>
		.NVR==.NVR+1>

	DEFINE ..POP(.NVX)<
		POP P,.NV'.NVX
		PURGE .NV'.NVX
		.NVR==.NVR-1>
SUBTTL	LOAD,STORE,INCR,DECR,ZERO

DEFINE LOAD (AC,Y,STR)<
	IFNB <STR>,<..STR0 (..LDB,AC,STR,Y)>
	IFB  <STR>,<MOVE AC,Y>>		;;DEFAULT TO FULL WORD MOVE

   DEFINE ..LDB (AC,LOC,MSK)<
	..TSIZ (..PST,MSK)
	.CASE ..PST,<<
		MOVE AC,LOC>,<
		HRRZ AC,LOC>,<
		HLRZ AC,LOC>,<
		LDB AC,[POINTR (LOC,MSK)]>>>

DEFINE STORE (AC,Y,STR)<
	IFNB <STR>,<..STR0 (..DPB,AC,STR,Y)>
	IFB  <STR>,<MOVEM AC,Y>>	;;DEFAULT FULL WORD MOVE

   DEFINE ..DPB (AC,LOC,MSK)<
	..TSIZ (..PST,MSK)
	.CASE ..PST,<<
		MOVEM AC,LOC>,<
		HRRM AC,LOC>,<
		HRLM AC,LOC>,<
		DPB AC,[POINTR (LOC,MSK)]>>>

DEFINE INCR (Y,STR)<
	IFNB <STR>,<..STR0 (.INCR0,,<STR>,Y)>
	IFB  <STR>,<AOS Y>>		;;DEFAULT FULL WORD INCR

   DEFINE .INCR0 (AC,LOC,MSK)<
	..PST==MSK-FWMASK
	.IF0 ..PST,<
		AOS LOC>,<	;;FULL WORD, CAN USE AOS
		$CALL .AOS	;;MUST USE SUPPORT CODE
		LSTOF.
		JUMP [POINTR(LOC,MSK)]
		LSTON.>>

DEFINE DECR (Y,STR)<
	IFNB <STR>,<..STR0 (.DECR0,,<STR>,Y)>
	IFB  <STR>,<SOS Y>>		;;DEFAULT FULL WORD DECR

   DEFINE .DECR0 (AC,LOC,MSK)<
	..PST==MSK-FWMASK
	.IF0 ..PST,<
		SOS LOC>,<	;;FULL WORD, CAN USE SOS
		$CALL .SOS	;;MUST USE SUPPORT CODE
		LSTOF.
		JUMP [POINTR(LOC,MSK)]
		LSTON.>>
DEFINE ZERO (Y,STR)<
	IFNB <STR>,<..STR1 (..TQZ,,<STR>,Y,..STR4)>
	IFB  <STR>,<SETZM Y>>		;;DEFAULT FULL WORD ZERO

   DEFINE ..TQZ (AC,LOC,MSK)<
	..TSIZ (..PST,MSK)	;;SET ..PST TO CASE NUMBER
	.CASE ..PST,<<
		SETZM LOC>,<	;;FULL WORD
		HLLZS LOC>,<	;;RH
		HRRZS LOC>,<	;;LH
	  ..TSAC (..ACT,LOC)	;;SEE IF LOC IS AC
	  .IF0 ..ACT,<
		$CALL .ZERO	;;NO -- MUST USE SUPPORT CODE
		LSTOF.
		JUMP [POINTR(LOC,MSK)]
		LSTON.>,<
		..TX (Z,LOC,MSK)>>>>
SUBTTL $BGINT,$DEBRK - Interrupt context switching

;At the beginning of each interrupt level routine, the first instruction
; is a $BGINT, with the address field indicating which priority level
; this interrupt is on.  When the interrupt is over, the $DEBRK instruction
; is used, which resumes non-interrupt level context and dismisses the
; interrupt.  Interrupt context gives all ACs and a new Stack for use.

;Establish interrupt level context

	DEFINE $BGINT(LVL)<
	  IFG LVL-INT.LV,<PRINTX ?Level LVL interrupts not supported>
	  .BGINT.(\LVL) >	;;END OF $BGINT DEFINITION

	DEFINE .BGINT.(A)<$CALL	I%INT'A>



;Return to normal (non-interrupt) level

	DEFINE $DEBRK<
	  $RET				;WILL INVOKE RIGHT ROUTINE
	> ;END OF $DEBRK DEFINITION
SUBTTL $BUILD,$SET,$EOB - Build pre-formed data blocks

;Many components have a need to build simple and complex blocks which
;	contain pre-formatted data, such as FOBs,IBs and other blocks
;	which are made up of several words, each containing from 1 to several
;	fields.  Since data structures change, these blocks should not be
;	just created using EXP or whatever.  These macros will take values
;	and install them in the right field and word of a structure.

; Start off a structure, argument is the size of the structure.

	DEFINE $BUILD(SIZE)<
	  IFDEF ..BSIZ,<PRINTX ?Missing $EOB after a $BUILD>
	  ..BSIZ==0			;;START COUNTER
	  ..BLOC==.			;;REMEMBER OUR STARTING ADDRESS
	  REPEAT SIZE,<			;;FOR EACH WORD IN THE BLOCK
		BLD0.(\..BSIZ,0)	;;ZERO OUT IT'S ACCUMULATOR
		..BSIZ==..BSIZ+1>	;;AND STEP TO NEXT
	>;END OF $BUILD DEFINITION

; For each value installed somewhere in the structure, set it into the block
; 	Arguments are word offset,field in word (optional) and value to set.

	DEFINE $SET(OFFSET,STR,VALUE),<
	  IFNDEF ..BSIZ,<PRINTX ?$SET without previous $BUILD>
	  IFNB <STR>,<..STR0 (..SET,<VALUE>,STR,OFFSET)>
	  IFB  <STR>,<..STR0 (..SET,<VALUE>,FWMASK,OFFSET)>
	> ; END OF $SET DEFINITION

	DEFINE ..SET (VALUE,LOC,MSK) <
	  IFGE <<<LOC>&777777>-..BSIZ>,<
		PRINTX ?WORD offset greater than $BUILD size parameter>
	  SET0. (\<LOC>,MSK,<VALUE>)
	> ;END ..SET DEFINITION

; After all values are declared, the block must be closed to do its actual
;	creation.

	DEFINE $EOB,<
	  IFNDEF ..BSIZ,<PRINTX ?$EOB without previous $BUILD>
	  IFN <.-..BLOC>,<PRINTX ?Address change between $BUILD and $EOB>
	  LSTOF.			;;DON'T SHOW THE BLOCK
	  ..T==0
	  REPEAT ..BSIZ,<
	    BLD0.(\..T,1)		;;STORE EACH WORD
	    ..T==..T+1 >
	  PURGE ..BSIZ,..T,..BLOC	;;REMOVE SYMBOLS
	  LSTON.
	>; END OF $EOB DEFINITION

	DEFINE BLD0.(N,WHAT),<
	  IFE WHAT,<..T'N==0>
	  IFN WHAT,<EXP ..T'N
		    PURGE ..T'N>
	> ;END OF BLD0. DEFINITION

	DEFINE SET0.(LOC,MSK,VALUE),<
	IFN <<..T'LOC>&MSK>,<PRINTX ?Initial field not zero in $SET>
	  ..TVAL==<VALUE>
	  ..TMSK==<MSK>
	  ..T'LOC==..T'LOC!<FLD(..TVAL,..TMSK)>
	  PURGE ..TVAL,..TMSK
	>;END OF SET0. DEFINITION
SUBTTL	$CALL,$RETT,$RETF,$RETE,$RET Uniform Call/Return Mechanisms

;	All routines which follow GALAXY Conventions should call
;  library routines and internal routines which return TRUE/FALSE
;  values with the $CALL Macro.  This provides a uniform calling
;  mechanism.

; 	All routines which follow GALAXY conventions should return
;  via one of the return instructions. These instructions set the contents
;  of the true/false register, TF and then return via POPJ P,.

;	If a routine wishes to merely pass on the value of the TF register
;  it should return using a $RET


	OPDEF	$CALL	[PUSHJ P,0]
	.NODDT	$CALL

; $RETE is the instruction used to return FALSE from a routine and also
; set a specific error code in the first status register, S1.  The argument
; provided to the instruction is a 3 letter GLXLIB canonical error code.
; The effect of the $RETE instruction is to place the value of the
; GLXLIB error code into S1, place FALSE into TF and return via POPJ.

	DEFINE $RETE (COD) <
	  $CALL	.RETE			;;CALL THE ERROR ROUTINE
		LSTOF.
	  JUMP	ER'COD'$
		LSTON.>			;;END OF $RETE DEFINITION


;$RETT is the instruction used to place a value of TRUE into the TF register
;  and return from the routine.  This instruction is used when a routine
;  wishes to indicate to its caller that it is returning successfully.

;	$RETT is defined during the PROLOG macro


;		OPDEF	$RETT [PJRST .RETT]


;$RETF is the instruction used to place a value of FALSE into the TF register
;  and return from the routine.  This instruction is used when a routine
;  wishes to indicate to its caller that is returning unsuccessfully.

;	$RETF is defined during the PROLOG macro

;		OPDEF	$RETF [PJRST .RETF]


;$RET is the instruction used to return the last value of TF to the caller

;	OPDEF	$RET	[POPJ P,]	;;RETURN CURRENT VALUE OF TF

;$RETIF is the instruction used to RETurn If True
;$RETIT	is the instruction used to RETurn If False
;	These Pseudo-ops are defined in the PROLOG macro

;		OPDEF	$RETIT	[JUMPT	.POPJ]

;		OPDEF	$RETIF	[JUMPF	.POPJ]

SUBTTL $GDATA Macro - Runtime System Data Area control

;This macro is used to define impure storage areas.  The actual
;areas are created at run-time by the memory manager.  The first argument
; is the name of the word(s) to be allocated. This name may be referenced
; as any other labelled location.  The second argument is the number of
; words to allocate.  If omitted, this defaults to 1.

;In order to facilitate debugging of new library routines, the $DATA and
;	$GDATA macros produce BLOCK pseudo-op type locations when used
;	in a module whose PROLOG indicates it is not part of the library.
; 	This means that a new library module may be loaded with a test program
;	as a non-library piece of code while it is being debugged.

; $GDATA is exactly like $DATA, except that the location defined
;	is GLOBAL, that is, available to other programs.

	DEFINE $GDATA(NAM,SIZ<1>)<
	  INTERN NAM
	  $DATA(NAM,<SIZ>)
	> ;END OF $GDATA DEFINITION
SUBTTL	$FATAL, and $WARN Macro definitions

;$FATAL is provided as a short form STOP code.  It should
;be used when it is impossible to proceed because
;the program doesn't have proper priviledges or can't find a required
;file -- or any other occassion where the full stopcode information
;is irrelevant or misleading


;CALL	$FATAL <any valid $TEXT string argument>
;

DEFINE $FATAL (STRING) <
	$CALL	.STOP
	LSTOF.
	JUMP	[XWD 0,[ITEXT (<STRING>)]
		 EXP %%.MOD]
	LSTON. > ;END OF $FATAL DEFINITION

;$WARN May be used when it is desired to issue a warning on the
;users terminal.

;CALL	$WARN <any valid $TEXT string argument>
;
DEFINE	$WARN (STRING) <
IFE %%.OTS,<DEFINE $WARN (MSG) <
		$TEXT (T%TTY,<% ^W6/[%%.MOD]/ MSG>)>>
IFN %%.OTS,<DEFINE $WARN (MSG) <
		$TEXT (T%TTY,<% ^W6/IIB+IB.PRG/ ^W/[%%.MOD]/ MSG>)>>
	$WARN <STRING>> ;END OF $WARN DEFINITION
SUBTTL	$STOP - Cause a STOP CODE to occur

; The $STOP macro generates a call to the .STOP routine in GLXCOM,
;	which processes the information imbedded in the $STOP parameter
;	area.  Modules using the $STOP macro should begin with a PROLOG
;	to set up the module name symbol %%.MOD or should define this
;	symbol separately.


;For each $STOP there is a unique label made, using the 3 letter
;	code provided.  The label is 'S..xxx' where the xxx is the 3 letter
;	code.  This label is declared global, to insure unique STOP
;	CODE names.

;The macro call is:
;	$STOP(CODE,STRING)

;WHERE	CODE = A UNIQUE 3 CHARACTER INDICATION OF THE STOP CODE
;  AND
;STRING IS AN EXPANDED STRING ASSOCIATED WITH THE ERROR CONDITION
; I.E.:	$STOP(NFP,No free pages)
;	WILL EXPAND TO:   PUSHJ	P,.STOP
;			  JUMP	 [XWD 'NFP',[ITEXT (No free pages)]
;				  EXP %%.MOD ]



DEFINE	$STOP(CODE,STRING),<
S..'CODE::!	$CALL .STOP
		LSTOF.
		JUMP [XWD ''CODE'',[ITEXT (<STRING>)]
			EXP %%.MOD]
		LSTON.	> ;END OF $STOP DEFINITION
SUBTTL $TEXT - Interface to the T%TEXT routine

; The $TEXT macro is used to do all formatted ASCII output involving
;	strings and/or variables.  The macro takes two arguments.
;	The first argument is the address of a routine to call when T%TEXT
;	actually has a single right justified 7 bit ASCII character to output
;	from its arguments.  The specified routine will be called with the
;	character in S1 and should return TRUE or FALSE in S1.  A value of
;	FALSE will cause a STOP CODE to occur.
;	If the first argument is null, i.e. left blank, then a default
;	routine will be called, specified at initialization.
;	If the first argument is <-1,,ADDR>, it is a IDPB style byte pointer
;	for GLXTXT to store bytes into.

;	The second argument is a text string containing characters to output
;	and imbedded argument specifiers for substitutable parameters to be
;	merged with constant data.

;	If no specifier precedes a string in the second argument, it is
;	assumed to be straight string data to be passed to the output routine
;	directly.  On the other hand, substitutable parameters are described
;	by:	^<QUALIFIER>[OPT. SPACING]/<ADDRESS-OF-VARIABLE>[OPTIONAL <,MASK>]/
;	Where the qualifier is one of the recognized single letter argument
;	types (See next page), and the address and optional mask are two
;	36 bit quantities, such as might be passed to LOAD/STORE. These
;	addresses can contain indexing and/or indirection ,may point to
;	the accumulators or the stack.

;	Each $TEXT instruction normally ends in a "free" carriage return
;	line feed sequence. That is, each $TEXT instruction produces one
;	line of output.  However, through use of the qualifiers 0,A,M,J,K and L,
;	output can be formatted to produce multiple lines via a single $TEXT
;	or one line via multiple $TEXTS. ^0 gives a null (0) terminator in place of CRLF.

; NOTE:	The $TEXT macro is a pseudo-instruction, and as such, it may be skipped
;	over to avoid its execution. Also, all accumulators are guaranteed
;	preserved .

;	Example:
;	   $TEXT(PUTCHR,<This is your PPN: ^P/MYPPN/ for today.>)
;		1. Prints (using the routine PUTCHR for output) the string,
;		    "This is your PPN: "
;		2. Prints the contents of location MYPPN as a TOPS-10 PPN.
;		3. Prints the string " for today."
;		4. Prints a <CRLF> to produce the end of the line.
;	Example:
;	   $TEXT(<-1,,LINBUF>,<File ^D/FB%STS(P1),FBS%FN/ is named ^F/@S1/^A>)
;		1. Prints the string "File ", depositing chars into the user buffer LINBUF
;		2. Prints the "loaded" contents of FB%STS(P1),FBS%FN as
;		    a decimal number
;		3. Prints the string " is named "
;		4. Prints the contents of the FD pointed to by AC S1 as
;		    a file specification.
;		5. Does not produce a <CRLF> sequence, since the ^A qualifier
;		    specifies that we supress it.
;	Optionally, any output field may be right or left justified or
;	centered.  The information used to do this appears between the
;	qualifier symbol and the slash which starts the address of the
;	field to be output.  The justification information consists of
;	three parts, two of which are optional.  The first piece of the
;	justification information is the width of the field. This is given
;	in Radix 10. and can be any number greater than zero.  The second
;	piece is a one letter code telling the Text processor which type
;	of justification to use. This can be "L" for left justification,
;	"R" for right justification or "C" for centering.  If this field
;	is omitted, the default is right justification for numeric items
;	(I.E. ^O and ^D), and left justification for all other types.
;	The third, optional, part is a single character which will be the
;	character used to do any padding necessary for the justification.
;	If the character is given, the justification code must be given also.
;	If the padding character is omitted, it defaults to blanks.

;	Example:
;	  $TEXT(PUTCHR,<^D10L*/S1/  ^F30/@FILSPC/  ^T40C/FOO(S2)>)
;		1. Prints the decimal number in S1, in a field of 10. characters.
;		   The number will be left justified, the remainder of the
;		   field will be filled with the character "*".
;		2. After printing one space, the file specification pointed
;		   to by location FILSPC will be printed in a 30 character
;		   field.  The justification defaults to left justification,
;		   and the fill character is a space.
;		3. After printing another space, the ASCIZ string starting
;		   at location FOO(S2) will be printed in a 40 character
;		   field. The resulting output will be centered in the field
;		   and filled with blanks as necessary.
;
;	NOTE: If output overflows a field, then no justification is done.
;
; The actual $TEXT macro

DEFINE	$TEXT	(ADR,STRING) <
	$CALL	T%TEXT
	LSTOF.	XCREF
	JUMP	[XWD 2,0
		 EVL (ADR)
		 ITEXT(<STRING>)]	;;Parse the string
	LSTON.>

DEFINE	EVL (A,B,C) <
	IFIDN <B'C><>,<EXP <A>>
	IFDIF <B'C><>,<
	 IFE <A+1>,<<POINT 7,'C>>
	 IFN <A+1>,<
	   IFIDN <C><>,<EXP <A,B>>
	   IFDIF <C><>,<EXP <A,B,C>>
	>>>


DEFINE	ITEXT	(STRING) <
	LSTOF.	XCREF
	..TEXT<STRING>		;;EXPAND IT
	  EXP	0		;;TERMINATE WITH A ZERO WORD
	LSTON.
> ;;End DEFINE ITEXT

; Define legal qualifers for argument types
;
;  CHR	This is the character which will invoke the function
;	when seen in a text string

;  TYPE	This is the type used in the $TQ macro to invoke the
;	function

;  ARGS	This field identifies which arguments are valid for
;	the function.  The following values may be specified:

;	0	Function accepts no arguments
;	1	Function accepts only address and field mask
;	2	Function accepts all arguments

;  PROC	This is the name of the macro processor which will be called
;	when the qualifier is encountered.


; Remember to add new qualifiers to the end, in order to keep older
; programs working.

	DEFINE TQUALS,<
	LSTOF.
	TQ(T,2,ASCIZ)			;;ASCIZ STRING
	TQ(O,2,OCTAL)			;;UNSIGNED OCTAL NUMBER
	TQ(D,2,DECIMAL)			;;DECIMAL NUMBER
	TQ(F,2,FILE)			;;FILE SPECIFICATION
	TQ(7,2,CSEVEN)			;;ONE RIGHT JUSTIFIED 7 BIT CHARACTER
	TQ(6,2,CSIXBIT)			;;ONE RIGHT JUSTIFIED 6 BIT, CHARACTER
	TQ(W,2,SIXBIT)			;;SIXBIT WORD
	TQ(5,2,SVNBIT)			;;ASCIZ, ONLY 1 WORD
	TQ(P,2,USER)			;;PPN OR DIRECTORY NUMBER
	TQ(U,2,DIRECTORY)			;;PPN OR USER NUMBER
	TQ(H,2,DAYTIME)			;;UDT TO BE TYPED AS DD-MON-YY HH:MM:SS
	TQ(C,2,TIME)			;;TIME FROM UDT TO BE TYPED AS HH:MM:SS
	TQ(E,2,ERROR)			;;TYPE OUT STRING FOR ERxxx$ ERROR CODE
	TQ(I,1,INDIRECT)		;;POINTER TO ITEXT (INDIRECT  TEXT) BLOCK
	TQ(M,0,CR,..TXC0(\".CHCRT))	;;TYPE ^M (CARRIAGE RETURN)
	TQ(J,0,LF,..TXC0(\".CHLFD))	;;TYPE ^J (LINE-FEED)
	TQ(L,0,FF,..TXC0(\".CHFFD))	;;TYPE ^L (FORM FEED)
	TQ(K,0,VT,..TXC0(\".CHVTB))	;;TYPE ^K (VERTICAL TAB)
	TQ(A,0,NOCRLF,..TXA(.TQCHA))	;;(APPEND) SUPPRRESS FREE CRLF
	TQ(0,0,NULL,..TXA(.TQCH0))	;;NUL CHAR INSTEAD OF CR-LF AT END
	TQ(3,0,STRING,..TXER(IQU))	;;INTERNAL STRING
	TQ(V,2,VERSION)			;;PROGRAM VERSION NUMBER
	TQ(2,0,CARET,..TXER(IQU))	;;INTERNAL UP-ARROR
	TQ(Q,2,POINTER)			;;BYTE POINTER TO ASCIZ STRING
	TQ(B,2,ROB)			;;OBJECT BLOCK
	TQ(1,2,OBJECT)			;;OBJECT TYPE
	TQ(N,2,NODE)			;;TYPE A NODE NAME/NUMBER
	TQ(R,2,JIB)			;;TYPE OUT JOB INFO BLOCK (JIB)
	LSTON.
> ;END OF TQUALS DEFINITION

;DEFINE TWO SYMBOLS OF THE FORM .TQxxx AND .TQCHx WHICH
;IDENTIFY THE VALID QUALIFIERS AND THE ARGUMENTS WHICH ARE
;VALID FOR EACH.  THE RIGHT HALF OF THE SYMBOL IS THE QUALIFIER
;INDEX AND THE LEFT HALF WILL CONTAIN A 0,1 OR 2 TO INDICATE WHICH
;ARGUMENTS ARE ALLOWED.



DEFINE	TQ(CHR,ARGS,TYP,PROC) <

  IFNB	<CHR>,<.TQCH'CHR==^D<ARGS>B17+ZZ>
  IFNB 	<PROC>,<DEFINE ..TQM'CHR<PROC>>
  IFNB	<TYP>,<.TQ'TYP==^D<ARGS>B17+ZZ>
	 ZZ==ZZ+1>

	ZZ==1			;FIRST QUALIFIER IS 1
	TQUALS			;DEFINE THE CODES

;DEFINE THE FIELDS IN THE TEXT ARGUMENT BLOCK USED FOR EACH ARG

	.TXTFL==0			;TEXT ARGUMENT FLAG WORD
	  TXT.NA==1B0			;FUNCTION HAS NO ARGUMENTS
	  TXT.FN==77B8			;TEXT FUNCTION CODE
	  TXT.AD==1B9			;ADDRESS WORD IS PRESENT
	  TXT.IM==1B10			;ADDRESS IS THE ARGUMENT (RESERVED)
	  TXT.JU==3B12			;ARGUMENT JUSTIFICATION CODE
	    .TXTJL==1			;JUSTIFY LEFT
	    .TXTJR==2			;JUSTIFY RIGHT
	    .TXTJC==3			;JUSTIFY CENTER
	  TXT.WD==377B23		;WIDTH OF FIELD
	  TXT.FC==377B35		;FILL CHARACTER

	.TXTAD==1			;TEXT ARGUMENT ADDRESS WORD
	  TXT.PT==7777B11		;POINTER PORTION OF ADDRESS
	  TXT.XA==1B12			;EXTENDED ADDRESS (RESERVED)
	  TXT.EA==37777777B35		;ADDRESS PORTION

;OBSOLETE DEFINITIONS FOR FLAG WORD

	  TXT.P==1B1			;POINTER WORD IS PRESENT (OBSOLETE)
	  TXT.S==1B2			;SPACING WORD IS PRESENT (OBSOLETE)
	  TXT.M==77B8			;MASK TO QUALIFIER PART

;OBSOLETE DEFINITIONS FOR OPTIONAL SPACING WORD

	  TXT.SC==177B6			;MASK TO GET CHARACTER FOR SPACING
	  TXT.SS==3B17			;MASK TO GET SIDE FOR SPACING
	    TXT.SL==1			;CODE TO SPACE LEFT
	    TXT.SR==2			;CODE TO SPACE RIGHT
	    TXT.SM==3			;CODE TO SPACE MIDDLE (CENTER)
	  TXT.SP==777777		;MASK TO GET POSITIONS FOR SPACING
SUBTTL	$TQ MACRO DEFINITION

;THE $TQ MACRO ALLOWS TEXT ARGUMENT BLOCKS TO BE BUILD WITHOUT
;REQUIRING CHARACTER BY CHARACTER PARSING OF THE TEXT STRING

DEFINE	$TQ(TYP,ADR,WID,JUS,FIL) <

  ..TXA(.TQ'TYP,WID,JUS,FIL,ADR)	;;CALL THE WORK MACRO
      IFN ..TXEF,<			;;REPORT ANY ERRORS
	..TERR<$TQ(TYP,ADR,WID,JUS,FIL)>>

> ;END OF $TQ DEFINITION


;THE ..TXA MACRO BUILDS A STANDARD ITEXT ARGUMENT BLOCK AND
;ESTABLISHES THE DEFAULT JUSTIFICATION AND FILL IF NONE WAS
;SPECIFIED.  THIS MACRO IS CALLED BY THE $TQ MACRO AND BY THE
;TEXT PARSING MACROS WHEN AN ARGUMENT HAS BEEN ASSEMBLED

DEFINE	..TXA(TYP,WID,JUS,FIL,ADR,STR) <

	..TXEF==0			;;CLEAR THE ERROR FLAGS

IFNDEF TYP,<..TXER(UQU)>		;;QUALIFIER MUST BE DEFINED
IFDIF <WID><>,<IRPC WID,<.IFN <WID>,NUMERIC,..TXER(IWA)>>
IFNB <JUS>,<IFNDEF .TXTJ'JUS,<..TXER(IJA)>>
IFDEF  TYP,<
  IFE <TYP_-^D18>,<IFDIF <ADR'STR'WID'JUS'FIL><>,<..TXER(ANA)>>
  IFE <1-<TYP_-^D18>>,<IFDIF <WID'JUS'FIL><>,<..TXER(JNA)>>
  IFE <2-<TYP_-^D18>>,<IFIDN <ADR'STR><>,<..TXER(ADS)>>>

      IFE ..TXEF,<
	IFIDN <WID><>,<..TXWD==<..TXJU==<..TXFC==0>>>
	IFDIF <WID><>,<
	  IFE <^D<WID>>,<..TXWD==<..TXJU==<..TXFC==0>>>
	  IFN <^D<WID>>,<..TXWD==^D<WID>
	    IFNB <JUS>,<..TXJU==.TXTJ'JUS>
	    IFB  <JUS>,<..TXJU==.TXTJL
	      IFE <TYP-.TQOCT>,<..TXJU==.TXTJR>
	      IFE <TYP-.TQDEC>,<..TXJU==.TXTJR>>
	    IFB  <FIL>,<..TXFC==" ">
	    IFNB <FIL>,<..TXFC=="FIL">>>

	IFB  <ADR'STR>,<..TXPT==0>
	IFNB <ADR'STR>,<..TXPT==1>
	IFE <..TXWD+..TXPT>,<
	    EXP FLD(TYP,TXT.FN)>
	IFN <..TXWD+..TXPT>,<
	    EXP FLD(TYP,TXT.FN)+FLD(..TXJU,TXT.JU)+FLD(..TXWD,TXT.WD)+FLD(..TXFC,TXT.FC)+TXT.AD
	    PNTR(ADR,STR)>>

> ;END OF ..TXA MACRO DEFINITION
;THE PNTR MACRO ACCEPTS A STRUCTURE OR ADDRESS MASK DEFINITION
;AND CREATES A BYTE POINTER TO THEARGUMENT.
;IF THE ARGUMENT IS A FULLWORD, THE POINTER POSITION IS 0.

DEFINE	PNTR(Y,STR) <
	 IFB  <STR>,<..STR0(..PNT,,<FWMASK>,Y)>
	 IFNB <STR>,<..STR0(..PNT,,<STR>,Y)>>

   DEFINE ..PNT(AC,LOC,MSK)<
	..PST==MSK-FWMASK
	.IF0 ..PST,<
		POINT 0,LOC,35>,<
		POINTR (LOC,MSK)>>
SUBTTL	Error processing and messages

DEFINE	$TX$ERR,<
	LSTOF.
	X(UQU,Unknown qualifier)
	X(IQU,Invalid qualifier)
	X(IJA,Invalid justification argument)
	X(IWA,Invalid width argument)
	X(PEA,Premature end of argument)
	X(JNA,Justification is not allowed)
	X(ANA,Arguments are not allowed)
	X(ADS,Address must be specified)
	LSTON.
> ;End of $TX$ERR definition

;Assign a bit symbol for each error

DEFINE	X(NAM,STRING) <
	..X'NAM==1B<ZZ>
	 ZZ==ZZ+1>

	 ZZ==0
	$TX$ERR		;;EQUATE THE SYMBOLS

;DEFINE A MACRO TO DISPLAY THE COMPILE TIME DIAGNOSTIC FOR ERRORS

DEFINE ..TERR(TEXT) <
  IF1,<
    PRINTX ? Error in "TEXT"
    DEFINE X(NAM,ERR) <IFN ..X'NAM&..TXEF,<PRINTX ? ERR>>
    $TX$ERR>
> ;End ..TERR definition

;HERE WHEN AN ERROR IS DETECTED.  THIS ROUTINE REMEMBERS THE
;ERROR IN THE ERROR REGISTER ..TXF AND CAUSES RETURN TO TOP
;THE TOP LEVEL PARSING ROUTINES.

  DEFINE ..TXER(E) <
    ..TXEF==..TXEF!..X'E		;;SET THE ERROR FLAG
    ..TXF==0				;;BACK TO TOP LEVEL
    ..TXB=="^">				;;ESTABLISH BREAK

SUBTTL	..TEXT PARSING MACRO DEFINITION

DEFINE ..TEXT (C) <

    ..TXF==0				;;SET TOP PROCESSING LEVEL
    ..TXB==0				;;CLEAR THE BREAK CHARACTER
    ..TXP==0				;;CLEAR TEXT PROCESSING FLAG
    ..TXEG==<..TXEF==0>			;;CLEAR ERROR REGISTERS
    IRPC C,<				;;PARSE THE STRING
	..TXC==ASCII\C\_-35		;;GET CHARACTER VALUE
	IFN ..TXB,<IFN ..TXB-..TXC,..CNS(<C>)
		   IFE ..TXB-..TXC,..TXB==0>
	IFE ..TXB,<..TXQ(<C>,\..TXF)>>	;;CALL PROPER PROCESSOR
    ..TXC1				;;TERMINATE TEXT IF ANY
    IFN ..TXB,<IFN <..TXB-"^">,<..TXER(PEA)>>
    ..TXEF==..TXEF!..TXEG		;;GET ANY ERRORS
    IFN ..TXEF,<..TERR<C>>
> ;END OF ..TEXT


;;HERE WHEN BREAK CHARACTER IS NOT SET TO DISPATCH TO
;APPROPRIATE PROCESSOR

DEFINE ..TXQ(C,P) <..TXQ'P(<C>)>


;HERE FOR THE VERY FIRST CHARACTER AND FOR EACH CHARACTER
;FOLLOWING THE COLLECTION OF A VALID ARGUMENT

DEFINE ..TXQ0(C) <

    IFN ..TXC-"^",<..TXC0(<C>)>		;;STORE AND INIT TEXT
    IFE ..TXC-"^",<..TXF==1>>		;;UNLESS WE HAVE "^"


;;HERE TO PROCESS THE QUALIFIER

;;MAKE SURE WE HAVE A VALID QUALIFER AND DO SPECIAL CASE
;;CHECK TO ALLOW A QUOTED "^".
;;SETS THE NEXT FUNCTION TO PROCESS WIDTH IF QUALIFIER
;;ACCEPTS ANY ARGUMENTS ELSE FORCES RETURN TO TOP LEVEL.

DEFINE ..TXQ1(C) <

    IFE ..TXC-"^",<..TXC0(<C>)>	;;STORE IF SPECIAL CHARACTER
    IFN ..TXF,<			;;ELSE
	..TXF==0		;;ASSUME TOP LEVEL
	IFDEF .TQCH'C,<		;;IF QUALIFIER IS VALID
	    IFDEF ..TQM'C,..TQM'C ;;EXECUTE MACRO IF DEFINED
	    IFN <.TQCH'C_-^D18>,<..TXF==2>>>
    IFE ..TXF-2,<..TXC1(<C>)	;;CLOSE CURRENT TEXT STRING
	..ICNS			;;CLEAR ACCUMULATED TEXT
	..CNS<..TXA(.TQCH'C,>>	;;SET STRING TO CALL ..TXA MACRO
    ..TXEG==..TXEG!..TXEF>	;;REMEMBER ANY ERRORS

;HERE TO PROCESS WIDTH

;THIS MACRO APPENDS ALL NUMERIC CHARACTERS TO THE STRING WHICH
;IS BEING ACCUMULATED.  WHEN THE FIRST NON NUMERIC IS ENCOUNTERED
;THE JUSTIFICATION PROCESSOR IS CALLED.

DEFINE ..TXQ2(C) <
    ..TXF==3				;;ASSUME JUSTIFICATION
    IFGE ..TXC-"0",IFLE ..TXC-"9",<..TXF==2>;;UNLESS ARGUMENT IS NUMERIC
    IFE ..TXF-2,<..CNS(C)>		;;APPEND NUMERIC ARGUMENT
    IFE ..TXF-3,<..CNS<,>		;;ELSE CLOSE WIDTH
		 ..TXQ3(C)>>		;;AND PROCESS JUSTIFICATION


;HERE TO PROCESS JUSTIFICATION

;STORE JUSTIFICATION ARGUMENT AND SETUP TO PROCESS FILL CHARACTER
;OR PROCESS FIRST ADDRESS DELIMITER

DEFINE	..TXQ3(C) <
    ..TXF==4				;;ASSUME NEXT ARG IS FILL
    IFE ..TXC-"/",<..TXF==5>		;;UNLESS FIRST SLASH
    IFE ..TXC-"[",<..TXF==5>		;;OR ADDRESS DELIMITER
    IFE ..TXF-4,<..CNS<C,>>		;;STORE JUSTIFICATION ARG
    IFE ..TXF-5,<..CNS<,,>		;;OR CLOSE JUSTIF AND FILL
		 ..TXQ5(C)>>		;;AND PROCESS DELIMITER


;HERE TO PROCESS FILL CHARACTER

;IF CHARACTER IS NOT ADDRESS DELIMITER WE STORE IT AS THE FILL
;CHARACTER AND SETUP TO PROCESS A SLASH.  IF THE ARGUMENT IS
;A DELIMITER WE CLOSE THE FILL CHARACTER ARGUMENT AND PROCESS
;IT.

DEFINE ..TXQ4(C) <
    ..TXF==4				;;ASSUME WE HAVE FILL CHARACTER
    IFE ..TXC-"/",..TXF==5		;;UNLESS IT IS ADDRESS
    IFE ..TXC-"[",..TXF==5		;;DELIMITER
    IFE ..TXF-5,<..CNS<,>		;;ELSE CLOSE FILL ARGUMENT
		 ..TXQ5<C>>		;;AND PROCESS DELIMITER
    IFE ..TXF-4,<..CNS<C,>		;;STORE FILL CHARACTER
		 ..TXF==5>>		;;SET TO PROCESS DELIMITER


;HERE TO PROCESS FIRST ADDRESS DELIMITER

;HERE WE SET OUR NEXT FUNCTION TO PROCESS FINAL DELIMITER

DEFINE ..TXQ5(C) <
    ..TXF==6				;;SET NEXT FUNCTION
    IFE ..TXC-"/",..TXB=="/"		;;SET FINAL BREAK CHARACTER
    IFE ..TXC-"[",..TXB=="]"
    IFE ..TXB-"]",..CNS<[>		;;STORE START OF LITERAL
    IFE ..TXB,..TXF==5>			;;IGNORE ANY JUNK


;HERE TO PROCSS FINAL DELIMITER AND BUILD AN ARGUMENT BLOCK

DEFINE ..TXQ6(C) <
    ..TXF==0			;;BACK TO TOP LEVEL
    IFE ..TXC-"]",..CNS<]>	;;STORE END OF LITERAL
    ..CNS<)>			;;TERMINATE ARGUMENT LIST
    ..GCNS			;;DO THE ..TXA MACRO
    ..TXEG==..TXEG!..TXEF>	;;REMEMBER ANY ERRORS


SUBTTL	ASCII TEXT STRING STORAGE MACRO DEFINITIONS

;HERE TO STORE A CHARACTER IN AN ASCII STRING.  A CHECK IS MADE
;TO ENSURE THAT WE ARE PROCESSING ASCII TEXT.

DEFINE ..TXC0(C) <
    IFE ..TXP,<			;;INITIALIZE TEXT PARSING
	..ICNS			;;CLEAR ACCUMULATED STRING
	..CNS<ASCIZ\>		;;START ASCIZ LITERAL
	..TXP==1>		;;REMEMBER WE ARE DOING TEXT
    ..CNS<C>			;;APPEND THE CHARACTER
    ..TXF==0			;;BACK TO TOP LEVEL
    ..TXB=="^">			;;SET TOP LEVEL BREAK


;HERE TO TERMINATE TEXT PROCESSING AND BUILD TEXT ARGUMENT

DEFINE ..TXC1(C) <

    IFN ..TXP,<			;;IGNORE IF NOT DOING TEXT
	..CNS<\>		;;CLOSE ASCIZ LITERAL
	EXP <FLD(.TQCHT,TXT.FN)+[..GCNS]>>;;BUILD THE ARGUMENT
    ..TXP==0>			;;CLEAR TEXT PROCESSING FLAG

	SUBTTL $WTO / $WTOJ / $WTOR / $ACK Macros

	COMMENT /
		 THE CALLING FORMAT IS:

		$WTO  (<Type line>,<Text line>,OBJ Blk address,Optional args)

		$WTOJ (<Type line>,<Text line>,OBJ Blk address,Optional args)

		$WTOR (<Type line>,<Text line>,OBJ Blk address,ACK code addr,Optional args)

		$ACK  (<Type line>,<Text line>,OBJ Blk address,ACK code addr,Optional args)

		$LOG  (<Type line>,<Text line>,OBJ Blk address,Optional args)

		$KWTOR	(ACK Code Addr,Optional args)	;KILL A WTOR REQUEST

		ANY OR ALL OF THE PARAMETERS AND TIEIR COMBINATIONS ARE
		ACCEPTABLE AS INPUT.
		THE TYPE-LINE OR TEXT-LINE ARE STRUCTURED
		THE SAME AS $TEXT CODE. ALL POSSIBLE COMBINATIONS OF
		$TEXT AND ITEXT CODES ARE ACCEPTABLE.

		The 'optional args' consist of
		<arg1,arg2,...,argn> where each of the arg'i is
		of the form: $WTxxx(y), where xxx is one of the
		valid suffixes from the ALLWTO macro, and y is
		the address of a block, or a flag bit, or some
		ITEXT, depending on the meaning of xxx

		/

	;Continued on next page
	;Continued from previous page

;First, define the 'for all WTO parameters' macro
;The code types are as follows:
;0 -	Takes an address
;1 -	Takes an 'OR-able' flag word
;2 -	Takes an ITEXT
;(It turns out that 0 and 1 are today indistinguishable during assembly)

;[317] Add new WTO data items to the end of this ALLWTO macro or you will 
;[317] break existing applications.

DEFINE ALLWTO,<
	.EAWTO(MTY,0)
	.EAWTO(TYP,2)
	.EAWTO(TXT,2)
	.EAWTO(OBJ,0)
	.EAWTO(ACK,0)
	.EAWTO(FLG,1)
	.EAWTO(NOD,0)
	.EAWTO(JBN,0)
	.EAWTO(ACD,0)
	.EAWTO(OCD,0)
	.EAWTO(MFL,1)
	.EAWTO(NHD,0)		;;[317]

>;End define ALLWTO

;Then define the individual setting macros
	DEFINE .EAWTO(SUFFIX,CODE),<
	DEFINE	$WT'SUFFIX'	(ARG),<
		IFB	<ARG>,<.WF'SUFFIX'==0
			IFN <CODE-2>,<.$W'SUFFIX'==0>>
		IFNB	<ARG>,<.WF'SUFFIX'==-1
			IFN <CODE-2>,<.$W'SUFFIX'==.$W'SUFFIX'!<ARG>>
			IFE <CODE-2>,<DEFINE .$W'SUFFIX',<<WO.'SUFFIX'>B8+[ITEXT (<ARG>)]>>
		>;;End IFNB
>;;End of define $WTSUFFIX
>;End define .EAWTO
	ALLWTO				;Define the $WTxxx macros

;Then define the 'RESET' macro
	DEFINE	$WTRST<
	DEFINE	.EAWTO(SUFFIX),<$WT'SUFFIX'	<>>
	ALLWTO				;;Reset all the $WTxxx macros
>;End define $WTRST

	;Continued on next page
	;Continued from previous page

;Generate the op-codes for the argument block
	DEFINE	.EAWTO(SUFFIX),<
	.OPCD==.OPCD+1
	WO.'SUFFIX'==.OPCD
>;End define .EAWTO
	.OPCD==0			;Initialize the op-code counter
	WO.MIN==.OPCD+1			;Anticipate the minimum opcode
	ALLWTO				;Generate the opcodes
	WO.MAX==.OPCD			;Define the largest, too
	PURGE	.OPCD			;Flush this sym

;And define the Action routine to generate the in-line blocks
DEFINE	$WTBLD<
	IFE	<.WFMTY>,<PRINTX ?No message type in $WTBLD>
DEFINE .EAWTO(SUFFIX,ARGCOD),<
IFN .WF'SUFFIX',<
	IFE	<ARGCOD-0>,<<WO.'SUFFIX'>B8+ .$W'SUFFIX'>
	IFE	<ARGCOD-1>,<<WO.'SUFFIX'>B8+ [EXP .$W'SUFFIX']>
	IFE	<ARGCOD-2>,<.$W'SUFFIX'>
>;;END IFN .WFSUFFIX
>;;End define .EAWTO
	ALLWTO				;;Build each arg block, if neccessary
	EXP	0			;;Finish the arg list
>;End define $WTBLD

;Now define the most commonly used forms of these macros
	DEFINE	$WTO(TYPE,TEXT,OBJADR,ARGS),<.WTOX.(.OMWTO,<TYPE>,<TEXT>,<OBJADR>,,<ARGS>)>
	DEFINE	$QWTO(TYPE,TEXT,OBJADR,ARGS),<.QWTO.(.OMWTO,<TYPE>,<TEXT>,<OBJADR>,,<$WTMFL(MF.WTO),ARGS>)>	;[315]
	DEFINE	$WTOR(TYPE,TEXT,OBJADR,ACKADR,ARGS),<.WTOX.(.OMWTR,<TYPE>,<TEXT>,<OBJADR>,<ACKADR>,<ARGS>)>

	DEFINE	$ACK(TYPE,TEXT,OBJADR,ACKADR,ARGS),<.WTOX.(.OMACK,<TYPE>,<TEXT>,<OBJADR>,<ACKADR>,<$WTFLG(WT.SJI),ARGS>)>

	DEFINE	$QACK(TYPE,TEXT,OBJADR,ACKADR,ARGS),<.QWTO.(.OMACK,<TYPE>,<TEXT>,<OBJADR>,<ACKADR>,<$WTFLG(WT.SJI),ARGS>)> ;[315]

	DEFINE	$WTOJ(TYPE,TEXT,OBJADR,ARGS),<.WTOX.(.OMWTO,<TYPE>,<TEXT>,<OBJADR>,,<$WTFLG(WT.JOB),ARGS>)>

	DEFINE	$LOG(TYPE,TEXT,OBJADR,ARGS),<.WTOX.(.OMLOG,<TYPE>,<TEXT>,<OBJADR>,,<ARGS>)>

	DEFINE	$KWTOR(ACKADR,ARGS),<.WTOX.(.OMWTR,,,,<ACKADR>,<$WTFLG(WT.KIL),ARGS>)>

	;Continued on next page
	;Continued from previous page

	DEFINE	.WTOX.(TYP,HDR,TXT,OBJ,ACK,ARG,%LLN),<
		$CALL	I%WTO		;;INIT THE MSG BLKS AND LETERRIP.
		LSTOF.			;;TURN OFF THE LISTING.
		JRST	%LLN		;;MAKE THE MACRO SKIP-ABLE.
		$WTRST			;;Reset the WTO macros
	IFNB <TYP>,<$WTMTY (<TYP>)>	;;Put in the message type
	IFNB <HDR>,<$WTTYP (<HDR>)>	;;Add the 'type' line of text
	IFNB <TXT>,<$WTTXT (<TXT>)>	;;Add the 'text' line of text
	IFNB <OBJ>,<$WTOBJ (<OBJ>)>	;;And the object block address
	IFNB <ACK>,<$WTACK (<ACK>)>	;;And the ack code
		IRP ARG,<ARG>		;;And do all the extra stuff
		$WTBLD			;;Then put in the blocks
	%LLN:!
	LSTON.  >		;;RESUME LISTINGS

	DEFINE	.QWTO.(TYP,HDR,TXT,OBJ,ACK,ARG,%LLN1,%LLN2),<
		SKIPA			;;[316]Skip over the skip return
		JRST	%LLN2		;;[316]Make the macro skipable
		SKIPE	G$NEBF		;;[315]Message originate remotely?
		JRST	%LLN1		;;[315]Yes, include a remote block
		$CALL	I%WTO		;;[315]Init the msg blks and leterrip.
		LSTOF.			;;[315]Turn off the listing.
		JRST	%LLN2		;;[315]Don't send another message
		$WTRST			;;[315]Reset the WTO macros
	IFNB <TYP>,<$WTMTY (<TYP>)>	;;[315]Put in the message type
	IFNB <HDR>,<$WTTYP (<HDR>)>	;;[315]Add the 'type' line of text
	IFNB <TXT>,<$WTTXT (<TXT>)>	;;[315]Add the 'text' line of text
	IFNB <OBJ>,<$WTOBJ (<OBJ>)>	;;[315]And the object block address
	IFNB <ACK>,<$WTACK (<ACK>)>	;;[315]And the ack code
		IRP ARG,<ARG>		;;[315]And do all the extra stuff
		$WTBLD			;;[315]Then put in the blocks

%LLN1:		$CALL	I%WTO		;;[315]Init the msg blks and leterrip.
		JRST	%LLN2		;;[315]Make the macro SKIP-able.
		$WTRST			;;[315]Reset the WTO macros
	$WTNHD(G$REMN)			;;[315]Name of remote node
	IFNB <TYP>,<$WTMTY (<TYP>)>	;;[315]Put in the message type
	IFNB <HDR>,<$WTTYP (<HDR>)>	;;[315]Add the 'type' line of text
	IFNB <TXT>,<$WTTXT (<TXT>)>	;;[315]Add the 'text' line of text
	IFNB <OBJ>,<$WTOBJ (<OBJ>)>	;;[315]And the object block address
	IFNB <ACK>,<$WTACK (<ACK>)>	;;[315]And the ack code
	$WTMFL(MF.NEB)			;;[315]Turn on the NEBULA bit
		IRP ARG,<ARG>		;;[315]And do all the extra stuff
		$WTBLD			;;[315]Then put in the blocks

	%LLN2:!
	LSTON.  >			;;[315]Resume listings

SUBTTL GALAXY system error codes

DEFINE ERRORS,<
	ERR	EOF,<End of file>
	ERR	IFP,<Illegal file position>
	ERR	FDE,<File data error>
	ERR	FND,<File is not on disk>
	ERR	FSM,<File still mapped>			;[301]
	ERR	NSD,<No such device>
	ERR	FCF,<File checkpoint failed>
	ERR	SLE,<A system limit was exceeded>
	ERR	IFS,<Illegal file specification>
	ERR	FNF,<File not found>
	ERR	PRT,<Protection violation>
	ERR	DNA,<Device not available>
	ERR	NCE,<No "current" entry in list>
	ERR	NMA,<No IPCF message is available>
	ERR	FDS,<Files are on different structures>
	ERR	FAE,<File already exists>
	ERR	USE,<Unexpected system error>
	ERR	NSP,<No such pid>
	ERR	BOL,<Beginning of list reached>
	ERR	EOL,<End of list reached>
	ERR	RQF,<Receivers quota full>
	ERR	SQF,<Senders quota full>
	ERR	NRE,<No remembered entry>
	ERR	TBF,<Table is full>
	ERR	EIT,<Table entry already exists>
	ERR	ITE,<Invalid table entry>
	ERR	QEF,<Quota exceeded or disk full>
	ERR	ARG,<Invalid argument specified>
	ERR	IFN,<Invalid function specified>
	ERR	IJN,<Invalid job number specified>
	ERR	RAD,<Invalid radix specified>
	ERR	NUM,<Invalid numeric argument>
	ERR	IDT,<Invalid date field specified>
	ERR	ITF,<Invalid time field specified>
	ERR	DOR,<Date/time out of range>
	ERR	DTM,<Value missing in date/time>
	ERR	MDD,<Missing day in date/time>
	ERR	DFZ,<Field zero in date/time>
	ERR	MDS,<Mnemonic date/time switch not implemented>
	ERR	DFL,<Field too large in date/time>
	ERR	ILR,<Illegal year format in date/time>
	ERR	NND,<Negative number in date/time>
	ERR	NPF,<Not known whether past or future in date/time>
	ERR	RDP,<Relative date parse required>
	ERR	NSW,<Switch does not begin with slash>
	ERR	NOM,<Unrecognized switch or keyword>
	ERR	NUL,<Null switch or keyword given>
	ERR	INW,<Invalid guide word>
	ERR	NC,<Not confirmed>
	ERR	ICN,<Invalid character in number>
	ERR	NQS,<Invalid quoted string - does not begin with quote>
	ERR	AMB,<Ambiguous switch or keyword>
	ERR	NMT,<Does not match token>
	ERR	CMA,<Comma not given>
	ERR	NNC,<Node name may not exceed 6 characters>
	ERR	INT,<Node terminator "::" must be specified>
	ERR	NSN,<Unknown node name>
	ERR	IPS,<Invalid path specification>
	ERR	IUS,<Invalid user specification>
	ERR	DGS,<Device name may not exceed 6 characters>
	ERR	DNE,<Unknown device>
	ERR	DIO,<Device can not do input or output>
	ERR	BDF,<Invalid date/time format>
	ERR	ABS,<Field too long for internal buffer>
	ERR	TMT,<Command too long for internal buffer>
	ERR	BDS,<Invalid default string>
	ERR	BTF,<Invalid table format>
	ERR	TME,<Date/time must be in the future>
	ERR	TMN,<No timer entry has expired>
	ERR	TMA,<Timer entry already exists>
	ERR	DVT,<Device terminator ":" must be specified>
	ERR	NCI,<Argument block may not be in the ACs>
	ERR	TLU,<Terminal location is unknown>
	ERR	FIO,<File is offline>
	ERR	FBM,<File being modified>
	ERR	WLK,<Write-locked device>
	ERR	CSD,<Cannot supersede a directory>
	ERR	CDD,<Cannot delete a non-empty directory>
	ERR	SNF,<Sub-file directory not found>
	ERR	ESL,<Search list is empty>
	ERR	LVL,<SFD level nested deeper than the maximum allowed>
	ERR	CCW,<Cannot create/write on any structure in search list>
	ERR	FCU,<Cannot update file>
	ERR	ENQ,<File has outstanding Enqueue lockes set>
	ERR	SWS,<Software write-lock on structure>
	ERR	DER,<Hardware device error>
	ERR	DTE,<Hard data error>
	ERR	BKT,<Block too large>
	ERR	IPP,<Non-existant UFD>
	ERR	TRN,<RIB or transmission error>
	ERR	ILC,<Illegal character in date/time>
	ERR	NFT,<Date/time must be in the future>
	ERR	NPS,<Date/time must be in the past>
	ERR	UDM,<Unrecognized month in date/time>
	ERR	UDN,<Unrecognized name in date/time>
	ERR	IFA,<Illegal file attribute>
	ERR	FAI,<File attribute inconsistancy>
	ERR	CEI,<Can't enable/disable interrupt system>
	ERR	ENF,<Linked list entry not found>
	ERR	NSL,<No such linked list>
	ERR	NFP,<No free pages>
	ERR	NPI,<No free pages for IPCF reception>
>  ;END DEFINE ERRORS

;GENERATE THE ERROR SYMBOLS

	ER%%%==1			;DON'T USE ERROR CODE 0
DEFINE ERR(A,B),<
	IF1,<IFDEF ER'A'$,PRINTX ?Duplicate error code A>
	ER'A'$==ER%%%
	ER%%%==ER%%%+1
>  ;END DEFINE ERR

	ERRORS

	ERUJI$==ERIFN$			;***Temporary***
SUBTTL Canonical File Information

;In order to bring the number of feature test switches needed to the
;absolute minimum, the GLXFIL (file handler) module makes information
;about open files available through the F%INFO routine call.  The
;particular piece of information desired is designated by providing
;a canonical descriptor for that piece of information.

;These FI.xxx symbols, defined here, are the F%INFO descriptors

DEFINE CFI<

	  LSTOF.

	X CRE	;;UDT FORMAT CREATION DATE/TIME OF FILE
	X GEN	;;VERSION/GENERATION NUMBER OF FILE
	X PRT	;;PROTECTION OF THE FILE
	X CLS	;;CLASS OF FILE (TOPS-20) ONLY
	X AUT	;;AUTHOR OF THE FILE
	X USW	;;USER SETTABLE WORD
	X SPL	;;SPOOL WORD (TOPS-10)
	X SIZ   ;;SIZE OF FILE, IN BYTES
	X MOD	;;DATA MODE
	X CHN	;;FILE CHANNEL # (CHN OR JFN)

	  LSTON.

> ;END OF CFI DEFINITION

;CREATE THE SYMBOLS

	FI.%%%==0

	DEFINE X(A)<
	FI.'A==FI.%%%
	FI.%%%==FI.%%%+1
	>

	CFI
SUBTTL Canonical Job Information

;In order to bring the number of feature test switches needed to the
;absolute minimum, GLXINT (Initialization) module makes information
;about jobs available through the I%JINF routine call. The
;particular piece of information desired is designated by providing
;a canonical descriptor for that piece of information.

;These JI.XXX symbols, defined here, are the I%JINF descriptors

DEFINE JBTAB<

	  LSTOF.

	X JNO,.JIJNO,<-1,,GJBJNO>	;;JOB NUMBER
	X TNO,.JITNO,<-1,,GJBTTY>	;;TERMINAL NUMBER
	X USR,.JIUNO,.GTPPN		;;LOGGED IN DIRECTORY NUMBER
	X CDN,.JIDNO,<-1,,GJBPTH>	;;CONNECTED DIRECTORY NUMBER
	X PRG,.JIPNM,.GTPRG		;;SIXBIT PROGRAM NAME
	X CJN,.JICPJ,<-1,,GJBCJB>	;;CONTROLLING JOB NUMBER (IF CONTROLLED BY PTY)
	X BAT,.JIBCH,.GTOBI		;;BATCH DATA WORD..STREAM # AND WTO DATA
	X JLT,.JISTM,.GTJLT		;;JOB LOGGED IN TIME
	X LOC,<-1,,GJBLOC>,<-1,,GJBLOC> ;;JOB LOCATION INFORMATION
	X RTM,.JIRT,<-1,,GJBRTM>	;;JOB RUNTIME IN MILLISECS
	X TLC,<-1,,GJBTLC>,<-1,,GJBTLC>	;;JOBS TERMINAL LOCATION
	  LSTON.

> ;END OF CJI DEFINITION

;CREATE THE SYMBOLS

	.ZZ==1
	JI.MIN==.ZZ		;smallest accepted value

	DEFINE X(A,B,C)<
	JI.'A==.ZZ
	.ZZ==.ZZ+1
	>

	JBTAB
	JI.MAX==.ZZ-1		;LARGEST ACCEPTED VALUE
SUBTTL	I%TIMR	Functions and argument block


.TIFNC==0		;HEADER WORD FOR EACH TIMER ENTRY
  TI.FRK==777777B17	;FORK HANDLE (TOPS20 RESERVED)
  TI.FNC==777777B35	;TIMER FUNCTION CODE
    .TIMRT==0		;RESERVED FOR RUNTIME
    .TIMEL==1		;ADD A REQUEST TO OCCUR AFTER N MILLISECONDS
    .TIMDT==2		;ADD A REQUEST TO OCCUR AT THE SPECIFIED UDT
    .TIMDD==3		;REMOVE PENDING REQUESTS AT THE UDT
    .TIMBF==4		;REMOVE PENDING REQUESTS BEFORE THE UDT
    .TIMAL==5		;REMOVE ALL PENDING REQUESTS
.TITIM==1		;ELAPSED TIME OR UDT AT WHICH EVENT IS TO OCCUR
.TIPSI==2		;PSI WORD (RESERVED)
.TIMPC==3		;USER SUPPLIED PC FOR TIMER
.TIDAT==4		;START OF USER SUPPLIED DATA

SUBTTL Scanning and Command Module Symbols

;Define the major macro to expand X(y,z,...) for each terminal type
;Note well:  the items in the TRMTYP macro MUST be in Alphabetical order
;	so that TRMTYP can be used to build parse tables.

DEFINE	TRMTYP,<
	LSTOF.
	X(33,TTY33,33,)				;;MODEL 33
	X(35,TTY35,35,)				;;MODEL 35
TOPS20<
	X(37,TTY37,37,)				;;MODEL 37
	X(EXECUPORT,EXEC,EXE,)			;;TI EXECUPORT
>;;END TOPS20
TOPS10<
	X(LA120,LA120,L12,)			;;LA120
>;;END TOPS10
	X(LA36,LA36,L36,)			;;LA36
	X(VT05,VT05,V05,<37,177,177,177>)	;;VT05
	X(VT100,VT100,100,<.CHESC,"[","K">)	;;VT100
	X(VT50,VT50,V50,<.CHESC,"J">)		;;VT50
	X(VT52,VT52,V52,<.CHESC,"J">)		;;VT52
TOPS10<	X(VT61,VT61,V61,<.CHESC,"J">)>		;;VT61
	LSTON.
>;END DEFINE TRMTYP

;The general form of the X macro (which must be redefined just before invoking
;TRMTYP) is:
;X(PARNAM,SIXNAM,SUF,EOLSEQ)
;Where,
;	PARNAM	is the parseable name
;	SIXNAM	is the (TOPS-10) SIXBIT name for TRMOP. .TOTRM
;	SUF	is a 3-char suffix for .TTsuf and .TIsuf
;	EOLSEQ	is a sequence of bytes which will clear to end of line

;Note:
;	.TTsuf is the code to be passed to K%STYP
;		This value need not be the same on the -10 and the -20,
;		but today, they are.
;	.TIsuf is a number between 0 and .TIMAX (inclusive) which may
;		be used to $BUILD and $SETup dispatch tables

;Now, define the .TIsuf symbols which are indicies into tables
;which contain 1 entry for each type of terminal
DEFINE X(PARNAM,SIXNAM,SUF,EOLSEQ),<
.TI'SUF==..Z
..Z==..Z+1>
	..Z==0
	TRMTYP			;Do 'em all!
	.TIMAX==..Z-1		;Set the max (must $BUILD (.TIMAX+1) still!)
	PURGE	..Z

TOPS10<
;Define the .TTsuf symbols, since they're not in UUOSYM
DEFINE X(PARNAM,SIXNAM,SUF,EOLSEQ),<
.TT'SUF==..Z
..Z==..Z+1
>;END DEFINE X
	..Z==0			;Start at 0
	TRMTYP			;Do 'em all!
	PURGE	..Z
>;END TOPS10

; The following TOPS-20 symbols are defined when building a TOPS-10 library
;	so that the emulation routines provided for scanning and command
;	parsing can use the same symbols on both systems.

TOPS10 <				;ALREADY DEFINED ON THE -20

; RDTTY flags and argument offsets

	.RDCWB==0			;COUNT OF WORDS FOLLOWING
	.RDFLG==1			;FLAG BITS
	  RD%BRK==1B0			;  BREAK ON ^Z OR ESC
	  RD%TOP==1B1			;  BREAK ON TOPS-10 BREAK SET
	  RD%PUN==1B2			;  BREAK ON PUNCTUATION
	  RD%BEL==1B3			;  BREAK ON EOL
	  RD%CRF==1B4			;  EAT CARRIAGE RETURNS
	  RD%RND==1B5			;  RETURN IF EDITED TO BEGINNING
	  RD%JFN==1B6			;  IFN RATHER THAN STRING PTR
	  RD%RIE==1B7			;  NON-BLOCKING, I.E. RETURN IF EMPTY
	  RD%BBG==1B8			;  PTR TO DEST BUFFER IS IN .RDBFP
	  RD%RAI==1B10			;  CONVERT LOWER TO UPPER CASE
	  RD%SUI==1B11			;  SUPRESS ^U (RUBOUT LINE) HANDLING

	  RD%BTM==1B12			;  INPUT ENDED ON A BREAK
	  RD%BFE==1B13			;  USER DELETED TO BEGINNING
	  RD%BLR==1B14			;  BACKUP LIMIT REACHED

	  RD%NEC==1B35			;  NO ECHO ON ANYTHING (TOPS-10)

	.RDIOJ==2			;INPUT AND OUTPUT IFNS OR STRING POINTER
	.RDDBP==3			;DESTINATION BYTE POINTER
	.RDDBC==4			;NUMBER OF BYTES LEFT AFTER POINTER
	.RDBFP==5			;BEGINNING BYTE POINTER
	.RDRTY==6			;RE-TYPE PROMPT POINTER
	.RDBRK==7			;LOCATION OF 4 WORD BREAK SET TABLE
	.RDBKL==10			;REAL (ARBITRARY) BACKUP LIMIT

;; STILL UNDER TOPS10 CONDITIONAL
; COMMAND SCANNING (S%CMND) INTERFACE

;FORMAT OF COMND STATE BLOCK:

	.CMFLG==0			;USER FLAGS,,REPARSE DISPATCH ADDRESS
	.CMIOJ==1			;INJFN,,OUTJFN
	.CMRTY==2			;^R BUFFER POINTER
	.CMBFP==3			;PTR TO TOP OF BUFFER
	.CMPTR==4			;PTR TO NEXT INPUT TO BE PARSED
	.CMCNT==5			;COUNT OF SPACE LEFT IN BUFFER AFTER PTR
	.CMINC==6			;COUNT OF CHARACTERS FOLLOWING PTR
	.CMABP==7			;ATOM BUFFER POINTER
	.CMABC==10			;ATOM BUFFER SIZE
	.CMGJB==11			;ADR OF GTJFN ARG BLOCK
	 CM%GJB==777777		;ADR OF GTJFN ARG BLOCK

;FUNCTION DESCRIPTOR BLOCK

	.CMFNP==0			;FUNCTION AND POINTER
	   CM%FNC==777B8		;FUNCTION CODE
	   CM%FFL==377B17		;FUNCTION-SPECIFIC FLAGS
	   CM%LST==777777		;LIST POINTER
	.CMDAT==1			;DATA FOR FUNCTION
	.CMHLP==2			;HELP TEXT POINTER
	.CMDEF==3			;DEFAULT STRING POINTER
	.CMBRK==4			;BREAK SET FOR CM%BRK

; FUNCTION CODES
;Note: The following function code symbols must agree with analogous
;definitions found in MONSYM.

	.CMKEY==0			;KEYWORD
	.CMNUM==1			;NUMBER
	.CMNOI==2			;NOISE WORD
	.CMSWI==3			;SWITCH
	.CMIFI==4			;INPUT FILE
	.CMOFI==5			;OUTPUT FILE
	.CMFIL==6			;GENERAL FILESPEC
	.CMFLD==7			;ARBITRARY FIELD
	.CMCFM==10			;CONFIRM
	.CMDIR==11			;DIRECTORY NAME (PPN)
	.CMUSR==12			;USER NAME (PPN)
	.CMCMA==13			;COMMA
	.CMINI==14			;INITIALIZE COMMAND
	.CMFLT==15			;FLOATING POINT (RSVD)
	.CMDEV==16			;DEVICE NAME
	.CMTXT==17			;TEXT
	.CMTAD==20			;DATE-TIME
	.CMQST==21			;QUOTED STRING
	.CMUQS==22			;UNQUOTED STRING
	.CMTOK==23			;TOKEN
	.CMNUX==24			;NUMBER DELIMITED BY NON-DIGIT
	.CMACT==25			;ACCOUNT
	.CMNOD==26			;NODE
>  ;END TOPS10

	  .RDSIZ==.RDBKL+1		;SIZE OF ARGUMENT BLOCK
TOPS10 <
	;Null JFN

;FLAGS

CM%ESC==1B0				;ESC SEEN
CM%NOP==1B1				;NO PARSE
CM%EOC==1B2				;END OF COMMAND SEEN
CM%RPT==1B3				;REPEAT PARSE NEEDED
CM%SWT==1B4				;SWITCH TERMINATED WITH ":"
CM%PFE==1B5				;PREVIOUS FIELD ENDED WITH ESC
CM%RAI==1B6				;RAISE INPUT
CM%XIF==1B7				;NO INDIRECT FILES
CM%WKF==1B8				;WAKEUP AFTER EACH FIELD
;REMOVE CM%NJF 9/21/79 MLB
CM%NSF==1B12				;SUFFIX MAY BE OMITTED IF DESIRED
CM%BRK==1B13				;INDICATES .CMBRK HAS DATA
CM%PO==1B14				;PARSE ONLY FLAG
CM%HPP==1B15				;HELP PTR PRESENT
CM%DPP==1B16				;DEFAULT PTR PRESENT
CM%SDH==1B17				;SUPPRESS DEFAULT HELP MESSAGE

;FLAGS FOR CMSWI FUNCTION

CM%VRQ==1B0				;VALUE REQUIRED


;FLAGS FOR TIME AND DATE

CM%IDA==1B0				;INPUT DATE
CM%ITM==1B1				;INPUT TIME
CM%NCI==1B2				;NO CONVERT TO INTERNAL
>;;Pause in TOPS10 definition -- The next 2 symbols will apply for TOPS20 also

CM%FUT==1B3				;Time is in future
CM%PST==1B4				;Time is in past

; Resume TOPS10 conditional.
TOPS10	<
;FLAGS IN KEYWORD TABLE (FIRST WORD OF STRING IF B0-6 = 0)

CM%INV==1B35				;INVISIBLE
CM%NOR==1B34				;NO-RECOGNIZE (PLACE HOLDER)
CM%ABR==1B33				;ABBREVIATION
CM%FW==1B7				;FLAG WORD (ALWAYS SET)


; STRING COMPARE (S%SCMP) FLAGS

	SC%LSS==1B0			;TEST STRING LESS THAN BASE STRING
	SC%SUB==1B1			;TEST STRING SUBSET OF BASE STRING
	SC%GTR==1B2			;TEST STRING GREATER THAN BASE STRING
					;(IF NONE, EXACT MATCH IS RESULT)

; TABLE LOOK UP (S%TBLK) FLAGS

	TL%NOM==1B0			;NO MATCH
	TL%AMB==1B1			;AMBIGUOUS
	TL%ABR==1B2			;UNIQUE ABBREVIATION
	TL%EXM==1B3			;EXACT MATCH

 > ;END TOPS10
CM%INT==1B9				;INTERRUPT RET. (10 AND 20..GALAXY DEFINED)
; COMMAND REPLY
	CR.FLG==0			;OFFSET TO FLAG WORD
	CR.RES==1			;OFFSET TO RESULT WORD
	CR.PDB==2			;GIVEN PDB,,USED PDB
	CR.COD==3			;CODE TYPE OF PROCESSED FIELD
	  CR.SIZ==CR.COD+1		;SIZE OF COMMAND REPLY BLOCK

;COMMAND ERROR BUFFER SIZE
	ERRBSZ==20			;SETUP 20 WORDS FOR NOW
SUBTTL	THE MESSAGE HEADER

;Among GALAXY programs, there is a common message header format
;	so that communication and error checking is easier.  There are
;	also some common function codes (currently only TEXT) which are
;	defined across program lines.   The specific data (if any) associated
;	with each message type follows the standard header. Note also
;	that MESSAGE LENGTH includes the header itself.

;	!=======================================================!
;	!      Message Length       !       Message Type        !
;	!-------------------------------------------------------!
;	!ACK!NOM!FAT!WRN!MOR!       !       Sixbit Suffix       !
;	!-------------------------------------------------------!
;	!                 Acknowledgement code                  !
;	!-------------------------------------------------------!
;	!                DECnet checksum word                   !
;	!=======================================================!

	PHASE	0

.MSTYP:!	BLOCK	1
	MS.CNT==-1,,0			;MESSAGE LENGTH
	MS.TYP==0,,-1			;MESSAGE TYPE
	  MT.OFF==700000		;OFFSET TO THE COMMON CODES
	  MT.TXT==700000		;TEXT MESSAGE
.MSFLG:!BLOCK	1			;FLAGS WORD
	MF.ACK==1B0			;ACKNOWLEDGEMENT REQUESTED
	MF.NOM==1B1			;NO MESSAGE, JUST AN ACK
	MF.FAT==1B2			;FATAL MESSAGE
	MF.WRN==1B3			;WARNING MESSAGE
	MF.MOR==1B4			;MORE MESSAGE FOLLOWS
	MF.NEB==1B5			;[300]NEBULA INVOLVED WITH THIS MSG
	MF.WTO==1B6			;[300]A WTO IS EXPECTED WITH THIS MSG
	MF.SUF==777777			;SUFFIX FOR TEXT MESSAGE
.MSCOD:!BLOCK	1			;USER SUPPLIED CODE USED FOR ACK'ING
MSHSIZ:!				;LENGTH OF MESSAGE
.MSDAT:!BLOCK	0			;START OF MESSAGE CONTENTS
	DEPHASE
SUBTTL	General message format

;The following is a description of the typical messages sent in
;GALAXY.

;	!=======================================================!
;	\                                                       \
;	\                  THE MESSAGE HEADER                   \
;	\                                                       \
;	!-------------------------------------------------------!
;	!                       FLAG WORD                       !
;	!-------------------------------------------------------!
;	!                  ARGUMENT COUNT WORD                  !
;	!=======================================================!
;


;			ARGUMENT DATA BLOCKS


;
;	!=======================================================!
;	!  LENGTH OF THE ARGUMENT   !     TYPE OF ARGUMENT      !
;	!-------------------------------------------------------!
;	\                                                       \
;	\                     ARGUMENT DATA                     \
;	\                                                       \
;	!=======================================================!

	PHASE MSHSIZ
.OFLAG:! BLOCK	1			;FLAG WORD FOR MESSAGE
.OARGC:! BLOCK	1			;ARGUMENT COUNT WORD
.OHDRS:!				;SIZE OF THE HEADER

	DEPHASE

;DESCRIPTION OF THE ARGUMENT BLOCK

	PHASE 0
ARG.HD:! BLOCK	1			;ARGUMENT HEADER WORD
	AR.LEN==-1,,0			;LENGTH OF THE BLOCK
	AR.TYP==0,,-1			;TYPE OF BLOCK
ARG.DA:! BLOCK	1			;START OF DATA AREA
ARG.SZ:!				;MINIMUM SIZE OF THE BLOCK

	DEPHASE

;General data types for all messages

.OROBJ==100				;OBJECT BLOCK
.ORTYP==101				;OBJECT TYPE FIELD
.ORJBN==102				;JOBNAME TYPE FIELD
.ORSEQ==103				;SEQUENCE NUMBER FIELD
.ORREA==104				;REASON TYPE FIELD
.ORDSP==105				;OPR DISPLAY ARGUMENT
.ORREQ==106				;REQUEST NUMBER FIELD
.ORNOD==107				;NODE BLOCK FOR QUASAR VALIDATION
.ORD60==110				;DN60 BLOCK OF DATA
.ORTIM==111				;TIME BLOCK (UDT)
.ORJNU==112				;JOB NUMBER FIELD
.ORTCR==113				;[314]TTY CHARACTERISTIC
.ORRFG==114				;[321]REMOTE WTO FLAG WORDS BLOCK
  WD.OBT==1				;[321]WDAOBT VALUE
  WD.FLG==2				;[321]WDAFLG VALUE
  .WDLEN==3				;[321]LENGTH OF .ORRFG BLOCK

;The following function types are currently used as argument types

;.CMNOD			FOR NODE NAME TYPE
;.CMTXT			FOR TEXT ASCIZ DATA
;.CMIFI			FOR INPUT FILE SPEC
;.CMUSR			FOR USER ID INFORMATION
;.CMDEV			FOR DEVICE DESIGNATOR
	SUBTTL	ACK - THE GALAXY 'ACK' MESSAGE

;	!=======================================================!
;	\							\
;	\		THE MESSAGE HEADER			\
;	\							\
;	!-------------------------------------------------------!
;	!		FLAG WORD (.OFLAG)			!
;	!-------------------------------------------------------!
;	!		ARGUMENT COUNT (.OARGC)			!
;	!-------------------------------------------------------!
;
;		THE MESSAGE BODY BLOCK
;
;	!-------------------------------------------------------!
;	!	BLOCK LENGTH	!	.CMTXT			!
;	!-------------------------------------------------------!
;	\							\
;	\		ASCIZ TEXT MESSAGE			\
;	\							\
;	!-------------------------------------------------------!
;
;		THE MESSAGE HEADER BLOCK
;
;	!-------------------------------------------------------!
;	!	BLOCK LENGTH	!	.ORDSP			!
;	!-------------------------------------------------------!
;	\							\
;	\		ASCIZ MESSAGE HEADER			\
;	\							\
;	!-------------------------------------------------------!


;	NOTE:::: * * * * * N O T E   W E L L * * * * *
;
;	THE 'ACK' CODE THAT WAS SUPPLIED BY THE USER IN THE ORIGIONAL
;		REQUEST WILL BE RETURNED IN .MSCOD
;
;
;	THE MESSAGE TYPE MAY BE MT.TXT (OLD MSG TYPE) OR
;		.OMTXT OR .OMACS (NEW ACK MESSAGE TYPE(S))
;
;
;	THE .ORDSP BLOCK WILL ONLY BE FOUND IN A .OMACS MESSAGE
;
;
;	THE .MSCOD FIELD MAY HAVE BITS MF.NOM, MF.FAT, MF.WRN,
;		MF.MOR LIT.
;	THE .MSCOD FIELD MAY ALSO HAVE MF.SUF FILLED IN.

SUBTTL	JIB - Job Information Block

;The foJob Information Block contains  the GALAXY Information to describe
;a job to the system. This block will be used to pass this information
;between all Galaxy Components.

;	!=======================================================!
;	!                   JOBNAME IN SIXBIT                   !
;	!-------------------------------------------------------!
;	!  SEQUENCE NUMBER OF JOB   !   QUASAR DEFINED FIELDS   !
;	!-------------------------------------------------------!
;	!           USER NUMBER ON -20 OR PPN ON -10            !
;	!-------------------------------------------------------!
;	!              REQUEST IDENTIFIER FOR JOB               !
;	!=======================================================!
;
;
;
;	!=======================================================!
;	!                                                       !
;	!               USER NAME (TOPS-10 ONLY)                !
;	!                                                       !
;	!=======================================================!


	PHASE 	0

JIB.JN:! BLOCK	1			;JOB NAME IN SIXBIT
JIB.SQ:! BLOCK	1			;SEQUENCE NUMBER FIELD
	JB.SEQ==777700,,0		;SEQUENCE NUMBER (QUASAR RESTRICTION)
JIB.US:! BLOCK	1			;USER NUMBER OR PPN
JIB.ID:! BLOCK	1			;REQUEST IDENTIFIER NUMBER

TOPS10<
JIB.NM:! BLOCK	2			;USER NAME 2 SIXBIT WORDS (TOPS-10 ONLY)
>;END TOPS10
JIBSIZ:!				;SIZE OF THE JOB INFO BLOCK
SUBTTL	OBJ - Object Descriptor

; Various programs must use a device/object designator which fully
; describes a an entity as to its type,unit number and node.  The canonical
; object descriptor is used for this purpose


;	The object/device designator:

;	!=======================================================!
;	!              Object type descriptor code              !
;	!-------------------------------------------------------!
;	!   Low Bound unit number   !  High Bound unit number   !
;	!-------------------------------------------------------!
;	!                  Node name in SIXBIT                  !
;	!-------------------------------------------------------!	[307]
;	/							/	[307]
;	/	Queue name in ASCIZ (DQS LPTSPL only)		/	[307]
;	/	or Port or Service name (LAT LPTSPL only)	/	[307]
;	!=======================================================!

		PHASE	0

OBJ.TY:!	BLOCK	1		;OBJECT TYPE CODE WORD
	.OTRDR==1			;TYPE	READER
	.OTNCU==2			;TYPE	NETWORK CONTROLLER
	.OTLPT==3			;TYPE	PRINTER
	  .UNLPT==1B0			;[304]AN UNKNOWN REMOTE LPT TYPE
	  .UNPRI==8			;[304]AN UNKNOWN REMOTE LPT PRIORITY
	  .LALPT==1B1			;[302]A LAT PRINTER
	  .LAPRI==4			;[303]A LAT PRINTER PRIORITY
	  .DQLPT==1B2			;[302]A DQS PRINTER
	  .DQPRI==2			;[303]A DQS PRINTER PRIORITY
	  .CLLPT==1B3			;[302]A CLUSTER PRINTER
	  .CLPRI==1			;[303]A CLUSTER PRINTER PRIORITY
	  PRIVAL==4			;[303]THE AMOUNT TO ROTATE LPT CODE
	  .LOLPT==1B4		        ;[310]A LOCAL PRINTER (FOR SHOW COMMAND)
	.OTBAT==4			;TYPE	BATCH CONTROLLER
	.OTCDP==5			;TYPE	CARD PUNCH
	.OTPTP==6			;TYPE	PAPER TAPE PUNCH
	.OTPLT==7			;TYPE	PLOTTER
	.OTTRM==10			;TYPE	TERMINAL
	.OTJOB==11			;TYPE	JOB (T/S)
	.OTOPR==12			;TYPE	OPERATOR
	.OTIBM==13			;TYPE	IBM
	.OTMNT==14			;TYPE	MOUNT
	.OTFTS==15			;TYPE	FILE TRANSFER
	.OTBIN==16			;TYPE	CARD INTERPRETER PROGRAM
	.OTRET==17			;TYPE	FILE RETRIEVAL
	.OTNOT==20			;TYPE	RETRIEVAL NOTIFICATION
	.OTDBM==21			;TYPE	DBMS
	.OTFAL==22			;TYPE	FAL
	.OTSNA==23			;TYPE	SNA
	.OTMAX==.OTSNA			;SET THE LARGEST ONE DEFINED
OBJ.UN:! BLOCK	1			;UNIT NUMBER WORD
	OU.HRG==-1,,0			;MASK FOR HIGH RANGE OF UNIT
	OU.LRG==0,,-1			;MASK FOR LOW RANGE OF UNIT
					;HRG=0 MEANS ONLY ONE ITEM
					;HRG=-1MEANS UP TO HIGHEST EXISTING
OBJ.ND:! BLOCK	1			;[307] Node name, kept in SIXBIT
OBJ.SZ:!				;SIZE OF THE OBJECT DESIGNATOR

OBJ.QN:! BLOCK	10			;[307] ASCIZ Queue/Port/Service name
OBJ.SQ:!				;[307] Size of ofject block+queue name
		DEPHASE
SUBTTL	OBJCTS MACRO

;THIS MACRO ASSOCIATES ALL LEGAL OBJECT CODES (SEE OBJECT DESCRIPTOR
; DEFINITION) WITH A TEXT STRING FOR THE OBJECT TYPE


	DEFINE OBJCTS,<

	X	.OTRDR,Reader
	X	.OTNCU,Network-Controller
	X	.OTLPT,Printer
	X	.OTBAT,Batch-Stream
	X	.OTCDP,Card-Punch
	X	.OTPTP,Papertape
	X	.OTPLT,Plotter
	X	.OTJOB,Job
	X	.OTTRM,Terminal
	X	.OTOPR,Operator
	X	.OTIBM,<IBM Remote>
	X	.OTMNT,<Device>
	X	.OTFTS,<File Transfer>
	X	.OTBIN,<Card Reader Interpreter>
	X	.OTRET,<File Retrieval>
	X	.OTNOT,<Retrieval Notification>
	X	.OTDBM,<DBMS System>
	X	.OTFAL,<File Access Listener>
	X	.OTSNA,<SNA Workstation>
> ;END OF OBJCTS DEFINITION

	SUBTTL	FD - File Descriptor

; The FD (File Descriptor) is the data structure used to pass a system
;	dependent file description to subroutines or as part of a larger
;	message or data structure.


	PHASE	0

.FDLEN:! BLOCK	1			;LENGTH WORD
	FD.LEN==-1,,0			;MASK TO LENGTH FIELD
	FD.TYP==0,,-1			;TYPE OF FD
	   .FDNAT==0			;NATIVE FILE DESCRIPTOR
	   .FDLOC==1			;ASCIZ LOCAL FILE DESRIPTOR
	   .FDNET==2			;ASCIZ REMOTE FILE DESCRIPTOR
	   .FDFRN==3			;ASCIZ FORIEGN FILE DESCRIPTOR
					;  (NON-DECNET)

.FDFIL:!				;FIRST WORD OF FILESPECIFICATION

	DEPHASE

TOPS10 <	;FILE DESCRIPTOR FOR TOPS10

;	!=======================================================!
;	!		   LENGTH OF THE FD			!
;	!-------------------------------------------------------!
;	!             STRUCTURE CONTAINING THE FILE             !
;	!-------------------------------------------------------!
;	!                       FILE NAME                       !
;	!-------------------------------------------------------!
;	!                       EXTENSION                       !
;	!-------------------------------------------------------!
;	!                        [P,PN]                         !
;	!=======================================================!
;	!                                                       !
;	!                 SFD PATH FOR THE FILE                 !
;	!               THESE WORDS ARE OPTIONAL                !
;	!             AND CAN BE OF LENGTH  0 TO 5              !
;	!                                                       !
;	!=======================================================!

	PHASE	.FDFIL

.FDSTR:! BLOCK	1		;STRUCTURE CONTAINING THE FILE
.FDNAM:! BLOCK	1		;THE FILE NAME
.FDEXT:! BLOCK	1		;THE EXTENSION
.FDPPN:! BLOCK	1		;THE OWNER OF THE FILE
FDMSIZ:!			;MINUMUM SIZE OF A FILE DESCRIPTOR

.FDPAT:! BLOCK	5		;PATH (OPTIONAL AND FROM 0 TO 5 WORDS)
FDXSIZ:!			;MAXIMUM FD AREA SIZE

	DEPHASE

>  ;END OF TOPS10

					;CONTINUED ON FOLLOWING PAGE
TOPS20 <		;FILE DESCRIPTOR FOR TOPS20 (FD.TYP==.FDNAT)

;	!=======================================================!
;	/                                                       /
;	/                                                       /
;	/   THE FILE DESCRIPTOR ON TOPS20 IS AN ASCIZ STRING    /
;	/      OF VARIABLE LENGTH AND READY TO BE GTJFN'ED      /
;	/                                                       /
;	/                                                       /
;	!=======================================================!

	PHASE	.FDFIL

.FDSTG:! BLOCK	1		;ASCIZ STRING FOR GTJFN/OPENF SEQUENCE
FDMSIZ:!			;MINIMUM SIZE OF A FILE DESCRIPTOR
FDXSIZ==^D300/^D5		;RESERVE ROOM FOR 300 CHARACTERS

	DEPHASE

>  ;END OF TOPS20


;		FILE DESCRIPTOR FOR LOCAL FILE (FD.TYP==.FDLOC)

;	!=======================================================!
;	/                                                       /
;	/   THE FILE DESCRIPTOR FOR THE LOCAL FILESPEC MAY BE   /
;	/   AN ASCIZ STRING IN A FORM ACCEPTABLE TO THE LOCAL   /
;	/   SYSTEM						/
;	/   DEV:[PPN]FILE.EXT OR DEV:[DIRECTORY]FILE.EXT.GEN	/
;	/                                                       /
;	!=======================================================!



;		FILE DESCRIPTOR FOR REMOTE DECNET NODE (FD.TYP==.FDNET)

;	!=======================================================!
;	/                                                       /
;	/   THE FILE DESCRIPTOR FOR A DECNET FILESPEC IS AN	/
;	/   ASCIZ STRING OF THE FORM NODE::DEV:[PPN]FILE.EXT	/
;	/   OR NODE::DEV:[DIRECTORY]FILE.EXT.GEN		/
;	/                                                       /
;	!=======================================================!


;		FILE DESCRIPTOR FOR A FORIEGN NODE (FD.TYP==.FDFRN)

;	!=======================================================!
;	/                                                       /
;	/   THE FILE DESCRIPTOR FOR A FORIEGN NODE IS AN ASCIZ	/
;	/   STRING OF THE FORM:					/
;	/   NODE::REMOTE-FILESPEC OR NODE::"REMOTE-FILESPEC"	/
;	/                                                       /
;	!=======================================================!

SUBTTL FOB - Parameter block passed to F%IOPN and F%OOPN

; THE FOLLOWING IS A DESCRIPTION OF THE BLOCK USED AS A PARAMETER
; PASSING AREA TO THE TWO FILE OPEN ROUTINES IN GLXFIL.

;	!=======================================================!
;	!      ADDRESS OF FD TO USE FOR FILE SPECIFICATION      !
;	!-------------------------------------------------------!
;	!				      !LSN!NFO!BYTE SIZE!
;	!-------------------------------------------------------!
;	!       FIRST HALF OF USER ID FOR "IN BEHALF OF"        !
;	!-------------------------------------------------------!
;	!          CONNECTED  DIRECTORY (TOPS-20 ONLY)          !
;	!=======================================================!

		PHASE	0

FOB.FD:! BLOCK	1			;POINTER TO FD AREA
FOB.CW:! BLOCK	1			;CONTROL WORD
;**;[240]Insert one line at FOB.CW:+1L	JCR	8/13/85
	   FB.SUP==1B26			;[240]File open (superseding)
	   FB.PHY==1B27			;PHYSICAL OPEN
	   FB.LSN==1B28			;LINE SEQUENCE NUMBERS APPEAR (IGNORE)
	   FB.NFO==1B29			;NEW FILE ONLY (NON-SUPERSEDING)
	   FB.BSZ==77B35		;BYTE SIZE OF THE FILE

FOB.MZ:!				;MINIMUM SIZE OF A FOB

FOB.US:! BLOCK	1			;USER ID FOR "IN BEHALF" OPERATIONS
FOB.CD:! BLOCK	1			;CONNECTED DIRECTORY (TOPS-20)
FOB.AB:! BLOCK	1			;FILE ATTRIBUTE BLOCK ADDRESS

FOB.SZ:!				;SIZE OF AN FOB

		DEPHASE


; File attribute definitions
;
FI.IMM==1B0		;ARGUMENT IS AN IMMEDIATE VALUE
FI.LEN==777B17		;LENGTH (IN WORDS) OF ATTRIBUTE
FI.ATR==777777B35	;FILE ATTRIBUTE MASK
   .FIPRO==1		   ;PROTECTION CODE
   .FIACT==2		   ;ACCOUNT STRING
   .FISPL==3		   ;SPOOLED FILE NAME
   .FIMAX==.FISPL	   ;HIGHEST LEGAL ATTRIBUTE TYPE
SUBTTL FRB - Parameter block passed to F%REN for renames

; THE FOLLOWING BLOCK IS SET UP BY THE CALLER OF F%REN IN GLXFIL.
; THE BLOCK PROVIDES THE SOURCE AND DESTINATION OF THE RENAME, AS
; WELL AS NEEDED PROTECTION INFORMATION.

;	!=======================================================!
;	!     POINTER TO FD DESCRIBING SOURCE OF THE RENAME     !
;	!-------------------------------------------------------!
;	!  POINTER TO FD DESCRIBING DESTINATION OF THE RENAME   !
;	!-------------------------------------------------------!
;	!           USER ID FOR AN "IN BEHALF" RENAME           !
;	!-------------------------------------------------------!
;	!CONNECTED DIRECTORY FOR AN "IN BEHALF" RENAME (TOPS-20)!
;	!-------------------------------------------------------!
;	! 		    FLAG BITS				!
;	!=======================================================!


			PHASE 0

FRB.SF:! BLOCK	1			;POINTER TO FD OF SOURCE FILE
FRB.DF:! BLOCK	1			;POINTER TO FD OF DESTINATION FILE

FRB.MZ:!				;MINIMUM SIZE OF AN FRB

FRB.US:! BLOCK	1			;USER ID FOR IN BEHALF
FRB.CD:! BLOCK	1			;CONNECTED DIRECTORY (TOPS20)
FRB.FL:! BLOCK	1			;RENAME FLAG BITS
   FR.NFO==1B0				   ;NEW FILE ONLY
   FR.PHY==1B1				   ;PHYSICAL RENAME
FRB.AB:! BLOCK	1			;FILE ATTRIBUTE BLOCK ADDRESS

FRB.SZ:!				;SIZE OF AN FRB

			DEPHASE
SUBTTL IB  - Initialization Block for GALAXY programs

;All programs which make use of the GALAXY library or runtime system
;	must go through an initialization call to insure that the
;	modules are in a determinant state, and also to set up the
;	profile that this program wants.  This initialization is
;	carried out using a communications area, the Initialization
;	Block, from which parameters are read and information filled in.
;
;	The initialization call to I%INIT is made with S1 containing the
;	size of the IB and S2 containing its address.

;	Initialization Block (IB):

;	!=======================================================!
;	!    Address of output routine for defaulted $TEXTs     !
;	!-------------------------------------------------------!
;	!	            program-wide flags                  !
;	!-------------------------------------------------------!
;	!       Base of program's interrupt vector(s)           !
;	!-------------------------------------------------------!
;	!       PID block address                               !
;	!-------------------------------------------------------!
;	!       $TEXT error exit routine                        !
;	!=======================================================!

		PHASE	0

IB.OUT:!	BLOCK	1		;ADDRESS OF ROUTINE TO CALL FROM
					;OUTPUT ROUTINE IF $TEXT SPECIFIES NONE
IB.FLG:!	BLOCK	1		;Program-wide flag word
	IT.OCT==1B0			; OPEN COMMAND TERMINAL
	IP.STP==1B1			; SEND STOPCODES TO ORION AS WTO IF SET
	IB.DPM==1B2			; USE JOB NUMBER FOR A PID
	IB.NPF==1B3			; DON'T SETUP PFH
	IB.SYS==1B4			; Set up as a system process
	IB.NAC==1B5			; No access to JFNs by an inferior 
IB.INT:!	BLOCK	1		;BASE OF INTERRUPT VECTOR(S)
IB.PIB:!	BLOCK	1		;Address of PID block
IB.ERR:!	BLOCK	1		;USER $TEXT ERROR EXIT ROUTINE ADDRESS.
IB.PRG:!	BLOCK	1		;PROGRAM NAME

IB.SZ:!					;SIZE OF THE IB

		DEPHASE
SUBTTL	PIB - PID block

;This block describes the PID that the program wishes to become, and
;other assorted flavors of IPCF parameters.  It is a parameter
;for the C%CPID, C%KIPD, C%SPID calls, and is aimed at by the IB.

;	!=======================================================!
;	!      Length               !                           !
;	!-------------------------------------------------------!
;	!                PID (filled by GLXLIB)                 !
;	!-------------------------------------------------------!
;	!PSI!JWP!RSE!SPI!CFV!SPB!                               !
;	!-------------------------------------------------------!
;	!      System index         !             !Chan or offst!
;	!-------------------------------------------------------!
;	!      Max # of PIDs        ! Send quota  !Receive quota!
;	!-------------------------------------------------------!
;	!               Pointer to INFO NAME (optional)         !
;	!-------------------------------------------------------!
;	!             Pointer to ACCOUNT string (optional)      !
;	!-------------------------------------------------------!
;	!             Pointer to LOCATION string (optional)     !
;	!=======================================================!

	PHASE	0
PB.HDR:!	BLOCK	1		;The PID block header word
	PB.LEN==LHMASK			;Length of this block
PB.PID:!	BLOCK	1		;The PID assigned (filled by GLXLIB)
PB.FLG:!	BLOCK	1		;Flags
	IP.PSI==1B0			;Connect this PID to the PSI system
	IP.JWP==1B1			;Get a job-wide PID (good till logout)
	IP.RSE==1B2			;Return to caller if send fails
	IP.SPF==1B3			;Special PID Flag (caller wants to
					;  be a system PID)
	IP.SPB==1B5			;SET IF CALLER IS PRIVELEGED AND WISHES
					;   TO SEE IF SENDER SET IP.CFP
PB.INT:!	BLOCK	1		;Interrupt channel or offset
	IP.SPI==LHMASK			;Special PID index
	IP.CHN==77			;Channel
PB.SYS:!	BLOCK	1		;Special index, quotas
	IP.MNP==LHMASK			;Max # PIDs for this job
	IP.SQT==777B26			;Send Quota
	IP.RQT==777B35			;Receive Quota
	IP.BQT==IP.SQT!IP.RQT		;Both Quotas
PB.MNS:!				;Minimum size of a PIB
PB.NAM:!	BLOCK	1		;Pointer to Name string
PB.ACT:!	BLOCK	1		;Pointer to Account string
PB.LOC:!	BLOCK	1		;Pointer to Location string
PB.MXS:!				;Maximum size of PIB
	DEPHASE
SUBTTL	SAB - Send Argument Block passed to C%SEND

;This block describes the IPCF message being sent


;	!=======================================================!
;	!     DESTINATION PID OR ADRS OF NAME STRING		!
;	!-------------------------------------------------------!
;	!                   LENGTH OF MESSAGE                   !
;	!-------------------------------------------------------!
;	!                  ADDRESS OF MESSAGE                   !
;	!-------------------------------------------------------!
;	!FLG!                SYSTEM PID INDEX                   !
;	!-------------------------------------------------------!
;	!           0 or PID Block address to send for          !
;	!=======================================================!

	PHASE 0


SAB.PD:!	BLOCK	1		;PID TO SEND MESSAGE TO
					; OR ADDRS OF NAME STRING
SAB.LN:!	BLOCK	1		;LENGTH OF MESSAGE TO SEND
					; THIS FIELD DEFINES IF THE MESSAGE IS
					; TO BE SENT AS A PAGE OR A PACKET
					; A LENGTH OF EXACTLY 1000 WILL
					; CAUSE A PAGE-MODE SEND OF THE
					; THE PAGE POINTED TO BY SAB.MS
					; OTHERWISE THE MESSAGE WILL BE
					; SENT AS A PACKET IF POSSIBLE OR
					; COPIED TO A NEW PAGE IF NECESSARY
SAB.MS:!	BLOCK	1		;STARTING ADDRESS OF MESSAGE
					; IF SAB.LN CONTAINS 1000, AN ERROR
					; WILL OCCUR IF THIS IS NOT THE
					; FIRST ADDRESS OF A PAGE

SAB.SI:!	BLOCK	1		;INFORMATION ON SPECIAL SYSTEM PID
	SI.FLG==1B0			;SET IF SI.IDX IS TO BE USED
	SI.NAM==1B1			;SET IF SAB.PD CONTAINS THE ADRS OF
					;A STRING (NAME OF PROCESS TO SEND TO)
	SI.IDX==0,,-1			;SENDER'S INDEX IN SYSTEM PID TABLE
					;NOTE, SETTING SP.FLG AND FILLING IN A
					;VALID INDEX IS SUFFICIENT TO IDENTIFY
					;THE DESTINATION OF A SEND. IN THIS CASE,
					;THE DESTINATION PID NEED NOT BE FILLED IN

SAB.PB:!	BLOCK	1		;0, or address of PIB describing PID
					;for which send is to be done

SAB.SZ:!				;LENGTH OF THE SAB

	DEPHASE
SUBTTL	MDB - Message Descriptor Block returned by C%RECV

;This block describes the IPCF message received by C%RECV or C%BRCV

;	!=======================================================!
;	!                         FLAGS                         !
;	!-------------------------------------------------------!
;	!                     SENDER'S PID                      !
;	!-------------------------------------------------------!
;	!                    RECEIVER'S PID                     !
;	!-------------------------------------------------------!
;	!     LENGTH OF MESSAGE     !    ADDRESS OF MESSAGE     !
;	!-------------------------------------------------------!
;	!             SENDER'S LOGGED-IN DIRECTORY              !
;	!-------------------------------------------------------!
;	!                  SENDER'S PRIVILEGES                  !
;	!-------------------------------------------------------!
;	!             SENDER'S CONNECTED DIRECTORY              !
;	!-------------------------------------------------------!
;	!FLG!                SYSTEM PID INDEX                   !
;	!=======================================================!

	PHASE	0

MDB.FG:!	BLOCK	1		;MESSAGE FLAGS (SEE UUOSYM.MAC)
MDB.SP:!	BLOCK	1		;SENDER'S PID
MDB.RP:!	BLOCK	1		;RECEIVER'S PID
MDB.MS:!	BLOCK	1		;MESSAGE INFORMATION
	MD.CNT==-1,,0			;WORD COUNT OF MESSAGE
	MD.ADR==0,,-1			;ADDRESS OF MESSAGE
MDB.SD:!	BLOCK	1		;SENDER'S LOGGED IN DIRECTORY
MDB.PV:!	BLOCK	1		;SENDER'S PRIVILEGES
	MD.PWH==1B0			;PROCESS HAS WHEEL PRIVILEGES
	MD.POP==1B1			;PROCESS HAS OPERATOR PRIV.
	MD.PMT==1B2			;PROCESS HAS MAINTENANCE PRIV.
	MD.SEM==1B8			;[305]PROCESS HAS SEMI-OPR PRIV.	
	MD.PJB==0,,-1			;JOB NUMBER OF SENDER
MDB.CD:!	BLOCK	1		;SENDER'S CONNECTED DIRECTORY
MDB.SI:!	BLOCK	1		;SENDER'S SPECIAL SYSTEM PID TABLE INFO
	SI.FLG==1B0			;SET IF SI.IDX IS TO BE USED
	SI.IDX==0,,-1			;SENDER'S INDEX IN SYSTEM PID TABLE
MDB.PR:!	BLOCK	1		;Sender's enabled capabilities 
MDB.SZ:!				;MDB LENGTH

DEPHASE
SUBTTL Special system PIDS

;For convenience, we define a macro which can generate code or data
;for all system PIDS which are of interest to the GALAXY library.
;Anyone interested in generating data or code for all special PIDS should
;define the .SPID macro, and invoke SPIDS
;The .SPID MACRO will take 4 params, a canonical index name, TOPS10 value,
;TOPS20 value, SIXBIT name of debugging component

DEFINE SPIDS,<
.SPID	(SP.QSR,.IPCPQ,.SPQSR,QUASAR)	;;QUASAR
.SPID	(SP.OPR,.IPCPO,.SPOPR,ORION)	;;ORION
.SPID	(SP.INF,.IPCPI,.SPINF,INFO)	;;INFO
.SPID	(SP.MDA,.IPCPM,.SPMDA,MDA)	;;Mountable device allocator
.SPID	(SP.NEB,,.SPNEB,NEBULA)		;;[313]CLUSTER MESSAGE ROUTER
TOPS10<
.SPID	(SP.IPC,.IPCPS,,IPCC)		;;IPC Controller
.SPID	(SP.ACT,.IPCPA,,ACTDAE)		;;Accouting DAEMON
.SPID	(SP.TLP,.IPCPT,,TAPLAB)		;;Tape labelling process
.SPID	(SP.TOL,.IPCPC,,TAPAVR)		;;Tape Auto-Vol-Recognizer
.SPID	(SP.DOL,.IPCPD,,DSKAVR)		;;Disk Auto-Vol-Recognizer
.SPID	(SP.FIL,.IPCPF,,FILDAE)		;;File DAEMON
>;;End TOPS10
>;End DEFINE SPIDS
SUBTTL System Independent IPCF Codes and Constants

;The constants and codes presented here are used to prevent
;too many feature test switches in the various modules.  When the two
;operating systems present two different codes for the same error
;situation, or two different indices for the same type of entry in a table,
;we can use SYSPRM to make up a canonical code for use by the GALAXY system.
;This makes for more readable code and lessens the  chance of error.

;IPCF error messages

	SYSPRM	IPE.SQ,IPCRS%,IPCFX6	;SENDER'S QUOTA EXHAUSTED
	SYSPRM	IPE.RQ,IPCRR%,IPCFX7	;RECEIVER'S QUOTA EXHAUSTED
	SYSPRM	IPE.SF,IPCRY%,IPCFX8	;SYSTEM FREE SPACE EXHAUSTED
;**;[266]Add one line after IPE.SF	JYCW	10/7/85
	SYSPRM	IPE.SS,777777,MONX06	;[266]No swappable free space
	SYSPRM	IPE.DU,IPCDU%,IPCFX4	;DESTINATION PID IS UNKNOWN
	SYSPRM	IPE.DD,IPCDD%,IPCFX5	;DESTINAION PID IS DISABLED
	SYSPRM	IPE.WM,IPCPR%,IPCF16	;RECEPTION IN THE WRONG MODE
	SYSPRM	IPE.NR,IPCUP%,777777	;NO ROOM IN CORE (TOPS-10 ONLY)
	SYSPRM	IPE.NM,IPCNP%,IPCFX2	;NO MESSAGE IS AVAILABLE

;IPCF codes

	SYSPRM	IP.CFV,IP.CFV,IP%CFV	;PAGE MODE BIT
	SYSPRM	IP.CFC,IP.CFC,IP%CFC	;FROM SYSTEM INFO OR IPCC
	SYSPRM	IP.CFE,IP.CFE,IP%CFE	;ERROR INDICATOR'S IN DESCRIPTOR
	SYSPRM	IP.CFM,IP.CFM,IP%CFM	;A RETURNED MESSAGE
	SYSPRM	IP.CFP,IP.CFP,IP%CFP	;PRIVILEGED SEND
	SYSPRM	IP.TTL,IP.CFT,IP%TTL	;TRUNCATE IF TOO LONG
	SYSPRM	IP.CFB,IP.CFB,IP%CFB	;DO NOT BLOCK ON RECEIVE
	SYSPRM	IP.CFS,IP.CFS,IP%CFS	;INDIRECT SENDERS PID
	SYSPRM	IP.CFR,IP.CFR,IP%CFR	;INDIRECT RECIEVERS PID

;Special System PID table indices

DEFINE .SPID(CANNAM,T10IDX,T20IDX,SYMBOL),<
	SYSPRM	CANNAM,T10IDX,T20IDX
>;END DEFINE .SPID
	SPIDS				;Generate the special PIDS

DEFINE .SPID(CANNAM,T10IDX,T20IDX,SYMBOL),<
	IFG	CANNAM-MX.PID,<MX.PID==CANNAM>
>;END DEFINE .SPID
	MX.PID==0			;Start with 0 as the max
	SPIDS				;Find the maximum
	MX.PID==MX.PID			;Publish the maximum
SUBTTL Program internal parameters of interest

; IN ORDER THAT CALLERS OF GLXLIB PROGRAMS CAN MAKE THE MOST EFFICIENT
;    USE OF THEM, SEVERAL PARAMETERS WHICH ARE REALLY INTERNAL TO THE
;    SEPARATE COMPONENTS ARE DECLARED HERE, SO THAT THEY ARE ACCESSIBLE.
;
; VALUES DECLARED HERE ARE "READ-ONLY" AND SHOULD NOT BE CHANGED
;    WITHOUT CONSULTING THE LISTING OF THE ACTUAL GLXLIB COMPONENT.

; PARAMETERS USED BY:	GLXFIL

	SYSPRM	SZ.IFN,^D30,^D30	;NUMBER OF FILES OPEN SIMULTANEOUSLY
	SYSPRM	SZ.BUF,200,1000		;SIZE OF BUFFER AREA
	SYSPRM	SZ.OBF,200,1000		;MAXIMUM WORDS XFERRED ON F%?BUF CALL
	SYSPRM	.PRIIN,377776,.PRIIN	;PRIMARY INPUT JFN
	SYSPRM	.PRIOU,377777,.PRIOU	;PRIMARY OUTPUT JFN
	SYSPRM	.NULIO,377775,.NULIO	;NULL I/O JFN

; PARAMETERS USED BY:	GLXIPC

	ND	SZ.PAK,PAGSIZ-1		;MAXIMUM SIZE OF A SHORT PACKET
	ND	SZ.PID,MX.PID+1		;MAXIMUM NUMBER OF SYSTEM PIDS
	ND	RT.SLP,^D3		;TIME TO SLEEP (SECS) BETWEEN RETRIES
	ND	RT.SFL,^D5		;RETRIES ON A SEND FAILURE
	ND	RT.SCL,^D60		;RETRIES ON A SYSTEM-COMPONENT TIME-OUT

; PARAMETERS USED BY:	GLXMEM

	ND	DDCNT,5			;PAGES ADDED TO FREE POOL BEFORE
					;DUMPING DICTIONARY
	ND	DCT.MN,1		;MINIMUM SIZE OF ENTRIES IN DICTIONARY
	ND	DCT.MX,^D50		;MAXIMUM SIZE OF ENTRY IN DICT
	ND	IPCPAD,1		;MINIMUM NUMBER OF PAGES THAT MUST BE FREE
					;BEFORE M%NXPG WILL RETURN ONE
	ND	CNK.PM,^D24	;CHUNK MANAGERS PAGE COUNT BEFORE CLEANUP
	ND	PAGAVL,^D10	;MAX PAGES IN MEM MANAGER BEFORE CLEANUP

	PT.FLG==777		;FLAG FIELD OF PAGE TABLE ENTRY
	  PT.USE==1B35		;INDICATES PAGE IS IN USE
	  PT.ADR==1B34		;PAGE IS ADDRESSABLE (I.E. EXISTS)
	  PT.INI==1B33		;PART OF INITIAL IMAGE (I.E. CODE, ETC.)
	PT.KEE==1B0		;[312]KEEP THIS PAGE AFTER A SEND

; PARAMETERS USED BY:	GLXOTS & GLXINI

	TOPS10 <OTSNAM==SIXBIT /GLXLIB/>	;LIBRARY NAME
	TOPS20 <DEFINE OTSNAM,< [ASCIZ \GLXLIB.EXE\]>>

; PARAMETERS USED BY:	GLXINT

	INT.MX==3		;INTERRUPT LEVELS TO INCLUDE
	SYSPRM	INT.LV,1,3	;MAXIMUM NUMBER OF ACTIVE INTERRUPT LEVELS
	ND	IPL.SZ,^D50	;INTERRUPT STACK DEPTH


	SUBTTL	$HALT	- Halt a Program without Reset

	SYSPRM	$HALT,<EXIT 1,>,<HALTF>	;EXIT WITHOUT RESET
	SUBTTL PDB - PARSER DESCRIPTOR BLOCK DEFINITION

; THE PARSER DESCRIPTOR BLOCK (PDB) IS THE BASIC DATA STRUCTURE USED TO
;CONTROL THE ACTION OF THE PARSER ROUTINE. THE PDB CONSISTS OF THE STANDARD
;FUNCTION DESCRIPTOR BLOCK (FDB) AS USED BY THE COMND JSYS, PLUS FOUR
;ADDITIONAL WORDS USED BY THE PARSER ROUTINE TO CONTROL THE PARSE. THE PDBDEF
;MACRO IS USED TO BUILD A PDB AND ALLOWS THE PROGRAMMER TO SPECIFY ALL OF
;THE FIELD PARAMETERS. IN ADDITION, THERE ARE A NUMBER OF MNEMONIC MACROS
;WHICH ALLOW THE USER TO BUILD FUNCTION SPECIFIC PDBS' AND PROVIDE A COMMON
;SUBSET OF THE PARAMETER FIELDS. THE PDBS' ARE LINKED THROUGH A NEXT PDB
;CHAIN FIELD, AND AN ALTERNATE PDB CHAIN FIELD TO FORM A TREE LIKE STRUCTURE
;WHICH DEFINES THE COMMAND SYNTAX. THE PARSE ROUTINE, WHEN PASSED THE ADDRESS
;OF THE ROOT OF THE TREE, THEN PARSES ONE COMPLETE COMMAND AND RETURNS CONTROL
;TO THE CALLER. THERE IS A PROVISION FOR THE USER TO SPECIFY EXIT ROUTINES
;WITHIN EACH PDB WHICH WILL BE CALLED AT CRITICAL POINTS AS THE PARSE
;PROGRESSES.
;
; THE FORMAT OF THE PARSER DESCRIPTOR BLOCK IS SHOWN BELOW:
;
;
;
;	!=======================================================!
;	!  FUNCTION   !  FUNCTION   ! ADDRESS OF NEXT FUNCTION  !
;	!    CODE     !    FLAGS    !     DESCRIPTOR BLOCK      !
;	!-------------------------------------------------------!
;	!              DATA FOR SPECIFIC FUNCTION               !
;	!-------------------------------------------------------!
;	!            POINTER TO HELP TEXT FOR FIELD             !
;	!-------------------------------------------------------!
;	!          POINTER TO DEFAULT STRING FOR FIELD          !
;	+-------------------------------------------------------+
;	!          SPECIAL ACTION ROUTINE FOR THIS PDB          !
;	!-------------------------------------------------------!
;	!              PDB DEFAULT FILLING ROUTINE              !
;	!-------------------------------------------------------!
;	!                     ERROR ROUTINE                     !
;	!-------------------------------------------------------!
;	!             CHAIN POINTER TO LINKED PDB'S             !
;	!=======================================================!
	SUBTTL PDBDEF - PDBDEF MACRO DEFINITION


; THE FORM OF THE PDBDEF MACRO CALL IS:

;PDBDEF (TYP,FLGS,DATA,HLPM,DEFM,LST,NXT,ERRTN,RTN,DEFR)

; ARGUMENTS TO THE PDBDEF MACRO ARE:
;
;
;	TYP	TYPE OF FDB, IE. .CMKEY
;	FLGS	FUNCTION SPECIFIC FLAGS
;	DATA	FUNCTION SPECIFIC DATA
;	HLPM	BYTE POINTER FOR HELP TEXT
;	DEFM	POINTER TO DEFAULT
;	LST	POINTER TO ALTERNATE FDB
;	NXT	PTR TO NEXT FDB (OPTIONAL FOR TYPE .CMKEY OR .CMSWI)
;	ERRTN	ROUTINE IF AN ERROR IS GOTTEN POINTING TO THIS PDB
;	RTN	SPECIAL ACTION ROUTINE FOR THIS PDB
;	DEFR	SPECIAL ROUTINE TO FILL IN DEFAULTS FOR THIS PDB


DEFINE PDBDEF(TYP,FLGS,DATA,HLPM,DEFM,LST,NXT,ERRTN,RTN,DEFR),<

	..XX==<FLD(TYP,CM%FNC)>+FLGS+<Z LST> ;;DEFINE .CMFNP WORD OF COMND FDB

   IFNB <HLPM>,<..XX=..XX!CM%HPP> ;;IF HELP TEXT, INCLUDE FLAG BIT
   IFNB <DEFM>,<..XX=..XX!CM%DPP> ;;IF DEFAULT TEXT, INCLUDE FLAG BIT

	EXP ..XX		;;ASSEMBLE THE .CMFNP WORD

   IFNB <DATA>,<EXP DATA>
   IFB <DATA>,<EXP 0>

   IFNB <HLPM>,<POINT 7,[ASCIZ \HLPM\]>
   IFB <HLPM>,<0>

   IFNB <DEFM>,<POINT 7,[ASCIZ \DEFM\]>
   IFB <DEFM>,<0>

;;THE REST OF THE DEFINITION IS NOT USED BY THE JSYS BUT ONLY BY THE PARSER

   IFB <RTN>,<0>
   IFNB <RTN>,<EXP RTN>

   IFB <DEFR>,<0>
   IFNB <DEFR>,<EXP DEFR>

   IFB <ERRTN>,<0>
   IFNB <ERRTN>,<EXP ERRTN>

   IFB <NXT>,<0>
   IFNB <NXT>,<EXP NXT>

>;END OF DEFINITION OF PDBDEF MACRO
	SUBTTL	PDB  -  PARSER DESCRIPTOR BLOCK

	;THIS BLOCK DEFINES THE OFFSETS AFTER THE FDB FOR THE PDB
	;RELATED ROUTINES.

	PB%HDR==0		;HEADER FOR THE BLOCK
	 PB.PDB==-1,,0		;OFFSET FOR PDB LENGTH
	 PB.FDB==0,,-1		;OFFSET FOR FDB LENGTH

	PHASE	0

PB%NXT:! BLOCK	1			;NEXT PDB TO USE
PB%RTN:! BLOCK	1			;ACTION ROUTINE FOR THE PARSER
PB%ERR:! BLOCK	1			;ERROR ROUTINE
PB%DEF:! BLOCK	1			;DEFAILT FILLING ROUTINE
PB%SIZ:! 				;SIZE OF MAXIMUM PDB DATA


	DEPHASE
IFN	FTUUOS,< .CMBRK==.CMDEF+1>	;DEFINE THE BREAK FIELD
IFN	FTUUOS,< CM%BRK==1B13>	;BREAK BIT FOR THE -10

PDB.SZ==.CMBRK+PB%SIZ

	COMMENT \

PDB.FD:!	BLOCK	.CMDEF+1 ;ALLOCATE SPACE FOR AN FDB
PDB.RT:!	BLOCK	1	;SPECIAL ACTION ROUTINE ADDRESS
PDB.DF:!	BLOCK	1	;DEFAULT FILLING ROUTINE ADDRESS
PDB.ER:!	BLOCK	1	;ERROR MESSAGE ROUTINE ADDRESS
PDB.NX:!	BLOCK	1	;ADDRESS OF PDB TO USE NEXT
PDB.SZ:!			;SIZE OF A PDB

	DEPHASE

	\;END OF COMMENT
	SUBTTL COMMAND FUNCTION MACROS

; THE FOLLOWING FUNCTION SPECIFIC MACROS ARE PROVIDED FOR THE PURPOSE OF
;DEFINING THE PDB COMMAND TREE. THE MACROS AND THEIR SYNTAX IS SHOWN BELOW:

; Where upper case identifies keywords which must be coded as shown
;and lower case identifies variable information which must be provided
;by the programmer, e.g., a symbol which represents the address of a
;block.

; The variable parameters are as follows -

; "next__pdb_address" is the address of the next parser data block to use
;in the parse

; "table__address" is the address of keyword table in TBLUK format

; "radix" is the radix in which the number will be input, in octal

; "help__text" is a string to be output on a ?

; "noise__text" is string representing the noise phrase

; "keyword__list" is an optional list of keywords representing additional
;functions

; where the general form of a keyword parameter is

; 	KEYWORD (argument)

; the entire list of keywords must be enclosed by angle brackets "<", ">"
;and the keyword elements are separated blanks or a comma


;	the valid keywords are
;
;	$DEFAULT (default__string)
;
;	$PDEFAULT (default__address)
;
;	$ALTERNATE (alternate__pdb)
;
;	$NEXT (next__pdb__address)
;
;	$ERROR (error__routine)
;
;	$ERRPDB (next_pdb)
;
;	$ACTION (special__action__routine)
;
;	$PREFILL (default__filling__routine)

;	EXAMPLE:

;	$KEY (NOIPDB,KYTBL1,<$ACTION(CHKIT)>)
;
;;	$KEY (next__pdb__address,table__address,keyword__list)
;
;;	$KEYDSP (table__address,keyword__list)
;
;;	$NUMBER (next__pdb__address,radix,help__text,keyword__list)
;
;;	$DIGIT (next__pdb__address,radix,help__text,keyword__list)
;
;;	$NOISE (next__pdb__address,noise__text,keyword__list)
;
;;	$SWITCH (next__pdb__address,table__address,keyword__list)
;
;;	$IFILE (next__pdb__address,help__text,keyword__list)
;
;;	$OFILE (next__pdb__address,help__text,keyword__list)
;
;;	$FIELD (next__pdb__address,help__text,keyword__list)
;
;;	$CRLF (,keyword__list)
;
;;	$DIR (next__pdb__address,keyword__list)
;
;;	$USER (next__pdb__address,keyword__list)
;
;;	$COMMA (next__pdb__address,keyword__list)
;
;;	$INIT (next__pdb__address,keyword__list)
;
;;	$FLOAT (next__pdb__address,help__text,keyword__list)
;
;;	$DEV (next__pdb__address,keyword__list)
;
;;	$CTEXT (next__pdb__address,help__text,keyword__list)
;
;;	$DATE (next__pdb__address,keyword__list)
;
;;	$TIME (next__pdb__address,keyword__list)
;
;;	$TAD (next__pdb__address,keyword__list)
;
;;	$QUOTE (next__pdb__address,help__text,keyword__list)
;
;;	$TOKEN (next__pdb__address,token__character,keyword__list)
;
;;	$NODNM (next__pdb__address,help__text,keyword__list)
;
;;	$ACCOUNT (next__pdb__address,help__text,keyword__list)
;
;;	$UQSTR (next__pdb__address,BRKSET,help__text,keyword__list)



; THE FOLLOWING SUPPORT MACROS ARE DEFINED TO ALLOW THE USER TO DEFINE THE
;KEYWORD AND SWITCH TABLES USED BY THE KEYWORD AND SWITCH PDB'S:

;
;;	DSPTAB (next__pdb__address,user__code,keyword__entry,[flags])
;
;;	KEYTAB (user__code,keyword__entry)
;
;;	$STAB
;
;;	$ETAB
;

DEFINE $TYPE (ARG),<DEFINE .$TYP <ARG>
			.%TYPE==1>

DEFINE $FLAGS (ARG),<DEFINE .$FLGS <ARG>
			.%FLGS==1>

DEFINE $PDATA (ARG),<DEFINE .$DATA <ARG>
			.%DATA==1>

DEFINE $HELP (ARG),<
	IFDIF <ARG> <>,<
DEFINE .$HLPM <POINT 7,[ASCIZ\ARG\]>
			.%HLPM==1>>

DEFINE $DEFAULT (ARG),<DEFINE .$DEFM <POINT 7,[ASCIZ\ARG\]>
			.%DEFM==1>

DEFINE $PDEFAULT (ARG),<DEFINE .$DEFM <POINT 7,<ARG>>
			.%DEFM==1>

DEFINE $ALTERNATE (ARG),<DEFINE .$LST <ARG+1>
			.%LST==1>

DEFINE $NEXT (ARG),<DEFINE .$NXT <ARG>
			.%NXT==1>

DEFINE $ERROR (ARG),<DEFINE .$ERTN <ARG>
			.%ERTN==1>

DEFINE $BREAK (ARG),<DEFINE .$BREA <ARG>
			.%BREA==1>

DEFINE $ERRPDB (ARG),<DEFINE .$ERTN <1B0+ARG+1>
			.%ERTN==1>

DEFINE $ERRTXT (ARG),<DEFINE .$ERTN <[MOVEI S2,[ASCIZ\ARG\]
				      $RETF]>
			.%ERTN==1>


DEFINE $ACTION (ARG),<DEFINE .$RTN <ARG>
			.%RTN==1>

DEFINE $PREFILL (ARG),<DEFINE .$DEFR <ARG>
			.%DEFR==1>

	SUBTTL	INITIALIZE PARSER MACRO MACROS

;INITIALIZE ALL THE INNER MACROS
;

	$TYPE (0)
	$FLAGS (0)
	$HELP (<>)
	$DEFAULT (0)
	$ALTERNATE (0)
	$NEXT (0)
	$ERROR (0)
	$BREAK (0)
	$ACTION (0)
	$PREFILL (0)
	DEFINE	NEXT(FOO),<TEMFDB##>
	;***REMOVE THIS DEFINITION
	C.SWIT==1B0
	DEFINE	SHRSWT,<C.SWIT+PDBCPY##>

DEFINE .$RESET <
	SALL
	XLIST
	DEFINE .$TYP <0>
	.%TYPE==0
	DEFINE .$FLGS <0>
	.%FLGS==0
	DEFINE .$DATA <0>
	.%DATA==0
	DEFINE .$HLPM <>
	.%HLPM==0
	DEFINE .$DEFM <0>
	.%DEFM==0
	DEFINE .$LST <0>
	.%LST==0
	DEFINE .$BREA <0>
	.%BREA==0
	DEFINE .$NXT <0>
	.%NXT==0
	DEFINE .$ERTN <0>
	.%ERTN==0
	DEFINE .$RTN <0>
	.%RTN==0
	DEFINE .$DEFR <0>
	.%DEFR==0>;END OF .$RESET


	SUBTTL	.$BUILD MACRO

;REDEFINE PDB.XX

DEFINE .$BUILD (%FDBL,%PDBL,%PDB,%FLAG) <			;;BUILD A PDB

	%FLAG==<FLD(.$TYP,CM%FNC)>!.$FLGS!<.$LST> ;;DEFINE .CMFNP WORD OF FDB

	IFN <.%BREA>,<%FLAG==%FLAG!CM%BRK> ;; IF BREAK SET IS PROVIDED

	IFN <.%HLPM>,<%FLAG==%FLAG!CM%HPP!CM%SDH> ;;IF HELP TEXT, INCLUDE FLAG
						;;BIT AND SUPPRESS HELP

	IFN <.%DEFM>,<%FLAG==%FLAG!CM%DPP> ;;IF DEFAULT, INCLUDE FLAG BIT

%PDB:!	XWD	%PDBL,%FDBL			;; LENGTH OF PDB,LENGTH OF FDB

	EXP %FLAG				;;ASSEMBLE WORD .CMFNP OF FDB

	EXP .$DATA			;;ASSEMBLE WORD .CMDAT OF FDB

IFN <.%HLPM!.%DEFM!.%BREA>,<
		EXP	.$HLPM>		;;ASSEMBLE WORD .CMHLP OF FDB


IFN <.%DEFM!.%BREA>,<
		EXP	.$DEFM>		;;ASSEMBLE WORD .CMDEF OF FDB


IFN <.%BREA>,<	EXP	.$BREA>		;;ASSEMBLE WORD .CMBRK FOR THE FDB

	%FDBL==.-%PDB			;LENGTH OF THE FDB

IFN <.%NXT!.%DEFR!.%RTN!.%ERTN>,< EXP .$NXT >	;;ASSEMBLE WORD PDB.NX OF PDB

IFN <.%DEFR!.%RTN!.%ERTN>,<EXP .$RTN >	;;GENERTAT ACTION ROUTINE

IFN <.%DEFR!.%ERTN>,<	EXP	.$ERTN>	;;GENERATE THE ERROR ROUTINE

IFN <.%DEFR>,<		EXP	.$DEFR>	;;GENERATE DEFAULT FILLING ROUTINE


	%PDBL==.-%PDB			;;LENGTH OF THE WHOLE BLOCK

	IF2<	PURGE %FDBL,%PDBL,%PDB,%FLAG>
	LIST>;END .$BUILD

	SUBTTL	PARSER MACROS FOR EACH FUNCTION

DEFINE $KEYDSP (TABLE,ARGLST) <
	.$RESET
	$TYPE (.CMKEY)
	$PDATA (TABLE)
	$NEXT (0)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $KEY (NXT,TABLE,ARGLST) <
	.$RESET
	$TYPE (.CMKEY)
	$PDATA (TABLE)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>



DEFINE $NUMBER (NXT,RADIX,HELP,ARGLST) <
	.$RESET
	$TYPE (.CMNUM)
	$PDATA (RADIX)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $DIGIT (NXT,RADIX,HELP,ARGLST) <
	.$RESET
	$TYPE (.CMNUX)
	$PDATA (RADIX)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>


DEFINE $NOISE (NXT,TEXT,ARGLST) <
	.$RESET
	$TYPE (.CMNOI)
	$PDATA (<POINT 7,[ASCIZ\TEXT\]>)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $SWITCH (NXT,TABLE,ARGLST) <
	.$RESET
	$TYPE (.CMSWI)
	$PDATA (TABLE)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>

DEFINE $SWIDSP (TABLE,ARGLST) <
	.$RESET
	$TYPE (.CMSWI)
	$PDATA (TABLE)
	$NEXT (0)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $IFILE (NXT,HELP,ARGLST) <
	.$RESET
	$TYPE (.CMIFI)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $OFILE (NXT,HELP,ARGLST) <
	.$RESET
	$TYPE (.CMOFI)
	$NEXT (NXT)
	$HELP (<>)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $FILE (NXT,HELP,ARGLST) <
	.$RESET
	$TYPE (.CMFIL)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $FIELD (NXT,HELP,ARGLST) <
	.$RESET
	$TYPE (.CMFLD)
	$NEXT (NXT)
	$HELP (<>)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $CRLF (ARGLST),<
	.$RESET
	$TYPE (.CMCFM)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $DIR (NXT,ARGLST) <
	.$RESET
	$TYPE (.CMDIR)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $USER (NXT,ARGLST) <
	.$RESET
	$TYPE (.CMUSR)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $COMMA (NXT,ARGLST) <
	.$RESET
	$TYPE (.CMCMA)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>



DEFINE $INIT (NXT,ARGLST) <
	.$RESET
	$NEXT (NXT)
	$TYPE (.CMINI)
	IRP ARGLST,<ARGLST>
	.$BUILD>

DEFINE $FLOAT (NXT,HELP,ARGLST) <
	.$RESET
	$TYPE (.CMFLT)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>


DEFINE $DEV (NXT,ARGLST) <
	.$RESET
	$TYPE (.CMDEV)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $CTEXT (NXT,HELP,ARGLST) <
	.$RESET
	$TYPE (.CMTXT)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $DATE (NXT,ARGLST) <
	.$RESET
	$TYPE (.CMTAD)
	$PDATA (CM%IDA)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $TIME (NXT,ARGLST) <
	.$RESET
	$TYPE (.CMTAD)
	$PDATA (CM%ITM)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $TAD (NXT,ARGLST) <
	.$RESET
	$TYPE (.CMTAD)
	$PDATA (<CM%IDA!CM%ITM>)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>

TOPS10<
DEFINE $FTAD (NXT,ARGLST) <
	.$RESET
	$TYPE (.CMTAD)
	$PDATA (<CM%IDA!CM%ITM!CM%FUT>)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>
> ; End of TOPS10


DEFINE $QUOTE (NXT,HELP,ARGLST) <
	.$RESET
	$TYPE (.CMQST)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $UQSTR (NXT,BRKSET,HELP,ARGLST) <
	.$RESET
	$TYPE (.CMUQS)
	$HELP (<>)
	$NEXT (NXT)
	$PDATA (BRKSET)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $NODNM (NXT,HELP,ARGLST) <
	.$RESET
	$TYPE (.CMNOD)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
;	$FLAGS (CM%PO)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $ACCOUNT (NXT,HELP,ARGLST) <
	.$RESET
	$TYPE (.CMACT)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $TOKEN (NXT,CHAR,ARGLST) <
	.$RESET
	$TYPE (.CMTOK)
	$PDATA (<POINT 7,[ASCIZ\CHAR\]>)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


	SUBTTL KEYWORD TABLE MACROS

;DSPTAB - MACRO TO BUILD A DISPATCH TABLE ENTRY
;	USED IN CONJUNCTION WITH $KEYDSP MACRO

DEFINE DSPTAB (NXT,CODE,KEY,FLAGS),<
	IFB <FLAGS>,<
	XWD	[ASCIZ\KEY\],[XWD CODE,NXT]>
	IFNB <FLAGS>,<
	XWD	[EXP CM%FW!FLAGS
		ASCIZ\KEY\],[XWD CODE,NXT]>
>	;END OF DSPTAB MACRO

;KEYTAB - MACRO TO BUILD A KEYWORD OR SWITCH TABLE ENTRY
;	USED IN CONJUNCTION WITH $KEY OR $SWITCH MACRO

DEFINE KEYTAB (CODE,KEY,FLAGS),<
	IFB <FLAGS>,<
	XWD	[ASCIZ\KEY\],CODE>
	IFNB <FLAGS>,<
	XWD	[EXP CM%FW!FLAGS
		ASCIZ\KEY\],CODE>
>	;END OF KEYTAB MACRO

;$STAB/$ETAB - MACROS TO DELINEATE START AND END OF KEYWORD TABLE
;	USED IN CONJUNCTION WITH DSPTAB AND KEYTAB MACROS

DEFINE $STAB (%X,%Y) <
	%X==.
	XWD %Y-1,%Y-1
	DEFINE $ETAB <
		%Y==.-%X>>

	SUBTTL End of GLXMAC
	END

