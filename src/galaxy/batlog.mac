	TITLE	BATLOG	--	BATCH CONTROLLER LOG FILE HANDLER
	SUBTTL	Preliminaries

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1975, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

	SEARCH	GLXMAC		;GET GALAXY SYMBOLS
	PROLOG(BATLOG)

	SEARCH	QSRMAC		;GET QUASAR SYMBOLS
	SEARCH	BATMAC		;GET BATCON SYMBOLS
	SEARCH	ORNMAC		;GET ORION SYMBOLS

	BMLMAN==:0		;Maintenance edit number
	BMLDEV==:42		;Development edit number
	VERSIN (BML)		;Generate edit number

	BMLWHO==0
	BMLVER==6
	BMLMIN==0

	;THE FOLLOWING ARE DEFINED EXTERNAL

	EXTERNAL ATOKJB		;JOB LOGOUT CODE
	EXTERNAL CURTIM		;CURRENT TIME AS TEXT STRING
	EXTERNAL CLOS.1		;CLOSE OUT JOB ROUTINE
	EXTERNAL JOBTOT		;TOTAL NUMBE OF JOBS PROCESSED TO DATE
	EXTERNAL JIBTXT		;JOB INFO BLOCK ITEXT
	Subttl	Table of Contents

;		     Table of Contents for BATLOG
;
;				  Section		      Page
;
;
;    1. Revision History . . . . . . . . . . . . . . . . . . .   3
;    2. L$INIT - LOG FILE INITIALIZATION AND SETUP . . . . . .   4
;    3. L$OUTP - LOG FILE PAGE OUTPUT ROUTINE  . . . . . . . .   5
;    4. L$OUT1 - OUTPUT CHARACTER IN S1 TO LOG . . . . . . . .   6
;    5. L$OPEN - LOG FILE OPEN ROUTINE . . . . . . . . . . . .   7
;    6. L$OPNE - LOG FILE OPEN ERROR ROUTINE . . . . . . . . .   8
;    7. L$IOER - LOG FILE I/O ERROR ROUTINE  . . . . . . . . .   9
;    8. L$NAME - GENERATE NEW LOG FILE NAME  . . . . . . . . .  10
;    9. L$PLOG - PUT A CHARACTER IN LOG WITH FORMATTING  . . .  11
;   10. L$TIME - LOG THE TIME ROUTINE  . . . . . . . . . . . .  12
;   11. L$IDEN - LOG THE LINE IDENTIFIER . . . . . . . . . . .  13
;   12. L$BLNK - LOG A BLANK LINE  . . . . . . . . . . . . . .  14
;   13. L$SIXU - LOG SIXBIT FROM LUUO  . . . . . . . . . . . .  15
;   14. L$LCMA - LOG A COMMA . . . . . . . . . . . . . . . . .  16
;   15. L$CMNT - LOG A COMMENT TO THE LOG FILE . . . . . . . .  17
;   16. L$CHKP - CHECKPOINT THE LOG FILE ROUTINE . . . . . . .  18
;   17. L$LSTP - LOG THE TIME STAMP AND TYPE . . . . . . . . .  19
;   18. PRVOFF - TURN PRIVILEGES OFF FOR QUOTA ENFORCEMENT . .  20
	SUBTTL	Revision History

COMMENT \

*****	Release 4.2 -- begin maintenance edits	*****

EDIT    0		26-January-84
		Currently no edits

*****	Release 5.0 -- begin development edits	*****

EDIT   10	5.1073  27-Jan-84
		Move to new development area. Add version vector. Clean
		up edit organization. Update TOC.

EDIT   11	5.1168	17-Oct-84
		When logging tabs, carriage returns and line feeds to the log
		file do not check for a	generated control character. 

*****	Release 5.0 -- begin maintenance edits	*****

20	Increment maintenance edit level for version 5 of GALAXY.

*****	Release 6.0 -- begin development edits	*****

40	6.1037		26-Oct-87
	Move sources from G5: to G6:

41	6.1057		4-Nov-87
	Change PS: to BS: and PS:[SPOOL] to SPOOL: for Non PS: login feature.

42	6.1225		8-Mar-88
	Update copyright notice.

\	;End of Revision History
	SUBTTL	L$INIT - LOG FILE INITIALIZATION AND SETUP

	;THIS ROUTINE WILL SETUP A PAGE FOR LOG FILE OUTPUT THAT WILL
	;GET OUTPUT TO THE LOG FILE

L$INIT:: $CALL	M%GPAG			;GET THE PAGE
	MOVEM	S1,.JLPAG(R)		;SAVE THE PAGE ADDRESS
	MOVEI	S2,<1000*5>-2		;SETUP FIRST TIME COUNT
	SKIPA				;SKIP OVER NORMAL SETTING
L$SETO:: MOVEI	S2,<1000*5>		;GET NUMBER OF BYTES
	MOVE	S1,.JLPAG(R)		;GET PAGE ADDRESS
	MOVEM	S2,.JLPCT(R)		;SAVE THE COUNT
	MOVSI	S2,(POINT 7,0)		;SETUP BYTE POINTER
	TRNN	F,FR.LFO		;WAS LOG FILE OPEN YET?
	MOVSI	S2,(POINT 7,0,13)	;NO..SKIP FIRST TWO BYTES
	HRR	S2,S1			;PUT ADDRESS IN POINTER
	MOVEM	S2,.JLPTR(R)		;SAVE THE POINTER
	POPJ	P,			;RETURN
	SUBTTL	L$OUTP - LOG FILE PAGE OUTPUT ROUTINE

	;THIS ROUTINE WILL DUMP THE LOG FILE PAGE TO THE FILE AND
	;RESET ALL THE DATA POINTERS

L$OUTP:: TRNE	F,FR.LFO		;IS LOG FILE OPEN YET
	PJRST	OUTP.1			;YES..JUST DUMP THE BUFFER
	PUSHJ	P,L$OPEN		;OPEN THE LOG FILE
	MOVE	S1,.JLJFN(R)		;GET LOG FILE IFN
	MOVEI	S2,FI.SIZ		;GET FILE SIZE
	$CALL	F%INFO			;GET SIZE FROM FILE
	MOVSI	S2,(POINT 7,0)		;MAKE A POINTER
	HRR	S2,.JLPAG(R)		;PUT PAGE ADDRESS IN POINTER
	JUMPE	S1,OUTP.0		;NONE..PROCESS AS  NEW FILE
	MOVEI	S1,CHR.CR		;GET CARRIAGE RETURN
	IDPB	S1,S2			;SAVE THE BYTE
	MOVEI	S1,CHR.FF		;SET UP FORM FEED
	IDPB	S1,S2			;SAVE THE BYTE
	JRST	OUTP.1			;CONTINUE..OUTPUT THE PAGE
OUTP.0:	MOVEI	S1,CHR.CR		;SETUP CARRIAGE RETURN
	IDPB	S1,S2			;SAVE THE BYTE
	MOVEI	S1,CHR.LF		;SETUP LINE FEED
	IDPB	S1,S2			;SAVE THE BYTE
OUTP.1:	TLNE	R,RL.NLG		;LOG FILE AVAILABLE
	PJRST	L$SETO			;SETUP OUTPUT PAGE
IFN	FTJSYS,<
	MOVE	S1,.JQJBB+JIB.SQ(R)	;GET SUBMITTERS ACTIVE PRIVS.
	TXNN	S1,EQ.PRV		;SKIP IF HE WAS ENABLED
	PUSHJ	P,PRVOFF		;TURN OFF PRIVILEGES
>;END FTJSYS
	MOVE	S2,.JLPAG(R)		;GET PAGE ADDRESS IN S2
	MOVEI	S1,<1000*5>		;GET MAX COUNT
	SUB	S1,.JLPCT(R)		;SUBTRACT COUNT REMAINING
	CAILE	S1,<1000*5>		;CHECK IF WITHIN PAGE
	MOVEI	S1,<1000*5>		;MAKE IT 5000
	HRL	S2,S1			;PLACE COUNT IN LEFT HALF
	MOVE	S1,.JLJFN(R)		;GET THE IFN
	$CALL	F%OBUF			;DUMP THE BUFFER
IFN	FTJSYS,<
	PUSH	P,TF			;REMEMBER TRUTH VALUE
	PUSHJ	P,PRVON			;TURN PRIVILEGES BACK ON
	POP	P,TF			;RESTORE TRUTH VALUE
>;END FTJSYS
	SKIPF				;SKIP IF ERROR
	PJRST	L$SETO			;SETUP PAGE AND RETURN
OUTP.E:	$WTO	(<Batch Log File Error>,<^I/JIBTXT/^I/LOGERR/>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)
	TLO	R,RL.NLG		;NO LOG FILE AVAILABLE
	TLZ	R,RL.OPR!RL.DIA		;CLEAR SOME POSSIBLE FLAGS
	PUSHJ	P,L$IOER		;LOG FILE I/O ERROR
	$RETF				;RETURN FALSE
	SUBTTL	L$OUT1 - OUTPUT CHARACTER IN S1 TO LOG
	SUBTTL	L$OUTC - OUTPUT CHARACTER INTO BUFFER

	;THIS ROUTINE WILL PLACE A CHARACTER IN THE BUFFER FOR OUTPUT
	;AND ADJUST THE COUNTS
	;
	;CALL	:	CH/	CHARACTER TO OUTPUT
	;
L$OUT1:: MOVE	CH,S1			;PLACE CHARACTER IN CH

L$OUTC:: SOSGE	.JLPCT(R)		;DECREMENT COUNT SKIP IF ROOM
	  JRST	OUTC.1			;NO ROOM..DUMP BUFFER AND CONTINUE
	IDPB	CH,.JLPTR(R)		;DEPOSIT THE BYTE
	$RETT				;RETURN
OUTC.1:	PUSHJ	P,L$OUTP		;OUTPUT THE PAGE
	PJRST	L$OUTC			;PUT OUT THE CHARACTER
	SUBTTL	L$OPEN - LOG FILE OPEN ROUTINE

	;THIS ROUTINE WILL OPEN UP THE LOG FILE FOR THE STREAM
	;AND IF THERE IS AN ERROR ATTEMPT TO OPEN A TEMPORARY LOG FILE
	;TO BE PRINTED INDICATING THE ERROR TO THE USER



L$OPEN:: MOVEI	S1,.JQLFD(R)		;LOG FILE FD
	MOVEM	S1,FOB.FD+.JLFOB(R)	;SAVE IN FILE OPEN BLOCK
	MOVEI	S1,7			;7 BIT BYTES
	MOVEM	S1,FOB.CW+.JLFOB(R)	;SAVE CONTROL WORD
	MOVE	S1,.JQLFP(R)		;GET FP PARAMETERS
	TXNN	S1,FP.SPL		;SPOOL BIT ON
	JRST	OPEN.1			;NO..DO IN BEHALF
	MOVEI	S1,FOB.MZ		;SHORT BLOCK SIZE
	JRST	OPEN.2			;CONTINUE LOG FILE OPEN
OPEN.1:
IFN	FTUUOS,<
	MOVE	S1,.JQPPN(R)		;GET USERS PPN IN BEHALF
	MOVEI	S2,0			;0 FOR CONSISTENCY
>;END FTUUOS
IFN	FTJSYS,<
	HRROI	S1,.JQNAM(R)		;USERS NAME
	HRROI	S2,.JQCON(R)		;CONNECTED DIRECTORY
>;END FTJSYS
	MOVEM	S1,FOB.US+.JLFOB(R)	;SAVE USER FIELD
	MOVEM	S2,FOB.CD+.JLFOB(R)	;SAVE CONNECTED DIRECTORY(-20)
	MOVEI	S1,FOB.SZ		;GET FILE OPEN BLOCK SIZE
	MOVX	T1,EQ.PRV		;GET PRIVILEGE FLAG
	TDNE	T1,.JQJBB+JIB.SQ(R)	;WAS IT SET?
	MOVEI	S1,FOB.MZ		;USE MINIMUM SIZE
OPEN.2:	MOVEI	S2,.JLFOB(R)		;ADDRESS OF BLOCK
	SKIPE	T1,.JCHRQ(R)		;SEEN BEFORE?
	JRST	OPEN.3			;YES..OPEN WITH APPEND
	GETLIM	T1,.JQLIM(R),BLOG	;GET BATCH LOG FILE DATA
	CAIN	T1,%BSCDE		;WAS IT SUPERCEDE
	JRST	OPEN.5			;DO SUPERCEDE OPEN
OPEN.3:	$CALL	F%AOPN			;OPEN THE FILE
OPEN.4:	JUMPF	L$OPNE			;LOG FILE ERROR
	MOVEM	S1,.JLJFN(R)		;SAVE IFN FOR LOG FILE
	TRO	F,FR.LFO		;LOG FILE NOW OPEN
IFN	FTJSYS,<
	MOVX	S2,FI.CHN		;GET THE JFN
	PUSHJ	P,F%INFO		;GET THE VALUE
	HRROI	S2,.JQACT(R)		;GET THE ACCOUNT STRING
	SACTF				;SET THE ACCOUNT FOR USER
	   JFCL				;IGNORE ANY ERRORS FOR NOW ***
>;END FTJSYS
	POPJ	P,			;RETURN
OPEN.5:	$CALL	F%OOPN			;DO SUPERCEDE OPEN
	JRST	OPEN.4			;CHECK THE RETURNS

	SUBTTL	L$OPNE - LOG FILE OPEN ERROR ROUTINE

	;THIS ROUTINE WILL PROCESS LOG FILE OPEN ERRORS

L$OPNE:: TROE	F,FR.LFE		;LOG FILE ERROR OCCUR YET
	JRST	OPNE.1			;YES,,EXIT NOW
	$WTO	(<Batch Log File Open Error>,<^I/JIBTXT/^I/LOGERR/
A Temporary Log File will be Created, Printed, and Deleted 
for This User. The Job will be Canceled.>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)
	MOVX	S1,E.LFOE		;LOG FILE OPEN ERROR
	MOVEM	S1,.JERRO(R)		;SAVE ERROR CODE
	TLO	F,FL.ERR		;ERROR BIT SET
	PUSHJ	P,L$CMNT		;LOG A COMMENT LINE
	$TEXT	(L$OUT1,<?  -- Batch Log File Open Error --
		^I/LOGERR/>)
	PUSHJ	P,L$NAME		;FIND LOG NAME...NEW NAME
	JUMPF	OPNE.1			;ERROR IN SPOOL OR 3,3..EXIT
	MOVX	S1,<FP.DEL!FP.SPL>	;GET DELETE BIT AND SPOOL BIT
	IORM	S1,.JQLFP(R)		;SAVE IN FILE FP
	PUSHJ	P,L$OPEN		;TRY TO OPEN FILE
	PUSHJ	P,L$OUTP		;DUMP THE CURRENT DATA
	$TEXT	(L$OUT1,<		A Temporary Log File ^F/.JQLFD(R)/
		Will be Created Printed and Deleted.>)
	PUSHJ	P,L$BLK1		;END AND ADD BLANK LINE
	TLZ	R,RL.OPR!RL.DIA		;CLEAR SOME POSSIBLE FLAGS
	PUSHJ	P,ATOKJB		;LOG OUT THE JOB****
	MOVEI	S1,%EQOLG		;OUTPUT LOG FILE
	STOLIM	S1,.JQLIM(R),OUTP	;RESET THE VALUE
	PJRST	CLOS.1			;AND DISMISS IT
OPNE.1:	$WTO	(<Batch Log File Error>,<^I/JIBTXT/^I/FNDLMS/>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)
OPNE.2:	TLZ	R,RL.OPR!RL.DIA		;CLEAR SOME POSSIBLE FLAGS
	PUSHJ	P,L$IOER		;LOG FILE I/O ERROR
	PUSHJ	P,ATOKJB		;LOG OUT THE JOB****
	PJRST	CLOS.1			;KILL THE JOB



FNDLMS:	ITEXT	(<Log Error Recovery Failed
^I/LOGERR/
--	 JOB CANCELED	-->)
LOGERR:: ITEXT	(<^E/[-1]/ FOR ^F/.JQLFD(R)/>)

IFN	FTJSYS,<
BATNAM:	ASCIZ /SPOOL:BATERR/		;[41]
>;END FTJSYS

	SUBTTL	L$IOER - LOG FILE I/O ERROR ROUTINE

	;THIS ROUTINE WILL SETUP ERROR CODE FOR USER AND OPERATOR

L$IOER:: MOVX	S1,E.LFIO		;SET LOG FILE I/O ERROR
	MOVEM	S1,.JERRO(R)		;SAVE THE CODE FOR END MESSAGE
	TLO	F,FL.ERR		;MARK ERROR CODE SET
	PUSHJ	P,L$CMNT		;LOG THE COMMENT LINE
	$TEXT	(L$OUT1,<? -- Batch Log File I/O Error --
		^I/LOGERR/>)
	PUSHJ	P,L$BLK1		;LOG A BLANK LINE
	POPJ	P,			;RETURN
	SUBTTL	L$NAME - GENERATE NEW LOG FILE NAME

	;THIS ROUTINE WILL GENERATE A LOG FILE NAME IN THE
	;SPOOL AREA FOR THE SYSTEM

IFN	FTUUOS,<
L$NAME:	MOVX	S1,FSSSTR		;GET STRUCTURE NAME OF SPOOL AREA
	MOVEM	S1,.JQLFD+.FDSTR(R)	;SAVE IN STRUCTURE WORD
	MOVX	S1,%LDQUE		;GET PPN OF SPOOL AREA
	GETTAB	S1,			;OBTAIN VALUE
	  JRST	.RETF			;BAD RETURN EXIT
	MOVEM	S1,.JQLFD+.FDPPN(R)	;SAVE PPN OF AREA
	MOVE	S1,[POINT 6,.JQLFD+.FDNAM(R)];NAME POINTER
	MOVEM	S1,.JQBYT(R)		;SAVE BYTE POINTER
	$CALL	I%NOW			;GET CURRENT TIME
	$TEXT	(FILNAM,<B^D4R0/S1,FILEMK/^D1R0/.JQSTR(R)/LOG^A>)
	MOVX	S1,FDMSIZ		;GET MINIMUM SIZE FD(NO PATH)
	STORE	S1,.JQLFD+.FDLEN(R),FD.LEN ;SAVE NEW LENGTH
	SETZM	.JQLFD+.FDPAT(R)	;CLEAR FIRST WORD OF SFD TO BE SAFE
	$RETT				;GIVE GOOD RETURN
>;END FTUUOS
IFN	FTJSYS,<
L$NAME:	HRLI	S2,(POINT 7,0)		;MAKE A BYTE POINTER
	HRRI	S2,.JQLFD+1(R)		;GET THE START OF FD
	MOVEM	S2,.JQBYT(R)		;SAVE BYTE POINTER
	$CALL	I%NOW			;GET THE TIME
	$TEXT	(FILNAM,<^T/BATNAM/-^D/JOBTOT/-^D6R0/S1,FILEMK/.LOG^0>)
	HRRZ	S1,.JQBYT(R)		;GET ENDING POINTER
	SUBI	S1,.JQLFD-1(R)		;GET THE LENGTH
	STORE	S1,.JQLFD(R),FD.LEN	;SAVE THE NEW COUNT
	$RETT				;GIVE GOOD RETURN
>;END FTJSYS


FILNAM:	
IFN	FTUUOS,<
	SUBI	S1,40		;CONVERT TO 6 BIT
	ANDI	S1,77		;ONLY WANT TO DIGITS
>;END FTUUOS
	IDPB	S1,.JQBYT(R)	;STORE THE BYTE
	$RETT			;RETURN

	SUBTTL	L$PLOG - PUT A CHARACTER IN LOG WITH FORMATTING

	;THIS ROUTINE WILL ANALYZE THE CHARACTER AND CONVERT CONTROL
	;CHARACTERS AND INSERT APPROPRIATE TABS


L$PLOG:: CAIL	CH,40		;IS THIS A CONTROL CHARACTER
	  JRST	PLOG.1		;NO, OUTPUT AS IS
	TLNE	F,FL.XCC	;IS THIS A GENERATED CTRL CHARACTER?
	  JRST	PLOG.0		;YES, OUTPUT AS ^CHAR
	CAILE	CH,CHR.CR	;HT, LF, VT, FF, AND CR ARE OK
	  JRST	PLOG.0		;ABOVE CR SHOWS AS ^CHAR
	CAIL	CH,CHR.HT	;BELOW HT SHOWS AS ^CHAR
	  JRST	PLOG.1		;SEND HT THRU CR IN IMAGE MODE
PLOG.0:	HRLM	CH,(P)		;SAVE THE ORIGINAL
	MOVEI	CH,"^"		;GET AN UPARROW
	PUSHJ	P,PLOG.1	;OUTPUT IT
	HLRZ	CH,(P)		;GET THE ORIGINAL
	MOVEI	CH,100(CH)	;MAKE THE APPROPRIATE CHARACTER
	PUSHJ	P,PLOG.1	;AND OUTPUT IT
	HLRZ	CH,(P)		;GET THE ORIGINAL AGAIN FOR THE CALLER
	POPJ	P,		;AND RETURN
PLOG.1:	TLZN	F,FL.CRS	;WAS LAST CHARACTER A CARRIAGE RETURN
	  JRST	PLOG.2		;NO, JUST OUTPUT IT
	CAIG	CH,CHR.FF	;CHECK FOR CR NOT FOLLOWED BY VERTICAL MOTION
	CAIGE	CH,CHR.LF	;SAME CHECK AS BELOW FOR TIME STAMP
	  SKIPA			;NOT VERTICAL MOTION, OUTPUT 2 TABS
	JRST	PLOG.2		;OUTPUT THE MOTION CHARACTER
	HRLM	CH,(P)		;SAVE THE CHARACTER ON THE STACK
	PUSHJ	P,L$2TAB	;OUTPUT 2 TABS
	HLRZ	CH,(P)		;RESTORE THE CHARACTER AND OUTPUT IT
PLOG.2:	SKIPE	.JRTIM(R)	;NEED A TIME STAMP
	  PUSHJ	P,L$LSTP	;YES, DO IT
PLOG.3:	CAIN	CH,CHR.CR	;IS THIS A CARRAIGE RETURN
	  TLO	F,FL.CRS	;YES, MARK IT FOR OVERPRINTING CHECK
	PUSHJ	P,L$OUTC	;OUTPUT THE CHARACTER
	CAIG	CH,CHR.FF	;CHECK IF IT WAS VERTICAL PAPER MOTION
	CAIGE	CH,CHR.LF	;THOSE CAUSE A TIME STAMP
	  $RETT			;NO MOTION..RETURN
	SETOM	.JRTIM(R)	;YES,NEXT LINE NEEDS A TIME STAMP
	$RETT			;RETURN TRUE
	SUBTTL	L$TIME - LOG THE TIME ROUTINE

	;THIS ROUTINE WILL PUT TIME STAMP IN THE LOG

L$TIME:: SETZM	.JRTIM(R)		;CLEAR THE TIME-STAMP NEEDED FLAG
	MOVSI	T1,(POINT 7,0)		;MAKE A BYTE POINTER
	HRRI	T1,CURTIM		;GET THE CURRENT TIME
TIME.1:	ILDB	CH,T1			;GET A BYTE
	JUMPE	CH,.POPJ		;NULL..RETURN
	PUSHJ	P,L$OUTC		;OUTPUT THE CHARACTER TO LOG
	JRST	TIME.1			;FINISH THE TIME STAMP
	SUBTTL	L$IDEN - LOG THE LINE IDENTIFIER
	SUBTTL	L$TXTL - LOG TEXT FROM LUUO CALL
	SUBTTL	L$LSTG - LOG THE STRING IN LOG FILE

	;THESE ROUTINES WILL PUT A STRING IN THE LOG FILE

L$IDEN:: SKIPN	.JRTIM(R)		;NEED TO END THE PREVIOUS LINE?
	    PUSHJ P,L$CRLF		;LOG A CRLF TO LOG
	PUSHJ	P,L$TIME		;LOG THE TIME
L$TXTL:: HRR	T1,.JBUUO##		;SETUP FOR UUO
L$LSTG:	HRLI	T1,(POINT 7,0)		;SETUP THE POINTER
LSTG.1:	ILDB	CH,T1			;GET A BYTE
	JUMPE	CH,.POPJ		;ZERO..RETURN
	PUSHJ	P,L$OUTC		;OUTPUT THE BYTE
	JRST	LSTG.1			;GET NEXT BYTE

	SUBTTL	L$BLNK - LOG A BLANK LINE
	SUBTTL	L$BLK1 - LOG A BLANK LINE WITHOUT CRLF
	SUBTTL	L$CRLF - LOG A CARRIAGE RETURN AND LINE-FEED
	SUBTTL	L$CRL2 - LOG A CRLF AND ADD ANOTHER WITHOUT STAMP



L$BLNK:: SKIPN	.JRTIM(R)	;NEED TO END THE PREVIOUS LINE?
L$CRL2::   PUSHJ P,L$CRLF	;OUTPUT A CR-LF
L$BLK1:: SETZM	.JRTIM(R)	;CLEAR FLAG TO ADD ANOTHER ONE
L$CRLF:: MOVEI	CH,CHR.CR	;THE CARRIAGE RETURN
	PUSHJ	P,PLOG.1	;OUTPUT IT
	MOVEI	CH,CHR.LF	;AND THE LINE FEED
	PJRST	PLOG.1		;AND EXIT THROUGH PUTLOG

	SUBTTL	L$SIXU - LOG SIXBIT FROM LUUO
	SUBTTL	L$LSIX - LOG SIXBIT ROUTINE

	;THIS ROUTINE WILL OUTPUT SIXBIT TO THE LOG FILE

L$SIXU:: MOVE	T1,@.JBUUO##	;SET UP FROM UUO ENTRY
L$LSIX:: MOVE	T2,[POINT 6,T1]	;GET BYTE POINTER
LSIX.1:	ILDB	CH,T2		;GET THE BYTE
	JUMPE	CH,.POPJ	;NULL..RETURN
	MOVEI	CH," "(CH)	;MAKE ASCII
	PUSHJ	P,L$OUTC	;OUTPUT THE CHARACTER
	TLNN	T2,770000	;GOT IT ALL?
	  POPJ	P,		;YES,,RETURN
	JRST	LSIX.1		;GET THE NEXT
	SUBTTL	L$LCMA - LOG A COMMA
	SUBTTL	L$LCOL - LOG A COLON



L$LCMA:: SKIPA	CH,[","]	;A COMMA
L$LCOL:: MOVEI	CH,":"		;A COLON
	JRST	L$OUTC		;OUTPUT THE CHARACTERS

	SUBTTL	L$CMNT - LOG A COMMENT TO THE LOG FILE
	SUBTTL	L$2TAB - LOG 2 TABS TO LOG FILE
	SUBTTL	L$LTAB - LOG A TAB TO LOG FILE
	SUBTTL	L$LPER - LOG A PERIOD TO LOG FILE

	;THIS ROUTINE WILL LOG A COMMENT INTO THE LOG FILE


L$CMNT:: SKIPN	.JRTIM(R)	;NEED TO END THE PREVIOUS LINE
	  PUSHJ	P,L$CRLF	;YES, DO IT
	SETZM	.JRTIM(R)	;NO TIME STAMP NEEDED
L$2TAB:: PUSHJ	P,L$LTAB	;OUTPUT A TAB
L$LTAB:: SKIPA	CH,[CHR.HT]	;AND ANOTHER ONE
L$LPER:: MOVEI	CH,MONCHR	;A PERIOD (OR SOMETHING LIKE THAT)
	JRST	PLOG.1		;OUTPUT THE PERIOD
	SUBTTL	L$CHKP - CHECKPOINT THE LOG FILE ROUTINE

	;THIS ROUTINE WILL DUMP THE LOG FILE AND THEN CHECKPOINT IT
	;ON ERROR WILL ABORT THE USER


L$CHKP:: TRNN	F,FR.LFO		;IS LOG FILE OPEN
	PUSHJ	P,L$OPEN		;GO OPEN LOG FILE
	PUSHJ	P,L$OUTP		;DUMP THE DATA
	JUMPF	.POPJ			;ERROR...RETURN
IFN	FTJSYS,<
	MOVE	S1,.JQJBB+JIB.SQ(R)	;GET SUBMITTERS ACTIVE PRIVS.
	TXNN	S1,EQ.PRV		;SKIP IF HE WAS ENABLED
	PUSHJ	P,PRVOFF		;TURN OFF PRIVILEGES
>;END FTJSYS
	MOVE	S1,.JLJFN(R)		;IFN FOR FILE
	$CALL	F%CHKP			;CHECKPOINT THE FILE
IFN	FTJSYS,<
	PUSH	P,TF			;REMEMBER TRUTH VALUE
	PUSHJ	P,PRVON			;TURN PRIVILEGES BACK ON
	POP	P,TF			;RESTORE TRUTH VALUE
>;END FTJSYS
	JUMPF	CHKP.1			;ABORT TRANSACTION
	MOVEM	S1,.JLUSI(R)		;LOG FILE POINTER
	POPJ	P,			;RETURN
CHKP.1:	$WTO	(<Batch Log Error>,<^I/JIBTXT/^I/LOGERR/
JOB BEING CANCELED>,.JQOBJ(R),<$WTNOD(.JQLOC(R))>)
	TLO	R,RL.NLG		;NO LOG AVAILABLE
	PUSHJ	P,L$IOER		;LOG THE I/O ERROR
	$RETF				;RETURN FALSE

	SUBTTL	L$LSTP - LOG THE TIME STAMP AND TYPE

L$LSTP:: PUSH	P,CH		;SAVE THE CHARACTER
	PUSHJ	P,L$TIME	;PUT TIME STAMP IN LOG FILE
	MOVEI	T1,[ASCIZ/ MONTR	/]
	TLNN	J,JL.UML	;WAS JOB AT MONITOR LEVEL
	  MOVEI	T1,[ASCIZ/ USER	/] ;NO, SAY USER MODE
	PUSHJ	P,L$LSTG	;LOG THE STRING
	POP	P,CH		;RESTORE CH
	POPJ	P,		;RETURN
	SUBTTL	PRVOFF - TURN PRIVILEGES OFF FOR QUOTA ENFORCEMENT

	;THIS ROUTINE WILL DISABLE WHEEL AND/OR OPERATOR PRIVILEGES SO
	;THAT DIRECTORY QUOTA CHECKING WILL BE ENFORCED ON SUBSEQUENT
	;WRITES.  (TOPS-20 ONLY).  TOH, 4-APR-80

IFN	FTJSYS,<
PRVOFF:	PUSH	P,T1			;SAVE BYTE POINTER
	$CALL	I%IOFF			;TURN OFF INTERRUPTS
	MOVEI	S1,.FHSLF		;GET PROCESS HANDLE
	RPCAP				;READ OUR CAPABILITIES
	ERJMP	[$STOP (CRC,Couldn't Read/set Capabilities)] 
	TXZ	T1,SC%WHL!SC%OPR	;TURN OFF WHEEL AND OPERATOR
	EPCAP				;AND ENABLE EVERYTHING BUT
	ERCAL	S..CRC			;HANDLE ERROR
	POP	P,T1			;RESTORE BYTE POINTER
	POPJ	P,			;RETURN TO CALLER
>;END FTJSYS


	SUBTTL	PRVON - TURN PRIVILEGES BACK ON

	;THIS ROUTINE WILL RE-ENABLE WHEEL AND/OR OPERATOR PRIVILEGES
	;(TOPS-20 ONLY).  TOH, 4-APR-80

IFN	FTJSYS,<
PRVON:	PUSH	P,T1			;SAVE BYTE POINTER
	MOVEI	S1,.FHSLF		;GET PROCESS HANDLE
	RPCAP				;READ OUR CAPABILITIES
	ERCAL	S..CRC			;HANDLE ERROR
	TXO	T1,SC%WHL!SC%OPR	;TURN ON WHEEL AND OPERATOR
	EPCAP				;ENABLE THESE CAPABILITIES
	ERCAL	S..CRC			;HANDLE ERROR
	$CALL	I%ION			;TURN INTERRUPTS BACK ON
	POP	P,T1			;RESTORE BYTE POINTER
	POPJ P,				;RETURN TO CALLER
>;END FTJSYS
	END
