	TITLE	OPRCMD - command tables for ORION
	SUBTTL	Preliminaries

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1975, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

	SALL
	SEARCH	GLXMAC
	SEARCH	ORNMAC
	SEARCH	NEBMAC			;[245]SEARCH NEBULA'S SYMBOLS
	SEARCH  MONSYM,MACSYM
	PROLOG(OPRCMD)

;Version numbers

	CMDMAN==:0			;Maintenance edit number
	CMDDEV==:261			;Development edit number
	VERSIN (CMD)			;Generate edit number

	.DIRECTIVE FLBLST


	Subttl	Table of Contents

;		     Table of Contents for OPRCMD
;
;				  Section		      Page
;
;
;    1. Revision history . . . . . . . . . . . . . . . . . . .   4
;    2. Special Macro Definitions  . . . . . . . . . . . . . .   5
;    3. $EXPL Macro Definition . . . . . . . . . . . . . . . .   6
;    4. SNADST Macro Definition  . . . . . . . . . . . . . . .   7
;    5. Remote Printing Macro Definitions  . . . . . . . . . .   8
;    6. Tables and ACTION routine for /CLUSTER-NODE: processin   9
;    7. Command Dispatch . . . . . . . . . . . . . . . . . . .  10
;    8. Argument Subroutines . . . . . . . . . . . . . . . . .  11
;    9. Argument subroutines for printers  . . . . . . . . . .  12
;   10. START command tables . . . . . . . . . . . . . . . . .  17
;   11. CONTINUE command tables  . . . . . . . . . . . . . . .  18
;   12. STOP command tables  . . . . . . . . . . . . . . . . .  19
;   13. ABORT command tables . . . . . . . . . . . . . . . . .  20
;   14. HOLD command tables  . . . . . . . . . . . . . . . . .  21
;   15. DEFINE command tables  . . . . . . . . . . . . . . . .  22
;   16. CANCEL command tables  . . . . . . . . . . . . . . . .  23
;   17. MODIFY command tables  . . . . . . . . . . . . . . . .  24
;   18. SHOW command tables  . . . . . . . . . . . . . . . . .  25
;   19. SHOW STATUS command tables . . . . . . . . . . . . . .  28
;   20. SHWNOD SHOW STATUS/PARAMETERS FOR NODE . . . . . . . .  29
;   21. RESPOND command tables . . . . . . . . . . . . . . . .  30
;   22. REQUEUE command tables . . . . . . . . . . . . . . . .  31
;   23. BACKSPACE command tables . . . . . . . . . . . . . . .  32
;   24. ALIGN command table  . . . . . . . . . . . . . . . . .  33
;   25. SUPPRESS command tables  . . . . . . . . . . . . . . .  34
;   26. ROUTE command tables . . . . . . . . . . . . . . . . .  35
;   27. SEND command tables  . . . . . . . . . . . . . . . . .  36
;   28. SET command tables . . . . . . . . . . . . . . . . . .  37
;   29. SET STRUCTURE command tables . . . . . . . . . . . . .  38
;   30. SET TAPE command tables  . . . . . . . . . . . . . . .  39
;   31. SET DISK command tables  . . . . . . . . . . . . . . .  40
;   32. SET ONLINE command tables  . . . . . . . . . . . . . .  41
;   33. SET USAGE command tables . . . . . . . . . . . . . . .  42
;   34. SET TAPE INITIALIZE command tables . . . . . . . . . .  43
;   35. SET NODE command tables  . . . . . . . . . . . . . . .  44
;   36. SET SCHEDULER command tables (TOPS20)  . . . . . . . .  45
;   37. SET PORT command tables  . . . . . . . . . . . . . . .  46
;   38. ENABLE/DISABLE command tables  . . . . . . . . . . . .  47
;   39. ENACLS ENABLE CLASS SCHEDULER command tables . . . . .  49
;   40. CLOSE command tables . . . . . . . . . . . . . . . . .  50
;   41. ENABLE/DISABLE NEBULA CONNECTIONS  . . . . . . . . . .  51
;   42. REPORT command tables  . . . . . . . . . . . . . . . .  52
;   43. MOUNT command tables . . . . . . . . . . . . . . . . .  53
;   44. NEXT - NEXT COMMAND  . . . . . . . . . . . . . . . . .  54
;   45. IDENTIFY command tables  . . . . . . . . . . . . . . .  55
;   46. SWITCH command tables (TOPS20) . . . . . . . . . . . .  56
;   47. DISMOUNT command tables  . . . . . . . . . . . . . . .  57
	Subttl	Table of Contents (page 2)

;		     Table of Contents for OPRCMD
;
;				  Section		      Page
;
;
;   48. PUSH command tables  . . . . . . . . . . . . . . . . .  58
;   49. HELP command tables  . . . . . . . . . . . . . . . . .  59
;   50. SHOW ALLOCATION command tables . . . . . . . . . . . .  60
;   51. UNDEFINE command tables  . . . . . . . . . . . . . . .  61
SUBTTL	Revision history

COMMENT \

*****  Release 4.2 -- begin maintenance edits  *****

146	4.2.1484	9-Aug-82
	Allow secondary ports to work on MODIFY commands.

147	4.2.1555	24-Oct-83
	Add some range checking stuff to prevent too many objects at
a time from being started.

*****  Release 5.0 -- begin development edits  *****

160	5.1003		4-Jan-83
	Move to new development area.  Add version vector.  Clean up
edit organization.  Update TOC.

161	5.1021		5-Apr-83
	Add SET STR SHARED/EXCLUSIVE.  Add SET PORT CI ONLINE/OFFLINE.

162	5.1026		6-May-83
	Add new ENABLE/DISABLE OUTPUT options for BUGCHK, BUGINF and SYSTEM
messages.

163	5.1027		10-May-83
	Change SET PORT CI ONLINE/OFFLINE to AVAILABLE/UNAVAILABLE.

164	5.1035		18-Jul-83
	Add support for new DISMOUNT (with) REMOVAL/NOREMOVAL.  While here,
clearify a SET ONLINE help message.

165	5.1058		23-Nov-83
	Make the SET TERMINAL command invisible for this release.  Remove
it in next release.

166	5.1069		23-Jan-84
	Add SHOW STATUS STRUCTURE command.

167	5.1075		3-Feb-84
	Add structure name to SHOW STATUS STRUCTURE command if desired.

170	5.1080		5-Feb-84
	Add UNDEFINE STRUCTURE FOO: command.

171	5.1111		1-Mar-84
	Add MOUNT STRUCTURE alias: /STRUCTURE-ID:structure name command

172	5.1124		2-Apr-84
	Add controller number to the SET DISK UNAVAILABLE.

173	5.1162		21-Sep-84
	Add changes to support SNA Workstations

174	5.1169		19-Oct-84
	Correct problems due to new SNA Workstations functionality.

175	5.1179		20-Nov-84
	Add support to allow disabling/enabling of two new display types,
DECNET-EVENT messages and DECNET-LINK messages.

176	5.1184		3-Dec-84
	Include an additional argument in the "X" macro - used in conjunction
with LCPTAB support.

177	5.1186		5-Dec-84
	Add NI AVAILABLE/UNAVAILABLE.

200	5.1203		26-Feb-85
	Add support for SHOW CONFIGURATION DISK-DRIVE.

*****  Release 5.0 -- begin maintenance edits  *****

205	Increment maintenance edit level for GALAXY 5.

206	5.1236		22-Apr-86
	Wrong $KEYxxx macro used in ENA105 for the ENABLE/DISABLE
OUTPUT-DISPLAY OPR command.

*****  Release 6.0 -- begin development edits  *****

230	6.1009		6-Oct-87
	Add support for remote printing. The syntax of the OPR commands:
ABORT, CONTINUE, REQUEUE, ROUTE, SET, SHOW STATUS, SHOW PARAMETER, SHUTDOWN,
START and STOP have changed.

231 	6.1010		8-Oct-87
	Change the Cluster printer help message (n:m)(/NODE:) to (n:m)(NODE)

232	6.1011		8-Oct-87
	Have CHKLAC scan the command message buffer rather than the atom buffer
when checking for validity and raising any lower case letters.

233	6.1015		13-Oct-87
	Do the following cleanup: ensure that the node specified in a remote
printing command is not the local node, make "$" and "_" illegal as the first
character of a DQS VMS queue name, or the LAT PORT, SERVICE or SERVER name.
Also, change the LAT SERVER name block from .CMFLD to .CMNOD in the message
passed to ORION. Lastly, remove Cluster printers from the SET PRINTER 
command.

234	6.1018		15-Oct-87
	Remove keywords FORMS-TYPE and DESTINATION in the SET PRINTER command
for DQS and LAT printers.

235	6.1019		18-Oct-87
	Allow routing between printers of different types

236	6.1034		23-Oct-87
	Add new keyword, SEMI-OPR, to the ENABLE/DISABLE command.  Add new
FDB for SEMI-OPR.  Add new command tables for SEMI-OPR.

237	6.1041		29-Oct-87
	Change SHOW STATUS PRINTER and SHOW PARAMETERS PRINTER to support
remote printing. Remove the /NODE: switch from commands dealing with
local printers.

240	6.1058		5-Nov-87
	Help for SET STRUCTURE command shows STRUCTURE STRUCTURE after ?
mark is typed.  There were two entries for the set structure command in the 
command table.  Delete one.

241	6.1078		15-Nov-87
	Add support for the /CLUSTER-NODE: switch.

242	6.1072		16-Nov-87
	Add the /TERMINAL-CHARACTERISTIC switch to the START PRINTER LAT and 
START PRINT 0/DEVICE:  command.

243	6.1081		17-Nov-87
	Add support for setting structures DUMPABLE/NONDUMABLE.

244	6.1078		18-Nov-87
	Make the SEND ALL command cluster-wide.

245	6.1098		22-Nov-87
	Add the /CLUSTER-NODE switch to the MOUNT STRUCTURE command.

246	6.1078		25-Nov-87
	Change the $CLUNOD macro to accept the next FDB after the /CLUSTER-NODE
switch.

247	6.1114		3-Dec-87
	Add support for the SHOW CLUSTER-GALAXY-LINK-STATUS, ENA/DIS
REPORT-CONNECTION-FAILURES and DECNET-CONNECTION-ATTEMPTS commands.

250	6.1117		3-Dec-87
	Remove the definitions of $URANGE, $SRANGE, $ORANGE and $NODE and
place them in ORNMAC so that OPRSCM will also have access to their definitions.

251	6.1173		27-Jan-88
	Add the FORMS-TYPE keyword for the SET command for LAT printers.

252	6.1177		11-Feb-88
	Add commands LOGFILES-TO-SPECIFIC-PRINTERS and PRINT-LOGFILES.

253	6.1182		15-Feb-88
	Add ENABLE/DISABLE UNPRIVILEGED-USER-ENTIRE-REMOTE-OUTPUT-DISPLAY
	commands.

254	6.1183		16-Feb-88
	Conitionalize tables according to CLUSTER and SINGLE in support of
ENABLE/DISABLE Cluster GALAXY.

255	6.1206		2-Mar-88
	Allow "." and "-" in LAT PORT, SERVICE and server names. Also, allow
".", "-", "_" and "$" as the first character of these names.

256	6.1225		8-Mar-88
	Update copyright notice.

257	6.1235		14-Apr-88
	Move symbol definitions MAXNOD, CLNNAM, CLNTAB and SBNNAM to OPRPAR
so that non-GALAXY programs that link in only OPRPAR link successfully.

260	6.1237		21-Apr-88
	Move macro definitions $UNIT, $STNUM, $STREAM, $EXPL, SNADST, $CLUSPL,
$DQSSPL, $LATSPL and $CLUNOD to ORNMAC so that OPRSCM may also use them.
Add printer type LAT for the BACKWARD, FORWARD, ALIGN and SUPPRESS commands.

261	6.1260		31-May-88
	Remove invalid ")" in ALI03A:
\   ;End of Revision History

	SUBTTL	Macro Support

	INTERN	CHKVAL,DSTBRK,CHKNOD,DQSCHK,LPTMSK,DQSSHO	 ;[260]
	INTERN	LATSRV,LATSAP,LATSHO,SHOMSK,CLUMSK,CHGBLK	 ;[260]
	INTERN	FIXIT,CHKPOS					 ;[260]

DSTBRK:	BRMSK. (EOLB0.,EOLB1.,EOLB2.,EOLB3.,,</>);[260]Break set

BRINI.						;[260]
BRKCH. (0,40)					;[260]
BRKCH. (57)					;[260]
BRKCH. (77)					;[260]
BRKCH. (177)					;[260]

LPTMSK: BRMSK. (W0.,W1.,W2.,W3.)		;[260]

BRINI.						;[260]
BRKCH. (0,14)					;[260]
BRKCH. (16,40)					;[260]
BRKCH. (57)					;[260]
BRKCH. (77)					;[260]
BRKCH. (177)					;[260]

SHOMSK: BRMSK. (W0.,W1.,W2.,W3.)		;[260]

BRINI.						;[260]
BRKCH. (0,40)					;[260]
BRKCH. (77)					;[260]
BRKCH. (177)					;[260]

CLUMSK: BRMSK. (W0.,W1.,W2.,W3.)		;[260]

SUBTTL	Command Dispatch

	INTERN	OPRCMD	;MAKE VECTOR ADDRESS AVAILABLE
	INTERN	STOBTH,STOHGH,STOOHG	;[247]

OPRCMD:	EXP	2	;SIZE
	EXP	INITCM	;POINTER TO THE INI FUNCTION
	EXP	CMDFDB	;TOP LEVEL DISPATCH

INITCM:: $INIT(CMDFDB)
CMDFDB:: $KEYDSP(CMDTAB,<$ACTION(CMDACT##),$ERROR(BADCOM)>)

CMDTAB:	$STAB
	ORNDSP(ABOFDB,ABORT,CNC)
	ORNDSP(ALIFDB,ALIGN,ALI)
	ORNDSP(BKSFDB,BACKSPACE,BKS)
	ORNDSP(CANFDB,CANCEL,DEL)
	ORNDSP(CLOFDB,CLOSE,CLO)
	ORNDSP(UNVFDB,CONTINUE,CNT)
IFN	FTDN60,<
	ORNDSP(DEFFDB,DEFINE,DEF)
>;END FTDN60
	ORNDSP(ENAFDB,DISABLE,DIS)
	ORNDSP(DSMFDB,DISMOUNT,DSM) 
	ORNDSP(ENAFDB,ENABLE,ENA)
IFN	NUMAPL,<			;CHECK IS ANY APPLICATION TABLES
	ORNDSP(ENTFDB##,ENTER,ENT)
>;END NUMAPL
	ORNDSP(EXTFDB##,EXIT,EXT)
	ORNDSP(BKSFDB,FORWARDSPACE,FWS)
	ORNDSP(HLPFDB,HELP,HLP)
	ORNDSP(HLDFDB,HOLD,HLD)
	ORNDSP(IDNFDB,IDENTIFY,IDN)
	ORNDSP(MODFDB,MODIFY,MOD)
	ORNDSP(MTNFDB##,MOUNT,MTN)		;[260]
	ORNDSP(NXTFDB##,NEXT,NXT)		;[260]
	ORNDSP(PUSFDB##,PUSH,PUS)		;[260]
	ORNDSP(HLDFDB,RELEASE,REL)	
	ORNDSP(RPTFDB##,REPORT,RPT)		;[260]
	ORNDSP(REQFDB##,REQUEUE,REQ)		;[260]
	ORNDSP(RSPFDB##,RESPOND,RSP)		;[260]
	ORNDSP(RTEFDB##,ROUTE,RTE)		;[260]
	ORNDSP(SNDFDB##,SEND,SND)		;[260]
	ORNDSP(SETFDB##,SET,SET)		;[260]
	ORNDSP(SHWFDB##,SHOW,SHW)		;[260]
	ORNDSP(SHDFDB,SHUTDOWN,SHD)	
	ORNDSP(STAFDB##,START,STA)		;[260]
	ORNDSP(STPFDB##,STOP,PAU)		;[260]
	ORNDSP(SUPFDB##,SUPPRESS,SUP)		;[260]
	ORNDSP(SWIFDB##,SWITCH,SWI)		;[260]
	ORNDSP(TAKOPR##,TAKE,TAK)		
	ORNDSP(UNDFDB##,UNDEFINE,UDF)		;[260]
	ORNDSP(WAIOPR##,WAIT,WAI)		
	$ETAB

BADCOM:	MOVEI	S2,[ASCIZ/Invalid OPR command specified/]
	$RETF				;BAD COMMAND
SUBTTL	Argument Subroutines

;ACTION ROUTINE CALLED ON $UNIT MACRO TO BARF ON NEGATIVE UNIT
;NUMBER ARGUMENTS.
CHKVAL:	SKIPL	CR.RES(S2)	;CHECK THAT NUMBER
	$RETT			;IT'S GOOD
	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ/Negative number improper/]
	$RETF

CHKPOS:	SKIPLE	CR.RES(S2)	;CHECK THE NUMBER
	$RETT			;O.K..RETURN
	PUSHJ	P,FIXIT		;FIXUP COMMAND
	MOVEI	S2,[ASCIZ/Number must be positive/]
	$RETF			;RETURN FALSE

; ACTION ROUTINE TO CHECK PRIORITY RANGES
CHKPRI:	SKIPLE	T1,CR.RES(S2)	;CHECK THAT NUMBER
	CAILE	T1,^D63
	SKIPA
	$RETT			;IT'S GOOD
	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ/Priority not in range/]
	$RETF

;TEMPORARY STORAGE FOR RANGE ARGUMENT
	$DATA	LSTARG,1		;LAST PARSED ARGUMENT ADDRESS
	$GDATA	CMDCOD,1		;COMMAND FUNCTION CODE

STOBTH:	SKIPGE	T1,CR.RES(S2)
	PJRST	CHKVAL		;ABORT COMMAND
	MOVEM	T1,LSTARG
	$RETT

;  Routine STOOHG to check width of range for object commands as well as
;  the stuff checked by STOHGH.

STOOHG:	SKIPGE	T1,CR.RES(S2)		;Is the range at least positive?
	PJRST	CHKVAL			;No, abort command
	SUB	T1,LSTARG		;Subtract the beginning of range
	JUMPL	T1,STOH.1		;Bad range
	CAIGE	T1,MXOBJR		;Too big?
	$RETT				;Just fine
	JRST STOH.1			;Bad range

;  Action routine STOHGH to check range validity based on bottom and top
;  of range.

STOHGH:	SKIPGE	T1,CR.RES(S2)
	PJRST	CHKVAL		;ABORT COMMAND
	CAMGE	T1,LSTARG
	SKIPA			;SKIP AND LOAD ERROR
	$RETT

STOH.1:	PUSHJ	P,FIXIT
	MOVEI	S2,[ASCIZ /Improper range specification/]
	$RETF

FIXIT:	HRRZ	T4,CR.FLG(S2)	;GET ADR OF CMDBLK
	MOVE	T1,.CMPTR(T4)	;GET COMMAND POINTER
	MOVE	T2,.CMABP(T4)	;GET BP TO ATOM BUFFER
FIXI.1:	ILDB	T3,T2
	JUMPE	T3,FIXI.2	;DONE.. ALL FIXED UP
	PUSHJ	P,DBP		;DECREMENT THE BP
	AOS	.CMCNT(T4)
	JRST	FIXI.1		;TRY NEXT CHARACTER
FIXI.2:	MOVEM	T1,.CMPTR(T4)	;STORE ADJUSTED BP
	POPJ	P,0

;LOCAL ROUTINE TO DECREMENT BYTE POINTER IN T1
DBP:	SOS	T1
	IBP	T1
	IBP	T1
	IBP	T1
	IBP	T1
	$RETT

	SUBTTL	Argument subroutines for printers

;**;[230]ROUTINES DQSCHK, LATSAP,LATSRV HAVE BEEN ADDED AS PART OF THIS EDIT

	EXTERNAL STRADR,G$NODE,ATMBFR,CMDRET,ARGFRE ;[237]

MAXDQS==^D31				;MAX LENGTH OF A DQS QUEUE NAME
MAXSAP==^D16				;MAX LENGTH OF SERVICE/PORT NAME
MAXSVR==^D6				;MAX LENGTH OF LAT SERVER NAME

DQSCHK:	$CALL	CHKLAC			;CHECK LENGTH AND VALID CHARACTERS
	JUMPF	.POPJ			;INVALID CHARACTER DETECTED
	CAIG	S1,MAXDQS		;NAME SPECIFIED LONGER THAN MAX?
	$RET				;NO, INDICATE SUCCESS
	MOVEI	S2,[ASCIZ/VMS printer queue name has an invalid length/]
	$RETF				;INDICATE ERROR

LATSAP:	$CALL	CHKSTR			;[255]CHECK LENGTH AND VALID CHARACTERS
	JUMPF	.POPJ			;INVALID CHARACTER DETECTED
	CAIG	S1,MAXSAP		;NAME SPECIFIED LONGER THAN MAX?
	$RET				;NO, INDICATE SUCCESS
	MOVEI	S2,[ASCIZ/Service or port name has an invalid length/]
	$RETF				;INDICATE ERROR
					

LATSRV:	$CALL	CHKSTR			;[255]CHECK LENGTH AND VALID CHARACTERS
	JUMPF	.POPJ			;INVALID CHARACTER DETECTED
	CAILE	S1,MAXSVR		;[233]VALID LENGTH?
	JRST	LATSR1			;[233]NO, INDICATE AN ERROR
	$CALL	CHKNOD			;[233]CHECK IF NODE IS LOCAL
	JUMPF	.POPJ			;[233]QUIT, IF SPECIFIED NODE IS LOCAL
	MOVX	S2,.CMNOD		;[233]PICK UP THE NODE BLOCK TYPE
	MOVE	S1,STRADR		;[233]PICK UP SERVER BLOCK ADDRESS
	STORE	S2,PFD.HD(S1),PF.TYP	;[233]CHANGE TO A NODE BLOCK
	$RET				;[233]PRESERVE THE TRUE/FALSE FLAG
LATSR1:	MOVEI	S2,[ASCIZ/Server name has an invalid length/]
	$RETF				;INDICATE ERROR

	

;**;[237]ROUTINE DQSSHO HAS BEEN ADDED AS PART OF THIS EDIT

;DQSSHO is used during the SHOW PRINTER processing for the cases of determining
;if the command is for all the printers of a particular class or for a
;specific printer of that class.

DQSSHO:	TDZA	S1,S1			;INDICATE FROM DQS PROCESSING
LATSHO: MOVEI	S1,1			;INDICATE FROM LAT PROCESSING
	$SAVE	<P1>			;SAVE THIS AC
	MOVE	P1,STRADR		;PICK UP THE LATEST MESSAGE BLOCK
	AOS	P1			;POINT PASS THE HEADER
	HRLI	P1,(POINT 7,,6)		;MAKE IT INTO A POINTER
	LDB	S2,P1			;PICK UP THE FIRST CHARACTER
	CAIE	S2,.CHCRT		;IS THIS A CARRIAGE RETURN?
	JRST	@DQSTAB(S1)		;A NAME HAS BEEN SPECIFIED

	ILDB	S2,P1			;PICK UP THE NEXT CHARACTER
	SKIPE	S2			;IS THERE ANY MORE?
	JRST	DQSS.3			;YES, INVALID CHARACTER SPECIFIED
	MOVEI	S2,DUMPDB+1		;PICK UP ADDRESS OF DUMMY FDB
	STORE	S2,CMDRET+CR.PDB,RHMASK	;STORE AS THE CURRENT PDB
	EXCH	T1,ARGFRE		;BACK OFF .CMFLD BLOCK FROM MESSAGE
	$RETT				;INDICATE SUCCESS

DQSS.1:	SETZ	S1,			;INITIALIZE CHARACTER COUNT
	$CALL	CHKLA0			;CHECK FOR VALID CHARACTERS
	JUMPF	.POPJ			;INVALID CHARACTER DETECTED
	CAIG	S1,MAXDQS		;IS THE LENGTH VALID?
	$RET				;PRESERVE THE TRUE/FALSE FLAG
	MOVEI	S2,[ASCIZ/VMS printer queue name has an invalid length/]
	$RETF				;INDICATE AN ERROR HAS OCCURRED

DQSS.2:	SETZ	S1,			;INITIALIZE CHARACTER COUNT
	$CALL	CHKST1			;[255]CHECK FOR VALID CHARACTERS
	JUMPF	.POPJ			;INVALID CHARACTER DETECTED
	CAIG	S1,MAXSAP		;NAME SPECIFIED LONGER THAN MAX?
	$RET				;NO, INDICATE SUCCESS
	MOVEI	S2,[ASCIZ/Service or port name has an invalid length/]
	$RETF				;INDICATE ERROR

DQSS.3:	MOVEI	S2,[ASCIZ/Invalid character specified in name/]
	$RETF				;INDICATE ERROR

DQSTAB:	DQSS.1				;CHECK DQS NAME CHARACTER VALIDITY
	DQSS.2				;CHECK LAT NAME CHARACTER VALIDITY

DUMPDB:	$FIELD	(CONFRM,<used to force $CRLF>) ;FORCE AN END TO THIS COMMAND



;**;[230]ROUTINE CHKLAC HAS BEEN ADDED AS PART OF THIS EDIT

;CHKLAC determines the length of an unquoted string. It also checks to ensure
;that the string contains only alphanumber characters, "$" and "_". This
;routine is used to validate DQS VMS printer queue names.
;
;Call is: No Arguments
;Returns true: All the characters specified in the name are valid
;              S1/Length of the name
;Returns false: An invalid character was detected in the name
;               S2/Address of the ASCIZ error string

CHKLAC:	$SAVE	<P1>			;SAVE THIS AC
	SETZ	S1,			;NUMBER OF CHARACTERS
	MOVE	P1,STRADR		;[232]PICK UP THE STRING ADDRESS
	AOS	P1			;[232]POINT PASS THE HEADER
	HRLI	P1,(POINT 7,,6)		;[232]MAKE IT INTO A POINTER
CHKLA0:	LDB	S2,P1			;[237]PICK UP THE FIRST CHARACTER
	CAIE	S2,"$"			;[233]IS IT A "$"?
	CAIN	S2,"_"			;[233]NO, IS IT AN "_"?
	JRST	CHKLA7			;[233]YES, AN INVALID FIRST CHARACTER
	SKIPA				;[233]GO CHECK THE VALIDITY
CHKLA1:	LDB	S2,P1			;PICK UP THE NEXT CHARACTER
	SKIPN	S2			;IS THIS THE LAST CHARACTER?
	JRST	CHKLA6			;YES, GO RETURN SUCCESS
	AOS	S1			;NO, COUNT THIS CHARACTER

	CAILE	S2,"9"			;IS THIS A DIGIT?
	JRST	CHKLA2			;NO, CHECK FOR A LETTER
	CAIL	S2,"0"			;IS THIS A DIGIT?
	JRST	CHKLA5			;YES, CHECK THE NEXT CHARACTER

	CAIE	S2,"$"			;IS THIS A "$"?
	JRST	CHKLA7			;NO, SO IT IS INVALID
	JRST	CHKLA5			;GO CHECK THE NEXT CHARACTER

CHKLA2:	CAILE	S2,"Z"			;IS THIS AN UPPER CASE LETTER?
	JRST	CHKLA3			;NO, CHECK FOR LOWER CHASE LETTER
	CAIL	S2,"A"			;IS THIS AN UPPER CASE LETTER?
	JRST	CHKLA5			;YES, CHECK THE NEXT CHARACTER
	JRST	CHKLA7			;THIS CHARACTER IS INVALID

CHKLA3:	CAILE	S2,"z"			;IS THIS A LOWER CASE LETTER?
	JRST	CHKLA7			;NO, IT IS INVALID
	CAIL	S2,"a"			;IS THIS A LOWER CASE LETTER?
	JRST	CHKLA4			;YES, CONVERT TO UPPER CASE

	CAIE	S2,"_"			;IS THIS AN UNDERSCORE?
	JRST	CHKLA7			;NO, IT IS INVALID
	JRST	CHKLA5			;YES, CHECK THE NEXT CHARACTER

CHKLA4:	SUBI	S2,<"a"-"A">		;CONVERT TO UPPER CASE
	DPB	S2,P1			;STORE THE CHARACTER
CHKLA5:	IBP	P1			;POINT TO THE NEXT CHARACTER
	JRST	CHKLA1			;CHECK THE NEXT CHARACTER
CHKLA6:	$RETT				;INDICATE ALL CHARACTERS VALID
CHKLA7:	MOVEI	S2,[ASCIZ/Invalid character specified in name/]
	$RETF				;INDICATE INVALID CHARACTER



;**;[255]ROUTINE CHKSTR HAS BEEN ADDED AS PART OF THIS EDIT

;CHKSTR determines the length of an unquoted string. It also checks to ensure
;that the string contains only alphanumeric characters, "$", "-", "." and "_".
;This routine is used to validate LAT port, service and server names.
;
;Call is:       No Arguments
;Returns true:  All the characters specified in the name are valid
;               S1/Length of the name
;Returns false: An invalid character was detected in the name
;               S2/Address of the ASCIZ error string

CHKSTR:	$SAVE	<P1>			;SAVE THIS AC
	SETZ	S1,			;NUMBER OF CHARACTERS
	MOVE	P1,STRADR		;PICK UP THE STRING ADDRESS
	AOS	P1			;POINT PASS THE HEADER
	HRLI	P1,(POINT 7,,6)		;MAKE IT INTO A POINTER

CHKST1:	LDB	S2,P1			;PICK UP THE NEXT CHARACTER
	SKIPN	S2			;IS THIS THE LAST CHARACTER?
	JRST	CHKST6			;YES, GO RETURN SUCCESS
	AOS	S1			;NO, COUNT THIS CHARACTER

	CAILE	S2,"9"			;IS THIS A DIGIT?
	JRST	CHKST2			;NO, CHECK FOR A LETTER
	CAIL	S2,"0"			;IS THIS A DIGIT?
	JRST	CHKST5			;YES, CHECK THE NEXT CHARACTER

	CAIN	S2,"$"			;IS THIS A "$"?
	JRST	CHKST5			;YES, CHECK THE NEXT CHARACTER
	CAIN	S2,"-"			;IS THIS A "-"?
	JRST	CHKST5			;YES, CHECK THE NEXT CHARACTER
	CAIN	S2,"."			;IS THIS A "."?
	JRST	CHKST5			;YES, CHECK THE NEXT CHARACTER

CHKST2:	CAILE	S2,"Z"			;IS THIS AN UPPER CASE LETTER?
	JRST	CHKST3			;NO, CHECK FOR LOWER CHASE LETTER
	CAIL	S2,"A"			;IS THIS AN UPPER CASE LETTER?
	JRST	CHKST5			;YES, CHECK THE NEXT CHARACTER
	JRST	CHKST7			;THIS CHARACTER IS INVALID

CHKST3:	CAILE	S2,"z"			;IS THIS A LOWER CASE LETTER?
	JRST	CHKST7			;NO, IT IS INVALID
	CAIL	S2,"a"			;IS THIS A LOWER CASE LETTER?
	JRST	CHKST4			;YES, CONVERT TO UPPER CASE

	CAIE	S2,"_"			;IS THIS AN UNDERSCORE?
	JRST	CHKST7			;NO, IT IS INVALID
	JRST	CHKST5			;YES, CHECK THE NEXT CHARACTER

CHKST4:	SUBI	S2,<"a"-"A">		;CONVERT TO UPPER CASE
	DPB	S2,P1			;STORE THE CHARACTER
CHKST5:	IBP	P1			;POINT TO THE NEXT CHARACTER
	JRST	CHKST1			;CHECK THE NEXT CHARACTER
CHKST6:	$RETT				;INDICATE ALL CHARACTERS VALID
CHKST7:	MOVEI	S2,[ASCIZ/Invalid character specified in name/]
	$RETF				;INDICATE INVALID CHARACTER

	

;[233]ROUTINE CHKNOD HAS BEEN ADDED AS PART OF THIS EDIT
;CHKNOD is called to ensure that the node specified in remote printing
;commands is not the local node

CHKNOD:	HRROI	S1,ATMBFR		;PICK UP THE ATOM BUFFER
	$CALL	S%SIXB			;CONVERT TO SIXBIT
	CAME	S2,G$NODE		;SPECIFIED NODE THE LOCAL NODE?
	$RETT				;NO, INDICATE TO THE CALLER
	MOVEI	S2,[ASCIZ/Cannot specify the local node name/]
	$RETF				;INDICATE ERROR TO THE CALLER



CHGBLK:	MOVE	S1,ARGFRE		;[260]PICK UP ADDRESS OF NEXT BLOCK
	MOVE	S2,[2,,.NDENM]		;[260]PICK UP CLUSTER-NODE NAME HEADER
	EXCH	S2,-2(S1)		;[260]REPLACE BLOCK HEADER WORD
	CAME	S2,[2,,.CMKEY]		;[260]A KEYWORD BLOCK?
	JRST	CHGB.2			;[260]NO, GO INDICATE AN ERROR
	MOVE	S2,@-1(S1)		;[260]PICK UP THE SIXBIT NODE NAME
	MOVEM	S2,-1(S1)		;[260]REPLACE ITS ADDRESS
	$RETT				;[260]RETURN TO OPRPAR VALIDATION

CHGB.2:	MOVEI	S2,[ASCIZ/Illegal node specification/]
	$RETF				;[260]RETURN TO OPRPAR VALIDATION

SUBTTL	CONTINUE command tables

SUBTTL	SHUTDOWN command tables

COMMENT	\
NOTE: SHOULD IT BECOME DESIRABLE FOR THE SHUTDOWN AND
CONTINUE COMMANDS TO BE NO LONGER SYNTACTICALLY IDENTICAL THEN THE
COMMON USE OF THIS PDB CHAIN DEFINITION IS NO LONGER VALID.
\

SHDFDB:	$NOISE	(SHD010,<scheduling for>)

UNVFDB:	$NOISE (UNVF01,<object>)

UNVF01:	$KEYDSP(UNVF02)

UNVF02:	$STAB
	ORNDSP(UNVF03,BATCH-STREAM,BAT)
	ORNDSP(UNVF04,<CARD-PUNCH>,CDP)
IFN FTFTS,<
	ORNDSP(UNVF03,<FAL-STREAM>,FAL)
	ORNDSP(UNVF03,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
	ORNDSP(UNVF04,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(UNVF04,<PLOTTER>,PLT)
	ORNDSP(UNVF10,PRINTER,LPT)
	ORNDSP(UNVF04,READER,RDR)
	$ETAB

UNVF03:	$SRANGE(CONFRM)

UNVF04:	$URANGE(CONFRM)

;[230]UNVF10 - UNVF16 ARE PART OF THIS EDIT

UNVF10:	$NOISE	(UNVF11,<unit number or remote printer type>)

UNVF11:	$ORANGE	(CONFRM,<number or range (n:m)>,<$ALTERNATE(<UNVF12>)>) ;[237]

;[230]REMOTE PRINTERS

UNVF12:	$KEYDSP	(UNVF13)
UNVF13:	$STAB
CLUSTER<  ORNDSP (UNVF14,CLUSTER,CLU)> ;[254]
	  ORNDSP (UNVF15,DQS,DQS)
	  ORNDSP (UNVF16,LAT,LAT)
	$ETAB
CLUSTER<
UNVF14:	$CLUSPL(CONFRM)
> ;[254]End of CLUSTER
UNVF15:	$DQSSPL(CONFRM)
UNVF16:	$LATSPL(CONFRM)

CONFRM:	$CRLF

SHD010:	$KEYDSP(SHD020)

SHD020:	$STAB
	ORNDSP(UNVF03,BATCH-STREAM,BAT)
	ORNDSP(UNVF04,<CARD-PUNCH>,CDP)
	ORNDSP(SHD030,NODE,NOD)
	ORNDSP(UNVF04,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP(UNVF04,<PLOTTER>,PLT)
	ORNDSP(UNVF10,PRINTER,LPT)
	ORNDSP(UNVF04,READER,RDR)
	$ETAB

SHD030:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO!CM%NSF)>)

SUBTTL	ABORT command tables

ABOFDB:	$NOISE	(ABO010,<current job on>)

ABO010:	$KEYDSP	(ABO020)
ABO020:	$STAB
	ORNDSP	(ABO060,<BATCH-STREAM>,BAT)
	ORNDSP	(ABO030,<CARD-PUNCH>,CDP)
IFN FTFTS,<
	ORNDSP	(ABO060,<FAL-STREAM>,FAL)
	ORNDSP	(ABO060,<FTS-STREAM>,FTS)
> ;End FTFTS conditional
	ORNDSP	(ABO030,<PAPER-TAPE-PUNCH>,PTP)
	ORNDSP	(ABO030,<PLOTTER>,PLT)
	ORNDSP	(ABO031,<PRINTER>,LPT)
	ORNDSP	(ABO090,<READER>,RDR)
	$ETAB


; Output device tables
;
ABO030:	$UNIT	(ABO040)

;[230]ABO031 - ABO038 ARE PART OF THIS EDIT

ABO031:	$NOISE	(ABO032,<unit number or remote printer type>)
ABO032:	$NUMBER	(ABO040,^D10,<unit number>,<$ACTION(CHKVAL),$ALTERNATIVE(ABO034)>)

;[230]REMOTE PRINTERS

ABO034:	$KEYDSP	(ABO035)
ABO035:	$STAB
CLUSTER<  ORNDSP (ABO036,CLUSTER,CLU)>	;[254]
	  ORNDSP (ABO037,DQS,DQS)
	  ORNDSP (ABO038,LAT,LAT)
	$ETAB
CLUSTER<
ABO036:	$CLUSPL (ABO040)
>;[254]End of CLUSTER
ABO037:	$DQSSPL	(ABO040)
ABO038:	$LATSPL	(ABO040)

ABO040:	$SWITCH	(ABO100,ABO050,<$ALTERNATE(ABO100)>)
ABO050:	$STAB
	ORNSWI	(<PURGE>,PUR)
	$ETAB


; Batch tables
;
ABO060:	$STREAM	(ABO070)
ABO070:	$SWITCH	(ABO100,ABO080,<$ALTERNATE(ABO100),$DEFAULT(</ERROR-PROCESSING>)>)
ABO080:	$STAB
	ORNSWI	(<ERROR-PROCESSING>,ERR)
	ORNSWI	(<NOERROR-PROCESSING>,NER)
	ORNSWI	(<PURGE>,PUR)
	$ETAB


; Card reader tables
;
ABO090:	$UNIT	(ABO100)


ABO100:	$EXPL	(CONFRM,<$ALTER(CONFRM)>)
SUBTTL	HOLD command tables
SUBTTL	RELEASE command tables

HLDFDB:	$KEY	(HLD030,HLD010)

HLD010:	$STAB
	ORNKEY	(<BATCH-JOBS>,BAT)
	ORNKEY	(<CARD-PUNCH-JOBS>,CDP)
IFN FTFTS,<
	ORNKEY	(<FTS-JOBS>,FTS)
> ;End FTFTS conditional
	ORNKEY	(<PAPER-TAPE-PUNCH-JOBS>,PTP)
	ORNKEY	(<PLOTTER-JOBS>,PLT)
	ORNKEY	(<PRINTER-JOBS>,LPT)
	$ETAB

HLD030:	$NUMBER(CONFRM,^D10,<request-id>,<$ACTION(CHKPOS),$ALTERNATE(HLD035)>)

HLD035:	$USER(CONFRM,<$ALTERNATE(HLD040)>)

HLD040:	$TOKEN(HLD050,<*>,<$HELP(<* to specify all requests>)>)

HLD050:	$NODE(CONFRM)
SUBTTL	DEFINE command tables

IFN	FTDN60,<
DEFFDB:	$KEY(DEF020,DEF010,<$DEFAULT(<NODE>)>)

DEF010:	$STAB
	ORNKEY(<NODE>,NOD)
	$ETAB

DEF020:	$NOISE(DEF030,<name>)

DEF030:	$NODNM(DEF040,<node name for IBM emulation/termination>,<$FLAGS(CM%PO!CM%NSF)>)

DEF040:	$NOISE(DEF050,<type>)

DEF050:	$KEYDSP(DEF060,<$DEFAULT(<HASP>)>)

DEF060:	$STAB
	ORNDSP(DEF063,<2780>,278)
	ORNDSP(DEF063,<3780>,378)
	ORNDSP(DEF063,<HASP>,HSP)
	ORNDSP(DEF140,<SNA-WORKSTATION>,SNA)
	$ETAB

DEF063:	$SWITCH	(DEF070,DEF065,<$ALTERNATE(DEF080),$DEFAULT(</SIGNON-REQUIRED>)>)
DEF065:	$STAB
	ORNSWI(<NO-SIGNON-REQUIRED>,NSN)
	ORNSWI(<SIGNON-REQUIRED>,SON)
	$ETAB

DEF070:	$NOISE(DEF080,<mode>)

DEF080:	$KEY(DEF100,DEF090,<$DEFAULT(<TERMINATION>)>)

DEF090:	$STAB
	ORNKEY(EMULATION,EMU)
	ORNKEY(TERMINATION,TRM)
	$ETAB

DEF100:	$NOISE(DEF110,<port>)

DEF110:	$NUMBER(DEF120,^D8,<port number for DN60>)

DEF120:	$NOISE(DEF130,<line>)

DEF130:	$NUMBER(CONFRM,^D8,<line number for DN60>)

DEF140:	$KEYDSP(DEF142,<$DEFAULT(<GATEWAY>)>)

DEF142:	$STAB
	ORNDSP(DEF180,<ACCESS-NAME>,ACC)
	ORNDSP(DEF150,<GATEWAY>,GWY)
	$ETAB

DEF150:	$NODNM(DEF160,<node name for SNA Gateway>,<$FLAGS(CM%PO!CM%NSF)>)
DEF160:	$KEY(DEF170,DEF162,<$DEFAULT(<ACCESS-NAME>)>)

DEF162:	$STAB
	ORNKEY(<ACCESS-NAME>,ACC)
	$ETAB

DEF170:	$FIELD(CONFRM,<access name>)

DEF180:	$FIELD(DEF190,<access name>)

DEF190:	$KEY(DEF200,DEF192,<$DEFAULT(<GATEWAY>)>)

DEF192:	$STAB
	ORNKEY(<GATEWAY>,GWY)
	$ETAB

DEF200:	$NODNM(CONFRM,<node name for SNA Gateway>,<$FLAGS(CM%PO!CM%NSF)>)

>;END FTDN60
SUBTTL	CANCEL command tables

CANFDB:	$KEYDSP(CAN010)

CAN010:	$STAB
	ORNDSP	(CAN020,<BATCH-REQUEST>,BAT)
	ORNDSP	(CAN020,<CARD-PUNCH-REQUEST>,CDP)
IFN FTFTS,<
	ORNDSP	(CAN020,<FTS-REQUEST>,FTS)
> ;End FTFTS conditional
	ORNDSP	(CAN040,<MOUNT-REQUEST>,MNT)
	ORNDSP	(CAN020,<PAPER-TAPE-PUNCH-REQUEST>,PTP)
	ORNDSP	(CAN020,<PLOTTER-REQUEST>,PLT)
	ORNDSP	(CAN020,<PRINTER-REQUEST>,LPT)
	$ETAB

CAN020:	$NUMBER(CONFRM,^D10,<request number to cancel in queue or if active>,<$ACTION(CHKPOS),$ALTERNATE(CAN030)>)

TOPS20 <
CAN030:	$USER(CONFRM,<$HELP(<user name whose jobs will be canceled>),$ALTERNATE(HLD040)>)
>;END TOPS20

TOPS10 <
CAN030:	$USER(CONFRM,<$HELP(<[project,programmer] whose jobs will be canceled>),$ALTERNATE(HLD040)>)
>;END TOPS10

CAN040:	$DEV(CAN060,<$HELP(<structure name to cancel all mount requests for>),$FLAGS(CM%PO),$ALTERNATE(CAN050)>)

TOPS10<
CAN050:	$NUMBER(CAN060,^D10,<mount request number to cancel>,<$ACTION(CHKPOS),$ALTERNATE(CAN055)>)
CAN055:	$TOKEN(CAN060,<*>,<$HELP(<* to specify all pending requests>)>)
>
TOPS20<
CAN050:	$NUMBER(CAN060,^D10,<mount request number to cancel>,<$ACTION(CHKPOS)>)
>

CAN060:	$EXPL(CONFRM,<$ALTERNATE(CONFRM)>)

SUBTTL	MODIFY command tables

MODFDB:
	$KEYDSP	(MOD010)

MOD010:	$STAB
TOPS10<	ORNDSP	(MOD300,<ACTIVE-SWAPPING-LIST>,ASL) >
	ORNDSP	(MOD020,<BATCH-REQUEST>,BAT)
	ORNDSP	(MOD020,<CARD-PUNCH-REQUEST>,CDP)
TOPS10<	ORNDSP	(MOD200,<CRASH-DUMP-LIST>,CDL) >
IFN FTFTS,<
	ORNDSP	(MOD020,<FTS-REQUEST>,FTS)
> ;End FTFTS conditional
	ORNDSP	(MOD020,<PAPER-TAPE-PUNCH-REQUEST>,PTP)
	ORNDSP	(MOD020,<PLOTTER-REQUEST>,PLT)
	ORNDSP	(MOD020,<PRINTER-REQUEST>,LPT)
TOPS10<	ORNDSP	(MOD200,<SYSTEM-SEARCH-LIST>,SSL) >
	$ETAB

MOD020:	$NUMBER(MOD030,^D10,<request number to modify in queue>,<$ACTION(CHKPOS),$ALTERNATE(MOD070)>)

MOD030:	$KEYDSP(MOD040)

MOD040:	$STAB
	ORNDSP(MOD050,<PRIORITY>,PRI)
	$ETAB

MOD050:	$NOISE(MOD060,<to be>)

MOD060:	$NUMBER(CONFRM,^D10,<priority for request in range 1 to 63>,<$ACTION(CHKPRI)>)

MOD070:	$USER(MOD030,<$ALTERNATE(MOD080)>)
MOD080:	$TOKEN(MOD090,<*>,<$HELP(<* to specify all requests>)>)

MOD090:	$NODE(MOD030)

TOPS10<

;More of the MODIFY command tables

;Here if MODIFYing lists pertaining to file structures
MOD200:	$NOISE	(MOD210,<to>)

MOD210:	$KEY	(MOD230,MOD220)

MOD220:	$STAB
	ORNKEY	(EXCLUDE,EXC)
	ORNKEY	(INCLUDE,INC)
	$ETAB

MOD230:	$DEV	(CONFRM,$HELP(<file structure name>))

;Here if MODIFYing lists pertaining to disk drives (units)
MOD300:	$NOISE	(MOD310,<to>)

MOD310:	$KEY	(MOD320,MOD220)

MOD320:	$DEV	(CONFRM,<$HELP(<disk unit name>),$FLAGS(CM%PO)>)

>;END TOPS10

SUBTTL	BACKSPACE command tables

SUBTTL	FORWARDSPACE command tables

BKSFDB::$KEY (BKS002,BKS001,<$DEFAULT(<PRINTER>)>)

BKS001:	$STAB
	ORNKEY (<PRINTER>,LPT)
	$ETAB

BKS002:	$NOISE	(BKS003,<unit number or remote printer type>)	;[260]
BKS003:	$NUMBER	(BKS009,^D10,<unit number>,<$ACTION(CHKVAL),$ALTERNATE(BKS006)>)
BKS006:	$KEYDSP	(BKS007)					;[260]
BKS007:	$STAB							;[260]
	  ORNDSP (BKS008,LAT,LAT)				;[260]
	$ETAB							;[260]
BKS008:	$LATSPL	(BKS009)					;[260]


BKS009:	$SWITCH(,BKS010)					;[260]

BKS010:	$STAB							;[260]
	ORNSDP(BKS011,<COPIES:>,CPY)				;[260]
	ORNSDP(CONFRM,<FILE>,FIL)				;[260]
	ORNSDP(BKS012,<PAGES:>,PAG)				;[260]
	$ETAB							;[260]

BKS011:	$NUMBER	(CONFRM,^D10,<number of copies>,$ACTION(CHKVAL));[260]
BKS012:	$NUMBER	(CONFRM,^D10,<number of pages>,$ACTION(CHKVAL))	;[260]

SUBTTL	ALIGN command table

ALIFDB::$NOISE (ALI001,<forms on>)

ALI001:	$KEY (ALI003,ALI002,<$DEFAULT(<PRINTER>)>)

ALI002:	$STAB
	ORNKEY (<PRINTER>,LPT)
	$ETAB

ALI003:	$NOISE	(ALI03A,<unit number or remote printer type>)	;[260]
ALI03A:	$NUMBER	(ALI010,^D10,<unit number>,<$ACTION(CHKVAL),$ALTERNATE(ALI03C)>) 								;[261]
ALI03C:	$KEYDSP	(ALI03D)					;[260]
ALI03D:	$STAB							;[260]
	  ORNDSP (ALI03E,LAT,LAT)				;[260]
	$ETAB							;[260]
ALI03E:	$LATSPL	(ALI010)					;[260]

ALI004:	$IFILE	(ALI005,<alignment file>,<$ALTER(ALI005)>)

ALI005:	$SWITCH(,ALI006,<$ALTER(CONFRM),$ACTION(SHRSWT)>)

ALI006:	$STAB
	ORNSDP(ALI007,<PAUSE:>,PAU)
	ORNSDP(ALI008,<REPEAT-COUNT:>,RPT)
	$ETAB

ALI007:	$NUMBER (NEXT,^D10,<seconds to pause>,$ACTION(CHKVAL))

ALI008:	$NUMBER (NEXT,^D10,<times to print>,$ACTION(CHKVAL))

ALI009:	$STAB
	ORNSWI(STOP,STP)
	$ETAB

ALI010:	$SWITCH(CONFRM,ALI009,<$ALTER(ALI004)>)

SUBTTL	ENABLE/DISABLE command tables

ENAFDB:	$KEYDSP	(ENA001,<$DEFAULT(OUTPUT-DISPLAY)>)

ENA001:	$STAB
TOPS20<	ORNDSP(ENA050,<AUTOMATIC-VOLUME-RECOGNITION>,AVR)>
TOPS20<	ORNDSP(ENACLS,<CLASS-SCHEDULER>,CLS)>
CLUSTER<ORNDSP(ENADCA,<DECNET-CONNECTION-ATTEMPTS>,DCA)>	;[254]
TOPS20<	ORNDSP(CONFRM,<FILE-RETRIEVAL-WAITS>,RET)>
	ORNDSP(CONFRM,<LOGFILES-TO-SPECIFIC-PRINTERS>,LSP)
	ORNDSP(CONFRM,<LOGGING>,LGG)
	ORNDSP(ENA100,<OUTPUT-DISPLAY>,OPD)
	ORNDSP(ENA180,<PRINT-LOGFILES>,LFS)
	ORNDSP(CONFRM,<QUEUE-REQUESTS>,QUE)
CLUSTER<ORNDSP(ENARCF,<REPORT-CONNECTION-FAILURES>,RCF)>	;[254]
	ORNDSP(CONFRM,<SEMI-OPR>,SEM)	;[236]ENABLE/DISABLE SEMI-OPR
CLUSTER<ORNDSP(CONFRM,<UNPRIVILEGED-USER-ENTIRE-REMOTE-OUTPUT-DISPLAY>,UNP)>;[254]
TOPS10<	ORNDSP(CONFRM,<STRUCTURE-RECOGNITION>,ASR)>
TOPS10< ORNDSP(ENA050,<VOLUME-RECOGNITION>,AVR)>
	$ETAB

ENA050:	$NOISE(ENA065,<for>)

ENA065:	$KEY(CONFRM,ENA070,<$ALTERNATE(ENA075)>)

ENA070:	$STAB
TOPS10< ORNKEY(<DISK-DRIVES>,DSK)>
	ORNKEY(<TAPE-DRIVES>,TAP)
	$ETAB
TOPS20<
ENA075:	$DEV(CONFRM,$HELP(tape drive name))
>;END TOPS20
TOPS10<
ENA075:	$DEV(CONFRM,<$HELP(<tape or disk drive name>)>)
>;END TOPS10

;continued on next page
;continued from previous page

;  Here on ENABLE/DISABLE OUTPUT-DISPLAY

ENA100:	$NOISE	(ENA105,<of>)

IFG	NUMAPL,<
ENA105:	$KEYDSP(ENA110,<$ALTERNATE(ENA140)>)
>;END NUMAPL
IFLE	NUMAPL,<
;**;[206]At ENA105:+0 change one line  JYCW  22-apr-86
ENA105:	$KEYDSP(ENA110)		;[206]If no application program show list
>;END

ENA110:	$STAB
	ORNDSP(ENA160,<ALL-MESSAGES>,ALM)
	ORNDSP(ENA160,<BATCH-MESSAGES>,BAT)
	ORNDSP(CONFRM,<BUGCHK-MESSAGES>,CHK)
	ORNDSP(CONFRM,<BUGINF-MESSAGES>,INF)
	ORNDSP(ENA160,<CARD-PUNCH-MESSAGES>,CDP)
	ORNDSP(ENA160,<CARD-READER-INTERPRETER-MESSAGES>,BIN)
	ORNDSP(CONFRM,<DECNET-EVENT-MESSAGES>,EVT)
	ORNDSP(CONFRM,<DECNET-LINK-MESSAGES>,DLK)
IFN FTFTS,<
	ORNDSP(ENA160,<FAL-MESSAGES>,FAL)
>  ; End of FTFTS conditional
	ORNDSP(ENA160,<FILE-RETRIEVAL-MESSAGES>,RET)
IFN FTFTS,<
	ORNDSP(ENA160,<FTS-MESSAGES>,FTS)
>  ; End of FTFTS conditional
	ORNDSP(ENA160,<MOUNT-MESSAGES>,MNT)
	ORNDSP(ENA160,<PAPER-TAPE-PUNCH-MESSAGES>,PTP)
	ORNDSP(ENA160,<PLOTTER-MESSAGES>,PLT)
	ORNDSP(ENA160,<PRINTER-MESSAGES>,LPT)
	ORNDSP(ENA160,<READER-MESSAGES>,RDR)
	ORNDSP(CONFRM,<SYSTEM-MESSAGES>,SYM)
	ORNDSP(ENA160,<USER-MESSAGES>,USR)
	$ETAB

IFG	NUMAPL,<
ENA140:	$KEY(CONFRM,ENA150)

	DEFINE	X(A,B,C,D),<ORNKEY(<A'-MESSAGES>,<B>)>

ENA150:	$STAB
	TABAPL
	$ETAB
>;END NUMAPL

ENA160:	$SWITCH(NEXT(ENA160),ENA170,<$ACTION(SHRSWT),$ALTERNATE(CONFRM)>)

ENA170:	$STAB
	ORNSWI(<INFORMATION-MESSAGES>,OTH)
	ORNSWI(<JOB-MESSAGES>,JOB)
	ORNSWI(<OPR-ACTION-MESSAGES>,OAM)
	$ETAB

ENA180:	$NOISE	(ENA185,<to local printer>)	 ;[252]
ENA185:	$ORANGE	(CONFRM,<local printer number or range (n:m)>) ;[252]

SUBTTL	ENACLS	ENABLE CLASS SCHEDULER command tables

TOPS20 <

ENACLS:	$SWITCH(,ENAC10,<$ALTERNATE(CONFRM),$ACTION(SHRSWT),$PREFILL(ENAACT)>)

ENAC10:	$STAB
	ORNSDP(ENAC30,<CLASS-ASSIGNMENTS:>,CAS)
	ORNSDP(ENAC20,<WINDFALL:>,WFL)
	$ETAB

ENAC20:	$KEY(NEXT(ENAC10),ENAC25,<$DEFAULT(<ALLOCATED>)>)

ENAC25:	$STAB
	ORNKEY(<ALLOCATED>,ALO)
	ORNKEY(<WITHHELD>,WHD)
	$ETAB

ENAC30:	$KEY(NEXT(ENAC10),ENAC35,<$DEFAULT(<ACCOUNT>)>)

ENAC35:	$STAB
	ORNKEY(ACCOUNT,ACT)
	ORNKEY(<POLICY-PROGRAM>,PPR)
	$ETAB

ENAACT:	MOVE	S1,CMDCOD			;GET THE COMMAND CODE
	CAIE	S1,.KYDIS			;WAS IT DISABLE?
	$RETT					;NO..RETURN O.K.
	MOVEI	S1,CONFRM			;GET CONFRM ADDRESS
	AOS	S1				;BUMP TO NEXT PDB
	STORE	S1,CR.PDB(S2),RHMASK		;RESET NEXT PDB
	$RETT					;RETURN
>;END TOPS20
SUBTTL	CLOSE command tables
SUBTTL	DEFINE command tables


CLOFDB:	$KEYDSP	(CLO001,<$DEFAULT(<LOG>)>)
CLO001:	$STAB
	ORNDSP	(CONFRM,LOG,LOG)
	$ETAB

	SUBTTL	ENABLE/DISABLE NEBULA CONNECTIONS

CLUSTER<
ENARCF:
ENADCA:	$SWITCH(ENAD20,ENAD10,<$ALTER(CONFRM)>)	;[247]

ENAD10:	$STAB					;[247]
	  ORNSWI(<NODE:>,NOD)			;[247]
	$ETAB					;[247]

ENAD20:	$NODNM(CONFRM,<node name>,<$FLAGS(CM%PO!CM%NSF),$ACTION(CHKNOD)>)

> ;[254]End of CLUSTER

SUBTTL	IDENTIFY command tables

TOPS20 <
IDNFDB::$NOISE(IDN010,<tape on drive>)>

TOPS10 <
IDNFDB:	$NOISE(IDN010,<device>)>

TOPS20 <
IDN010:	$DEV(IDN020,<$HELP(<tape drive name>)>)>

TOPS10 <
IDN010:	$DEV(IDN020,<$HELP(<device name>)>)>

IDN020:	$NOISE(IDN030,<with>)

IDN030:	$KEYDSP(IDN040,<$DEFAULT(<REQUEST-ID>)>)

IDN040:	$STAB
	ORNDSP(IDN050,<REQUEST-ID>,RQN)
TOPS20<	ORNDSP(CONFRM,<SCRATCH>,SCR) >	;ONLY VALID ON TOPS20
	ORNDSP(IDN060,<VOLUME-ID>,VID)
	$ETAB

IDN050:	$NUMBER(CONFRM,^D10,<request number of the mount request>,<$ACTION(CHKPOS)>)

IDN060:	$QUOTE(CONFRM,<volume-id in quotes if has non-alphanumeric characters>,<$ALTERNATE(IDN070)>)

IDN070:	$FIELD(CONFRM,<volume-id without quotes>)

SUBTTL	DISMOUNT command tables

DSMFDB:$KEYDSP(DSM010)

DSM010:	$STAB
	ORNDSP(DSM020,<STRUCTURE>,STR)
	ORNDSP(DSM030,<TAPE-DRIVE>,TAP)
	$ETAB

TOPS20 <

DSM020:	$DEV	(DSM060,<$HELP(<structure name to dismount>)>)

DSM060:	$NOISE (DSM070,<with>,<$ALTERNATE(CONFRM)>)

DSM070:	$KEY (CONFRM,DSM080,<$ALTERNATE(CONFRM)>)

DSM080:	$STAB
	ORNKEY (<NO-REMOVAL>,NRM)
	ORNKEY (<REMOVAL>,REM)
	$ETAB

> ;End TOPS20

DSM030:	$DEV	(CONFRM,<$HELP(<tape drive from which to dismount tape>)>)

TOPS10 <

DSM020:	$DEV	(DSM040,<$HELP(<structure name to dismount>),$FLAGS(CM%PO)>)

DSM040:	$SWITCH(,DSM050,<$ACTION(SHRSWT),$ALTERNATE(CONFRM)>)

DSM050:	$STAB
	ORNSDP(NEXT(DSM040),<NOCHECK>,NCK)
	ORNSDP(NEXT(DSM040),<REMOVE>,REM)
	$ETAB

> ;End TOPS10

	comment \
	;removed on July 11,1979
SUBTTL	UNLOAD	command tables (removed)

UNLFDB:	$NOISE(UNL010,<tape drive>)

UNL010:	$DEV	(CONFRM,<$HELP(<tape drive to unload>)>)

;	UNDEFINED FOR NOW
	\;end of comment


SUBTTL	RECOGNIZE command tables


TOPS10 <
RECFDB:	$NOISE(REC010,<labels on>)

REC010:	$DEV (CONFRM,<$HELP(<tape or disk drive to recognize>),$FLAGS(CM%PO)>)
>;END TOPS10

SUBTTL	HELP command tables

	ND	CR.ADR,4		;Address of current argument

HLPFDB:: $NOISE	(HLPFD1,<with>)

HLPFD1:	$CTEXT(,<command>,<$ACTION(HLPACT),$DEFAULT(HELP)>)

HLPACT:	MOVE	T1,CR.ADR(S2)		;Get the data
	HRROI	T1,ARG.DA(T1)		;Point to the string
	$CALL	SETOUT##		;Setup proper $TEXT defaults
	MOVEI	S1,HEPFD		;Point to help file
	MOVE	S2,T1			;Point to string
	$CALL	P$HELP##
	$CALL	SNDOUT##		;Send the output
	$CALL	P$NPRO##		;Mark no processing
	$RETT				;Return

;File descriptor for help file for OPR

TOPS20	<
HEPFD:	XWD	HSIZ,0
	ASCIZ /HLP:OPR.HLP/
HSIZ==.-HEPFD
>

TOPS10	<
HLPFD:	$BUILD	FDMSIZ
	$SET(.FDLEN,FD.LEN,FDMSIZ)
	$SET(.FDSTR,,<SIXBIT/HLP/>)
	$SET(.FDNAM,,<SIXBIT/OPR/>)
	$SET(.FDEXT,,<SIXBIT/HLP/>)
	$EOB
>

SUBTTL	SHOW ALLOCATION command tables

TOPS10<
ALC000:	$KEYDSP	(ALC010)

ALC010:	$STAB
	ORNDSP	(CONFRM,<ALL-REQUESTS>,ALL)
	ORNDSP	(ALC020,<BATCH-REQUEST>,BRQ)
	ORNDSP	(ALC030,JOB,JOB)
	$ETAB

ALC020:	$NUMBER	(CONFRM,^D10,<request-id for batch job>,<$ALTERNATE(ALC040)>)

ALC030:	$NUMBER	(CONFRM,^D10,<job number>)

ALC040:	$CRLF	($HELP(<confirm for all batch requests>))
>;END TOPS10

	END
