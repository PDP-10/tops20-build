TITLE	GALGEN	GALAXY system generation program
SUBTTL  Preliminaries

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1975, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


	SEARCH	GLXMAC,QSRMAC		;GET GLXLIB, QUASAR SYMBOLS

	PROLOGUE(GALGEN)		;GENERATE ALL NECESSARY DEFINITIONS


SUBTTL	Version information

	GLNVER==6			;Major version number
	GLNMIN==0			;Minor version number
	GLNMAN==0			;Maintenance edit level
	GLNDEV==6010			;Development edit level
	GLNWHO==0			;Last edited by (0 = DEC)

	VERSIN (GLN)			;Generate version number
	
GLNVEC: BLDVEC	(GLXMAC,GMC,L)
	BLDVEC  (QSRMAC,QMC,L)
	BLDVEC  (GALGEN,GLN,L)

	%GLN==<VRSN.(GLN)>+GMCEDT+QMCEDT

	LOC	137
	EXP	%GLN			;STORE VERSION NUMBER
	RELOC				;AND BACK TO NORMAL PROCESSING

	Subttl	Table of Contents

;		     Table of Contents for GALGEN
;
;				  Section		      Page
;
;
;    1. Version information  . . . . . . . . . . . . . . . . .   2
;    2. Revision History . . . . . . . . . . . . . . . . . . .   4
;    3. OUTPUT MACROS  . . . . . . . . . . . . . . . . . . . .   5
;    4. Parsing Settup Macros  . . . . . . . . . . . . . . . .   7
;    5. Parsing Action Macros  . . . . . . . . . . . . . . . .   9
;    6. Zero and Non-zero Data Area  . . . . . . . . . . . . .  10
;    7. Program Startup  . . . . . . . . . . . . . . . . . . .  12
;    8. Initialize the Configuration File  . . . . . . . . . .  13
;    9. Begin The Dialog . . . . . . . . . . . . . . . . . . .  14
;   10. Administrative Controls  . . . . . . . . . . . . . . .  15
;   11. CLUSTER GALAXY . . . . . . . . . . . . . . . . . . . .  16
;   12. SEMI-OPR Parameters  . . . . . . . . . . . . . . . . .  17
;   13. Applications Parameters  . . . . . . . . . . . . . . .  18
;   14. Batch Job Defaults . . . . . . . . . . . . . . . . . .  19
;   15. Line printer defaults and parameters . . . . . . . . .  20
;   16. MDA Parameters . . . . . . . . . . . . . . . . . . . .  21
;   17. NEBULA ACK MESSAGE OPTION  . . . . . . . . . . . . . .  22
;   18. Miscellaneous Parameters . . . . . . . . . . . . . . .  23
;   19. Terminal Input Processors  . . . . . . . . . . . . . .  25
;   20. KEYWORD - Parse a keyword response . . . . . . . . . .  26
;   21. NEWKEY Support routine for $NEWKEY macro . . . . . . .  27
;   22. NUMBER - SUPPORT ROUTINE FOR $NUMBER . . . . . . . . .  28
;   23. NUMBRS Support routine for $NUMBRS MACRO . . . . . . .  29
;   24. CHOICE Support Routine for $CHOICE MACRO . . . . . . .  30
;   25. HELP AND COMMENT SUPPORT ROUTINES  . . . . . . . . . .  31
;   26. $TEXT OUTPUT ROUTINES  . . . . . . . . . . . . . . . .  32
;   27. PROMPT Support Routine for $PROMPT Macro . . . . . . .  33
SUBTTL	Revision History

COMMENT \

*****	Release 4.2 -- Begin maintenance edits *****

			2-Mar-83
	Currently no edits

*****	Release 5.0 -- Begin development edits *****

2100	5.1013		2-mar-83
	Add edit vector, delete old edit history, update version and 
copyright.

2101	5.1049		24-Oct-83
	Fix previous edit using VRSN to correctly calculate version number.

2102	5.1050		25-Oct-83
	Add new question to determine the number of objects that can
be controlled by a single command.

2103	5.1160		18-Sept-84
	Add new question to determine the highest number a batch stream can be 
on a system.

2104	5.1184		3-Dec-84
	Add LCPTAB as a possible application.

2105	5.1197		5-Feb-85
	Add new questions to determine if QUASAR, ORION, BATCON and LPTSPL
are to be system processes or not.
*****	Release 5.0 -- begin maintenance edits	*****

2115	Increment maintenance edit level for version 5 of GALAXY.

*****	Release 6.0 -- Begin development edits *****

6000	6.1000		5-Oct-87
	Add question to determine if Cluster LPTSPL is to checksum its DECnet
messages or not. (The default is YES).

6001	6.1001		5-Oct-87
	Add a question to determine the logical name of Cluster LPTSPL's
shared directory.

6002	6.1034		23-Oct-87
	Add six questions regarding controllable devices for by SEMI-OPR.

6003	6.1038		27-Oct-87
	Add one question to determine whether Cluster GALAXY is ENABLE/DISABLE
at GALAXY start up.  The default is YES.

6004	6.1053		3-Nov-87
	Remove the Cluster printer checksum option

6005	6.1121		6-Dec-87
	Add an option to specify the number of LISSPL servers.

6006	6.1122		6-Dec-87
	Add an option as to whether NEBULA is to run as a system process 
or not.

6007	6.1189		19-Feb-88
	Add an option as to whether NEBULA should send NEBULA ACK
and NEBULA ACK RESPONSE messages or not.

6010	6.1225		8-Mar-88
	Update copyright notice.

\	;End of revision history

SUBTTL	OUTPUT MACROS

;UNCONDITIONAL TEXT OUTPUT

;Each of the following accept standard GALAXY $TEXT strings as
;arguments.  In Addition, the "@" is replaced by <CRLF> and is
;not written on terminal or file.


; $TTYSTR <@Hello@> would Type <CRLF>Hello<CRLF> on terminal.

	DEFINE	$TTYSTR (TEXT) <	;;WRITE STRING TO TERMINAL

	$TEXT	(TTYCHR,<TEXT>)		;;ACCEPT ANY $TEXT ARGUMENT

> ; END TTYSTR


; $CNFSTR <@Hello@> would Write <CRLF>Hello<CRLF> in Config File

	DEFINE	$CNFSTR (TEXT) <	;;WRITE STRING TO CONFIG FILE

	$TEXT	(CNFCHR,<TEXT>)		;;ACCEPT ANY $TEXT ARGUMENT

> ; END CNFSTR

	DEFINE	$BTHSTR (TEXT) <	;;WRITE TO FILE AND TERMINAL

	$TEXT	(BTHCHR,<TEXT>)		;;ACCEPT ANY $TEXT ARGUMENT

> ; END BTHSTR

; $HEADER Macro Accepts a one line String argument and generates the
; the following output for $HEADER (Header Text):

; Configuration File Output:
; Form Feed to start new page followed by "SUBTTL	Header Text"
; followed by header text centerd and underscored as follows
;
;			Header Text
;			------ ----

; Terminal output:
; Two blank lines followed by Centered and underscored "Header Text"

	DEFINE $HEADER (STRING) <

	$CALL	HEADER
	XLIST
	JUMP	[ASCIZ\STRING\]
	LIST

> ;END OF HEADER

; CONDITIONAL OUTPUT TO TERMINAL AND FILE

; $COMMENT Accepts a paragraph as an argument and conditionally displays
; and writes paragraph into configuration file as a multiline comment.
; Only does Output if Dialog Length is "LONG".


	DEFINE $COMMENT (STRING) <

	$CALL	COMMENT
	XLIST
	JUMP	[ASCIZ\STRING\]
	LIST

> ;END OF COMMENT


;$HELP Accepts a Paragraph as an argument and moves argument to
; HLPTXT to be used as help if user types ? in response to any
; Question.  The Help paragraph is also written in the Configuration
; file as a comment and displayed on the terminal if the dialog
; length is "LONG"

; Only Asciz strings are supported, however "@" will be replaced
; with <CRLF>.

	DEFINE $HELP (STRING) <

	$CALL	HELP
	XLIST
	JUMP	[ASCIZ\@STRING@\]
	LIST

> ;END OF HELP
SUBTTL	Parsing Settup Macros

; $PROMPT Accepts an $TEXT String as an argument and Causes this
; string to be moved to PRMTXT where it will be appended with any
; Range or Choice and any Default String.  $PROMPT does not cause
; the display of any text.  (The Text will be displayed when the
; appropriate action routine is called
; $PROMPT also initializes Range, Choice, and Default Specifications

	DEFINE $PROMPT (TEXT) <

	$CALL	PROMPT
	XLIST
	JUMP	[ITEXT <TEXT>]
	LIST

> ;END OF PROMPT

; $RANGE accepts Decimal integers for Minimum and maximum values
; for the $NUMBER and $FIELD Action Macros. It also accepts an
; Asciz Suffix.
; $RANGE appends the vaules to PRMTXT so they may be displayed
; with the prompt by the action routine.

	DEFINE $RANGE (MINIMUM,MAXIMUM,SUFFIX) <

	$CALL	RANGE
	XLIST
	JUMP	[^D<MINIMUM>
		 ^D<MAXIMUM>
	IFB <SUFFIX>,<Z ]>
	IFNB<SUFFIX>,<ASCIZ\ SUFFIX\]>
	LIST

> ;END OF RANGE
; Parsing Settup macros (continued)

; $CHOICES Accepts a list of Asciz Keywords to allow for the $KEYWORD
; Action Macro.  It generates a Sorted Keyword table beginning at
; location KEYTAB that is used for parsing keywords
; $CHOICES appends the list of possible choices to PRMTXT so it may
; be displayed with the prompt by the Keyword action routine.

	DEFINE $CHOICES (ARGLST) <

	$CALL	CHOICES
	XLIST
	$TABLE <ARGLST>				;BUILD TABLE AND POINTER
	LIST

> ;END OF CHOICES

; $REJECT Accepts a list of Keywords to reject for the $NEWKEY macro.


	DEFINE $REJECT (ARGLST) <

	$CALL	REJECT
	XLIST
	$TABLE <ARGLST>
	LIST

> ;END OF REJECT

; $DEFAULT accepts any standard $TEXT string as an argument and 
; moves the resultant string to DEFTXT where it is used if the
; user types only a carriage return.
; $DEFAULT also appends the string to PRMTXT so it may be displayed
; with the prompt by the Action routine

	DEFINE $DEFAULT (ITXT) <

	$CALL	DEFAULT
	XLIST
	JUMP	[ITEXT <ITXT>]
	LIST

> ;END OF DEFAULT

; $TABLE is used by $CHOICES and $REJECT to build a table and a one
; word pointer to the table in the form of a JUMP instruction

	DEFINE $TABLE (ARGLST) <

	.ZZ.==0					;COUNT ARGS
	IRP <ARGLST>,<.ZZ.==.ZZ.+1>
	JUMP	[XWD .ZZ.,[ASCIZ\ARGLST\]	;COUNT,,STRING ADR
		.ZZ.==0				;NUMBER ENTRIES
		  IRP ARGLST,<
		  XWD [ASCIZ\ARGLST\],.ZZ.
		  .ZZ.==.ZZ.+1
		  > ];END IRP ARGLST		;END OF TABLE

> ;END OF TABLE
SUBTTL	Parsing Action Macros

; The following macros cause the PROMPT (RANGE or CHOICES) [DEFAULT]
; to be displayed and the answer to be accepted.  The all call a
; single field parsing routine with the particular function they desire
; to have parsed


; $NUMBER Causes a Decimal integer to be accepted within the range
; specified since the last $PROMPT

; True Return always with Integer in S1

	DEFINE $NUMBER <

	$CALL	NUMBER

> ;END OF NUMBER

; $NUMBRS Causes a numeric string to be accepted

; The string must be numeric and may contain a decimal point

; Returns S1/ Integer value of the string (ignoring decimal point)
;	S2/ 1 * the number of digits to the right of the decimal

	DEFINE	$NUMBRS <

	$CALL	NUMBRS

> ;END OF NUMBRS

; $KEYWORD Causes a word specified in a $CHOICE since the last $PROMPT
; to be accepted (or the default if specified and only carriage return
; is typed)

; True Return always with

; S1/ Number of the word in the $CHOICE argument list (counting from 0)
; S2/ address of the Keyword asciz string

	DEFINE $KEYWORD <

	$CALL	KEYWORD

> ;END OF KEYWORD

; $NEWKEY Causes a unique word not currently in the KEYTABLE to be
; accepted and placed into the KEYTABLE.   $REJECT may be used to
; prefill the table with invalid entries

	DEFINE $NEWKEY <

		$CALL	NEWKEY

> ;END NEWKEY DEFINITION


; $FIELD Causes an alphanumeric field to be accepted.  It checks
; the field to see that it's length is within the $RANGE specified
; since the last $PROMPT

; True return if field is within specified range

; S1/ Length of field
; ATOM/ Start of asciz string

; False return if field is not within specifed range

; S1/ Length of field

	DEFINE $FIELD <

	$CALL	FIELD

> ;END OF FIELD


; $YESNO Causes a yes or no answer to be accepted. It takes
; three arguments, all of which ar optional
; Arg 1 -- Must be YES, NO, or blank (determines default answer)
; Arg 2 -- Must be Address to branch to on YES answer or blank
; Arg 3 -- Must be Address to branch to on NO answer or blank

; True return if YES was specified and dispatch address was blank

; False return if NO was specified and dispatch address was blank

	DEFINE $YESNO (DEFAULT,YESDSP<0>,NODSP<0>) <

	$CALL	YESNO
	XLIST
	JUMP	[YESDSP
		 NODSP
	IFB <DEFAULT>,<Z ]>	;NO DEFAULT
	IFNB<DEFAULT>,<ASCIZ\DEFAULT\]>
	LIST
> ;END OF $YESNO
SUBTTL	Zero and Non-zero Data Area

	PDLSIZ==60

PDL:	BLOCK	PDLSIZ

;SYSTEM DEPENDENT VARIABLES

OPSYS:	BLOCK	1		;0=TOPS10     -1=TOPS20
G.NPGS:	BLOCK	1		;NUMBER OF AVAILABLE USER PAGES
G.NCMX:	BLOCK	1		;MAXIMUM PAGES AVAILABLE PER JOB

;PROGRAM VARIABLES

CNFIFN:	BLOCK	1		;IFN OF GALCNF FILE
FULLFD:	BLOCK	1		;ADDRESS OF FULL OPENED FD FOR GALCNF
DIALEN:	BLOCK	1		;0=SHORT DIALOG     -1=LONG DIALOG
NOMSG:	BLOCK	1		;0=WRITE QUESTION/ANSWER -1=DONT WRITE
TXTPTR:	BLOCK	1		;POINTER USED BY DEPTXT ROUTINE
TXTCNT:	BLOCK	1		;INCREMENTED BY DEPTXT ROUTINE

IB:	$BUILD	IB.SZ
	  $SET	(IB.PRG,,%%.MOD)	;PROGRAM NAME IS GALGEN
	  $SET(IB.OUT,,TTYCHR)	;DEFAULT $TEXT OUTPUT ROUTINE
	  $SET(IB.FLG,IT.OCT,1)	;OPEN CONTROLLING TERMINAL
	$EOB

IFN FTUUOS,<
GFD:	$BUILD	FDMSIZ
	  $SET(.FDLEN,FD.LEN,FDMSIZ)
	  $SET(.FDNAM,,<SIXBIT/GALCNF/>)
	  $SET(.FDEXT,,<SIXBIT/MAC/>)
	$EOB
>  ;END IFN FTUUOS

IFN FTJSYS,<
GFD:	XWD GFDSIZ,0
	ASCIZ /DSK:GALCNF.MAC/
	GFDSIZ==.-GFD
>  ;END IFN FTJSYS

FOB:	$BUILD	FOB.SZ
	  $SET(FOB.FD,,GFD)		;FD ADDRESS
	  $SET(FOB.CW,FB.BSZ,7)		;FILE BYTE SIZE
	$EOB

;COMMAND STATE BLOCK

CMDBLK::
CMDFLG:	BLOCK 1			;COMMAND FLAGS,,REPARSE ADDRESS
CMDJFN:	BLOCK 1			;INPJFN,,OUTJFN
CMDPRM:	BLOCK 1			;PROMPT POINTER
BUFPTR:	BLOCK 1			;POINNTER TO BEGINNING OF COMMAND BUFFER
NXTPTR:	BLOCK 1			;POINTER TO NEXT CHARACTER TO BE PARSED
BUFSIZ:	BLOCK 1			;FREE CHARACTER COUNT IN COMMAND BUFFER
CMDINC:	BLOCK 1			;NUMBER OF CHARACTERS LEFT TO PARSE
ATMPTR:	BLOCK 1			;POINTER TO BEGGINING OF ATOM BUFFER
ATMSIZ:	BLOCK 1			;FREE CHARACTER COUNT  IN ATOM BUFFER
CMDJFB:	BLOCK 1			;ADDRESS OF GTJFN BLOCK FOR COMND BLOCK

;COMMAND FUNCTION BLOCK

FNCBLK::
CMDFNC:	BLOCK 1			;FUNCTION!FLAGS,,NEXT FNCBLK
CMDDAT:	BLOCK	1		;DATA SPECIFICE TO FUNCION
CMDHLP:	BLOCK 1			;POINTER TO HELP STRING (LONG)
CMDDEF:	BLOCK	1		;DEFAULT STRING POINTER
CMDFN2:	BLOCK	1		;FUNCTION BLOCK 2

;RANGE CHECK WORDS

MIN:	BLOCK 1
MAX:	BLOCK 1

	NCHRW==5		;CHARACTERS PER WORD
	BUFLEN==^D50		;SIZE OF BUFFER IN WORDS
	HLPSIZ==^D256		;MAX WORDS OF HELP
	KEY$LN==^D18		;LARGEST NUMBER OF CHOICES
	STR$LN==^D30/NCHRW	;SIZE OF STORAGE FOR LARGEST STRING
	KTE$LN==STR$LN+5	;Number of WORDS/TABLE entry

HLPTXT:	BLOCK HLPSIZ		;BUFFER TO STORE HELP STING
PRMTXT:	BLOCK ^D50		;STORAGE  FOR $TEXT PRMTXT
DEFTXT:	BLOCK ^D10		;STORAGE FOR DEFAULT STRING
BUFFER:	BLOCK BUFLEN		;COMMAND BUFFER
ATOM:	BLOCK BUFLEN		;ATOM BUFFER
KEYTAB:	BLOCK KEY$LN+1		;FOR KEYWORD ARGUMENTS
STRBUF:	BLOCK <KEY$LN*STR$LN>+<KEY$LN*3> ;ROOM FOR STRING STORAGE
SUBTTL	Program Startup

GALGEN:	RESET				;RESET THE WORLD
	MOVE	P,[IOWD PDLSIZ,PDL]	;SETUP THE PUSHDOWN POINTER
	MOVEI	S1,IB.SZ		;GET IB LENGTH
	MOVEI	S2,IB			;AND IB ADDRESS
	$CALL	I%INIT		;AND GET THE LIBRARY

	$TTYSTR <@GALGEN Version ^V/[%GLN]/@>

	SETZM	CMDFLG			;CLEAR FLAGS AND REPARSE
	MOVE	S1,[.PRIIN,,.PRIOU]	;SET JFNS TO TTY
	MOVEM	S1,CMDJFN
	HRROI	S1,PRMTXT		;POINT TO PRMTXT BUFFER
	MOVEM	S1,CMDPRM
	HRROI	S1,BUFFER		;POINT TO BUFFER
	MOVEM	S1,BUFPTR		;BEGINNING
	MOVEM	S1,NXTPTR		;NEXT CHARACTER TO PARSE
	SETZM	CMDINC			;CLEAR CONT OF CHAR TO PARSE
	MOVEI	S1,BUFLEN*NCHRW		;COMPUTE SIZE OF BUFFER
	MOVEM	S1,BUFSIZ		;AND SAVE
	MOVEM	S1,ATMSIZ		;SAME SIZE AS ATOM (CURRENTLY)
	HRROI	S1,ATOM			;POINT TO ATOM BUFFER
	MOVEM	S1,ATMPTR		;AND SAVE
	SETZM	CMDJFB			;NO GET JFN BLOCK CURRENTLY

	MOVEI	S1,KEY$LN		;INIT KEYTABLE
	MOVEM	S1,KEYTAB

;NO NEED TO FIND OUT WHAT SYSTEM WE ARE RUNNING.  WE ARE ALWAYS TOPS-20

REPEAT 0,<
	MOVX	S1,<112,,11>		;GETTAB TO MONITOR TYPE
	GETTAB	S1,			;DO IT FOR TOPS-10
	  $STOP(CDM,Cannot Determine Monitor Type)
	LDB	S1,[POINT 6,S1,23]	;GET MONITOR TYPE
	SETZM	OPSYS			;ASSUME ITS TOPS10
	CAIE	S1,1			;IF TOPS10
	CAIN	S1,4			; OR TOPS20
	SKIPA				;ALL IS WELL
	$STOP(UMT,Unrecognized Monitor Type)
	CAIN	S1,4			;IS IT TOPS20?
	SETOM	OPSYS			;YES, REMEMBER
	MOVEI	S1,[ASCIZ /TOPS-10/]	;LOAD MONITOR TYPE
	SKIPE	OPSYS			;SKIP IF NOT
>
	SETOM	OPSYS			;[6002]ALWAYS TOPS-20
	MOVEI	S1,[ASCIZ /TOPS-20/]	;ONE OR THE OTHER
	$TTYSTR <@
[Starting GALAXY Generation Procedure for ^T/0(S1)/ System]>
SUBTTL	Initialize the Configuration File

INITFL:	MOVEI	S1,FOB.SZ		;GET FOB SIZE
	MOVEI	S2,FOB			;GET FOB
	$CALL	F%OOPN		;OPEN THE FILE
	JUMPT	INIT.1			;JUMP IF WE WON
	$TTYSTR <@?  Cannot write configuration file ^F/GFD/ -- ^E/[-1]/>
	PJRST	I%EXIT			;AND STOP NOW

INIT.1:	MOVEM	S1,CNFIFN			;STORE THE IFN
	SETO	S2,			;GET FULL FD OF THE FILE
	$CALL	F%FD			;ASK GLXLIB FOR IT
	MOVEM	S1,FULLFD		;STORE IT
	$TTYSTR <[Writing  GALAXY Configuration File ^F/@FULLFD/]>


	$CNFSTR <

SUBTTL	GALCNF	Created by GALGEN Version ^V/[%GLN]/ at ^H/[-1]/

	UNIVERSAL GALCNF
	.DIRECT	.NOBIN


	DEFINE XP (SYM,VAL) ^7/[.CHLAB]/
	SYM==:VAL^7/[.CHRAB]/

	G.%GLN==^O/[%GLN]/		;STANDARD VERSION FOR GALGEN
	G.GVER==^O/[GLNVER]/		;GALAXY VERSION NUMBER

	RADIX 5+5>

	MOVNI	S1,1			;LOAD A TOPS10 VALUE
	MOVEI	S2,0			;AND A TOPS20 VALUE
	SKIPE	OPSYS			;SKIP IF IT IS TOPS10
	EXCH	S1,S2			;EXCHANGE THEM IF TOPS20

	$CNFSTR <

	FTUUOS==^D/S1/			;-1 IF TOPS 10 ELSE 0
	FTJSYS==^D/S2/			;-1 IF TOPS 20 ELSE 0>
SUBTTL	Begin The Dialog

DIALOG:	SETOM	DIALEN			;ASSUME LONG DIALOG

	$COMMENT <
In the following dialog, all questions are of the form:

  text of question (list or range of answers) [default answer]>
	$COMMENT <
The line starts with the actual text of the question.  Following
the question is a description  of the possible answers  enclosed
in parentheses.  This description might be a range of numbers, a
list of  keywords, or  a  textual description.   Following  this
description is the default answer, enclosed in square  brackets.
The default will be assumed if you only press the RETURN key.>
	$COMMENT<
You have the  choice of carrying  on a LONG  dialog in which  an
explanation of  each question  is provided  automatically, or  a
SHORT dialog in which it is  assumed that you are familiar  with
the GALAXY generation procedure.  In either case, you can always
obtain the help text by typing  a question mark (?) in  response
to any question.>
	$HELP <
Answer the  following  question with  either  LONG (for  a  long
dialog) or SHORT (for a short one).  Simply pressing the  RETURN
key will imply SHORT.>

DIAL.1:	$PROMPT <Dialog Length>
	$CHOICES <SHORT,LONG>
	$DEFAULT (SHORT)
	$KEYWORD			;GET THE KEYWORD

DIAL.2:	CAIE	S1,1			;WAS LONG SPECIFIED?
	SETZM	DIALEN			;NO -- MAKE IT SHORT

SUBTTL	Administrative Controls

ADMIN:	$HEADER (Administrative Controls and Parameters)
	$COMMENT <
The  questions  in  this   section  determine  absolute   GALAXY
parameters, which  cannot  be  overridden by  user  or  operator
commands.>
	$CNFSTR <@	XP	G.OLOG,^D/[-1]/>
	$HELP < 
The system logs all operator interactions in a disk file in  the
spooling area.  Your answer to the following question  specifies
the name to be used for this file.>

	$PROMPT	<Operator log filename>

TOPS10 <$RANGE (3,6,Characters)
	$DEFAULT (OPERAT)>

TOPS20 <$RANGE (3,20,Characters)
	$DEFAULT (OPERATOR-SYSTEM)>

	$FIELD

	$CNFSTR <
DEFINE G$$LGN ^7/[.CHLAB]/	X	^T/ATOM/^7/[.CHRAB]/>

ADM.1:

TOPS10 <
	$HELP <
You have the option  of maintaining a  backup master queue  file
which may be used in the unlikely event that the primary  master
queue file is destroyed.>

	$PROMPT	<Do you want redundant master queue file>
	$YESNO	NO
	
	$CNFSTR	<@	XP	FTRQUE,^D/TF/>

	$HELP <
Any  permanantly  mounted  structure  may be used for the master
queues.  The structure that is first in the system  search  list
is preferred.>
	$PROMPT <File structure to use for master queue>
	$RANGE (3,6,Characters)
	$DEFAULT <SSL>
	$FIELD

	$CNFSTR <@	XP	G.QSTR,'^T6/ATOM/'>
> ;END OF TOPS10 CONDITIONAL

TOPS20 <
	$CNFSTR <@	XP	G.QSTR,0	;NOT REQUIRED FOR TOPS20>
	$CNFSTR <@	XP	FTRQUE,0	;NOT REQUIRED FOR TOPS20>
> ;END OF TOPS20 CONDITIONAL
ADM.3:
	$HELP <
Users can  specify  a  priority for  their  batch  and  spooling
requests with the  /PRIORITY switch.  The  allowable values  for
this parameter range  between 1  (representing lowest  priority)
and 63 (representing the highest).  The following two  questions
relate to this switch.  The first question requests the  maximum
priority which may be specified by a non-privileged user. >

	$PROMPT <Maximum priority non-privileged users may specify>
	$RANGE (1,63)
	$DEFAULT (20)
	$NUMBER

	$CNFSTR <@	XP	G.SPRI,^D/S1/>

	$HELP<
You may specify the value to be used if the user does not specify
a /PRIORITY switch.  This value must be between 1 and the maximum
that you specified in the previous question.>

	$PROMPT <Default for /PRIORITY on batch and spooling requests>
	$RANGE (1,63)
	$DEFAULT (10)
	$NUMBER				;GET THE NUMBER

	$CNFSTR <@	XP	G.DPRI,^D/S1/>

	$HELP<
This value is to control the number of objects  (printers,  batch
streams, etc.) that can be controlled by a single command in OPR.
This value should be at least the maximum number of objects of  a
single type you may have.  This value must be at least 1.>

	$PROMPT <Maximum number of objects that can be controlled with one command>
	$RANGE (1,100)
	$DEFAULT (6)
	$NUMBER

	$CNFSTR <@	XP	G.MRNG,^D/S1/>

	$HELP<
Specify the highest number that a batch stream can be on the system.  The value must be greater than zero and less than or equal to 10000. >

	$PROMPT <Highest number a batch stream can be on the system>
	$RANGE (1,10000)
	$DEFAULT (100)
	$NUMBER

	$CNFSTR <@	XP	G.INBS,^D/S1/>

	$HELP<
The priority of a  process  and  the  permissible  range  of
queues it may run in is determined by the scheduler priority
control word.  A system process gets a higher priority  than
all  user  jobs  and  gets  as much time as is necessary for
execution. >

	$PROMPT<Do you wish QUASAR to run as a system process?>

	$YESNO (YES)

	SETZM S1			;IB.SYS turned off
	SKIPF				;If no, keep IB.SYS turned off
	AOS	S1			;If yes, turn on IB.SYS
	$CNFSTR<@	XP	Q.SYS,^D/S1/>

	$PROMPT<Do you wish ORION to run as a system process?>

	$YESNO (YES)
	SETZM S1			;IB.SYS turned off
	SKIPF				;If no, keep IB.SYS turned off
	AOS	S1			;If yes, turn on IB.SYS
	$CNFSTR<@	XP	O.SYS,^D/S1/>

	$PROMPT<Do you wish NEBULA to run as a system process?>

	$YESNO (YES)
	SETZM S1			;IB.SYS turned off
	SKIPF				;If no, keep IB.SYS turned off
	AOS	S1			;If yes, turn on IB.SYS
	$CNFSTR<@	XP	N.SYS,^D/S1/>

	$PROMPT<Do you wish BATCON to run as a system process?>

	$YESNO (YES)
	SETZM S1			;IB.SYS turned off
	SKIPF				;If no, keep IB.SYS turned off
	AOS	S1			;If yes, turn on IB.SYS
	$CNFSTR<@	XP	B.SYS,^D/S1/>

	$PROMPT<Do you wish LPTSPL to run as a system process?>

	$YESNO (YES)
	SETZM S1			;IB.SYS turned off
	SKIPF				;If no, keep IB.SYS turned off
	AOS	S1			;If yes, turn on IB.SYS
	$CNFSTR<@	XP	L.SYS,^D/S1/>
SUBTTL	CLUSTER GALAXY
;[6003]  C.GALA is the CLUSTER GALAXY flag word.  0=disable 1=enable

	$HELP<The follow pararmeter determines whether CLUSTER GALAXY should
be ENABLEd or DISABLEd at GALAXY startup.  The default is YES.
>
	$PROMPT<Do you want to ENABLE CLUSTER GALAXY at GALAXY start up?>

	$YESNO (YES)
	SETZM S1			;ASSUME NO
	SKIPF				;If no,
        AOS S1				;1=enable
	$CNFSTR<@	XP	C.GALA,^D/S1/>
	
SUBTTL	SEMI-OPR Parameters
;[6002]
	$HELP<
The following parameters allows a user with SEMI-OPR privilege to be able
to control certain devices.
 >

	$PROMPT<Do you want SEMI-OPR to be able to control the printers?>
	SETZM S2
	$YESNO (YES)

	SETZM S1			;S.PRI turned off
	SKIPF				;If no, keep S.PRI turned off
	 $CALL [AOS S1			;If yes, turn on S.PRI
	       AOS S2
	       $RETT]
	$CNFSTR<@	XP	S.PRI,^D/S1/>

	$PROMPT<Do you want SEMI-OPR to be able to control the plotters?>

	$YESNO (YES)
	SETZM S1			;S.PLO turned off
	SKIPF				;If no, keep S.PLO turned off
	 $CALL [AOS S1			;If yes, turn on S.PRI
	       AOS S2
	       $RETT]
	$CNFSTR<@	XP	S.PLO,^D/S1/>

	$PROMPT<Do you want SEMI-OPR to be able to control the card readers?>

	$YESNO (YES)
	SETZM S1			;S.CRD turned off
	SKIPF				;If no, keep S.CRD turned off
	 $CALL [AOS S1			;If yes, turn on S.PRI
	       AOS S2
	       $RETT]
	$CNFSTR<@	XP	S.CRD,^D/S1/>

	$PROMPT<Do you want SEMI-OPR to be able to control the card punch?>

	$YESNO (YES)
	SETZM S1			;S.CPH turned off
	SKIPF				;If no, keep S.CPH turned off
	 $CALL [AOS S1			;If yes, turn on S.PRI
	       AOS S2
	       $RETT]
	$CNFSTR<@	XP	S.CPH,^D/S1/>

	$PROMPT<Do you want SEMI-OPR to be able to control the paper tape punch?>

	$YESNO (YES)
	SETZM S1			;S.CPH turned off
	SKIPF				;If no, keep S.CPH turned off
	 $CALL [AOS S1			;If yes, turn on S.PRI
	       AOS S2
	       $RETT]
	$CNFSTR<@	XP	S.PTP,^D/S1/>

	$PROMPT<Do you want SEMI-OPR to be able to control the tape drives?>

	$YESNO (YES)
	SETZM S1			;S.TAP turned off
	SKIPF				;If no, keep S.TAP turned off
	 $CALL [AOS S1			;If yes, turn on S.PRI
	       AOS S2
	       $RETT]
	$CNFSTR<@	XP	S.TAP,^D/S1/>
	$CNFSTR<@	XP	S.SOP,^D/S2/> ;TOTAL SEMI-OPR DEVICE
					      ;CONTROL

SUBTTL	Applications Parameters

APPLIC:	$HEADER <Applications>

	$COMMENT <
The following section establishes  parameters  for  applications
supported by GALAXY (for example, NCP).  These applications will
be accessible through OPR, the operator interface.>
	$HELP <
You  can  enable  applications  through  your  answers  to   the
following questions.>

	$PROMPT <Will you be running applications?>
TOPS10	<$YESNO	(NO)>
TOPS20	<$YESNO	(YES)>

	JUMPF	APL.5				;WRITE NULL DEFINITION
	$HELP <
Each application must  be associated with  an application  table
name (for example, NCPTAB).>

	HRRZS	KEYTAB			;CLEAR TABLE COUNTS
	SETOM	NOMSG			;SUPPRESS WRITING DIALOG TO FILE

APL.1:	$PROMPT <Application name or carriage return to exit>
	$RANGE (1,20,characters)
	$NEWKEY
	JUMPF	APL.2			;END OF TABLES
	MOVEI	S1,KEYTAB		;GET ENTRIES ADDRESS
	MOVE	S2,[POINT 7,ATOM]
	$CALL	S%TBLK
	MOVE	P1,(S1)			;SAVE CONTENTS IN P1

	$PROMPT <Table name for ^T/ATOM/>
	$RANGE (1,6,Characters)
	$FIELD
	HRLI	P1,440700		;MAKE POINTER TO STORAGE
	MOVEM	P1,TXTPTR		;SAVE FOR DEPTXT
	$TEXT	(DEPTXT,<^T6/ATOM/^0>)	;SAVE THE STRING
	$PROMPT	<Is there an internal ORION application for this application?>
	$YESNO	(NO)
	JUMPF	APL.1			;NO is right
	$PROMPT	<Application module name>
	$RANGE	(1,6,Characters)
	$FIELD
	HLRZ	S1,KEYTAB		;Get the count
	IMULI	S1,KTE$LN		;Multiply by the size of an entry
	ADDI	S1,STRBUF-2		;Calculate where to store the string
	HRLI	S1,(POINT 7,)		;Make pointer to storage
	MOVEM	S1,TXTPTR		;Store for DEPTXT
	$TEXT	(DEPTXT,<^T6/ATOM/^0>)
	JRST	APL.1

	$CNFSTR	<@;;X	^7/[.CHLAB]/Application^7/[.CHRAB]/,Seq,Table>

APL.2:	$CNFSTR	<@DEFINE G$$ATB ^7/[.CHLAB]/>	;START TABLE DEFINITION

	HLLZ	T1,KEYTAB			;GET NUMBER OF ENTRIES
	JUMPE	T1,APL.4			;EMPTY?
	MOVNS	T1				;NO -- NEGATE COUNT
	HRRI	T1,KEYTAB+1			;POINT TO FIRST ENTRY
	SETZ	T2,				;CLEAR SEQUENCE
 APL.3:	HLRZ	S1,(T1)				;POINT TO FIRST STRING
	HRRZ	S2,(T1)				;POINT TO SECOND STRING
	MOVEI	T3,2(S2)			;Point to possible module name
	$CNFSTR	<@X	^7/[.CHLAB]/^T/0(S1)/^7/[.CHRAB]/,^D/T2/,^T/0(S2)/,^T/0(T3)/>
	AOJ	T2,				;BUMP SEQUENCE
	AOBJN	T1,APL.3			;DO ALL ENTRIES

APL.4:	$CNFSTR	<@^7/[.CHRAB]/ ; END OF G$$ATB>
	SETZM	NOMSG				;RESTORE WRITING TO FILE
	SKIPA
APL.5:	$CNFSTR	<@DEFINE G$$ATB ^7/[.CHLAB]/^7/[.CHRAB]/>
SUBTTL	Batch Job Defaults

BJOB:	$HEADER <Batch Job Defaults>

	$COMMENT <
The questions in this section are used to define default  values
for  the various options that a user can specify when submitting
a batch job.>
	$HELP <
The  batch  user can specify a maximum runtime for his batch job
using the /TIME switch.  If he does not specify this switch  the
following default will be used:>

BJOB.1:	$PROMPT <Default batch job runtime limit>
	$RANGE (5,9999,seconds)
	$DEFAULT (300)
	$NUMBER				;GET A NUMBER

	$CNFSTR <@	XP	G.ITIM,^D/S1/>
	$HELP < 
Every batch  job has  maximum limits  for each  type of  spooled
output.  These  limits  can  be  set  by  the  batch  user  with
appropriate switches to the SUBMIT command.  If the user doesn't
specify these switches, the following defaults will be used:>

BJOB.2:	$PROMPT <Line printer output limit>
	$RANGE (0,9999,pages)
	$DEFAULT (200)
	$NUMBER				;GET A NUMBER

	$CNFSTR <@	XP	G.ILPT,^D/S1/>

BJOB.3:	$PROMPT <Card punch output limit>
	$RANGE (0,9999,cards)
	$DEFAULT (1000)
	$NUMBER				;GET A NUMBER

	$CNFSTR <@	XP	G.ICDP,^D/S1/>

	$PROMPT	<Paper tape punch output limit>
	$RANGE (0,5000,feet)
	$DEFAULT (200)
	$NUMBER

	$CNFSTR <@	XP	G.IPTP,^D/S1/>

	$PROMPT	<Plotter output limit>
	$RANGE (0,5000,minutes)
	$DEFAULT <30>
	$NUMBER

	$CNFSTR <@	XP	G.IPLT,^D/S1/>
	JRST	BJOB.4

LOGTBL:	2			;VALUE FOR LOG
	1			;VALUE FOR NOLOG
	3			;VALUE FOR ERROR

BJOB.4:
	$HELP < 
The user can specify whether or not the batch log file should be
printed after the job terminates by using the /OUTPUT switch  to
the SUBMIT command.  The action  is specified by: LOG to  always
print the log file, NOLOG to never print the log file, and ERROR
to print the log  file only if the  job ended with an  unhandled
error.  If the user doesn't  specify this switch, the  following
value will be used.>

	$PROMPT <Default for SUBMIT/OUTPUT>
	$CHOICES <LOG,NOLOG,ERROR>
	$DEFAULT (LOG)
	$KEYWORD			;GET THE KEYWORD

	$CNFSTR <@	XP	G.ILOG,^D/LOGTBL(S1)/>

	MOVEI	S1,0			;LOAD A ZERO
	SKIPE	OPSYS			;SKIP IF TOPS10
	JRST	BJOB.7			;AND JUST WRITE THE VALUE

	$HELP <
The  system  provides  for the enforcement of a maximum physical
memory limit on batch jobs.  The  user  can  specify  a  maximum
memory  parameter  and  if  any  program attempts to exceed this
limit, the batch job goes virtual.>

BJOB.5:	$PROMPT <Should memory limits be enforced>
	$YESNO	YES
	SETZM	S1
	JUMPF	BJOB.7			;IF NO, WRITE A 0

	$HELP <
The  user  can specify a maximum memory limit by using the /CORE
switch.  If this switch  is  not  specified  by  the  user,  the
following default will be used.>

BJOB.6:	$PROMPT <Memory limit>
	$RANGE (24,512,pages)
	$DEFAULT (200)
	$NUMBER				;GET A NUMBER

BJOB.7:	$CNFSTR <@	XP	G.ICOR,^D/S1/	;CORE LIMITS>
SUBTTL	Line printer defaults and parameters

LPTP:	$HEADER <Line Printer Defaults and Parameters>

	$COMMENT <
The questions in this section are used to set default values for
the line printer spooler.>
	$HELP <
Job banner pages are printed at  the  beginning  of  each  print
request.   The  user's  name  and  any /NOTE value is printed on
them.>

	$PROMPT	<Number of job banner pages>
	$RANGE (0,5)
	$DEFAULT (2)
	$NUMBER				;GET THE NUMBER

	$CNFSTR <@	XP	G.LBAN,^D/S1/>

	$HELP <
Job  trailer pages are printed at the end of each print request.
The user's  name  and  any  spooler  checkpoint  information  is
printed on them.>

	$PROMPT	<Number of job trailer pages>
	$RANGE (0,5)
	$DEFAULT (2)
	$NUMBER				;GET THE NUMBER

	$CNFSTR <@	XP	G.LTRL,^D/S1/>

	$HELP	<
File header pages are printed before  each file or copy in  each
print request.  The file name is printed in BOLD letters on each
header page.>

	$PROMPT <Number of file header pages>
	$RANGE (0,5)
	$DEFAULT (2)
	$NUMBER				;GET THE NUMBER

	$CNFSTR <@	XP	G.LHDR,^D/S1/>

	$HELP <
The user can specify a special form for a print request with the
/FORMS switch.  If this switch is not  specified  the  following
default will be used.>

	$PROMPT	<Name for standard output forms>
	$RANGE (4,6,Characters)
	$DEFAULT (NORMAL)
	$FIELD

	$CNFSTR <@	XP	G.DNOR,'^T6/ATOM/'>

	$HELP <
The number  of  characters  that uniquely  identify  a  form  is
compared with  the current  form name  to determine  if a  forms
change is required for a specific user request.>

	$PROMPT	<Number of characters which uniquely identifies form>
	$RANGE (2,6)
	$DEFAULT (4)
	$NUMBER				;GET THE NUMBER

	$CNFSTR <@	XP	G.DNUC,^D/S1/>

	$HELP < 
Cluster LPTSPL requires a directory that must be shared  between
all  the  systems  in the cluster which send print requests to a
Cluster LPTSPL.  The default logical name is LPTXFR.>

	$PROMPT	<Cluster LPTSPL shared directory logical name >

TOPS20 <$RANGE (2,40,Characters)
	$DEFAULT (LPTXFR)>

	$FIELD

	$CNFSTR <
DEFINE G$$LPT ^7/[.CHLAB]/	X	^T/ATOM/^7/[.CHRAB]/>

	$HELP	<
Cluster printers require the LISSPL server to be running on the node  where
the actual physical printer is located. LISSPL has server forks which  pick
up the print requests from remote nodes. The default number of server forks
is 2.>

	$PROMPT	<Number of LISSPL server forks >
	$RANGE (1,4)
	$DEFAULT (2)
	$NUMBER				;GET THE NUMBER

	$CNFSTR <@	XP	L.NUML,^D/S1/>

SUBTTL	MDA Parameters
	
MDA:	TOPS10<

	$HEADER (Parameters for MDA)

	$COMMENT <
The questions  in  this section  are  used to  set  the  default
parameters for the Mountable Device Allocator (MDA).>

	$CNFSTR	<

	      %TRK7==1			      ; 7 TRACK
	      %TRK9==2			      ; 9 TRACK
	>

	$HELP <
You have  the  option of  specifying  which label  type  is  the
default.
                             NOTE:
Label type USER-EOT will allow a user program to see the end  of
tape condition on an UNLABELED tape only.  All other label types
will  cause  the  user  to  block  at  end  of  tape  while  MDA
automatically  expands  the  volume  set.  In this case the user
program will NOT see end of tape.  >

MDA.1:	$PROMPT <Default tape label type>
	$CHOICES <ANSI,BYPASS,IBM,USER-EOT,UNLABELED>
	$DEFAULT (<USER-EOT>)
	$KEYWORD

	MOVE	P1,[EXP %TFANS,%TFLBP,%TFEBC,%TFUNV,%TFUNL](S1)

	$CNFSTR	<@	XP	DEFLBT,^D/P1/>

	$HELP	<
You have the option of  specifying the default density at  which
tapes are read and written.>

MDA.2:	$PROMPT	<Default 9-track tape density>
	$CHOICES <200,556,800,1600,6250>
	$DEFAULT (1600)
	$KEYWORD

	MOVE	P1,[EXP .TFD20,.TFD55,.TFD80,.TFD16,.TFD62](S1)

	$CNFSTR	<@	XP	DEF9TK,^O/P1/>

	$PROMPT	<Default 7-track tape density>
	$CHOICES <200,556,800>
	$DEFAULT (800)
	$KEYWORD

	MOVE	P1,[EXP .TFD20,.TFD55,.TFD80](S1)

	$CNFSTR	<@	XP	DEF7TK,^O/P1/>

	$HELP	<
You have  the option  of specifying  the default  track type  on
which to mount tapes.>

	$PROMPT	<Default track type>
	$CHOICES <7,9>
	$DEFAULT (9)
	$KEYWORD

	$CNFSTR	<@	XP	DEFTRK,%TRK^T/0(S2)/>

>
TOPS20<	$HEADER	<Tape Label Action>>

	$HELP	<
The system  administrator  can  allow  non-privileged  users  to
bypass label processing.>

	$PROMPT	<Allow bypassing for non-privileged users?> 
	$YESNO	(NO)

	$CNFSTR	<@	XP	NPRTLB,^D/TF/>

	SUBTTL NEBULA ACK MESSAGE OPTION

$HEADER <NEBULA (Cluster GALAXY message router) options>

;[6007] G.NEBA is the NEBULA ACK/RESPONSE ACK message option
;[6007] 0=disable 1=enable

$HELP<
     The NEBULA ACK/ACK RESPONSE  message  option  ensures  that
NEBULA  actually  has  DECnet  communication  with nodes that it
assumes it does by sending an ACK message  every  5  minutes  to
each  node  it  believes  it  has  communication with.  If a ACK
RESPONSE message is not received from a node  after  5  minutes,
then  NEBULA  assumes  that  it no longer has communication with
that node.
>
$COMMENT<
     This covers the case where the  NI  of  a  remote  node  is
reloaded.   In this case, the local NEBULA is not interrupted so
it assumes that it still has communication with the remote  node
when in fact it does not.
>


	$PROMPT<Do you want NEBULA ACK/RESPONSE ACK messages enabled?>

	$YESNO (NO)			;[6007]Default is NO
	SETZM S1			;[6007]ASSUME NO
	SKIPF				;[6007]If no,
        AOS S1				;[6007]1=enable
	$CNFSTR<@	XP	G.NEBA,^D/S1/>
	

SUBTTL	Miscellaneous Parameters

MISC:	$HEADER <Miscellaneous Defaults and Parameters>

	$COMMENT <
The  questions  in   this  section  refer   to  general   GALAXY
parameters.>
	$HELP <
The following section establishes default bias and disk page  to
spooler unit conversion factors.>

	$PROMPT	<Do you want the standard limit computation>
	$YESNO	(YES)

	JUMPF	MISC.1

TOPS10 <
	$CNFSTR	<@	XP	G.LPTM,6>
	$CNFSTR <@	XP	G.LPTD,8>
	$CNFSTR <@	XP	G.CDPM,33>
	$CNFSTR	<@	XP	G.CDPD,4>
	$CNFSTR	<@	XP	G.PLTM,7>
	$CNFSTR	<@	XP	G.PLTD,100>
	$CNFSTR	<@	XP	G.PTPM,7>
	$CNFSTR	<@	XP	G.PTPD,4>
> ;End of TOPS10

TOPS20 <
	$CNFSTR	<@	XP	G.LPTM,15>
	$CNFSTR <@	XP	G.LPTD,5>
	$CNFSTR <@	XP	G.CDPM,33>
	$CNFSTR	<@	XP	G.CDPD,1>
	$CNFSTR	<@	XP	G.PLTM,7>
	$CNFSTR	<@	XP	G.PLTD,25>
	$CNFSTR	<@	XP	G.PTPM,28>
	$CNFSTR	<@	XP	G.PTPD,1>
> ;End of TOPS20
	JRST	MISC.2

MISC.1:
TOPS10	<
	$HELP <
The default output limit of a spooled file is calculated as:

    limit = disk blocks * units per disk block * copies

The output limit is  expressed in pages  for the printer,  cards
for the card punch,  minutes for the plotter,  and feet for  the
paper tape punch.  The following questions establish the  number
of units of output per disk page.> >

TOPS20	<
	$HELP <
The default output limit of a spooled file is calculated as:

    limit = disk pages * units per disk page * copies

The output limit is  expressed in pages  for the printer,  cards
for the card punch,  minutes for the plotter,  and feet for  the
paper tape punch.  The following questions establish the  number
of units of output per disk page:> >

TOPS10<	$PROMPT <Number of printed pages per disk block >
	$DEFAULT (.7) >
TOPS20<	$PROMPT	<Number of printed pages per disk page >
	$DEFAULT (5)  >
	$NUMBRS
	$CNFSTR	<@	XP	G.LPTM,^D/S1/>
	$CNFSTR	<@	XP	G.LPTD,^D/S2/>

TOPS10<	$PROMPT	<Number of punched cards per disk block >
	$DEFAULT (8) >
TOPS20<	$PROMPT <Number of punched cards per disk page >
	$DEFAULT (33) >
	$NUMBRS
	$CNFSTR	<@	XP	G.CDPM,^D/S1/>
	$CNFSTR	<@	XP	G.CDPD,^D/S2/>

TOPS10<	$PROMPT	<Minutes of plotter output per disk block >
	$DEFAULT (0.07) >
TOPS20<	$PROMPT	<Minutes of plotter output per disk page >
	$DEFAULT (0.28) >
	$NUMBRS
	$CNFSTR	<@	XP	G.PLTM,^D/S1/>
	$CNFSTR	<@	XP	G.PLTD,^D/S2/>

TOPS10<	$PROMPT	<Feet of paper tape per disk block >
	$DEFAULT (7) >
TOPS20<	$PROMPT	<Feet of paper tape per disk page >
	$DEFAULT (28) >
	$NUMBRS
	$CNFSTR	<@	XP	G.PTPM,^D/S1/>
	$CNFSTR	<@	XP	G.PTPD,^D/S2/>

MISC.2:
	$HELP <
The default action to be taken when output exceeds the specified
limit for an output spooler may  be to ABORT the job and  ignore
all remaining output, ASK the operator what to do, or PROCEED to
finish processing the job.>

	$PROMPT	<Default output-limit-exceeded action>
	$CHOICES <ABORT,ASK,PROCEED>
	$DEFAULT <ASK>
	$KEYWORD
	AOS	S1			;GET PROPER VALUE

	$CNFSTR	<@	XP	G.FLEA,^D/S1/>



GALEND:	$CNFSTR	<@	XP	FTDN60,-1	;Always include DN60 support>
	$CNFSTR	<@	XP	FTFTS,0		;No FTS support>
TOPS10 <
	$CNFSTR	<@	XP	FTRJE,0		;No DN200 support>
	$CNFSTR	<@	XP	FTFACT,-1	;FACT file support on>
> ;End TOPS10

TOPS20 <
	$CNFSTR	<@	XP	FTRJE,-1	;Always include DN200>
	$CNFSTR	<@	XP	FTFACT,0	;FACT file support off>
> ;End TOPS20

	$CNFSTR <@@	END>
	$TTYSTR <@@[End of GALGEN Dialog]>

	MOVE	S1,CNFIFN
	$CALL	F%REL
	JRST	I%EXIT
SUBTTL	Terminal Input Processors

GETANS:	CAIN	S1,.CMFLD		;ARE WE PARSING A FINLD?
	SKIPE	CMDDEF			; WITH NO DEFAULT?
	JRST	GETAN			;NO..PROCEED NORMALLY
	MOVX	S1,FLD(.CMFLD,CM%FNC)+CM%SDH
	MOVEM	S1,CMDFN2			;STORE AS ALTERNATE
	MOVE	S1,[CM%SDH+CMDFN2]
	IORM	S1,CMDFNC		;SET THE ALTERNATE
	MOVEI	S1,.CMCFM		;MAKE CONFIRM PRIMARY
GETAN:	STORE	S1,CMDFNC,CM%FNC	;STORE FUNCTION CODE
	STORE	S2,CMDDAT		;AND SPECIFIC DATA
	MOVEI	S1,GET.1
	HRRM	S1,CMDFLG		;STORE REPARSE ADDRESS
	DMOVE	S1,[EXP CMDBLK,[<.CMINI>B8]]
	$CALL	S%CMND		;INIT COMMAND AND DISPLAY PROMPT
	SKIPT
	$STOP	(CIF,Command Initialization Failed)
GET.1:	DMOVE	S1,[EXP CMDBLK,FNCBLK]	;GET RESPONSE
	SETZM	ATOM
	$CALL	S%CMND		;FROM COMND
	JUMPF	.RETF			;DIE IF COMND DID
	LDB	S1,[POINT 7,ATOM,6]		;CHECK FIRST BYTE
	JUMPE	S1,.RETF			;DIE IF NULL
	DMOVE	S1,CR.FLG(S2)		;GET COMMAND FLAGS RETURNED
	TXNE	S1,CM%NOP		;CHECK NO PARSE
	  $RETF				;BAD RETURN
	TXNE	S1,CM%EOC		;CHECK END OF LINE
	$RETT				;GOOD..RETURN NOW
	$SAVE	<S1,S2>			;SAVE FOR RETURN
	DMOVE	S1,[EXP CMDBLK,[<.CMCFM>B8]]	;CONFIRM COMMMAND
	$CALL	S%CMND
	JUMPF	.RETF			;DIE IF FALSE
	MOVE	S1,0(S2)		;GET FLAGS
	TXNE	S1,CM%EOC
	$RETT
	$TTYSTR <@? Answer Not Confirmed with Carriage Return>
	$RETF

;WRTANS is called to write the prompt and answer to the configuration
;file as a comment.  It should be called after a field is parsed
;succesfully

WRTANS:	SKIPN	NOMSG				;WRITING MESSAGES?
	$CNFSTR	<@;^T/PRMTXT/^T/BUFFER/>	;YES..DO IT
	$RETT
SUBTTL	KEYWORD - Parse a keyword response

;KEYWORD is called to match a user response to a keyword table.
KEYWORD:MOVEI	S1,.CMKEY		;SET KEYWORD FUNCTION
	MOVEI	S2,KEYTAB		;FROM KEYTAB (SORTED via CHOICE)
	$CALL	GETANS
	JUMPF	KEYW.1			;HELP AND RETRY
	HRRZ	S1,(S2)			;CALLING INDEX TO S1
	HLRZ	S2,(S2)			;ADDRESS OF STRING TO S2
	PJRST	WRTANS			;WRITE TO FILE AND RETURN

KEYW.1:	$TTYSTR <? Invalid Keyword, Please try again.@>
	JRST	KEYWORD

;FIELD is called to parse a one-word user response

FIELD:	MOVEI	S1,.CMFLD		;SET FIELD FUNCTION
	SETZ	S2,			;NO ARGS
	$CALL	GETANS
	MOVE	S2,[POINT 7,ATOM]	;COUNT CHARACTERS
	MOVEM	S2,TXTPTR		;SAVE POINTER
	SETZ	S1,			;CLEAR TALLY
	JUMPF	FLD.4			;Complain and retry

FLD.1:	ILDB	S2,TXTPTR		;GET BYTE
	JUMPE	S2,FLD.2		;EXIT ON NULL
	AOJA	S1,FLD.1		;TALLY COUNT

FLD.2:	CAML	S1,MIN			;FAIL IF TOO SMALL
	CAMLE	S1,MAX			;OR IF TOO BIG
	JRST	FLD.3			;OUT OF RANGE

	PJRST	WRTANS			;WRITE TO FILE AND RETURN

FLD.3:	$TTYSTR <? Field Length Incorrect, Please try again.@>
	JRST	FIELD

FLD.4:	$TTYSTR <? Field incorrect, Please try again.@>
	JRST	FIELD

YESNO:	$TEXT(DEPTXT,<(YES,NO) ^A>)	;List the choices
	HRRZ	S2,@0(P)		;Get the default keyword
	SKIPE	S1,2(S2)		;Get the default word
	$DEFAULT (^T/2(S2)/)		;Set the default if present
YESNO2:	MOVEI	S1,.CMKEY		;Set the keyword function
	MOVEI	S2,YONTAB		;And the list of keywords
	$CALL	GETANS			;Get the answer
	JUMPF	YESNO1			;Help and retry
	HRRZ	S1,(S2)			;Calling index to S1
	HLRZ	S2,(S2)			;Address of string to S2
	PUSHJ	P,WRTANS		;Log the answer
	HRRZ	S2,@0(P)		;Get the address of the arguments	
	HRL	S2,S1			;S2/ ARGADR(S1)
	SKIPN	S2,@S2			;LOAD AND TEST ARG
	 PJRST @[.RETT
		 .RETF](S1)		;RETURN IF NULL
	POP	P,S1			;ELSE CLEAN UP STACK
	PJRST	@S2			;AND DISPATCH
YESNO1:	$TTYSTR	<? Please answer YES or NO@>
	JRST	YESNO2			;Try again
YONTAB:	2,,2				;Size of the table
	[ASCIZ \NO\],,1
	[ASCIZ \YES\],,0
SUBTTL	NEWKEY	Support routine for $NEWKEY macro

NEWKEY:	MOVEI	S1,.CMFLD		;FUNCTION FIELD
	SETZ	S2,			;NO ARGS
	$CALL	GETANS		;GET THE ANSWER
	JUMPF	.RETF			;END OF THE LINE
	HLRZ	S2,KEYTAB		;GET THE COUNT
	IMULI	S2,KTE$LN		;Compute offset to strbuf
	ADD	S2,[POINT 7,STRBUF+1]	;Point to it
	MOVEM	S2,TXTPTR		;STORE THE POINTER
	SETZM	TXTCNT			;CLEAR THE COUNT
	$TEXT	(DEPTXT,<^T/ATOM/^0>)	;MOVE THE STRING
	MOVE	S1,TXTCNT		;GET THE COUNT
	CAML	S1,MIN			;CHECK LENGTH
	CAMLE	S1,MAX			; OF STRING
	 JRST	[$TTYSTR <@? Keyword size out of range>
		 JRST	NEWKEY]		;TRY AGAIN
	MOVEI	S1,KEYTAB		;POINT TO TABLE
	HRL	S2,S2			;GET ADDR,,ADDR
	ADDI	S2,STR$LN		;COMPUTE OFFSET TO SECOND ENTRY
	$CALL	S%TBAD		;ADD THE ENTRY TO TABLE
	JUMPT	WRTANS			;LOG IN FILE AND RETURN
	CAIN	S1,EREIT$		;ENTRY ALREADY EXIST?
	$TTYSTR	<@? ^T/ATOM/ already specicified>
	CAIE	S1,ERTBF$		;IS TABLE FULL?
	JRST	NEWKEY			;NO -- TRY AGAIN
	$TTYSTR	<@? Keyword table is full>
	$RETF
SUBTTL	NUMBER - SUPPORT ROUTINE FOR $NUMBER

;NUMBER is called to parse type-in of a decimal number.
;
;T Return:	S1/ Number

NUMBER:	MOVEI	S1,.CMNUM		;REQUEST NUMBER
	MOVEI	S2,^D10			;IN DECIMAL RADIX
	$CALL	GETANS		;GET THE TYPE-IN
	JUMPF	NUM.1			;HELP AND RETRY
	MOVE	S1,S2			;NUMBER IN S1
	CAML	S1,MIN			;CHECK RANGE
	CAMLE	S1,MAX
	JRST	NUM.2			;OUT OF RANGE
	PJRST	WRTANS			;WRITE TO FILE AND RETURN

NUM.1:	$TTYSTR <? You Must Specify a number@>
	JRST	NUMBER

NUM.2:	$TTYSTR <? Number not within specified Range@>
	JRST	NUMBER
SUBTTL	NUMBRS	Support routine for $NUMBRS MACRO

NUMBRS:	MOVEI	S1,.CMTXT	;TEXT FUNCTION
	MOVEI	S2,NUMBRK	;BREAK SET
	$CALL	GETANS		;PARSE THE STRING
	$CALL	NUMBDV		;GET THE VALUE
	JUMPT	WRTANS			;WRITE IN FILE AND RETURN
	$TTYSTR	<@? Invalid numeric string@>
	JRST	NUMBRS			;GET THE STRING

NUMBDV:	MOVEI	S1,0			;INITIALIZE RESULT
	MOVEI	S2,1			;INITIALIZE SCALE
	SETZ	T3,			;CLEAR FLAG FOR PERIOD SEEN
	MOVE	T1,[POINT 7,ATOM]	;POINT TO BUFFER
NUMV.1:	ILDB	T2,T1			;GET A BYTE
	JUMPE	T2,.RETT		;TERMINATE ON NULL
	CAIL	T2,"0"
	CAILE	T2,"9"			;NUMERIC
	 JRST	[CAIN T2,"."		;NO -- THEN MUST BE PERIOD
		 SKIPE T3		; AND THE ONLY ONE
		  $RETF			;OOPS -- BAD SYNTAX
		 SETO T3,		;SET FLAG -- PERIOD SEEN
		 JRST NUMV.1]		;GET NEXT CHARACTER
	IMULI	S1,^D10			;ADJUST INTEGER RESULT
	ADDI	S1,-"0"(T2)		;ADD THIS DIGIT
	JUMPE	T3,NUMV.1		;WAS PERIOD SEEN?
	IMULI	S2,^D10			;YES -- ADJUST PER DECIMAL POINT
	JRST	NUMV.1			;GET NEXT DIGIT

NUMBRK:	777777,,777760		;BREAK ON ALL CONTROL
	777764,,001760		;ALLOW 0-9 AND ,
	777777,,777760		;BREAK ON ALL ALPHA
	777777,,777760		;BREAK ON ALL ALPHA
SUBTTL	CHOICE	Support Routine for $CHOICE MACRO


REJECT:	HRRZ	S1,@0(P)		;POINT TO ARGUMENTS
	MOVE	S2,(S1)			;S2/ ARG CNT,,STRING ADR
	PJRST	CHO.1			;FALL INTO COMMON CHOICE ROUTINE

CHOICE:	HRRZ	S1,@0(P)		;POINT TO ARGUMENTS
	MOVE	S2,(S1)			;S2/ ARG CNT,,STRING ADR
	$TEXT	(DEPTXT,<(^T/(S2)/) ^A>) ;MOVE STRING TO PRMTXT BUFFER
CHO.1:	HLLZ	S2,S2			;GET A NULL IN S2
	MOVE	T1,TXTPTR		;STORE NULL, BUT DON'T
	IDPB	S2,T1			;CHANGE POINTER

;add each entry to table

;	S1/	Dummy table address
;	S2/	Arg count,,0

	MOVN	T1,S2			;NEGITIVE COUNT,,0
	HRRI	T1,1(S1)		;ADDRESS OF FIRST ENTRY
	HRRZS	KEYTAB			;CLEAR TABLE COUNTS

TBA.1:	MOVEI	S1,KEYTAB		;POINT TO TABLE
	MOVE	S2,(T1)			;GET ENTRY
	$CALL	S%TBAD		;ADD IT TO TABLE
	AOBJN	T1,TBA.1		;DO ALL ENTRIES
	$RETT
SUBTTL	HELP AND COMMENT SUPPORT ROUTINES

HELP:	MOVE	S1,[POINT 7,HLPTXT]
	MOVEM	S1,TXTPTR		;POINT DEPTXT TO HELP BUFFER
	HRRZ	T1,@0(P)		;GET ADDRESS OF STRING
	$TEXT	(DEPTXT,^T/@T1/^0)	;STORE HELP MESSAGE
	SKIPE	DIALEN			;WRITE IN FILE IF LONG DIALOG
	$CALL	COM.1			;WRITE AS A COMMENT IN FILE
	MOVX	S1,CM%HPP!CM%SDH	;HELP PRESENT AND NO DEFAULT HELP
	IORM	S1,CMDFNC		;IN FUNCTION BLOCK
	MOVE	S1,[POINT 7,HLPTXT]	;STORE POINTER TO HELP
	MOVEM	S1,CMDHLP		;FOR COMND
	$RETT

;COMMENT Routine to Output Comment to File

COMMENT:SKIPN	DIALEN			;RETURN IF SHORT DIALOG
	$RETT
	HRRZ	T1,@0(P)		;GET ADDRESS OF STRING

;CALLED HERE FROM HELP AND PROMPT WITH ADDR IN T1

COM.1:	SKIPE	DIALEN			;DISPLAY IF LONG MODE
	$TEXT	(TTYCHR,^T/@T1/@)
	HRLI	T1,440700		;CREATE POINTER
	$CALL	CNFCRL		;PREFIX WITH <CRLF>
COM.2:	MOVEI	S1,";"			;PREFIX WITH "; "
	$CALL	CNFCHR
	MOVEI	S1," "
	$CALL	CNFCHR
COM.3:	ILDB	S1,T1			;GET BYTE
	  JUMPE	S1,COM.4		;EXIT ON NULL BYTE
	$CALL	CNFCHR
	CAIE	S2,12			;LAST CHARACTER <LF>?
	JRST	COM.3			;NO -- GET NEXT BYTE
	JRST	COM.2			;ELSE FORCE NEW PREFIX
COM.4:	PJRST	CNFCRL			;SUFFIX WITH <CRLF> AND RETURN

HEADER:	HRRZ	S1,@0(P)		;GET ADDRESS OF STRING
	$TEXT	(CNFCHR,<^LSUBTTL	^T/@S1/@>) ;NEW PAGE AND SUBTTL
	MOVE	S2,[POINT 7,BUFFER]
	MOVEM	S2,TXTPTR
	$TTYSTR <@@>			;SPACE TWO LINES ON TERMINAL
	$TEXT	(DEPTXT,<^T52C/@S1/>)	;JUSTIFY HEADER
HEAD.1:	ILDB	S1,S2			;UNDERSCORE ALL EXCEPT "SPACE<CRLF>
	CAILE	S1," "			;SPACE OR CONTROL?
	MOVEI	S1,"-"
	IDPB	S1,TXTPTR		;ELSE WRITE CHARACTER
	CAIE	S1,12			;TERMINATE ON <LF>
	JRST	HEAD.1
HEAD.2:	SETZ	S1,
	IDPB	S1,TXTPTR
	MOVEI	T1,BUFFER		;POINT TO BUFFER
	SOS	DIALEN			;FORCE OUTPUT TO TERMINAL
	$CALL	COM.1			;AND WRITE AS COMMENT
	AOS	DIALEN			;RESTORE DIALOG LENGTH
	$RETT
SUBTTL	$TEXT OUTPUT ROUTINES

IFN FTUUOS,<DEFINE PBOUT <OUTCHR S1>>

BTHCHR:	$SAVE	<P1>			;PRESERVE P1
	MOVE	P1,S1			;SAVE ARG
	$CALL	CNFCHR		;WRITE IN FILE
	MOVE	S1,P1			;RESTORE ARG
	PJRST	TTYCHR			;WRITE ON TERMINAL AND RETURN

CNFCRL:	MOVEI	S1,15			;WRITE <CRLF> IN FILE
	$CALL	CNFCHR
	MOVEI	S1,12
	PJRST	CNFCHR			;AND RETURN

CNFCHR:	CAIN	S1,"@"			;REQUEST FOR <CRLF> ?
	PJRST	CNFCRL			;YES -- DO IT
	MOVE	S2,S1			;PUT CHARACTER IN S2
	MOVE	S1,CNFIFN		;PUT IFN IN S1
	$CALL	F%OBYT		;WRITE THE CHARACTER
	JUMPT	.RETT			;AND RETURN IF SUCCESS
	$TTYSTR <? Error Writing File -- ^E/[-1]/>
	PJRST	I%EXIT			;AND DIE

TTYCRL:	MOVEI	S1,15			;WRITE <CRLF> ON TERMINAL
	PBOUT
	MOVEI	S1,12
	PBOUT
	$RETT

TTYCHR:	CAIN	S1,"@"			;REQUEST FOR <CRLF> ?
	PJRST	TTYCRL			;YES -- DO IT
	PBOUT
	$RETT

SUBTTL	PROMPT Support Routine for $PROMPT Macro

PROMPT:	HRRZ	S1,@0(P)		;GET ADDRESS OF STRING
	MOVE	S2,[POINT 7,PRMTXT]
	MOVEM	S2,TXTPTR		;POINT DEPTXT AT PRMTXT BUFFER
	$TEXT	(DEPTXT,^I/@S1/^A)	;STORE PROMPT STRING IN PRMTXT
	SETZ	S1,
	MOVE	S2,TXTPTR		;STORE TRAILING NULL
	IDPB	S1,S2			;BUT DON'T CHANGE POINTER
	MOVX	S1,CM%DPP+CM%LST		;CLEAR DEFAULT AND LST
	ANDCAM	S1,CMDFNC		;CLEAR DEFALUT PRESENT FLAG
	SETZM	CMDDEF			;CLEAR DEFAULT POINTER WORD
	SETZM	MIN			;CLEAR RANGE CHECK WORDS
	SETZM	MAX
	$RETT

DEFAULT:HRRZ	S1,@0(P)		;GET ADDR OF DEFAULT ITEXT
	$TEXT	(<-1,,DEFTXT>,^I/@S1/^0);STORE AS DEFAULT STRING
	$TEXT	(DEPTXT,<[^I/@S1/] ^0>)	;MOVE TO PRMTXT BUFFER
	MOVE	S1,[POINT 7,DEFTXT]	;GET POINTER TO DEFAULT STRING
	MOVEM	S1,CMDDEF		;STORE AS DEFAULT POINTER
	MOVX	S1,CM%DPP
	IORM	S1,CMDFNC		;SET DEFAULT PRESENT FLAG
	$RETT

RANGE:	HRRZ	S1,@0(P)		;GET ADDR OF ARGS
	MOVE	S2,0(S1)		;GET MINIMUM
	MOVEM	S2,MIN
	MOVE	S2,1(S1)		;GET MAXIMUM
	MOVEM	S2,MAX
	CAME	S2,MIN			;(MIN-MAX Suffix) ?
	$TEXT	(DEPTXT,<(^D/MIN/-^D/MAX/^T/2(S1)/) ^A>) ;MOVE TO PRMTXT
	CAMN	S2,MIN			;(Count Suffix) ?
	$TEXT	(DEPTXT,<(^D/MIN/^T/2(S1)/) ^A>)
	SETZ	S1,			;STORE NULL BUT DON'T CHANGE
	MOVE	S2,TXTPTR		;POINTER
	IDPB	S1,S2
	$RETT

DEPTXT:	CAIN	S1,"@"			;REQUEST FOR CRLF?
	JRST	DEPCRL			;YES -- STORE IT
	IDPB	S1,TXTPTR		;ELSE JUST STORE CHARACTER
	SKIPE	S1			;NULL?
	AOS	TXTCNT			;NO -- ACCOUNT FOR CHARACTER
	$RETT

DEPCRL:	MOVEI	S1,15
	IDPB	S1,TXTPTR
	AOS	TXTCNT
	MOVEI	S1,12
	IDPB	S1,TXTPTR
	AOS	TXTCNT
	$RETT
	END	GALGEN
