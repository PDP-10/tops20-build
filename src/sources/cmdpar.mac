UNIVER	CMDPAR  --  Parameter File To Use CMDPAR
SUBTTL	/PJT/MLB/DC/PJT/SSC FEB-81


;
;
;	COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION 1981, 1986.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED  AND
;	COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH
;	THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE  OR
;	ANY  OTHER  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE
;	AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE
;	SOFTWARE IS HEREBY TRANSFERRED.
;
;	THE INFORMATION IN THIS SOFTWARE IS  SUBJECT  TO  CHANGE  WITHOUT
;	NOTICE  AND  SHOULD  NOT  BE CONSTRUED AS A COMMITMENT BY DIGITAL
;	EQUIPMENT CORPORATION.
;
;	DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF
;	ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;

	SALL				;SUPRESS MACRO EXPANSIONS

EXTERN	.NEXT,.TAKE			;DEFINED IN CPATOP ITSELF

SUBTTL	FUNCTION CODES

;Note: The following function code symbols must agree with analogous
;definitions found in MONSYM.

	.CMKEY==0			;KEYWORD
	.CMNUM==1			;NUMBER
	.CMNOI==2			;NOISE WORD
	.CMSWI==3			;SWITCH
	.CMIFI==4			;INPUT FILE
	.CMOFI==5			;OUTPUT FILE
	.CMFIL==6			;GENERAL FILESPEC
	.CMFLD==7			;ARBITRARY FIELD
	.CMCFM==10			;CONFIRM
	.CMDIR==11			;DIRECTORY NAME (PPN)
	.CMUSR==12			;USER NAME (PPN)
	.CMCMA==13			;COMMA
	.CMINI==14			;INITIALIZE COMMAND
	.CMFLT==15			;BUT NOT SUPPORTED ON 10
	.CMDEV==16			;DEVICE NAME
	.CMTXT==17			;TEXT
	.CMTAD==20			;BUT NOT SUPP ON 10
	.CMQST==21			;QUOTED STRING
	.CMUQS==22			;UNQUOTED STRING
	.CMTOK==23			;TOKEN
	.CMNUX==24			;NUMBER DELIMITED BY NON-DIGIT
	.CMACT==25			;ACCOUNT
	.CMNOD==26			;NODE

; MASK WORDS FOR .CMFLD -- DIGITS, ALPHS (U & L), AND DASH
;
	FLDB0.==777777,,777760
	FLDB1.==777754,,1760
	FLDB2.==400000,,760
	FLDB3.==400000,,760


;FLAGS

CM%ESC==:1B0				;ESC SEEN
CM%NOP=1B1				;NO PARSE
CM%EOC=1B2				;END OF COMMAND SEEN
CM%RPT=1B3				;REPEAT PARSE NEEDED
CM%SWT=1B4				;SWITCH TERMINATED WITH ":"
CM%PFE=1B5				;PREVIOUS FIELD ENDED WITH ESC
CM%RAI=1B6				;RAISE INPUT
CM%XIF=1B7				;NO INDIRECT FILES
CM%WKF=1B8				;WAKEUP AFTER EACH FIELD
;REMOVE CM%NJF 9/21/79 MLB
CM%BRK==:1B13				;INDICATES .CMBRK HAS DATA
CM%PO=1B14				;PARSE ONLY FLAG
CM%HPP=1B15				;HELP PTR PRESENT
CM%DPP=1B16				;DEFAULT PTR PRESENT
CM%SDH=1B17				;SUPPRESS DEFAULT HELP MESSAGE

;FLAGS FOR CMSWI FUNCTION

CM%VRQ=1B0				;VALUE REQUIRED


;FLAGS FOR TIME AND DATE

CM%IDA==1B0				;INPUT DATE
CM%ITM==1B1				;INPUT TIME
CM%NCI==1B2				;NO CONVERT TO INTERNAL

;FLAGS IN KEYWORD TABLE (FIRST WORD OF STRING IF B0-6 = 0)

CM%INV=1B35				;INVISIBLE
CM%NOR=1B34				;NO-RECOGNIZE (PLACE HOLDER)
CM%ABR=1B33				;ABBREVIATION
CM%FW=1B7				;FLAG WORD (ALWAYS SET)


; STRING COMPARE (S%SCMP) FLAGS

	SC%LSS==1B0			;TEST STRING LESS THAN BASE STRING
	SC%SUB==1B1			;TEST STRING SUBSET OF BASE STRING
	SC%GTR==1B2			;TEST STRING GREATER THAN BASE STRING
					;(IF NONE, EXACT MATCH IS RESULT)

; TABLE LOOK UP (S%TBLK) FLAGS

	TL%NOM==1B0			;NO MATCH
	TL%AMB==1B1			;AMBIGUOUS
	TL%ABR==1B2			;UNIQUE ABBREVIATION
	TL%EXM==1B3			;EXACT MATCH

CM%INT==1B9				;INTERRUPT RET. (10 AND 20..CMDPAR DEFINED)

; COMMAND REPLY
;THIS BLOCK IS A DESCRIPTION OF THE ELEMENTS AVAILABLE TO THE
;ACTION,PREFILL, AND ERROR ROUTINES WHEN CALLED

;CALL	S1/	LENGTH OF THE BLOCK
;	S2/	ADDRESS OF THE BLOCK

	CR.FLG==0			;CSB FLAGS,, CSB ADDR
	CR.RES==1			; ???
	CR.PDB==2			;GIVEN PDB,,USED PDB
	CR.COD==3			;CODE TYPE OF CURRENT PDB
	CR.SAV==4			;TOKEN ENTRY FOR CURR FIELD
	  CR.SIZ==CR.SAV+1		;SIZE OF COMMAND REPLY BLOCK

;COMMAND ERROR BUFFER SIZE
	ERRBSZ==20			;SETUP 20 WORDS FOR NOW
	SUBTTL COMMAND FUNCTION MACROS

; THE FOLLOWING FUNCTION SPECIFIC MACROS ARE PROVIDED FOR THE PURPOSE OF
;DEFINING THE PDB COMMAND TREE. THE MACROS AND THEIR SYNTAX IS SHOWN BELOW:

; Where upper case identifies keywords which must be coded as shown
;and lower case identifies variable information which must be provided
;by the programmer, e.g., a symbol which represents the address of a
;block.

; The variable parameters are as follows:

; "next__pdb_address" is addr of next parser data block to use in parse
; "table__address" is the address of keyword table in TBLUK format
; "radix" is the radix in which the number will be input, in octal
; "help__text" is a string to be output on a ?
; "noise__text" is string representing the noise phrase

; "keyword__list" is an optional list of keywords which further control parsing.
; The general form of a keyword parameter is:
;
; 	KEYWORD (argument)
;
; the entire list of keywords must be enclosed by angle brackets "<", ">"
; and the keyword elements are separated blanks or a comma.
; The valid keywords are:
;
;	$ACTION (special__action__routine)
;	AC$NOI (pdb of common $NOISE)
;	AC$R0/AC$R1 (upper-limit of $NUMBER)
;
;	$ALTERNATE (alternate__pdb)
;
;	$DEFAULT (default__string)
;
;	$ERROR (error__routine)
;
;	$ERRPDB (next_pdb)
;
;	$NEXT (next__pdb__address)
;
;	$PDEFAULT (default__address)
;
;	$PREFILL (default__filling__routine)
;
;	EXAMPLE:	$KEY (NOIPDB,KYTBL1,<$ACTION(CHKIT)>)

; The token parsing macros are as follows:

;;	$ACCOUNT (next__pdb__address,help__text,keyword__list)
;
;;	$COMMA (next__pdb__address,keyword__list)
;
;;	$CTEXT (next__pdb__address,help__text,keyword__list)
;
;;	$CRLF (,keyword__list)
;
;;	$DATE (next__pdb__address,keyword__list)
;
;;	$DEV (next__pdb__address,keyword__list)
;
;;	$DIR (next__pdb__address,keyword__list)
;
;;	$DIGIT (next__pdb__address,radix,help__text,keyword__list)
;
;;	$FILE (next__pdb__address,help__text,keyword__list)
;	$IFILE (next__pdb__address,help__text,keyword__list)
;	$OFILE (next__pdb__address,help__text,keyword__list)
;
;;	$FIELD (next__pdb__address,help__text,keyword__list) (also $FNAME)
;
;;	$FLOAT (next__pdb__address,help__text,keyword__list)
;
;;	$INIT (next__pdb__address,keyword__list) (also $INITC)
;
;;	$KEY (next__pdb__address,table__address,keyword__list)
;
;;	$KEYDSP (table__address,keyword__list)
;
;;	$NUMBER (next__pdb__address,radix,help__text,keyword__list)
;;	$NUMGE
;;	$NUMGT
;
;;	$NODNM (next__pdb__address,help__text,keyword__list)
;
;;	$NOISE (next__pdb__address,noise__text,keyword__list)
;
;;	$QUOTE (next__pdb__address,help__text,keyword__list)
;
;;	$SUB (next-pdb, 1st pdb of subroutine)
;
;;	$SWITCH (next__pdb__address,table__address,keyword__list)
;
;;	$TIME (next__pdb__address,keyword__list)
;
;;	$TAD (next__pdb__address,keyword__list)
;
;;	$TOKEN (next__pdb__address,token__character,keyword__list)
;
;;	$USER (next__pdb__address,keyword__list)
;
;;	$UQSTR (next__pdb__address,BRKSET,help__text,keyword__list)



; THE FOLLOWING SUPPORT MACROS ARE DEFINED TO ALLOW THE USER TO DEFINE THE
;KEYWORD AND SWITCH TABLES USED BY THE KEYWORD AND SWITCH PDB'S:

;
;;	DSPTAB (next__pdb__address,user__code,keyword__entry,[flags])
;
;;	KEYTAB (user__code,keyword__entry)
;
;;	$STAB
;
;;	$ETAB
;

DEFINE $$TYPE (ARG),<DEFINE .$TYP <ARG>
			.%TYPE==1>

DEFINE $FLAGS (ARG),<DEFINE .$FLGS <ARG>
			.%FLGS==1>

DEFINE $PDATA (ARG),<DEFINE .$DATA <ARG>
			.%DATA==1>

DEFINE $HELP (ARG),<
	IFDIF <ARG> <>,<
DEFINE .$HLPM <POINT 7,[ASCIZ\ARG\]>
			.%HLPM==1>>

DEFINE $DEFAULT (ARG),<DEFINE .$DEFM <POINT 7,[ASCIZ\ARG\]>
			.%DEFM==1>

DEFINE $PDEFAULT (ARG),<DEFINE .$DEFM <POINT 7,<ARG>>
			.%DEFM==1>

DEFINE $ALTERNATE (ARG),<DEFINE .$LST <ARG+1>
			.%LST==1>

DEFINE $NEXT (ARG),<DEFINE .$NXT <ARG>
			.%NXT==1>

DEFINE $ERROR (ARG),<DEFINE .$ERTN <ARG>
			.%ERTN==1>

DEFINE $BREAK (ARG),<DEFINE .$BREA <ARG>
			.%BREA==1>

DEFINE $ERRPDB (ARG),<DEFINE .$ERTN <1B0+ARG+1>
			.%ERTN==1>

DEFINE $PREFILL (ARG),<DEFINE .$DEFR <ARG>
			.%DEFR==1>

SUBTTL	USER AND SPECIAL ACTION ROUTINES

DEFINE $ACTION (ARG),<.$RTN==ARG!.$RTN
			.%RTN==1>

; AC$NOI - CAUSES CMDPAR TO PLACE NOISE PDB IDENT BY ARG BETWEEN
;	THE KEY TABLE AND THE PDB'S DESCRIBED AS NEXT OF EACH ENTRY
;
DEFINE AC$NOI (ARG),<$ACTION(AC%NOI!ARG)>

; AC$R0 - VERIFY RANGE IS 0 TO ARG (BLANK IMPLIES INFINITY)
; AC$R1 - VERIFY RANGE IS 1 TO ARG (BLANK IMPLIES INFINITY)
;
;	ARG MAY NOT BE GTR THAN HALF WORD. ALSO IF NO ARG SPECIFIED,
;	REGULAR ACTION ROUTINE MAY STILL BE SPECIFIED
;
DEFINE AC$R0(ARG<AC%AAC>),<$ACTION(AC%R0N!ARG)>
DEFINE AC$R1(ARG<AC%AAC>),<$ACTION(AC%R1N!ARG)>

; AC$SET - SET A PDB LABEL VARIABLE TO THE SPECIFIED PDB
;
DEFINE AC$SET (VAL$)<
	$ACTION<[MOVEI 0,VAL$		;;GET PDB ADDR
		 MOVEM 0,VAR$AD		;;SET THE LABEL VAR
		 SETOM 0		;;INDIC SUCCESSFUL ACTION
		 POPJ P,]>
>

; ACTION FLAGS (LEFT HALF OF ACTION WORD OF PDB)
;
AC%NOI==1B0				;USE COMMON NOISE
AC%R0N==1B1				;RANGE CHK, 0 - N
AC%R1N==1B2				;RANGE CHK, 1 - N
AC%RAN==1B3				;RANGE CHK, M - N
AC%AAC==1B4				;ALLOW REGULAR ACTION

	SUBTTL	INITIALIZE PARSER MACRO MACROS

;INITIALIZE ALL THE INNER MACROS
;

	$$TYPE (0)
	$FLAGS (0)
	$HELP (<>)
	$DEFAULT (0)
	$ALTERNATE (0)
	$NEXT (0)
	$ERROR (0)
	$BREAK (0)
	$PREFILL (0)

DEFINE .$RESET <
	SALL
	XLIST
	DEFINE .$TYP <0>
	.%TYPE==0
	DEFINE .$FLGS <0>
	.%FLGS==0
	DEFINE .$DATA <0>
	.%DATA==0
	DEFINE .$HLPM <>
	.%HLPM==0
	DEFINE .$DEFM <0>
	.%DEFM==0
	DEFINE .$LST <0>
	.%LST==0
	DEFINE .$BREA <0>
	.%BREA==0
	DEFINE .$NXT <0>
	.%NXT==0
	DEFINE .$ERTN <0>
	.%ERTN==0
	.$RTN==0
	.%RTN==0
	DEFINE .$DEFR <0>
	.%DEFR==0>;END OF .$RESET


	SUBTTL	.$BUILD MACRO

;REDEFINE PDB.XX

DEFINE .$BUILD (%FDBL,%PDBL,%PDB,%FLAG) <			;;BUILD A PDB

	%FLAG==<.$TYP>B8!.$FLGS!<.$LST>	;;DEFINE .CMFNP WORD OF FDB

	IFN <.%BREA>,<%FLAG==%FLAG!CM%BRK> ;; IF BREAK SET IS PROVIDED

	IFN <.%HLPM>,<%FLAG==%FLAG!CM%HPP!CM%SDH> ;;IF HELP TEXT, INCLUDE FLAG 
						;;BIT AND SUPPRESS HELP

	IFN <.%DEFM>,<%FLAG==%FLAG!CM%DPP> ;;IF DEFAULT, INCLUDE FLAG BIT

%PDB:	XWD	%PDBL,%FDBL			;; LENGTH OF PDB,LENGTH OF FDB

	EXP %FLAG				;;ASSEMBLE WORD .CMFNP OF FDB

	EXP .$DATA			;;ASSEMBLE WORD .CMDAT OF FDB

IFN <.%HLPM!.%DEFM!.%BREA>,<
		EXP	.$HLPM>		;;ASSEMBLE WORD .CMHLP OF FDB


IFN <.%DEFM!.%BREA>,<
		EXP	.$DEFM>		;;ASSEMBLE WORD .CMDEF OF FDB


IFN <.%BREA>,<	EXP	.$BREA>		;;ASSEMBLE WORD .CMBRK OF FDB

	%FDBL==.-%PDB			;LENGTH OF THE FDB

IFN <.%NXT!.%DEFR!.%RTN!.%ERTN>,< .$NXT >	;;ASSEMBLE WORD PDB.NX OF PDB

IFN <.%DEFR!.%RTN!.%ERTN>,< .$RTN >	;;GENERTAT ACTION ROUTINE

IFN <.%DEFR!.%ERTN>,<	EXP	.$ERTN>	;;GENERATE THE ERROR ROUTINE

IFN <.%DEFR>,<		EXP	.$DEFR>	;;GENERATE DEFAULT FILLING ROUTINE


	%PDBL==.-%PDB			;;LENGTH OF THE WHOLE BLOCK

	IF2<	PURGE %FDBL,%PDBL,%PDB,%FLAG>
	LIST>;END .$BUILD

	SUBTTL	PARSER MACROS FOR EACH FUNCTION

DEFINE $KEYDSP (TABLE,ARGLST) <
	.$RESET
	$$TYPE (.CMKEY)
	$PDATA (TABLE)
	$NEXT (0)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $KEY (NXT,TABLE,ARGLST) <
	.$RESET
	$$TYPE (.CMKEY)
	$PDATA (TABLE)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>



DEFINE $NUMBER (NXT,RADIX,HELP,ARGLST) <
	.$RESET
	$$TYPE (.CMNUM)
	$PDATA (RADIX)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

; $NUMGE - NUMBER MUST BE GE 0
; $NUMGT - NUM MUST BE GTR 0
;
DEFINE $NUMGE(A1,A2,A3,A4) < $NUMBER (A1,A2,<A3>,<A4,AC$R0>) >
DEFINE $NUMGT(A1,A2,A3,A4) < $NUMBER (A1,A2,<A3>,<A4,AC$R1>) >

DEFINE $DIGIT (NXT,RADIX,HELP,ARGLST) <
	.$RESET
	$$TYPE (.CMNUX)
	$PDATA (RADIX)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>


DEFINE $NOISE (NXT,TEXT,ARGLST) <
	.$RESET
	$$TYPE (.CMNOI)
	$PDATA (<POINT 7,[ASCIZ\TEXT\]>)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $SUB (NXT, SUBPDB)<
	EXP SUBPDB			;;ADDR OF PDB TO "CALL"
	EXP NXT				;;PDB TO RETURN TO
	EXP Q'SUBPDB#			;;LOCATION TO STORE RETURN PDB IN
>
SUB.ST==0				;OFFSETS INTO $SUB BLOCK
SUB.RA==1
SUB.RV==2

DEFINE $SWITCH (NXT,TABLE,ARGLST) <
	.$RESET
	$$TYPE (.CMSWI)
	$PDATA (TABLE)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>

DEFINE $SWIDSP (TABLE,ARGLST) <
	.$RESET
	$$TYPE (.CMSWI)
	$PDATA (TABLE)
	$NEXT (0)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $IFILE (NXT,HELP,ARGLST) <
	.$RESET
	$$TYPE (.CMIFI)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $OFILE (NXT,HELP,ARGLST) <
	.$RESET
	$$TYPE (.CMOFI)
	$NEXT (NXT)
	$HELP (<>)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $FILE (NXT,HELP,ARGLST) <
	.$RESET
	$$TYPE (.CMFIL)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $FIELD (NXT,HELP,ARGLST) <
	.$RESET
	$$TYPE (.CMFLD)
	$NEXT (NXT)
	$HELP (<>)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>
SYN $FIELD,$FNAME

DEFINE $CRLF (ARGLST),<
	.$RESET
	$$TYPE (.CMCFM)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $DIR (NXT,ARGLST) <
	.$RESET
	$$TYPE (.CMDIR)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $USER (NXT,ARGLST) <
	.$RESET
	$$TYPE (.CMUSR)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $COMMA (NXT,ARGLST) <
	.$RESET
	$$TYPE (.CMCMA)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>



DEFINE $INIT (NXT,ARGLST) <
	.$RESET
	$NEXT (NXT)
	$$TYPE (.CMINI)
	IRP ARGLST,<ARGLST>
	.$BUILD>
SYN $INIT,$INITC

DEFINE $FLOAT (NXT,HELP,ARGLST) <
	.$RESET
	$$TYPE (.CMFLT)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>


DEFINE $DEV (NXT,ARGLST) <
	.$RESET
	$$TYPE (.CMDEV)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $CTEXT (NXT,HELP,ARGLST) <
	.$RESET
	$$TYPE (.CMTXT)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $DATE (NXT,ARGLST) <
	.$RESET
	$$TYPE (.CMTAD)
	$PDATA (CM%IDA)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $TIME (NXT,ARGLST) <
	.$RESET
	$$TYPE (.CMTAD)
	$PDATA (CM%ITM)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $TAD (NXT,ARGLST) <
	.$RESET
	$$TYPE (.CMTAD)
	$PDATA (<CM%IDA!CM%ITM>)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>


DEFINE $QUOTE (NXT,HELP,ARGLST) <
	.$RESET
	$$TYPE (.CMQST)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $UQSTR (NXT,BRKSET,HELP,ARGLST) <
	.$RESET
	$$TYPE (.CMUQS)
	$HELP (<>)
	$NEXT (NXT)
	$PDATA (BRKSET)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $NODNM (NXT,HELP,ARGLST) <
	.$RESET
	$$TYPE (.CMNOD)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
;	$FLAGS (CM%PO)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $ACCOUNT (NXT,HELP,ARGLST) <
	.$RESET
	$$TYPE (.CMACT)
	$HELP (<>)
	$NEXT (NXT)
IFIDN <HELP> <>,< IRP ARGLST,<ARGLST>
			.$BUILD>
IFDIF <HELP> <>,<
	$HELP (HELP)
	IRP ARGLST,<ARGLST>
	.$BUILD>>

DEFINE $TOKEN (NXT,CHAR,ARGLST) <
	.$RESET
	$$TYPE (.CMTOK)
	$PDATA (<POINT 7,[ASCIZ\CHAR\]>)
	$NEXT (NXT)
	IRP ARGLST,<ARGLST>
	.$BUILD>

DEFINE	$OTOK	(NXT,CHCODE,ARGLST) <
	.$RESET
	$$TYPE	(.CMTOK)
	$PDATA	(<POINT 7,[CHCODE]>)
	$NEXT	(NXT)
	IRP	ARGLST,<ARGLST>
	.$BUILD>

DEFINE	$QTOK	(NXT,CHAR,ARGLST)<
	.$RESET
	$$TYPE	(.CMTOK)
	$PDATA	(<POINT 7,[ASCIZ CHAR]>)
	$NEXT	(NXT)
	IRP	ARGLST,<ARGLST>
	.$BUILD>


SUBTTL KEYWORD TABLE MACROS

;THE TB$ MACROS ARE USED TO BUILD ENTIRE TABLES AT ONCE.
;WHEN THIS CANNOT BE DONE, DSPTAB AND KEYTAB CAN BE USED TO GEN INDIV ENTRIES

;DSPTAB - MACRO TO BUILD A DISPATCH TABLE ENTRY
;	USED IN CONJUNCTION WITH $KEYDSP MACRO

DEFINE DSPTAB (NXT,CODE,KEY,FLAGS),<
	$$ENTAB (KEY,FLAGS,<[XWD CODE,NXT]>)	;;DO KEY/DISP INDEP WORK
>

; $$DENT - GENERATE ENTRY IN DISPATCH TABLE
;	ASSUMES $$LABL & $$CODE GEN PROPER DISPATCH FOR EACH TAB ENTRY.
;	LABEL AND CODE ARE FUNCTION OF ROOT$
;	IF NO EXPLICIT KYWD STRING GIVEN, USE ROOT$
;	SFX IS NORMALLY EITHER NUL OR :
;
DEFINE $$DENT (SFX,ROOT$,NAM$,FL$),<
	IFB <NAM$>,< $$ENTAB (ROOT$'SFX, FL$, $$DVAL(ROOT$)) >
	IFNB <NAM$>,< $$ENTAB (NAM$'SFX, FL$, $$DVAL(ROOT$)) >
>
DEFINE $$DDUM(A$)<
	IFN P$COLON,<$$DENT(:,A$)>		;STRIP PAREN IF ANY
	IFE P$COLON,<$$DENT(,A$)>
>
DEFINE $$DVAL(KEY1)<[XWD $$CODE(KEY1),$$LABL(KEY1)]>

; $$ENTAB - ENTRY IN EITHER TYPE OF TABLE
;	LEFT HALF OF ENTRY FUNCT OF WHETHER FLAGS DEFINED
;	KEY/DISP DIFS IN RH RESOLVED BY CALLER OF $$ENTAB
;
DEFINE $$ENTAB(NAM$,FL$,RH$)<
	IFB <FL$>,<XWD [ASCIZ\NAM$\],RH$>	;;TABLE ENTRY NO FLAGS
	IFNB <FL$>,<
		XWD [EXP CM%FW!FL$	;;FLAG INFO
		     ASCIZ\NAM$\], RH$	;;REGULAR INFO
	>
>

;KEYTAB - MACRO TO BUILD A KEYWORD OR SWITCH TABLE ENTRY
;	USED IN CONJUNCTION WITH $KEY OR $SWITCH MACRO

DEFINE KEYTAB (CODE,KEY,FLAGS),<
	$$ENTAB (KEY,FLAGS,CODE)	;;DO KEY/DISP INDEP WORK
>

; $$KENT - GENERATE ENTRY IN KEY TABLE
;	ASSUMES $$CODE GEN PROPER DISPATCH FOR EACH TAB ENTRY.
;	CODE IS FUNCTION OF ROOT$
;	IF NO EXPLICIT KYWD STRING GIVEN, USE ROOT$
;
DEFINE $$KENT (ROOT$,NAM$,FL$),<
	IFB <NAM$>,< $$ENTAB (ROOT$, FL$, $$KVAL(ROOT$)) >
	IFNB <NAM$>,< $$ENTAB (NAM$, FL$, $$KVAL(ROOT$)) >
>
DEFINE $$KDUM(A$)<$$KENT(A$)>		;STRIP PAREN IF ANY
DEFINE $$KVAL(KEY1)<$$CODE(KEY1)>

;$STAB/$ETAB - MACROS TO DELINEATE START AND END OF KEYWORD TABLE
;	USED IN CONJUNCTION WITH DSPTAB AND KEYTAB MACROS

DEFINE $STAB (%X,%Y) <
	%X==.
	XWD %Y-1,%Y-1
	DEFINE $ETAB <
		%Y==.-%X>>

; TB$DSP - GENERATES DISPATCHING TABLE FOR A SET OF OPTIONS
; ARGUMENTS:
;	TYP$ = PREFIX TO IDENT PARTIC TABLE
;	FLD$ = ALPH LIST OF ENTRIES IN TABLE
; NOTES:
;	IF ENTRY HAS IMBEDDED DASH(ES) EG. A-1 OR A-B-C,
;	REPRESENT AS <A,1> AND <A,B,C>.
;
DEFINE TB$DSP(TYP$,FLD$)<
TYP$'TB:
	$STAB				;;START TABLE
	IRP FLD$,<$$DDUM(FLD$)>		;;EACH TABLE ENTRY
	$ETAB
>

; TB$KEY - GENERATES NON-DISPATCHING TABLE FOR A SET OF OPTIONS
; ARGUMENTS:
;	TYP$ = PREFIX TO IDENT PARTIC TABLE
;	FLD$ = ALPH LIST OF ENTRIES IN TABLE
; NOTES:
;	IF ENTRY HAS IMBEDDED DASH(ES) EG. A-1 OR A-B-C,
;	REPRESENT AS <A,1> AND <A,B,C>.
;
DEFINE TB$KEY(TYP$,FLD$)<
TYP$'TB:
	$STAB				;;START TABLE
	IRP FLD$,<$$KDUM(FLD$)>		;;EACH TABLE ENTRY
	$ETAB
>

	SUBTTL	PRE-DEFINED CODE/LABEL ALGORITHMS FOR BUILDING TABLES

; CM$TAB - DEFINES CMD DISPATCH TABLE
;
DEFINE CM$TAB(FLD$,KDOPT$)<
	DEFINE $$CODE(X$)<%'X$>
	DEFINE $$LABL(X$)<.'X$>		;;DISPATCH BASED ON VERB NAME
	$KEYDSP(CMD.TB,<KDOPT$>)	;;DISPATCH TO KYWD TABLE
	TB$DSP(CMD.,<FLD$>)		;;DO THE REAL WORK
>

; KY$WRD - SINGLE WORD TABLE & PARSE CODE ALWAYS SET TO 0
; KY$TAB - DEFINES OPTION DISPATCH TABLE
;	   PARSE CODE IS NAMED LOCAL TO THE PARTIC TABLE
;
DEFINE KY$TAB(NEXT$,T$,FLD$,KDOPT$)<
	DEFINE $$CODE(X$)<T$'%'X$>
	$KEY	(NEXT$,T$'TB,<KDOPT$>)		;;DISPATCH TO KYWD TABLE
	TB$KEY(T$,<FLD$>)		;;DO THE REAL WORK
>
DEFINE KY$WRD(NEXT$,T$,FLD$,KDOPT$)<
	DEFINE $$CODE(X$)<0>
	$KEY	(NEXT$,T$'TB,<KDOPT$>)		;;DISPATCH TO KYWD TABLE
	TB$KEY(T$,<FLD$>)		;;DO THE REAL WORK
>

; OP$TAB - DEFINES OPTION DISPATCH TABLE
; BOTH DISPATCH LABEL AND PARSE CODE ARE NAMED LOCAL TO THE PARTIC TABLE
;
DEFINE OP$TAB(T$,FLD$,KDOPT$)<
	DEFINE $$CODE(X$)<T$'%'X$>
	DEFINE $$LABL(Y$)<T$''Y$>		;;DISPATCH BASED ON FLD NAME
	$KEYDSP	(T$'TB,<KDOPT$>)		;;DISPATCH TO KYWD TABLE
	TB$DSP(T$,<FLD$>)		;;DO THE REAL WORK
>

; SV$TAB - DEFINES SWIT DISPAT TAB FOR GROUP OF SWITCHES THAT ALL TAKE VALS
; BOTH DISPATCH LABEL AND PARSE CODE ARE NAMED LOCAL TO THE PARTIC TABLE
;
DEFINE SV$TAB(T$,FLD$,KDOPT$)<
	DEFINE $$CODE(X$)<T$'%'X$>
	DEFINE $$LABL(X$)<T$''X$>		;;DISPATCH BASED ON FLD NAME
	P$COLON==1			;;APPEND COLONS
	$SWITCH	(0,T$'TB,<KDOPT$>)		;;DISPATCH TO KYWD TABLE
	TB$DSP(T$,<FLD$>)		;;DO THE REAL WORK
	P$COLON==0
>

; SW$TAB - DEFINES DISPATCH TABLE FOR SWITCHES
;
;	IF A SWITCH TAKES A VALUE, SUFFIX : TO END OF 2ND ELEMENT OF SUB-ARG
;
DEFINE SW$TAB(T$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<T$'%'X$>
	DEFINE $$LABL(X$)<T$''X$>	;;DISPATCH BASED ON FLD NAME
	$SWITCH	(0,T$'TB,<KOPT$>)	;;DISPATCH TO KYWD TABLE
	TB$DSP(T$,<FLD$>)		;;DO THE REAL WORK
>

	SUBTTL	ARGUMENT BLOCK FOR CALLING THE PARSER

	;THIS IS A DESCRIPTION OF THE ARGUMENT BLOCK USED
	;TO CALL THE PARSER ROUTINE (OPRPAR)
	;	S1/	LENGTH OF THE BLOCK
	;	S2/	ADDRESS OF THE BLOCK

	PHASE	0
PAR.TB:! BLOCK	1			;ADDRESS OF THE TABLES
PAR.PM:! BLOCK	1			;ADDRESS OF THE PROMPT STRING
					;DEFAULT TO OPR IF ZERO
PAR.CM:! BLOCK	1			;ADDRESS TO STORE PARSED DATA
					;DEFAULT TO GET PAGE IF ZERO
PAR.SR:! BLOCK	1			;ADDRESS OF THE STRING TO PARSE
					;DEFAULT TTY IF NOT SPECIFIED OR ZERO
					;-1 MEANS DO A RESCAN FOR INCORE
PAR.SZ:!				;SIZE OF THE PARSER CALLING BLOCK
	DEPHASE

	SUBTTL	RETURN BLOCK FROM THE PARSER

	;THIS BLOCK IS A DESCRIPTION OF THE ARGUMENT BLOCK RETURNED
	;BY THE PARSER.
	;	S1/	LENGTH OF THE BLOCK
	;	S2/	ADDRESS OF THE BLOCK

	PHASE	0
PRT.FL:! BLOCK	1			;FLAG WORD FOR RETURN
PRT.CM:! BLOCK	1			;COMMAND MESSAGE ADDRESS
PRT.CF:! BLOCK	1			;COMMAND FLAG WORD
PRT.MS:! BLOCK	1			;POINTER TO TEXT OF MESSAGE ON
PRT.SM:!				;SIZE OF PRT ON TRUE RETURN
					;FALSE RETURN
PRT.EM:! BLOCK	1			;POINTER TO ERROR MESSAGE ON
					;FALSE RETURN
PRT.EC:! BLOCK	1			;ERROR CODE RETURNED
					;FROM ACTION ROUTINE
PRT.SZ:!				;SIZE OF PRT ON FALSE RETURN
	DEPHASE

; FLAGS IN PRT.FL

	P.TAKE==1B0			;TAKE COMMAND PROCESSED
	P.CTAK==1B1			;COMMAND FROM A TAKE COMMAND
	P.ACTE==1B2			;ACTION ROUTINE ERROR
	P.NPRO==1B3			;NO PROCESSING FOR COMMAND
	P.ERRO==1B4			;ERROR FLAG..ERROR OCCURRED
	P.REPA==1B5			;REPARSE REQUIRED
	P.INTE==1B6			;INTERRUPT EXIT FLAG
	P.DSPT==1B7			;DISPLAY THIS TAKE COMMAND
	P.ENDT==1B8			;END OF TAKE FILE
	P.DERR==1B9			;DEFAULT ROUTINE ERROR
	P.CEOF==1B10			;CORE PARSE END OF FILE

	SUBTTL	PARSED FIELD DESCRIPTION

; FORMAT OF AN ENTRY IN THE TOKEN LIST OUTPUT BY PARSE$

	PHASE	0
PFD.HD:! BLOCK	1			;HEADER WORD FOR BLOCK
	PF.TYP==0,,-1			;TYPE IN THE LEFT HALF
	PF.LEN==-1,,0			;LENGTH IN RIGHT HALF
					;INCLUDES THIS WORD
PFD.D1:! BLOCK	1			;FIRST DATA WORD
PFD.D2:! BLOCK	1			;SECOND DATA WORD (IF NECESSARY)
PFD.SZ:! 				;SIZE OF THE BLOCK

	DEPHASE

END
