TITLE	UTLCMD - SYNTAX TABLES FOR RMSUTL
SUBTTL A. UDDIN/RL
;
;	COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION 1980, 1986.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED  AND
;	COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH
;	THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE  OR
;	ANY  OTHER  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE
;	AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE
;	SOFTWARE IS HEREBY TRANSFERRED.
;
;	THE INFORMATION IN THIS SOFTWARE IS  SUBJECT  TO  CHANGE  WITHOUT
;	NOTICE  AND  SHOULD  NOT  BE CONSTRUED AS A COMMITMENT BY DIGITAL
;	EQUIPMENT CORPORATION.
;
;	DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF
;	ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;

;++
; FACILITY:	RMSUTL
;
; ABSTRACT:
;
;	UTLCMD contains the syntax tables for RMSUTL.
;
; ENVIRONMENT:	User mode?
;
; AUTHOR: Anwar Uddin, CREATION DATE: 1980
;
; MODIFIED BY:
;
;	Ron Lusk, 3-Feb-84 : VERSION 2.0
;
; 423	-	Clean up for version 2.0 of RMS.
; 430	-	Add file recognition on OPEN commands, among other changes
; 431	-	Change the CHANGE statement for SEQ/REL files
; 432	-	Change the DEFINE FILE command to allow Seq/Rel files
; 433	-	Add new datatypes
; 434	-	Fix edit 431 to make CHANGE and DISPLAY work
; 455	-	Fix colon (":") on /DISPLAY switch in DEFINE DATA command
;--
SEARCH	RMSMAC,RMSINT

$PROLOG(UTL)
SEARCH	CMDPAR

P$COLON==0				;;INIT DEF OF IT
LSS==74b6				;;BECAUSE OF A MACRO BUG
GTR==76B6
LE==361720,,0
GE==371720,,0

; $AID - DEFINE NUMERIC FLD THAT IS USED TO IDENTIFY AN AREA ID
;
DEFINE $AID(NEXT$,KDOPT$,%NUM)<
	$NOISE	(%NUM,#)		;;INDIC CLASS RATHER THAN SCALAR
%NUM:	$NUMGE	(NEXT$,BASE10,area ID,<KDOPT$>)
>

; AK$TAB - DEFINES KYWD TABLE IN WHICH EACH ENTRY IS AN RMS ARG BLK FIELD
;
DEFINE AK$TAB(NEXT$,TYP$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<E.'X$'##>	;;ADDRESS OF FLD DESCRIPTOR
	$KEY(NEXT$,TYP$'TB,<KOPT$>)	;;KEY TABLE
	TB$KEY(TYP$,<FLD$>)		;;DO THE REAL WORK
>

; AO$TAB - DEFINES DISPATCH TABLE IN WHICH EACH ENTRY IS RMS SYMBOLIC VAL
;
DEFINE AO$TAB(T$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<E.'X$'##>	;;ADDRESS OF FLD DESCRIPTOR
	DEFINE $$LABL(X$)<T$''X$>	;;DISPATCH BASED ON FLD NAME
	$KEYDSP(T$'TB,<KOPT$>)		;;KEY TABLE
	TB$DSP(T$,<FLD$>)		;;DO THE REAL WORK
>

; AS$TAB - DEFINES SWITCH DISPATCH TABLE FOR RMS ARGBLK FIELDS
; DISPATCH LABEL IS LOCAL -- SO VALUE CAN BE PICKED UP
; PARSE CODE IS ADDRESS -- SO APPROP $STORE CAN BE DONE
;
DEFINE AS$TAB(T$,FLD$,KDOPT$)<
	DEFINE $$CODE(X$)<E.'X$'##>	;;ADDRESS OF FLD DESCRIPTOR
	DEFINE $$LABL(X$)<T$''X$>	;;DISPATCH BASED ON FLD NAME
	P$COLON==1			;;APPEND COLONS
	$SWITCH	(0,T$'TB,<KDOPT$>)	;;DISPATCH TO KYWD TABLE
	TB$DSP(T$,<FLD$>)		;;DO THE REAL WORK
	P$COLON==0			;;TURN OFF
>

; AV$TAB - DEFINES TABLE IN WHICH EACH ENTRY IS RMS SYMBOLIC VAL
;
DEFINE AV$TAB(NEXT$,TYP$,P$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<P$'$'X$>	;;SYMBOL IN RMSINT
	$KEY(NEXT$,TYP$'TB,<KOPT$>)	;;KEY TABLE
	TB$KEY(TYP$,<FLD$>)		;;DO THE REAL WORK
>

; $FILEF - ALLOW SYMBOLS THAT INCLUDE . < > : [ ]
;
DEFINE $FILEF (NXT$,HELP$,ARGS$) <$FNAME(NXT$,<HELP$>,<$BREAK(MSKFIL),ARGS$>)>

; $INDEX - DEFINE NUMERIC FLD THAT IS USED TO IDENTIFY AN ELEMENT OF A CLASS
;
DEFINE $INDEX(NEXT$,KDOPT$,%NUM)<
	$NOISE	(%NUM,#)		;;INDIC CLASS RATHER THAN SCALAR
%NUM:	$NUMGT	(NEXT$,BASE10,positive decimal number,<KDOPT$>)
>

; $KREF - DEFINE NUMERIC FLD THAT IS USED TO IDENTIFY A KEY OF REFERENCE
;
DEFINE $KREF(NEXT$,KDOPT$,%NUM)<
	$NOISE	(%NUM,#)		;;INDIC CLASS RATHER THAN SCALAR
%NUM:	$NUMGE	(NEXT$,BASE10,key of reference,<KDOPT$>)
>

; $MACF - ALLOW SYMBOLS THAT INCLUDE . $ - OR %
;
DEFINE $MACF (NXT$,HELP$,ARGS$) <$FNAME(NXT$,<HELP$>,<$BREAK(MSKMAC),ARGS$>)>

SUBTTL	DATA DECLARATIONS

BASE10==^D10				;FOR $NUM--- MACRO
BASE8==8

$IMPURE
$GDATA	(PDBPAG,1000)			;BLOCK FOR PARSED DATA

$DATA	(CHENT)				;ON IF CHANGING ENTRY (AS OPP ID)
$DATA	(QRFADO)			;VAR FOR RET VAL FROM RFADO
$DATA	(QVALDF)			;VAR FOR RET VAL FROM VALDF
$DATA	(VALDF)				;VAR FOR PDB OF CURR FLD'S DATTYP
$DATA	(QRTUSE)			;[431] ADDRESS OF RECORD-TO-USE CLAUSE
$DATA	(QCHCOM)			;[a434] COMMA FOR CHANGE COMMAND
$DATA	(QDSCOM)			;[a434] COMMA FOR DISPLAY COMMAND
CHABTO:	$NOISE	(0,TO)			;FOR AC$NOI IN CHANGE

$PURE

MSKFIL:
	FLDB0.				;WORD-N OF MASK
	FLDB1.&<^-<1B12!1B14!1B26!1B28!1B30>>
					;B12=, B14=. B26=: B28=< B30=>
	FLDB2.&<^-<1B27!1B29>>		;B27=[ B29=]
	FLDB3.
MSKMAC:
	FLDB0.				;WORD-N OF MASK
	FLDB1.&<^-<1B4!1B5!1B13!1B14>>	;B4=$ B5=% B13=- B14=.
	FLDB2.
	FLDB3.

;
;BREAK MASKS FOR FLOATING AND LARGE (AND PACKED) INTEGERS
;
									;A433
	BRINI.			;INITIALIZE BREAK MASK FOR STANDARD FIELD
	BRKCH. (0,37)		;ALL CONTROL CHARACTERS
	BRKCH. (40,54)		;SPACE THROUGH COMMA
	BRKCH. (57)		;SLASH
	BRKCH. (72,77)		;COLON THROUGH QUESTION MARK
	BRKCH. (100,103)	;ATSIGN THRU C
	BRKCH. (110,177)	;H THRU RUBOUT

FLTB0.==W0.			;FLOATING POINT BREAK MASK
FLTB1.==W1.
FLTB2.==W2.
FLTB3.==W3.

FLTBRK:
	EXP FLTB0.,FLTB1.,FLTB2.,FLTB3.


	UNBRK. "."		; DON'T BREAK ON DOT FOR INTEGERS
INTB0.==W0.			;FLOATING POINT BREAK MASK
INTB1.==W1.
INTB2.==W2.
INTB3.==W3.

INTBRK:
	EXP INTB0.,INTB1.,INTB2.,INTB3.

SUBTTL	ACTION ROUTINES

;+
; ACTION ROUTINES ARE EFFECTIVELY PART OF CMDPAR
; CMDPAR CALLS THEM WITH:
;	T1 = LENGTH OF CMD DATA BLK
;	T2 = ITS ADDR
; YOU SHOULD RETURN:
;	TF = -1 IF SUCCESSFUL
;	TF = 0 IF FAILED, WITH T2 = PTR TO ASCIZ ERR MSG
;-

;
; CMDACT first prevents the user from giving commands 
; which require an open file if the RMS file is not 
; open.  It then checks to ensure that the FIX, SPACE,
; UNCLUTTER, and VERIFY commands are not given to 
; sequential or relative files.  Finally, it sets up
; the rest of the command parser based on the file 
; organization (record-to-use clauses, record and 
; prologue fields, etc.).
;

CMDACT:	MOVE	T1,CR.SAV(T2)		;[430] Get token entry
	MOVE	T3,1(T1)		;[431] Get value of token
	CASES	T3,%VERIFY		;[431] What was the command?
$CASE	(%CHANGE)			;[431] CHANGE command
	JRST	COPCHK			;[431] Needs open file
$CASE	(%DELETE)			;[431] DELETE command
	JRST	COPCHK			;[431] Needs an open file
$CASE	(%DISPLAY)			;[431] DISPLAY command
	JRST	COPCHK			;[431] Needs an open file
$CASE	(%FIX)				;[431] FIX command
	JRST	COPCHK			;[431] Needs open indexed file
$CASE	(%SET)				;[431] SET command
	JRST	COPCHK			;[431] Open file required
$CASE	(%SPACE)			;[431] SPACE command
	JRST	COPCHK			;[431] Open indexed file needed
$CASE	(%UNCLUTTER)			;[431] UNCLUTTER command
	JRST	COPCHK			;[431] Open indexed file needed
$CASE	(%VERIFY)			;[431] VERIFY command
	JRST	COPCHK			;[431] Open indexed file needed
$CASF					;[431] Any other command
	JRST	L$CASX			;[431] Needs no file
$CASX					;[431] Return normally
	;
	; Return here if command does not require open file.
	;
	SETOM	TF			;[431]
	POPJ	P,			;[431]



COPCHK:	MOVE	T1,UTLFLG		;[430] Fetch flags
	TXNE	T1,UT%FOP		;[430] Is file open?
	$SKIP				;[430] No
		MOVEI	T2,[ASCIZ/File not open/]
		SETZM	TF
		POPJ	P,
	$ENDIF
	MOVE	T1,FAB			;[431] Check file organization
	$FETCH	T4,ORG,(T1)		;[431] ...
	CAIN	T3,%FIX			;[431] Non-indexed files can't be FIXed
	JRST	CIXCHK			;[431] ...
	CAIN	T3,%UNCLUTTER		;[431] nor UNCLUTTERed
	JRST	CIXCHK			;[431] ...
	CAIN	T3,%SPACE		;[431] nor SPACEd
	JRST	CIXCHK			;[431] ...
	CAIN	T3,%VERIFY		;[431] nor VERIFY-ed
	JRST	CIXCHK			;[431] ...
	SETOM	TF			;[430] Everyone else is fine (for now)
	JRST	CMDSET			;[431] Set up the command parser

CIXCHK:	MOVEI	T2,[ASCIZ/File must be indexed/]
	SETZM	TF			;[430] Assume Sequential/Relative file
	CAIE	T4,FB$IDX		;[431] Indexed organization?
	POPJ	P,			;[431] No - quit
	SETOM	TF			;[430] Yes - return OK
	JRST	CMDSET			;[431] Go setup the command parser

CMDSET:	CASES	T4,FB$IDX		;[431] Adjust parser for organization

$CASE	(FB$SEQ)			;[431] Sequential organization
	MOVEI	T1,RTUSEQ		;[431] Sequential Record-To-Use clause
	MOVEM	T1,QRTUSE		;[431] ...
	MOVEI	T1,CHSCOM		;[a434] Get correct commas
	MOVEM	T1,QCHCOM		;[a434] ...
	MOVEI	T1,DSSDFC		;[a434] ...
	MOVEM	T1,QDSCOM		;[a434] ...
	JRST	L$CASX			;[431] Go to common exit
$CASE	(FB$REL)			;[431] Relative organization
	MOVEI	T1,RTURLT		;[431] Relative Record-To-Use clause
	MOVEM	T1,QRTUSE		;[431] ...
	MOVEI	T1,CHRCOM		;[a434] Get correct commas
	MOVEM	T1,QCHCOM		;[a434] ...
	MOVEI	T1,DSRDFC		;[a434] ...
	MOVEM	T1,QDSCOM		;[a434] ...
	JRST	L$CASX			;[431] Go to common exit
$CASE	(FB$IDX)			;[431] Indexed organization
	MOVEI	T1,RTUIDX		;[431] Indexed Record-To-Use clause
	MOVEM	T1,QRTUSE		;[431] ...
	MOVEI	T1,CHICOM		;[a434] Get correct commas
	MOVEM	T1,QCHCOM		;[a434] ...
	MOVEI	T1,DSIDFC		;[a434] ...
	MOVEM	T1,QDSCOM		;[a434] ...
	JRST	L$CASX			;[431] Go to common exit
$CASF					;[431] Should not get here
	JRST	L$CASX			;[431]   but exit anyway
$CASX					;[431] Whew!
	POPJ	P,			;[431] Return to CMDPAR	



;
; Action routine for "CHANGE BUCKET { ENTRY | ID } ..."
; Based on bucket type and record format, provides a proper
; list of field keywords for parsing.
;
CHENACT:				;ACTION ROUTINE FOR CHANGE BKT ENT
	SETOM	CHENT			;INDIC CHANGE ENT
	JRST	CIEACT			;MERGE
CHIDACT:				;ACTION ROUTINE FOR CHANGE BKT ID
	SETZM	CHENT			;INDIC ID

CIEACT:
;
; SET PDB ON BASIC OF TYPE OF ENTRY BEING CHANGED
;
;[431]	MOVE	T1,UTLFLG		;CHK IF FILE OPEN
;[431]	TXNE	T1,UT%FOP		;IS IT?
;[431]	$SKIP				;NO
;[431]		MOVEI	T2,[ASCIZ/File not open/]
;[431]		SETZM	TF
;[431]		POPJ	P,
;[431]	$ENDIF
	MOVE	T1,CU$TYPE		;GET BKT INFO
	CASES	T1,MX%BTY
$CASE	(BTY%CLOB)
	MOVEI	T2,[ASCIZ/Current bucket has bad header/]
	SETZM	TF			;FAILURE RETURN
	POPJ	P,
$CASE	(BTY%IDX)
	MOVEI	T5,CIESET		;YES
	SKIPGE	CHENT			;ENTRY # SPEC?
	JRST	L$CASX			;YES, NO PROB
	MOVEI	T2,[ASCIZ/Current bucket not a data bucket/]
	SETZM	TF			;FAILURE RETURN
	POPJ	P,
$CASE	(BTY%PRIM)
	MOVE	T2,FAB			;ADDR OF FAB
	MOVEI	T5,CVESET		;ASSUME VAR LENGTH RECORDS
	$FETCH	T1,RFM,(T2)		;CHECK RECORD FORMAT
	CAIE	T1,FB$VAR		;VARIABLE FORMAT?
	MOVEI	T5,CFESET		;FIXED HEADER FORMAT
	JRST	L$CASX
$CASE	(BTY%SEC)
	MOVEI	T5,CSESET		;SECONDARY BKT.
$CASX
	MOVEM	T5,.NEXT		;SET NEXT PDB
	SETOM	TF			;SUCC RET
	POPJ	P,

SETDFV:
;
; ACTION ROUTINE FOR DATAfield VALUE, SET PDB FROM DATA TYPE OF FLD
;
	MOVE	T5,CR.SAV(T2)		;GET ADDRESS OF PARSE DATA
	$CALL	SY.FIND,<0(T5)>		;PASS THE CURR TOK
	JUMPT	L$IFX			;A MATCH?
	  MOVEI	T2,[ASCIZ/Name not known/] ;NO, TELL CALLER
	  SETZM	TF			;FAILURE RET
	  POPJ	P,
	$ENDIF
	LOAD	T2,UF.TYP(T1)		;GET ACTUAL DATA TYPE
	JUMPL	T2,SETDFE		;RANGE CHECK			  ;M436
	CAILE	T2,MX%DFT		;RANGE CHECK			  ;M433
SETDFE:	 ERRU	(IUE)			;BLETCH				  ;M433
	MOVE	T5,VALTAB(T2)		;GET STATE FOR DATATYPE		  ;M433
	MOVEM	T5,VALDF		;SETUP NEXT PDB
	SETOM	T1
	POPJ	P,

VALTAB:
	VALQUO				; ASCII
	VALQUO				; EBCDIC
	VALQUO				; FILE
	VALQUO				; SIXBIT
	VALDEC				; DECIMAL
	VALOCT				; OCTAL
	VALFLO				; FLOATING
	VALDOU				; DOUBLEFLOATING
	VALGFL				; GFLOATING
	VALLON				; LONGINTEGER
	VALPAC				; PACKED
	VALUNS				; UNSIGNED

DEFINE PRINTV(X),<PRINTX X>

IFN <MX%DFT-DFT%UN>,<PRINTX SOME DATA-TYPES UNSUPPORTED IN SETDFV
		     PRINTV \MX%DFT
		     PRINTV \DFT%UN
		     REPEAT <MX%DFT-DFT%UN>,<Z>>

REDCAS:
;
; ACTION ROUTINE FOR REDEFINE, SET PDB FROM TYPE OF SYMBOL
;
	MOVE	T5,CR.SAV(T2)		;GET ADDRESS OF PARSE DATA
	$CALL	SY.FIND,<0(T5)>		;PASS THE DATA FOR CURR TOK
	JUMPT	L$IFX			;A MATCH?
	  MOVEI	T2,[ASCIZ/Name not known/] ;NO, TELL CALLER
	  SETZM	TF			;FAILURE RET
	  POPJ	P,
	$ENDIF
	SETZM	T3			;INDIC NO PDB SET YET
	$FETCH	T2,BID,(T1)		;GET TYPE OF FLD
	CAIN	T2,DA$TYP		;DAT FLD?
	MOVEI	T3,DEFDAS		;YES
	CAIE	T2,XA$TYP		;XAB?
	$SKIP				;YES
	  $FETCH T2,COD,(T1)		;GET TYPE OF XAB
	  CAIN	T2,XB$KEY		;KEY?
	  MOVEI	T3,DEFXBC		;YES
	  CAIN	T2,XB$ALL		;AREA?
	  MOVEI	T3,DEFBKZ		;YES
	$ENDIF
	JUMPE	T3,L$ERRU(IUE)		;UNKNOWN TYPE CODES IN BLK
	MOVEM	T3,.NEXT		;SET NEXT PDB
	SETOM	TF			;SUCC RET
	POPJ	P,

SUBTTL	TOP-LEVEL SYNTAX OF RMSUTL

UTLCMD::			 	;ARG BLK PASSED ON EACH PARSE$ CALL
	CMDINI				;1ST PDB PASSED TO COMND ON EACH CMD
	[ASCIZ/RMSUTL>/]		;PROMPT STRING
	PDBPAG				;PAGE FOR PARSED DATA
	0				;USE TTY FOR CMD INPUT & OUTPUT

CMDINI:	$INITC(CMDS)			;THE INIT-CMD PARSER DESC BLK

CMDS:	CM$TAB	(<CHANGE,CLOSE,DEFINE,DELETE,DISPLAY,EXIT,FIX,HELP,INFORMATION,OPEN,REDEFINE,SET,SPACE,TAKE,UNCLUTTER,VERIFY>,<$ACTION(CMDACT),$BREAK(MSKMAC)>)

CFM:	$CRLF			;CRLF IS COMMON TERMINATOR OF COMMANDS

SUBTTL	SYNTAX OF CHANGE COMMAND

;General Syntax:
;---------------
;
; CHANGE (VALUE OF) object location (SETTING) to-list
;	 WHERE <to-list> IS:  <field-name> (TO) <value>

; TOP-LEVEL DISPATCH
;
VAR$AD==QVALDF			;FOR AC$SET TO CHANGE DATFLD
.CHANG:	$NOISE (CHAENT,VALUE OF,<AC$SET(@QCHCOM)>)			;M434
CHAENT:	OP$TAB	(CHA,<BUCKET,<PROLOGUE,PROLOGUE-DATA>>,<$ALTERN(CHADF)>)


;CHANGE to-list (FOR RECORDS IDENTIFIED BY) records-to-use
;

;CHGDAT:$SUB	(CHDCOM,CHADF)	;BECAUSE CHG DF IS $ALTERN, QVALDF PRESET
CHICOM:	$COMMA	(CHADF,<$ALTERN(RTUIDX)>)	;[M434] Use correct RTU clause
CHRCOM:	$COMMA	(CHADF,<$ALTERN(RTURLT)>)	;[M434] Use correct RTU clause
CHSCOM:	$COMMA	(CHADF,<$ALTERN(RTUSEQ)>)	;[M434] Use correct RTU clause

CHADF:	$MACF	(CHDTO,<datafield-name>,$ACTION(SETDFV))
CHDTO:	$NOISE	(@VALDF,<TO>)

CBEDF:	KY$WRD	(CBEDFN,CBED,DATAFIELD)	;MERGE FOR CHANGE BKT ENTRY datafld-list
CBEDFN:	$NOISE	(CHADF,NAMED)		;...CAN BE CAUSE QVALDF ALREADY SET	

;CHANGE (VALUE OF) BUCKET (AT) HEADER!ENTRY n1!ID n2 (SETTING) to-list


; CHANGE BUCKET DISPATCH
;
CHABUC:	$NOISE	(BUCOPT,<AT>)
BUCOPT:	OP$TAB	(CHG,<ENTRY,HEADER,ID>)

; CHANGE BUCKET HEADER
;

CHGHEA:	$NOISE	(HTOLST,<SETTING>)
CBHCOM:	$COMMA	(HTOLST,$ALTERN(CFM))
HTOLST:	AO$TAB	(CBH,<<ANO,<AREA-NUMBER>>,<IBA,ATTRIBUTES>,<LID,<LAST-ID>>,LEVEL,<NBP,<NEXT-BUCKET>>,<NID,<NEXT-ID>>,<IBT,TYPE>,<WIU,WORDS-IN-USE>>,AC$NOI(CHABTO))
CBHANO:	$NUMGE	(CBHCOM,BASE10,<area-ID of bucket>)
CBHIBT:	AV$TAB	(CBHCOM,IBT,IB,<DATA,INDEX>)
CBHLID:	$NUMGE	(CBHCOM,BASE10,<maximum ID for this bucket>)
CBHLEV:	$NUMGE	(CBHCOM,BASE10,<# of index levels to data-level>)
CBHNBP:	$NUMGE	(CBHCOM,BASE10,<page number of next bucket>)
CBHNID:	$NUMGE	(CBHCOM,BASE10,<ID that will be assigned next entry>)
CBHWIU:	$NUMGE	(CBHCOM,BASE10,<# of words used in bucket>)

CBHIBA:	AV$TAB	(CIBAPL,IBA,IB,<NIL,RIGHTMOST,ROOT>)
CIBAPL:	$TOKEN	(CBHIBA,+,<$ALTERN(CBHCOM)>)

;CHANGE ENTRY: GET OBJECT NUMBER & SETUP OPTIONS FOR REMAINDER OF CMD LINE

CHGID:	$INDEX	(0,$ACTION(CHIDACT))
CHGENT:	$INDEX	(0,$ACTION(CHENACT))

; CHANGE ENTRY to-list FOR INDEX ENTRY
;
CIESET:	$NOISE	(CIEOPT,<SETTING>)
CIEOPT:	AO$TAB	(CIE,<<IRA,ATTRIBUTES>,<DBP,DOWN-POINTER>,<IKV,KEY-VALUE>>,AC$NOI(CHABTO))
CIEDBP:	$NUMGT	(CIECMA,BASE10,<page number of a bucket>)
CIEIKV:	$QUOTE	(CIECMA,<Quoted key>)
CIECMA:	$COMMA	(CIEOPT,<$ALTERN(CFM)>)

CIEIRA:	AV$TAB	(CIATPL,IAT,IR,<HIKEY,NIL>)
CIATPL:	$TOKEN	(CIEIRA,+,<$ALTERN(CIECMA)>)

; CHANGE ENTRY to-list FOR VARIABLE-LENGTH UDR
;
VAR$AD==QVALDF			;FOR AC$SET
CVESET:	$NOISE	(CVEOPT,SETTING,<AC$SET(CVECMA)>)
CVEOPT:	AO$TAB	(CVE,<<IRA,ATTRIBUTES>,<RID,ENTRY-ID>,RFA,<IRS,SIZE>>,<$ALTERN(CBEDF),AC$NOI(CHABTO)>)

CVERID:	$NUMGT	(CVECMA,BASE10,<ID to assign this entry>)
CVERFA:	$SUB	(CVECMA,RFADO)
CVEIRS:	$NUMGE	(CVECMA,BASE10,<bytes in the record>)
CVECMA:	$COMMA	(CVEOPT,<$ALTERN(CFM)>)

CVEIRA:	AV$TAB	(CVATPL,VAT,IR,<DELETED,KEEP,NIL,POINTER>)
CVATPL:	$TOKEN	(CVEIRA,+,<$ALTERN(CVECMA)>)

; CHANGE ENTRY to-list FOR FIXED-LENGTH UDR
;
VAR$AD==QVALDF			;FOR AC$SET
CFESET:	$NOISE	(CFEOPT,SETTING,<AC$SET(CFECMA)>)
CFEOPT:	AO$TAB	(CFE,<<RID,ENTRY-ID>,RFA>,<$ALTERN(CBEDF),AC$NOI(CHABTO)>)
CFERID:	$NUMGT	(CFECMA,BASE10,<ID to assign this entry>)
CFERFA:	$SUB	(CFECMA,RFADO)
CFECMA:	$COMMA	(CFEOPT,<$ALTERN(CFM)>)

CFEIRA:	AV$TAB	(CFATPL,FAT,IR,<DELETED,KEEP,NIL,POINTER>)
CFATPL:	$TOKEN	(CFEIRA,+,<$ALTERN(CFECMA)>)

; CHANGE ENTRY to-list FOR SIDR ENTRY
;
CSESET:	$NOISE	(CSEOPT,<SETTING>)
CSEOPT:	AO$TAB	(CSE,<<RID,ENTRY-ID>,<SKV,KEY-VALUE>,<SRS,SIZE>>,<$ALTERN(CSRFA),AC$NOI(CHABTO)>)
CSERID:	$NUMGT	(CSECMA,BASE10,ID to assign this entry)
CSESKV:	$QUOTE	(CSECMA,<Quoted key>)
CSESRS:	$NUMGT	(CSECMA,BASE10,# of words after header)
CSECMA:	$COMMA	(CSEOPT,<$ALTERN(CFM)>)

CSEIRA:	AV$TAB	(CSATPL,SAT,IR,<NIL>)
CSATPL:	$TOKEN	(CSEIRA,+,<$ALTERN(CSECMA)>)

CSRFA:	AO$TAB	(CSR,<<RFEL,RFA>>)
CSRRFE:	$INDEX	(CSRFTO)
	VAR$AD==QRFADO			;CANT ALTERN TO SUB
CSRFTO:	$NOISE	(CSRRFA,TO,AC$SET(CSECMA))
CSRRFA:	KY$WRD	(CSECMA,RNIL,<NIL>,$ALTERN(RFADO))

;CHANGE (VALUE OF) PROLOG-DATA (FOR) FILE!AREA n1!KEY n2 (SETTING) to-list
;

CHAPRO:	$NOISE	(CPROPT,<FOR>)
CPROPT:	OP$TAB	(CHN,<AREA,FILE,KEY>)
CHFCOM:	$COMMA	(CPFOPT,$ALTERN(CFM))		;FOR SUBSEQ FLDS
CHKCOM:	$COMMA	(CPKOPT,$ALTERN(CFM))

; CHANGE PROLOG AREA
;
CHNARE:	$AID	(ASETNG)
ASETNG:	$NOISE	(ATOLST,<SETTING>)
ATOLST:	AO$TAB	(ABKZ,<<BKZ,BUCKET-SIZE>>)
ABKZBK:	$NOISE	(BKTVAL,<TO>)
BKTVAL:	$NUMGE	(CFM,BASE10,pages per bucket)

; CHANGE PROLOG FILE
;
CHNFIL:	$NOISE	(CPFOPT,<SETTING>)
CPFOPT:	AO$TAB	(CPF,<<ARC,AREA-COUNT>,<ARO,AREA-OFFSET>,<BKS,<BUCKET-SIZE>>,<BSZ,<BYTE-SIZE>>,<KYC,<KEY-COUNT>>,<KYO,<KEY-OFFSET>>,<MRS,<MAXIMUM-RECORD-SIZE>>,<ORG,<ORGANIZATION>>,<PIF,<PAGES-IN-FILE>>,<RFM,RECORD-FORMAT>>,AC$NOI(CHABTO))

CPFBKS:	$NUMGE	(CHFCOM,BASE10)
CPFBSZ:	$NUMGE	(CHFCOM,BASE10)
CPFMRS:	$NUMGE	(CHFCOM,BASE10)
CPFORG:	AV$TAB	(CHFCOM,ORZ,FB,<INDEXED,RELATIVE,SEQUENTIAL>)
	FB$IND==FB$IDX				;DEFINE SYMBOL AV$TAB EXPECTS
CPFRFM:	AV$TAB	(CHFCOM,RFM,FB,<FIXED,VARIABLE>)

CPFARC:	$NUMGE	(CHFCOM,BASE10,<number of areas>)
CPFARO:	$NUMGE	(CHFCOM,BASE10,<offset of first area descriptor>)
CPFPIF:	$NUMGE	(CHFCOM,BASE10,<next available page>)
CPFKYC:	$NUMGE	(CHFCOM,BASE10,<number of keys in file>)
CPFKYO:	$NUMGE	(CHFCOM,BASE10,<offset of first key descriptor>)

; CHANGE PROLOG KEY n
;
CHNKEY:	$KREF	(CPKSET)
CPKSET:	$NOISE	(CPKOPT,<SETTING>)
CPKOPT:	AO$TAB	(CPK,<<KYA,ATTRIBUTES>,<DAN,DATA-AREA>,<DFL,DATA-FILL>,<DTP,DATA-TYPE>,<IAN,INDEX-AREA>,<IFL,INDEX-FILL>,<REF,KEY-OF-REFERENCE>,<LVS,LEVELS>,<NKP,NEXT-KEY>,<ROOT,ROOT-PAGE>>,<$ALTERN(CPKSEG),AC$NOI(CHABTO)>)
CPKSEG:	AO$TAB	(CKS,<<POS,POSITION>,<SIZ,SIZE>>)

CPKLVS:	$NUMGE	(CHKCOM,BASE10,<# of levels in index structure>)
CPKNKP:	$NUMGE	(CHKCOM,BASE10,<offset of next key descriptor>)
CPKROO:	$NUMGE	(CHKCOM,BASE10,<page of index's root>)
CPKDAN:	$NUMGE	(CHKCOM,BASE10,<area ID of key's data buckets>)
CPKDFL:	$NUMGE	(CHKCOM,BASE10,max words to load in key's data buckets)
CPKDTP:	AV$TAB	(CHKCOM,DT,XB,<<AS8,8-BIT-ASCII>,<STG,ASCII>,<FL2,DOUBLE-FLOATING>,EBCDIC,<FL1,FLOATING>,<IN4,INTEGER>,GFLOATING,<IN8,LONG-INTEGER>,PACKED,SIXBIT,<UN4,UNSIGNED>>)							;M433
CPKIAN:	$NUMGE	(CHKCOM,BASE10,<area ID of key's index buckets>)
CPKIFL:	$NUMGE	(CHKCOM,BASE10,max words to load in key's index buckets)
CPKREF:	$NUMGE	(CHKCOM,BASE10,<key-of-reference>)

CPKKYA:	AV$TAB	(CKATPL,KAT,XB,<<CHG,CHANGES-ALLOWED>,<DUP,DUPLICATES-ALLOWED>,NIL>)
CKATPL:	$TOKEN	(CPKKYA,+,$ALTERN(CHKCOM))

CKSPOS:	$NOISE	(POSIDX,<OF SEGMENT>)
POSIDX:	$INDEX	(POSTO)
POSTO:	$NOISE	(POSIT,TO)
POSIT:	$NUMGE	(CHKCOM,BASE10,<# of bytes before key segment>)

CKSSIZ:	$NOISE	(SIZIDX,<OF SEGMENT>)
SIZIDX:	$INDEX	(SIZTO)
SIZTO:	$NOISE	(SIZIT,TO)
SIZIT:	$NUMGE	(CHKCOM,BASE10,<bytes in key segment>)

SUBTTL	SYNTAX OF CLOSE

; CLOSE RMSFILE ! REPORT
;
.CLOSE:	$NOISE	(CLOTYP,<FILE TYPE>)
CLOTYP:	KY$TAB	(CFM,CLO,<REPORT,<RMS,RMS-FILE>>,$DEFAULT(RMS-FILE))      ;M433

SUBTTL	SYNTAX OF DEFINE COMMAND

.DEFIN:	$NOISE	(DEFTYP,OBJECT)
DEFTYP:	OP$TAB	(DEF,<AREA,DATAFIELD,FILE,KEY>)		;PROC APPROP OPTION

; SYNTAX TO DEFINE A DATA RECORD AND IT'S FIELDS:
; ----------------------------------------------
;
;	DEFINE  DATAFIELD datafieldname (WITH TYPE)
;	 ASCII!FILE-BYTES!SIXBIT!PACKED!EBCDIC
;		(WITH LENGTH) n1 (STARTING AT BYTE) n2
;
;	DEFINE DATAFIELD datafieldname (WITH TYPE)
;	 INTEGER!LONG-INTEGER!FLOATING!DOUBLE-FLOATING!GFLOATING
;	 (STARTING AT WORD) n3
;

DISW%D==DFT%DEC
DISW%O==DFT%OCT
DESW%D==0
DEFDAT:	$NOISE	(DEFDNM,NAMING IT)
DEFDNM:	$MACF	(DEFDAS,<field name>)
DEFDAS:	$NOISE	(DEDTYP,WITH TYPE)
DEDTYP:	OP$TAB	(DFT,<ASCII,<DOUBLE,DOUBLE-FLOATING>,<FILE,FILE-BYTES>,FLOATING,GFLOATING,INTEGER,<LONG,LONG-INTEGER>,PACKED,SIXBIT>)			  ;M433

DFTDOU:									  ;A433
DFTFLO:									  ;A433
DFTGFL:									  ;A433
DFTLON:									  ;A433
DFTINT:	$NOISE	(DEDWRD,STARTING AT WORD) 				  ;A433
DEDWRD:	$NUMGE	(DEDISW,BASE10,<number of words before field>,$ALTERN(DEDISW));
DEDISW:	SW$TAB	(DESW,<<DISPLAY,DISPLAY:>>,$ALTERN(DEDKEY))	;[455] [433]
DESWDI:	KY$TAB	(DEDKEY,DISW,<DECIMAL,OCTAL>,$ALTERN(DEDKEY),$DEFAULT(DECIMAL))									  ;A433

DFTASC:
DFTFIL:
DFTPAC:									  ;A433
DFTSIX:	$NOISE	(DEDLEN,WITH LENGTH)
DEDLEN:	$NUMGT	(DEDBYT,BASE10,<number of bytes in field>)
DEDBYT:	$NOISE	(DEDBNM,STARTING AT BYTE)
DEDBNM:	$NUMGE	(DEDKEY,BASE10,<number of bytes before field>,$ALTERN(DEDKEY));

	DESW%D==KD%DIS				;COMMON TABLE WITH KEY ATTR

DEDKEY:	SW$TAB	(DDK,<KEY>,$ALTERN(DKEYSW))
DDKKEY==CFM
	DDK%KEY==KD%KEY				;COMMON TAB WITH KEY ATTR

; SYNTAX TO DEFINE A FILE (SEE TABLES FOR SPELLED OUT SWITCHES):
; -----------------------
;
;DEFINE FILE file-name (WITH ORGANIZATION)
;
; FOR V1:
;		INDEXED (WITH KEYS) key-name-list [/MRS /BSZ /RFM]
;		RELATIVE (WITH CELL SIZE) n [/MRN /BSZ /RFM /BLOCK]
;		SEQUENTIAL [/MRS /BSZ /RFM /BLOCK]
;
; IN FUTURE?:
;		ASCII
;		LINE-SEQUENCED

DEFFIL:	$NOISE	(DEFFNM,NAMING IT)
DEFFNM:	$FILEF	(DEFORN,<file spec>)
DEFORN:	$NOISE	(DEFORG,WITH ORGANIZATION)
DEFORG:	OP$TAB	(DFO,<INDEXED,RELATIVE,SEQUENTIAL>)	;[432]

DFOIND:	$NOISE	(DFKNAM,WITH KEYS)
DFKNAM:	$MACF	(DFCOMA,<key-name>)
DFCOMA:	$COMMA	(DFKnam,<$ALTERN(DFISW)>)
DFISW:	SV$TAB	(DFI,<<BKS,BUCKET-SIZE>,<BSZ,BYTE-SIZE>,<RFM,FORMAT>,<MRS,RECORD-SIZE>>,<$ALTERN(DFI.DF)>)
DFI.DF:	$CRLF	($HELP<confirm with CRLF (defaults are BYTE-SIZE=7, FORMAT=VAR)>)
DFIBKS:	$NUMGE	(DFISW,BASE10,default pages per bucket)
DFIBSZ:	$NUMGE	(DFISW,BASE10,bits per byte)
DFIMRS:	$NUMGE	(DFISW,BASE10,bytes per record)
DFIRFM:	AV$TAB	(DFISW,DER,FB,<FIX,VAR>)

DFOREL:	$NOISE	(DFRMRS,WITH MAXIMUM RECORD SIZE)	;[432]
DFRMRS:	$NUMGE	(DFRSW,BASE10,bytes per record)		;[432]
DFRSW:	SV$TAB	(DFR,<<BSZ,BYTE-SIZE>,<RFM,FORMAT>,<MRN,MAXIMUM-RECORD-NUMBER>,<RAT,RECORD-ATTRIBUTES>>,<$ALTERN(DFR.DF)>)	;[432]
DFR.DF:	$CRLF	($HELP<confirm with CRLF (defaults are BYTE-SIZE=7, FORMAT=VARIABLE)>)	;[432]
DFRBSZ:	$NUMGE	(DFRSW,BASE10,<byte size>)		;[432]
DFRRFM:	AV$TAB	(DFRSW,DRR,FB,<FIXED,VARIABLE>)		;[432]
DFRMRN:	$NUMGE	(DFRSW,BASE10,<maximum record number>)	;[432]
DFRRAT:	AV$TAB	(DFRSW,DRA,FB,<BLOCKED>)		;[432]
	FB$BLO==FB$BLK					;[432]

DFOSEQ:	SV$TAB	(DFQ,<<BSZ,BYTE-SIZE>,<RFM,FORMAT>,<MRS,MAXIMUM-RECORD-SIZE>,<RAT,RECORD-ATTRIBUTES>>,<$ALTERN(DFQ.DF)>)	;[432]
DFQ.DF:	$CRLF	($HELP<confirm with CRLF (defaults are BYTE-SIZE=7, FORMAT=VARIABLE)>)	;[432]
DFQBSZ:	$NUMGE	(DFOSEQ,BASE10,<byte size>)			;[432]
DFQRFM:	AV$TAB	(DFOSEQ,DSR,FB,<FIXED,VARIABLE>)		;[432]
DFQMRS:	$NUMGE	(DFOSEQ,BASE10,<maximum record size in bytes>)	;[432]
DFQRAT:	AV$TAB	(DFOSEQ,DSA,FB,<BLOCKED>)			;[432]
	FB$BLO==FB$BLK						;[432]

;DFRAT:	AV$TAB	(DEFFF,DRA,FB,<BLK>)
;DFRFM:	AV$TAB	(DEFFE,DFR,FB,<FIX,VAR>)
;DEFFE:	SV$TAB	(DE,<BSZ,MRN,MRS,RAT>,<$ALTERN(DFNDEF)>)
;DEBSZ:	$NUMGE	(DEFFE,BASE10,<byte size>)
;DEMRN:	$NUMGE	(DEFFE,BASE10,<maximum record number>)
;DEMRS:	$NUMGE	(DEFFE,BASE10,<maximum record size>)
;DERAT:	AV$TAB	(DEFFE,DRB,FB,<BLK>)

;SYNTAX TO DEFINE AN AREA
;------------------------
;
;	DEFINE AREA (NAMING IT) area-name (WITH BUCKET SIZE) n
;

DEFARE:	$NOISE	(DEFANM,NAMING IT)
DEFANM:	$MACF	(DEFBKZ,<area-name>)
DEFBKZ:	$NOISE	(DFBKZ,<WITH BUCKET SIZE>)
DFBKZ:	$NUMGE	(CFM,BASE10,# of pages per bucket)


;SYNTAX TO DEFINE A KEY DESCRIPTION:
;-----------------------------------
;
;	DEFINE KEY key-name (WITH SEGMENTS) segment-list [SWITCHES]
;

DEFKEY:	$NOISE	(DEFKNM,NAMING IT)
DEFKNM:	$MACF	(DEFXBC,<key-name>)
DEFXBC:	$NOISE	(DFSNAM,WITH SEGMENTS)
DFSNAM:	$MACF	(DSCOMA,<segment-name>)
DSCOMA:	$COMMA	(DFSNAM,<$ALTERN(DKEYSW)>)

DKEYSW:	SW$TAB	(KD,<<CHA,CHANGES-ALLOWED>,<DFL,DAFILL:>,<DAN,DANAME:>,<DUP,DUPLICATES-ALLOWED>,<IFL,IAFILL:>,<IAN,IANAME:>>,$ALTERN(CFM))
KDCHA==DKEYSW
KDDUP==DKEYSW
KDDAN:	$MACF	(DKEYSW,<area name>)
KDDFL:	$NUMGE	(DKEYSW,BASE10,max words to load in key's data buckets)
KDIAN:	$MACF	(DKEYSW,<area name>)
KDIFL:	$NUMGE	(DKEYSW,BASE10,max words to load in key's index buckets)

SUBTTL	SYNTAX OF DELETE COMMAND

.DELET:	$NOISE	(DELEOP,<OBJECT>)
DELEOP:	OP$TAB	(DEL,<<BUC,BUCKET-ENTRY>,RECORD>)


; DELETE (OBJECT) BUCKET-ENTRY (IDENTIFIED BY) ENTRY n1!ID n2
;

DELBUC:	$NOISE	(DELOPT,<IDENTIFIED BY>)
DELOPT:	KY$TAB	(DELVAL,DLT,<ENTRY,ID>)
DELVAL:	$INDEX	(CFM)


; DELETE (OBJECT) RECORD (IDENTIFIED BY) records-to-use
;

DELREC:	$NOISE	(@QRTUSE,<IDENTIFIED BY>)	;[431] Use correct R-T-U clause

SUBTTL	SYNTAX OF DISPLAY COMMAND

; DISPLAY PROLOGUE-DATA!BUCKET!DATA!<datafield>  ........
;	DISPLAY PROLOGUE-DATA (FOR) FILE!AREA n1!KEY n2
;
;	DISPLAY BUCKET (AT) ENTRY n1-list!ID n2-list!HEADER!KEY-VALUE!LARGEST-ENTRY
;
;	DISPLAY DATA!<datafield> (FOR RECORDS IDENTIFIED BY) .....
;
.DISPL:	$NOISE	(DSPVAL,<VALUE OF>)
DSPVAL:	OP$TAB	(DSP,<BUCKET,DATA,<PROLOGUE,PROLOGUE-DATA>>,<$ALTERN(DSPDAF)>)

DSPBUC:	$NOISE	(DISBUC,<AT>)
DISBUC:	OP$TAB	(DIS,<ENTRY,HEADER,ID,<KEY,KEY-VALUE>,<LAST,LARGEST-ENTRY>>,$ALTERN(CFM))
DISENT:	$INDEX	(DIBETO,,DIBELO)
DIBETO:	$NOISE	(DIBEHI,TO)
DIBEHI:	$NUMGE	(DIBECM,BASE10,larger number,$ALTERN(DIBECM))
DIBECM:	$COMMA	(DIBELO,<$ALTERN(CFM)>)
DISID==DISENT
DISHEA==CFM
DISKEY:	$NOISE	(DISKEV,GREATER OR EQUAL TO)
DISKEV:	$QUOTE	(CFM,<Quoted key>)
DISLAS==CFM

DSPDAT:	$NOISE	(@QRTUSE,<FOR RECORDS IDENTIFIED BY>)	;[431] Correct R-T-U clause

DSPPRO:	$NOISE	(DSOPT,<FOR>)
DSOPT:	OP$TAB	(DS,<AREA,FILE,KEY>,<$ALTERN(CFM)>)

DSAREA:	$AID	(CFM)
DSFILE: AK$TAB	(DSFCON,DSF,<<ARC,AREA-COUNT>,<ARO,AREA-OFFSET>,<BKS,<BUCKET-SIZE>>,<BSZ,<BYTE-SIZE>>,<KYC,KEY-COUNT>,<KYO,KEY-OFFSET>,<MRS,<MAXIMUM-RECORD-SIZE>>,<ORG,<ORGANIZATION>>,<PIF,<PAGES-IN-FILE>>,<RFM,<RECORD-FORMAT>>>,<$ALTERN(CFM)>)
DSFCON:	$COMMA	(DSFILE,<$ALTERN(CFM)>)

DSKEY:	$KREF	(IDXFLD)
IDXFLD:	AK$TAB	(IDXCON,DIX,<<KYA,ATTRIBUTES>,<DAN,DATA-AREA>,<DFL,<DATA-FILL>>,<DTP,<DATA-TYPE>>,<IAN,<INDEX-AREA>>,<IFL,<INDEX-FILL>>,<REF,<KEY-OF-REFERENCE>>,<LVS,LEVELS>,<NKP,<NEXT-KEY>>,POSITION,<ROOT,ROOT-PAGE>,SIZE>,$ALTERN(CFM))
IDXCON:	$COMMA	(IDXFLD,<$ALTERN(CFM)>)

DSPDAF:	$MACF	(@QDSCOM,<datafield-name>)

DSIDFC:	$COMMA	(DSPDAF,$ALTERN(RTUIDX)) ;[431] [a434] Use correct R-T-U clause
DSRDFC:	$COMMA	(DSPDAF,$ALTERN(RTURLT)) ;[a434] Use correct R-T-U clause
DSSDFC:	$COMMA	(DSPDAF,$ALTERN(RTUSEQ)) ;[a434] Use correct R-T-U clause

SUBTTL	SYNTAX OF EXIT COMMAND

;EXIT	(to monitor)
;
.EXIT:	$NOISE (CFM,<TO MONITOR>)


SUBTTL	SYNTAX OF FIX COMMAND

; FIX RFA-list
;

.FIX:	$NOISE	(FIXRFA,<RECORD WITH RFA>)
FIXRFA:	$SUB	(FIXIDX,RFADO)
FIXIDX:	$NOISE	(FIXKRF,OF INDEX)
FIXKRF:	$NUMGE	(FIXCMA,BASE10,key of reference,$DEFAULT(0))
FIXCMA:	$COMMA	(FIXRFA,$ALTERN(CFM))


SUBTTL	SYNTAX OF HELP COMMAND

;HELP		(please)
;
.HELP:	$NOISE (CFM,<PLEASE>)


SUBTTL	SYNTAX OF INFO COMMAND

;INFO	ALL!AREAS!CONTEXT!DATAFIELDS!KEYS
;
.INFOR:	$NOISE	(INFTYP,ABOUT)
INFTYP:	KY$TAB	(CFM,INF,<ALL,AREAS,CONTEXT,DATAFIELDS,KEYS>)


SUBTTL		SYNTAX OF OPEN COMMAND

;OPEN (FILETYPE) RMSFILE (WITH NAME) file-name (FOR) INPUT!OUTPUT
;OPEN (FILE TYPE) REPORT (WITH NAME) file-name /APPEND
;

.OPEN:	$NOISE	(OPNTYP,<FILE TYPE>)
OPNTYP:	OP$TAB	(OPE,<REPORT,<RMS,RMS-FILE>>,$DEFAULT(RMS-FILE)) ;M433
OPEREP:	$NOISE	(REPNAM,<WITH NAME>)
REPNAM:	$FILEF	(REPSWI,<file spec>) ;[M435] Don't default to existing file
REPSWI:	SW$TAB	(OPN,<APPEND>,$ALTERN(CFM))
OPNAPP:	$CRLF

OPERMS:	$NOISE	(RMSNAM,<WITH NAME>)
RMSNAM:	$IFILE	(RMSOPT,<file spec>) ;[430] Use recognition
RMSOPT:	$NOISE	(OPNIO,<FOR>)
OPNIO:	KY$TAB	(OPNMOD,OP,<INPUT,OUTPUT,PATCHING>,$DEFAULT(INPUT))
OPNMOD:	SW$TAB	(OSRM,<<MAX,MAXIMUM-RECORD-SIZE:>>,$ALTERN(CFM))
	OSRM%M=0
OSRMMAX:$NUMGE	(CFM,BASE10,bytes in largest record)

SUBTTL	SYNTAX OF REDEFINE CMD

;REDEFINE (NAME) BLK-NAME ... [CONTINUE WITH DEFINE CMD]
;

.REDEF:	$NOISE	(REDNAM,NAME)
REDNAM:	$MACF	(0,already DEFINEd name,$ACTION(REDCAS))

;REDCAS SETS NEXT PDB TO MERGE WITH APPROP DEFINE OPTION

SUBTTL		SYNTAX OF SET COMMAND

.SET:	$NOISE	(SETENT,<CURRENT>)
SETENT:	OP$TAB	(SET,<BUCKET,INDEX,RECORD>)

;SET (CURRENT) INDEX (USING KRF) n [(AND) ROOT ! PAGE n ! RFA a/b]
;
SETIND:	$NOISE	(SINKRF,USING KEY OF REFERENCE)
SINKRF:	$NUMGE	(SINLOC,BASE10)
SINLOC:	$NOISE	(SINLTY,AND)
SINLTY:	OP$TAB	(SIL,<BUCKET,RFA,ROOT>,$DEFAULT(ROOT))
SILBUC:	$NOISE	(SILBUV,AT PAGE)
SILBUV:	$NUMGT	(CFM,BASE10,file page number)
SILRFA:	$NOISE	(SILRFV,BKT/ID)
SILRFV:	$SUB	(CFM,RFADO)
SILROOT==CFM

; SET BUCKET (TO ...) DATA-LEVEL!DOWN!ENTRY n!LAST-RECORD!NEXT!ROOT n!UP
;
SETBUC:	$NOISE	(SBKT,<TO ONE IDENTIFIED BY>)
SBKT:	OP$TAB	(STB,<<DATA,DATA-LEVEL>,DOWN,<LAST,LAST-RECORD>,NEXT,ROOT,UP>)
STBDAT==CFM
STBDOW:	$NOISE	(STBDNU,USING ENTRY)
STBDNU:	$NUMGT	(CFM,BASE10, positive decimal number,$DEFAULT(1))
STBLAS==CFM
STBNEX==CFM
STBROO==CFM
STBUP==CFM

; SET RECORD (TO ...)  [KEY range ! ! LAST ! REL range]   [(AND) name opr value]
;
SETREC:	$NOISE	(@QRTUSE,<TO FIRST ONE IDENTIFIED BY>)	;[431] Correct R-T-U clause}i~r~r

RTUIDX:	OP$TAB	(RTU,<KEY,<LAST,LAST-ENTRY>,<REL,RELATIVE-REC-NO>>,$ALTERN(CFM))	;[431]
RTULAS==CFM
RTUKEY:	$KREF	(RTUFRO,$ALTERN(RTUST1))
RTUFRO:	$NOISE	(RTUST1,FROM)
RTUST1:	$QUOTE	(RTUKTO,<quoted key>,<$ALTERN(RTUKY1)>)
RTUKY1:	KY$WRD	(RTUKTO,RTUL,<LOWEST>)
RTUKTO:	$NOISE	(RTUST2,<TO>)
RTUST2:	$QUOTE	(RTUTST,<quoted key>,<$ALTERN(RTUKY2)>)
RTUKY2:	KY$TAB	(RTUTST,RUH,<<FOUND,FOUND-KEY-VALUE>,HIGHEST>,$ALTERN(RTUCFM))

RTUREL:	$NOISE	(RTUNUM,FROM)
RTUNUM:	$NUMGE	(RTUNTO,BASE10)
RTUNTO:	$NOISE	(RTUN2,<TO>)
RTUN2:	$NUMGE	(RTUTST,BASE10,<larger number>,$ALTERN(CFM))

VAR$AD==QVALDF				;FOR RET VAR AFTER DATTYP DEP DF VAL
RTUTST:	$NOISE	(RTUCFM,<AND>)
RTUCFM:	$CRLF	($ALTERN(RTUSYM))
RTUSYM:	$MACF	(RTUOPR,<datafield to test>,$ACTION(SETDFV))
RTUOPR:	$NOISE	(RTUEQL,OPERATOR,AC$SET(CFM))
RTUEQL:	$TOKEN	(RTUVAL,=,<$ALTERN(RTUNE)>)
RTUNE:	$TOKEN	(RTUVAL,#,<$ALTERN(RTUGE)>)
RTUGE:	$OTOK	(RTUVAL,GE,<$ALTERN(RTUGTR)>)
RTUGTR:	$OTOK	(RTUVAL,GTR,<$ALTERN(RTULE)>)
RTULE:	$OTOK	(RTUVAL,LE,<$ALTERN(RTULSS)>)
RTULSS:	$OTOK	(RTUVAL,LSS)
RTUVAL:	$NOISE	(@VALDF,VALUE)

;[431]
;[431] Record-to-use clause for sequential files
;[431]
RTUSEQ:	OP$TAB	(RSQ,<<CUR,CURRENT-RECORD>,<REL,RELATIVE-REC-NO>,RFA>,$ALTERN(CFM))
RSQCUR==CFM
RSQREL:	$NUMGE	(CFM,BASE10,position of record relative to current record,$DEFAULT(1))
RSQRFA:	$NUMGE	(CFM,BASE10,RFA of record)

;						;[431]
; Record-to-use clause for relative files
;
RTURLT:	OP$TAB	(RRL,<<CUR,CURRENT-RECORD>,KEY,<REL,RELATIVE-REC-NO>,RFA>,$ALTERN(CFM))
RRLCUR==CFM
RRLKEY:	$NUMGE	(CFM,BASE10,record key)		;[431]
RRLREL:	$NUMGE	(CFM,BASE10,position of record relative to current record,$DEFAULT(1))
RRLRFA:	$NUMGE	(CFM,BASE10,RFA of record)

SUBTTL	PROCESS THE SPACE CMD

;	SPACE (USAGE OF FILE FROM) verify-options

.SPACE:	$NOISE	(SPAOPT,USAGE OF FILE FROM)
SPAOPT:	OP$TAB	(SPA,<<ALL,ALL-KEYS>,KEY,<SEC,SECONDARY-KEYS>>,$DEFAULT(ALL-KEYS))
SPAKEY:	$KREF	(SPFROM)
SPFROM:	$NOISE	(SPSTR1,FROM)
SPSTR1:	$QUOTE	(SPTO,<quoted key>,<$ALTERN(SPKY1)>)
SPKY1:	KY$WRD	(SPTO,SP1,<LOWEST>,$ALTERN(CFM))
SPTO:	$NOISE	(SPSTR2,<TO>)
SPSTR2:	$QUOTE	(CFM,<quoted key>,<$ALTERN(SPKY2)>)
SPKY2:	KY$WRD	(CFM,SP2,<HIGHEST>,$ALTERN(CFM))
SPAALL==CFM
SPASEC==CFM

SUBTTL	PROCESS THE UNCLUTTER COMMAND

;	UNCLUTTER (FILE) [keys-to-use] /PROGRESS:n2

.UNCLU:	$NOISE	(UNCST1,<INDEX FILE FROM>)
UNCST1:	$QUOTE	(UNCTO,<quoted key>,<$ALTERN(UNCKY1)>)
UNCKY1:	KY$WRD	(UNCTO,UCL,<LOWEST>,$ALTERN(UNCSW))
UNCTO:	$NOISE	(UNCST2,<TO>)
UNCST2:	$QUOTE	(UNCSW,<quoted key>,<$ALTERN(UNCKY2)>)
UNCKY2:	KY$WRD	(UNCSW,UCH,<HIGHEST>,$ALTERN(UNCSW))
UNCSW:	UCS%PRO==VSW%PRO			;TREAT AS COMMON TABLE
	SV$TAB	(UCS,<PROGRESS>,<$ALTERN(CFM)>)
UCSPRO:	$NUMGT	(UNCSW,BASE10,<frequency to show progress>)


SUBTTL	PROCESS THE VERIFY COMMAND

; VERIFY [KEY n [key-range] ! SECONDARY ! ALL] /NOACCESS/NOFIX/PROGRESS:n2

.VERIF:	$NOISE	(VEROPT,<INDEX FILE UPON>)
VEROPT:	OP$TAB	(VER,<<ALL,ALL-KEYS>,KEY,<SEC,SECONDARY-KEYS>>,$DEFAULT(ALL-KEYS))
VERKEY:	$KREF	(VFROM)
VFROM:	$NOISE	(VRSTR1,FROM)
VRSTR1:	$QUOTE	(VRTO,<quoted key>,<$ALTERN(VRKY1)>)
VRKY1:	KY$WRD	(VRTO,VR1,<LOWEST>,$ALTERN(VRYSW))
VRTO:	$NOISE	(VRSTR2,<TO>)
VRSTR2:	$QUOTE	(VRYSW,<quoted key>,<$ALTERN(VRKY2)>)
VRKY2:	KY$WRD	(VRYSW,VR2,<HIGHEST>,$ALTERN(VRYSW))
VRYSW:	SW$TAB	(VSW,<<ACC,NOACCESS>,<FIX,NOFIX>,<PROG,PROGRESS:>>,$ALTERN(CFM))
VSWACC==VRYSW
VSWFIX==VRYSW
VSWPRO:	$NUMGT	(VRYSW,BASE10,<frequency to show progress>)

VERALL==VRYSW
VERSEC==VRYSW

SUBTTL	COMMAND "SUBROUTINES"

; RFADO - PARSE AN RFA FIELD
;
RFADO:	$NUMGT	(RFASLA,BASE10,bucket of RFA)
RFASLA:	$TOKEN	(RFAID,/)
RFAID:	$NUMGT	(@QRFADO,BASE10,ID of RFA)

; VALDF - PICK UP DATA TYPE DEP DATFLD VALUE
;
VALQUO:	$QUOTE	(@QVALDF,<quoted string>)
VALDEC:	$NUMBER	(@QVALDF,BASE10)
VALOCT:	$NUMBER	(@QVALDF,BASE8)
VALFLO:	$FLOAT	(@QVALDF)

VALGFL:
VALDOU: $FNAME	(@QVALDF,<Floating-point number>,$BREAK(FLTBRK))
VALPAC:
VALUNS:
VALLON: $FNAME	(@QVALDF,<Integer>,$BREAK(INTBRK))

END
