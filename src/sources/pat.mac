; *** Edit 447 to PAT.MAC by WONG on 20-Nov-86, for SPR #21427 (TCO none)
; Edit 436 breaks USETI when in update mode. In routine GETEOF, use SIZEF JSYS
; to find the file byte count instead of GTFDB because an opened file byte
; count might be diferent then the one in the FDB.
; *** Edit 444 to PAT.MAC by WONG on 24-Jun-86, for SPR #21229 (TCO none)
; Edit 442 breaks some Cobol and TOPS-10 programs. Delete two lines at
; UUOPEN:+0
; *** Edit 443 to PAT.MAC by WONG on 6-Jun-86, for SPR #20582
; Fix MSTIME to return the correct millisecond. This edit supersedes edit
; 416,417 429,430.
; Edit 442 to PAT.MAC by WAGNER on 29-Aug-85
; Fix OPEN EXTENT to write correct date in FDB, also fix UUOPEN to not trash
; flags. Rewrite previous edits for clarity. 
; Edit 441 to PAT.MAC by WAGNER on 28-Aug-85
; Yet another typo, fix them all. 
; Edit 440 to PAT.MAC by WAGNER on 28-Aug-85
; Edit 439 introduced a typo, fix it. 
; Edit 439 to PAT.MAC by WAGNER on 28-Aug-85, for SPR #20876
; Fix OPEN EXTEND to write correct date in FDB, also fix UUOPEN to not trash
; flags. 
;Edit 438 to PAT.MAC by WAGNER on Tue 16-Jul-85
;		Fix edit 436, Caused APL problems and COBOL Transmission errors
;Edit 437 to PAT.MAC by WAGNER on Mon 20-May-85
;		Edit 432 appears to break COMPT 6. Remover for Now
;Edit 436 to PAT.MAC by WAGNER on Mon 29-Apr-85, for SPR #17425
;		Fix buried update race when doing simultaneous update,
;;		sequential I/O. Also correct some coding errors, add a
;;		label GSTAT1: for Simulas use.
;Edit 435 to PAT.MAC by WAGNER on Fri 26-Apr-85
;		INTERRUPT SYSTEM DISABLED AFTER AN EXIT 1, BREAKS DBMS
;Edit 434 to PAT.MAC by WAGNER on Thu 11-Apr-85, for QAR # 706185
;		RUN. UUO emulation in PA1050 can release JFNS of other forks.
;Edit 433 to PAT.MAC by WAGNER on Mon 1-Apr-85, for QAR #706274
;		Fix bug that PA1050 turns off TTY echoing
;Edit 432 to PAT.MAC by WAGNER on Thu 21-Mar-85, for SPR #20226
;		Make PA1050 know about XSIR%
;Edit 431 to PAT.MAC by SHTIL on Wed 9-Jan-85 - Cosmetic change to edit 430
;Edit 430 to PAT.MAC by SHTIL on Fri 4-Jan-85, for SPR #20385
;		MAKE MSTIME UUO RETURN THE RIGHT TIME ABOUT MIDNIGHT
;Edit 429 to PAT.MAC by SHTIL on Mon 12-Nov-84 - Related to the edit 417
;Edit 428 to PAT.MAC by SHTIL on Fri 26-Oct-84
;		PREVENT TERMINAL PARAMETER SMASHING
;;		SET LEVTAB/CHANTAB TO ZERO WHEN EXITING PA1050
;Edit 427 to PAT.MAC by SHTIL on Thu 13-Sep-84 - Cancel edit 426
;Edit 426 to PAT.MAC by SHTIL on Wed 5-Sep-84
;		Make an error ,message start with ?
;Edit 425 to PAT.MAC by SHTIL on Tue 14-Aug-84, for SPR #18040
;		Properly handle failed GET JSYS in GETSEG
;Edit 424 to PAT.MAC by SHTIL on Tue 31-Jul-84, for SPR #19453
;		Set proper character set for APLSF
;Edit 422 to PAT.MAC by SHTIL on Wed 18-Jul-84 -
;	Correct a mistake in edit 418
;Edit 419 to PAT.MAC by EVANS on Fri 13-Jul-84 - RESCIND BAD EDIT 418
;Edit 418 to PAT.MAC by SHTIL on Fri 29-Jun-84, for SPR #19962
;		Set correct last write date in FILOP with append access
;Edit 417 to PAT.MAC by SHTIL on Thu 28-Jun-84, for SPR #19841
;		Same as for previuos edit
;Edit 416 to PAT.MAC by SHTIL on Fri 22-Jun-84, for SPR #19841
;		Make MSTIME UUO properly evaluating the daylight savings
;;		time change.
;Edit 415 to PAT.MAC by SHTIL on Thu 21-Jun-84, for SPR #19646
;		Make PA1050 verify that in INPUT UUO data were transferred into
;;		the buffer before setting BF.IOU.
;Edit 414 by CJOHNSON on Wed 8-Feb-84
;		Properly calculate IOBYTP at FOPEN9+8
;Edit 413 More code bumming etc, 29-Jun-83 by NIXON.
; Add new COMPT. UUO. functions for COBOL 27-Jun-83 by NIXON.
; Cosmetic changes, code bumming etc. 27-Jun-83 by NIXON.
;Edit 412 by MAYO on Tue 26-Jul-83
;		Give more information on a machine size exceeded error.
;Edit 411 by MAYO on Thu 24-Mar-83
;		Add power to FTDEB (allow UUO name typeout)
;Edit 410 by SM - goodbye to SAMFRK conditionals
;Edit 409 by SM - Remove XCTUM in SKPINL; it caused SKPINL$X to fail.
;	Also add JFCL check to SKPINC as well. No SPR.
;Edit 408 by SM - Pick up block address, not length, at FOPN8A:+3L. 18871.
;	Yet another correction to 356!
; UPD ID= 66, AU51:PAT.MAC.9,   7-Dec-82 12:10:26 by MAYO
;Edit 407 by SM - Correction to 356
; UPD ID= 63, au51:PAT.MAC.8,  23-Nov-82 12:54:06 by MAYO
;Edit 406 by SM - Overhaul TMSG. 18148.
; UPD ID= 40, AU51:PAT.MAC.6,  17-Sep-82 15:59:06 by MAYO
;Edit 405 by SM - Finish installing 356, 2 years later.
; UPD ID= 35, AU51:PAT.MAC.5,   1-Sep-82 11:36:03 by MAYO
;Edit 404 by SM - Pretty up output of edit 365. 18080.
; UPD ID= 28, AU5:PAT.MAC.3,   1-Jul-82 11:29:09 by MAYO
; UPD ID= 76, U5:PAT.MAC.4,  28-Jan-82 14:06:25 by NIXON
; Fix FILOP USETI to behave like USETI UUO when block # is beyond end of file
;Edit 403 by SM - Oops on 402. Fix failing unlabeled tape code.
; UPD ID= 6, AU4:PAT.MAC.2,  24-Mar-82 11:10:17 by MAYO
;Edit 402 by SM - Have ENTER/LOOKUP on MTA actually GTJFN the name.
; UPD ID= 959, AU4:PAT.MAC.11,   2-Feb-82 15:50:51 by MAYO
;Edit 401 by SM - neaten up the TTY code now that it's all stable
; UPD ID= 958, AU4:PAT.MAC.8,  28-Jan-82 15:03:56 by MAYO
;Edit 400 by SM - Reshuffle tty code for easier debugging (addition to 367)
; UPD ID= 957, AU4:PAT.MAC.7,  26-Jan-82 12:47:48 by MAYO
;Edit 377 by SM - Have SETNAM do more reasonable SETSN call
; UPD ID= 956, AU4:PAT.MAC.6,  26-Jan-82 11:44:47 by MAYO
;Edit 376 by SM - Create new compt. function - kill w/out screwing vestigals
; UPD ID= 940, AU4:PAT.MAC.5,  13-Jan-82 11:50:00 by MAYO
;Edit 375 by SM - Have a 7 pro code translate to 00, not 02.
; UPD ID= 934, AU4:PAT.MAC.4,  30-Dec-81 14:20:33 by MAYO
;Edit 374 by SM - Put break key same-as ^C^C code in condit. FTBKCC
; UPD ID= 915, au4:PAT.MAC.13,   4-Dec-81 15:18:27 by MAYO
;Edit 373 by SM - On a suicide function, fix the terminal (see 400,401)
;Edit 372 by SM - Addition to definitive fix 367
; UPD ID= 910, au4:PAT.MAC.11,   1-Dec-81 10:42:29 by MAYO
;Edit 371 by SM - Fix to edit 360 - make MTA error check not hurt universe.
; UPD ID= 840, au4:PAT.MAC.7,   1-Oct-81 13:18:42 by MAYO
;Edit 370 by SM - Fix to DEVCHR for "controlling tty" bit
; UPD ID= 810, AU4:PAT.MAC.4,  16-Sep-81 14:05:11 by MAYO
;Edit 367 by SM - fix for term states on entry and
;		exit. Undoes (321) and tco 5.1260. Allows PA1050 to restore
;		all pertinent tty states to what they were on entry at EXIT:
;		time. Restores them back on a CONTinue. (see also 372,373,376,
;		400,401.)
; UPD ID= 791, AU4:PAT.MAC.3,  11-Sep-81 15:13:06 by MAYO
;Edit 366 by SM - attempt to make TAPOP. .TKKTP guess better
; UPD ID= 786, AU4:PAT.MAC.2,   9-Sep-81 14:53:03 by MAYO
;Edit 365 by SM - If overquota, etc., say what file did it
;Edit 364 by SM - Fix so TRMNO can take -1 for current job

; UPD ID= 2226, SNARK:<5.UTILITIES>PAT.MAC.8,  19-Jun-81 11:25:14 by MAYBERRY
; Indicate which version shipped with COBOL-12B
; UPD ID= 1942, SNARK:<5.UTILITIES>PAT.MAC.7,   5-May-81 17:08:38 by SCHMITT
;TCO 5.1310 - If DWNTIM -1, return -1 to caller
; This is the edit level that went out with COBOL-12B, all edits below here
; UPD ID= 1807, SNARK:<5.UTILITIES>PAT.MAC.6,  15-Apr-81 10:31:48 by MAYBERRY
; TCO 5.1281 v(363) make check for page number in .JBHSO in hi-seg origin calc
; UPD ID= 1767, SNARK:<5.UTILITIES>PAT.MAC.5,  25-Mar-81 17:47:52 by GRANT
;Update Copyright
; UPD ID= 1521, SNARK:<5.UTILITIES>PAT.MAC.4,   5-Feb-81 14:36:56 by OSMAN
;tco 5.1260 - Don't SFMOD when doing EXIT uuo, since if we're running as
;background fork, the SFMOD can screw up things like EMACS which may be
;running in foreground. (this edit later removed)
; UPD ID= 1166, SNARK:<5.UTILITIES>PAT.MAC.3,  15-Oct-80 15:35:48 by SCHMITT
; TCO 5.1174 - Turn echoing off for PTY rather than setting Half Duplex
; UPD ID= 819, SNARK:<5.UTILITIES>PAT.MAC.2,   1-Aug-80 12:30:09 by SIMMONS
; TCO 5.1118 V(360) INSTALL ERROR MSG ON DUMPO
; UPD ID= 757, SNARK:<4.1.UTILITIES>PAT.MAC.15,  16-Jul-80 11:09:02 by MAYBERRY
; TCO 4.1.1161 V(356) INSTALL SITGO  FILOP. PATCHES,V(357) CHANGE LABTAP CODE
; UPD ID= 637, SNARK:<4.1.UTILITIES>PAT.MAC.14,  13-Jun-80 15:24:37 by SIMMONS
;TCO 4.1.1160 V(355) FIX SO ON A CONT IN APLSF YOU GET L/C CHARACTERS
; UPD ID= 633, SNARK:<4.1.UTILITIES>PAT.MAC.13,  12-Jun-80 14:03:14 by MAYBERRY
; UPD ID= 2927 on 6/6/80 at 4:25 PM by MAYBERRY
;TCO 4.1.1158 V(354) DO RING-BUFFERED UPDATE RIB FILOP.
;TCO 4.1.1159 V(353) OPEN MTA WITH CORRECT BYTE SIZE
; UPD ID= 549, SNARK:<4.1.UTILITIES>PAT.MAC.12,  22-May-80 11:02:27 by SIMMONS
;TCO 4.1.1157 V(352) FIX SO -10 PROG CAN RUN FROM SUBSYS ON A GETSEG
; UPD ID= 409, SNARK:<4.1.UTILITIES>PAT.MAC.11,   4-Apr-80 10:02:04 by SIMMONS
;TCO 4.1.1135 V(351) FIX TO CORRECT DATE FOR D60SPT
; UPD ID= 389, SNARK:<4.1.UTILITIES>PAT.MAC.10,  28-Mar-80 10:42:26 by SIMMONS
;TCO 4.1.1130 V(350) FIX FOR ERROR CODE GJFX35 AT LKERTB
; UPD ID= 371, SNARK:<4.1.UTILITIES>PAT.MAC.9,  26-Mar-80 11:33:21 by SIMMONS
;TCO 4.1.1122 V(347) FIX FOR GETSEG
; UPD ID= 297, SNARK:<4.1.UTILITIES>PAT.MAC.8,  28-Feb-80 14:49:22 by SIMMONS
;TCO 4.1.1093 V(346) FIX FOR APLSF SO ON U/C INPUT RECEIVE L/C ON OUTPUT
; UPD ID= 295, SNARK:<4.1.UTILITIES>PAT.MAC.7,  27-Feb-80 09:43:37 by SIMMONS
; UPD ID= 292, SNARK:<4.1.UTILITIES>PAT.MAC.6,  21-Feb-80 13:33:28 by MAYBERRY
;TCO 4.1.1087	V(345)	ADD OPEN APPEND FILOP CODE
;TCO 4.1.1086	V(344)	FIX FILOP USETI/USETO BLK-NUM TO FILE ADDRESS CALC
; UPD ID= 177, SNARK:<4.1.UTILITIES>PAT.MAC.5,  28-Dec-79 11:02:04 by SIMMONS
;TCO # 4.1.1057 V(343) - FIX JFNS WHEN 2 CONTAINS A 101
; UPD ID= 12, SNARK:<4.1.UTILITIES>PAT.MAC.4,  26-Nov-79 12:15:18 by SIMMONS
;<4.1.UTILITIES>PAT.MAC.3,  8-Nov-79 15:18:32, EDIT BY DBELL
;TCO 4.2568 - USE VARYING BYTESIZES FOR MAGTAPES SO EBCDIC TAPES WORK
;<4.UTILITIES>PAT.MAC.74,  7-Nov-79 10:51:17, EDIT BY DBELL
;TCO 4.2566 - GIVE GOOD ARGUMENT TO UFPGS SO FILOP FUNCTION 10 WORKS
;<4.UTILITIES>PAT.MAC.73, 27-Sep-79 13:51:36, EDIT BY DBELL
;TCO 4.2492 - MAKE MTCHR NOT FAIL IF THE MAGTAPE HAPPENS TO NOT BE OPEN
;<EKLUND>PAT.MAC.2, 10-Sep-79 16:28:22, EDIT BY EKLUND
;TCO 4.2451 - MAKE STACK SANE AGAIN ON QUOTA EXCEEDED INTERRUPTS
;<4.UTILITIES>PAT.MAC.71,  4-Sep-79 14:02:42, EDIT BY DBELL
;TCO 4.2437 - MAKE READ BACKWARDS WORK FOR MAGTAPES
;<EKLUND>PAT.MAC.7,  4-Sep-79 09:57:05, EDIT BY EKLUND
;TCO # 4.2435 v4(334) make REWIND of spooled card file work reasonably
;<4.UTILITIES>PAT.MAC.68,  8-Aug-79 10:42:33, EDIT BY HELLIWELL
;DON'T MOUNT DECTAPE UNLESS MUST GET JFN IN MTAPE CODE
;<YODER>PAT.MAC.2, 26-Jul-79 17:10:10, EDIT BY YODER
;TCO # 4.2350 v4(332) fix edit 331, which broke NUL:
;<4.UTILITIES>PAT.MAC.65, 15-Jun-79 13:45:29, EDIT BY YODER
;TCO # 4.2290 v4(331) make DIRCHK give non-skip return for NUL:
;<4.UTILITIES>PAT.MAC.64, 13-Jun-79 15:20:34, EDIT BY R.ACE
;[EDIT ON BEHALF OF STAN WHITLOCK]
;TCO # 4.2285 v4(327) make GETLCH return correct line characteristics, not 0
;<4.UTILITIES>PAT.MAC.63, 23-Apr-79 11:51:16, EDIT BY WHITLOCK
;TCO # 4.2239 v4(326) make MTCHR. return record length in LH of AC
;<4.UTILITIES>PAT.MAC.62,  1-Apr-79 21:03:35, EDIT BY GILBERT
;TCO 4.2231 v4(325) Reserve pages 764 up for DDT.  Define MAXPAT==764000.
;<4.UTILITIES>PAT.MAC.61, 12-Mar-79 14:09:48, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.UTILITIES>PAT.MAC.60,  2-Mar-79 16:26:39, EDIT BY MILLER
;TCO 4.2201. REMOVE CODE ADDED IN RELEASE 2 TO FIX MTA POSITIONING OPS
;<WHITLOCK..PA1050>PAT.MAC.59,  1-Mar-79 08:45:43, EDIT BY WHITLOCK
;TCO # 4.2200 v4(324) make edit 322 work with edit 320
;<WHITLOCK..PA1050>PAT.MAC.58, 26-Feb-79 13:06:29, EDIT BY WHITLOCK
;TCO # 4.2199 V4(323) make BREAK key act like 2 ^C if user is trapping ^C
;<WHITLOCK..PA1050>PAT.MAC.57, 26-Feb-79 12:13:55, EDIT BY WHITLOCK
;TCO # 4.2198 V4(322) speed up OUTSTR - use SOUT instead of BOUT loop
;<WHITLOCK..PA1050>PAT.MAC.56, 26-Feb-79 11:44:22, EDIT BY WHITLOCK
;TCO # 4.2197 v4(321) restore user's SFMOD on CONTinue
;<WHITLOCK..PA1050>PAT.MAC.55, 22-Feb-79 16:53:36, EDIT BY WHITLOCK
;TCO # 4.2196 v4(320) disable control char translation on TTY output
;<4.UTILITIES>PAT.MAC.54,  2-Feb-79 14:15:22, EDIT BY ALUSIC
;TCO # 4.2182 V4(317) ISSUE ERROR MSG AND HALT ON CHN 11 INT IF NOT UUO @IOERR
;<4.UTILITIES>PAT.MAC.53, 23-Jan-79 15:02:38, EDIT BY ALUSIC
;TCO # 4.2169 V4(316) FIX TRMOP FUNCTIONS .TONFC AND .TOWID AT TONFCS & TOWIDR.
;<4.UTILITIES>PAT.MAC.52, 27-Dec-78 11:59:42, EDIT BY HELLIWELL
;TCO # 4.2133 V4(315) FIX BUG IN REMAP WHEN MOVING CODE UP
;<4.UTILITIES>PAT.MAC.51, 13-Dec-78 14:47:28, EDIT BY ALUSIC
;TCO # 4.2121 V4(314) SET EOF POINTER TO REFLECT CORRECT # WDS AT MOVBUF+7
;<4.UTILITIES>PAT.MAC.50,  6-Dec-78 17:34:15, EDIT BY HURLEY
;FIX THE MISSING DATA ON THE "CREF" COMMAND. (EMPTY LISTINGS)
;MAKE UCL3 NOT CALL SETEOF IF THE DEVICE IS NOT A DISK (EG A LPT:)
;<4.UTILITIES>PAT.MAC.49, 17-Nov-78 17:18:47, EDIT BY HELLIWELL
;TCO # 4.2091 CHANGE "DSK:<SUBSYS>" TO "PS:<SUBSYS>"
;<4.UTILITIES>PAT.MAC.48, 17-Nov-78 09:52:29, EDIT BY ALUSIC
;TCO# 4.2090 SET USE BITS IN INPUT BUFFER HEADERS, FIXES FORTRAN MTA BACKSPACE
;<ALUSIC.SPR>PAT.MAC.1,  6-Nov-78 11:13:18, EDIT BY ALUSIC
;TCO# 4.2080 MAKE TTCL6 (GETLCH) RETURN 0 IF JOB IS DETACHED
;<4.UTILITIES>PAT.MAC.46, 29-Oct-78 14:13:03, EDIT BY HELLIWELL
;<4.UTILITIES>PAT.MAC.45, 29-Oct-78 13:13:44, EDIT BY HELLIWELL
;SOME MORE FIXES FOR HI SEG FREE POINTER OFF END OF HI SEG
;<4.UTILITIES>PAT.MAC.44, 29-Oct-78 12:32:43, EDIT BY HELLIWELL
;TCO 4.2073 ACCOUNT FOR HI SEG WITH LENGTH EXACT MULTIPLE OF PAGE DURING GETSEG
;<4.UTILITIES>PAT.MAC.43, 20-Oct-78 18:38:23, EDIT BY HELLIWELL
;TCO 4.2057 ADD GETTAB TABLE 100 FOR HI SEG ORIGIN ONLY.
;<4.UTILITIES>PAT.MAC.42, 19-Oct-78 11:00:22, EDIT BY ALUSIC
;TCO 4.2053 MAKE SLEEP WORK CORRECTLY-DELETE THIBR AT IOWAIT.
;<4.UTILITIES>PAT.MAC.41,  3-Oct-78 11:16:49, EDIT BY HURLEY
;TCO 4.2030 - CHANGE LINE FEED CCOC BITS TO BE 2 INSTEAD OF 3
;<4.UTILITIES>PAT.MAC.40, 21-Sep-78 10:36:37, EDIT BY HELLIWELL
;<4.UTILITIES>PAT.MAC.39, 21-Sep-78 10:29:59, EDIT BY HELLIWELL
;TCO # 4.2018 ADD GETTAB TABLE 5 (.GTKCT). RETURN RUNTIME * 20K
;<4.UTILITIES>PAT.MAC.38, 20-Sep-78 17:37:36, EDIT BY HELLIWELL
;TCO # 4.2017 DON'T COPY JOB DATA AREA TO HIGH SEG IF NOT WRITABLE
;<4.UTILITIES>PAT.MAC.37, 19-Sep-78 10:57:30, EDIT BY HELLIWELL
;TCO # 4.2014 IMPLEMENT GETTABS .GTRDV AND .GTRDI
;TCO # 4.2014 ADD CELLS LOWDEV AND LOWPPN AND MAKE SURE THEY ARE SETUP
;<4.UTILITIES>PAT.MAC.36, 23-Aug-78 08:12:34, EDIT BY MILLER
;CHANGE NAME OF .GTHSN TO GTHSNS
;<4.UTILITIES>PAT.MAC.35, 23-Aug-78 07:57:56, EDIT BY MILLER
;RESTORE TOPAGS AND TOPAGR TO THEIR OLD SELVES.
;<4.UTILITIES>PAT.MAC.34, 18-Aug-78 08:10:01, Edit by KONEN
;TCO 4.1987 - DON'T CLOBBER BYTE COUNT FOR NON-DISK FILES IN EXEC CLOSE
;<4.UTILITIES>PAT.MAC.33,  1-Aug-78 14:52:30, Edit by ALUSIC
;TCO #1964 CALL SETEOF AT UCL3+7 TO SET EOF IN FDB DURING CLOSE OUTPUT
;<4.UTILITIES>PAT.MAC.32, 27-Jul-78 08:09:39, EDIT BY MILLER
;MORE FIXES FOR XON/XOFF
;<4.UTILITIES>PAT.MAC.31, 26-Jul-78 18:51:42, EDIT BY MILLER
;CHANGE TOPAGR TO USE MTOPR TO FETCH THE BIT
;<4.UTILITIES>PAT.MAC.30, 26-Jul-78 18:40:51, EDIT BY MILLER
;CHANGE TOPAGS TO DO XON/XOFF PROPERLY
;<4.UTILITIES>PAT.MAC.23, 21-Jul-78 13:38:34, EDIT BY OSMAN
;CHECK .JIT20 (GETJI) INSTEAD OF LOOKING FOR /EXEC/
;<4.UTILITIES>PAT.MAC.22, 14-Jul-78 13:52:19, EDIT BY HURLEY
;FIXED IO ERROR INDICATION ON DATA ERRORS FROM THE DISK
;<3A.UTILITIES>PAT.MAC.18, 27-Jun-78 23:39:45, Edit by HELLIWELL
;<4.UTILITIES>PAT.MAC.20, 26-Jun-78 15:09:20, Edit by HELLIWELL
;SET TERMINAL MODE ON OPEN OF CONTROLLING TERMINAL
;<4.UTILITIES>PAT.MAC.19, 24-Apr-78 14:40:22, Edit by DBELL
;MAKE TMPBLK LARGER SO ENQ/DEQ CAN HAVE LARGER ARGUMENT BLOCKS
;<4.UTILITIES>PAT.MAC.18, 12-Apr-78 12:26:01, Edit by HELLIWELL
;FIX REMAP TO DEFAULT HI SEG ORIGIN PROPERLY
;<4.UTILITIES>PAT.MAC.17, 11-Apr-78 15:24:17, Edit by HELLIWELL
;ADD MISSING INSTRUCTION AT REMAP1+12
;<4.UTILITIES>PAT.MAC.16, 11-Apr-78 14:38:45, Edit by HELLIWELL
;FIX TYPO IN HI SEG ORIGIN EDIT
;<4.UTILITIES>PAT.MAC.15, 11-Apr-78 14:30:26, EDIT BY HURLEY
;TCO 1899 - FIX MAGTAPE BUFFER SIZE DEFAULTING TO USE JOB DEFAULTS
;<4.UTILITIES>PAT.MAC.14, 11-Apr-78 14:12:06, Edit by HELLIWELL
;FIX MANY BUGS HAVING TO DO WITH HI SEG ORIGIN, INCLUDING REWRITE OF REMAP UUO
;<4.UTILITIES>PAT.MAC.13,  7-Apr-78 16:49:20, EDIT BY HURLEY
;FIX TAPE REWINDS - BOT WAS NEVER BEING CLEARED AT GSTATS
;<4.UTILITIES>PAT.MAC.12,  7-Apr-78 12:37:46, Edit by HELLIWELL
;RETURN TO USER AFTER COMPTG (GTJFN) IF PARSE ONLY
;<4.UTILITIES>PAT.MAC.11,  7-Apr-78 11:27:15, Edit by HELLIWELL
;MUST COPY USER STRING TO STRNG1 BUFFER WHEN STPARS FAILS
;<4.UTILITIES>PAT.MAC.10,  6-Apr-78 16:06:44, Edit by HELLIWELL
;FIX COMPT. FUNCTION 3 TO REQUIRE 4 ARGS FOR PPN TO DIR (INCLUDES DEVICE)
;<4.UTILITIES>PAT.MAC.9,  6-Apr-78 15:38:48, Edit by HELLIWELL
;FIX COMPT. FUNCTION 2 (RENAME) TO REQUIRE ONLY 3 ARGS (2 MORE OPTIONAL)
;<4.UTILITIES>PAT.MAC.8,  6-Apr-78 14:29:40, Edit by HELLIWELL
;AT MTAPE7+6 MOUNT DECTAPE EVEN IF ALREADY HAVE JFN
;IN COMPTG, IF STPARS FAILS, USE USER'S ORIGINAL STRING INSTEAD OF GIVING ERROR RETURN
;IN COMPTG, AVOID DVCHR JSYS IF GJ%OFG ON FOR GTJFN (PARSE)
;UNLABLED EDIT:
;FIX SFMOD THAT USESE 770000 INSTEAD OF 170000
;<4.UTILITIES>PAT.MAC.5, 28-Feb-78 16:23:27, Edit by DBELL
;IMPLEMENT FUNCTION 10 OF FILOP. - UPDATE "RIBS"
;<4.UTILITIES>PAT.MAC.4, 28-Feb-78 15:55:57, Edit by BORCHEK
;fix enter returning error in wrong place
;<4.UTILITIES>PAT.MAC.3, 14-Feb-78 17:37:24, EDIT BY HURLEY
;CHANGED TM.ASC TO BE 1B29
;<4.UTILITIES>PAT.MAC.2, 29-Jan-78 18:09:54, Edit by BORCHEK
;DON'T SET INIT BIT FOR LPT AT DEVCHZ
;<4.UTILITIES>PAT.MAC.1, 23-Jan-78 12:01:39, EDIT BY HELLIWELL
;FIX PROTECTION TRANSLATION AT ULK2L, TEST FOR LEAST PROTECTION
;TTYSET NOW CALLED IN OPEN ROUTINE BECAUSE RFMOD CAN'T BE DONE UNTIL OPEN

	TITLE PAT - 10/50 COMPATIBILITY FOR TOPS20
	SEARCH MONSYM,MACSYM
	IFNDEF .PSECT,<
	.DIRECT .XTABM>

.GROUP==0	;GROUP WHO LAST MODIFIED PROGRAM
.MAJOR==5	;MAJOR VERSION NUMBER
.MINOR==1	;MINOR VERSION LETTER
	RADIX 10
.EDIT==447	;EDIT NUMBER
	RADIX 8


;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1976,1977,1978,1979,1980,1981,1982,1983
; BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.


PATVER==:<BYTE (3).GROUP(9).MAJOR(6).MINOR(18).EDIT>	;EDIT NUMBER STORED IN PVLOC
SUBTTL DEFINITIONS AND ALLOCATION

COMMENT \

THIS CODE RESIDES IN A HIGH AREA OF USER CORE (CURRENTLY 700000).
IT IS LOADED FROM THE SSAVE FILE SYS:PA1050.EXE BY THE
MONITOR WHENEVER A FORK EXECUTES ITS FIRST 10/50 UUO (40-77, BUT NOT 0).
THE FIRST TIME, ENTRY IS VIA THE SECOND LOCATION OF THE ENTRY VECTOR.
THEREAFTER, 10/50 UUO'S RESULT IN AN IMMEDIATE TRANSFER TO
THIS CODE VIA THE FIRST LOCATION OF THE ENTRY VECTOR.  WHEN
ANY 10/50 UUO IS EXECUTED, THE MONITOR MOVES LOCATION 40 TO
MONUUO (SPECIFIED BY FOURTH WORD OF ENTRY VECTOR), AND THE RETURN
 PC TO MONUPC (SPECIFIED BY FIFTH WORD OF ENTRY VECTOR).  THIS CODE
INTERPRETS THE UUO AND RETURNS DIRECTLY TO THE USER PROGRAM.

THIS CODE USES THREE OF THE RESERVED UUO'S (42-44) FOR INTERNAL
PURPOSES.

ASSEMBLY AND LOADING PROCEDURE:

@LOAD PAT
@START
@

THE START AFTER LOADING CAUSES THE CODE TO BE MOVED FROM ITS LOAD
LOCATION TO ITS RUNNING LOCATION IN HIGH CORE.  THE SYMBOL
TABLE IS ALSO MOVED, AND THE POINTER ADJUSTED.  AN SSAVE FILE
OF PAGES 700-777 SHOULD BE MADE TO BE USED FOR DEBUGGING.

TO PRODUCE THE SYSTEM FILE, START AT MAKEPF (MAKEPF$G).  THIS WILL
WRITE A SSAVE FILE WITH WRITE PROTECTION INTO THE SPECIFIED FILE.

FOR DEBUGGING COMPATIBILITY PACKAGE, FIRST RESET, AND GET
THE TEN-50 PROGRAM TO BE USED FOR TESTING, IF ANY.
THEN, MERGE AN SSAVE FILE (WITH DDT AND SYMBOLS) OF THE
DEBUG VERSION OF PAT, TYPE DDT, THEN DEBUG$G TO SET UP THE
COMPATIBILITY VECTOR, PSI SYSTEM, AND TEMPORARY STORAGE.

NOTES ON ^C TRAPPING: PAT WAS ORIGINALLY DESIGNED TO ALLOW A USER TO
BREAK THROUGH ^C TRAPS. IF THIS IS NOT DESIRED, THE TRAP CAN BE MADE
SAFER BY SETTING MAXFRU TO -1 AND FTBKCC TO 0.
\

;INTERNAL UUO'S

OPDEF PJRST [JRST]

OPDEF CALL[40B8]		;10/50 CALL UUO

	DEFINE UMOVE (A,B)<
		PUSHJ P,UXCT
		MOVE A,B>

	DEFINE UMOVEM (A,B)<
		PUSHJ P,UXCT
		MOVEM A,B>

	DEFINE XCTUU (A)<
		PUSHJ P,UXCT
		A>

	DEFINE XCTU2 (A)<
		PUSHJ P,UXCT2
		A>

	DEFINE XCTUM (A)<
		PUSHJ P,UXCT
		A>

	DEFINE XCTMU (A)<
		PUSHJ P,UXCT
		A>

	DEFINE XCTLB (A)<
		PUSHJ P,LBXCT
		A>

	DEFINE XJSYS (INST) <
	PUSHJ P,DOJSYS
	INST>

	DEFINE IJSYS (INST)<
	JSP EE,INJSYS
	INST>

;MACRO TO REFERENCE PAGE NUMBER WITHIN ADDRESS

DEFINE PAGEN (LOC)<POINT 9,LOC,26>

;TYPEOUT MACRO AND FRIENDS
.NUL==0		;NO TYPEOUT AHEAD OF MESSAGE
.CR==1		;TYPE A <CR> FIRST
.CRQ==2		;<CR> AND ? FIRST
.CRP==3		;<CR> AND % FIRST

.NOREF==0

	DEFINE TMSG (MSG)
<	TMSGS	.NUL,<MSG>
>

	DEFINE	TMSGS(LD,MSG<>,%FOO)
<	PUSHJ	P,TMSGQ
	 %%R==<-1,,[ASCIZ ~MSG~] >
	 %%Q==<XWD LD,0>
	IFN %%Q,<		;;LONG FORM
	 JRST	%FOO
	 EXP	%%R
	 EXP	%%Q>
	IFE %%Q,<		;;SHORT FORM
	 TRNA	0
	 EXP	%%R>
%FOO:>

IFNDEF FTSTAT,<FTSTAT==0>	;KEEP STATISTICS OF PA1050 USAGE
IFNDEF FTFILSER,<FTFILSER==0>	;USE FILSER FOR DEVICE DPA
;**;[374] At IFNDEF FTFILSER, Added 1 line           	SM	 7-Dec-81
IFNDEF FTBKCC,<FTBKCC==-1>	;ALLOW BREAK TO ACT LIKE ^C^C
	FTDEB==0		;0 OR -1 ONLY (-1 FOR ON)

	RETRY==6		;TIMES TO RETRY ON A MACHINE-SIZE EXCEEDED ERR

	MLON
	SALL

;ACCUMULATOR DEFINITIONS

PF=0		;PAT'S FLAG AC
A=1		;FIRST AC'S ARE TEMPS AND JSYS ARGS
B=2
C=3
D=4
E=5
F=6
G=7
AA=10		;CONTAINS DEVICE NUMBER DURING I/O UUO HANDLING
BB=11		;HOLDS BASE OF I/O CHANNEL DATA BLOCK DURING ...
CC=12		;HOLDS ADDRESS OF CURRENT RING BUFFER IN I/O
AC=13		;AC NUMBER IN TEN-FIFTY UUO
CAC=14		;CONTENTS OF THAT AC. LOADED ON ALL UUOS.
EE=15		;EE AND FF ARE USED BY UMOVE AND UMOVEM WITHOUT SAVING
FF=16		; IF USED, BE AWARE THAT THEY WILL BE CHANGED ON UMOVE'S
P=17

;FLAGS IN AC PF. LEFT HALF ARE PERMANENT (HOLD OVER USER PROG)
; RIGHT HALF ARE MEANINGFUL ONLY WITHIN A GIVEN UUO, CLEARED ON ENTRY

R.CLS==1	;FLAG SET DURING CLOSE AND TESTED IN OUTPUT TO AVOID
		;OUTPUTTING 0 LENGTH RECORDS.
R.DIRN==2	;DIRECTION OF TRANSFER IN MTA, USET
R.RUNU==4	;DISTINGUISH RUN UUO FROM GETSEG UUO
R.UEXT==10	;EXTENDED LOOKUP OR ENTER FLAG
R.EXIT==20	;ON FOR EXIT 1, ; OFF FOR EXIT 0, .
R.NOWC==40	;DONT COMPUTE WORD COUNT FOR BUFFER. THERE IS DATA THERE
R.FERR==100	;FATAL ERROR. PREVENTS PMAPPING PAT OUT OF EXISTANCE
R.KJFN==200	;KEEP JFN IN CLOSE ROUTINE.
R.RHLT==400	;RUN OR GETSEG UUO FOLLOWED BY HALT (DON'T RETURN)
R.SYS==1000	;RUN UUO FROM SYS, SO DO SETNM
R.ENT==2000	;DOING AN ENTER, SET PROTECTION FIELD
R.CMR==4000	;CMRETN RETURN FOR STATISTICS GATHERING
R.CVF==10000	;FLAG TO CAUSE CONTROL-V'S TO GO INTO ASCII STRINGS
R.CVC==20000	;FLAG TO MARK THAT A PARTICULAR CHARACTER SHOULD BE QUOTED
R.EXP==40000	;AN EXPUGE WAS DONE DURING THIS UUO, DONT DO ANOTHER
R.ILLJ==100000	;DOING AN XJSYS, DONT TYPE ILL INST
R.SUIC==200000	;COMMITTING SUICIDE
;**;[376] At R.SUIC, Added 1 line                	SM	25-Jan-82
R.SU2==R.ENT	;[376] On a suicide, don't touch VESTigals (REUSE R.ENT)
;**;[345] CREATE NEW TEMPORARY FLAG
R.FLP==400000	;[345] FILOP. UUO IN PROGRESS

L.DBUG==1	;DEBUGGING PAT ITSELF
L.ONCE==2	;HAVE BEEN THRU ONCE CODE
L.INDF==4	;INDICATE FF BY ^L REQUESTED AT EXEC LEVEL, SO DO SO.
L.GSTA==20	;<SYSTEM>PA1050.STATISTICS WAS FOUND, DO GENERAL STATISTICS
L.LSTA==40	;PA1050.STATISTICS WAS FOUND, DO LOCAL STATISTICS
L.FLSR==100	;FILSER HAS BEEN LOADED INTO ADDRESS SPACE
L.TFA==200	;TTY FORK FOR HIBERNATE IS NOW ACTIVE
L.NCCE==400	;CONTROL-C CANNOT BE ENABLED
L.SMAL==1000	;SMALL SYSTEM (LESS THAN 196K)
L.UPDT==(1B1)	;[356] Put a file into update mode in ENTER UUO processing
		;[356] This is used by FILOP. to force update mode

;CHARACTERS REFERENCED SYMBOLICALLY
C.CC==3		;CONTROL-C CHARACTER
C.BELL==7	;BELL CHARACTER
C.TAB==11	;TAB
C.LF==12	;LINE FEED
C.FF==14	;FORMFEED CHARACTER
C.CR==15	;CARRIAGE RETURN
C.EOF=="Z"-100	;CONTROL-Z, END-OF-FILE FOR TTY
STDALT==33	;10/50'S STANDARD ALTMODE CHARACTER
ALT1==175	;NON-STANDARD ALTMODE
ALT2==176	;ANOTHER NON-STANDARD ALTMODE

C.RTYP=="R"-100	;RETYPE THE CURRENT LINE COMMAND
C.DELC==177	;SINGLE-CHARACTER DELETE (RUBOUT)
C.DELL=="U"-100	;LINE (BUFFER) DELETE (^U)
C.CNTV=="V"-100	;CONTROL-V HARACTER FOR QUOTING

;DEVICE DESIGNATOR DEFINITIONS

DSK==0
DRM==1
MTA==2
DTA==3
PTR==4
PTP==5
DIS==6
LPT==7
CDR==10
CDP==11
TTY==12
PTY==13
NIL==15
PLT==17

	;[356] TOPS-10 LOOKUP/ENTER/RENAME/FILOP. ERROR RETURNS

	FNFERR==0		;[356] FILE NOT FOUND
	IPPERR==1		;[356] INCORRECT PPN
	PRTERR==2		;[356] PROTECTION FAILURE
	FBMERR==3		;[356] FILE BEING MODIFIED
	AEFERR==4		;[356] ALREADY EXISTING FILE NAME
	ISUERR==5		;[356] ILLEGAL SEQUENCE OF UUOS
	TRNERR==6		;[356] TRANSMISSION ERROR
	NSFERR==7		;[356] NOT A SAVE FILE
	NECERR==10		;[356] NOT ENOUGH CORE
	DNAERR==11		;[356] DEVICE NOT AVAILABLE
	NSDERR==12		;[356] NO SUCH DEVICE
	ILUERR==13		;[356] ILLEGAL UUO
	NRMERR==14		;[356] NO ROOM
	WLKERR==15		;[356] WRITE LOCKED
	NETERR==16		;[356] NOT ENOUGH TABLE SPACE
	POAERR==17		;[356] PARTIAL ALLOCATION ERROR
	BNFERR==20		;[356] BLOCK NOT FREE
	CSDERR==21		;[356] CAN NOT SUPERSEDE A DIRECTORY
;ARGUMENT BLOCK FOR FILOP.

;;[356]  !=========================================================================!
;;[356]  !UP!                                  !           FUNCTION CODE           !
;;[356]  !-------------------------------------------------------------------------!
;;[356]  !                                I/O MODE                                 !
;;[356]  !-------------------------------------------------------------------------!
;;[356]  !                           DEVICE NAME OR UDX                            !
;;[356]  !-------------------------------------------------------------------------!
;;[356]  !        OUTPUT BUFFER HEADER        !        INPUT BUFFER HEADER         !
;;[356]  !-------------------------------------------------------------------------!
;;[356]  !      NUMBER OF OUTPUT BUFFERS      !      NUMBER OF INPUT BUFFERS       !
;;[356]  !-------------------------------------------------------------------------!
;;[356]  !        PTR TO RENAME BLOCK         !        PTR TO LOOKUP BLOCK         !
;;[356]  !-------------------------------------------------------------------------!
;;[356]  !        LENGTH OF PATH BLOCK        !         PTR TO PATH BLOCK          !
;;[356]  !-------------------------------------------------------------------------!
;;[356]  !           PROJECT NUMBER           !        PROGRAMMER NUMBER           !
;;[356]  !=========================================================================!

;[356] OFFSETS IN ARGUMENT BLOCK
.FOFNC==0	;[356] FUNCTION (AND FLAGS)
.FOIOS==1	;[356] I/O STATUS (OPEN MODE)
.FODEV==2	;[356] DEVICE
.FOBRH==3	;[356] BUFFER RING HEADER POINTERS
.FONBF==4	;[356] NUMBER OF BUFFER TO BUILD
.FOLEB==5	;[356] PTR TO RENAME,,LOOKUP/ENTER BLOCK (SEE .RB??? SYMBOLS)
.FOPAT==6	;[356] PTR TO PATH BLOCK (SEE .PT??? SYMBOLS)
.FOPPN==7	;[356] (PRIVILEGED) IN-YOUR-BEHALF PPN

;[356] FLAGS IN .FOFNC
FO.PRV==1B0	;[356] JOB IS JACCT OR [1,2] AND WANT TO USE PRIVS
FO.ASC==1B1	;ASSIGN AN EXTENDED CHANNEL NUMBER

;[356] FUNCTION CODES
.FORED==1	;[356] READ ONLY
.FOCRE==2	;[356] CREATE (NEW FILE ONLY)
.FOWRT==3	;[356] WRITE (CREATE OR SUPERCEDE)
.FOSAU==4	;[356] SINGLE ACCESS UPDATE
.FOMAU==5	;[356] MULTI-ACCESS UPDATE
.FOAPP==6	;[356] APPEND
.FOCLS==7	;[356] CLOSE (OPTIONAL FLAGS IN .FOIOS, SEE CL.???)
.FOURB==10	;[356] UPDATE RIB
.FOUSI==11	;[356] USETI
.FOUSO==12	;[356] USETO
.FORNM==13	;[356] RENAME
.FODLT==14	;[356] DELETE
.FOPRE==15	;[356] PREALLOCATE
REPEAT 0,<	;NOT YET IMPLEMENTED
.FOSIO==16	;SUPER I/O
.FOINP==17	;INPUT
.FOOUT==20	;OUTPUT
.FOSET==21	;SETSTS
.FOGET==22	;GETSTS
.FOREL==23	;RELEASE
.FOWAT==24	;WAIT
.FOSEK==25	;SEEK
.FORRC==26	;REWRITE RIB
>
;ARGUMENT BLOCK FOR COMPT. UUO FUNCTION 1 AND 13

;  !=========================================================================!
;  !      CHANNEL                        !           FUNCTION CODE           !
;  !-------------------------------------------------------------------------!
;  !                             AC1 GTJFN BITS                              !
;  !-------------------------------------------------------------------------!
;  !                             AC2 GTJFN BITS                              !
;  !-------------------------------------------------------------------------!
;  !                             AC1 OPENF BITS                              !
;  !-------------------------------------------------------------------------!
;  !                               OPEN MODE                                 !
;  !-------------------------------------------------------------------------!
;  !                       INPUT BUFFER HEADER ADDRESS                       !
;  !-------------------------------------------------------------------------!
;  !                      OUTPUT BUFFER HEADER ADDRESS                       !
;  !-------------------------------------------------------------------------!
;  !                      ADDRESS FOR EXTENDED FUNCTION                      !
;  !-------------------------------------------------------------------------!
;  !      NUMBER OF OUTPUT BUFFERS      !      NUMBER OF INPUT BUFFERS       !
;  !=========================================================================!

;OFFSETS IN ARGUMENT BLOCK FOR FUNCTION 1 AND 13
.CMPCH==0	;CHANNEL # (LHS)
.CMPFN==0	;FUNCTION (RHS)
.CMPG1==1	;AC1 GTJFN BITS
.CMPG2==2	;AC2 GTJFN BITS
.CMPO2==3	;AC2 OPENF BITS
.CMPOM==4	;OPEN MODE
.CMPIB==5	;INPUT BUFFER HEADER ADDRESS
.CMPOB==6	;OUTPUT BUFFER HEADER ADDRESS
.CMPXF==7	;ADDRESS OF RIB FOR EXTENDED FUNCTION (MUST BE 4 WORDS OR MORE)
.CMPNB==10	;NUMBER OF OUTPUT BUFFERS ,, NUMBER OF INPUT BUFFERS

;FUNCTION CODES
.CMOPN==1	;FUNCTION 1, OPEN, LOOKUP, AND ENTER
.CMRNM==2	;FUNCTION 2, RENAME
.CMDIR==3	;FUNCTION 3, PPN TO DIRECTORY
.CMRUN==4	;FUNCTION 4, RUN
.CMJFS==5	;FUNCTION 5, JFNS
.CMPSI==6	;FUNCTION 6, SET UP PSI CHANNEL
.CMERS==7	;FUNCTION 7, ERSTR
.CMCHN==10	;FUNCTION 10, GET JFN OF CHANNEL
.CMSUI==11	;FUNCTION 11, COMMIT SUICIDE AND RETURN
.CMVST==12	;FUNCTION 12, LIKE 11 BUT LEAVE VEST ALONE!
.CMAPP==13	;FUNCTION 13, OPEN EXTEND (APPEND)
;10/50 JOB AREA LOCATIONS

JOBPD1==45
JOBS41==122

.JBUUO=40
.JBERR=42
.JBREL=44
.JBDDT=74
.JBHSO=75
.JBPFI=114
.JBHRL=115
.JBSYM=116
.JBUSY=117
.JBSA=120
.JBFF=121
.JBREN=124
.JBAPR=125
.JBCNI=126
.JBTPC=127
.JBOPC=130
.JBCOR=133
.JBINT=134
.JBVER=137
.JBDA=140

.JBHSA==0
.JBH41==1
.JBHCR==2
.JBHRN==3
.JBHVR==4
.JBHNM==5
.JBHSM==6
;     ==7
.JBHDA==10			;NEEDED DURING ASSEMBLY

;FLAGS IN RH OF FLAGWD

IO.BIN==10		;BINARY MODE
IO.FCS==100		;FULL CHARACTER SET
IO.SUP==200		;SUPPRESS ECHOING
IO.TEC==400		;TRUTH IN ECHOING MODE
IO.IMP==400000		;IO IMPROPER MODE

;FLAGS IN LH OF FLAGWD IN CHANNEL DATA TABLES (CHTABS)

RNDMF==1	;FILE IS BEING READ RANDOMLY
MTABFS==1	;MTA BUFFERS ARE SET UP
PTYCRF==2	;LAST CHAR SENT TO PTY WAS A <CR>
MTALTW==2	;LAST MAGTAPE TRANSFER WAS A WRITE
PTYCWF==4	;PTY IS WAITING FOR ^C TO TAKE EFFECT
DTACLS==PTYCWF	;DTA JFN WAS CLOSED FOR ANOTHER CHANNEL TO RUN
MTADMS=PTYCWF	;DATA MODE WAS SET ON MTA
RDMFDF==10	;READING MFD, SIMULATE WITH DIRST
RDUFDF==20	;READING UFD, SIMULATE WITH GNJFN
UFDEOF==40	;NO MORE FILES IN DIRECTORY DURING UFD SIMULATION
DTADMP==100	;DTA HAS BEEN OPENED IN DUMP MODE
ENTERF==200
INBUFF==400
IOPENF==1000
LOOKPF==2000
OOPENF==4000
DTAMF==10000	;DTA IS MOUNTED AND DIRECTORY WAS READ
MTARDB==DTAMF	;MAGTAPE READS ARE BACKWARDS
OUTBFF==20000
INFIRF==40000
OUFIRF==100000
INITF==200000


;FLAGS IN LH OF TYSTAT AND LH OF FLAGWD FOR TTY'S ONLY

TT.BIN==PTYCRF		;TTY IS IN BINARY MODE FLAG
TT.CTY==PTYCWF		;TTY IS CONTROLING TTY FOR THIS JOB
TT.ALT==RDMFDF		;USER WANTS NO ALT MODE CONVERSION
TT.GAG==RDUFDF		;DONT TYPE MESSAGES TO USER TTY
TT.XON==UFDEOF		;TTY IN TAPE MODE, NO LF AFTER CR
TT.BKE==DTADMP		;TTY BREAK ON EVERYTHING

;TTY MODE DEFINITIONS

	TM.ECH==3B25		;ECHO FIELD
	TM.IOD==2B25		;IMMEDIATE OR DEFERRED MODE
	TM.WAK==17B23		;ALL TTY WAKE BITS
	TM.BKE==17B23		;BREAK ON EVERYTHING
	TM.FWK==14B23		;FORMAT CONTROLS WAKE
	TM.FCS==14B23		;FORMAT AND NON-FORMAT CONTROLS
	TM.GAG==1B26!1B27	;ADVISE AND LINK
	TM.ASC==1B29		;ASCII OR BINARY
	TM.ATE==3B29		;(320) disable translation on output

;FLAGS FOR DEVICE CHARACTERISTICS

HASDIR==4			;DEVICE HAS DIRECTORY
MTADEV==20			;DEVICE IS MAGTAPE
DTADEV==100			;DEVICE IS DECTAPE
PTRDEV==200			;DEVICE IS PAPERTAPE READER
PTPDEV==400			;DEVICE IS PAPERTAPE PUNCH
TTYDEV==1B32
DSKDEV==200000			;DEVICE IS DISC

MAXERR==10			;RETRIES WHEN READING MAGTAPE
USRLVL==3			;LEVEL PERMITTED FOR COMPAT FUNCTION 6
USRMXC==2			;[356] MAXIMUM CHANNEL AVAILABLE FOR COMPAT 6

.HSLOC=400000			;DEFAULT (NORMAL) HISEG LOCATION
DDTLOC=770000			;START ADDRESS OF DDT
MAXPAT==764000			;FIRST ADDRESS WE CAN'T USE
B18==400000			;HANDY ABBREVIATION FOR SIGN BIT
TTYDSG==400000			;TTY DESIGNATOR FORMAT

MAXIOL==7000			;BIGGEST DUMP I/O LIST TOPS-20 WILL BUY

MAXFRU==3			;# OF ^C'S BEFORE BOMBING PAT

WHEEL==1B18			;PROCESS CAPABILITY BIT
OPER==1B19			;PROCESS CAPABILITY BIT
MAINT==1B21			;PROCESS CAPABILITY BIT
PRIJFN==100			;PRIMARY INPUT JFN
PROJFN==101			;PRIMARY OUTPUT JFN

PPNLH==4			;LH OF PPN RETURNED BY GETPPN AND GETTAB
MAXDIR==^D1000			;# OF ILLEGAL DIR'S BEFORE EOF
STDPRT=005000,,0		;STANDARD FILE PROTECTION

FDBCTL==1			;FILE DESCRIPTOR BLOCK DEFINITIONS
FDBPRT==4
FDBVER==7
FDBBYV==11
FDBSIZ==12
FDBCRV==13
FDBWRT==14			;LAST WRITE OF FILE
FDBREF==15
FDBDEL==1B3

DV.DSK==1B1			;DEVICE CHARACTERISTICS BITS
DV.LPT==1B3			;DEVICE CHARACTERISTICS BITS

;GET THE 10/50 UUO'S INTO THE SYMBOL TABLE FOR DEBUGGING PAT
X==0

DEFINE RDEFS,<
REDEF <CALL,INIT,X,X,X,X,X,CALLI,OPEN,TTCALL,X,X,X,RENAME,IN,OUT,SETSTS,STATO>
REDEF <GETSTS,STATZ,INBUF,OUTBUF,INPUT,OUTPUT,CLOSE,RELEAS>
REDEF <MTAPE,UGETF,USETI,USETO,LOOKUP,ENTER,X>
>

DEFINE REDEF(A)<IRP A,<A=:EXP <A>>>

RDEFS

	DEFINE SYSGET (X)<
		MOVE A,[SIXBIT /X/]
		SKIPN B,X	;HAVE WE GOTTEN THIS ALREADY?
		  SYSGT		;NO, GO GET IT
		MOVEM B,X	;STORE IT FOR FUTURE USE
>

	DEFINE SYSGTA (X)<
		SKIPE A,X
		  JRST .+3
		MOVE A,[SIXBIT/X/]
		SYSGT
		MOVEM A,X
>

;CORE ASSIGHMENTS
;FIRST FOR THE CODE.

PATLOC=:700000			;PLACE WHERE COMPATIBILITY ACTUALLY RUNS
PATPAG==:PATLOC_<-^D9>		;AND AS A PAGE NUMBER TO GET THRU LOADER
FLSRLC=:600000			;START ADR OF FILSER DATA BASE
FLSRPG==:FLSRLC_<-^D9>		;PAGE NUMBER OF START OF FILSER
LODORG==400000			;WHERE THE LOADER WILL LEAVE "HI SEGMENT"

;STORAGE ALLOCATOR FOR TEMP STORAGE

	DEFINE ALC(NAM,SIZ)
	<	NAM=:LC
LC==LC+SIZ
>

;VARIABLE STORAGE FOR PAT

	PATVAR==732		;[356] STORAGE AREA FOR PAT VARIABLES
	TMPPAG==PATVAR		;PAGE FOR TMPCOR DATA BASE FILE
IFE FTSTAT,<STATLP==TMPPAG	;NO STATISTICS PAGE
	    STATGP==TMPPAG>	;NO SYSTEM STATISTICS PAGE
IFN FTSTAT,<STATLP==TMPPAG+1	;DEFINE STATISTICS PAGE
	    STATGP==STATLP+1>	;DEFINE SYSTEM WIDE STATISTICS PAGE
	LC==<STATGP+1>_11	;START OF TEMPORARY PAGES
IFN FTSTAT,<
	STATLC==STATLP_11	;ADDRESS OF LOCAL STAISTICS PAGE
	STATGC==STATGP_11	;ADDRESS OF SYSTEM WIDE STATISTICS PAGE
	STATFW==ST.X_^D24!ST.Y_^D12!ST.Z	;FORMAT WORD
	ST.X==4			;LENGTH OF MISC TABLE
	ST.Y==200		;LENGTH OF CALLI TABLE
	ST.Z==100		;LENGTH OF GETTAB TABLE
	ST.FMT==0		;WHERE TO STORE FORMAT WORD
	ST.TCL==1		;1-20 IS FOR TTCALL'S
	ST.UUO==21		;21-60 IS FOR UUO'S
	ST.VER==61		;COMPATIBILITY PACKAGE VERSION #
	ST.ONC==62		;# OF TIMES THRU ONCE CODE
	ST.UNI==63		;# OF UNIMPLEMENTED CALLI'S EXECUTED
	ST.UEI==64		;# OF UNEXPECTED INTERRUPTS IN PAT
	ST.CLI==61+ST.X		;61+X TO 60+X+Y IS FOR CALLI'S
				;60+X+Y DOWN IS FOR NEGATIVE CALLI'S
	ST.GTB==61+ST.X+ST.Y	;61+X+Y TO 60+X+Y+Z IS FOR GETTAB'S

	ST.TIM==60+ST.X+ST.Y+ST.Z	;OFFSET FOR TIMMING STATISTICS
>

DEFINE STAT(A,B,C)
<IFN FTSTAT,<
	TLNN PF,L.LSTA		;LOCAL STATISTICS WANTED?
	  JRST .+3		;NO, DONT REFERENCE THE PAGE
	AOS STATLC+C(A)		;EXECUTION COUNTER
	ADDM B,STATLC+ST.TIM+C(A) ;INCREMENT TIME SPENT IN UUO
	TLNN PF,L.GSTA		;GLOBAL STATISTICS WANTED?
	  JRST .+3		;NO, DONT REFERENCE PAGE
	AOS STATGC+C(A)		;SYSTEM WIDE COUNTER
	ADDM B,STATGC+ST.TIM+C(A) ;SYSTEM STATISTICS FOR UUO TIMMINGS
>>

	FILPAG==600		;FILSER STARTS AT PAGE 600
	FILEND==677		;HIGHEST PAGE OF FILSER DATA BASE

	TSLOC==LC

	ALC CHTABS,0
	ALC JFNTAB,1		;ONLY NEEDS 7 BITS
	ALC LABDAT,15		;FOR CHECKING TAPES FOR LABELS, ETC.
	ALC MAPTAB,1		;MAPPING INFO FOR DISK FILES
	ALC BUFHTB,1		;OUTPUT AND INPUT BUFFER HEADERS
	ALC FLAGWD,1		;INTERNAL FLGS,,FILE STATUS
	ALC DEVNUM,1		;DEVICE DESIGNATOR OF THIS DEVICE,
				;  FILLED IN BY INIT
	ALC DEVNAM,1		;SIXBIT DEVICE NAME FROM USER
	ALC FILNAM,1		;SIXBIT FILE NAME FROM USER
	ALC EXT,1		;SIXBIT FILE EXT (3 CHARS) FROM USER
	ALC DIRNUM,1		;DIRECTORY NUMBER
	ALC PROT,1		;PROTECTION VALUE (TOPS-20 STYLE)

	ALC IOBYTP,1		;POINTER TO NEXT WORD IN FILE
	ALC NOMFDC,0		;# OF ILLEGAL DIR NUMBERS PASSED OVER
	ALC IOEOFP,1		;POINTER TO EOF FOR DISK FILES
	ALC MTADAT,0		;MAGTAP INFORMATION (DEFSTR'S BELOW)
	ALC MFDPT,1		;DIRECTORY COUNT FOR MFD READING

	NTABS==LC-CHTABS
	MAXCHN==17		;HIGHEST REGULAR CHANNEL
	ALC CHTABN,<MAXCHN*NTABS>

	ALC HIBWRD,1		;LAST HIBERNATE FLAGS
	ALC WAKEF,1		;-1 = AN EVENT OCCURED FORCING HIBER TO WAKE UP
	ALC IOWATF,1		;WAITING FOR IO TO HAPPEN
	ALC SAVMOD,1		;SAVED TELETYPE MODE
ALC CHTEND,0			;ABOVE HERE CLEARED BY CALLI 0.

;MAGTAP DEFSTRS

	DEFSTR (MTADEN,MTADAT(BB),35,4) ;DENSITY
	DEFSTR (MTADM,MTADAT(BB),31,4)  ;DATA MODE
	DEFSTR (MTABYT,MTADAT(BB),27,6)	; [357] OPEN BYTE SIZE (^D36 MAX)

	ALC JOB,1		;TSS JOB #
	ALC NJOBS,1		;NUMBER OF JOBS
	ALC HGHSGN,1		;NUMBER OF THE HIGH SEG FOR THIS JOB
IFN FTFILSER,<
	ALC TOPNBL,3		;OPEN BLOCK FOR FILSER
>
	ALC CCIENB,1		;CONTROL-C INTERCEPT IS ENABLED
	ALC CCIFLG,1		;CONTROL-C INTERCEPT IS IN PROGRESS
	ALC FRUSTC,1		;NUMBER OF TIMES ^C HAS BEEN HIT
	ALC FIRPTY,1		;FIRST PTY IN TTYJOB TABLE (SETUP BY ONCE)
	ALC TTINPT,1		;PUTTER POINTER FOR TTCALL BUFFER
	ALC TTOUPT,1		;GETTER POINTER FOR TTCALL BUFFER
	ALC TTCNT,1		;BYTE COUNT,TTCALL INPUT BUFFER
	ALC OTTCNT,1		;NUMBER OF CHARS IN LAST LINE (FOR TTCALL 10)
	TTMAXC==100*4		;MAXIMUM # OF CHARS IN TTBUF
	ALC TTBUF,100		;TTCALL INPUT BUFFER
	ALC TTBUFE,0		;END OF TTBUF
	ALC TTLINE,1		;LINE PRESENT FOR TTCALL
;**;[367] At ALC TTLINE+1, Replaced 1 line with 2   	SM	16-Sep-81
	ALC TTSTI,12		;[367] STORAGE FOR TTY INFO ON ENTRY
	ALC TTSTO,12		;[367] DITTO FOR TTY INFO ON EXIT
	ALC DEVNM7,2		;SEVEN BIT DEVICE NAME
	ALC FILNM7,3		;SEVEN BIT FILE NAME (LEAVE ROOM FOR ^V'S)
	ALC EXT7,2		;SEVEN BIT EXTENSION
	ALC SEE,1		;SAVE EE AND FF DURING MYUUO'S
;**;[370] At ALC SEE+1, Added 1 line                  	SM	 1-Oct-81
	ALC DVTMP,2		;[370] AC STORE ON DEVCHR TTY CHECK
;**;[406] At ALC SEE +2L, Inserted 1 line                      SM 16-Nov-82
	ALC TMSTMP,2		;TEMP FOR TMSGQ
	ALC BUFFER,2
	ALC IAC,20		;AC'S ON INTERRUPT
	ALC ASAVE,1		;TEMPORARY STORAGE AT INTERRUPT LEVEL

IFN FTSTAT,<
	ALC NCALLI,1		;NUMBER OF THE CALLI UUO BEING DONE
>

	ALC IOBPT,1		;BYTE POINTER FOR IN AND OUT
	ALC IOCNT,1		;COUNT FOR IN AND OUT

TMPBKL==^D120			;LENGTH OF TMPBLK
	ALC TMPBLK,TMPBKL	;TEMP BLOCK, USED FOR ENQ/DEQ
BLLEN==30
	ALC STRNG1,BLLEN	;TEMP STRING STORAGE (LARGE ENOUGH FOR GETJI BLOCK)
				;ALSO USED AS STACK IN CSTART ROUTINES
	ALC DIRNAM,12		;STRING SPACE FOR A DIRECTORY NAME
	ALC FDBB,22
	ALC LABBLK,15		;[353] TEMP TO SAVE MTA LABEL INFORMATION
	ALC JBLOCK,14		;FOR JFN ARG LIST

;**;[366] At ALC JBLOCK +2L, Added 1 line            	SM	10-Sep-81
	ALC MTOPIN,.MODVT+2	;[366] STORE FOR MTOPR INFO (.MOSTA)
;**;[432] AT ALC JBLOCK +3L, modify 2 lines		DSW	6-MAR-85
;**;[437] AT ALC JBLOCK +3L, modify 2 lines		DSW	20-MAY-85
	ALC RETSAV,1		;[432][437] RETURN SAVED BY PSEUDOINTERRUPT
	ALC LV2SAV,1		;[432][437] LEVEL 2 PC SAVE WORD
	ALC CNIWRD,1		;SAVES OV EN AND FOV EN FOR APR CONI
	ALC HSORG,1		;ORIGIN OF HISEG (ADDRESS)
	ALC JBREL,1		;SAVED .JBREL
	ALC JBHRL,1		;SAVED .JBHRL
	ALC JBDDT,1		;COMPATIBILITY'S COPY OF .JBDDT
	ALC LOWNAM,1		;NAME OF JOB AS SET BY RUN OR SETNAM UUOS
	ALC LOWDEV,1		;DEVICE FROM WHICH LOW SEG CAME
	ALC LOWPPN,1		;PPN OF LOW SEG
	ALC SEGNAM,1		;NAME OF JOB'S HIGH SEGMENT
	ALC SEGDEV,1		;DEVICE FROM WHICH HIGH SEG CAME
	ALC SEGPPN,1		;PPN OF HIGH SEG

	ALC USRENB,1		;WHAT USER ASKED FOR ON LAST APRENB UUO
;**;[432] AT ALC JBLOCK +17L, INSERT 1 LINE	DSW	6-MAR-85
;**;[437] AT ALC JBLOCK +17L, REMOVE 1 LINE	DSW	20-MAY-85
	ALC DMPLST,2		;MTA IO BY DUMP COMMANDS HERE
	ALC STRRET,1		;INDEX FOR COMPT. UUO TO RETURN GTJFN STRING AND POINTER
	ALC MTDUMP,1		;TEMP IN DUMP I/O
	ALC SPDELC,1		;TEMP IN DUMP I/O
	ALC TMPJFN,1		;JFN OF TMPCOR FILE
	ALC FLSJFN,1		;JFN OF FILSER DATA BASE FILE
	ALC TTYFRK,1		;FORK HANDLE FOR TTY HIBERNATE FORK
	ALC TYSTAT,1		;TTY STATUS (CONTROLLING TTY).
				; SIGN IS ^O FLAG, RH IS INIT BITS
	ALC CSTFLG,1		;FLAG TO FORCE MRETN TO DO A START/REE
	ALC UIIFLG,1		;USER INTERRUPT ICC DONE FROM MRETN
	ALC UIFLAG,1		;[356] Bit n denots which channel has an interrupt
				;[356]  pending.
;**;[407] At ALC UIITRP, Commented 1 line                SM  7-Dec-82
;[407]	ALC UIITRP,USRMXC+1	;;[407] Incorrect
	ALC UTRPPC,2		;[356] First word is thw word that is JSR'd to for
				;[356]  a user interrupt.  The second word should
				;[356]  contain a JRST USRINT.
;**;[407] At ALC UITRAP, Modified 1 line                SM  7-Dec-82
	ALC UITRAP,USRMXC+1	;[407] CUSER INTERRUPT TRAP ADDRESSES
	ALC UIACA,1		;PLACE TO SAVE AN AC DURING USER INT
	ALC LEVTAB,3		;PSI LEVEL TABLE
	USRSAV==LEVTAB+2	;POINTER TO USER INTERRUPT PC
	ALC CHNTAB,^D36		;PSI CHANNEL TABLE

	ALC JOBNAM,1		;STORAGE AREA FOR SYSGET MACRO
	ALC TICKPS,1
	ALC SNAMES,1
	ALC SSIZE,1
	ALC SNBLKS,1
	ALC SYSVER,1
	ALC PTYPAR,1
	ALC SYSTAT,1
	ALC TTYJOB,1
	ALC DWNTIM,1		;CEASE TIME
	ALC DMAPTB,NPPN		;TABLE OF DIRECTORY NUMBERS FOR UNMAPPING
	ALC LSTUFD,1		;LAST UFD READ
	ALC LSTUFJ,1		;JFN USED TO READ LAST UFD
	ALC LSTUFP,1		;POINTER INTO UFD
	ALC LSTMFP,1		;POINTER INTO MFD
	ALC LSTMFN,1		;LAST DIR NUM USED IN MFD READ
	ALC NEWJFN,1		;JFN TO BE RELEASED AT LOOKER
	ALC USRMSK,1		;MASK OF CHANNELS DEFINED BY USER
	ALC MAPLST,1		;BIT MASK OF AVAILABLE PREFAULTING PGS
	ALC MAPTOT,1		;# OF FILES THAT ARE BEING PREFAULTED
;**;[345] INSERT AFTER DEFINITION OF MAPTOT
	ALC SUCNT,1		;[345] SIMULATED UUO COUNT
	ALC FLPAC,1		;[345] FILOP. UUO AC
	ALC FLPAGL,1		;[345] FILOP. UUO ARGUMENT BLOCK LENGTH
	ALC FLPARG,1		;[345] FILOP. UUO ARGUMENT BLOCK ADDRESS
	ALC FOPAD, 1		;[356] Address for the FILOP processing
	ALC FOPFLG,1		;[356] FILOP. flags
	SYN FLPAC,FOPAC		;[356] Saved value of AC during FILOP. processing
	ALC FOPFNC,1		;FILOP. function code
	ALC FOPTMP,1		;[356] Temp location for FILOP. processing
	ALC FOPPPN,1		;[356] FILOP. PPN
	ALC FOPARG,1		;[356] First word of the LKP block
	ALC CHKBLK,5		;[356] CHKAC block for the FILOP. processing.

CLRTOP==LC-1			;LAST LOCATION CLEARED ON FIRST ENTRY

	ALC STIME,1		;RUN TIME AT START OF UUO FOR STATISTICS
	ALC ITIME,1		;UPTIME IN MILLISECONDS FOR MSTIME UUO
	ALC ECHINI,1		;INITIAL ECHO SETTING
	ALC TTWDTH,1		;WIDTH OF LINE BEFORE TURNING OFF CR-LF
	ALC DIECNT,1		;NUMBER OF FAILING SYSTEM-RESOURCES MSGS.
	ALC ACS,20		;USER'S AC'S AT TIME OF UUO.
	ALC PFLAGS,1		;STORAGE FOR PF AC WHILE USER RUNS.
	ALC INPAT,1		;IN PAT IF NON-0,IN USER PROG IF 0
	ALC INFLSR,1		;IN FILSER, CONTROL-C'S ARE NOT ALLOWED
	ALC FDBTMP,1		;ROOM TO MODIFY A WORD OF FDB
	ALC MONUUO,1		;COPY OF MONITOR 40
	ALC MONUPC,1		;USER PC SAVED BY MONITOR
	ALC CSTCOD,1		;^C START CODE: -1=ST,
				; -2=REE, -3=DDT,, -4=CLOSE, +N=GOTO N
	ALC CSTOPC,1		;OLD PC WHERE ^C CONT WOULD HAVE GONE
	ALC CLSDEV,1		;LOC TO STORE DEV NAME TO BE CLOSED?
	ALC EXITPC,1		;PC TO CONTINUE AT IF USER CONTINUES AFTER MONRET
	ALC SAVTIW,1		;PLACE TO STORE OLD TERMINAL INT WORD
	ALC RUNDEV,1		;DEVICE SPECIFIED IN RUN UUO
	ALC RUNNAM,1		;NAME OF PROGRAM TO RUN
	ALC RUNEXT,1		;EXT OF PROG TO BE RUN
	ALC RUNPPN,1		;PPN OF PROG TO RUN

PDLL==40
	ALC PDL,PDLL
FPDLEN==10
	ALC FRKPDL,FPDLEN	;STACK FOR TTY FORK
IPDLL==10
	ALC IPDL,IPDLL		;USED AT INTERRUPT LEVEL 1

	ALC FORTY,1		;PLACE TO STORE CONTENTS OF 40 AT TIME OF CALL
				;THIS IS LAST SO THAT THE SECOND PAGE
				;GETS CREATED ON THE FIRST UUO

	TSTOP=LC		;END OF TEMP STORAGE. TRY TO KEEP
				; THIS IN TWO PAGES. (REF IOMPGS)
	NIOPGS==30		;PAGES AVAILABLE FOR PREFAULTING
				;THIS SHOULD BE DIVISIBLE BY NPLPGS
	NPLPGS==4		;NUMBER OF PRELOADED PAGES AT A TIME
	IOMPGS==<<TSTOP>_-11>+1	;MAPPED I/O USES 32. PAGES STARTING HERE
	IOMEND==IOMPGS+NIOPGS	;FIRST FREE PAGE AFTER I/O AREA

	NPATPG==<MAXPAT-PATLOC>_-11 ;# OF PAGES FOR PAT


IFL <MAXPAT-IOMEND>,<PRINTX ? PAT is too big -- reduce NIOPGS>

SUBTTL ENTRY VECTOR AND TOP-LEVEL OF UUO HANDLER

	HISEG
	PHSLOC==PATLOC+.JBHDA
	PHASE PHSLOC

EVEC=PATLOC		;COPY TO PUBLISHED LOCATION

;**** CAUTION!
;	THE ENTRY VECTOR STARTING AT KEVEC IS BLT'ED TO EVEC BY LINIT
;	THEREFORE THERE MUST BE NOTHING SHOULD PRECEED KEVEC

KEVEC:	JRST COMPAT		;0 - UUO'S NORMALLY ENTER VIA THIS
	JRST PATINI		;1 - FIRST UUO ENTERS VIA THIS
	EXP PATVER		;2 - VERSION OF PAT IS IN FIXED LOC 700002
	MONUUO			;3 - MON 40 DUMPED HERE ON MON UUO
	MONUPC			;4 - USER PC DUMPED HERE ON MON UUO
	JRST MAKSHR		;5 - MAKE SHR VERSION OF SUBSYSTEM
	EXP CCPSIN		;6 - CHANNEL FOR EXEC TO PSI ON FOR ^C REE
	XWD CSTCOD,CSTOPC	;7 - WHERE TO STORE DATA FOR ^C ST SEQ.
	XWD JBHRL,JBREL		;10 - POINTERS SO EXEC CAN DO CORE COMMAND
	XWD LOWNAM,CLSDEV	;11 - LH = LOW SEG NAME FROM RUN OR SETNAM
				;     RH=PLACE FOR EXEC TO PUT DEV NAME OR JFN TO BE CLOSED
	XWD DEBUG1,SEGNAM	;12 - LH = START ADR TO INITIALIZE PAT,
				;     RH = HIGH SEG NAME
	XWD NTABS,JFNTAB	;13 - LH = LENGTH OF DATA BASE FOR EACH CHANNEL
				;     RH = ADR OF JFN FOR CHANNEL 0
EVECL==.-KEVEC			;LENGTH OF ENTRY VECTOR
CSTMCD==5			;MAX VALUE OF CSTCOD KNOWN ABOUT

SJBSYM: BLOCK 1			;PLACE FOR LINIT TO STASH .JBSYM
PVLOC:	EXP PATVER		;VERSION NUMBER USED BY MAKEPF

;10/50 TYPE UUO'S ARRIVE HERE

PATINI:	SETZM PFLAGS		;FIRST TIME ENTRY. CLEAR FLAG WORD.
COMPAT:
IFN FTFILSER,<	SETZM INFLSR>		;CLEAR FILSER FLAG
	SETZM FRUSTC		;INITIALIZE FRUSTRATION COUNTER
	SETZM DIECNT
	SETZM IOWATF		;CLEAR WAITING FLAG
;**;[345] INSERT @COMPAT+1 1/2
	SETZM SUCNT		;[345] CLEAR SIMULATED UUO COUNTER
	MOVEM 17,ACS+17
	MOVEI 17,ACS
	BLT 17,ACS+16
	SETOM INPAT		;MARK THAT ACS ARE SAVED
	HLLZ PF,PFLAGS		;FLAGS TO AC FOR PAT'S FLAGS.
IFN FTSTAT,<
	MOVEI A,1		;GET RUN TIME IN 10 MICROSECOND INCREMENTS
	TLNE PF,L.LSTA!L.GSTA	;DONT DO HPTIM IF NO STATISTICS BEING DONE
	HPTIM
	  TLZ PF,L.GSTA!L.LSTA	;DONT DO ANY MORE STATISTICS
	MOVEM A,STIME		;SAVE FOR USE AT END OF UUO
>
	MOVE P,PATSTK		;SETUP LOCAL STACK
;**;[400] At BP: -3L, Deleted 4 lines               	SM	28-Jan-82
	MOVE A,MONUUO
	MOVEM A,FORTY		;PRESERVE 40 OVER MYUUO'S
BP:	LDB AC,ACPTR		;GET AC FIELD OF UUO
	MOVE CAC,ACS(AC)	;CONTENTS OF USER AC (MAY BE IRRELEV.)
	MOVE A,MONUPC		;GET CALLING PC OF USER UUO
	MOVEM A,JOBPD1		;PUT IT IN 10/50'S STACK AREA
	PUSH P,A		;AND ON PAT'S STACK

	TLNN PF,L.ONCE		;FIRST TIME?
	PUSHJ P,ONCE		;YES. GO SET UP PSI AND TEMP STORAGE
	SETZM NEWJFN		;INITIALIZE THIS LOCATION
	SKIPN CCIENB		;IS ^C INTERCEPT ALREADY SET
	TLNE PF,L.NCCE		;NO, IS CONTROL-C ENABLING ALLOWED?
	  JRST COMPA1		;NO, SO DONT DO IT
	SKIPE A,.JBINT		;IS .JBINT NOW NON-ZERO
	PUSHJ P,CHKCCI		;YES, CHECK TO SEE IF ^C INTERCEPT TO BE SET
COMPA1:	LDB A,[POINT 9,FORTY,8] ;GET UUO NUMBER
	IFN FTDEB,<
	 TMSGS	.CR,< Doing UUO >
	 DMOVEM A,TMSTMP
	 MOVE B,A
	 MOVX A,.PRIOU
	 MOVEI C,8
	 NOUT
	 ERJMP .+1
	 CAIE B,47
	 JRST DBG3
	 MOVEI A,":"
	 PBOUT
	 MOVX A,.PRIOU
	 HRRZ B,FORTY
	 NOUT
	 ERJMP DBG1
	 MOVE	C,[POINT 6,CALLIT(B)]
DBG4:	 MOVEI	A," "
	 PBOUT%
DBG2:	 TLNN	C,770K
	 JRST	DBG1
	 ILDB	A,C
	 ADDI	A," "
	 PBOUT%
	 JRST	DBG2
DBG3:	 MOVE	C,[POINT 6,FOONAM-40(B)]
	 JRST	DBG4
DBG1:    DMOVE A,TMSTMP
>
	CAIL A,40		;SMALL NUMBERS ARE ILLEGAL
	CAIL A,100		;IS IT A GOOD ONE?
	PUSHJ P,ITRAP		;NO GOOD.
	JRST @COMUTB-40(A)	;WE ONLY WANT TO DO 40-77

COMUTB:	EXP UCALL,UINIT,ITRAP,ITRAP,ITRAP,ITRAP,ITRAP,UCALLI
	EXP UOPEN,UTTCLL,ITRAP,ITRAP,ITRAP,URENME,UIN,UOUT
	EXP USETST,USTATO,UGETST,USTATZ,UINBUF,UOUTBF,UINPUT,UOUTPT
	EXP UCLOSE,URELEA,UMTAPE,UUGETF,UUSETI,UUSETO,ULOOKP,UENTER

ACPTR:	POINT 4,FORTY,12
PATSTK:	IOWD PDLL,PDL		;LOCAL STACK
PSISTK: IOWD PDLL,PDL		;STACK WHILE ON LEVEL 1

;RETURN FROM 10/50 UUO

;**;[345] REPLACE 2 WORDS AT MRETN2
MRETN:	TDZA B,B		;[345] NORMAL RETURN
MRETN2:	MOVEI B,1		;[345] SKIP RETURN
MRETNB:	SKIPN UIFLAG		;[345] USER INTERUPT WAITING?
	SKIPE CSTFLG		;[345] OR ^C BEEN TYPED?
	SETZM SUCNT		;[345] FORGET SIMULATED UUO
	SKIPLE SUCNT		;[345] SIMULATED UUO?
	JRST   [SOS SUCNT	;[345] YES, BUT NOT ANY MORE
		ADDM B,(P)	;[345] ADD IN SKIP
		POPJ P,]	;[345] RETURN FROM SIMULATED UUO
	ADDM B,PDL		;[345] ADD IN SKIP
	MOVEM PF,PFLAGS		;[345] SAVE FLAG AC
	MOVE A,PDL		;GET USER PC
	MOVEM A,JOBPD1		;STORE FOR HIM TO SEE
	HRRI A,1(A)		;SET UP FOR INTERRUPT RETURN
	MOVEM A,MONUPC		;UPDATE RETURN ADDRESS
	SKIPE A,CSTFLG		;CONTROL-C, START DONE?
	JRST CSTMRT		;YES. GO PROCESS IT
MRETNA:
IFN FTSTAT,<
	TLNE PF,L.LSTA!L.GSTA	;IF NOT TAKING STATISTICS, DONT CALL ROUTINE
	PUSHJ P,DOSTAT		;GO DO SOME STATISTICS
>
	MOVSI 17,ACS
	BLT 17,17
	SETZM INPAT		;ACS NOW RESTORED
	SKIPN UIFLAG		;USER INTERRUPT PENDING
	JRSTF @JOBPD1
	MOVE	B,UIFLAG	;[356] Get the user interrupt channel if any
				;[356]  are pending
	SETZM UIFLAG		;CLEAR USER INTERRUPT FLAG
	SETOM UIIFLG		;MARK THAT AN IIC IS BEING DONE
;[356]	MOVSI B,(1B0)		;CHANNEL 0 IS USER CHANNEL
	MOVEI A,.FHSLF		;INTERRUPT BACK UP TO LEVEL 3
	IIC
	PUSHJ P,BUGSTP		;SHOULD NEVER GET HERE

CSTMRT:	SETZM CSTFLG		;CLEAR FLAG THAT START DONE.
	SKIPE INFLSR		;WAS CONTROL-C TURNED OFF FOR FILSER?
CSTMR1:	  JRST [SETZM INFLSR	;YES, OK TO ALLOW CONTROL-C'S
		SETZM CCIFLG	;CLEAR CONTROL-C FLAG
		SETZM CCIENB	;MARK THAT CONTROL-C NOT DISABLED
		MOVEI A,3	; GET CONTROL-C CHANNEL
		DTI		;DEACTIVATE IT
		TMSG <^C>	;TYPE OUT ^C
		HALTF		;AND EXIT
		JRST MRETNA]	;RETURN IF CONTINUED
	HLL A,JOBPD1		;PRESERVE USER'S FLAGS
	EXCH A,JOBPD1		;PUT START ADR IN RETURN, GET UNUSED RET
	MOVEM A,.JBOPC		;PUT THE RETURN IN OPC FOR USER
	SKIPN CCIFLG		;IS THERE A ^C INTERCEPT IN PROGRESS?
	  JRST MRETNA		;NO, RETURN TO USER ADR
	SETZM CCIFLG		;YES, CLEAR FLAG
	SKIPN B,.JBINT		;GET POINTER TO INTERCEPT BLOCK
	  JRST CSTMR1		;NOT SET UP, LET ^C TAKE
	MOVE C,1(B)		;GET FLAGS
	SKIPN 2(B)		;IS PC WORD ZERO?
	TRNN C,ER.ICC		;AND, IS CONTROL-C STILL ENABLED?
	  JRST CSTMR1		;NO, LET ^C THROUGH
	MOVEM A,2(B)		;STORE INTERRUPTED ADDRESS
	JRST MRETNA		;AND RETURN TO HIM

BAPOPJ:	POP P,B
APOPJ:	POP P,A
	POPJ P,

CPOPJ2:	AOS (P)
CPOPJ1:	AOS (P)		;SKIP RETURN
CPOPJ:	POPJ P,

;COMMON RETURNS FROM UUO'S

;**;[345] REPLACE RETZR1 THRU RETM1+1
RETZER:	TDZA A,A		;[345] CLEAR AC A, AND SKIP TO STOTAC
RETZR1:	TDZA A,A		;[345] CLEAR AC A, AND SKIP TO STOTC1
STOTAC:	TDZA B,B		;[345] STORE THE AC, NON-SKIP RET
STOTC1:	MOVEI B,1		;[345] STORE THE AC, SKIP RETURN
STOTCS:	MOVEM A,ACS(AC)	;STORE THE AC FOR USER
	JRST MRETNB		;[345] AND RETURN FROM THE UUO

RETM1:	TDZA B,B		;[345] NON-SKIP RETURN A MINUS 1
RETM11:	MOVEI B,1		;[345] SKIP RETURN A MINUS 1
	MOVNI A,1		;[345] RETURN A MINUS ONE
	JRST STOTCS		;[345] TO USER'S AC
;STATISTICS GATHERING ROUTINES

IFN FTSTAT,<
DOSTAT:	MOVEI A,1		;READ CLOCK AGAIN
	HPTIM
	  POPJ P,		;JUST RETURN WITHOUT DOING STATISTICS
	SUB A,STIME		;GET AMOUNT OF TIME TO DO UUO
	MOVE B,A
	LDB A,[POINT 6,FORTY,8]	;GET UUO OPCODE
	STAT A,B,<ST.UUO-40>	;DO STATISTICS REPORTING
	CAIN A,(TTCALL_-^D9)	;IS THIS A TTCALL UUO?
	  JRST STTTCL		;YES, GO COUNT IT
	TRNE PF,R.CMR		;IS THIS A CMRETN RETURN
	  JRST STUNI		;YES, GO COUNT UNIMPLEMENTED CALLS
	CAIE A,(CALLI_-^D9)	;CALLI UUO?
	CAIN A,(CALL_-^D9)	;OR A CALL UUO?
	  SKIPA A,NCALLI	;YES, GET CALLI #
	  POPJ P,		;NO, THEN WE ARE DONE
	TRNE A,200000		;NEGATIVE CALLI?
	  HRRZI A,200(A)	;YES, GET OFFSET FROM 200
	ANDI A,377777		;CLEAR PHYSICAL ONLY BIT
	TRNE A,777600		;WITHIN BOUNDS?
	  POPJ P,		;NO, DO NO ACCOUNTING
	STAT A,B,<ST.CLI>	;ACCOUNT!
	CAIE A,41		;GETTAB UUO?
	  POPJ P,		;NO, RETURN
	HLRZ A,NCALLI		;GET TABLE #
	TRNE A,777700		;WITHIN BOUNDS?
	  POPJ P,		;NO, RETURN
	STAT A,B,<ST.GTB>	;COUNT IT UP
	POPJ P,			;FINALLY DONE

STTTCL:	LDB A,ACPTR		;GET AC FIELD
	STAT A,B,<ST.TCL>
	POPJ P,			;RETURN

STUNI:	MOVEI A,0
	STAT A,B,<ST.UNI>
	POPJ P,
>

UXCT:	MOVE EE,@0(P)		;GET INSTRUCTION TO BE EXECUTED
	MOVEI FF,@EE		;GET EFFECTIVE ADDRESS
	CAML FF,HSORG		;CHECK THE ADDRESS - IN HISEG?
	CAMLE FF,JBHRL		;YES, IS THIS A LEGAL HIGH SEG ADDRESS?
	CAMG FF,JBREL		;IS IT A LEGAL LOW SEG ADR
	TRNA			;IT IS LEGAL
	PUSHJ P,ITRAP		;ILLEGAL, GO PRINT OUT MESSAGE
UXCT0:	CAIL FF,20		;IN THE AC'S?
	POPJ P,			;NO, THEN WE CAN DO THIS INST DIRECTLY
	HRRI EE,ACS(FF)		;GET OFFSET EFFECTIVE ADDR
UXCT1:	TLZ EE,37		;CLEAR INDEX AND INDIRECT BITS
	AOS (P)			;SKIP OVER INST
	XCT EE			;DO THE INST (MODIFIED)
	  POPJ P,		;NO SKIP
	JRST CPOPJ1		;SKIP RETURN

;Same as UXCT but for two word instructions i.e. DMOVE/DMOVEM

UXCT2:	MOVE EE,@0(P)		;GET INSTRUCTION TO BE EXECUTED
	MOVEI FF,@EE		;GET EFFECTIVE ADDRESS
	CAML FF,HSORG		;CHECK THE ADDRESS - IN HISEG?
	AOJA FF,.+2		;YES, CHECK SECOND WORD
	AOJA FF,.+2		;NO, IN LOW SEG
	CAMLE FF,JBHRL		;YES, IS THIS A LEGAL HIGH SEG ADDRESS?
	CAMG FF,JBREL		;IS IT A LEGAL LOW SEG ADR
	SOJA FF,UXCT0		;IT IS LEGAL
	PUSHJ P,ITRAP		;ILLEGAL, GO PRINT OUT MESSAGE
	SOJA FF,UXCT0

LBXCT:	MOVE EE,@0(P)		;HERE TO XCT BYTE INSTRUCTIONS
	MOVE FF,@EE		;GET POINTER WORD
	MOVEI FF,@FF		;GET EFFECTIVE ADDRESS OF DESTINATION
	CAML FF,HSORG		;IN HISEG?
	  CAMLE FF,JBHRL	;YES, IS IT LEGAL?
	CAMG FF,JBREL		;LEGAL LOW SEG ADR?
	  TRNA			;YES, LEGAL ADR
	  PUSHJ P,ITRAP		;ILLEGAL ADR, GO TYPE MESSAGE
	CAIL FF,20		;ADR IN THE ACS
	  POPJ P,		;NO, GO EXECUTE IT
	HLL FF,@EE		;RESTORE P AND S FOR BYTE POINTER
	TLZ FF,37		;CLEAR INDIRECT AND INDEX BITS
	HRRI FF,ACS(FF)		;MAKE IT POINT TO SAVED ACS
	HRRI EE,FF		;MAKE EE USE FF AS POINTER
	JRST UXCT1		;GO DO INSTRUCTION

DOJSYS:	TRO PF,R.ILLJ		;MARK THAT WE ARE IN AN XJSYS MACRO
	XCT @0(P)		;XCT THE JSYS
	AOS 0(P)		;SET UP FOR SKIP RETURN
				;THIS INSTRUCTION IS SKIPPED IF AN
				;  INTERRUPT OCCURED DURING THE JSYS
	TRZ PF,R.ILLJ		;CLEAR FLAG FOR INTERRUPT LEVEL
	JRST CPOPJ1		;SKIP OVER JSYS INSTRUCTION ITSELF

INJSYS:	SKIPN UIFLAG		;USER INTERRUPT PENDING?
	SKIPE CSTFLG		;OR ^C INTERRUPT PENDING?
	JRST [	SETZM IOWATF	;CLEAR WAITING FLAG
		SOS PDL		;DECREMENT PC
		JRST MRETN]	;EXIT TO USER
	XCT 0(EE)		;DO THE JSYS
	 JRST 1(EE)		;NON-SKIP RETURN
	JRST 2(EE)		;SKIP RETURN
INJSYE:
SUBTTL UUO PROCESSORS FOR INDIVIDUAL UUO'S

;10/50 CALL AND CALLI TABLES
;NOTE THAT NEGATIVE CALLIS AND 0-55 HAVE SIXBIT CALLS
; WHILE 56 UP DO NOT.
MXSIXB==55			;MAXIMUM CALLI WHICH HAS A SIXBIT ARG

DEFINE MCALLI
<CC LIGHTS,LIGHTS
>

;NOTE, IF SECOND ARG IS NULL THEN UUO IS NOT IMPLEMENTED.

DEFINE PCALLI
<CC RESET,RESET
 CC DDTIN,DDTIN
 CC SETDDT,SETDDT
 CC DDTOUT,DDTOUT
 CC DEVCHR,DEVCHR
 CC DDTGT
 CC GETCHR,GETCHR
 CC DDTRL
;10
 CC WAIT
 CC CORE,CORE
 CC EXIT,EXIT
 CC UTPCLR,UTPCLR
 CC DATE,DATE
 CC LOGIN,ILEGAL
 CC APRENB,APRENB
 CC LOGOUT,LOGOUT
;20
 CC SWITCH,SWITCH
 CC REASSI,REASSI
 CC TIMER,TIMER
 CC MSTIME,MSTIME
 CC GETPPN,GETPPN
 CC TRPSET,ILEGAL
 CC TRPJEN,ILEGAL
 CC RUNTIM,RUNTIM
;30
 CC PJOB,PJOB
 CC SLEEP,SLEEP
 CC SETPOV
 CC PEEK,RETZER
 CC GETLIN,GETLIN
 CC RUN,RUN
 CC SETUWP,MRETN2
 CC REMAP,REMAP
;40
 CC GETSEG,GETSEG
 CC GETTAB,GETTAB
 CC SPY
 CC SETNAM,SETNAM
 CC TMPCOR,TMPCOR
 CC DSKCHR,DSKCHR
 CC SYSSTR,SYSSTR
 CC JOBSTR,JOBSTR
;50
 CC STRUUO,STRUUO
 CC SYSPHY,SYSPHY
 CC FRECHN
 CC DEVTYP,DEVTYP
 CC DEVSTS
 CC DEVPPN,DEVPPN
 CC SEEK
 CC RTTRP
;60
 CC LOCK
 CC JOBSTS,JOBSTS
 CC LOCATE
 CC WHERE
 CC DEVNAM,DVNAM.
 CC CTLJOB,CTLJOB
 CC GOBSTR,GOBSTR
 CC ACTIVA
;70
 CC DEACTI
 CC HPQ
 CC HIBER,HIBER
 CC WAKE,WAKE
 CC CHGPPN
 CC SETUUO
 CC DEVGEN
 CC OTHUSR,GETPPN
;100
 CC CHKACC,CHKACC
 CC DEVSIZ,DEVSIZ
 CC DAEMON
 CC JOBPEK
 CC ATTACH
 CC DAEFIN
 CC FRCUUO
 CC DEVLNM
;110
 CC PATH.,PATH
 CC METER.
 CC MTCHR.,MTCHR
 CC JBSET.
 CC POKE.
 CC TRMNO.,TRMNO
 CC TRMOP.,.TRMOP
 CC RESDV.,RESDV
;120
 CC UNLOK
 CC DISK.
 CC DVRST.
 CC DVURS.
 CC XTTSK.
 CC CAL11.
 CC MTAID.
 CC IONDX.
;130
 CC CNECT.
 CC MVHDR.
 CC ERLST.
 CC SENSE.
 CC CLRST.
 CC PIINI.
 CC PISYS.
 CC DEBRK.
;140
 CC PISAV.
 CC PIRST.
 CC IPCFR.
 CC IPCFS.
 CC IPCFQ.
 CC PAGE.
 CC SUSET.
 CC COMPT.,COMPT.
;150
 CC SCHED.
 CC ENQ,.ENQ
 CC DEQ,.DEQ
 CC ENQC,.ENQC
 CC TAPOP,TAPOP
 CC FILOP,FILOP
 CC NODE.
;160
 CC ERRPT.
 CC ALLOC.
 CC PERF.
 CC DIAG.
 CC DVPHY.
 CC GTNTN.
 CC GTXTN.
 CC ACCT.
;170
 CC DTE.
 CC DEVOP.
 CC SPPRM.
 CC MERGE.
 CC UTRP.
 CC PIJBI.
 CC SNOOP.
 CC TSK.
;200
 CC KDP.
 CC QUEUE.
 CC RECON.
>


DEFINE CC (A,B)<
IFB <B>,<
	JRST CMRETN		;; A UNIMPLEMENTED
>
IFNB <B>,<
	JRST	B		;; A HANDLER
>
>

MCLIT:
MCALLI				;TRANSFER TO NEGATIVE CALLI'S
NMCLI==.-MCLIT			;NUMBER OF MINUS CALLI'S
CALLTV:				;ADDRESS OF TABLE ENTRY FOR CALLI 0

PCALLI				;TRANSFERS FOR POSITIVE CALLI'S

NPCLI==.-CALLTV

 IFN FTDEB,<			;BUILD A SIXBIT TABLE OF UUO NAMES
DEFINE REDEF(A),<IRP A,<SIXBIT/A/>>
FOONAM:	RDEFS
 >


;UUO'S
;CALL AND CALLI

UCALL:	UMOVE A,@FORTY		;ARG TO CALL IN SIXBIT, NAME OF ROUTINE
	MOVSI B,-<NPCAL+NMCAL>	;LENGTH OF TWO SIXBIT TABLES
	CAMN A,CALLIT-NMCAL(B)	;THIS ENTRY IN NAME TABLE?
	JRST [MOVEI B,-NMCAL(B)	;YES. GET CALLI NUMBER IT WOULD BE
		JRST UCALL1]	;AND GO TO CALLI HANDLER
	AOBJN B,.-2		;NO, TRY NEXT NAME
CMRETN:
IFN FTSTAT,<
	TRO PF,R.CMR		;MARK THAT AN UNIMPLEMENTED CALL WAS DONE
>
	JRST MRETN		;MAKE A NO-OP.

UCALLI:	HRRZ B,FORTY		;EFFECTIVE ADDR IS THE ARG
	TRNE B,B18		;EXTEND SIGN INTO PHYSICAL BIT.
	TROA B,1B19		;IT'S NEGATIVE.
	TRZ B,1B19		;ITS POSITIVE
	MOVEI A,NPCLI+NMCLI	;TOTAL CALLI LENGTH. CATCHES NEGATIVE
				; OUT OF RANGE TOO, BY HALF-WORD ARITHMETIC
	CAIG A,NMCLI(B)		;OFFSET TO ACCOUNT FOR LEGAL NEGATIVE VALUES
	JRST CMRETN		;LARGE ARGUMENTS ARE NO-OPS
UCALL1:
IFN FTSTAT,<
	HRRM B,NCALLI		;SAVE CALLI # FOR ACCOUNTING
	HRLM CAC,NCALLI		;SAVE GETTAB TABLE # ALSO
>
	JRST @CALLTV(B)		;DISPATCH


SUBTTL UUOS FOR FILE OPERATIONS

;FILE STUFF

GSTATS:	PUSHJ P,SETUP
;**;[436] ADD LABEL AT GSTATS:+1.L	DSW	4/26/85
GSTAT1:	MOVE C,FLAGWD(BB)
	CAIN AA,PTY		;IS THIS A PTY?
	  JRST PTYSTS		;YES, GO GET PTY STATUS
	HRRZ A,C
	CAIE AA,MTA		;THIS A MTA?
	POPJ P,
	PUSHJ P,GST2		;YES, GET CURRENT MTA STATUS
	MOVEI B,4000		;CLEAR BOT IN FLAGWD
	ANDCAM B,FLAGWD(BB)	;THIS BIT IS ALWAYS CORRECT FROM GST2
	IORB A,FLAGWD(BB)	;GET CONDITIONS ALREADY SET
	HRRZS A
	POPJ P,

;ROUTINE TO GET STATUS FOR MAGTAPE.
;RETURNS WITH GDSTS DATA IN B, UPDATED 10/50 STATUS IN A.
;IOBKTL ISN'T SET, DUE TO THE COMPLEXITY OF 1B23 OF TOPS-20 GDSTS.
; THE CALLER IS LEFT TO DO THAT

GST2:	HRRZ A,JFNTAB(BB)	;SEE IF JFN IS OPEN
	GTSTS
	JUMPL B,GST3		;IF 1B0 = 1, THEN OPENED
	MOVE B,[440000,,OF%RD]	;NOT OPENED, MUST OPEN IT FIRST
	OPENF
	 JRST GST3		;FAILED, GO GET WHATEVER POSSIBLE
	GDSTS			;GET THE STATUS
	TLO A,(CO%NRJ)		;NOW CLOSE THE JFN
	CLOSF			;BUT KEEP IT FROM BEING RELEASED
	 JFCL
	JRST GST4		;ENTER COMMON CODE

GST3:	HRRZ A,JFNTAB(BB)	;ARGUMENT TO GDSTS
	GDSTS			;GET TOPS-20 STATUS
GST4:	MOVE C,FLAGWD(BB)	;OLD TEN FIFTY STATUS
	TRZ C,707700		;BITS WHICH MAY NEED UPDATING
	MOVE A,B		;TOPS-20 BITS TO A
	TRZE A,MT%IRL		;ILLEGAL RECORD LENGTH?
	TRO A,1B21		;YES, TURN IT INTO TOPS10 BIT
	ANDI A,767600		;ONLY ONES TO KEEP ARE MATCHING HDW BITS
	TRZE A,40000		;SUPPRESS ERROR RETRY?
	TRO A,100		;YES, MOVE TO CORRECT PLACE
	TLNN C,MTALTW		;LAST TRANSFER A WRITE?
	TRZ A,MT%ILW		;NO, WE DONT WANT TO SEE WRITE LOCK BIT
	IOR A,C			;ADD IN OLD STATUS AND IOBKTL
	HRRZS A			;JUST RIGHT-HALF
	POPJ P,0		;RETURN

UGETST:	PUSHJ P,GSTATS
	UMOVEM A,@FORTY
	JRST MRETN

USTATO:	PUSHJ P,GSTATS
	TDNE A,FORTY
	JRST MRETN2		;SKIP RETURN
	JRST MRETN		;NOSKIP RETURN

USTATZ:	PUSHJ P,GSTATS
	TDNN A,FORTY
	JRST MRETN2		;SKIP RETURN
	JRST MRETN		;NOSKIP RETURN

USETST:	PUSHJ P,SETUP
	HRRZ B,FORTY
	HRRM B,FLAGWD(BB)	;SAVE MODE ETC
	CAIN AA,MTA		;THIS A MTA?
	  JRST MTASET		;YES, GO SET UP PARITY AND DENSITY
	MOVSI A,TTYDEV
	TDNE A,DEVTBL(AA)	;TTY?
	PUSHJ P,TTYSET		;YES, SET UP NEW TTY MODE
	JRST MRETN

TTYSET:	MOVE A,JFNTAB(BB)	;GET JFN FOR THIS TTY
	MOVE E,FLAGWD(BB)	;AND FLAGS
	TLNN E,TT.CTY		;IS THIS THE CONTROLING TTY?
	  JRST TTSET1		;NO
	HRRM E,TYSTAT		;YES, SAVE THE NEW MODE
	MOVE E,TYSTAT		;GET FLAGS
TTSET1:	JRST TTYST0		;GO SET UP NEW MODE

UOPEN:	TLOA C,-1
UINIT:	TLZ C,-1
	PUSHJ P,SETUPG		;IS A DEVICE ALREADY INIT'ED?
	  JRST UINIT1		;NO
	PUSH P,C		;SAVE WHETHER OPEN OR INIT
	PUSHJ P,URELR		;CALL RELEASE FOR THIS CHANNEL
	POP P,C

UINIT1:	JUMPL C,UOPEN1		;WAS IT OPEN?
	MOVE A,(P)		;A TO POINT AT FIRST OF THREE ARGS
	AOS 0(P)
	AOS 0(P)		;P TO POINT TO R1
	MOVE C,FORTY		;MAY BE THE RESULT OF AN XCT
	SOJA A,UOPEN2

UOPEN1:	HRRZ A,FORTY		;EFFECTIVE ADR IS POINTER TO THREE ARGS
	UMOVE C,(A)
UOPEN2:	HRRZM C,FLAGWD(BB)	;TAKES CARE OF STATUS FOR NOW

	PUSHJ	P,UUOPEN	;[356] Call the OPEN routine
	 JRST	MRETN		;[356] Failed - Give a fail return
	JRST	MRETN2		;[356] Give a good return

;[356] Here to do the OPEN/INIT of a device.  This is an alternate entry
;[356] point for the FILOP processing.
;[356]
;[356] Usage:
;[356]	MOVE	A,Effective address of the block
;[356]	MOVE	B,Address of the internal block
;[356]	PUSHJ	P,UUOPEN
;[356]	(Fail return)
;[356]	(Good return)

;**;[442] INSERT 2 LINES AT UUOPEN:+0.L	DSW	8/29/85
;**;[444]At UUOPEN:+0L delete two lines  JYCW  6/18/86
UUOPEN:	UMOVE C,2(A)		;SIXBIT NAME FROM USER
	MOVEM C,BUFHTB(BB)	;XWD OBUFH,IBUFH
	UMOVE C,1(A)		;SIXBIT NAME FROM USER
	CAMN C,[SIXBIT/PTY/]	;IS THIS A GENERIC PTY
	  PUSHJ P,GETPTY	;YES, GO GET A PHYSICAL PTY
	MOVEM C,DEVNAM(BB)	;SAVE IT IN SIXBIT
	PUSHJ P,DEV67		;PUT IT IN DEVNM7
	MOVE C,DEVNAM(BB)	;GET SIXBIT BACK

;FIND OUT WHAT DEVICE REALLY IS
;CHECK FOR LEGAL MODE
;SET BUFFER SIZE AND BYTE SIZE IN C

	HRROI A,DEVNM7
	STDEV			;GET DEVICE CHARACTERISTICS
	  TDZA B,B		;NOT A LEGAL DEVICE NAME, TRY SYS AND TTY
	JRST UOPENE		;FOUND DEVICE, GO OPEN IT
	CAMN C,[SIXBIT /SYS/]
	JRST UOPENE		;CAN'T STDEV ON SYS
	MOVSI B,TTY
	CAMN C,[SIXBIT /TTY/]
	JRST UOPENE
IFN FTFILSER,<
	MOVE A,DEVNAM(BB)	;GET NAME
	PUSHJ P,DPACHK		;SEE IF THIS IS A TOPS-10 PACK
	  POPJ P,		;[356]IT IS NOT, ERROR
	MOVEM A,DEVNAM(BB)	;SAVE PACK NAME
	JRST TOPEN		;GO DO THE OPEN
>

UOPENE:	MOVEM B,DEVNUM(BB)	;SAVE DEVICE DESIGNATOR
	PUSHJ P,UOPENF		;DO THE OPEN COMMON CODE
	  POPJ P,		;[356] Failed
	JRST CPOPJ1		;[356] OPEN was sucessful
	JRST UOPEN6		;NOT A DISK, GO DO GTJFN NOW

UOPENF:	MOVE E,FLAGWD(BB)
	LDB AA,PDVNUM		;GET THE TOPS-20 DEVICE TYPE NUMBER
	CAIN AA,TTY		;IS THIS A TTY
	  PUSHJ P,[GJINF	;YES, GET CONTROLING TTY NUMBER
		HRRZ A,DEVNUM(BB)
		CAME A,D	;IS THIS THE CONTROLING TTY?
		  POPJ P,	;NO, JUST RETURN
		HLL E,TYSTAT	;YES, GET CURRENT STATE FLAGS
		TLO E,TT.CTY	;ADD CONTROLLING TERMINAL BIT
		MOVEM E,FLAGWD(BB) ;STORE BITS FOR CHANNEL
		MOVEI A,.CTTRM	;CONTROLLING TTY
		JRST TTPSTS]	;GO SET TERMINAL MODE AND RETURN
	MOVE C,DEVTBL(AA)	;GET LEGAL 10/50 MODE BITS
	ANDI E,17		;WHAT MODE
	MOVEI D,1
	ROT D,(E)		;PUT BIT IN 35-N
	TRNN C,(D)		;IS MODE LEGAL FOR THIS DEVICE
	 POPJ P,		;NO	****NOT RIGHT. SHOULD BE ILLMOD***
	CAILE E,14		;BUFFERED?
	JRST UOPEN4		;NO
	MOVSI C,004400		;FIDDLE WITH MODE NUMBER TO GET BYTE SIZE
	CAIGE E,10		;MODE >=10?
	MOVSI C,000700		;NO, 7 BIT, NOT 36
	MOVEI E,0
	MOVE D,BUFHTB(BB)
	TRNN D,-1		;IS THERE AN INPUT HEADER?
	JRST UOPNE1		;NO
;**;[345] REPLACE 3 WORDS @UOPNE0
UOPNE0:	XCTUU <HLLM C,1(D)>	;[345] STORE BYTE POINTER SIZE
	UMOVEM E,2(D)		;[345] STORE BYTE COUNT
	TRNE PF,R.FLP		;[345] A FILOP. UUO IN PROGESS?
	JRST UOPNE1		;[345] YES, THAT'S ENOUGH
	UMOVEM E,(D)		;[345] ZERO BUFFER ADDRESS
	XCTUU <HRRM C,1(D)>	;[345] ZERO BYTE POINTER ADDRESS

UOPNE1:	HLRZ D,D		;FIRST TIME LEFT HALF IS OUTPUT HEADER
	JUMPN D,UOPNE0		;EITHER NO OUT HDR OR SECOND TIME THRU

UOPEN4:	MOVSI B,INITF		;CHANNEL INIT'ED
	IORB B,FLAGWD(BB)	;MARK IT.
;**; Insert two lines at UOPEN4 + 1 1/2
	CAIN AA,.DVNUL		;[332] NUL?
	JRST CPOPJ2		;[332] YES, FORGET ALL THIS
	MOVE B,DEVTBL(AA)
	TLNE B,DTADEV!DSKDEV	;DECTAPE OR DSK?
	  JRST CPOPJ1		;YES, CAN'T GTJFN YET.
	MOVE B,DEVTBL(AA)
	TLNN B,MTADEV		;IS IT A MAGTAPE?
	JRST CPOPJ2		;NO, ALL DONE
	SETZM MTADAT(BB)	;INITIALIZE DATA WORD
	MOVSI A,MTARDB		;GET READ BACKWARDS FLAG
	ANDCAM A,FLAGWD(BB)	;AND CLEAR IT
	MOVE A,DEVNUM(BB)	;GET DEVICE DESIGNATOR
	TLO A,(1B3)		;SUPRESS READING DIRECTORY
	MOUNT
	  JRST UOPNF		;MOUNT FAILED GO TRAP OR BOMB
	JRST CPOPJ2		;GIVE DOUBLE SKIP RETURN FOR NON-DISK DEVICES

UOPEN6:	MOVS A,DEVNAM(BB)	;GET DEVICE NAME
	CAIE A,'TTY'		;TTY?
	JRST UOPEN7		;NO
	MOVEI A,PROJFN		;YES, USE PRIMARY
	JRST UOPEN8		;GO STORE JFN

UOPEN7:	PUSHJ P,SETJBK		;SET UP JBLOCK
	SETZM JBLOCK		;  FOR GTJFN
	MOVEI A,JBLOCK
	HRROI B,STRNG1		;GET POINTER TO MAIN STRING
	GTJFN
	  JRST MRETN		;GIVE ERROR TO USER
UOPEN8:	MOVEM A,JFNTAB(BB)
	DVCHR			;GET CHARACTERISTICS
	TXNN B,DV%AV		;AVAILABLE TO THIS JOB?
	JRST UOPEN9		;NO, GIVE FAILURE RETURN
	CAIE AA,PTY		;IS THIS A PTY
	  JRST CPOPJ1		;[356] No, then done
	PUSHJ P,PTYSTF		;YES, GO START UP THE FORKS
	SKIPA
	 JRST CPOPJ1		;[356] Sucessful
UOPEN9:	PUSHJ P,URELJ		;GO RELEASE JFN AND CLEAR INIT BLOCK
	POPJ P,			;[356] Give an error return

UOPNF:	PUSHJ P,MNTFAI		;SEE IF TRAP WAS SET UP
	JFCL
	PUSHJ P,ERROR		;NO, TYPE OUT ERROR (NO RETURN)

PDVNUM:	POINT 6,DEVNUM(BB),17		;NUMERIC DEVICE TYPE FROM DESIGNATOR

UINBUF:	TLOA C,-1
UOUTBF:	TLZ C,-1
	PUSHJ P,SETUP
	MOVE D,FLAGWD(BB)
	TLNN D,INITF		;CHANNEL INIT'ED?
	PUSHJ P,ERRCHN		;NO-YOU LOSE
	MOVE CC,BUFHTB(BB)
	TLNN C,-1		;HEADER POINTER ALREADY IN RIGHT HALF?
	HLRZ CC,CC		;OBUF,IBUF_0,OBUF
	MOVSI B,INBUFF
	TLNN C,-1
	MOVSI B,OUTBFF
	HRRZ C,FORTY		;NUMBER OF BUFFERS IN RING
	CAIN C,0		;DID USER SPECIFY ZERO BUFFERS?
	MOVEI C,2		;YES, GIVE HIM TWO
	PUSHJ P,IOBUF
	JRST MRETN

IOBUF:	IORM B,FLAGWD(BB)
	PUSH P,C		;SAVE NUMBER OF BUFFERS WANTED
	MOVE B,DEVTB2(AA)	;GET DEFAULT BUFFER SIZE
	CAIE AA,LPT		;LINE PRINTER?
	CAIN AA,CDR		;OR CDR?
	JRST IOBUF1		;YES, WATCH OUT FOR SPOOLED DEVICES
	CAIE AA,MTA		;MAGTAPE?
	JRST IOBUF2		;NO
	PUSHJ P,GETMBS		;GET THE MAGTAPE BUFFER SIZE
	 MOVE B,DEVTB2(AA)	;FAILED, USE THE STANDARD
	MOVE B,A		;GET SIZE IN B
	JRST IOBUF2

IOBUF1:	HRRZ A,JFNTAB(BB)	;GET THE CHARACTERISTICS
	DVCHR			;TO SEE IF IT IS SPOOLED
	TLNE B,(1B3)		;ASSIGNABLE BIT = 0 MEANS SPOOLED
IOBUF3:	SKIPA B,DEVTB2(AA)	;PHYSICAL DEVICE, USE STD BUFFER SIZE
	MOVEI B,200		;SPOOLED DEVICE, USE 200
IOBUF2:	POP P,C			;GET BACK COUNT OF BUFFERS WANTED
	UMOVE D,.JBFF		;WHERE TO START RING
	MOVEI E,(D)		;SPARE COPY OF START
	MOVEI G,3(B)		;TOTAL LENGTH OF EACH BUFFER
	IMULI G,(C)		;TIMES NUMBER OF BUFFERS
	ADDI G,(D)		;PLUS BEGINNING ADDRESS
	CAILE G,PATLOC		;MUST BE BELOW COMPATIBILITY CODE
	PUSHJ P,ERRARG
	CAML G,JBREL		;IS THERE ENOUGH CORE NOW?
	PUSHJ P,XPAND		;NO, GET SOME MORE
	CAIGE D,20		;.JBFF POINT INTO ACS?
	  PUSHJ P,ITRAP		;YES, ADDRESS CHECK
	MOVSI F,400000		;RING USE BIT
	HRRI F,1(D)		;POINTER TO SECOND WORD OF FIRST BUFFER
	UMOVEM F,(CC)		;GOES IN FIRST WORD OF HEADER

	MOVSI F,1(B)		;SIZE+1 IN LH OF SECOND WORD  OF EACH BUFFER

UIOBFL:	HRRI F,1(D)		;POINTER TO SELF IN RIGHT HALF
	ADDI F,3(B)		;PLUS LENGTH OF A COMPLETE BUFFER
	CAIN C,1		;EXCEPT THE LAST BUFFER
	HRRI F,1(E)		;WHICH POINTS BACK TO THE FIRST

	UMOVEM F,1(D)		;SET  RING PTR TO XWD SIZE+1,NXTBUF+1

	ADDI D,3(B)		;POINT BEYOND THIS BUFFER
	SOJG C,UIOBFL		;BACK IF MORE BUFFERS TO SET UP
	XCTUU <HRRM D,.JBFF>	;SET .JBFF BEYOND BUFFERS
	POPJ P,

ULOOKP:	PUSHJ P,SETUP
	MOVE D,FLAGWD(BB)
	TLNN D,INITF
	PUSHJ P,ERRCHN
	PUSHJ P,UULKP		;[356] Call the routine to do the work
	  JRST LOOKER		;[356] Failed - Store the error code and return
	JRST MRETN2		;[356] Good return to the user

;**;[403] At ULOOKP: +11L, Inserted 17 lines                SM 30-Jun-82
;[403] Call here to see if the MTA on Channel BB is a labeled tape.
;[403] This returns tape type in A and skips if the tape is labeled
;[403] If unlabeled, return 0 and do not skip.

LABCHK:	HRRZ	A,JFNTAB(BB)	;[403] GET THE JFN FOR THE MTOPR
	MOVEI	B,.MORLI	;[403] FUNCTION TO GET TAPE INFO
	MOVEI	C,2		;[403] JUST NEED FIRST FEW WORDS
	MOVEM	C,LABDAT+0	;[403] SO SET ARG BLOCK LENGTH ACCORDINGLY
	MOVEI	C,LABDAT	;[403] POINTER TO ARG BLOCK
	MTOPR			;[403] DO IT
	 ERJMP	NOTLAB		;[403] HMMM... MUST BE UNLABELED!
	MOVE	A,LABDAT+1	;[403] GET THE LABEL TYPE
	CAIN	A,.LTUNL	;[403] WAS IT LABELED?
NOTLAB:	TDZA	A,A		;[403] NO, RETURN 0
	AOS	(P)		;[403] YES, GIVE THE SKIP RETURN
	RET

;[356] Here to do the LOOKUP UUO.  This routine is also called from the FILOP
;[356] processing as well as the LOOKUP processing.

;**;[402] At UULKP:, Added 2 lines               	SM	22-Mar-82
UULKP:	CAIN AA,MTA		;[402] IF MAGTAPE, LOOKUP MAY BE MEANINGFUL
;**;[403] At UULKP: +1L, Replaced 1 line with 3             SM 30-Jun-82
	JRST	[PUSHJ	P,LABCHK ;[403] IT IS. IS IT LABELED?
		 JRST	CPOPJ1	;[403] NO, JUST LEAVE
		 JRST	UULKPQ]	;[403] YES, TREAT AS DIRECTORY
	PUSHJ P,DIRCHK		;SKIP IF HAS DIRECTORY
	  JRST CPOPJ1		;[356] No, No-op
IFN FTFILSER,<
	HLRZ A,DEVNAM(BB)	;GET GENERIC NAME
	CAIN A,'DPA'		;THIS A TOPS-10 DPA?
	  JRST TLKUP		;YES, DO ITS OWN LOOKUP
>
;**;[402] At UULKP: +9L, Added label			SM	22-Mar-82
UULKPQ:	SETZM IOCNT		;CLOSE THIS CHANNEL
	PUSHJ P,UCL1R		;CLOSE IT AND RELEASE JFN
	MOVE B,DEVTBL(AA)
;**;[402] At UULKPQ: +3L, Added 2 lines         	SM	22-Mar-82
	TLNE B,MTADEV		;[402] IS THIS A MAGTAPE?
	JRST ULK6		;[402] YES, JUST GTJFN
	TLNE B,DTADEV!DSKDEV	;DECTAPE OR DSK?
	JRST ULK6		;YES- DO GTJFN NOW
	SKIPN A,JFNTAB(BB)	;NO- MUST HAVE JFN ALREADY
	PUSHJ P,ERRCHN
	JRST ULK7

ULK6:	CAIE AA,DTA		;IS THIS A DTA?
	  JRST ULK6B		;NO
	MOVE A,FLAGWD(BB)	;GET OPEN BITS
	TRNE A,100		;OPENED IN NON-STANDARD MODE?
	 JRST CPOPJ1		;[356] Yes, LOOKUP is a no-op that skips
	PUSHJ P,DTAINI		;CLOSE ALL OTHER OPEN JFNS FOR THIS DTA
	PUSHJ P,DTAMNT		;YES, GO MOUNT IT
	  JRST DTMNTF		;MOUNT FAILED, GO MENTION THIS FACT
ULK6B:	PUSHJ P,LUKPAR		;TRANSLATE LOOKUP/ENTER PARAMS INTO STRINGS
	  JRST ER1		;BAD UFD SPECIFICATION
	MOVE B,DEVTBL(AA)	;GET TYPE OF DEVICE
	HLRZ A,EXT(BB)		;GET EXTENSION NAME
	TLNE B,DSKDEV		;IS THIS A DISK?
	CAIE A,(SIXBIT/UFD/)	;AND ARE WE LOOKING UP A UFD?
	  SKIPA			;NO TO ONE OF THE ABOVE QUESTIONS
	PUSHJ P, ULKUFD		;YES, GO SIMULATE UFD READING
	  MOVX A,GJ%OLD!GJ%IFG	;THIS GETS SKIPPED ON A SUCCESFUL ULKUFD RETURN
	HRROI B,STRNG1		;SET UP STRING POINTER
	MOVEM A,JBLOCK		;SAVE FLAGS
	MOVEI A,JBLOCK		;SET UP FOR LONG FORM GTJFN
	GTJFN
	  JRST ULKERR		;[356]
	MOVEM A,JFNTAB(BB)	;ASSIGNED JFN
	PUSHJ P,FILDIR		;UPDATE DIRNUM(BB)

ULK7:	PUSHJ P,ULKOPN		;GO OPEN THE JFN
	  JRST CVTERR		;[356] Convert TOPS-20 error to TOPS-10
	JRST CPOPJ1		;[356] LOOKUP is finished

;[356] Here to check for special error cases

ULKERR:	MOVE	B,FLAGWD(BB)	;[356] Get the flags
	TLNE	B,RDUFDF	;[356] Reading a UFD ?
	 JRST	UFDEMT		;[356] Yes
	CAIE	A,GJFX24	;[356] No new files error ?
	 JRST	CVTERR		;[356] No, convert the error code
	JRST	ER0		;[356] Yes, give a FNFERR

UFDEMT:	MOVSI	B,UFDEOF	;[356] Flag an EOF
	IORM	B,FLAGWD(BB)	;[356] . . .
	JRST	ULK7		;[356] And continue processing

ULKOPN:	MOVEI B,OF%RD		;OPEN FOR INPUT
ULKOP0:	PUSHJ P,OPENX
	 JRST [	CAIE A,OPNX8	;NOT MOUNTED?
		 POPJ P,
		JRST INMNTF]	;YES, GO COMPLAIN
ULKOP1:	MOVSI B,IOPENF!LOOKPF
	IORM B,FLAGWD(BB)	;DENOTE FILE OPEN SO CLOSE WILL REALLY CLOSE
	SKIPN AA		;IS THIS THE DISK?
	  PUSHJ P,OPNDSK	;YES, GO SET UP EOF POINTER
	MOVSI D,DSKDEV		;MULTIPLE DIRECTORY DEVICE BIT
	TDNN D,DEVTBL(AA)	;IS IT ONE OF THOSE?
	JRST CPOPJ1		;NO, ALL DONE FOR NOW
	MOVSI D,RDUFDF		;READING THE UFD?
	TDNE D,FLAGWD(BB)
	JRST [	MOVSI F,(777B8)	;SET UFD PROTECTION TO LOWEST
		JRST ULK2A]	;TEMPORARY ****

	HRRZ A,JFNTAB(BB)	;SET UP JFN
	MOVSI B,22		;XWD 22,0 I.E. WHOLE FDB
	MOVEI C,FDBB		;PSB BUFFER FOR FILE DESCRIPTOR BLOCK
	GTFDB
	 ERJMP CPOPJ1
	MOVE B,FDBB+FDBREF	;LAST REF DATE AND TIME
	PUSHJ P,NODATE
	ANDI D,7777		;12 BITS ONLY
;**;[438] DELETE 4 LINES AT ULKOP1:+18.L	DSW	7/12/85
	TRNE PF,R.UEXT		;EXTENDED LOOKUP?
	JRST ULK8
	XCTUU <HRRM D,1(G)>	;2 FOR MDD
	XCTLB <DPB C,[POINT 3,1(G),23]> ;STORE 3 HIGH ORDER DATE BITS
	JRST ULK2
ULK8:	XCTUU <HRRM D,3(G)>
	XCTLB <DPB C,[POINT 3,3(G),23]> ;STORE 3 HIGH ORDER DATE BITS

ULK2:	SETZ F,			;INIT PROTECTION WORD
	MOVE A,[POINT 6,FDBB+FDBPRT,17]
	MOVE B,[POINT 3,F]
	MOVEI E,3		;SET UP FOR THREE PROTECTION FIELDS
ULK2L:	ILDB D,A		;GET THE FIRST PROTECTION CLASS
	MOVEI C,7		;ASSUME HIGHEST PROTECTION
	TRNE D,10		;EXECUTE?
	 MOVEI C,6		;YES, REDUCE PROTECTION
	TRNE D,40		;READ?
	 MOVEI C,5		;YES, REDUCE PROTECTION
	TRNE D,4		;APPEND?
	 MOVEI C,3		;YES, REDUCE PROTECTION
	TRNE D,20		;WRITE?
	 MOVEI C,0		;YES, NO PROTECTION (0)
	IDPB C,B		;STORE THIS FIELD IN F
	SOJG E,ULK2L		;LOOP BACK FOR THREE TIMES

	MOVE B,FDBB+FDBWRT	;CREATION DATE OF THIS VERSION
	PUSHJ P,NODATE
	IOR F,D			;ADD DATE,TIME TO PROT ALREADY IN F0-8
	LDB B,[POINT 4,FDBB+FDBBYV,17] ;NOW GET MODE
	DPB B,[POINT 4,F,12]	;RETURN MODE OF LAST OPEN TO USER
ULK2A:	TRNE PF,R.UEXT		;EXTENDED LOOKUP
	JRST ULK9
	UMOVEM F,2(G)		;PROTECTION,0 MODE,TIME AND DATE
	XCTLB <DPB C,[POINT 3,1(G),20]>	;STORE HIGH ORDER 3 DATE BITS
	JRST ULK3
ULK9:	UMOVE E,0(G)		;GET # OF ELEMENTS IN EXTENDED LIST
	CAIGE E,4		;SHOULD WE RETURN PROTECTION
	  JRST ULK3		;NO
	UMOVEM F,4(G)
	XCTLB <DPB C,[POINT 3,3(G),20]>	;STORE HIGH ORDER 3 DATE BITS

ULK3:	LDB B,[POINT 6,FDBB+FDBBYV,11]	;BYTE SIZE
	SKIPN B			;IS B 0?
	  MOVEI B,^D36		;YES, AVOID THE DIVIDE BY 0 AND USE 36
	MOVEI A,^D36
	IDIVI A,(B)		;NO OF BYTES IN A WORD
	MOVE B,FDBB+FDBSIZ	;NO OF BYTES IN FILE
	IDIVI B,(A)		;NO OF WORDS IN FILE
	SKIPE C			;INTEGER WORDS
	ADDI B,1		;ROUND UP
;**;[438] INSERT 3 LINES AT ULK3:+9.L	DSW	7/12/85
	MOVE A,FLAGWD(BB)	;[438] SEE IF A UFD OR MFD
	TLNN A,RDUFDF!RDMFDF	;[436][438] BY TESTING THESE BITS
	  MOVEM B,IOEOFP(BB)	;[436][438] IT IS NOT, SAVE THE EOF
	TRNE PF,R.UEXT		;EXTENDED LOOKUP?
	JRST ULK10
	CAILE B,377777		;<128K WORDS?
	JRST ULK4		;NOPE
	MOVNI B,(B)		;YES, -NO OF WORDS
	JRST ULK5
ULK4:	TRNE B,177		;EVEN NO OF BLOCKS?
	ADDI B,200		;NO, ROUND UP 1 BLOCK
	ASH B,-7		;CONVERT WORDS TO 128 WORD BLOCKS
ULK5:	XCTUU <HRLZM B,3(G)>
	JRST ULK11
ULK10:	MOVE A,DIRNUM(BB)	;GET DIRECTORY NUMBER
	PUSHJ P,PPNUNM		;CONVERT TO PPN
	UMOVEM A,1(G)		;RETURN TO USER
	CAIGE E,5		;ENOUGH ROOM FOR WORD COUNT
	  JRST ULK11		;NO
	UMOVEM B,5(G)		;STORE WORD COUNT
	MOVEI C,6(G)		;ZERO THE EXTENDED LOOKUP AREA
	MOVEI B,6		;STARTING AT ITEM 7
ULK10A:	CAMLE B,E		;DONE?
	  JRST ULK10B		;YES
	XCTUU <SETZM (C)>	;ZERO ELEMENT
	AOS C
	AOJA B,ULK10A		;LOOP BACK

ULK10B:	CAIGE E,11		;WANT SIZE IN BLOCKS?
	  JRST ULK11		;NO
	HRRZ A,FDBBYV+FDBB	;YES, GET SIZE IN PAGES
	ASH A,2			;MULTIPLY BY 4 TO GET BLOCKS
	UMOVEM A,10(G)		;RETURN ALLOCATED BLOCKS
	UMOVEM A,11(G)		;AND ACTUAL BLOCKS
	CAIGE E,16		;WANT .RBDEV?
	  JRST ULK11		;NO
	MOVE B,DEVNAM(BB)	;GIVE USER THE DEVICE NAME
	UMOVEM B,16(G)
	CAIGE E,25		;WANT QUOTA'S
	  JRST ULK11		;NO
	MOVSI A,RDUFDF		;ARE WE READING A UFD
	TDNN A,FLAGWD(BB)
	  JRST ULK10C		;NO, DONT GIVE THIS INFO
	GJINF			;SEE IF THIS IS FOR CONNECTED DIR
	CAME B,DIRNUM(BB)	;...
	  JRST ULK10C		;NO, CANNOT GET THIS INFO
	SETO A,			;THE CONNECTED DIR
	GTDAL			;GET DIR ALLOCAATION
	LSH A,2			;TURN PAGES INTO BLOCKS
	UMOVEM A,22(G)		;STORE AS FCFS QUOTA LEFT
	UMOVEM A,23(G)		;STORE LOGGED OUT QUOTA
	HRROI A,[ASCIZ/DSK/]	;USE CURRENT CONNECTED STR
	PUSHJ P,PAGUSE		;GET NUMBER OF PAGES IN USE
	ASH A,2			;TURN PAGES INTO BLOCKS
	UMOVEM A,25(G)		;STORE BLOCKS
ULK10C:	CAIGE E,26		;WANT .RBAUT?
	  JRST ULK11		;NO
	HRROI B,STRNG1		;NOW GET THE AUTHOR NAME
	HRROI A,[ASCIZ/PS:</]	;BUILD THE STR/DIR NAME STRING
	SETZ C,
	SIN
	MOVSI A,.GFAUT		;NOW ADD THE AUTHOR'S NAME
	HRR A,JFNTAB(BB)	;FROM THE JFN
	GFUST			;GET FILE USER NAME STRING
	 ERJMP ULK10D		;IF NONE, SKIP IT
	MOVEI A,">"		;CLOSE THE STRING
	IDPB A,B		;NOW HAVE "PS:<DIR>"
	MOVEI A,0		;FOLLOW IT WITH A NULL
	IDPB A,B
	HRROI A,STRNG1		;NOW GET THE PPN
	STPPN
	 ERJMP ULK10D
	UMOVEM B,26(G)		;STORE IN ARRAY
ULK10D:	CAIGE E,35		;WANT .RBTIM?
	  JRST ULK11		;NO
	MOVE B,FDBB+FDBWRT	;GET DATE OF THIS VERSION
	UMOVEM B,35(G)		;STORE
ULK11:	JRST CPOPJ1


;THIS ROUTINE CALCULATES THE NUMBER OF PAGES CURRENTLY ALLOCATED
;IN THE CONNECTED DIRECTORY. IT IS CALLED BY:
;		MOVE A,[POINT 7,[ASCIZ/STR/]]
;		PUSHJ P,PAGUSE
;
; RETURNS +1 ALWAYS WITH A=NO OF PAGES

PAGUSE:
	SETO A,
	GTDAL			;GET QUOTA AND USED PAGES
	MOVE A,B		;RETURN USED PAGES
	POPJ P,

DATE:	SETO B,			;TO REQUEST CURRENT TAD
	PUSHJ P,NODATE
	ANDI D,7777		;12 BITS WORTH ONLY
	LSH C,^D12		;GET HIGH ORDER DATE BITS
	IOR D,C			;PUT IN HIGH ORDER 3 BITS FOR DATE 75
	MOVE A,D		;DATE TO A FOR RETURN TO USER
	JRST STOTAC		; ..

;GET 12 BIT DATE INTO AC D AND HIGH ORDER THREE BITS INTO AC C

NODATE:	SETZ D,			;NORMAL FLAGS
	ODCNV			;GET YEAR, MONTH, DAY, ETC.
	ERJMP [	SETO B,		;ERROR, GET TODAY'S DATE
		JRST NODATE]
	HRRZ A,D		;SAVE SECONDS SINCE MIDNIGHT
	HLRZ D,B		;YEAR
	SUBI D,^D1964		;CONVERT TO 10/50 FORMAT, I.E. ...
	IMULI D,^D12		;(YEAR-1964)*12
	ADDI D,0(B)
	IMULI D,^D31		;((YEAR-1964)*12+(MONTH-1))*31
	HLRZ C,C
	ADDI D,0(C)		; ... +DAY-1
	LDB C,[POINT 3,D,23]	;GET HIGH ORDER THREE BITS FOR DATE-75
	ANDI D,7777		;12 BITS ONLY
	IDIVI 	A,^D60		;MINUTES
	ANDI A,3777		;ONLY 11 BITS WORTH
	LSH A,^D12
	IOR D,A
	POPJ P,

OPENX:
IFN FTFILSER,<
	HLRZ D,DEVNAM(BB)	;GET GENERIC NAME
	CAIN D,'DPA'		;TOPS-10 PACK?
	  JRST CPOPJ1		;YES, DO NOTHING
>
	SETZM IOBYTP(BB)	;INITIALIZE POINTER TO START OF FILE
	SETZM IOEOFP(BB)	;AND POINTER TO END OF FILE
	MOVE D,FLAGWD(BB)
	TLNE D,RDUFDF		;ARE WE READING A UFD?
	  JRST CPOPJ1		;YES, SO DONT OPEN THE JFN
	TLNE D,INITF		;IS IT INIT'ED?
	SKIPN A,JFNTAB(BB)	;AND HAS IT A JFN?
	PUSHJ P,ERRCHN		;NO
	HRRZS A			;GET RH ONLY OF JFN
	CAIE A,PRIJFN		;PRIMARY INPUT JFN?
	CAIN A,PROJFN		;OR PRIMARY OUTPUT JFN?
	  JRST CPOPJ1		;YES, DONT RE-OPEN IT
	MOVE C,B		;SAVE MODE FOR OPENING
	GTSTS
	JUMPGE B,OPENX3		;IS FILE ALREADY OPEN?
	SKIPE MAPTAB(BB)	;ARE THERE PAGES MAPPED?
	  PUSHJ P,UNMAPP	;YES, GO UNMAP IT SO CLOSF WORKS
	TXNE B,GS%RDF		;YES.- OPEN FOR INPUT?
	TXO C,OF%RD		;YES- SAVE THAT INFO
	TXNE B,GS%WRF		;OPEN FOR OUTPUT?
	TXO C,OF%WR		;YES- SAVE THAT INFO
	TXO A,CO%NRJ+CZ%NUD	;PRESERVE THE JFN
	CLOSF			;AND CLOSE FILE
	PUSHJ P,ERROR
	PUSH P,C		;SAVE OPEN BITS
	JUMPN AA,OPENX5		;IF NOT A DSK, SKIPE THIS CHECK
	MOVE B,[XWD 1,1]	;GET WORD INDICATION DELETION
	MOVEI C,FDBTMP
	HRRZ A,A
	GTFDB
	 ERJMP OPENX5
	MOVX C,FB%DEL
	TDNN C,FDBTMP		;IS FILE DELETED?
	JRST OPENX5		;NO
;**;[436] CHANGE 1 LINE AT OPENX:+35.L	DSW	4/23/85
	HRLI A,FDBCTL(CF%NUD)	;YES, UNDELETE IT
	MOVSI B,(FDBDEL)
	SETZ C,
	CHFDB

OPENX5:	POP P,C
	HRRZ A,A

OPENX3:	MOVE B,C		;NOW IT CAN BE OPENED
	MOVEI C,17
	ANDI C,(D)		;MODE
	LDB AA,PDVNUM		;GET DEVICE TYPE NUMBER
	MOVE D,DEVTBL(AA)
	TLNE D,DTADEV		;IS THIS DUMP MODE TO DECTAPE?
	CAIG C,14
	SKIPA
	JRST OPENX1		;YES- OPEN IN DUMP MODE
	;[353] CHANGE @ OPENX3+11
	TLNN	D,MTADEV	;[353] IS THIS A MAGTAPE?
	JRST	OPNX3W		;[353] NO, CONT

	;[353] MAG-TAPE OPEN

	MOVSI	D,MTABFS	;MARK THAT BUFFERS ARE NOT SET UP
	ANDCAM	D,FLAGWD(BB)

	PUSHJ	P,MTLBSZ	;[353] SET AC A TO BYTE SIZE
	LSH	A,^D12		;[353] SHIFT INTO LEFT 4 OCTAL CHARS
	HRLI	B,(A)		;[353] SET OPENF BYTE SIZE
	CAIL C,15		; IS THIS A DUMP MODE?
	JRST OPENX1		;YES, GO SET UP FOR DUMP MODE
	JRST OPENX2		;NO, OPEN IT FOR SIN/SOUT MODE



;[353] MTLBSZ	ROUTINE TO FIND THE PROPER MTA BYTE SIZE
;[353]
;[353]		IF CALLED FROM OPEN CODE, AC B HAS OPEN BITS, FILE NOT OPEN
;[353]
;[353] RETURNS	+1  AC A=BYTE SIZE
;[353] 		SAVES USED AC'S
;[353] 		BAD ERRORS KILL IT

	;[353] CHECK FOR NON-36 BIT BYTE CASES
	;[353] FIRST SAVE SOME AC'S

MTLBSZ:	PUSH	P,C		;[353] SAVE SOME AC'S
	PUSH	P,D		;[353]
	PUSH	P,E		;[353]
	PUSH	P,B		;[353]

	PUSHJ	P,MTALAB	;[353] IS IT LABELED?
	JRST	MLBSZA		;[353] NO, CONT

	HRRZ	A,JFNTAB(BB)	;[353] GET JFN
	GTSTS			;[353] GET FILE STATUS
	TXNE	B,GS%OPN	;[353] IS FILE OPEN?
	JRST	MLBSZD		;[353] YES

	;[353] FILE NOT OPEN, AC B HAD OPEN BITS

	MOVE	B,(P)		;[353] RESTORE OPEN BITS
	TRNN	B,OF%WR		;[353] OPEN OUTPUT?
	JRST	MLBSZB		;[353] NO DO INPUT CASE
	JRST	MLBSZE		;[353] YES, DO OUTPUT CASE


MLBSZD:	TXNN	B,GS%WRF	;[353] OPEN FOR WRITE?
	JRST	MLBSZB		;[353] NO, DO INPUT CASE


	;[353] HERE FOR OPEN OUTPUT LABELED TAPE CHECK TO SEE IF ATTRIBUTES
	;[353] ARE SET FOR THE FILE USING A LOGICAL NAME

MLBSZE:	HRROI	A,E		;[353] INDICATE WANT RESULTS IN AC "E"
	HRRZ	B,JFNTAB(BB)	;[353] GET JFN
	MOVEI	C,JS%AT1	;[353] INDICATE SINGLE ATTRIBUTE,AC "D" HAS IT
	MOVE	D,[POINT 7,[ASCIZ /FORMAT/]] ;[353] INDICATE WANT FORMAT VALUE
	SETZ	E,		;[353] CLEAR DESTINATION
	JFNS			;[353] RETURN ANY FORMAT ATTRIBUTE SET
	 ERJMP	MLBSZC		;[353] ERROR ASSUME NONE SET
	ROT	E,7		;[353] RIGHT JUSTIFY CHAR
	CAIN	E,"U"		;[353] IS FORMAT "U"?
	JRST	MLBSZ6		;[353] YES USE 36-BIT BYTES

	;[353] LABELED F,S OR D FORMAT, SET 7 BIT (ANSI) OR 8 BIT (IBM) BYTES

	MOVE	C,LABBLK+1	;[353] GET LABEL TYPE
	CAIE	C,.LTEBC	;[353] IS IT EBCDIC?
	JRST	MLBSZ7		;[353] NO, THEN USE 7-BIT BYTES
	JRST	MLBSZ8		;[353] YES, THEN USE 8-BIT BYTES

	;[353] HERE FOR INPUT LABELED TAPE

MLBSZB: MOVE	E,LABBLK+4	;[353] GET FORMAT CHAR FOR INPUT CASE
	CAIN	E,"U"		;[353] IS IT U-FORMAT?
	JRST	MLBSZ6		;[353] YES, SET 36-BIT BYTES
	MOVE	C,LABBLK+1	;[353] GET LABEL TYPE
	CAIN	C,.LTEBC	;[353] IS IT EBCDIC?
	JRST	MLBSZ8		;[353] YES, THEN USE 8-BIT BYTES

	;[353] HERE FOR INPUT F,D,S FORMAT INPUT ANSI-LABEL

	PUSHJ	P,LABDDM	;[353] GET DATA MODE
	JRST	MLBSZ7		;[353] ANSI, SET 7-BIT BYTE
	JRST	MLBSZ8		;[353] INDUSTRY, SET 8-BIT BYTE
	JRST	MLBSZ7		;[353] OTHER, SET 7-BIT BYTE


	;[353] HERE IF NOT LABELED TAPE, IF INDUSTRY COMPATIBLE SET 8-BIT BYTE

MLBSZA:	PUSHJ	P,LABDDM	;[353] GET HARDWARE DATA MODE
	JRST	MLBSZ6		;[353] ANSI, SET 36 BIT BYTES
	JRST	MLBSZ8		;[353] INDUSTRY, SET 8-BIT BYTES
	JRST	MLBSZ6		;[353] OTHER, SET 36 BIT BYTES

	;[353] HERE IF LABELED OUTPUT WITH NO ATTRIBUTES SET

MLBSZC: PUSHJ	P,LABDDM	;[353] GET HARDWARE DATA MODE
	JRST	MLBSZ7		;[353] ANSI, SET 7-BIT BYTES
	JRST	MLBSZ8		;[353] INDUSTRY,SET 8-BIT BYTES
	JRST	MLBSZ6		;[353] NEITHER, ASSUME 36-BITS

	;[353] HERE IF 7-BIT BYTES

MLBSZ7:	MOVEI	A,7	 	;[353] SET 7-BIT BYTES
	JRST	MLBSZX		;[353] AND CONTINUE

	;[353] HERE IF 8-BIT BYTES

MLBSZ8:	MOVEI	A,^D8	 	;[353] SET 8-BIT BYTES
	JRST	MLBSZX		;[353] AND CONTINUE

	;[353] HERE IF 36-BIT BYTES

MLBSZ6:	MOVEI	A,^D36		;[353] SET 36-BIT BYTE
MLBSZX:	STOR	A,MTABYT	; [357] SET OPEN BYTE SIZE
	POP	P,B		;[353]
	POP	P,E		;[353] RESTORE THESE
	POP	P,D		;[353]
	POP	P,C		;[353]
	POPJ	P,		;[353] RETURN

;[353] LABDDM GET INDICATED DATA MODE FOR THIS TAPE
;[353]
;[353]	RETURNS		+1 IF ANSI-ASCII
;[353]			+2 IF INDUSTRY-COMPATIBLE
;[353]			+3 IF OTHER
;[353] USES AC A,B,C

LABDDM:	MOVE	B,FLAGWD(BB)	;[353] GET THE FLAGS
	TLNN	B,MTADMS	;[353] HAS THE DATA MODE BEEN SET
	JRST	LBDDM1		;[353] NO, CHECK DEFAULT SETTING
	LOAD	C,MTADM		;[353] GET DATA MODE WORD
	HRRE	C,TPSDMT(C)	;[353] GET DATA MODE
	JRST	LBDDM2		;[353] CONT

	;[353] NO DATA MODE SET, CHECK FOR DEFAULT OF ANSI-ASCII/IND-COMPT

LBDDM1:	SETO	A,		;[353] A=-1, THIS JOB
	HRROI	B,C		;[353] GET ONE WORD AND PUT IT IN C
	MOVEI	C,.JIDM		;[353] START AT THE DEFAULT DATA MODE WORD
	GETJI			;[353] GET THE DATA MODE
	 JFCL			;[353] ERROR, ASSUME NONE SET

LBDDM2:	CAIN	C,.SJDMA	;[353] ANSI-ASCII?
	POPJ	P,		;[353] YES, RET
	CAIE	C,.SJDM8	;[353] INDUSTRY-COMPATIBLE?
	AOS	(P)		;[353] NO,DOUBLE SKIP
	AOS	(P)		;[353] YES,SKIP
	POPJ	P,		;[353] RET


;[353] MTALAB:	ROUTINE TO SEE IF FILE IS LABELED TAPE
;[353]
;[353] RETURNS	+1	IF UNLABELED
;[353]		+2	IF LABELED , LABBLK HAS LABEL INFORMATION,C=LABEL TYPE
;[353]
;[353] USES AC	A,B,C,D

MTALAB:	MOVEI	C,LABBLK	;[353] GET START OF ARG BLOCK
	SETZM	(C)		;[353] CLEAR FIRST ARG
	MOVE	B,[LABBLK,,LABBLK+1] ;[353] SET BLT PTR
	BLT	B,14(C)		;[353] CLEAR ARG BLOCK (15 WORDS)
	MOVEI	B,15		;[353] INDICATE SIZE OF ARG BLOCK
	MOVEM	B,(C)		;[353] AND SET IT
	HRRZ	A,JFNTAB(BB)	;[353] RESTORE JFN
	GTSTS			;[353] GET FILE STATUS
	TXNE	B,GS%OPN	;[353] SKIP IF FILE NOT OPEN
	JRST	MTLABC		;[353] ALREADY OPEN

	MOVE	B,[440000,,200000] ;[353]
	OPENF			;[353] DO VANILLA OPEN
	ERJMP	LBOPER		;[353] ERROR,  GIVE MESS AND QUIT
	TLOA	D,-1		;[353] SKIP, SET AC E NON-ZERO,FILE WAS CLOSED
MTLABC:	SETZ	D,		;[353] INDICATE FILE WAS OPEN
	HRRZ	A,JFNTAB(BB)	;[353] RESTORE JFN
	MOVEI	B,.MORLI	;[353] INDICATE GET LABEL INFORMATION
				;[353] ARG BLOCK STARTS AT LABBLK,C SET ABOVE
	MTOPR			;[353] GET LABEL INFO
	 ERJMP	MTLABX		;[353] ERROR, ASSUME UNLABELED
	MOVE	C,LABBLK+1	;[353] GET LABEL TYPE
	CAIE	C,.LTUNL	;[353] CHECK FOR UNLABELED CASE
	AOS	(P)		;[353] NO,LABELED, SKIP RETURN
MTLABX:	JUMPE	D,MTLABZ	;[353] SKIP CLOSE IF FILE WAS OPEN
	TXO	A,CO%NRJ	;[353] INDICATE SAVE JFN
	CLOSF			;[353] CLOSE IT
	JRST	LBOPER		;[353] ERROR, GIVE MESS AND QUIT
MTLABZ:	POPJ	P,		;[353] RETURN, LABBLK HAS LABEL INFO



	;[353] HERE FOR NON-MTA OPEN

OPNX3W:	HRLI B,070000		;[353] NOT MTA, OPEN IN ASCII MODE
	CAIN AA,CDR		;CARD READER?
	JRST [	CAIN C,10	;IMAGE MODE?
		HRLI B,204000	;YES, SET UP SPECIAL MODE
		HRRZ A,JFNTAB(BB) ;GET THE DEVICE CHARACTERISTICS
		PUSH P,B	;SAVE THE BYTE POINTER
		DVCHR
		MOVE A,B
		POP P,B
		TLNN A,(1B3)	;IS THIS THE SPOOLED CDR?
		HRLI B,440000	;YES, OPEN IN 36 BIT MODE
		JRST OPENX2]	;GO DO OPENF
	CAIN AA,PLT		;IS THIS A PLOTTER?
	  JRST [HRLI B,060000	;YES, ASSUME 6-BIT BYTES
		CAIL C,10	;BINARY MODE?
		  HRLI B,440000	;YES, USE 36-BIT WORDS
		JRST OPENX2]	;GO OPEN PLOTTER
	TLNE D,PTRDEV+PTPDEV	;IS PAPER TAPE?
	JRST [	CAIGE C,10	;YES, ASCII MODE?
		JRST OPENX2	;YES
		HRLI B,100000	;BYTE SIZE IS 8 IF IMAGE MODE
		CAIL C,13
		HRLI B,440000	;36 IF BINARY MODE
		DPB C,[POINT 4,B,9] ;PASS ALONG MODE
		JRST OPENX2]
	TLNN D,HASDIR		;UNLESS THIS IS A DIRECTORY DEVICE
	CAIL C,10		;OR BINARY MODE SPECIFIED
	HRLI B,440000		;IN WHICH CASE USE BINARY MODE
	JRST OPENX2

OPENX1:	HRLI B,447400	;DUMP MODE

OPENX2:	CAIN AA,PTY		;IS THIS A PTY?
	  HRRI B,OF%RD!OF%WR	;YES, ALWAYS OPEN IT IN READ AND WRITE
	HRRZ A,JFNTAB(BB)
	TXO B,OF%NWT		;NEVER WAIT FOR DEVICES
	OPENF
	 JRST OPENX4
	JUMPE AA,CPOPJ1		;IF THIS IS A DISK, GO SET UP POINTERS
	CAIN AA,PTY		;IS THIS A PTY?
	  JRST OPNPTY		;YES, GO MARK THAT IT WAS OPENED
	MOVE B,DEVTBL(AA)
	TLNE B,MTADEV		;MAGTAPE?
	PUSHJ P,MTASTS		;YES, SET MTA STATUS
	MOVE B,DEVTBL(AA)
	TLNE B,TTYDEV		;TTY?
	PUSHJ P,TTYSET		;YES, SETUP MODES
	JRST CPOPJ1

OPENX4:	CAIE A,OPNX8		;UNMOUNTED DEVICE?
	  POPJ P,		;NO, GIVE ERROR RETURN
	MOVE B,DEVTBL(AA)
	TLNN B,PTRDEV		;PAPERTAPE READER?
	  POPJ P,
	MOVEI A,^D5000
	DISMS			;GIVE THE OPERATOR ANOTHER 2 SEC.
	HRRZ A,JFNTAB(BB)
	JRST OPENX2		;AND TRY AGAIN

OPNDSK:	MOVE A,FLAGWD(BB)	;SEE IF A UFD OR MFD
	TLNE A,RDUFDF!RDMFDF	;...
	  POPJ P,		;YES, DONT SET IOEOFP
	PUSHJ P,GETEOF		;GET THE EOF FOR THIS FILE
	MOVEM A,IOEOFP(BB)	;SAVE IT AWAY
	POPJ P,			;AND RETURN


;ROUTINE TO GET THE EOF OF A FILE IN A

;**;[436] REPLACE ROUTINE GETEOF: AT GETEOF:	DSW	4/23/85
GETEOF:	PUSH P,B		;[436] SAVE SOME ACS
	PUSH P,C		;[436] ...
	PUSH P,D		;[436] 
;**;[447]At GETEOF:+3L replace 8 lines with 9 lines  JYCW  Nov/20/86
	HRRZ A,JFNTAB(BB)	;[436][447]Get JFN
	MOVE B,[XWD 1,.FBBYVU]	;[436][447]Get byte size from FDB
	MOVEI C,D		;[436][447]Use D as argument block
	SETZ D,			;[436][447]Clear D
	GTFDB			;[436][447]
	 ERJMP .+1		;[436][447]Ignore error
	SIZEF 			;[447]Get file byte count 
	 PUSHJ P,ERROR		;[447]Report any errors 
	MOVE A,B		;[436][447] Move byte count to A
	LDB B,[POINT 6,D,11]	;[436] GET BYTE SIZE IN B
	SKIPG B			;[436] DONT ALLOW 0
	  MOVEI B,^D36		;[436] FILE DOESN'T EXIST ASSUME 36 BIT BYTES
	MOVEI C,^D36		;[436] CALCULATE THE # OF BYTES PER WORD
	IDIVI C,(B)		;[436]  IS: (BITS PER WORD / BITS PER BYTE)
	IDIVI A,(C)		;[436] NOW GET # OF WORDS IN THE FILE
	SKIPE B			;[436] ANY ROUND OFF
	  AOS A			;[436] YES, COUNT PARTIAL WORD
;**;[447]At GETEOF:+19L delete 1 line JYCW  Nov/20/86
	POP P,D			;[436] ...
	POP P,C			;[436] ...
	POP P,B			;[436] ...
	POPJ P,			;[436] NOW RETURN
;[356]CVTERR - ROUTINE TO CONVERT A TOPS-20 FILE PROCESSING ERROR TO SOMETHING
;[356]	  A TOPS-10 PROGRAM WILL UNDERSTAND.
;[356]
;[356] USAGE:
;[356]	A CONTAINS TOPS-20 ERROR CODE
;[356]	PUSHJ	P,CVTERR		;[356] CONVERT THE ERROR
;[356]	(RETURN)
;[356]	B CONTAINS THE TOPS-10 ERROR CODE


CVTERR:	MOVSI	C,-LKERLN	;[356] SET UP TO SCAN TABLE OF ERROR CODES
LOOKLP:	HRRZ	B,LKERTB(C)	;[356] GET NEXT ERROR CODE FROM TABLE
	CAME	A,B		;[356] IS THIS A MATCH?
	AOBJN	C,LOOKLP	;[356] NO, TRY OTHER ERROR CODES
	JUMPL	C,.+2		;[356] JUMP IF THE ERROR WAS FOUND
ER0:	 TDZA	B,B		;[356] GET A ZERO FOR FNFERR
	HLRZ	B,LKERTB(C)	;[356] GET TOPS-10 ERROR CODE TO BE RETURNED
	POPJ	P,		;[356] RETURN TO THE CALLER

ER1:	SKIPA	B,[EXP IPPERR]	;[356] GET THE ILLEGAL PPN ERROR
ER5:	MOVEI	B,ISUERR	;[356] ILLEGAL SEQUENCE OF UUOS ERROR
	POPJ	P,		;[356] RETURN TO THE CALLER


LKERTB:	XWD	IPPERR,GJFX17	;[356]NO SUCH DIR
	XWD	PRTERR,GJFX24	;[356]NO NEW FILES
	XWD	PRTERR,GJFX29	;[356]DEV NOT AVAILABLE
	XWD	PRTERR,OPNX3	;[356]READ ACCESS NOT ALLOWED
	XWD	PRTERR,OPNX4	;[356]WRITE ACCESS NOT ALLOWED
	XWD	PRTERR,OPNX5	;[356]EXECUTE ACCESS NOT ALLOWED
	XWD	PRTERR,OPNX6	;[356]APPEND ACCESS NOT ALLOWED
	XWD	PRTERR,OPNX12	;[356]LIST ACCESS NOT ALLOWED
	XWD	PRTERR,OPNX13	;[356]ILLEGAL ACCESS
	XWD	PRTERR,OPNX15	;[356]NON-READ/WRITE ACCESS NOT ALLOWED
	XWD	PRTERR,DELFX1	;[356]CANNOT DELETE BECAUSE OF LACK OF PRIVELEGES
	XWD	PRTERR,CFDBX2	;[356]ILLEGAL TO CHANGE THESE FDB BITS
	XWD	PRTERR,RNAMX3	;[356]ACCESS TO DESTINATION NOT ALLOWED
	XWD	PRTERR,RNAMX8	;[356]ACCESS TO SOURCE NOT ALLOWED
	XWD	FBMERR,OPNX1	;[356]ALREADY OPEN
	XWD	FBMERR,OPNX9	;[356]FILE BUSY
	XWD	AEFERR,GJFX27	;[356]OLD FILE NOT ALLOWED
	XWD	TRNERR,OPNX16	;[356]FILE HAS BAD INDEX BLOCK
	XWD	NRMERR,GJFX23	;[356]NO ROOM IN DIR
	XWD	NRMERR,OPNX10	;[356]NO ROOM
	XWD	NRMERR,OPNX23	;[356]QUOTA EXCEEDED
	XWD	NETERR,GJFX22	;[356]NO ROOM IN JSB

LKERLN==.-LKERTB


;[356]LOOKER - ROUTINE TO STORE A TOPS-10 ERROR CODE INTO THE LOOKUP/ENTER/RENAME
;[356]	  BLOCK.

;[356] USAGE:
;[356]	MOVEI	B,ERROR.CODE
;[356]	PJRST	LOOKER

;[356] ROUTINE WILL RETURN TO THE USER.

LOOKER:	SKIPE	A,NEWJFN	;[356] Is there a JFN to be released ?
	RLJFN			;[356] Yes - Release it
	  JFCL			;[356] Don't care
	SETZM	NEWJFN		;[356] Clear so we dont do it again
	HRRZ	G,FORTY		;[356] Get the user argument list pointer
	TRNE	PF,R.UEXT	;[356] Extended LOOKUP/ENTER ?
	  JRST	LOOKR3		;[356] Yes - Store the error code differently
	XCTUU	<HRRM B,1(G)>	;[356] Put the error number in the right half of E+1
	JRST	MRETN		;[356] Return to the user (Error return)

LOOKR3:	XCTUU	<HRRM B,3(G)>	;[356] Store the error code in .RBEXT
	JRST	MRETN		;[356] And return to the user

;TRANSLATE LOOKUP AND ENTER PARAMETERS TO STRINGS

LUKPAR:	MOVSI G,RDUFDF!UFDEOF!DTADMP	;CLEAR BITS
	ANDCAM G,FLAGWD(BB)	;...
	SETZM EXT(BB)		;INITIALIZE A FEW FIELDS
	SETZM PROT(BB)
	SETZM DIRNUM(BB)
	HRRZ G,FORTY		;POINTER TO PARAMETER BLOCK
	UMOVE F,(G)		;NAME IN SIXBIT
	TRZ PF,R.UEXT		;INITIALIZE EXTENDED LOOKUP FLAG
	TLNN F,-1		;IS LEFT HALF ZERO?
	CAIGE F,3		;AND RIGHT HALF >= 3?
	  JRST LUKPR1		;NOT EXTENDED LOOKUP FORMAT
	TRO PF,R.UEXT		;YES - INDICATE EXTENDED ENTER BLOCK
	UMOVE D,2(G)		;GET FILE NAME
	MOVEM D,FILNAM(BB)
	JUMPE D,LUKPR2		;IF NULL FILE NAME, DONT BELIEVE REST OF ARGS
	UMOVE D,3(G)		;GET EXT
	HLLZM D,EXT(BB)
	UMOVE D,1(G)		;GET PPN
	MOVE A,DEVNAM(BB)	;GET SIXBIT DEVICE NAME
	PUSHJ P,GETDIR		;TRANSLATE IT TO DIRECTORY NUMBER
	  POPJ P,		;NO SUCH TRANSLATION
	MOVEM D,DIRNUM(BB)
	XCTLB <LDB D,[POINT 9,4(G),8]>	;GET PROTECTION VALUE
	CAIGE F,4		;WAS THIS SPECIFIED
	  MOVEI D,0		;NO, USE STANDARD
	PUSHJ P,GTPROT		;TRANSLATE TO TOPS-20 STYLE PROTECTION
	MOVEM D,PROT(BB)
	JRST LUKPR2		;GO SET UP JBLOCK

LUKPR1:	MOVEM F,FILNAM(BB)	;NOT EXTENDED TYPE LOOKUP BLOCK
	JUMPE F,LUKPR2		;IF NO NAME, IGNORE OTHER ARGUMENTS
	UMOVE D,1(G)		;GET EXT
	HLLZM D,EXT(BB)
	XCTUU <MOVE D,3(G)>	;GET PPN
	MOVE A,DEVNAM(BB)	;GET SIXBIT DEVICE NAME FOR GETDIR
	PUSHJ P,GETDIR		;GET DIRECTORY NUMBER
	  POPJ P,		;NO MAPPING
	MOVEM D,DIRNUM(BB)	;STORE DIR NUM
	XCTLB <LDB D,[POINT 9,2(G),8]>
	PUSHJ P,GTPROT		;GET TOPS-20 STYLE PROTECTION
	MOVEM D,PROT(BB)
LUKPR2:	AOS (P)			;INSURE A SKIP RETURN

SETJBK:	PUSHJ P,JBKSET		;GO INITIALIZE JBLOCK
	MOVE E,[POINT 7,STRNG1]
	SKIPE D,DEVNAM(BB)	;ANY DEVICE NAME
	  PUSHJ P,JDEV		;YES, GO ADD THIS TO STRING
	SKIPE B,DIRNUM(BB)	;ANY SPECIFIED DIRECTORY?
	 JRST [	HRROI A,STRNG1	;YES, PUT STR:<DIR> IN MAIN STRING
		DIRST
		 JRST .+1
		MOVE E,A	;USE THIS NEW STRING POINTER
		JRST .+1]
	SKIPN D,FILNAM(BB)	;GET FILE NAME
	  JRST SETJB1		;NONE, JUST EXIT
	PUSHJ P,SIX27V		;ADD THIS TO STRING
	MOVEI C,"."		;AND A "."
	IDPB C,E		;OVERWRITE 0 AT END
	MOVE D,EXT(BB)		;NOW ADD EXTENSION
	PUSHJ P,SIX27V
	MOVEI C,";"		;END WITH A ";"
	IDPB C,E
SETJB1:	MOVEI D,0
	IDPB D,E		;END STRING WITH 0
	POPJ P,			;RETURN

JBKSET:	MOVE A,[XWD 377777,377777]	;NO FILES
	MOVEM A,JBLOCK+1
	SETZM JBLOCK+2		;SYSTEM DEFAULTS ON EVERYTHING
	MOVE A,[XWD JBLOCK+2,JBLOCK+3]
	BLT A,JBLOCK+10
	POPJ P,
;ROUTINE TO GET A DIR NUMBER FROM A PPN
;ACCEPTS IN A/	SIXBIT DEVICE NAME
;	    D/	PPN
;USES DEVNAM, DIRNAM, AND STRNG1 AS SCRATCH STRINGS
;RETURNS +1:	NO TRANSLATION
;	 +2:	DIRECTORY NUMBER IN D AND POINTER TO STRING
;			CONTAINING DIR NAME IN AC A

GETDIR:	SKIPG D			;NEGATIVE OR 0 PPN?
	  TDZA D,D		;YES, LEAVE AS 0
	TLNE D,-1		;PATH POINTER?
	  JRST GETDR0		;NO
	UMOVE D,2(D)		;YES, GET PATH PPN
GETDR0:	JUMPE D,CPOPJ1		;IF NONE SPECIFIED JUST RETURN
	PUSH P,D		;SAVE THE PPN
	MOVE D,A		;GET DEV NAME TRANSLATED INTO ASCII
	HRROI E,DEVNM7		;INTO DEVNM7
	PUSHJ P,SIXTO7
	POP P,D			;GET BACK PPN
	PUSHJ P,PPNMAP		;SEE IF IT IS SPECIAL
	 SKIPA			;IT ISNT
	JRST GETDR4		;YES, STRING POINTER IS IN E
	HRROI A,STRNG1		;NOW GET DIR NUMBER
	MOVE B,D		;GET PPN
	HRROI C,DEVNM7
	PPNST			;TRANSLATE THE PPN
	 ERJMP CPOPJ		;NONE
	MOVE E,[POINT 7,STRNG1]	;GET POINTER TO STR/DIR STRING
GETDR4:	MOVE B,E		;GET STRING POINTER
	MOVX A,RC%EMO		;NO RECOGNITION
	RCDIR
	 ERJMP CPOPJ		;NONE
	TXNE A,RC%NOM!RC%AMB	;SUCCEED?
	POPJ P,			;NO
	MOVE D,C		;PUT DIRECTORY NUMBER IN D
	MOVE A,[POINT 7,DIRNAM]	;NOW BUILD DIR NAME STRING IN DIRNAM
GETDR1:	ILDB B,E		;GET A CHARACTER FROM STR/DIR STRING
	JUMPE B,CPOPJ		;FAILED
	CAIE B,"<"		;FOUND START OF DIR YET?
	JRST GETDR1		;NO, LOOP BACK UNTIL FOUND
GETDR2:	ILDB B,E		;GET NEXT DIR NAME CHARACTER
	JUMPE B,GETDR3		;REACHED THE END
	CAIN B,">"		;SEEN THE END?
	JRST GETDR3		;YES
	IDPB B,A		;STORE IT IN DESTINATION
	JRST GETDR2		;LOOP BACK UNTIL THE END IS REACHED

GETDR3:	MOVEI B,0		;END WITH A NULL
	IDPB B,A
	MOVE A,[POINT 7,DIRNAM]
	JRST CPOPJ1		;RETURN SUCCESSFUL


GTPROT:	SKIPN D			;DOES USER WANT DEFAULT
	  POPJ P,		;YES, LET SYSTEM SUPPLY DEFAULT
	SETZ A,			;INITIALIZE ANSWER
	MOVE C,[POINT 3,D,26]
	MOVEI B,3		;SET UP LOOP COUNTER
GTPRTL:	ILDB E,C		;GET NEXT FIELD
	MOVE E,PTAB(E)		;GET TRANSLATION
	LSH A,6
	IORI A,(E)		;ADD IN THIS FIELD
	SOJG B,GTPRTL		;LOOP FOR THREE FIELDS
	MOVE D,A
	POPJ P,

PTAB:	77			;0
	77			;1
	76			;2
	56			;3
	56			;4
	52			;5
;**;[375] At PTAB: +6L, Replaced 2 lines         	SM	13-Jan-82
	10			;6 ;[375] A more proper way...
	00			;7 ;[375] No access at all is more reasonable

JDEV:	CAMN D,[SIXBIT/SYS/]	;DEVICE SYS?
	  JRST JDEV1		;YES
JDEV0:	PUSH P,E		;SAVE STRING POINTER IN E
	MOVE E,[POINT 7,DEVNM7]	;GET POINTER TO DEVICE NAME BLOCK
	MOVEM E,JBLOCK+2	;STORE IN DEFAULT BLOCK
	PUSHJ P,SIX27V		;TRANSLATE TO ASCIZ
	POP P,E			;RESTORE MAIN STRING POINTER
	POPJ P,
JDEV1:	HRROI A,[ASCIZ/SYS/]	;CHECK FOR SYS AS A LOGICAL NAME
	STDEV			;...
	  TDZA A,A		;NOT DEFINED
	JRST JDEV0		;USE SYS AS A DEVICE NAME
	HRROI B,[ASCIZ/PS:<SUBSYS>/]	;GET SYSTEM DIRECTORY NUMBER
	MOVX A,RC%EMO		;NO RECOGNITION
	RCDIR
	 ERJMP JDEV2		;FAILED
	TXNE A,RC%NOM!RC%AMB
JDEV2:	MOVEI C,0		;FAILED, LEAVE NUMBER AS 0
	MOVEM C,DIRNUM(BB)	;SET UP NEW DIRECTORY NUMBER
	POPJ P,			;DEFAULT DEVICE TO DSK

;ROUTINE TO MAP PPN'S TO DIRECTORIES

;CALL:
;	MOVE A,PPN
;	MOVEI B,[ASCIZ/STR/]
;	PUSHJ P,PPN2DR
;	  ERROR - NO CONVERSION
;	SUCCESSFUL WITH DIR NUMBER IN A

PPN2DR:	PUSH P,A		;SAVE ACS
	PUSH P,B
	MOVE D,A		;GET PPN
	PUSHJ P,PPNMAP		;GO SEE IF IT IS SPECIAL
	 JRST PPN2D1		;NO
	POP P,0(P)		;NO LONGER NEED STR NAME
	POP P,0(P)		;OR PPN
	MOVE B,E		;SET UP TO TRANSLATE THIS STRING
	JRST PPN2D2

PPN2D1:	POP P,C			;GET POINTER TO STR NAME
	POP P,B			;GET PPN
	HRROI A,STRNG1		;SET UP TO RECEIVE STR/DIR STRING
	PPNST
	 ERJMP CPOPJ		;FAILED
	HRROI B,STRNG1		;NOW GET DIR NUMBER FROM STRING
PPN2D2:	MOVX A,RC%EMO		;NO RECOGNITION
	RCDIR
	 ERJMP CPOPJ		;FAILED
	TXNE A,RC%NOM!RC%AMB
	POPJ P,			;FAILED HERE TOO
	MOVE A,C		;GET DIR NUMBER INTO A
	JRST CPOPJ1		;GIVE SUCCESSFUL RETURN


;ROUTINE TO GET DIR NUMBER IF HASH TABLE NOT AROUND
;CALL:
;	MOVE D,PPN
;	PUSHJ P,PPNMAP
;	ERROR RETURN - NO MAPPING FOR THIS PPN
;	NORMAL RETURN - ASCIZ POINTER TO DIRECTORY NAME IN E

PPNMAP:	MOVSI C,-NPPN		;SET UP AOBJN COUNTER
	CAME D,PMAPTB(C)	;IS THIS A MATCH
	AOBJN C,.-1		;NO, LOOP BACK
	JUMPGE C,CPOPJ		;NO MATCH, GIVE NON-SKIP RETURN
	MOVE E,SMAPTB(C)	;GET ASCIZ STRING POINTER TO DIR
	JRST CPOPJ1		;SKIP RETURN

;ROUTINE TO MAP DIRECTORIES TO PPN'S
;CALL:	MOVE A,DIRNUM
;	PUSHJ P,PPNUNM
;	RETURN HERE WITH PPN IN A, ALL OTHER ACS WERE SAVED

PPNUNM:	PUSH P,D		;SAVE ALL ACS
	PUSH P,C
	PUSH P,B
	PUSH P,A
	JUMPE A,[GJINF		;IF 0 GIVE BACK OWN PPN
		MOVE A,B
		MOVEM A,0(P)	;PUT DIR NUM ON STACK
		JRST .+1]	;AND CONTINUE ON
	MOVSI D,-NPPN		;SET UP AOBJN POINTER
PPNLOP:	SKIPN C,DMAPTB(D)	;HAS THIS ENTRY BEEN TRANSLATED YET
	  PUSHJ P,[MOVE B,SMAPTB(D) ;NO, GET DIRNUM FOR THIS ENTRY
		MOVX A,RC%EMO	;NO RECOGNITION
		RCDIR		;GET DIR NUMBER
		 ERJMP CPOPJ	;NO TRANSLATION
		TXNE A,RC%NOM!RC%AMB
		POPJ P,		;NO TRANSLATION
		MOVEM C,DMAPTB(D) ;SAVE DIR NUMBER
		POPJ P,]
	CAMN C,0(P)		;IS THIS A MATCH
	  JRST [MOVE A,PMAPTB(D) ;YES, GET MAPPED PPN
		POP P,(P)	;POP OFF A
		JRST PPNDN1]	;CLEAN UP
	AOBJN D,PPNLOP		;LOOP FOR ALL MAPPED PPN'S
	POP P,A			;NO MATCH, USE THIS VALUE
	STPPN			;GET A PPN FROM THIS DIR NUMBER
	 ERJMP BUGSTP		;NO ERRORS ALLOWED
	MOVE A,B		;GET DIR NUMBER INTO A
PPNDN1:	POP P,B			;RESTORE ACS
	POP P,C
	POP P,D
	POPJ P,			;AND RETURN WITH PPN IN A

FILDIR:	JUMPN AA,CPOPJ		;IS THIS A DSK?
	HRROI A,DIRNAM		;YES, GET A DIR NUMBER FROM JFN
	HRRZ B,JFNTAB(BB)	;JFN
	MOVE C,[1B2!1B5!JS%PAF]	;GET STR:<DIR>
	JFNS			;...
	MOVX A,RC%EMO		;NOW GET DIR NUMBER
	HRROI B,DIRNAM		;DIR STRING
	RCDIR
	 ERJMP FILDR1		;FAILED
	TXNN A,RC%NOM!RC%AMB
	MOVEM C,DIRNUM(BB)	;SAVE DIR #
FILDR1:	MOVE A,JFNTAB(BB)	;RESTORE JFN
	POPJ P,

DEFINE MAPPPN
<	MAPGEN(<1,4>,<SUBSYS>)
	MAPGEN(<1,2>,<OPERATOR>)
	MAPGEN(<1,1>,<SYSTEM>)
>

DEFINE MAPGEN(A,B)
<	XWD A>

PMAPTB:	MAPPPN

NPPN=.-PMAPTB

DEFINE MAPGEN(A,B)
<	POINT 7,[ASCIZ/PS:<B>/]>

SMAPTB:	MAPPPN

UENTER:	PUSHJ P,SETUP		; [356]
	MOVE D,FLAGWD(BB)
	TLNN D,INITF
	PUSHJ P,ERRCHN
	PUSHJ	P,UUENTR	;[356] Call the ENTER code
	 JRST	LOOKER		;[356] Faield, give error return
	JRST	MRETN2		;[356] Good return


;[356] Here is the main ENTER processing code.  This code is called for
;[356] for the ENTER UUO and the FILOP UUO

UUENTR:	TRO PF,R.ENT		;[356] Mark that an ENTER is being done
;**;[402] At UUENTR: +1L, Added 1 line          	SM	22-Mar-82
;**;[403] At UUENTR: +2L, Replaced 1 line with 4            SM 30-Jun-82
	CAIN	AA,MTA		;[403] MTA?
	JRST	[PUSHJ	P,LABCHK ;[403] YES, IS IT LABELED?
		 JRST	CPOPJ1	;[403] NO, JUST GO BACK TO USER
		 JRST	UENT1]	;[403] YES, FLY ON
	CAIN AA,LPT		;LINE PRINTER?
	JRST UENT1		;YES, RELEASE THE JFN AND DO GTJFN AGAIN
	PUSHJ P,DIRCHK		;DIRECTORY TYPE DEVICE?
	  JRST CPOPJ1		;[356] No, nop
	MOVE A,DEVTBL(AA)	;DEVICE BITS
	TLNN A,DSKDEV		;A DISK?
	JRST UENT1		;NO
IFN FTFILSER,<
	HLRZ A,DEVNAM(BB)	;GET GENERIC NAME
	CAIN A,'DPA'		;TOPS-10 DSK?
	  JRST TENTER		;YES, GO DO FILSER ENTER
>
	MOVE A,FLAGWD(BB)	;YES. GET ITS ST@TUS
	TLnn A,IOPENF		;FILE ALREADY OPEN FOR INPUT?
	jrst uent1		;no
	pushj p,lukpar		;yes
	 jrst er1
	JRST ENTR4		;GO DO IT.
UENT1:	SETZM IOCNT		;PREPARE FOR CLOSE
	PUSHJ P,UCL1R		;CLOSE AND RELEASE JFN
	MOVEI D,17
	AND D,FLAGWD(BB)
	CAIE AA,DTA		;IS THIS A DTA?
	  JRST ENTR3A		;NO
	MOVE A,FLAGWD(BB)	;GET OPEN BITS
	TRNE A,100		;OPENED IN NON-STANDARD MODE?
	 JRST CPOPJ1		;[356] Yes, ENTER is a nop that skips
	PUSHJ P,DTAINI		;YES, GO CLOSE OTHER OPEN JFNS FOR THIS DTA
	PUSHJ P,DTAMNT		;GO MOUNT IT
	  JRST DTMNTF		;FAILED, GO COMPLAIN
ENTR3A:	PUSHJ P,LUKPAR		;SET UP SAME PARAMETERS AS LOOKUP
	  JRST ER1		;UNRECOGNIZABLE UFD
;**;[403] At ENTR3A: +2L, Replaced 6 lines with 9           SM 30-Jun-82
	SKIPE	D,FILNAM(BB)	;[403] GET SIXBIT FILENAME; IT IS NONZERO?
	JRST	ENTR3Q		;[403] YES, ITS OK
	CAIN	AA,LPT		;[403] NO, IS THIS AN LPT?
	JRST	ENTR3Q		;[403] YES, SO 0 FILENAME IS OK
	CAIE	AA,MTA		;[403] IS AN MTA?
	JRST	ER0		;[403] NO, SO THE 0 IS REALLY ILLEGAL
	PUSHJ	P,LABCHK	;[403] IS IT A LABELED MTA?
	JRST	ENTR3Q		;[403] NO, A 0 FILENAME IS OK
	JRST	ER0		;[403] AURIGA! NEED A FILENAME ON LABELED TAPES
;**;[402] At ENTR3A: +8L, Added label ENTR3Q:		SM	22-Mar-82
ENTR3Q:	MOVSI D,IOPENF
	TDNE D,FLAGWD(BB)	;FILE OPENF FOR READING ALREADY?
	PUSHJ P,ERRARG
	MOVSI A,(GJ%FOU)
	MOVEM A,JBLOCK		;STORE FLAGS
ENTR3B:	MOVEI A,JBLOCK		;SET UP POINTER TO E-BLOCK
	HRROI B,STRNG1
	GTJFN
	  JRST [PUSHJ P,WARN	;ERROR - FIRST CHECK IF DIR FULL
		  JRST CVTERR	;[356] Convert the TOPS-20 error to TOPS-10
		JRST ENTR3B]	;DID AN EXPUNGE, TRY AGAIN
	MOVEM A,JFNTAB(BB)	;SAVE GOTTEN JFN
	MOVEM A,NEWJFN		;IF OPENF FAILS
	PUSHJ P,FILDIR		;UPDATE DIRNUM(BB)
ENTR4:	MOVE B,FLAGWD(BB)	;GET STATUS
	TLZN PF,L.UPDT		;[356] Is this a forced update mode ?
;**;[436] INSERT 4 LINES AT ENTR4:+2.L	DSW	4/26/85
	 JRST ENTR4A		;[436] NO FORCED UPDATE
	TLO B,LOOKPF+IOPENF	;[436] YES, SET "LOOKUP AND OPEN DONE"
	IORM B,FLAGWD(BB)	;[436]  AND REMEMBER IT
	CAIA			;[436]
ENTR4A:	TLNE B,IOPENF		;WRITE OR UPDATE?
	SKIPA B,[OF%RD!OF%WR]	;UPDATE (READ/WRITE)
	MOVX B,OF%WR		;WRITE
	PUSHJ P,OPENX
	  JRST [CAIN AA,DTA	;IS THIS A DTA
		 JRST [	CAIE A,OPNX4	;YES, WRITE LOCKED?
			JRST .+1	;NO, CALL WARN
			PUSHJ P,ILLOUT	;TYPE OUT PROBLEM MESSAGE
			HRRZ A,JFNTAB(BB)
			JRST ENTR4]	;TRY AGAIN
		PUSHJ P,WARN	;FAILURE, GO SEE IF QUOTA EXCEEDED
		  JRST CVTERR	;[356] Not quota problems, go give error return
		JRST ENTR4]	;DID AN EXPUNGE SO TRY AGAIN
ENTFIN:	PUSHJ P,SETDAT		;SET CREATION DATE AND TIME IF SPECIFIED
	SKIPE A,DIRNUM(BB)	;IS THERE A PPN?
	PUSHJ P,PPNUNM		;YES, GET THE PPN FROM IT
	HRRZ G,FORTY		;GET POINTER TO ARG BLOCK
	UMOVE F,(G)		;GET FIRST WORD
	TLNN F,-1		;ZERO LH?
	CAIGE F,3		;AND GREATER THAN 3?
	  TRZA PF,R.UEXT	;NO, THEN NOT EXTENDED FORMAT
	TRO PF,R.UEXT		;YES, EXTENDED FORMAT BLOCK
	TRNN PF,R.UEXT		;EXTENDED ARG BLOCK?
	JRST [	UMOVEM A,3(G)	;NO
		JRST ENTFI1]	;STORE PPN IN SHORT FORM BLOCK
	UMOVEM A,1(G)		;EXTENDED BLOCK
	UMOVE B,0(G)		;GET LENGTH OF BLOCK
	MOVE A,DEVNAM(BB)	;GET DEVICE NAME
	CAIGE B,16		;USER WANT RIBDEV?
	JRST ENTFI1		;NO
	UMOVEM A,16(G)		;YES
ENTFI1:	MOVSI A,OOPENF!ENTERF
	IORB A,FLAGWD(BB)
	JUMPN AA,CPOPJ1		;[356]IF NOT A DSK, RETURN TO USER
	TLNE A,LOOKPF		;SEE IF A LOOKUP WAS DONE
;**;[436] CHANGE 2 LINES AT ENTFI1:+4.L	DSW	4/23/85
	 JRST ENTFI2		;[436] YES, RETURN FILE SIZE NOW
	MOVSI E,-EXTLEN		;[436] NOW SEE IF THE EXTENSION MATCHES
	MOVS A,EXT(BB)		;  ONE OF THE SPECIAL EXTENSIONS
;**;[436] CHANGE 1 LINE AT ENTLOP:+0.L	DSW	4/23/85
ENTLOP:	HLRZ B,EXTTAB(E)	;[436] GET EXTENSION FROM TABLE
	CAME A,B		;SEE IF THIS IS A MATCH
;**;[436] CHANGE 2 LINES AT ENTLOP:+2.L	DSW	4/23/85
	AOBJN E,ENTLOP		;[436] NO MATCH, LOOP BACK
	JUMPGE E,ENTFI2		;[356][436] RAN OUT OF ENTRIES?
	HRRZ A,JFNTAB(BB)	;SEE IF THIS IS VERSION 1
	MOVE B,[XWD 1,FDBVER]	;TO SEE IF VERSION COUNT SHOULD BE SET
	MOVEI C,D
	GTFDB
;**;[436] CHANGE 1 LINE AT ENTLOP:+8.L	DSW	4/23/85
	 ERJMP ENTFI2		;[436] GO RETURN EOF
	HLRZS D			;THIS IS THE VERSION NUMBER
	CAIE D,1		;IS IT 1
;**;[436] CHANGE 2 LINES AT ENTLOP:+11.L	DSW	4/23/85
	  JRST ENTFI2		;[356][436] NO, GO RETURN EOF
;**;[438] CHANGE 1 LINE AT ENTLOP:+12.L		DSW	7/12/85
	HRRZ C,EXTTAB(E)	;[436][438]GET DEFAULT NO. OF VERSIONS TO KEEP
	ROT C,-6		;POSITION THEM INTO BITS 0-5
	MOVSI B,770000		;SET UP MASK
	HRRZ A,JFNTAB(BB)	;GET JFN
;**;[436] CHANGE 1 LINE AT ENTLOP:+16.L	DSW	4/23/85
	HRLI A,FDBBYV(CF%NUD)	;[436] AND OFFSET INTO FDB
	XJSYS <CHFDB>		;SET NEW VERSION LIMIT
	  JFCL
;**;[436] CHANGE 1 LINE AT ENTLOP:+19.L	DSW	4/23/85
	JRST ENTFI2		;[356][436]
;**;[436] INSERT NEW ROUTINE BEFORE EXTTAB:	DSW	4/23/85
;[436]	The TOPS-10 Monitor Calls manual says that for an "Update ENTER"
;	(i.e., ENTER after LOOKUP), word 3 of the argument block will
;	contain the length of the file, not a PPN. We should do this
;	correctly, so that we can avoid races. It may have changed since
;	we did the LOOKUP, especially if someone else was writing the
;	file at that time, and has closed it. If this was an extended
;	ENTER and there is room, we will return the size of the file
;	both in words and in TOPS-10 disk blocks.

ENTFI2:	PUSHJ P,OPNDSK		;[436] GET THE CURRENT END OF FILE
	TRNE PF,R.UEXT		;[436] EXTENDED ENTER?
	 JRST ENTFI3		;[436]  YES, GO DO IT...
	MOVE A,FLAGWD(BB)	;[436] GET THE FLAG WORD
	TLNN A,LOOKPF		;[436] WAS A LOOKUP DONE FIRST?
	 JRST CPOPJ1		;[436] NO, RETURN NOW
	MOVE A,IOEOFP(BB)	;[436] GET CURRENT WORD COUNT
	CAIG A,377777		;[436] MORE THAN 128K WORDS?
	 JRST [	MOVNI A,(A)	;[436]  NO, GET -# OF WORDS
		MOVSS A		;[436]  SWAP INTO LEFT HALF
		UMOVEM A,3(G)	;[436]  MOVE TO CALLERS BLOCK
		JRST CPOPJ1 ]	;[436]  RETURN SUCCESSFULLY
	ADDI A,177		;[436] YES, ROUND TO NEXT BLOCK
	ASH A,-7		;[436] AND CONVERT WORDS TO BLOCKS
	HRLZ A,A		;[436] MOVE TO LEFT,,0
	TLZ A,400000		;[436] MAKING SURE IT'S POSITIVE
	UMOVEM A,3(G)		;[436] SAVE FOR THE USER
	JRST CPOPJ1		;[436] AND RETURN SUCCESSFULLY
ENTFI3:	UMOVE B,0(G)		;[436] GET SIZE OF ARGUMENT BLOCK
	TRZ B,400000		;[436] MAKE SURE RB.NSE IS OFF
	CAIGE B,5		;[436] ENOUGH ROOM FOR WORD COUNT?
	 JRST CPOPJ1		;[436] NO, RETURN
	MOVE A,IOEOFP(BB)	;[436] GET CRRENT WORD COUNT
	UMOVEM A,5(G)		;[436] STORE WORD COUNT IN .RBSIZ
	CAIGE B,11		;[436] ROOM TO STORE BLOCK COUNT
	 JRST CPOPJ1		;[436] NO, RETURN
	ADDI A,177		;[436] ROUND UP TO NEXT BLOCK
	ASH A,-7		;[436] CONVERT WORDS TO BLOCKS
	UMOVEM A,10(G)		;[436] SAVE .RBEST (ESTIMATED SIZE)
	UMOVEM A,11(G)		;[436] AND  .RBALC (ALLOCATED SIZE)
	JRST CPOPJ1		;[436] RETURNING SUCCESSFULLY
;TABLE OF SPECIAL EXTENSIONS
;  LH - SIXBIT EXTENSION, RH - VERSIONS TO KEEP

EXTTAB:	XWD 'LST',1
	XWD 'REL',1
	XWD 'CRF',1
	XWD 'TMP',1
	XWD 'OVR',1
	XWD 'SYM',1
	XWD 'TEM',1
	XWD 'XPN',1
	XWD 'BIN',1
	XWD 'QUE',1
	XWD 'QUF',1
	XWD 'DIR',1
EXTLEN==.-EXTTAB

SETDAT:	JUMPN AA,CPOPJ		;IF NOT A DSK, JUST RETURN
	HRRZ G,FORTY		;GET POINTER TO DATA BLOCK
	SKIPN G			;(351) NO BLOCK?
	POPJ P,			;YES, JUST RETURN AND USE DEFAULT DATE
	UMOVE F,(G)		;GET FIRST WORD
	TLNN F,-1		;ZERO LH?
	CAIGE F,3		;AND GREATER THAN 3?
	  TRZA PF,R.UEXT	;NO, THEN NOT EXTENDED FORMAT
	TRO PF,R.UEXT		;YES, EXTENDED FORMAT BLOCK
	TRNE PF,R.UEXT		;EXTENDED ENTER?
	  JRST [XCTLB <LDB A,[POINT 3,3(G),20]>
		XCTLB <LDB B,[POINT 12,4(G),35]>
		XCTLB <LDB D,[POINT 11,4(G),23]>
		JRST SETDT1]	;YES, GET INFO FROM EXTENDED BLOCK
	XCTLB <LDB A,[POINT 3,1(G),20]>
	XCTLB <LDB B,[POINT 12,2(G),35]>
	XCTLB <LDB D,[POINT 11,2(G),23]>
SETDT1:	LSH A,^D12		;GET HIGH ORDER BITS OF DATE
	IOR A,B			;GET LOW ORDER BITS OF DATE
	JUMPE A,SETDT2		;IF NOT SPECIFIED, RETURN
	IMULI D,^D60		;TURN MINUTES INTO SECONDS FROM MIDNITE
	IDIVI A,^D31		;GET DAY OF THE MONTH IN B
	HRLZ C,B		;STORE FOR JSYS
	IDIVI A,^D12		;GET MONTH AND YEAR
	HRLI B,^D1964(A)	;GET ACTUAL YEAR
	HRROI A,STRNG1		;COLLECT DATE IN STRNG1
	SETZ E,			;STANDARD FLAGS
	XJSYS <ODTNC>		;GET DATE AND TIME
	 JRST SETDT2		;IF ERROR, USE CURRENT DATE
	HRROI A,STRNG1		;NOW GET INTERNAL FORMAT
	SETZ B,			;NO SPECIAL FLAGS
	IDTIM
	  JRST SETDT2		;FAILED, SO SET TODAYS DATE
	SKIPA C,B		;SET UP TO CHANGE FDB
;**;[422] CHANGE 1 LINE AT SETDT2 AND 2 LINES AT SETDT2+2 (SPR#19962)
SETDT2:	HRLZI C,-1 		;[422] SET C VERY SMALL SO CAMGE FAILS
	GTAD			;GET DATE
;**;[418] Change 2 line at SETDT2+2 (SPR #19962)
;**;[419] Rescind previous edit		DEE	13-JUL-84
	CAMGE C,A		;[422]BACK TO C,A [419]C,A back to A,C[418] IS DATE SPECIFIED GREATER THAN TODAY
	  MOVE C,A		;[418] NO,USE CURRENT DATE/TIME
	SETO B,			;ALL BITS IN WORD CHANGE
	HRRZ A,JFNTAB(BB)	;GET FILE JFN
;**;[436] CHANGE 1 LINE AT URENME:-4.L	DSW	4/23/85
	HRLI A,FDBWRT(CF%NUD)	;[436] CREATION OF THIS VERSION
	XJSYS <CHFDB>		;CHANGE IT
	  JFCL
	POPJ P,			;AND RETURN

URENME:	TRO PF,R.ENT		;PREVENT THE VERSION FIELD FROM BEING SET
	PUSHJ P,SETUP
	PUSHJ P,UUREN		;[356] Do the rename
	  JRST LOOKER		;[356] Store the error and return to the user
	JRST MRETN2		;[356] Give a good return to the caller

;[356] Here to process the RENAME UUO.  This routine can also be called
;[356] from the FILOP processing routine.

UUREN:	MOVE D,FLAGWD(BB)
	TLNN D,INITF
	PUSHJ P,ERRCHN
	PUSHJ P,DIRCHK		;DIRECTORY DEVICE?
	  JRST CPOPJ1		;[356] No

	SKIPN JFNTAB(BB)	;SEE IF A FILE WAS PREVIOUSLY OPENED
	  JRST ER5		;NO FILE PREVIOUSLY SELECTED

IFN FTFILSER,<
	HLRZ A,DEVNAM(BB)	;TOPS-10 DSK?
	CAIN A,'DPA'
	  JRST TRENME		;YES, GO TO FILSER
>
	SETZM IOCNT		;NOW DO A CLOSE (FOR LEVEL-D)
	PUSHJ P,UCL1K		;  CLOSE WITHOUT RELEASING JFN

	PUSHJ P,FILDIR		;GET CORRECT DIRECTORY NUMBER
	PUSH P,DIRNUM(BB)	;SAVE OLD DIRECTORY NUMBER
	PUSH P,EXT(BB)		;SAVE OLD EXT
	PUSH P,FILNAM(BB)	;AND FILE NAME
	PUSHJ P,LUKPAR		;SET UP RENAME PARAMETERS
	  JRST [SUB P,[3,,3]	;REMOVE FILE NAME, EXT
		JRST ER1]	;UNRECOGNIZABLE UFD
	SKIPN FILNAM(BB)	;ZERO NAME?
	  JRST RENDEL		;YES, GO DELETE FILE
	MOVSI A,600000
	MOVEM A,JBLOCK		;STORE FLAGS FOR GTJFN
URENM1:	MOVEI A,JBLOCK		;GET E-BLOCK ADDRESS
	HRROI B,STRNG1
	GTJFN
	  JRST [PUSHJ P,WARN	;SEE IF OVER QUOTA
;[356]; Note that this fixes a bug too
		  SKIPA		;[356] No, give ane rror return
		JRST URENM1	;[356] Go try again
		ADJSP P,-3	;[356] Remove the junk on the stack
		JRST CVTERR]	;[356] Convert the error code
	EXCH A,JFNTAB(BB)	;PUT NEW JFN IN
	PUSH P,A		;SAVE JFN
	PUSHJ P,FILDIR		;GET DIRECTORY
	POP P,A			;GET JFN BACK
	EXCH A,JFNTAB(BB)	;RESTORE OLD JFN
 	POP P,B			;GET OLD FILE NAME
	POP P,C			;AND EXT
	POP P,D			;AND DIRECTORY NUMBER
	CAMN B,FILNAM(BB)	;FILE NAME THE SAME?
	CAME C,EXT(BB)		;AND EXT THE SAME
	  JRST URENM2		;NO GO RENAME
	CAME D,DIRNUM(BB)	;HAS DIRECTORY CHANGED
	  JRST URENM2		;YES GO RENAME
	RLJFN			;NO.  RELEASE THE JFN
	  JFCL			;IGNORE ANY ERRORS
	PUSHJ P,URENA1		;CHANGE FILE PARAMETERS ONLY
	  JRST CVTERR		;[356]ERROR RETURN
	JRST CPOPJ1		;[356]
URENM2:	PUSHJ P,URENAM		;GO DO THE RENAMING
	  JRST CVTERR		;[356] IT FAILED
	JRST CPOPJ1		;[356] SUCCESSFUL

URENAM:	PUSH P,A
	HRLI A,FDBPRT		;MAKE IT POSSIBLE TO RENAME THIS FILE
	MOVEI B,770000		;NOT PROTECTED FROM THIS USER
	MOVEI C,770000
	XJSYS <CHFDB>		;CHANGE THE PROTECTION
	  JRST [POP P,(P)		;FAILURE
		POPJ P,]
	HRR A,JFNTAB(BB)		;GET OLD JFN
	XJSYS <CHFDB>		;CHANGE ITS PROTECTION ALSO
	  JRST [POP P,(P)		;FAILURE
		POPJ P,]		;RETURN ERROR CODE
;**;[436] INSERT 2 LINES AT URENAM:+9.L	DSW	4/23/85
	CAIN AA,DSK		;[436] IS THIS A DISK FILE?
	 PUSHJ P,SETEOF		;[436] YES, UPDATE EOF IF OPEN OUTPUT
	HRRZ A,JFNTAB(BB)		;OLD JFN
	TLO A,(CO%NRJ)		;DON'T RELEASE IT
	CLOSF			;BE SURE FILE IS CLOSED
	 JFCL
	HRRZ A,JFNTAB(BB)	;OLD JFN
	POP P,B			;NEW JFN
	MOVEM B,NEWJFN		;IN CASE RNAMF FAILS, JFN WILL BE RELEASED
	RNAMF
	  POPJ P,			;GIVE ERROR RETURN
	MOVEM B,JFNTAB(BB)		;NEW JFN
URENA1:	HRLI A,FDBPRT		;NOW SET THE DESIRED PROTECTION
	HRR A,JFNTAB(BB)		;IN FDB
	MOVEI B,-1		;ONLY RH IS CHANGED
	HRRZ C,PROT(BB)		;GET DESIRED PROT
	SKIPE C			;IF 0 USE WHAT SYSTEM DEFAULTED
	CHFDB
	ERJMP CPOPJ		;MAY NOT BE ABLE TO CHANGE THE PROTECTION
	PUSHJ P,SETDAT		;SET CREATION DATE AND TIME IF SPECIFIED
	JRST CPOPJ1

RENDEL:	SUB P,[3,,3]		;REMOVE NAME, EXT. AND PPN
	HRRZ A,JFNTAB(BB)	;ZERO FILE NAME ON RENAME, IE DELETE
	SETZ B,			;KEEP NO VERSIONS
	DELNF			;MARK ALL FILES DELETED
	 JRST LOOKER		;ERROR OCCURED
	SETZM JFNTAB(BB)	;INIT DATA BASE
	GTSTS			;GET STATUS OF JFN
	TLNN B,(1B0)		;OPEN?
	JRST [	RLJFN		;NO, JUST RELEASE IT
		 JFCL		;
		JRST MRETN2]	;SUCCESS
	CLOSF			;FILE OPEN, CLOSE AND RELEASE
	 JFCL
	JRST CPOPJ1		;[356] SUCCESS

UCLOSE:	PUSHJ P,SETUPG
	  JRST MRETN		;NOTHING TO BE OPEN, RETURN IMMEDIATELY
	MOVE A,FORTY		;MOVE CLOSE BITS
	MOVEM A,IOCNT		;TO WHERE UCL1 WILL SEE THEM
	PUSHJ P,UCL1K		;CLOSE, KEEPING JFN
	JRST MRETN

UCL1K:	TROA PF,R.KJFN		;KEEP THE JFN
UCL1R:	TRZ PF,R.KJFN		;RELEASE THE JFN
	TRO PF,R.CLS		;INDICATE CLOSE
	MOVEI B,1
	TDNE B,IOCNT		;CLOSE OUTPUT?
	JRST UCL2		;NO
	PUSH P,IOCNT
	PUSH P,FORTY
	SETZM FORTY
	MOVSI B,OOPENF
	MOVEI A,17
	AND A,FLAGWD(BB)
	CAIG A,14		;BUFFERED MODE?
	TDNN B,FLAGWD(BB)	;AND OPEN FOR OUTPUT?
	JRST UCL1		;NO- ALL DONE
	HLRZ CC,BUFHTB(BB)	;SEE IF THERE IS A BUFFER RING
	JUMPE CC,UCL1		;NO, DONT DO OUTPUT
	UMOVE A,0(CC)		;GET FIRST WORD OF RING
	TLZ A,377777		;CLEAR UN DESIRED BITS
	JUMPLE A,UCL1		;IF VIRGIN OR ZERO, DONT DO OUTPUT
	PUSHJ P,OUTTN		;IF OPEN FOR WRITING, DO LAST OUT
	 JFCL			;PITY
UCL1:	POP P,FORTY
	POP P,IOCNT
	MOVSI B,OOPENF		;CHECK IF FILE OPENED
	TDNN B,FLAGWD(BB)
	SKIPN MAPTAB(BB)	;AND MAPPED PAGE?
	JRST UCL1A		;NO
REPEAT 0,<
	SKIPG A,JFNTAB(BB)	;NOW SET THE SIZE AND # OF WORDS
	  JRST UCL5		;ONLY IF THERE IS A JFN
	HRLI A,FDBSIZ		;BYTE COUNT
	MOVNI B,1		;ALL 36 BITS
	MOVE C,IOEOFP(BB)	;SET EOF
	XJSYS <CHFDB>
	  JFCL
	HRLI A,FDBBYV		;
	MOVSI B,7700
	MOVSI C,(^D36B11)	;SIZE = 36 BITS
	XJSYS <CHFDB>
	  JFCL
>
	JRST UCL5		;GO REMOVE PAGE
UCL1A:	CAIN AA,MTA		;IS THIS A MTA?
	  PUSHJ P,CLSMTA	;YES, GO WRITE EOF
UCL2:
	MOVEI B,2		;CLOSING INPUT SIDE?
	TDNN B,IOCNT		; ..
	SKIPG MAPTAB(BB)	;YES. HAVE A PAGE MAPPED?
	JRST UCL4		;NO.
UCL5:	PUSHJ P,UNMAPP		;GO UN MAP PAGE
UCL4:	MOVE B,FLAGWD(BB)
	MOVE A,IOCNT
	TRNN A,1		;CLOSING OUTPUT?
	TLZN B,OOPENF		;WAS THIS OPENED?
	  JRST UCL6		;NO, DONT SET PROTECTION
	JUMPN AA,UCL6		;DONT SET PROT IF NOT A DISK
	TLNE B,IOPENF!LOOKPF	;WAS IT ALSO OPENED FOR READING?
	  JRST UCL6		;YES, THEN DONT CHANGE PROT EITHER
	MOVSI A,FDBPRT		;YES, SET PROT
	HRR A,JFNTAB(BB)	;GET JFN
	MOVEI B,-1		;SET ONLY RH
	HRRZ C,PROT(BB)		;GET DESIRED PROTECTION
	JUMPE C,UCL4A		;IF NOT SET, USE SYSTEM DEFAULT PROT
	TRNN A,-1		;WAS THIS FILE CLOSED ALREADY?
	  JRST UCL4A		;YES, DONT CHANGE PROT
	XJSYS <CHFDB>		;NO, OK TO CHANGE PROTECTION
	  JFCL
UCL4A:	MOVE B,FLAGWD(BB)	;GET FLAGS AGAIN
	MOVE A,IOCNT		;SET UP CLOSE BITS AGAIN
	TLZ B,OOPENF		;CLEAR OUTPUT OPEN FLAG
UCL6:	TRNN A,2		;CLOSING INPUT?
	TLZ B,IOPENF		;YES
IFN FTFILSER,<
	HLRZ A,DEVNAM(BB)	;SEE IF THIS IS A DPA
	CAIN A,'DPA'
	  JRST TCLOSE		;YES, GO CLOSE IT WITH FILSER
>
	SKIPLE A,JFNTAB(BB)
	TLNE B,OOPENF+IOPENF	;BOTH SIDE NOW CLOSED?
	JRST UCL3		;NO
	HRRZS A			;GET RH ONLY
	CAIE A,PRIJFN		;PRIMARY INPUT JFN?
	CAIN A,PROJFN		;OR PRIMARY OUTPUT JFN?
	  JRST UCL3		;YES, DONT CLOSE IT
	PUSH P,A		;SAVE JFN
	CAIN AA,DSK		;DSK?
	 PUSHJ P,SETEOF		;YES, GO SET THE EOF
	POP P,A
	HRL A,IOCNT		;GET CLOSE BITS
	TLNN A,40		;FLUSH OUTPUT FILES?
	TLZA A,-1		;NO, CLEAR CLOSF BITS
	HRLI A,(CZ%ABT)		;YES, SET ABORT BIT
	TLO A,(1B0)		;SET SIGN BIT FOR CLOSF
	CLOSF			;CLOSE IT
	  JFCL			;MULTIPLE CLOSE IS NOP
	SKIPLE A,JFNTAB(BB)	;DON'T RELEASE JFN IF IT IS ZERO
	TRNE PF,R.KJFN		;OR CALLER SAID KEEP IT
	JRST UCL3
	HRRZS A
	PUSHJ P,SAVUFD		;IF THIS IS A UFD JFN SAV IT
	  SKIPA			;NOT A UFD
	 JRST UCL6A		;SAVED, DONT RELEASE IT
	RLJFN
	PUSHJ P,ERROR
UCL6A:	SETZM JFNTAB(BB)
UCL3:	CAIN AA,DTA		;DTA?
	PUSHJ P,DTAMNT		;YES, GO LEAVE DTA MOUNTED
	  JFCL			;IGNORE ERROR RETURN
	MOVEI A,2		;B34
	TDNN A,IOCNT		;OMIT INPUT SIDE?
	PUSHJ P,CLOSEI		;NAH, CLOSE IT
	MOVEI A,1		;B35
	TDNE A,IOCNT		;OUTPUT CLOSE?
	POPJ P,			;NO, RETURN
	CAIN AA,DSK		;IS THIS A DISK?
	PUSHJ P,SETEOF		;SET EOF SIZES IN FDB
	PJRST CLOSEO		;DO BUFFER HEADER STUFF

SETEOF:
 IFN FTDEB,<
	TMSG	< (in SETEOF) >
>
;**;[436] REWRITE ROUTINE SETEOF: AT SETEOF:+0.L	DSW	4/23/85
	PUSH P,A		;[436] SAVE AC A
	MOVE A,FLAGWD(BB)	;[436] CHECK IF DSK FILE
	TLNE A,OOPENF		;[436] WAS FILE OPENED?
	 TLNE A,RDUFDF+RDMFDF	;[436]  YES, IS THIS NOT A DIRECTORY?
	  JRST POP.A		;[436]   YEP, DONT SET EOF ON DIRECTORY JFNS
	SKIPG A,JFNTAB(BB)	;[436] DO WE THINK WE HAVE A JFN?
	 JRST POP.A		;[436]  NOPE, DONT PLAY AROUND ANYMORE...
	PUSH P,B		;[436] YES, MORE PLAYING, SAVE AC B TOO
	HRRZS A			;[436] MAKE ONLY A JFN IN AC 1
	GTSTS			;[436] CHECK THE FILE'S STATUS
	TXC B,GS%NAM+GS%OPN+GS%WRF	;[436] COMPLEMENT BITS OF INTEREST
	TXCE B,GS%NAM+GS%OPN+GS%WRF	;[436] WERE ALL OF EM ON (1)?
	 JRST POP.B		;[436] NO, DONT MESS WITH THE FILE
	PUSH P,C		;[436] SIGH, NEED ANOTHER AC
	MOVE A,JFNTAB(BB)	;[436] GET JFN AND UPDATE THE EOF NOW
	HRLI A,FDBSIZ(CF%NUD)	;[436] DO THE BYTE COUNT FIRST
	MOVNI B,1		;[436] CHANGE ENTIRE WORD
	MOVE C,IOEOFP(BB)	;[436] GET NEW EOF FOR THE FILE
	XJSYS <CHFDB>		;[436] CHANGE THE FDB, DON'T WAIT
	 JFCL			;[436]
	HRLI A,FDBBYV		;[436] DO THE BYTE SIZE NEXT
	MOVSI B,7700		;[436] THIS IS THE FIELD TO CHANGE
	MOVSI C,(^D36B11)	;[436] MAKE IT 36-BIT BYTES
	XJSYS <CHFDB>		;[436] CHANGE THE FDB, WAIT FOR DISK UPDATE
	 JFCL
POP.C:	POP P,C			;[436] RESTORE OUR ACS
POP.B:	POP P,B			;[436] ...
POP.A:	POP P,A			;[436] ...
	POPJ P,			;[436] ALL DONE

UNMAPP:	PUSH P,A
	PUSH P,B
	PUSH P,C		;SAVE ALL ACS USED
	SKIPN B,MAPTAB(BB)	;ANY PAGES MAPPED?
	JRST UNMAPD		;NO
	HRLI B,.FHSLF		;YES, UNMAP THEM FROM THIS FORK
	MOVE C,[PM%CNT+NPLPGS]	;ALL OF THEM IN ONE SWELL FOOP
	SETO A,
	PMAP
	MOVSI A,(1B0)		;NOW FREE UP THIS SLOT
	HRRZ B,MAPTAB(BB)	;GET PAGE NUMBER
	MOVNI B,-IOMPGS(B)	;GET NEGATIVE PAGE OFFSET IN PAGE AREA
	IDIVI B,NPLPGS		;GET BIT POSITION IN MAPLST
	LSH A,0(B)
	IORM A,MAPLST		;BLOCK IS NOW AVAILABLE
	SETZM MAPTAB(BB)	;CLEAR POINTER TO IT
	SOS MAPTOT		;COUNT DOWN NUMBER OF MAP SLOTS USED
UNMAPD:	POP P,C			;RESTORE ACS
	POP P,B
	POP P,A
	POPJ P,

;ROUTINE TO SAVE A UFD JFN (TO SPEED UP SCAN AND WILD)
;CALL:	PUSHJ P,SAVUFD
;	  RETURN HERE IF JFN NOT SAVED
;	RETURN HERE IF JFN WAS SAVED AND SHOULD NOT BE RELEASED

SAVUFD:	PUSH P,A		;SAVE ALL ACS USED
	MOVE A,FLAGWD(BB)	;GET FLAGS
	TLNE A,RDUFDF		;IS THIS A UFD JFN
	SKIPG A,JFNTAB(BB)	;GET JFN OF UFD
	  JRST APOPJ		;NOT A UFD JFN, RETURN TO RELEASE IT
	EXCH A,LSTUFJ		;SAVE JFN OF UFD
	HRRZS A
	RLJFN			;RELEASE OLD JFN
	JFCL
	MOVE A,DIRNUM(BB)	;GET DIR NUM
	MOVEM A,LSTUFD		;SAVE FOR LATER
	MOVE A,IOBYTP(BB)	;GET POINTER WORD
	MOVEM A,LSTUFP		;SAVE IT TOO
	POP P,A			;RESTORE AC
	JRST CPOPJ1		;AND SKIP RETURN
CLOSEO:	MOVSI B,OOPENF+OUFIRF
	HLRZ A,BUFHTB(BB)
	JRST CLOSI2

CLOSEI:	MOVSI B,IOPENF+INFIRF+LOOKPF
	HRRZ A,BUFHTB(BB)	;PTR TO INPUT BUFFER HEADER
CLOSI2:	TDNN B,FLAGWD(BB)
	POPJ P,
	TRO B,1B22		;CLEAR EOF.
	ANDCAB B,FLAGWD(BB)
	ANDI B,17
	CAIE A,0		;IS THERE A BUFFER?
	CAILE B,14		;AND IN BUFFERED MODE?
	POPJ P,			;NO

	MOVSI B,400000		;CLOSE A BUFFER RING
	XCTUU <SKIPN (A)>	;HAS BUFFER RING BEEN SET UP?
	POPJ P,			;NO
	XCTUU <SETZM 2(A)>	;CLEAR BYTE COUNT
	XCTUU <TDNE B,(A)>	;AND HAS IT BEEN USED?
	POPJ P,			;NO, FORGET IT

	XCTUU <IORB B,(A)>

	MOVEI D,(B)		;EXTRA COPY FOR END TEST
	MOVEI A,100		;SET MAXIMUM # OF BUFFERS IN RING COUNT
BUFLP:	MOVEI C,(B)
	CAMLE C,JBREL		;ARE RING LINK POINTERS OK?
	PUSHJ P,ERRARG		;NO, SMASHED SOMEHOW
	MOVSI B,400000
	XCTUU <ANDCAB B,(C)>	;CLEAR BUFFER USE BIT AND FETCH CHAIN POINTER
	CAIE D,(B)		;BACK AROUND TO FIRST ONE IN RING?
	SOJG A,BUFLP		;NO
	POPJ P,

DIRCHK:	CAIN AA,.DVNUL		;NULL DEVICE?
	  POPJ P,		;YES, DIRECTORY NOT REQUIRED, RETURN
	MOVE B,DEVTBL(AA)	;GET DEVICE BITS
	TLNE B,HASDIR		;HAVE A DIRECTORY?
	AOS 0(P)		;YES. SKIP RETURN
	POPJ P,0		;RETURN.
DEV67:	MOVE D,DEVNAM(BB)	;GET THE SIXBIT NAME
	HRROI E,DEVNM7		;WHERE ASCIZ SHOULD GET PUT
;	JRST SIXTO7		;CONVERT IT.

;CONVERSION FROM SIXBIT TO ASCIZ
;C - CLOBBERABLE
;D - SIXBIT THING TO CONVERT
;E - POINTER TO DESTINATION

SIXTO7:	HRLI E,440700	;ASSUME ALL ASCIZ'S START ON WORD BOUNDARY
	SETZM 0(E)		;CLEAR DESTINATION WORD
SIX27E:	TRZA PF,R.CVF		;CLEAR QUOTING FLAG
SIX27V:	TRO PF,R.CVF		;MARK THAT CHARACTERS SHOULD BE QUOTED
	JUMPE D,SIXT7B		;QUIT IF STRING EMPTY
SIXT7A:	MOVEI C,0
	ROTC C,6		;PUT ONE CHAR INTO C
	CAIGE C,'A'		;SEE IF CHARACTER SHOULD BE QUOTED
	CAIG C,'9'		;A-Z AND 0-9 WONT GET QUOTED
	SKIPA			;SO FAR OK
	  TRO PF,R.CVC		;QUOTE THIS CHAR
	CAIG C,'Z'		;GREATER THAN Z
	CAIGE C,'0'		;OR LESS THAN 0
	  TRO PF,R.CVC		;QUOTE THIS CHAR
	TRZE PF,R.CVC		;THIS CHAR TO BE QUOTED
	TRNN PF,R.CVF		;YES, QUOTE FLAG ON?
	  JRST SIXT7C		;NO, DONT QUOTE ANYTHING
	PUSH P,C		;SAVE CHARACTER
	MOVEI C,C.CNTV		;GET QUOTE CHAR
	IDPB C,E		;STORE IT
	POP P,C			;GET CHARACTER BACK
SIXT7C:	ADDI C,40		;OFFSET
	IDPB C,E		;STORE AWAY
	JUMPN D,SIXT7A		;ANY MORE CHARS IN THING?
SIXT7B:	PUSH P,E		;SAVE BYTE POINTER BEFORE STORING 0
	IDPB D,E		;STORE A ZERO TERMINATOR
	POP P,E			;RESTORE UPDATED BYTE POINTER FOR CALLER
	POPJ P,
;SETUP ON ENTRY TO IO UUO'S

SETUP:	PUSHJ P,SETUPG		;CALL CONDITIONAL SETUP ROUTINE
	  PUSHJ P,ERRCHN	;NOT OPEN. ERROR.
	POPJ P,0		;OK.

SETUPG:	TLNE AC,770000		;SIXBIT NAME?
	JRST SETUPD		;YES, GO SEARCH FOR NAME
	MOVE BB,AC		;CHANNEL NUMBER
	IMULI BB,NTABS
SETUPF:	LDB AA,PDVNUM		;GET NUMERIC DEVICE TYPE
	CAIL AA,MAXDEV		;IS THIS A KNOWN DEVICE?
	POPJ P,			;NO
	SKIPE DEVNAM(BB)	;SOMETHING OF A CROCK.
	AOS 0(P)
	POPJ P,

SETUPD:	MOVEI BB,0		;SCAN FOR DEVICE NAME
SETUPL:	CAMN AC,DEVNAM(BB)	;FOUND IT YET?
	JRST SETUPF		;YES
	ADDI BB,NTABS		;NO, STEP TO NEXT CHANNEL
	CAIG BB,17*NTABS	;REACHED THE END YET?
	JRST SETUPL		;NO, LOOP BACK FOR ALL CHANNELS
	POPJ P,			;RETURN UNSUCCESSFUL

UUSETO:	TROA PF,R.DIRN		;FLAG USETO VS USETI
UUSETI:	TRZ PF,R.DIRN		;USETI VS USETO
	PUSHJ P,SETUP
	CAIN AA,DTA		;IS IT DECTAPE?
	  JRST DTASET		;YES
	JUMPN AA,MRETN		;ONLY ALLOWED FOR DISK AND DTA
	MOVSI A,RNDMF		;MARK THAT FILE IS RANDOM
	IORB A,FLAGWD(BB)	;THEN SEE IF SUPER USETI/O
	TLNN A,LOOKPF!ENTERF	;IS THIS A SUPER USETI OR USETO
	  JRST SUSET		;YES, GO HANDLE IT
	TLNE A,RDUFDF		;IS THIS A UFD WE ARE ADVANCING?
	  JRST UUFDST		;YES IT IS.... ARGH!
	HRRZ B,FORTY		;BUFFER NUMBER
	CAIN B,-1		;IS THIS A SPECIAL CASE?
	  JUMPE AA,UUSET3	;YES, GO SET POINTER TO END OF FILE
	SOJGE B,.+2
	SETZ B,
	IMUL B,DEVTB2(AA)	;BUFFER SIZE
	TRNN PF,R.DIRN		;OUTPUT?
	CAMGE B,IOEOFP(BB)	;NO. INPUT BEYOND EOF?
	JRST UUSET1		;NO
	PUSH P,B		;SAVE POSITION
	PUSHJ P,PTRGET		;GET EOF VALUE
	 JRST [	POP P,B
		JRST MRETN]	;FAILED
	POP P,B			;GET BACK NEW POSITION
	CAMGE B,IOEOFP(BB)	;IS IT BEYOND THE EOF?
	JRST UUSET1		;NO

UUSET3:
IFN FTFILSER,<
	HLRZ A,DEVNAM(BB)	;IS THIS A DPA?
	CAIN A,'DPA'		;...
	  PUSHJ P,TUSET		;YES, GO DO FUNCTION
>
	PUSHJ P,PTRGET		;GET NEW EOF
	 JRST MRETN
	SKIPE B,IOEOFP(BB)	;GET THE END OF FILE
	SOS B			;IF NOT ZERO, DECREMENT IT
	TRZ B,177		;MAKE B = POINTER TO EOF MINUS ONE BLOCK
	TRNE PF,R.DIRN		;IS THIS A USETO
	  JRST UUSET1		;YES, GO STORE VALUE
	MOVE B,IOEOFP(BB)	;NO, GET EOF
	MOVEM B,IOBYTP(BB)	;MARK IT
	HRRZ A,JFNTAB(BB)	;NOW SET THE NEW FILE POINTER
	SFPTR
	 JFCL
UUSETE:	MOVEI A,1B22		;INPUT, EOF FLAG SET
	IORM A,FLAGWD(BB)
	JRST MRETN

UUSET1:	MOVEI C,1B22		;CLEAR EOF BIT
	ANDCAM C,FLAGWD(BB)	;  IN CASE IT WAS ON
IFN FTFILSER,<
	HLRZ C,DEVNAM(BB)	;IS THIS A TOPS-10 PACK?
	CAIN C,'DPA'
	 JRST UUSET2		;YES, DONT DO SFPTR
>
	HRRZ A,JFNTAB(BB)	;GET JFN OF FILE
	SFPTR
	  JFCL			;IGNORE ERROR
UUSET2:	MOVEM B,IOBYTP(BB)	;STORE NEW BYTE POINTER
	CAMLE B,IOEOFP(BB)	;IS THIS A NEW END OF FILE?
	  MOVEM B,IOEOFP(BB)	;YES, UPDATE EOF POINTER
IFN FTFILSER,<
	HLRZ A,DEVNAM(BB)	;IS THIS A DPA?
	CAIN A,'DPA'		;...
	  PUSHJ P,TUSET		;YES, GO DO FUNCTION
>
	JRST MRETN

SUSET:
IFN FTFILSER,<
	HLRZ A,DEVNAM(BB)	;GET GENERIC NAME
	CAIE A,'DPA'		;IS THIS A TOPS-10 PACK
	  JRST BUGSTP		;NO, SUPER USETI/O IS ILLEGAL
	SETZM IOBYTP(BB)	;MAKE SURE EOF DOESNT HAPPEN
	HRLOI A,377777		;GET LARGE NUMBER FOR EOF POINTER
	MOVEM A,IOEOFP(BB)
	JRST TDOUUO		;GO DO UUO
>
IFE FTFILSER,<
	JRST BUGSTP		;NOT ALLOWED
>

SUBTTL	FILOP -- General purpose file operation UUO

;[356]UUO TO PERFORM FILE OPERATIONS
;[356]CALL WITH:
;[356]	MOVE	AC,[N,,E]
;[356]	FILOP.	AC,
;[356]	  ERROR RETURN
;[356]	NORMAL RETURN
;[356]

;[356]BITS IN THE LH OF FOPFLG
FOP.SA==(1B0)		;[356]THIS FILOP. DOES BOTH A LOOKUP AND
			;[356] AN ENTER. WE MUST SAVE ARGUMENTS TILL
			;[356] THE ENTER
FOP.LK==(1B1)		;[356]DO A LOOKUP
FOP.EN==(1B2)		;[356]DO AN ENTER
FOP.MA==(1B3)		;[356]MULTI-ACCESS UPDATE
FOP.AP==(1B4)		;[356]APPEND
FOP.PV==(1B5)		;[356]REQUESTING PRIVS.
FOP.NS==(1B6)		;[356]DO NOT SUPERSEDE
FOP.UR==(1B7)		;[356]JUST UPDATE RIB
FOP.NF==(1B8)		;[356]LIT IF INPUT FILE NOT FOUND ON APPEND OR UPDATE
FOP.AL==(1B9)		;[356]PRE-ALLOCATE
FOP.RN==(1B10)		;[356]THIS FILOP. DOES A RENAME
FOP.DL==(1B11)		;[356]THIS FILOP. DELETES THE FILE

FOPTAB:		;[356]DISPATCH TABLE FOR FILOP.
EXP	FOPILU					;[356](00) ILLEGAL
XWD	FOP.LK,FOPEN				;[356](01) READ
XWD	FOP.NS+FOP.EN,FOPEN			;[356](02) CREATE
XWD	FOP.EN,FOPEN				;[356](03) CREATE OR SUPERSEDE
XWD	FOP.SA+FOP.LK+FOP.EN,FOPEN		;[356](04) UPDATE
XWD	FOP.SA+FOP.LK+FOP.EN+FOP.MA,FOPEN	;[356](05) MULTI-ACCESS UPDATE
XWD	FOP.SA+FOP.LK+FOP.EN+FOP.AP,FAPND	;[356](06) APPEND
EXP	FURIB					;[356](07) CLOSE
XWD	FOP.UR,FURIB				;[356](10) UPDATE RIB
EXP	FUSTI					;[356](11) USETI
EXP	FUSTO					;[356](12) USETO
XWD	FOP.RN+FOP.LK,FOPEN			;[356](13) RENAME
XWD	FOP.RN+FOP.DL+FOP.LK,FOPEN		;[356](14) DELETE
XWD	FOP.EN+FOP.AL,FOPEN			;[356](15) PREALLOCATE
REPEAT 0,<		;NOT YET IMPLEMENTED
EXP	FOPILU					;(16) SUPER I/O
EXP	FOPINP					;(17) INPUT
EXP	FOPOUT					;(20) OUTPUT
EXP	FOPSET					;(21) SETSTS
EXP	FOPGET					;(22) GETSTS
EXP	RELEAS					;(23) RELEASE
EXP	CMRETN					;(24) WAIT
EXP	CMRETN					;(25) SEEK
EXP	FOPILU					;(26) REWRITE RIB
>
FOPMAX==.-FOPTAB-1 	;[356]MAXIMUM FUNCTION

FILOP:	TRO	PF,R.FLP	;[356] Flag processing a FILOP.
	HLRZM	CAC,FLPAGL	;[356] Save the argument block length
	HRRZM	CAC,FLPARG	;[356] Store the argument block index
	MOVEM	AC,FOPAC	;[356] Store the contents of AC
	UMOVE	A,.FOFNC(CAC)	; Get the channel and function code
	HRRZM	A,FOPFNC	; Save the function code for later
	HLRZ	AC,A		; Get channel only
	TRZ	AC,(FO.PRV)	;[356] Clear the priv bit
	TRZN	AC,(FO.ASC)	; Extended channel wanted?
	JRST	FILOPA		; No
	PUSHJ	P,GETXCH	; Yes, get extended channel
	  JRST	MRETN		; Not available
	XCTUM	<HRLM	AC,.FOFNC(CAC)>	; Return channel to user
FILOPA:	HRLM	AC,FOPAC	;[356] Save the channel for later use
	HRRZ	A,FOPFNC	; Get the FILOP. function
	CAILE	A,FOPMAX	;[356] or less than the max allowed ?
	 JRST	FOPILU		;[356] Yes - Go give the user an error
 IFN FTDEB,<
	TMSG < FILOP function >
	PUSH	P,A
	MOVE	B,A
	MOVX	A,.PRIOU
	MOVEI	C,10
	NOUT%
	 ERJMP .+1
	POP	P,A
 >
	HLLZ	B,FOPTAB(A)	;[356] Get the FILOP. flags from the table
	MOVEM	B,FOPFLG	;[356] Store them
	JRST	@FOPTAB(A)	;[356] Call the correct routine

;Get an extended channel

GETXCH:	POPJ	P,		;Always give error return for now


;[356] Error return

FOPNSD:	SKIPA	B,[EXP	NSDERR]	;[356] Get the error retur
FOPILU:	MOVEI	B,ILUERR	;[356] Issue an ILU error
FOPERR:	SKIPE	A,NEWJFN	;[356] Is there a JFN to get rid of ?
	 RLJFN			;[356] Yes - Make it go away
	  JFCL			;[356] Failed or none
	SETZM	NEWJFN		;[356] Clear the JFN
	MOVE	A,B		;[356] Move the TOPS-10 error code into correct AC
	HRRZ	AC,FOPAC	;[356] Get the AC to store into
	JRST	STOTAC		;[356] Store the error code and return to the user

;[356] Here to process many of the FILOP. functions

FOPEN:	TLNE	B,FOP.AL!FOP.MA!FOP.DL!FOP.RN ;[356] Is this something we can not do ?
	 JRST	CMRETN		;[356] Yes - Die
	MOVE	D,FLPAGL	;[356] Make sure that there are enough arguments
	CAIGE	D,4		;[356] . . .
	  JRST	FOPILU		;[356] No - Issue an error return
	HLRZ	AC,FOPAC	;[356] Set up AC again
	PUSHJ	P,SETUPG	;[356] Is the device open ?
	 JRST	FOPEN0		;[356] No - Open it
	PUSHJ	P,URELR		;[356] Release the channel first
FOPEN0:	MOVE	AC,FOPAC	;[356] Set up AC again
	MOVE	CAC,FLPARG	;[356] Get the arguments again
	MOVEI	A,.FOIOS(CAC)	;[356] Point to the OPEN block in the FILOP. block
;**;[436] INSERT 2 LINES AT FOPEN0:+3L	DSW	4/26/85
	MOVE	C,(A)		;[436] GET THE STATUS BITS
	HRRZM	C,FLAGWD(BB)	;[436] SAVE THEM
	PUSHJ	P,UUOPEN	;[356] Open the device
	  JRST	FOPNSD		;[356] Failed -- Give no such device error
	MOVE	D,FLPAGL	;[356] Get the number of arguments in the FILOP. block
	CAIN	D,.FOBRH+1	;[356] More than just an OPEN ?
	 JRST	MRETN2		;[356] No - Give a good return
	MOVE	CAC,FLPARG	;[356] Get the arguments again
	UMOVE	C,.FONBF(CAC)	;[356] Get the number of buffers wanted
	MOVEM	C,FOPTMP	;[356] Store into the temp location
	HLRZ	CC,BUFHTB(BB)	;[356] Get the output buffer header
	HLRE	C,C		;[356] Get the number of buffers
	JUMPE	C,FOPEN1	;[356] No output buffers

	SKIPG	C		;[356] Want the default number of buffers ?
	 MOVEI	C,2		;[356] Yes - Use two
	MOVSI	B,OUTBFF	;[356] Flag that this is an OUTBUF
	PUSHJ	P,IOBUF		;[356] Set up the buffers

;[356] Here to do the INBUF processing

FOPEN1:	HRRE	C,FOPTMP	;[356] Get the number of INPUT buffers
	JUMPE	C,FOPEN2	;[356] No input buffers - Skip this
	SKIPG	C		;[356] Want the default
	 MOVEI	C,2		;[356] Yes - Use two
	MOVSI	B,INBUFF	;[356] Flag doing an INBUF
	HRRZ	CC,BUFHTB(BB)	;[356] Get the input buffer header
	PUSHJ	P,IOBUF		;[356] Set up the I/O buffers

;[356] Here to see if we need to do a LOOKUP

FOPEN2:	MOVE	D,FLPAGL	;[356] Get the number of arguments
	CAIN	D,.FONBF+1	;[356] Done yet ?
	  JRST	MRETN2		;[356] Yes - Return to the caller

	MOVE	CAC,FLPARG	;[356] Get the arguments again
	UMOVE	C,.FOLEB(CAC)	;[356] Get the address of the LOOKUP/ENTER block
	HRRM	C,FORTY		;[356] Fudge for the LOOKUP code
	MOVEM	D,FOPARG	;[356] Save for later testing
	.RBCNT==0		;[356] Fudge
	UMOVE	D,.RBCNT(C)	;[356] Get the first word of the LOOKUP block
;**;[436] CHANGE 1 LINE AT FOPEN2:+9.L	DSW	4/26/85
	TLNN	D,-1		;[356][436] Is this an extended block ?
	 MOVEI	D,4		;[356] Yes - Fudge the argument block count
	MOVEM	D,FOPTMP	;[356] Store the argument count

	MOVE	E,FOPFLG	;[356] Get the FILOP. flags
	JUMPGE	E,FOPEN4	;[356] Need to do both LOOKUP/ENTER ?
	CAIGE	D,5		;[356] Yes - Save some things
	 JRST	FOPEN5		;[356] Big enough block
	MOVEI	A,4		;[356] Get the new argument count
;**;[436] CHANGE 1 LINE AT FOPEN4:-1.L	DSW	4/26/85
	UMOVEM	A,.RBCNT(C)	;[356][436] Store into the LOOKUP block

FOPEN4:	TLNN	E,FOP.LK	;[356] Need to do a lookup ?
	  JRST	FOPEN7		;[356] No - skip this

FOPEN5:	MOVE	F,FOPARG	;[356] Get the argument
	TLNN	F,-1		;[356] Is this extended ?
	 JRST	FOPN5C		;[356] Yes - Do this differently
	XCTUU	<HRRZ	A,1(C)>	;[356] Get the date information
	JRST	FOPN5D		;[356] And skip

FOPN5C:	XCTUU	<HRR	A,3(C)>	;[356] Get the date information
FOPN5D:	HRLM	A,FOPTMP	;[356] Store it for later
	UMOVE	D,(C)		;[356] Get the first word again
	TLNE	D,-1		;[356] Is this extended ?
	 JRST	FOPN5A		;[356] Non-extended
	UMOVE	A,1(C)		;[356] Get the PPN
	JRST	FOPN5B		;[356] And skip the next

FOPN5A:	UMOVE	A,3(C)		;[356] Get the PPN
FOPN5B:	MOVEM	A,FOPPPN	;[356] Store the PPN for later
	HLRZ	AC,FOPAC	;[356] Get the channel
;[356]	TLNE	E,FOP.AP	;[356] Is this append mode ?
;[356]	 TLO	PF,L.APND	;[356] Yes - Light the flag
	PUSHJ	P,UULKP		;[356] Do the LOOKUP
	  JRST	FOPLER		;[356] Process the LOOKUP error

	MOVE	CAC,FLPARG	;[356] Get the address of the argument block again
	XCTUU	<HRRZ	A,(CAC)> ;[356] Get the function again
	MOVE	A,FOPCHK(A)	;[356] Convert that into the correct code
	MOVEM	A,CHKBLK+.CKAAC	;[356] Store the type of checking to be done
	HRRZ	A,JFNTAB(BB)	;[356] Get the JFN for the file
	MOVEM	A,CHKBLK+.CKAUD	;[356] Store it into the argument block
	MOVE	A,FLPAGL	;[356] Get the number of args
	CAIGE	A,.FOPPN+1	;[356] Have an on behalf of PPN??
	 JRST	FOPFNF		;[356] No, skip this
	SETZB	A,B		;[356] Clear to get the information
	GJINF			;[356] Get the logged in 36-bit acct number
				;[356]  and connected directory
	DMOVEM	A,CHKBLK+.CKALD	;[356] Store the information
	SETZM	CHKBLK+.CKAEC	;[356] Clear this word
	MOVX	A,CK%JFN+.CKAUD+1 ;[356] Get the flags and the length
	MOVEI	B,CHKBLK	;[356] Get the address of the argument block
	CHKAC			;[356] Do the JSYS call
	 SKIPA			;[356] Failed
	JUMPL	A,FOPFNF	;[356] All is ok if A is minus one
	CAIN	A,CKAX4		;[356] Is it no file error ?
	 JRST	FOPFNF		;[356] Yes - Still ok
	MOVEI	B,PRTERR	;[356] Get the error code
	JRST	FOPERR		;[356] Give the error to the user

FOPFNF:	HRRZ	D,FOPTMP	;[356] Get the length back again
	HRRZ	C,FORTY		;[356] Get the address of the LOOKUP block back
	CAIGE	D,5		;[356] Is this at least 5 long ?
	  JRST	FOPEN7		;[356] No
	UMOVEM	D,(C)		;[356] Restore the length of the block

FOPEN7:	MOVE	E,FOPFLG	;[356] Get the FILOP flags
	TLNN	E,FOP.EN	;[356] Require an ENTER ?
	  JRST	FOPEN8		;[356] No - Skip this section
	MOVE	A,FOPPPN	;[356] Get the PPN back again
	MOVE	D,FOPARG	;[356] Get the first word
	TLNN	E,FOP.LK	;[356] Did we do a LOOKUP ?
	  JRST	FOPN7B		;[356] No - Skip this
	TLNE	D,-1		;[356] Is this an extended block ?
	 JRST	FOPN7A		;[356] No - Skip to the non-extended code
	UMOVEM	A,1(C)		;[356] Restore the PPN back into the block
	JRST	FOPN7B		;[356] and continue

FOPN7A:	UMOVEM	A,3(C)		;[356] Store the PPN
FOPN7B:	TLNE	E,FOP.NF	;[356] File not found ?
	 TLO	PF,L.UPDT	;[356] Yes - Force update mode
;	TLNE	E,FOP.AP	;[356] Append mode ?
;	 TLO	PF,L.APND	;[356] Yes - Force append mode
	PUSHJ	P,UUENTR	;[356] ENTER the file
	  JRST	FOPEER		;[356] Failed ?

	MOVE	CAC,FLPARG	;[356] Get the address of the argument block again
	XCTUU	<HRRZ	A,(CAC)> ;[356] Get the function again
	MOVE	A,FOPCHK(A)	;[356] Convert that into the correct code
	MOVEM	A,CHKBLK+.CKAAC	;[356] Store the type of checking to be done
	HRRZ	A,JFNTAB(BB)	;[356] Get the JFN for the file
	MOVEM	A,CHKBLK+.CKAUD	;[356] Store it into the argument block
	MOVE	A,FLPAGL	;[356] Get the number of args
	CAIGE	A,.FOPPN+1	;[356] Have a PPN to check
	 JRST	FOPEN8		;[356] No, assume it is okay
	SETZB	A,B		;[356] Clear
	GJINF			;[356] Get the information
	DMOVEM	A,CHKBLK+.CKALD	;[356] Store the information
	SETZM	CHKBLK+.CKAEC	;[356] Clear this word
	MOVX	A,CK%JFN+.CKAUD+1 ;[356] Get the flags and the length
	MOVEI	B,CHKBLK	;[356] Get the address of the argument block
	CHKAC			;[356] Do the JSYS call
	 SKIPA			;[356] Failed
	JUMPL	A,FOPEN8	;[356] All is ok if A is minus one
	CAIN	A,CKAX4		;[356] Is it this failure ?
	 JRST	FOPEN8		;[356] Yes - Still ok
	MOVEI	B,PRTERR	;[356] Get the error code
	JRST	FOPERR		;[356] Give the error code

FOPEN8:	MOVE	E,FOPFLG	;[356] Get the FILOP flags again
	TLNN	E,FOP.RN	;[356] Require a RENAME ?
	 JRST	FOPN8A		;[356] No - Continue
	MOVE	CAC,FLPARG	;[356] Get the address of the argument block again
	JRST	CMRETN		;[356] *** TEMP ***

FOPN8A:	MOVE	D,FLPAGL	;[356] Get the number of arguments
	CAIGE	D,.FOPAT+1	;[356] Is this argument block this large ?
	 JRST	FOPEN9		;[356] No - Skip this too
;**;[408] At FOPN8A: +3L, Modified 1 line                   SM 28-Feb-83
	MOVE	CAC,FLPARG	;[356][408]Get the address of the arg block
	UMOVE	C,.FOPAT(CAC)	;[356] get the address of the path block
	JUMPE	C,FOPEN9	;[356] Jump if there is on path block
	HRRZM	C,FORTY		;[356] Save in a safe place
;**;[436] CHANGE 1 LINE AT FOPN8A:+7L	DSW	4/26/85
	HLRZ	D,C		;[356][436] Get the length of the block
	CAIGE	D,4		;[356] Interesting case
	  JRST	FOPEN9		;[356] Skip this then
;**;[436] REPLACE 2 LINES WITH 3 AT FOPN8A:+10.L	DSW	4/26/85
	MOVE	A,DIRNUM(BB)	;[436] GET DIRECTORY NUMBER
	PUSHJ	P,PPNUNM	;[436] DIRECTORY NUMBER TO PPN TRANSLATION
	UMOVEM	A,2(C)		;[436] STORE THE PPN
	XCTUU	<SETZM 3(C)>	;[356] Clear the next word

FOPEN9:	SKIPE	E,FOPFLG	;[356] Get the flags
	 TLNN	E,FOP.AP	;[356] Want append mode ?
	  JRST	MRETN2		;[356] No - UUO finished
	JUMPN	AA,FOPN11	;[356] Is this a disk ?
	MOVE	A,FDBB+FDBSIZ	;[356] Get the size of the file in bytes
	LDB	C,[POINT 6,FDBB+FDBBYV,11] ;[356] Get the byte size
	SKIPN	C		;[356] Zero ?
	  MOVEI	C,^D36		;[356] Yes - Change to 36 bit bytes
;**;[414] At FOPEN9:+8L remove 1 and add 3 lines	8-Feb-84	CRJ
	MOVEI	B,^D36		;[414] Get number of bits in a word
	IDIVI	B,(C)		;[414] Get number of bytes in a word
	IDIVI	A,(B)		;[414] Get number of words in this file
	SKIPE	B		;[356] Have to round up ?
;**;[414] At FOPEN9:+9L change 2 lines			8-Feb-84	CRJ
	 AOS	A		;[414] Yes - Bump to the next word
	AOS	A		;[414] Point to the next word
;**;[414] At FOPEN9:+12L remove 1 line		8-Feb-84	CRJ
	MOVEM	A,IOBYTP(BB)	;[414] Store for the other I/O routines
	MOVE	A,JFNTAB(BB)	;[356] Get the files JFN
	SFPTR			;[356] Point to the place in the file
	 PUSHJ	P,ERROR		;[356] ?????

	JRST	MRETN2		;[356] Return to the user

FOPN11:	CAIE	AA,MTA		;[356] Is this a magtape ?
	 JRST	MRETN2		;[356] No - Give a good return
	JRST	CMRETN		;[356] Die
	MOVEI	A,16		;[356] Get the MTAPE function
	PUSHJ	P,DOMTAP	;[356] Do the MTAPE function
	 JRST	FOPERR		;[356] Error return
	MOVEI	A,7		;[356] Get the next function
	PUSHJ	P,DOMTAP	;[356] And do it too it
	 JRST	FOPERR		;[356] Error return
;[356] ROUTINE TO CALL THE MTAPE ROUTINE

;[356]	MOVEI	A,FUNCTION
;[356]	PUSHJ	P,DOMTAP

DOMTAP:	HRRM	A,FORTY		;[356] Store the function
	PUSHJ	P,MTAPE0	;[356] Do the function
	MOVE	A,FLAGWD(BB)	;[356] Get the flags
	TRNN	A,700000	;[356] Any errors
	 AOJA	(P)		;[356] Won
	MOVEI	B,1		;[356] Failed
	POPJ	P,		;[356] Return to the user
;[356] Here to process the error returns for the ENTER and the LOOKUP

FOPLER:	TDZA	D,D		;[356] Flag from a LOOKUP error return
FOPEER:	SETO	D,		;[356] Flag from an ENTER
	IORI	D,(B)		;[356] OR in the error code
	JUMPN	D,FOPERR	;[356] Jump if not LKP and FNFERR
	MOVSI	E,FOP.NF	;[356] Get the flag to light
	IORB	E,FOPFLG	;[356] Light it and get he flags
	TLNN	E,FOP.EN	;[356] ENTER required ?
	 JRST	FOPERR		;[356] No - Just give up
	HRRZ	C,FORTY		;[356] Get the address of the LOOKUP block
	MOVE	E,FOPARG	;[356] Get the header of the LOOKUP block
	HLRZ	A,FOPTMP	;[356] Get the date information
	TLNE	E,-1		;[356] Is this an extended LOOKUP ?
	 JRST	FOPEE0		;[356] No - Handle differently
	XCTUU	<HRRM	A,1(C)>	;[356] Store the date information
	JRST	FOPFNF		;[356] And continue processing

FOPEE0:	XCTUU	<HRRM	A,3(C)>	;[356] Store the date information
	JRST	FOPFNF		;[356] Continue processing



;[356] THE FOLLOWING IS THE TABLE TO CONVERT THE FILOP THINGS TO CHKAC FUNCTIONS

FOPCHK:	EXP	-1		;[356] Illegal
	EXP	.CKARD		;[356] Read a file
	EXP	.CKACF		;[356] Create
	EXP	.CKACF		;[356] Create/Supersede
	EXP	.CKAAP		;[356] Update a file
	EXP	.CKAAP		;[356] Multi access update
	EXP	-1		;[356] Close a file
	EXP	-1		;[356] Update RIB
	EXP	-1		;[356] USETI
	EXP	-1		;[356] USETO
	EXP	.CKACF		;[356] RENAME
	EXP	.CKACF		;[356] DELETE
	EXP	.CKACF		;[356] PREALLOCATE

;[356] HERE TO CLOSE THE FILE

FCLOS0:	UMOVE	A,.FOIOS(CAC)	;[356] Get the close flags
	MOVEM	A,IOCNT		;[356] Store for the close code
	HLLZ	B,FOPAC		;[356] Get the channel
	LSH	B,5		;[356] Move into the correct place
	IOR	A,B		;[356] build this mess
	MOVEM	A,FORTY		;[356] Fake this out
	PUSHJ	P,UCL1K		;[356] Close the channel
;**;[436] REPLACE 1 LINE WITH 3 AT FCLOS0:+7.L	DSW	4/26/85
	PUSHJ	P,GSTAT1	;[436] GET STATUS TO A
	HRRZ	AC,FOPAC	;[436] GET ARG AC NUMBER
	JRST	STOTC1		;[436] STORE IN AC, SKIP RETURN

; Here to do the FILOP update RIB function

FURIB:	PUSHJ	P,SETUP		;[356] Make sure the file is open
	MOVE	B,FOPFLG	;[356] Get the FILOP. flags
	TXNN	B,<(FOP.UR)>	;[356] Is this update RIB ?
	  JRST	FCLOS0		;[356] No, close the file
	JUMPN AA,MRETN2		;IF NOT A DISK, SUCCESS
	MOVE A,FLAGWD(BB)	;GET FLAGS
	TLNN A,ENTERF		;WRITING TO FILE?
	JRST MRETN2		;NO, SUCCESSFUL RETURN

;**;[354] INSERT @FILOP+30
	TLNN A,OOPENF		;[354] OPEN FOR OUTPUT
	JRST MRETN2		;[354] NO, SUCCESSFUL RETURN
	MOVEI B,17		;[354] BUFFERED MODE?
	AND B,A			;[354]   ..
	CAIL B,15		;[354]   ..
	JRST FILO20		;[354] NO
	TLNN A,OUFIRF		;[354] A DUMMY OUTPUT DONE?
	JRST FILO20		;[354] NO
	HLRZ CC,BUFHTB(BB)	;[354] IS THERE A BUFFER RING?
	JUMPE CC,FILO20		;[354] NO
	UMOVE A,0(CC)		;[354] A VIRGIN RING?
	TLZ A,377777		;[354]   ..
	JUMPLE A,FILO20		;[354] YES
	PUSH P,IOBYTP(BB)	;[354] SAVE POSITION IN FILE
	PUSH P,IOBPT		;[354] SAVE BUFFER BYTE POINTER
	PUSH P,IOCNT		;[354] SAVE BUFFER BYTE COUNT
	PUSHJ P,SETOBF		;[354] PREPARE BUFFER FOR EMPTYING
	SKIPE IOCNT		;[354] EMPTY BUFFER?
	PUSHJ P,OUTDSK		;[354] NO, TRANSFER BUFFER
	POP P,IOCNT		;[354] RESTORE BUFFER BYTE COUNT
	POP P,IOBPT		;[354] RESTORE BUFFER BYTE POINTER
	POP P,IOBYTP(BB)	;[354] RESTORE POSITION IN FILE
FILO20:	HRLZ A,JFNTAB(BB)	;[354] GET JFN AND PAGE TO START AT
	MOVEI B,-1		;MAXIMUM NUMBER OF PAGES (MINUS 1!!)
	UFPGS			;WRITE ALL PAGES TO THE DISK
	 PUSHJ P,ERROR		;SHOULDN'T FAIL
	PUSHJ P,SETEOF		;SET END OF FILE POINTER
	JRST MRETN2		;SKIP RETURN

; Here to do the FILUP USETI and USETO functions

FUSTI:	TRZA PF,R.DIRN		;INPUT
FUSTO:	TRO PF,R.DIRN		;OUTPUT
	PUSHJ P,SETUP		;[356] Set up and check for the channel being open
	JUMPN AA,CMRETN		;IF NOT A DISK, RETURN ERROR
	MOVSI A,RNDMF		;MARK THAT THE ACCESS IS RANDOM
	IORB A,FLAGWD(BB)	;GET FLAGS
	TLNN A,RDUFDF		;READING A UFD?
	TLNN A,LOOKPF!ENTERF	;OR NO LOOKUP OR ENTER BEEN DONE YET?
	JRST CMRETN		;YES, GIVE ERROR
	UMOVE B,1(CAC)		;GET BLOCK NUMBER
	CAMN B,[-1]		;IS THIS A SPECIAL CASE?
	JRST UUSET3		;YES, GO SET POINTER TO END OF FILE
;**;[344] INSERT @FILOP2+7 1/2
;Note that this is not the correct test. Anything less than 777777,,777770 should be legal
	SOJL B,CMRETN		;[344] SUBTRACT 1 (1ST BLOCK INDEX = 0)
	IMUL B,DEVTB2(AA)	;TURN IT INTO # OF WORDS
	TRNN PF,R.DIRN		;USETI?
	CAMGE B,IOEOFP(BB)	;YES, IS IT PAST THE EOF?
	TRNA			;NO
	JRST UUSET3		;YES, SET EOF AND GIVE ERROR RETURN
	MOVEI C,1B22		;TURN OFF EOF IF IT WAS ON
	ANDCAM C,FLAGWD(BB)
	HRRZ A,JFNTAB(BB)	;NOW SET THE FILE POINTER
	SFPTR			;TO THE DESIRED BYTE
	 PUSHJ P,ERROR		;SHOULD NEVER FAIL
	MOVEM B,IOBYTP(BB)	;STORE THE NEW BYTE POINTER
	CAMLE B,IOEOFP(BB)	;IS THIS A NEW EOF?
	MOVEM B,IOEOFP(BB)	;YES, REMEMBER THAT FACT
	JRST MRETN2		;ALL DONE

;**;[345] INSERT AT FREE LOCATION @FILOP2+21 1/2
FAPND:				;[356][345] APPEND FILOP. FUNCTION
	MOVEI A,4		;[345] ARGUMENT BLOCK AT LEAST 4 WORDS
	CAMLE A,FLPAGL		;[345]   ..
	PUSHJ P,ERRARG		;[345] NO, ERROR
	MOVE A,FLPARG		;[345] GET OPEN UUO ARGUMENT ADDRESS
	ADDI A,1		;[345]  ..
	MOVEM A,FORTY		;[345] STORE FOR OPEN UUO
	AOS SUCNT		;[345] MARK SIMULATED UUO
	PUSHJ P,UOPEN		;[345] CALL OPEN UUO
	  JRST [MOVEI A,11	;[345] FAILED, DEVICE NOT AVAILABLE
		JRST FILOPE]	;[345] GIVE ERROR RETURN
	MOVEI A,5		;[345] ARGUMENT BLOCK AT LEAST 5 WORDS
	CAMLE A,FLPAGL		;[345]   ..
	JRST FILOP5		;[345] NO, CAN'T SETUP BUFFERS
	MOVE A,FLPARG		;[345] GET INBUF UUO ARGUMENT
	XCTUU <HRRE B,.FONBF(A)>	;[345]   ..
	JUMPE B,FILOP4		;[345] 0 INDICATES NO BUFFERS
	SKIPG B			;[345] -1 INDICATES DEFAULT BUFFERS
	SETZ B,			;[345]   ..
	MOVEM B,FORTY		;[345] STORE FOR INBUF UUO
	AOS SUCNT		;[345] MARK SIMULATED UUO
	PUSHJ P,UINBUF		;[345] CALL INBUF UUO
FILOP4:	MOVE A,FLPARG		;[345] GET OUTBUF UUO ARGUMENT
	XCTUU <HLRE B,.FONBF(A)>	;[345]   ..
	JUMPE B,FILOP5		;[345] 0 INDICATES NO BUFFERS
	SKIPG B			;[345] -1 INDICATES DEFAULT BUFFERS
	SETZ B,			;[345]   ..
	MOVEM B,FORTY		;[345] STORE FOR OUTBUF UUO
	AOS SUCNT		;[345] MARK SIMULATED UUO
	PUSHJ P,UOUTBF		;[345] CALL INBUF UUO
FILOP5:	HLRZ CC,BUFHTB(BB)	;[345] GET BUFFER RING HEADER ADDRESS
	JUMPE CC,FILOP6		;[345] NO BUFFER RING HEADER
	XCTUU <SKIPLE A,0(CC)>	;[345] FIRST BUFFER ALREADY SETUP?
	JRST FILOP6		;[345] YES, DON'T NEED TO DO IT
	TRNN A,-1		;[345] BUFFER RING SETUP PROPERLY?
	JRST FILOP6		;[345] NO
	XCTUU <HRRZM A,0(CC)>	;[345] SETUP FIRST BUFFER
	PUSHJ P,INIBUF		;[345]   ..
FILOP6:	CAIN AA,DTA		;[345] A DECTAPE?
	JRST CMRETN		;[345] NOT SUPPORTED
	CAIE AA,DSK		;[345] A DSK?
	JRST FILO15		;[345] NO
	MOVEI A,6		;[345] ARGUMENT BLOCK AT LEAST 6 WORDS
	CAMLE A,FLPAGL		;[345]   ..
	PUSHJ P,ERRARG		;[345] NO, ERROR
	MOVE A,FLPARG		;[345] GET LOOKUP/ENTER UUO ARGUMENT ADDRESS
	XCTUU <HRRZ A,5(A)>	;[345]   ..
	MOVEM A,FORTY		;[345] STORE FOR LOOKUP/ENTER UUO
	UMOVE B,0(A)		;[345] GET FIRST WORD OF BLOCK
	TLNN B,-1		;[345] EXTENDED LOOKUP/ENTER?
	CAIGE B,3		;[345]   ..
	JRST FILOP8		;[345] NO
	XCTUU <PUSH P,3(A)>	;[345] SAVE .RBEXT IN CASE ERROR
	AOS SUCNT		;[345] MARK SIMULATED UUO
	PUSHJ P,ULOOKP		;[345] CALL LOOKUP UUO
	  JRST [HRRZ B,FORTY	;[345] FAILED, GET ERROR CODE
		XCTUU <HRRZ A,3(B)>	;[345]   ..
		JUMPE A,FILOP7	;[345] FILE NOT FOUND
		POP P,(P)	;[345] OTHER ERROR, CLEAN UP STACK
		JRST FILOPE]	;[345] GIVE ERROR RETURN
	POP P,(P)		;[345] CLEAN UP STACK
	JRST FILO11		;[345]
FILOP7:	XCTUU <POP P,3(B)>	;[345] RESTORE .RBEXT
	JRST FILO10		;[345]
FILOP8:	XCTUU <PUSH P,3(A)>	;[345] SAVE 4TH WORD
	XCTUU <PUSH P,1(A)>	;[345] SAVE 2ND WORD IN CASE ERROR
	AOS SUCNT		;[345] MARK SIMULATED UUO
	PUSHJ P,ULOOKP		;[345] CALL LOOKUP UUO
	  JRST [HRRZ B,FORTY	;[345] FAILED, GET ERROR CODE
		XCTUU <HRRZ A,1(B)>	;[345]   ..
		JUMPE A,FILOP9	;[345] FILE NOT FOUND
		POP P,(P)	;[345] OTHER ERROR, CLEAN UP STACK
		POP P,(P)	;[345]   ..
		JRST FILOPE]	;[345] GIVE ERROR RETURN
	POP P,(P)		;[345] CLEAN UP STACK
	HRRZ A,FORTY		;[345] RESTORE 4TH WORD
	XCTUU <POP P,3(A)>	;[345]   ..
	JRST FILO11		;[345]
FILOP9:	XCTUU <POP P,1(B)>	;[345] RESTORE 2ND WORD
	XCTUU <POP P,3(B)>	;[345] RESTORE 4TH WORD
FILO10:	AOS SUCNT		;[345] MARK SIMULATED UUO
	PUSHJ P,UENTER		;[345] CALL ENTER UUO
	  JRST FILO12		;[345] FAILED
	JRST FILO99		;[345] ALL DONE CUZ LOOKUP FAILED
FILO11:	AOS SUCNT		;[345] MARK SIMULATED UUO
	PUSHJ P,UENTER		;[345] CALL ENTER UUO
FILO12:	  JRST [HRRZ A,FORTY	;[345] FAILED, GET ERROR CODE
		XCTUU <HRRZ A,3(A)>	;[345]   ..
		JRST FILOPE]	;[345] GIVE ERROR RETURN

;Enter here from COMPT. APPEND code
FILO69:	HLRZ CC,BUFHTB(BB)	;[345] GET BUFFER RING HEADER ADDRESS
	JUMPE CC,FILO13		;[345] SKIP SIN IF NO BUFFER RING HEADER
	XCTUU <HRRZ A,0(CC)>	;[345] GET FIRST BUFFER
	JUMPE A,FILO13		;[345] SKIP SIN IF NO FIRST BUFFER
	XCTUU <HLRZ A,0(A)>	;[345] GET BUFFER SIZE
	SUBI A,1		;[345]   ..
	MOVE B,IOEOFP(BB)	;[345] GET FILE WORD SIZE
	IDIV B,A		;[345] CALCULATE LAST BUFFER FILE POINTER
	JUMPE C,FILO13		;[345] SKIP SIN IF BUFFER FULL
	IMUL B,A		;[345]   ..
	MOVEM B,IOBYTP(BB)	;[345] SAVE IT
	MOVNS C			;[345] NEGATE WORD COUNT
	PUSH P,C		;[345] SAVE IT
	HRRZ A,JFNTAB(BB)	;[345] GET JFN
	SKIPN A			;[345] JFN DEFINED?
	PUSHJ P,BUGSTP		;[345] NO, OOPS
	GTSTS			;[345] FILE OPEN?
	SKIPL B			;[345]   ..
	PUSHJ P,BUGSTP		;[345] NO, OOPS
	MOVE B,IOBYTP(BB)	;[345] GET LAST BLOCK FILE POINTER
	SFPTR			;[345] SET FILE POINTER
	  ERCAL ERROR		;[345] FAILED
	XCTUU <HRRZ B,0(CC)>	;[345] BUILD BYTE POINTER
	ADD B,[XWD 004400,1]	;[345]   ..
	MOVE C,(P)		;[345] GET NEGATIVE WORD COUNT
	SIN			;[345] GET THE BLOCK
	  ERCAL ERROR		;[345] FAILED
	XCTUU <HLL B,1(CC)>	;[345] REBUILD BYTE POINTER
	TLZ B,770077		;[345]   ..
	UMOVEM B,1(CC)		;[345] STORE UPDATED BYTE POINTER
	LDB B,[POINT 6,B,11]	;[345] EXTRACT BYTE SIZE
	MOVEI A,^D36		;[345] CALCULATE BYTES PER WORD
	IDIV A,B		;[345]   ..
	POP P,B			;[345] RESTORE NEGATIVE WORD COUNT
	IMUL B,A		;[345] CONVERT TO BYTES
	XCTUU <ADDM B,2(CC)>	;[345] UPDATE BUFFER BYTE COUNT
	JRST FILO14		;[345]
FILO13:	MOVE A,IOEOFP(BB)	;[345] GET FILE WORD SIZE
	IDIV A,DEVTB2(AA)	;[345] CALCULATE NEW BUFFER FILE POINTER
	SKIPE B			;[345]   ..
	ADDI A,1		;[345]   ..
	IMUL A,DEVTB2(AA)	;[345]   ..
	MOVEM A,IOBYTP(BB)	;[345] SAVE IT
FILO14:	MOVSI A,RNDMF		;[345] MARK THAT THE ACCESS IS RANDOM
	IORM A,FLAGWD(BB)	;[345]   ..
	HRRZ A,JFNTAB(BB)	;[345] GET THE JFN
	MOVE B,IOBYTP(BB)	;[345] GET BLOCK FILE POINTER
	SFPTR			;[345] SET THE FILE POINTER
	  ERCAL ERROR		;[345] FAILED
	JRST FILO99		;[345] ALL DONE CUZ DSK
FILO15:	CAIE AA,MTA		;[345] A MAG TAPE?
	JRST FILO99		;[345] NO, ALL DONE
	MOVEI A,16		;[345] GET MTSKF. UUO ARGUMENT
	MOVEM A,FORTY		;[345] STORE FOR MTAPE UUO
	AOS SUCNT		;[345] MARK SIMULATED UUO
	PUSHJ P,UMTAPE		;[345] CALL MTAPE UUO
	MOVEI A,17		;[345] GET MTBSF. UUO ARGUMENT
	MOVEM A,FORTY		;[345] STORE FOR MTAPE UUO
	AOS SUCNT		;[345] MARK SIMULATED UUO
	PUSHJ P,UMTAPE		;[345] CALL MTAPE UUO
	HLRZ CC,BUFHTB(BB)	;[345] GET BUFFER RING HEADER ADDRESS
	JUMPE CC,FILO99		;[345] ALL DONE IF NO BUFFER RING HEADER
	XCTUU <HRRZ A,0(CC)>	;[345] GET FIRST BUFFER
	JUMPE A,FILO99		;[345] ALL DONE IF NO FIRST BUFFER
	MOVEI A,7		;[345] GET MTBSR. UUO ARGUMENT
	MOVEM A,FORTY		;[345] STORE FOR MTAPE UUO
	AOS SUCNT		;[345] MARK SIMULATED UUO
	PUSHJ P,UMTAPE		;[345] CALL MTAPE UUO
	HLRZ CC,BUFHTB(BB)	;[345] GET BUFFER RING HEADER ADDRESS
	HRRZ A,JFNTAB(BB)	;[345] GET JFN
	SKIPN A			;[345] JFN DEFINED?
	PUSHJ P,BUGSTP		;[345] NO, OOPS
	GTSTS			;[345] FILE OPEN?
	SKIPGE B		;[345]   ..
	PUSHJ P,BUGSTP		;[345] YES, OOPS
	MOVX B,<<FLD(44,OF%BSZ)>!OF%RD>	;[345] OPEN IT
	OPENF			;[345]   ..
	  ERCAL ERROR		;[345] FAILED
	PUSHJ P,MTASTS		;[345] SET DENSITY, PARITY, ETC ...
	HRRZ A,JFNTAB(BB)	;[345] GET BYTE SIZE
	RFBSZ			;[345]   ..
	  ERCAL ERROR		;[345] FAILED
	MOVE E,B		;[345] SAVE IT
	XCTUU <HRRZ B,0(CC)>	;[345] BUILD BYTE POINTER
	ADDI B,1		;[345]   ..
	DPB E,[POINT 6,B,11]	;[345]   ..
	MOVEI F,^D36		;[345] CALCULATE BYTES PER WORD
	IDIV F,E		;[345]   ..
	XCTUU <HRRZ G,0(CC)>	;[345] GET WORD COUNT FROM FIRST BUFFER
	XCTUU <HLRZ G,0(G)>	;[345]   ..
	SUBI G,1		;[345]   ..
	IMUL G,F		;[345] CALCULATE BYTE COUNT
	MOVN C,G		;[345] NEGATE IT
	SINR			;[345] GET THE RECORD
	  ERCAL ERROR		;[345] FAILED
	HRLI A,(CO%NRJ)		;[345] CLOSE
	CLOSF			;[345]   ..
	  ERCAL ERROR		;[345] FAILED
	JUMPGE C,[UMOVE A,0(CC)	;[345] BUFFER FULL, GET BUFFER ADDRESS
		XCTUU <SETZM 2(A)>	;[345] ZERO BUFFER
		HRLI C,2(A)	;[345]   ..
		HRRI C,3(A)	;[345]   ..
		XCTUU <BLT C,0(B)>	;[345]   ..
		JRST FILO99]	;[345] ALL DONE CUZ BUFFER FULL
	XCTUU <HLL B,1(CC)>	;[345] REBUILD BYTE POINTER
	TLZ B,770077		;[345]   ..
	UMOVEM B,1(CC)		;[345] STORE UPDATED BYTE POINTER
	LDB B,[POINT 6,B,11]	;[345] EXTRACT BYTE SIZE
	MOVEI A,^D36		;[345] CALCULATE BYTES PER WORD
	IDIV A,B		;[345]   ..
	MOVE B,G		;[345] CALCULATE BYTES READ
	ADD B,C			;[345]   ..
	IDIV B,F		;[345] CONVERT TO WORDS
	SKIPE C			;[345]   ..
	ADDI B,1		;[345]   ..
	IMUL B,A		;[345] CONVERT TO BYTES
	MOVNS B			;[345] NEGATE IT
	XCTUU <ADDM B,2(CC)>	;[345] UPDATE BUFFER BYTE COUNT
	MOVEI A,7		;[345] GET MTBSR. UUO ARGUMENT
	MOVEM A,FORTY		;[345] STORE FOR MTAPE UUO
	AOS SUCNT		;[345] MARK SIMULATED UUO
	PUSHJ P,UMTAPE		;[345] CALL MTAPE UUO
;	JRST FILO99		;[345] ALL DONE CUZ MAG TAPE
FILO99:	JRST MRETN2		;[345] ALL DONE, YAY!!!

FILOPE:	MOVE AC,FLPAC		;[345] ERROR RETURN, GET AC
	JRST STOTAC		;[345] STORE AC AND RETURN

PTRGET:	PUSHJ P,DIRCHK		;DIRECTORY DEVICE?
	  POPJ P,0		;NO. NO-OP
	MOVE A,FLAGWD(BB)		;CHANNEL FLAGS
	TLNE A,DTADMP		;IS THIS A DTA DOING DUMP MODE STUFF
	  JRST PTRGT2		;YES, GO HANDLE SPECIAL CASE
	TLNE A,LOOKPF!ENTERF	;MUST BE LOOKED UP OR ENTERED
	TLNN A,OOPENF!IOPENF	;AND OPEN FOR INPUT OR OUTPUT
	  POPJ P,		;ERROR
	JUMPE AA,PTRGT1		;IF DISK, RETURN IOEOFP(BB)
	HRRZ A,JFNTAB(BB)
;NOTE - FOLLOWING IN PLACE OF SIZEF WHICH FAILS IF FILE NEVER CLOSED.
	RFPTR			;WHERE ARE WE IN FILE?
	  POPJ P,
	PUSH P,B		;SAVE IT
	SETO B,			;REQUEST CURRENT EOF
	SFPTR			; ..
	  JRST BPOPJ		;[356] Restore B and return
	RFPTR			;FIND WHERE THAT IS
	  JRST BPOPJ		;[356] Restore B and return
	EXCH B,0(P)		;SAVE ANSWER
	SFPTR			;RESTORE TO WHERE WE WERE AT CALL
	  JRST BPOPJ		;[356] Restore B and return
	AOS -1(P)		;[356] Give a skip return
BPOPJ:	POP P,B			;[356] RETURN THE LENGTH OF FILE
	POPJ P,
;**;[436] REPLACE MANY LINES AT PTRGT1:+0.L	DSW	4/23/85
;[436] NOTE: WE'LL USE GETEOF: INSTEAD OF OLD CODE, DOES SAME THING
PTRGT1:	PUSHJ P,GETEOF		;[436] RETURNS EOF IN AC A
	MOVE B,A		;[436] GET WHERE WE WANT IT...
	CAMLE B,IOEOFP(BB)	;[436] DO NOT SAVE EOF IF IT IS LOWER
	 MOVEM B,IOEOFP(BB)	;[436] SAVE EOF POINTER
	JRST CPOPJ1

PTRGT2:	MOVEI B,1102*200	;RETURN THE # OF WORDS ON A DTA
	JRST CPOPJ1


;IN, OUT, INPUT, OUTPUT

UOUT:	PUSHJ P,OUTT
	MOVE A,FLAGWD(BB)
;**;[371] At UOUT: +2L, Replaced 1 line         	SM	26-Oct-81
	TRNE A,742000		;[371] DATA ERROR, EOT.
	JRST UIOSK1
	JRST UIOSK

UIN:	PUSHJ P,INN
	MOVE A,FLAGWD(BB)
	TRNE A,762000		;DATA ERRS, EOF, OR EOT?
UIOSK1:	AOS 0(P)
UIOSK:	JRST MRETN

UINPUT:	PUSHJ P,INN
	JRST MRETN

UOUTPT:	PUSHJ P,OUTT
	JRST MRETN

;IN AND INPUT OPERATORS

INN:	PUSHJ P,SETUP
	MOVE A,FLAGWD(BB)
	JUMPN AA,INN0		;IS THIS THE DISK?
	TLNE A,LOOKPF		;YES, WAS A LOOKUP DONE
	  JRST INN0		;YES
	MOVEI A,IO.IMP		;NO, SET IO IMPROPER MODE
	IORM A,FLAGWD(BB)	;IN FLAG REGISTER
	POPJ P,			;AND RETURN
INN0:	TLNE A,IOPENF		;OPEN FOR INPUT?
	JRST INN3		;YES
	CAIN AA,TTY		;IS THIS A TTY
	  JRST INNTTO		;YES, OPEN IT FOR BOTH READ AND WRITE
	MOVEI B,OF%RD
	PUSHJ P,OPENX		;OPEN IT FOR INPUT
	  JRST INMNTF		;OPEN FAILED, SEE IF NEEDS MOUNTING
	MOVSI A,IOPENF!LOOKPF
INN1:	IORM A,FLAGWD(BB)	;MARK THAT FACT
	PUSHJ P,SETDES		;GO SET UP NEW DEVICE DESIGNATOR WORD
	PUSHJ P,SETUP		;SET UP DEVICE DESIGNATOR IN CASE IT CHANGED
	JUMPN AA,INN		;IF NOT A DISK, TRY AGAIN
	PUSHJ P,OPNDSK		;IF DISK FILE, SET UP THE COUNTS
	JRST INN		;GO TRY AGAIN

INNTTO:	MOVEI B,OF%RD!OF%WR	;READ AND WRITE
	PUSHJ P,OPENX
	  JRST INMNTF		;FAILED
	MOVSI A,IOPENF!OOPENF	;MARK THAT OPENED FOR BOTH
	JRST INN1

INMNTF:	PUSHJ P,MNTFAI		;SEE IF TRAP SET UP
	 JFCL
	PUSHJ P,ILLINP		;NO GO TYPE APPROPRIATE MESSAGE
	JRST INN		;TRY AGAIN

INN3:	ANDI A,17		;GET MODE INITED IN.
	CAIL A,15		;IS IT A BUFFERED MODE?
	JRST INDMP		;NO, DUMP MODE
	HRRZ CC,BUFHTB(BB)	;BUFFER HEADER
	HRRZ A,FORTY
	CAIE A,0		;SPECIFYING NEW RING?
	HRRM A,0(CC)		;YES, STORE ADDRESS
	MOVSI A,INFIRF		;FIRST TIME FLAG
	TDNE A,FLAGWD(BB)	;IS IT?
	SKIPG (CC)		;OR BUFFERS ALREADY SET UP
	  SKIPA			;YES, GO SET UP SIZE ETC.
	  JRST INN2		;NO
	IORB A,FLAGWD(BB)	;YES, BUT NOT NEXT TIME ...
	MOVSI A,IOPENF
	MOVSI B,INBUFF
	MOVEI C,2		;TWO BUFFERS
	XCTUM <HRRZ D,0(CC)>	;GET RH ONLY
	SKIPN D			;BUFFERS SET UP ALREADY?
	PUSHJ P,IOBUF		;NO SET UP A TWO BUFFER RING
	SKIPGE A,(CC)		;DON'T ADVANCE BUFFER THE FIRST
	JRST INN2B
INN2:	MOVSI A,400000		;CLEAR USE BIT OF CURRENT BUFFER
	ANDCAB A,@(CC)		;ALSO GET POINTER TO NEXT BUFFER
INN2B:	HRRZM A,(CC)
	TRZ PF,R.DIRN		;MARK THAT INPUT IS BEING DONE
	PUSHJ P,INIBUF		;ZERO BUFFER AND SET UP PTR AND COUNT
	HRRZ A,JFNTAB(BB)

	PUSHJ P,@INDSPT(AA)	;SETUP SHOULD SET UP AA WITH DEVICE NUMBER
	PUSHJ P,SETIBF		;COMPUTE COUNT AND SET UP NEW PTR
	MOVE B,0(CC)		;CURRENT BUFFER ADDRESS
	HRRZ A,FLAGWD(BB)	;FILE STATUS
	UMOVEM A,-1(B)		;STORE STATUS AT BEGINNING OF BUFFER
	POPJ P,

INDSPT:	INDSK			;DSK
	ITRAP			;DRM
	INMTA			;MTA
	INDTA			;DTA
	INBYT			;PTR
	ITRAP			;PTP
	ITRAP			;DSP
	ITRAP			;LPT
	INCDR			;CDR
	INBYT			;FE
	INTTY			;TTY
	INPTY			;PTY
	INTTY			;TTR
	INBYT			;NUL
	INBYT			;NET
	ITRAP			;PLT
	INBYT			;DLX
	ITRAP			;CDP
	INBYT			;DCN
	INBYT			;SRV

NINDSP==.-INDSPT

IF2 <IFN <NINDSP-MAXDEV>,<PRINTX INPUT DISPATCH TABLE "INDSPT" NEEDS FIXING>>

INDMP:	CAIN AA,DTA		;IS THIS A DTA
	  PUSHJ P,DTAINI	;YES, CLOSE ANY OPEN JFNS FOR THIS DTA
	HRRZ A,JFNTAB(BB)	;JFN
	CAIN AA,DSK		;DEVICE DISK?
	JRST INDM2		;YES- SIMULATE DUMPI BY SIN
	HRRZ B,FORTY		;NO- USE DUMPI
	CAIGE B,20		;IN THE AC'S?
	ADDI B,ACS		;YES. POINT TO THEM
	TRZ PF,R.DIRN		;DIRECTION IS INPUT (FOR MTA)
	MOVE C,DEVTBL(AA)	;IS IT A MAGTAPE?
	TLNE C,MTADEV		; ..
	JRST MTALP1		;YES. TREAT SEPARATELY
INDM1:	DUMPI
	  JRST INDMER		;ERROR. SEE IF FIXABLE.
INDM3:	POPJ P,

INDM2:	HRRZ D,FORTY		;COMMAND LIST POINTER
INCML:	CAIGE D,20		;IN THE ACS?
	ADDI D,ACS		;YES. POINT TO STORED ACS
	MOVE C,(D)		;COMMAND LOOP
	JUMPE C,INDM3		;DONE ON ZERO COMMAND
	TLNE C,-1		;ZERO LEFT HALF MEANS GOTO
	JRST INDM4
	MOVE D,C
	JRST INCML		;GET NEW COMMAND

INDM4:	MOVE B,FLAGWD(BB)	;IS THIS A UFD WE ARE READING
	TLNE B,RDUFDF
	  JRST INDUFD		;YES, GO DO GNJFN'S
	TRZ PF,R.DIRN		;MARK THAT WE ARE DOING INPUT
	HRRZM C,IOBPT		;SET UP IO POINTER
	HLROS C			;GET WORD COUNT
	MOVNM C,IOCNT		;STORE AS POSITIVE COUNT OF WORDS TO TRANSFER
	PUSH P,D		;SAVE COUNTER
	PUSHJ P,MOVBUF		;GO TRANSFER THE BUFFER
	 JRST [	POP P,D		;RESTORE STACK
		JRST INDM4B]	;EOF
	POP P,D			;RESTORE COUNTER
	MOVE B,IOBYTP(BB)	;GET FINAL BYTE POINTER
	TRZE B,177		;MAKE SURE IT ENDED ON A 200 WORD BOUNDRY
	 JRST [	ADDI B,200	;IT DIDNT, SO MAKE IT BE ON A BLK BOUND
		IFN FTFILSER,<
		HLRZ A,DEVNAM(BB)
		CAIN A,'DPA'	;CHECK FOR TOPS-10 PACK
		JRST .+1	;IF YES, DO NOT DO THE SFPTR
		>
		HRRZ A,JFNTAB(BB)
		SFPTR		;SET NEW POINTER
		 PUSHJ P,ERROR
		JRST .+1]
	MOVEM B,IOBYTP(BB)	;STORE NEW BYTE POINTER
	SKIPG B,IOCNT		;WAS THIS TRANSFER COMPLETED
	AOJA D,INCML		;YES, GO GET THE NEXT COMMAND TO DO
	AOS IOBPT
	SETZM @IOBPT		;NO, ZERO THE REST OF THE BUFFER AREA
	SOJG B,.-2
	AOJA D,INCML		;GO SEE IF THROUGH

INDM4B:	MOVEI A,1B22		;YES. REALLY EOF.
	IORM A,FLAGWD(BB)	;SET 10/50 EOF BIT
	JRST INDM3		;DONE.

;SET BUFFER FOR USER AFTER INPUT

SETIBF:	MOVE B,IOCNT		;BYTES NOT XFERRED LAST TIME
	LDB C,[POINT 6,IOBPT,11] ;BYTE SIZE OF XFER
	XCTLB <LDB D,[POINT 6,1(CC),11]> ;USER'S BYTE SIZE
	CAIN C,0(D)		;SAME?
	JRST SETIB1		;YES
	CAIG C,0(D)		;XFER SIZE BIGGER?
	JRST SETIB2		;NO
	SKIPE D			;IF 0 DONT DO DIVIDE
	IDIVI C,0(D)		;XFER SIZE BIGGER, GET RATIO
	IMUL B,C		;NUMBER USER-SIZE BYTES NOT XFER'D
SETIB1:	MOVN C,B		;B NOW HAS NUMBER NOT XFERRED
	XCTUU <ADDB C,2(CC)>	;ACTUAL BYTES XFERRED TO USER
	MOVE B,C		;BYTES
	MOVEI C,^D36		;BITS PER WORD
	XCTLB <LDB D,[POINT 6,1(CC),11]>	;USER'S BITS PER BYTE
	SKIPE D			;IF 0 DONT DIVIDE
	IDIVI C,(D)		;BYTES PER WORD
	IDIVI B,(C)		;WORDS
	SKIPE C			;AND FRACTION THEREOF
	ADDI B,1
	MOVE C,0(CC)		;CURRENT BUFFER ADDRESS
	TRNE PF,R.NOWC		;SHOULD THE WORD COUNT BE STORED?
	  JRST SETIB3		;NO, SO DONT STORE IT
	XCTMU <HRRM B,1(C)>	;STORE THE WORD COUNT WITH BUFFER
;**;[415] Add 1 line at SETIB3+6,+13
SETIB3:	MOVSI A,HASDIR+MTADEV	;SEE IF 36-BIT DEVICE
	TDNE A,DEVTBL(AA)	;IF NOT, THEN BUFFER WAS ALREADY ZEROED
	SKIPN IOCNT		;DID BUFFER GET COMPLETELY FILLED
	  JRST SETIB4		;YES, JUST RETURN
	XCTUM <HLRZ C,0(C)>	;GET SIZE OF BUFFER PLUS ONE
	ANDI C,377777		;CLEAR USE BIT
	SUBI C,1(B)		;GET REMAINING WORDS IN BUFFER
	PUSH P,B		;[415] SAVE # BYTES TRANSFERRED
	AOS B,IOBPT		;GET POINTER TO NEXT WORD IN BUFFER
	HRLS B			;SET UP SOURCE WORD FOR BLT
	SETZM 0(B)		;ZERO THE FIRST WORD
	ADDI C,-1(B)		;GET POINTER TO END OF BUFFER
	HRRI B,1(B)		;GET DESTINATION
	CAIL C,0(B)		;BLOCK OF MORE THAN ONE WORD IN LENGTH?
	  BLT B,0(C)		;YES, ZERO BLOCK
	POP P,B			;[415] RESTORE NUMBER BYTES TRANSFERRED
;**;[415] ADD 4 LINES AT SETIB4+1
SETIB4:	MOVSI A,400000		;BUFFER USE BIT (BF.IOU)
	JUMPN B,SETIBX		;[415] BUFFER ACTIVE ?
	XCTUU <ANDCAM A,@(CC)>	;[415] NO
	POPJ P,			;[415] RETURN
SETIBX:				;[415]
	XCTUU <IORM A,@(CC)>	;SET IN BUFFER HEADER
	POPJ P,			;RETURN

SETIB2:	IDIVI D,0(C)		;BUT OTHERWISE, THIS FIXES UP
	IDIV B,D		;BYTE COUNT
	JRST SETIB1

;ROUTINE TO INPUT FROM DSK VIA PMAP SINCE SIN IS SLOWER.

INDSK:	MOVE B,FLAGWD(BB)	;GET FLAGS FOR THIS CHANNEL
	TLNE B,RDUFDF		;ARE WE READING A UFD
	JRST INUFD		;YES, GO SIMULATE IT
	TRZ PF,R.DIRN		;MARK THAT WE ARE DOING INPUT
	MOVEI A,200		;ALWAYS DO 200 WORDS FOR DISK
	EXCH A,IOCNT
	PUSH P,A		;SAVE ORIGINAL COUNT FOR LATER
	PUSHJ P,MOVBUF		;GO MOVE A BUFFER
	  JRST [POP P,A		;EOF WAS SEEN
		JRST INTY8A]
	POP P,A			;GET ORIGINAL IOCNT
	MOVE B,IOCNT		;GET NEW IOCNT
	ADDI A,-200(B)		;GET IOCNT REFLECTING # OF WORDS RECEIVED
	HRRZM A,IOCNT		;STORE FOR CLEAN UP ROUTINE
	JRST INTTY9		;OK RETURN

INDON1:	AOS IOCNT
	JRST INTTY9

INTTY8:	PUSHJ P,CRLF		;TYPE CRLF ECHO
INTY8A:	MOVEI A,1B22		;EOF FLAG IN STATUS WORD
	IORM A,FLAGWD(BB)
INTTY9:	MOVSI A,400000		;BUFFER USE FLAG
	XCTUU <IORM A,@(CC)>
	LDB A,[POINT 6,IOBPT,11] ; GET BYTE SIZE
	CAIE A,7		;WAS THIS AN ASCII TRANSFER
	  JRST INTTY7		;NO, DONT CLEAR REST OF WORD
	MOVE A,IOCNT
	IDIVI A,5		;DOES IT END ON WORD BOUNDARY?
	JUMPE B,INTTY7		;YES, ALL DONE.
	MOVE A,B
	SETZ B,

FILWD:	XCTLB <IDPB B,IOBPT>	;FILL REST OF LAST WORD WITH ZEROES
	SOS IOCNT
	SOJG A,FILWD

INTTY7:	POPJ P,

CRLF:	PUSH P,A		;TYPE OUT A CRLF
	HRROI A,[ASCIZ/
/]
CPSOUT:	PSOUT
	JRST APOPJ

OUTT:	PUSHJ P,SETUP
	MOVE B,FLAGWD(BB)
;**;[345] INSERT @OUTT+2 1/2
	JUMPN AA,OUTT3		;[345] IS THIS THE DISK?
	TLNE B,ENTERF		;[345] YES, WAS AN ENTER DONE
	  JRST OUTT3		;[345] YES
	TLNN B,OUFIRF		;[345] NO, DUMMY OUTPUT?
	  JRST OUTT3		;[345] YES
	MOVEI B,IO.IMP		;[345] NO, SET IO IMPROPER MODE
	IORM B,FLAGWD(BB)	;[345] IN FLAG REGISTER
	POPJ P,			;[345] AND RETURN
OUTT3:	TLNE B,OOPENF		;[345] OPEN FOR OUTPUT?
	JRST OUTTN		;YES
	SKIPN JFNTAB(BB)	;DOES IT HAVE JFN?
	TLNN B,OUFIRF		;OR IS IT FIRST TIME THROUGH?
	TLNN B,INITF		;AND IS IT INIT'ED?
	PUSHJ P,ERRCHN		;NO- ERROR
	SKIPN JFNTAB(BB)	;DOES IT HAVE JFN?
	JRST OUTTN		;NO, DON'T OPEN IT YET
	CAIN AA,TTY		;IS THIS A TTY
	  JRST OUTTTO		;YES, OPEN IT FOR BOTH R+W
	MOVEI B,1B20
	PUSHJ P,OPENX		;OPEN FOR OUTPUT
	  JRST OUTMTF		;OPEN FAILURE, GO SEE IF IT WAS A MOUNT
	MOVSI A,OOPENF
OUTT0:	IORM A,FLAGWD(BB)	;AND MARK IT
	JRST OUTT

OUTTTO:	MOVEI B,1B19!1B20	;OPEN FOR BOTH READ AND WRITE
	PUSHJ P,OPENX
	  JRST OUTMTF
	MOVSI A,IOPENF!OOPENF
	JRST OUTT0

OUTMTF:	PUSHJ P,MNTFAI		;SEE IF USER WANTS TO TRAP THIS
	 JFCL
	PUSHJ P,ILLOUT		;NO TYPE A MESSAGE AND BOMB
	JRST OUTT		;TRY AGAIN

OUTTN:	MOVEI A,17
	AND A,FLAGWD(BB)	;MODE
	CAIL A,15		;IS IT A BUFFERED MODE?
	JRST OUTDMP		;NO
	HLRZ CC,BUFHTB(BB)	;OUTPUT BUFFER HEADER POINTER
	JUMPE CC,CPOPJ		;IF NO BUFFER HEADER, IGNORE CLOSE
	HRRZ A,FORTY
	JUMPN A,[HRRM A,0(CC)	;NES RING? YES, STORE ADDRESS
		MOVSI A,400000	;CLEAR IOUSE BIT
		ANDCAM A,0(CC)
		JRST .+1]
	MOVSI A,OUFIRF		;FIRST TIME THROUGH FLAG
	TDNE A,FLAGWD(BB)	;IS IT?
	SKIPGE 0(CC)		;OR BUFFER NOT SETUP?
	SKIPA			;YES, DO DUMMY OUTPUT
	JRST OUTT2		;NO
	IORM A,FLAGWD(BB)	;YES
	MOVEI C,2
	MOVSI B,OUTBFF		;OUTBUF DONE FLAG
	XCTUU <SKIPN 0(CC)>	;OUTPUT BUFFERS SETUP?
	PUSHJ P,IOBUF		;NOT YET
	XCTUU <SKIPGE A,(CC)>	;HAS USER SET UP HIS OWN BUFFERS?
	JRST OUTT9		;NO, GO FIX UP FIRST BUFFER FOR HIM

OUTT2:	PUSHJ P,SETOBF
	HRRZ A,JFNTAB(BB)	;GET DESTINATION
	SKIPN IOCNT		;ALWAYS OUTPUT IF NON-ZERO
	TRNN PF,R.CLS		;IF ZERO, DON'T OUTPUT IF CLOSE
	PUSHJ P,@OUTLST(AA)
	MOVE B,0(CC)		;CURRENT BUFFER ADDRESS
	HRRZ A,FLAGWD(BB)	;FILE STATUS
	MOVEM A,-1(B)		;STORE LATTER IN BEGINNING OF FORMER
	XCTUU <MOVE A,@(CC)>	;ADVANCE THE BUFFER
OUTT9:	XCTUU <HRRZM A,(CC)>
	TRO PF,R.DIRN		;MARK THAT OUTPUT IS BEING DONE
	PJRST INIBUF
OUTLST:	EXP OUTDSK		;DSK
	EXP ITRAP		;DRM
	EXP OUTMTA		;MTA
	EXP OUTDTA		;DTA
	EXP ITRAP		;PTR
	EXP OUTBYT		;PTP
	EXP ITRAP		;DSP
	EXP OUTBYT		;LPT
	EXP ITRAP		;CDR
	EXP OUTBYT		;FE
	EXP OUTTTY		;TTY
	EXP OUTPTY		;PTY
	EXP ITRAP		;TTR
	EXP OUTBYT		;NUL
	EXP OUTBYT		;NET
	EXP OUTBYT		;PLT
	EXP OUTBYT		;DLX
	EXP OUTBYT		;CDP
	EXP OUTBYT		;DCN
	EXP OUTBYT		;SRV

NOUTDS==.-OUTLST

IF2 <IFN <MAXDEV-NOUTDS>,<PRINTX DISPATCH TABLE "OUTLST" NEEDS FIXING>>

OUTDMP:	MOVSI A,OUFIRF		;MARK THAT OUTPUT WAS DONE
	IORM A,FLAGWD(BB)	;SO CLOSE KNOWS
	CAIN AA,DTA		;DTA?
	  PUSHJ P,DTAINI	;YES, CLOSE ANY OPEN JFNS FOR THIS DTA
	HRRZ A,JFNTAB(BB)	;JFN
	CAIN AA,DSK		;DISK DEVICE TYPE?
	JRST OUTDM2		;YES- SIMULATE DUMPO BY SOUT
	HRRZ B,FORTY		;NO- USE DUMPO
	CAIGE B,20		;POINTER IN AC'S?
	ADDI B,ACS		;YES. POINT TO STORED ACS
	TRO PF,R.DIRN		;DIRECTION IS OUTPUT.
	MOVE C,DEVTBL(AA)
	TLNE C,MTADEV		;MAG TAPE?
	JRST MTALP1		;YES. GO TO MAG TAPE HANDLER
OUTDM1:	DUMPO
	  JRST OUDMER		;LOST. SEE IF RECOVERABLE
OUTDM3:	POPJ P,

OUTDM2:	HRRZ D,FORTY		;COMMAND LIST POINTER
OUTCML:	CAIGE D,20		;IN THE ACS?
	ADDI D,ACS		;YES. POINT TO STORED ACS
	MOVE C,(D)		;COMMAND LOOP
	JUMPE C,OUTDM3		;DONE ON ZERO COMMAND
	TLNE C,-1		;ZERO LEFT HALF MEANS GOTO
	JRST OUTDM4		;NO,REAL IO WORD
	MOVE D,C
	JRST OUTCML

OUTDM4:	TRO PF,R.DIRN		;MARK THAT OUTPUT IS IN PROGRESS
	HRRZM C,IOBPT		;STORE POINTER TO BUFFER IN USER AREA
	HLROS C			;GET NEG WORD COUNT
	MOVNM C,IOCNT		;STORE AS POSITIVE IOCNT
	HRRZ A,JFNTAB(BB)	;GET JFN IN CASE AN SFPTR IS DONE
	MOVE B,IOBYTP(BB)	;GET CURRENT POSITION TO START WRITING
	CAMLE B,IOEOFP(BB)	;NEED TO UPDATE FILE POINTER TO NEXT BLK
	SFPTR			;YES, ALWAYS START ON A BLOCK BOUNDRY
	  JFCL
	PUSH P,D		;SAVE THE COUNTER
	PUSHJ P,MOVBUF		;MOVE THE BUFFER
	  JFCL			;SHOULD NEVER GET HERE
	POP P,D			;RESTORE COUNTER
	MOVE B,IOBYTP(BB)	;SEE IF TRANSFER ENDED ON A BLOCK BOUNDRY
	ANDI B,177
	JUMPE B,OUDM4D		;IF 0, THEN DONT FILL WITH ZEROS
	HRROI C,-200(B)		;GET NEG # OF ZEROS TO BE WRITTEN
	HRRZ A,JFNTAB(BB)	;GET JFN OF FILE
	MOVE B,IOBYTP(BB)	;FIRST, GET THE BYTE POINTER SET UP
	SFPTR
	 ERCAL ERROR
	MOVSI B,(POINT 0,0,0)	;GET POINTER TO A SOURCE OF ZEROS
	SOUT			;FILL WITH ZEROS

OUDM4D:	PUSHJ P,FIXEOF		;GO FIX UP THE EOF IF IT NEEDS IT
	MOVE C,IOBYTP(BB)	;GET THE BYTE POINTER AGAIN
	TRZN C,177		;WAS THIS AN EVEN BLOCK TRANSFER?
	AOJA D,OUTCML		;YES, GO DO NEXT COMMAND
	ADDI C,200		;NO, MAKE IT AN EVEN 200
	MOVEM C,IOBYTP(BB)
	AOJA D,OUTCML		;GO DO NEXT COMMAND

OUTBYT:	MOVE 2,IOBPT
	MOVN 3,IOCNT
	JUMPGE 3,CPOPJ		;IT'S POSSIBLE THERE'S NOTHING TO DO
	SOUT
	MOVEM 2,IOBPT
	SETZM IOCNT
	POPJ P,

OUTDSK:	MOVE A,IOBYTP(BB)	;GET NEW END OF DATA
	ADD A,IOCNT		;FOR EOF CALCULATION
	PUSH P,A		;SAVE FOR AFTER TRANSFER
IFN FTFILSER,<
	HLRZ B,DEVNAM(BB)	;THIS GOING TO A TOPS-10 PACK?
	CAIN B,'DPA'		;IF YES, THEN LEAVE COUNT ALONE
	  JRST OUTDS1		;YES, LEAVE ACTUAL COUNT FOR FILSER
>
	MOVEI A,200		;ALWAYS TRANSFER 200 WORDS FOR DISK
	MOVEM A,IOCNT		;...
OUTDS1:	TRO PF,R.DIRN		;OUTPUT IN PROGRESS
	PUSHJ P,MOVBUF		;SEND OUT THE BUFFER
	  JFCL
	POP P,A			;GET POSSIBLE NEW EOF POSITION
	CAMLE A,IOEOFP(BB)	;IS THERE A NEW EOF
	 PUSHJ P,UPDEOF		;YES, UPDATE THE EOF
	POPJ P,


;ROUTINE TO UPDATE THE EOF FOR A CHANNEL

FIXEOF:	MOVE A,IOBYTP(BB)	;GET THE NEW BYTE POINTER
	CAMG A,IOEOFP(BB)	;SEE IF EOF NEEDS UPDATING
	POPJ P,			;NO, JUST RETURN
UPDEOF:	MOVEM A,IOEOFP(BB)	;STORE THE NEW EOF
	MOVE A,FLAGWD(BB)	;SEE IF THIS FILE IS A NEW FILE
	TLNN A,IOPENF!LOOKPF	;IF FILE WAS LOOKED UP, THEN DO THE SFPTR
	POPJ P,			;OTHERWISE, NO NEED TO SET EOF POINTER
	HRRZ A,JFNTAB(BB)	;GET THE JFN
	MOVE B,IOEOFP(BB)	;GET THE NEW EOF POINTER
	SFPTR			;SET THE NEW POSITION
	 ERCAL ERROR
	POPJ P,			;RETURN

;MOVE A BUFFER TO OR FROM THE FILE
;PRESERVE AC D ALWAYS

MOVBUF:
IFN FTFILSER,<
	HLRZ A,DEVNAM(BB)	;IS THIS A DPA?
	CAIN A,'DPA'		;...
	  JRST TMOVB		;YES, GO DO UUO INSTEAD
>
	PUSHJ P,MAPINP		;GO TRY TO MAP IN THE PAGE
	SKIPE MAPTAB(BB)	;IS THERE A MAPPED AREA?
	JRST MOVBFP		;YES, GO BLT DATA FROM THERE
	TRNE PF,R.DIRN		;IN OR OUT?
	  SKIPA A,[SOUT]	;OUT
	MOVE A,[SIN]		;IN
	PUSH P,A		;SAVE JSYS TO BE EXECUTED
	MOVE C,IOEOFP(BB)	;(314)GET EOF
	SUB C,IOBYTP(BB)	;(314)GET # OF WORDS LEFT IN FILE
	TRNN PF,R.DIRN		;(314)ONLY CARE IF INPUT
	CAML C,IOCNT		;(314) NOT ENOUGH WORDS TO SATISFY REQUEST?
	  MOVE C,IOCNT		;(314)OK TO USE FULL COUNT
	JUMPLE C,APOPJ		;(314)NO MORE WORDS EOF RETURN TAKEN
	MOVNS C			;(314)C= NEG NUMBER OF WORDS TO TRANSFER
	MOVE B,IOBPT		;AND POINTER TO USER AREA
	HRLI B,(POINT 36,0,35)	;MAKE SURE IT IS A LEGAL BYTE POINTER
	PUSH P,C		;SAVE COUNT
	MOVN A,C		;GET ADDRESS OF WORD BEYOND BUFFER
	ADDI A,1(B)		;SIN ZERO'S 1 WORD AFTER BUFFER
	PUSH P,0(A)		;SAVE WORD
	PUSH P,A		;AND ITS ADDRESS
	HRRZ A,JFNTAB(BB)	;GET JFN
	XCT -3(P)		;DO THE TRANSFER
	POP P,A			;GET BACK ADR OF WORD AFTER BUFFER
	POP P,0(A)		;RESTORE WORD AFTER BUFFER
	POP P,A			;GET BACK ORIGINAL COUNT
	POP P,(P)		;CLEAN UP STACK
	SUB C,A			;CALCULATE # OF WORDS TRANSFERED
	JUMPE C,CPOPJ		;IF NONE TRANSFERED, EOF
	ADDM C,IOBYTP(BB)	;UPDATE FILE POINTER
	SUB C,IOCNT		;UPDATE IOCNT
	MOVNM C,IOCNT		;THOSE WORDS NOT TRANSFERED
	MOVEM B,IOBPT		;AND UPDATED POINTER
	JRST CPOPJ1		;EXIT SUCCESSFULLY

MOVBFP:	MOVE B,IOBYTP(BB)	;GET CURRENT POINTER
	ANDI B,777		;GET WORD WITHIN PAGE
	SUBI B,1000		;GET NEG # OF WORDS LEFT IN PAGE
	MOVE C,IOEOFP(BB)	;GET EOF
	SUB C,IOBYTP(BB)	;GET # OF WORDS LEFT IN FILE
	TRNN PF,R.DIRN		;ONLY CARE IF INPUT
	CAML C,IOCNT		;IS THERE NOT ENOUGH WORDS TO SATISFY REQUEST
	  MOVE C,IOCNT		;OK TO USE FULL COUNT
	CAMGE C,IOCNT		;NEAR THE END OF FILE?
;**;[436] DELETE 4 LINES IN LITERAL AT MOVBFP:+9.L	DSW	4/23/85
	JRST [	PUSHJ P,GETEOF	;[436] YES, SEE IF THE EOF CHANGED
		CAMG A,IOEOFP(BB)
		JRST .+1	;EOF DID NOT CHANGE
		MOVEM A,IOEOFP(BB) ;STORE NEW EOF
		JRST MOVBFP]	;GO TRY AGAIN WITH NEW EOF
	JUMPLE C,CPOPJ		;NO MORE WORDS, EOF RETURN TAKEN
	MOVNS C			;C = NEG # OF WORDS TO TRANSFER
	CAMLE B,C		;ENOUGH WORDS IN PAGE?
	  JRST MOVB1		;NO, DO THIS IN CHUNKS
MOVB2:	MOVE A,IOBYTP(BB)	;GET POSITION WITHIN OF FILE
	IDIVI A,NPLPGS*1000	;GET POSITION WITHIN MAPPED AREA INTO B
	HRRZ A,MAPTAB(BB)	;GET THE START OF THE MAPPED AREA
	LSH A,11		;MAKE IT AN ADDRESS
	ADDI A,(B)		;THIS IS DESTINATION ADDRESS
	HRL A,IOBPT		;NOW GET ADDRESS OF USER BUFFER
	ADD A,[XWD 1,0]
	TRNN PF,R.DIRN		;DOING OUTPUT?
	  MOVSS A		;YES, REVERSE THE DIRECTION OF A
	ADDM C,IOCNT		;COUNT DOWN IOCNT
	MOVN B,C		;GET POS WORD COUNT
	ADDM B,IOBPT		;UPDATE IOBPT
	ADDM B,IOBYTP(BB)	;AND FILE POINTER
	ADDI B,(A)		;GET END OF TRANSFER ADDRESS
MOVINS:	BLT A,-1(B)		;TRANSFER THE DATA
	ERJMP MOVBE		;IF FAILED, GO SEE IF SPARSE FILE
MOVINE:	JRST CPOPJ1

MOVB1:	MOVE C,B		;DO ONLY WHAT IS LEFT IN THIS PAGE
	PUSHJ P,MOVB2
	  JFCL
	JRST MOVBUF		;LOOP BACK FOR REST


MOVBE:	PUSH P,A		;SAVE THE ACS
	PUSH P,B
	TRNE PF,R.DIRN		;DOING AN INPUT?
	JRST MOVBE1		;NO, GO TRY AGAIN
	MOVEI A,.FHSLF		;GET LAST ERROR
	GETER
	HRRZS B			;ONLY WANT THE ERROR CODE
	CAIE B,ILLX01		;ILLEGAL READ?
	JRST MOVBE1		;NO, GO DO BLT AGAIN ONLY LET IT TRAP
	POP P,B			;RESTORE ARGUMENTS
	POP P,A			;GIVE THE USER PROGRAM ZEROES
	SETZM (A)		;ZERO FIRST WORD OF BUFFER
	HRLS A			;SET UP BLT POINTER TO PROPAGATE ZERO
	HRRI A,1(A)		;SET UP DESTINATION ADR
	CAILE B,(A)		;ENOUGH ROOM FOR BLT?
	BLT A,-1(B)		;YES, GIVE REST OF ZEROES TO USER
	JRST CPOPJ1		;RETURN

MOVBE1:	POP P,B			;THIS IS AN UNKNOWN ERROR
	POP P,A			;SO DO THE BLT AGAIN
	BLT A,-1(B)		;BUT LET THE ERROR CAUSE A TRAP
	JRST CPOPJ1		;SO QOUTA AND DATA ERRORS WORK RIGHT

;ROUTINE TO MAP IN THE NEXT 4 PAGES OF A FILE

MAPINP:	SKIPN MAPTAB(BB)	;IS THERE A MAPPED AREA?
	JRST MAPIN0		;NO, GO TRY TO SET ONE UP
	MOVE A,IOBYTP(BB)	;NOW SEE IF WE ARE ON A BOUNDRY
	IDIVI A,NPLPGS*1000
	IMULI A,NPLPGS		;GET FIRST PAGE OF THE SECTION
	HLRZ B,MAPTAB(BB)	;GET FIRST MAPPED PAGE OF FILE
	CAMN A,B		;HAVE THE RIGHT AREA MAPPED
	POPJ P,			;YES, NO NEED TO GO FURTHER
MAPIN0:	SKIPN MAPTAB(BB)	;IS THERE A MAP SLOT YET
	JRST [	PUSHJ P,GETIOP	;NO, GO GET ONE
		 JRST MAPIN1	;NONE LEFT
		MOVEM A,MAPTAB(BB)
		JRST .+1]
	MOVE A,IOBYTP(BB)	;GET PAGE OF FILE TO PRELOAD
	IDIVI A,NPLPGS*1000	;GET ADDRESS OF FIRST PAGE TO MAP
	IMULI A,NPLPGS*1000
	LSH A,-11		;GET PAGE NUMBER OF FIRST MAPPED PAGE
	HRLM A,MAPTAB(BB)	;SAVE PAGE # OF MAPPED FILE PAGE
	HRL A,JFNTAB(BB)	;SET UP FOR PMAP
	HRLI B,.FHSLF		;MAP INTO THIS FORK
	HRR B,MAPTAB(BB)	;GET PAGE NUMBER TO MAP INTO
	MOVE C,[PM%CNT!PM%RD+NPLPGS]
	MOVE D,FLAGWD(BB)	;SEE IF PRELOADING IS TO BE DONE
	TLNN D,RNDMF		;DOING RANDOM ACCESS?
	TRNE PF,R.DIRN		;NO, INPUT?
	SKIPA			;NO, DO NOT PRELOAD ANY PAGES
	TXO C,PM%PLD		;YES, THEN PRELOAD THE PAGES
	TLNE D,OOPENF		;OPENED FOR WRITE?
	TXO C,PM%WR		;YES, TURN ON WRITE BIT
	PMAP			;PREFAULT THE PAGES
	 ERJMP MAPIN1		;IF FAILED, GO USE SIN
	POPJ P,			;AND RETURN

MAPIN1:	SKIPN MAPTAB(BB)	;IS THERE A MAPPED AREA
	POPJ P,			;NO, DO NOT NEED TO DO ANYTHING
	PUSHJ P,UNMAPP		;YES, UNMAP THE PAGES
	HRRZ A,JFNTAB(BB)
	MOVE B,IOBYTP(BB)
	SFPTR			;SET THE BYTE POINTER UP CORRECTLY
	 ERJMP MAPIN2		;PROBLEM - INVESTIGATE...
	POPJ P,			;NOW GO USE SEQUENTIAL IO
MAPIN2:	CAIE A,DESX8		;FILE NOT ON DISK?
	PUSHJ P,ERROR		;NO, SOME OTHER ERROR
	POPJ P,			;NO FILE! JUST RETURN

GETIOP:	TLNN PF,L.SMAL		;SMALL SYSTEM?
	JRST GETIO0		;NO, ALWAYS PREFAULT IF POSSIBLE
	MOVE A,MAPTOT		;HOW MANY FILES ARE OPEN ALREADY?
	CAIL A,5		;REACHED ARBITRARY LIMIT YET?
	POPJ P,			;YES, DO NOT PREFAULT ANY MORE
GETIO0:	MOVE A,MAPLST		;FIND A FREE MAP SLOT
	JFFO A,GETIO1		;IF ANY
	POPJ P,			;NONE LEFT
GETIO1:	MOVSI A,400000		;NOW SET UP A MASK
	MOVN C,B
	LSH A,0(C)
	ANDCAM A,MAPLST		;MARK THIS SLOT IN USE
	AOS MAPTOT		;COUNT UP THE NUMBER OF SLOTS IN USE
	IMULI B,NPLPGS		;CALCULATE THE PAGE # OF THE SLOT
	ADDI B,IOMPGS
	MOVE A,B		;RETURN THE ANSWER IN A
	JRST CPOPJ1		;SKIP RETURN WHEN SUCCESSFUL

;PREPARE FULL BUFFER FOR EMPTYING

SETOBF:	MOVEI B,17
	AND B,FLAGWD(BB)	;MODE
	XCTUU <HLLZ C,1(CC)>	;GET BYTE SIZE BITS
	XCTUU <HRRZ D,1(CC)>	;FETCH RH OF BYTE POINTER
	UMOVE E,(CC)
	SUBI D,1(E)		;PTR TO ZERO'TH WORD OF DATA
	MOVEI A,1B31
	TDNE A,FLAGWD(BB)	;USER WANTS TO SPECIFY OWN COUNT?
	  JRST [UMOVE D,1(E)	;YES, GET COUNT
		JRST .+1]
	MOVEI F,0(D)		;SAVE UN-MULTIPLIED COUNT
	LDB A,[POINT 6,C,11]	;BYTE SIZE
	PUSH P,B		;SAVE B OVER DIVIDE
	PUSH P,A		;PUSH SIZE
	MOVEI A,44		;WORD LENGTH
	SKIPE 0(P)		;IN CASE CLOBBERED
	IDIV A,0(P)		;BYTES PER WORD
	POP P,B			;DISCARD BYTE SIZE
	POP P,B			;RESTORE B
	IMULI D,0(A)		;BYTE COUNT IN THOSE WORDS
	MOVEI C,1(E)		;CONSTRUCT BYTE POINTER FOR XFER

	;[353] INSERT @ SETOBF+22
	CAIN AA,MTA		;[353] MAGTAPE?
	JRST STOBF0		;[353] YES, SPECIAL HANDLING

	MOVSI E,HASDIR		;USUAL CHECK FOR WORD TRANSFERS
	HRLI C,0700		;TRANSFER 7-BIT UNLESS
	CAIGE B,10		;MODE IS BINARY, OR
	TDNE E,DEVTBL(AA)	;DEVICE HAS DIRECTORY OR IS MAGTAPE
	HRLI C,4400		;IN WHICH CASE TRANSFER 36-BIT

	;[353] INSERT @ SETOBF+27
	JRST	STOBF1		;[353] CONT

	;[353] HERE FOR MTA, SET PROPER BYTE SIZE

STOBF0:	PUSH	P,A		;[353] SAVE A
;	PUSHJ	P,MTLBSZ	;[357][353] GET BYTE SIZE IN AC A
	LOAD	A,MTABYT	; [357] GET OPEN BYTE SIZE
	LSH	A,6		;[353] SHIFT LEFT 6 PLACES (BYTE SIZ POS.)
	HRLI	C,(A)		;[353] SET IN C
	POP	P,A		;[353] RESTORE A


STOBF1:	MOVEM C,IOBPT		;[353] SET BYTE PTR
	TLNE C,4000		;IF 36-BIT XFER,
	MOVE D,F		;USE UN-MULTIPLIED COUNT
	MOVEM D,IOCNT		;LEAVE COUNT FOR XFER ROUTINE
	LDB C,[POINT 6,IOBPT,11] ;GET BYTE COUNT FROM IOBPT
	XCTLB <LDB B,[POINT 6,1(CC),11]> ;GET USER'S BYTE COUNT
	CAMG B,C		;IS IOCNT WRONG
	  POPJ P,		;NO, RETURN
	IDIVI B,(C)		;YES, CORRECT IT
	IMULI D,(B)		;GET # OF BYTES PER WORD
	MOVEM D,IOCNT		;STORE CORRECT VALUE
	POPJ P,

SETDES:	MOVSI A,'TTY'		;SET NEW DEVICE DESIGNATOR WORD
	CAMN A,DEVNAM(BB)	;UNLESS IT IS THE TTY
	  POPJ P,		;TTY, JUST RETURN
	HRRZ A,JFNTAB(BB)	;GET JFN
	DVCHR			;GET NEW DEVICE CHARACTERISTICS WORD
	MOVEM A,DEVNUM(BB)	;SAVE NEW DEVICE TYPE IN CASE SPOOLED DEV
	POPJ P,

;PREPARE EMPTY BUFFER

INIBUF:	MOVEI D,17
	AND D,FLAGWD(BB)	;MODE
;**;[345] CHANGE WORD @INIBUF+2
	MOVSI E,HASDIR		;[345] SEE IF 36-BIT XFER POSSIBLE
	HRRZ B,A		;CHECK IF A POINTS TO ACS
	CAIGE B,20		;THIS WOULD BE ILLEGAL
	  PUSHJ P,ITRAP		;DONT ALLOW THIS, BLT WILL KILL PAT AC'S
	XCTUU <SETZM 1(A)>	;ZERO THE BUFFER
	MOVSI B,1(A)
	HRRI B,2(A)
	HLRZ C,(A)		;SIZE OF DATA AREA+1.
	ANDI C,377777		;CLEAR RING USE BIT
	CAIG C,1		;SHOULD BE NONZERO BUFFER SIZE
	PUSHJ P,ERRARG
	SUBI C,1
	PUSH P,C		;SAVE FOR LATER USE
	ADDI C,1(A)
	CAIGE D,10		;BINARY MODE?
	TDNE E,DEVTBL(AA)	;36-BIT DEVICE?
	  TRNE PF,R.DIRN	;YES, IS THIS INPUT?
	SKIPA			;NO, CLEAR BUFFER
	  JRST INIB1		;DONT HAVE TO CLEAR INPUT BUFFER FOR 36 BIT TRANSFER
	XCTUU <BLT B,(C)>
INIB1:	XCTUU <HLLZ B,1(CC)>	;GET SIZE BITS
	TLZ B,770077
	HRRI B,1(A)
	UMOVEM B,1(CC)		;INITIALIZE BYTE POINTER
	LDB C,[POINT 6,B,11]	;BYTE SIZE
	MOVEI A,44		;WORD SIZE
	PUSH P,B		;SAVE B OVER DIVIDE
	SKIPE C			;IN CASE OF JUNK IN HEADER
	IDIVI A,0(C)		;BYTES PER WORD
	POP P,B			;RESTORE B
	IMUL A,0(P)		;BYTES IN BUFFER
	UMOVEM A,2(CC)		;INIT BYTE COUNT
	CAIN AA,MTA		;MAGTAPE?
	JRST INIBMT		;YES, SPECIAL HANDLING
	POP P,A			;BUFFER LENGTH
	HRLI B,0700		;7-BIT UNLESS...
	CAIGE D,10		;BINARY MODE, OR
	TDNE E,DEVTBL(AA)	;36-BIT DEVICE?
	HRLI B,4400		;IN WHICH CASE 36-BIT
	CAIN AA,CDR		;IS THIS A CDR?
	JRST [	CAIE D,10	;YES, IS IT IN BINARY MODE
		JRST .+1	;NO
		HRLI B,1400	;YES, USE MODE 10
		MOVEM B,IOBPT	;STORE THE BYTE POINTER
		IMULI A,3	;GET THE NUMBER OF BYTES PER BUFFER
		JRST INIB2]	;GO STORE IT
	MOVEM B,IOBPT
	TLNN B,4000		;SMALL BYTES?
	IMULI A,5		;YES, 5 PER WORD
INIB2:	MOVEM A,IOCNT
	POPJ P,


INIBMT:	POP P,IOCNT		;SET WORD COUNT
	MOVEM B,IOBPT		;REMEMBER POINTER (WITHOUT BYTE SIZE)
	;[353] REPLACE @ INIBMT + 2
;	PUSHJ	P,MTLBSZ	;[357][353] GET MTA BYTE SIZE
	LOAD	A,MTABYT	; [357] GET OPEN BYTE SIZE
	DPB A,[POINT 6,IOBPT,11] ;[353] FILL IN BYTE SIZE
	MOVE	B,A		;[353] GET BYTE SIZE IN B
	MOVEI A,^D36		;HOW MANY BITS IN A WORD
	IDIV A,B		;COMPUTE HOW MANY BYTES IN A WORD
	IMULM A,IOCNT		;CONVERT WORD COUNT TO BYTE COUNT
	POPJ P,			;DONE

URELEA:	PUSHJ P,SETUPG
	JRST MRETN		;NOTHING TO RELEASE

IFN FTFILSER,<
	HLRZ A,DEVNAM(BB)	;IS THIS A DPA?
	CAIN A,'DPA'
	  JRST TRELEA		;YES, DO A FILSER RELEASE
>
	PUSHJ P,URELR		;DO THE RELEASE
	JRST MRETN

URELR:	SKIPN DEVNAM(BB)
	POPJ P,
	LDB AA,PDVNUM		;GET DEVICE TYPE CODE
	SETZM IOCNT
	PUSHJ P,UCL1K		;CLOSE FILE, KEEPING JFN
URELJ:	SKIPG JFNTAB(BB)	;IS THERE A JFN
	  JRST UREL2		;NO, DONT RELEASE IT
	HRRZ A,JFNTAB(BB)
	CAIE A,PRIJFN		;REAL JFN?
	CAIN A,PROJFN		; ..
	JRST UREL3		;NO
	PUSHJ P,SAVUFD		;IF A UFD SAVE JFN
	RLJFN
	  JFCL			;MAY FAIL BECAUSE FILE MAPPED ON ANOTHER CHANNEL

UREL2:	HLLZS FLAGWD(BB)	;CLEAR INIT BITS.
	SETZM CHTABS(BB)
	MOVSI A,CHTABS(BB)
	HRRI A,CHTABS+1(BB)
	BLT A,CHTABS+NTABS-1(BB)
	POPJ P,

UREL3:	HLLZ E,TYSTAT		;GET JUST LEFT HALF OF STATUS
	PUSHJ P,TTPSTS		;GO SET UP NEW TTY STATUS
	JRST UREL2

;SOME DEVICE TYPE THINGS

DSKCHR:	HLRZ F,CAC		;GET LENGTH OF ARG BLOCK
	CAIG F,0		;IS IT NON-ZERO
	  MOVEI F,1		;ASSUME ONE WORD
IFN FTFILSER,<
	UMOVE A,0(CAC)		;GET DEVICE NAME
	PUSHJ P,DPACHK		;SEE IF IT IS A TOPS-10 PACK
	  SKIPA			;NO
	JRST TDOUUO		;YES, GO CALL FILSER
>
	UMOVE D,0(CAC)		;GET USER ARGUMENT
	PUSHJ P,CHKDSK		;SEE IF THIS IS A DSK
	  JRST MRETN		;NO, GIVE ERROR RETURN
	CAIGE F,2		;WANT ANY VALUES RETURNED?
	  JRST DSKCH3		;NO, JUST RETURN THE AC FLAGS
	HRROI A,DEVNM7		;GET POINTER TO STR
	PUSHJ P,PAGUSE		;GET PAGES IN USE
	PUSH P,A		;SAVE ANSWER
	HRROI A,DEVNM7		;GET POINTER TO STR AGAIN
	HRROI B,STRNG1		;BUILD STR: STRING
	SETZ C,
	SIN
	MOVEI C,":"		;TACK ON A COLON
	IDPB C,B
	MOVEI C,0		;FOLLWED BY A NULL
	IDPB C,B
	MOVX A,RC%EMO		;NOW GET A DIR #
	HRROI B,STRNG1
	RCDIR
	 ERJMP DSKCH1
	TXNE A,RC%NOM!RC%AMB	;FOUND ONE?
	JRST DSKCH1		;NO
	MOVE A,C		;GET DIR # IN A
	GTDAL			;GET QUOTA
	POP P,B			;GET PAGES LEFT
	SUB A,B			;CALCULATE PAGES LEFT IN QUOTA
	ASH A,2			;TURN PAGES INTO BLOCKS
	UMOVEM A,1(CAC)		;STORE IT
DSKCH1:	HRROI A,DEVNM7		;GET STR NAME AGAIN
	STDEV			;GET A DEVICE DESIGNATOR
	 JRST DSKCH2		;FAILED
	MOVE A,B		;GET DESIGNATOR INTO A
	GDSKC			;GET FREE BLOCKS LEFT
	LSH B,2			;CHANGE PAGES TO BLOCKS
	CAIGE F,3
	  JRST DSKCH3
	UMOVEM B,2(CAC)
	CAIGE F,4
	  JRST DSKCH3
	UMOVEM B,3(CAC)		;STORE BLKS LEFT ON STR AND UNIT
DSKCH2:	CAIGE F,5		;CHECK ARG LIST LENGTH
	  JRST DSKCH3		;NOT LONG ENOUGH FOR STRUCTURE NAME
	UMOVE E,0(CAC)		;GET DEVICE NAME AGAIN
	UMOVEM E,4(CAC)		;STORE STR NAME
	CAIGE F,16		;LONG ENOUGH FOR PHYSICAL NAME
	  JRST DSKCH3		;NO, JUST RETURN
	UMOVEM E,14(CAC)	;STORE LOGICAL NAME AS "DSK"
	UMOVEM E,15(CAC)	;AND PHYSICAL NAME AS "DSK" TOO.
DSKCH3:	SETZ A,			;SET UP ANSWER
	XCTUM <MOVS B,0(CAC)>	;GET DEVICE NAME AGAIN
	CAIE B,'DSK'		;IS THIS DSK?
	MOVSI A,2		;NO, SAY THAT IT IS NOT GENERIC DSK
	JRST STOTC1		;RETURN ANSWER

CHKDSK:	HRROI E,DEVNM7		;MAKE IT ASCIZ
	PUSHJ P,SIXTO7		;...
	HRROI A,DEVNM7		;NOW GET DEVICE DESIGNATOR
	STDEV
	  POPJ P,
	TLNE B,77777		;IS THIS A DISK?
	  POPJ P,		;NO
	JRST CPOPJ1		;YES

GETCHR:
DEVCHR:	PUSH P,AC		;SAVE AC FOR STOTAC
	TLNE CAC,-1		;DEVICE NAME OR CHANNEL NUMBER?
	JRST DEVCH0		;SIXBIT DEVICE NAME
	CAILE CAC,MAXCHN	;LEGAL CHANNEL NUMBER
	JRST DEVCHZ		;NO, GIVE ERROR RETURN
	MOVEI AC,(CAC)		;GET CHANNEL NUMBER
	PUSHJ P,SETUPG		;GET INDEX INTO NAME TABLE
	JRST DEVCHZ		;NO DEVICE ON THIS CHANNEL, RETURN 0
	MOVE D,DEVNAM(BB)	;GET DEVICE NAME FROM TABLE
	JRST DEVCH3		;GO GET CHARACTERISTICS
DEVCH0:	MOVEI AC,0		;SET UP TO SEE IF THIS IS ALREADY INITED
DEVCLP:	PUSHJ P,SETUPG		;IS THERE A DEVICE ON THIS CHANNEL?
	JRST DEVCH2		;NO
	CAMN CAC,DEVNAM(BB)	;IS IT SAME AS ARGUMENT
	JRST DEVCH1		;YES, GO GET ITS CHARACTERISTICS
DEVCH2:	CAIGE AC,MAXCHN		;CHECKED ALL CHANNELS YET
	AOJA AC,DEVCLP		;NO
	SETO BB,		;MARK THAT THIS IS NOT INITED
DEVCH1:	MOVE D,CAC		;SIXBIT DEVICE NAME
DEVCH3:	PUSHJ P,DVCHR1		;CALL COMMON ROUTINE
	  JFCL			;NONEXISTENT DEVICE
	JUMPL BB,DVCHZ1		;IF NOT INITED, STORE THIS ANSWER
	TXNE A,DV.DSK!DV.LPT	;IF THIS A DISK OR LPT
	JRST DVCHZ1		;DON'T SET INITED BIT
	TROA A,1B19		;MARK THAT THIS DEVICE WAS INITED
DEVCHZ:	MOVEI A,0		;RETURN A ZERO
DVCHZ1:	POP P,AC		;RESTORE AC FOR STOTAC
	JRST STOTAC		;AND STORE THE RESULT

DEVSIZ:	UMOVE D,1(CAC)		;GET THE SIXBIT ARG DEVICE NAME
	PUSHJ P,DVCHR1		;GET ITS CHARACTERISTICS
	  JRST RETM11		;NO SUCH DEV. RETURN A MINUS 1
	HLRZ C,B		;GET THE TOPS-20 DEVICE TYPE
	ANDI C,777		; ..
	CAILE C,MAXDEV		;KNOWN DEVICE?
	MOVEI C,0		;NO, USE DSK
	UMOVE F,0(CAC)		;AND THE MODE WORD
	MOVE D,F		;GET MODE
	ANDI D,17		;JUST THE MODE FIELD
	MOVNI A,2		;ANSWER IF ILLEGAL
	MOVEI E,1		;BIT FOR MODE
	LSH E,(D)		;TO BIT POSITION
	TDNN E,DEVTBL(C)	;LEGAL?
	JRST STOTC1		;NO. RETURN THE -2
	CAIL D,15		;OK. IS MODE DUMP?
	JRST RETZR1		;YES. SKIP RETURN A ZERO
	HRRZ A,DEVTB2(C)	;NO. BUFFERED. GET BUFFER SIZE
	CAIE C,LPT		;LPT?
	CAIN C,CDR		;OR CDR?
	TLNE B,(1B3)		;YES, IS IT SPOOLED?
	SKIPA			;NO
	MOVEI A,200		;YES, USE 200 WORD BUFFERS
	CAIN C,DTA		;IS THIS A DECTAPE?
	TRNN F,100		;AND IN MODE 100?
	SKIPA			;NO
	  MOVEI A,200		;YES, BUFFER SIZE IS REALLY 200 WORDS
	CAIE C,MTA		;MAGTAPE?
	JRST DEVSI1		;NO, ALL DONE
	PUSHJ P,GETMBS		;YES, GET THE MAGTAPE BUFFER SIZE
	 MOVE A,DEVTB2+MTA	;FAILED, USE THE DEFAULT
DEVSI1:	ADD A,[2,,3]		;LH IS TWO BUFFERS, RH IS SIZE WITH HDR
	JRST STOTC1		;RETURN THAT AS ANSWER, SKIP.

DEVTYP:	MOVE D,CAC		;GET ARGUMENT IN CASE SIXBIT
	TLNE CAC,-1		;DEVICE NAME?
	JRST DVTYP1		;YES.
	CAILE CAC,MAXCHN	;LEGAL CHANNEL NUMBER?
	JRST MRETN		;NO
	MOVEI A,(CAC)		;YES
	IMULI A,NTABS		;GET TABLE OFFSET
	MOVE CAC,DEVNAM(A)	;GET DEVICE NAME
	SKIPE D,DEVNAM(A)	;A DEVICE THERE?
DVTYP1:	PUSHJ P,DVCHR1		;YES. GET THE BITS FROM TOPS-20 DVCHR TO B
	  JRST RETZR1		;ERROR. SKIP RETURN WITH A ZERO
	HLRZ D,B		;GET THE TOPS-20 INDEX
	ANDI D,777		; ..
	MOVE A,DVTYPT(D)	;GET FIXED BITS
	HLRZ C,C		;GET JOB NUMBER
	CAIN C,-1		;FREE?
	MOVEI C,0		;YES
	JUMPN C,DVTYP3		;IS THERE A JOB NUMBER
	MOVE C,JOB		;LOAD C WITH TSS JOB #
	MOVEI D,17		;SCAN ALL 17 CHANNELS
	MOVEI E,0		; LOOKING FOR THIS DEVICE INITED
DVTYP2:	CAMN CAC,DEVNAM(E)	;FOUND IT YET?
	  JRST DVTYP3		;YES, GO SAY THIS JOB HAS THE DEVICE
	ADDI E,NTABS		;UPDATE CHANNEL INDEX
	SOJGE D,DVTYP2		;LOOP BACK FOR 20 TIMES
	MOVEI C,0		;NOT FOUND RETURN 0
DVTYP3:	DPB C,[POINT 9,A,26]	;PUT IN ANSWER
	TLNE B,(1B5)		;AVAILABLE?
	TLO A,(1B12)		;YES
	TLNN B,(1B3)		;IS THIS A SPOOLED DEVICE?
	TLO A,(1B13)		;YES, SET APPROPRAITE BIT
	JRST STOTC1		;SKIP RETURN WITH ANSWER

;COMMON ROUTINE FOR DEVCHR, DEVSIZ

DVCHR1:	SETZ C,			;INITIALIZE TSS JOB #
	MOVE E,DEVTBL		;CHARACTERISTICS FOR DSK
	MOVSI B,0		;INDEX IS 0 IF DISK (SYS)
	CAMN D,[SIXBIT /SYS/]	;DEVICE SYS?
	JRST DEVC1		;YES, USE CHARS FOR DSK
	MOVE E,CONTTY		;PREPARE CONSOLE TTY BITS
	MOVSI B,(<TTY>B17+DV%AS) ;ASSIGNABLE TTY
	CAMN D,[SIXBIT /TTY/]	;THAT WHAT HE WANTS?
	JRST DEVC1		;YES. RETURN THEM
	PUSH P,D		;SAVE DEVICE NAME
	MOVEI E,BUFFER		;PLACE TO PUT ASCIZ STRING OF DEVICE
	PUSHJ P,SIXTO7
	MOVEI E,0
	MOVNI B,1		;MINUS ONE FLAG IF NOT FOUND BY DVCHR
	HRROI A,BUFFER		;ARGUMENT FOR STRING TO DEVICE
	STDEV			;GET THE DEVICE TYPE
	  JRST DEVC3		;NONE, CHECK TOPS-10 PACK
	POP P,D			;CLEAR OUT STACK
	MOVE A,B		;TO RIGHT AC
	DVCHR			;GET THE BITS
	HLRZ D,B
	ANDI D,777		;DEVICE NUMBER
	CAILE D,MAXDEV		;KNOWN DEVICE?
	MOVEI D,0		;NO, USE DSK
;**;[370] At DVCHR1: +24L, Replaced 1 line with 15	SM	 1-Oct-81
	CAIE D,.DVTTY		;[370] SPECIAL CASE IF TTY
	JRST NTTYDV		;[370] IF NOT, WE'RE OK
	DMOVEM B,DVTMP		;[370] RH C IS TTY NUMBER, FROM DVCHR
	SETO A,			;[370] SET UP TO GET OUR TTY #
	HRROI B,A		;[370] GET RESULT INTO A
	MOVEI C,.JITNO		;[370] JUST GET TTY #
	GETJI			;[370] ..
	 SETO A,		;[370] SNH. IF IT DOES, FORCE NOMATCH
	DMOVE B,DVTMP		;[370] RESTORE PROPER B & C
	CAIE A,(C)		;[370] NOW... IS IT *MY* TTY?
	JRST NTTYDV		;[370] NO. PROCEED NORMALLY
	MOVE E,CONTTY		;[370] AH HA! MY TTY, WITH A FUNNY NAME.
	MOVSI B,(<TTY>B17+DV%AS);[370] SO RETURN RIGHT BITS
	JRST DEVC1		;[370] AND LEAVE
NTTYDV:	MOVE E,DEVTBL(D)	;[370] NOT OUR TTY, GET 10/50 DEV CHRS.
	TLNE B,(1B5)		;IS THE THING AVAILABLE TO THIS JOB?
	TLOA E,40		;YES
	TRO E,1B19		;NO, MARK IT INITED BY ANOTHER JOB
	TLNE B,(1B6)		;ASSIGNED?
	TRO E,1B18		;YES. SET ASSCON IN 10/50 MODE WORD
DEVC1:	AOS 0(P)		;SKIP RETURN
DEVC2:	MOVE A,E		;CHARACTERISTICS IN A FOR
	POPJ P,0		;CALLER TO RETURN TO USER

DEVC3:	POP P,A			;GET DEVICE NAME
IFE FTFILSER,<
	JRST DEVC2		;NO DEVICE
>
IFN FTFILSER,<
	PUSHJ P,DPACHK		;SEE IF TOPS-10 PACK
	  JRST [SETZB C,E	;NO
		JRST DEVC2]
	MOVE E,DEVTBL		;YES, RETURN SAME AS DSK
	SETZB B,C
	JRST DEVC1
>

;10/50 DEVICE CHARACTERISTICS

CONTTY:	XWD 030053,400403	;BITS FOR A CONTROLLING TTY
DEVTBL:	XWD 201047,177777	;DSK A,AL,I,B,IB,DR,D (ALL MODES FOR DSK)
	XWD 0,0			;DRM
	XWD 000023,154403	;MTA DITTO DSK
	XWD 001107,154403	;DTA DITTO DSK
	XWD 000202,014403	;PTR A,AL,I,B,IB
	XWD 000401,014403	;PTP DITTO PTR
	XWD 002001,020000	;DSP ID ONLY
	XWD 040001,000403	;LPT A,AL,I
	XWD 100002,010403	;CDR A,AL,I,B
	XWD 100001,014003	;FE A,AL,B,IB
DEVTTY:	XWD 000053,000403	;TTY A,AL,I
	XWD 000013,000003	;PTY
	XWD 000053,000003	;TTR
	XWD 757777,177777	;NUL
	XWD 000047,014403	;NET
	XWD 000001,014403	;PLT
	XWD 201047,177777	;DLX A,AL,I,B,IB,DR,D (ALL MODES FOR DSK)
	XWD 100001,014003	;CDP A,AL,B,IB
	XWD 201047,177777	;DCN A,AL,I,B,IB,DR,D (ALL MODES FOR DSK)
	XWD 201047,177777	;SRV A,AL,I,B,IB,DR,D (ALL MODES FOR DSK)

MAXDEV==.-DEVTBL		;MAXIMUM KNOWN DEVICE


XLIST
LIT
LIST

;THE FOLLOWING ROUTINES ALL HAVE CONVERSIONS TO AND FROM SECONDS

RUNTIM:	MOVEI E,^D1000		;GET DESIRED UNITS IN E
	JUMPE CAC,RUNTM9	;JOB ZERO MEANS SELF
	TRZE CAC,400000		;IS THIS A REQUEST FOR HIGH PRECISION TIMING?
	  JRST RUNTMH		;YES, CAN DO THIS JOB ONLY
RUNTM0:	HRRZ A,CAC		;GET JOB NUMBER
	HRROI B,D		;GET RUNTIME FOR THIS JOB
	MOVEI C,.JIRT		;INTO AC D
	GETJI
	  MOVEI D,0		;IF ILLEGAL, ASSUME 0
	SKIPGE A,D		;IS THE JOB RUNNING?
	 MOVEI A,0		;NEGATIVE NUMBER SAYS NO SUCH JOB
RUNTM2:	MOVE C,A		;SAVE RUNTIM
	SYSGTA (<TICKPS>)	;GET TICKS PER SECOND
	EXCH A,C
	CAME C,E		;ALREADY CORRECT UNITS?
RUNTM1:	PUSHJ P,CONVRT		;NO, GO CONVERT TIME TO CORRECT UNITS
RUNTM8:	JRST STOTAC		;RETURN TO USER'S AC

RUNTM9:	MOVNI 1,5
	RUNTM			;GET RUN TIME FOR THIS JOB
	JRST RUNTM2

RUNTMH:	SKIPE CAC		;THIS JOB?
	CAMN CAC,JOB		;...
	  SKIPA A,[1]		;YES, CAN DO HPTIM JSYS
	JRST RETZER		;NO, GIVE USER 0 INTSEAD
	HPTIM			;GET MICRO SECOND TIME
	  JRST RETZER		;NOT IMPLEMENTED
	IDIVI A,12		;TURN INTO 10 MICRO SEC INTERVAL
	JRST STOTAC		;AND RETURN IT TO USER

;CONVERT TIME TO DESIRED UNITS
;CALL:	MOVE A,TIME
;	MOVE C,CURRENT UNITS
;	MOVE E,DESIRED UNITS
;	PUSHJ P,CONVRT
;	RETURN HERE WITH NEW TIME IN A

CONVRT:	FLTR E,E
	FLTR C,C
	FLTR A,A
	CAMGE C,E		;IS THE VALUE IN SMALLER UNITS THAN FINAL ANS?
	JRST CONVR3		;NO
	FDVR C,E		;DIVIDE THE LARGER FUDGE FACTOR BY THE SMALLER
CONVR2:	FDVR A,C		;NOW DIVIDE BY THE FF
	FIXR A,A
	POPJ P,

CONVR3:	FMPR A,E		;THIS RESULT SHOULD FIT
	JRST CONVR2

PJOB:	MOVE A,JOB		;GET JOB NUMBER
	JRST STOTAC		;RETURN IT TO USER

TIMER:	MOVEI E,^D60		;CLOCK TICKS (60THS) SINCE MIDNIGHT
	SETO B,			;TO REQUEST CURRENT TIME
	SETZ D,			;NORMAL FLAGS
	ODCNV
	MOVEI A,0(D)		;SECONDS SINCE MIDNIGHT
	MOVEI C,1		;UNITS (SECONDS)
	JRST RUNTM1		;NO, GO CONVERT TO PROPER UNITS AND RETURN
;**;[443]At MSTIME:+0L replace 28L with 15 lines  JYCW 6/3/86
;Since the MONITOR  rounds off to the nearest second when determining the time
;(ODCNV), we must do some guessing as to whether a round off did or did not
;occur. The millisecond from the TIME JSYS is divided by 1000 to get the ms
;part of the up time.  It's this value we use to determine whether there was a
;round off.  If it's greater or equal to 500 we assume that the MONITOR did
;round off the time (ODCNV) so we subtract 1 sec and add the ms to the time.
;If it's less than 500 we assume that there is no round off and just add the ms
;to the time.  Then we check this value against the previous base time to see
;if the calculated time is in the future.  If it's not we add back the second
;because there was no round off. 
MSTIME:	SETO B,			;[443]Now get actual time since midnight
	SETZ D,			;...
	ODCNV
	HRRZ C,D		;[443]Get the time
	IMULI C,^D1000		;[443]Convert seconds to milliseconds
	TIME			;[443]Get uptime in ms
	IDIV A,B		;[443]Convert to sec 
	MOVE A,B		;[443]remember the left over ms
	CAIL A,^D500		;[443]Round off?
	SUBI C,^D1000		;[443]Yes, sub 1 sec
	ADD A,C			;[443]Get the time in ms
	CAMGE A,ITIME		;[443]Is it greater than before?
	ADDI A,^D1000		;[443]No, add back the second
	MOVEM A,ITIME		;[443]Update the base time
	JRST STOTAC		;RETURN IT TO USER

GETPPN:	GJINF
	MOVE A,B		;DIRECTORY NUMBER AS A PPN
	PUSHJ P,PPNUNM		;GO GET PPN UNMAPPING
	JRST STOTAC		;RETURN IT


;10/50 STANDARD BUFFER SIZE FOR EACH DEVICE

DEVTB2:	EXP 200,0,200,177,40,40,0,200,33,32,20,20,20,200,100,43,20,32,200,200

;TABLE OF BITS FOR DEVTYP CALLI

DVTYPT:	400003,,0	;DSK
	0		;DRM
	7,,2		;MTA
	400003,,1	;DTA
	6,,4		;PTR
	5,,5		;PTP
	0		;DSP
	5,,7		;LPT
	2,,10		;CDR
	3,,14		;FE
	13,,3		;TTY
	13,,12		;PTY
	13,,3		;TTR
	3,,0		;NIL
	3,,14		;NET
	1,,13		;PLT
	3,,14		;DLX
	1,,11		;CDP
	3,,14		;DCN
	3,,14		;SRV

CORE:	SKIPE CAC		;0 ARG GIVES FREE CORE, ERROR RETURN
	PUSHJ P,COREUU
	SKIPA
	AOS 0(P)		;OK RETURN, R2
	MOVEI A,PATLOC		;RETURN HOW MUCH HE CAN HAVE
	TLNE PF,L.FLSR		;FILSER MAPPED IN?
	  MOVEI A,FLSRLC	;YES, GET START OF FILSER AREA INSTEAD
	LSH A,-^D10		;IN K
	JRST STOTAC		;RETURN IT IN THE AC

COREUU:	TLNN CAC,-1		;ANY CHANGE TO HIGH SEGMENT?
	JRST COREU4		;NO
	HLRZ B,CAC
	TRO B,777
	CAIL B,PATLOC		;TOO LARGE?
	  POPJ P,		;YES, GIVE ERROR RETURN
	TLNN PF,L.FLSR		;FILSER MAPPED IN?
	  JRST COREU1		;NO
	CAIL B,FLSRLC		;YES, TOO LARGE?
	  POPJ P,		;YES, GIVE ERROR RETURN
COREU1:	SKIPE C,JBHRL		;ANY HIGH SEG?
	JRST CORU1A		;YES, USE CURRENT END
	MOVE C,JBREL		;GET CURRENT LOW SEG END
	TRO C,777		;END OF PAGE
	ADDI C,1		;BEGIN NEXT
	CAIGE C,.HSLOC		;ABOVE DEFAULT
	MOVEI C,.HSLOC		;NO, USE DEFAULT
	MOVEM C,HSORG		;SET HI SEG ORIGIN
	SOS C			;LAST WORD USED
CORU1A:	CAMGE B,HSORG		;NEGATIVE HISEG LENGTH?
	JRST FLUSHI		;YES
	CAMLE B,C		;MORE THAN BEFORE?
	JRST COREU3		;YES
COREU2:	PUSH P,A		;SAVE UUO ARG
	MOVEI A,(C)		;GET OLD WORD SIZE
	PUSHJ P,SHRINK		;REMOVE PAGES IF NEEDED.
	POP P,A			;AND RESTORE AC ARG
	JRST COREU3		;ON TO CHECK LOW SEG.

FLUSHI:	HRRZ A,JBHRL		;OLD HIGH SEG SIZE
	MOVE B,HSORG
	SOS B			;NEW SIZE IS ZERO
	PUSHJ P,SHRINK		;SHRINK THE HIGH SEGMENT
	SETZ B,
COREU3:	HRRZM B,JBHRL
	XCTUU <HRRM B,.JBHRL>
	SKIPN JBHRL		;ANY HIGH SEG LEFT
	PUSHJ P,CLRHSN		;NO, CLEAR HIGH SEG NAME
COREU4:	TRNN CAC,-1		;ANY CHANGE TO LOW SEG?
	JRST CPOPJ1		;NO
CORU10:	HRRZ B,CAC
	TRO B,777
	SKIPE JBHRL		;IS THERE A HIGH SEG?
	CAMGE B,HSORG		;DOES USER WANT TO EXPAND INTO HIGH SEG?
	  SKIPA			;NO
	  POPJ P,		;DONT LET HIM OVERWRITE THE HIGH SEG.
	HRRZ C,JBREL
	CAIL B,PATLOC		;ARG OK?
	POPJ P,
	TLNN PF,L.FLSR		;FILSER MAPPED IN?
	  JRST CORU11		;NO
	CAIL B,FLSRLC		;ARG STILL OK?
	  POPJ P,		;NO, ERROR
CORU11:	HRRZM B,JBREL
	XCTUU <HRRM B,.JBREL>	;NEW .JBREL
	HRRZ B,JBREL		;NEW .JBREL
	CAIG B,(C)		;MORE THAN BEFORE?
	JRST COREU7		;NO
	JRST COREU9

COREU7:	MOVEI A,0(C)		;NEW LOW SEG
	PUSHJ P,SHRINK		;ADJUST SEGMENT SIZE
COREU9:	JRST CPOPJ1

;SHRINK A SEGMENT. A/ OLD WORDS TOP, B/ NEW WORDS TOP.
SHRINK:	JUMPE A,CPOPJ		;IN CASE OLD VALUE MISSING
	CAIG A,(B)		;OLD REALLY BIGGER?
	POPJ P,0		;NO. RETURN.
	PUSH P,A		;BE TRANSPARENT
	PUSH P,B
	PUSH P,D
	MOVEI D,(A)		;COPY OLD SIZE
	LSH D,-11		;CONVERT TO PAGE NUMBERS
	LSH B,-11
	SETO A,			;REMAP FROM NULL-SPACE
	MOVEI C,0(D)		;CALCULATE COUNT OF PAGES TO BE DELETED
	SUBI C,0(B)		;...
	TLO C,(1B0)		;DO A MULTIPLE PMAP
	HRLI B,.FHSLF		;THIS FORK
	HRRI B,1(B)		;START AT CORRECT PAGE
	PMAP			;PAGE TO REMOVE
	POP P,D			;RESTORE ACS.
	JRST BAPOPJ		;AND RETURN.

XPAND:	PUSH P,CAC		;CORE UUO WANTS ARG IN CAC
	HRRZ CAC,G		;PHONY UP A CORE UUO FOR LOW SEG.
	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSHJ P,CORU10		;EXPAND CORE TO GET IT
	PUSHJ P,ERROR		;ERROR RETURN- COULDN'T
	POP P,D
	POP P,C
	POP P,B
	POP P,CAC		;RESTORE I/O CALL CAC
	POPJ P,			;OK- ALL DONE.

SUBTTL TTCALL AND OTHER TERMINAL HANDLING UUO'S
;TTCALL UUO, DISPATCH BY AC FIELD.
;AC VALUES ARE:
;0=INCHRW 1=OUTCHR 2=INCHRS 3=OUTSTR 4=INCHWL 5=INCHSL 6=GETLCH
;7=SETLCH 10=RESCAN 11=CLRBFI 12=CLRBFO 13=SKPINC 14=SKPINL
;15=IONEOU 16=CPOPJ 17=CPOPJ

UTTCLL:	MOVE E,TYSTAT		;CARRY AROUND TTY STATUS BITS IN E
	MOVEI A,PRIJFN		;INITIALIZE JFN OF TTY
	PUSHJ P,@TTCLTB(AC)	;CALL TTCALL ROUTINE
	JRST MRETN		;NON-SKIP RETURN
	JRST MRETN2		;SKIP RETURN

TTCLTB:	EXP TTCL0,TTCL1,TTCL2,TTCL3,TTCL4,TTCL5,TTCL6,TTCL7
	EXP TTCL10,TTCL11,TTCL12,TTCL13,TTCL14,TTCL15
	EXP MRETN,MRETN		;16 AND 17 NOT IMPLEMENTED

TBOUND:	HRRZ C,FORTY		;ARG MUST NOT BE BETWEEN 20 AND 137
	CAIGE C,.JBPFI
	CAIGE C,20
	POPJ P,
	PUSHJ P,ERRARG

;TTCALL ROUTINES TO INPUT CHARACTERS

;TTCALL 0, - INPUT A CHARACTER AND WAIT (CHARACTER MODE)

TTCL0:	PUSHJ P,NOCTRO		;TURN OFF CONTROL-O
	PUSHJ P,TBOUND		;SEE IF ARGUMENTS ARE IN BOUNDS
	TLO E,TT.BKE		;BREAK ON ANYTHING
	PUSHJ P,TTPSTS		;GO SET UP NEW MODE FOR PRIMARY TTY
TTCL0A:	PUSHJ P,TTPGET		;GO GET A CHARACTER AND WAIT IF NONE
TTXIT:	UMOVEM B,@FORTY		;STORE CHARACTER INTO USER'S AREA
	POPJ P,			;AND RETURN

;TTCALL 2, - INPUT A CHARACTER AND SKIP (CHARACTER MODE)

TTCL2:	PUSHJ P,NOCTRO		;CLEAR CONTROL-O
	PUSHJ P,TBOUND		;MAKE SURE ARG IS IN BOUNDS
	TLO E,TT.BKE		;SET UP TO BREAK ON EVERYTHING
TTCL2A:	PUSHJ P,TTPSTS		;GO SET UP NEW MODE
	PUSHJ P,TTFILL		;GO PULL IN A CHARACTER IF ONE READY
	  POPJ P,		;NO CHARACTER, GIVE NON-SKIP RETURN
	AOS 0(P)		;SET UP SKIP RETURN
	JRST TTCL0A		;GO GET THE CHARACTER

;TTCALL 4, - INPUT A CHARACTER AND WAIT (LINE MODE)

TTCL4:	PUSHJ P,NOCTRO		;CLEAR CONTROL-O
	PUSHJ P,TBOUND		;SEE IF ARG IS IN BOUNDS
	TLZ E,TT.BKE		;CLEAR BREAK ON EVERYTHING FLAG
	PUSHJ P,TTPSTS		;GO SET UP NEW MODE
	JRST TTCL0A		;GO READ IN A CHARACTER

;TTCALL 5, - INPUT A CHARACTER AND SKIP (LINE MODE)

TTCL5:	PUSHJ P,NOCTRO		;CLEAR CONTROL-O FLAG
	PUSHJ P,TBOUND		;SEE IF ARG IS IN BOUNDS
	TLZ E,TT.BKE		;CLEAR BREAK ON EVERYTHING MODE
	JRST TTCL2A		;GO SEE IF A CHARACTER IS THERE

DDTIN:	HRRZ A,CAC		;GET USER BUFFER ADDRESS
	MOVEI B,21		;CHECK IT FOR BOUNDRIES
	PUSHJ P,ADRCKB		;BOTH ENDS OF THE BUFFER
	MOVEI A,PRIJFN		;DDTIN ALWAYS REFERS TO CONTROLING TTY
	MOVE E,TYSTAT		;GET STATUS OF TTY
	PUSHJ P,NOCTRO		;CLEAR CONTROL-O
	TLO E,TT.BKE		;SET BREAK ON ANYTHING
	PUSHJ P,TTPSTS		;SET STATUS FOR CONTROLING TTY
	MOVE D,CAC		;GET START OF BUFFER
	HRLI D,(POINT 7,0)	;MAKE A BYTE POINTER INTO USER BUFFER
	MOVEM D,IOBPT
	MOVEI F,21*5-1		;KEEP COUNT OF CHARACTERS STORED
DDTIN1:	PUSHJ P,TTPGET		;GET A CHARACTER
	XCTLB <IDPB B,IOBPT>	;STORE IT IN USER BUFFER
	PUSHJ P,TTFILL		;SEE IF ANY MORE
	  SKIPA			;NO
	SOJG F,DDTIN1		;YES, LOOP BACK FOR ALL CHARACTERS IN BUFFER
	MOVEI B,0		;ALWAYS CLOSE WITH A NULL
	XCTLB <IDPB B,IOBPT>
	JRST MRETN		;AND RETURN
;ROUTINES TO FILL THE INTERNAL BUFFER FOR THE CONTROLING TTY

;TTFILL - READS IN ANY WAITING CHARACTERS UP TO FIRST BREAK CHAR
;	  WILL NOT BLOCK IF THERE ARE NO CHARACTERS

TTFILL:	SKIPE TTLINE		;IS THERE A LINE IN THE BUFFER
	  JRST CPOPJ1		;YES, THEN RETURN
	TLNE E,TT.BKE!TT.BIN	;IN BREAK ON EVERYTHING MODE?
	SKIPG TTCNT		;YES, IS THERE A CHARACTER READY?
	SKIPA A,[PRIJFN]	;NO, SEE IF ONE IN MONITOR BUFFER
	  JRST CPOPJ1		;YES, SKIP RETURN
	SIBE			;ANY CHARACTERS READY TO BE READ IN
	  JRST [PUSHJ P,TTFLW0	;YES, GO READ IN ONE
		JRST TTFILL]	;AND LOOP BACK
	POPJ P,			;NO, DONT BLOCK

;TTFILW - READS IN ONE CHARACTER AND PUTS IT INTO THE INTERNAL BUFFER
;	  THIS ROUTINE WILL BLOCK IF NO CHARACTER IS READY

TTFILW:	PUSHJ P,TTFLW0		;GO WAIT FOR A CHARACTER TO BE TYPED
	PUSHJ P,TTFILL		;ANY CHARACTERS READY YET?
	  JRST TTFILW		;NO, MAY HAVE BEEN ^R, ^U, OR RUBOUT
	POPJ P,

TTFLW0:	TDNE E,[TT.BIN!TT.BKE,,IO.FCS]
	  JRST TTFLWB		;CANNOT USE RDTXT, USE BIN
	MOVE A,[PRIJFN,,PROJFN]	;SET UP FOR RDTXT JSYS
	MOVE B,TTINPT		;GET POINTER INTO BUFFER
	MOVE C,[RD%TOP!RD%RIE!RD%BRK!RD%JFN!RD%BBG+TTMAXC]
	SUB C,TTCNT		;GET NUMBER OF CHARACTERS LEFT IN BUF
	MOVE F,TTCNT		;SAVE THE COUNT FOR LATER
	TLNE E,TT.XON		;IS TTY TAPE ON?
	  TLO C,(RD%CRF)	;GET LF INSTEAD OF CR-LF
	MOVE D,[POINT 8,TTBUF]	;POINTER TO START OF BUFFER
	PUSHJ P,DORDTX		;DO THE RDTXT JSYS
	MOVNI D,-TTMAXC(C)	;GET COUNT OF CHARACTERS IN BUFFER
	HRRZM D,TTCNT		;STORE NEW COUNT
	MOVEM B,TTINPT		;SAVE NEW PUTTER POINTER
	TLNN C,(RD%BTM)		;WAS THERE A BREAK CHARACTER TYPED?
	  JRST [TRNN C,-1	;DID COUNT RUN OUT?
		 JRST TTFLW1	;YES, CAUSE BREAK
		CAME F,TTCNT	;NO, WERE ANY CHARACTERS READ IN?
		  POPJ P,	;YES, RETURN TO CALLER
		MOVEI A,PRIJFN	;NO, WAIT FOR ONE
		PUSHJ P,TTYBIN	;READ IN A CHARACTER
		BKJFN		;BACK UP OVER THIS CHAR
		  PUSHJ P,BUGSTP
		JRST TTFLW0]	;GO LET RDTXT DO ITS THING
	MOVEI A,C.CR		;SEE IF IN TTY TAPE MODE
	TLNE E,TT.XON
	  JRST [PBOUT		;ECHO CR
		DPB A,TTINPT	;CHANGE LF TO CR
		JRST .+1]
TTFLW1:	MOVEI A,PROJFN		;CLEAR CONTROL-O
	PUSHJ P,NOCTRO
	JRST TTBRK

TTFLWB:	PUSHJ P,TTYBIN		;GO DO THE BIN
	PUSHJ P,TTPUTC		;GO STORE THIS CHARACTER
	CAIE B,C.BELL		;IS THIS A BELL?
	CAIL B,175		;OR RUBOUT OR ALTMODE?
	  JRST TTBRK		;YES, THEN SET BREAK CHAR SEEN
	CAIN B,C.EOF		;IS THIS A CONTROL-Z
	  JRST TTBRK		;YES, SET BREAK
	CAIE B,C.DELL		;CONTROL-U?
	CAIN B,STDALT		;OR ALTMODE?
	  JRST TTBRK		;YES, SET BREAK
	CAIGE B,C.CR		;FORMATTING CHARACTER?
	CAIGE B,C.LF		;  NOT INCLUDING CR
	  POPJ P,		;NO, DONT SET BREAK
	JRST TTBRK		;YES, SET BREAK

;ROUTINES TO GET CHARACTERS

;TTPGET - GET A CHARACTER FROM THE CONTROLING TTY AND PERFORM CONVERSION IF DESIRED
;	  THIS ROUTINE WILL WAIT FOR A CHARACTER IF NONE THERE

TTPGET:	PUSHJ P,TTFILL		;GO SEE IF ANY CHARACTERS THERE
	  PUSHJ P,TTFILW	;NO, WAIT FOR ONE
	PUSHJ P,TTGETC		;GO GET THE CHARACTER
	TLNE E,TT.BIN!TT.ALT	;SHOULD ALTMODES BE CONVERTED?
	  POPJ P,		;NO, SO DONT
	CAIE B,ALT1		;IS IT AN ALTMODE
	CAIN B,ALT2		;OR ANOTHER ALTMODE
	  MOVEI B,STDALT	;YES, MAKE ALL ALTMODES THE SAME
	POPJ P,			;AND RETURN

TTBRK:	SETOM TTLINE		;NOW THERE IS A LINE IN MY BUFFER
	PUSH P,A		;SAVE A
	MOVE A,TTCNT		;SAVE COUNT OF CHARS IN LINE
	MOVEM A,OTTCNT		;FOR TTCALL 10 (RESCAN)
	JRST APOPJ

TTBINI:	PUSHJ P,TTYSST		;SET TTY STATUS
	MOVE A,[POINT 8,TTBUF]	;GET START OF BUFFER
	MOVEM A,TTINPT		;SET UP GETTER
	MOVEM A,TTOUPT		;AND PUTTER
	SETZM TTCNT
	SETZM TTLINE
	SETZM OTTCNT
	POPJ P,

TTGTC0:	PUSHJ P,TTFILW		;GET A CHARACTER
TTGETC:	SKIPG TTCNT		;MAKE SURE THERE IS A CHAR
	  JRST TTGTC0		;NO, GO WAIT FOR A CHARACTER
	SOS TTCNT		;COUNT DOWN COUNTER
	ILDB B,TTOUPT		;GET CHAR
	PUSH P,A		;SAVE A
	SKIPLE TTCNT		;ANY CHARACTERS LEFT?
	  JRST TTGTC1		;YES
	MOVE A,[POINT 8,TTBUF]	;INITIALIZE THE POINTERS
	MOVEM A,TTOUPT
	MOVEM A,TTINPT
	SETZM TTLINE		;NO MORE LINE IN BUFFER
TTGTC1:	TRNN E,IO.BIN		;IN BINARY MODE?
	  ANDI B,177		;NO, TRUNCATE TO 7 BITS
	JRST APOPJ		;RESTORE A AND RETURN

TTPUTC:	PUSH P,A		;SAVE A
	MOVE A,TTCNT		;GET CURRENT COUNT
	CAILE A,TTMAXC		;IS THE BUFFER FULL?
	  PUSHJ P,BUGSTP	;YES, THIS IS WORTHY OF A HALT
	IDPB B,TTINPT		;STORE CHAR IN BUFFER
	AOS A,TTCNT		;UPDATE COUNTER
	CAIL A,TTMAXC-5		;BUFFER ALMOST FULL?
	  PUSHJ P,TTBRK		;YES, PRETEND THAT A LINE IS THERE
	JRST APOPJ		;RESTORE A AND RETURN

TTCL1:	MOVEI A,PROJFN		;OUTPUT A SINGLE CHAR
	PUSHJ P,TTCLRB		;CLEAR BINARY MODE IF ON
	UMOVE B,@FORTY
	PUSHJ P,TTYBOU		;OUTPUT CHARACTER, CHECKING ^L, ^O
	POPJ P,

TTCL15:	MOVEI A,PROJFN		;OUTPUT ONE IMAGE CHARACTER.
	RFMOD			;SO SWITCH TTY TO BINARY TO DO IT.
	PUSH P,B		;SAVE PREVIOUS MODE
	TRZ B,3B29		;BINARY
	SFMOD
	UMOVE B,@FORTY		;GET USER'S CHARACTER
	PUSHJ P,TTYBO1		;SEND IT
	POP P,B			;RESTORE PREVIOUS MODE
	SFMOD			; ..
	POPJ P,

TTYBOU:				;ROUTINE TO OUTPUT A BYTE TO TTY
	CAIN A,PRIJFN		;OUTPUT TO PRIMARY INPUT SOMEHOW?
	MOVEI A,PROJFN		;YES. MAKE IT OUTPUT.
	CAIN B,C.FF		;FORMFEED?
	JRST TTYBOF		;YES. GO CHECK INDICATE FLAG
	CAIN B,STDALT		;ESCAPE (33)
	JRST TTYBOI		;YES GO SEND 33 INSTEAD OF $
	;ELSE FALL INTO OUTPUTTER
TTYBO1:	BOUT			;ORDINARY. OUTPUT IT.
	POPJ P,0		;AND RETURN
TTYBOF:	TLNN PF,L.INDF		;FORMFEED. SEND OR INDICATE?
	JRST TTYBO1		;SEND.
	HRROI B,[ASCIZ /^L
/]				;INDICATION. NOTE CLOBBERS B AND C
	MOVEI C,0		;STRING LENGTH COUNTER
	SOUT			;STRING TO TTY (JFN IN A)
	POPJ P,0		;AND RETURN
TTYBOI:	PUSH P,B		;SAVE CHARACTER
	RFMOD			;SWITCH TTY TO BINARY
	PUSH P,B		;SAVE PREVIOUS MODE
	TRZ B,3B29		;SET BINARY
	SFMOD
	MOVE B,-1(P)		;GET CHARACTER BACK
	PUSHJ P,TTYBO1		;SEND IT
	POP P,B			;GET PREVIOS MODE
	SFMOD			;RESTORE IT
	POP P,B			;REMOVE CHARACTER FROM STACK
	POPJ P,			;RETURN


;ROUTINE TO INITIALIZE TTY ON RESET OR RESTART

TTYSST:	MOVEI A,PRIJFN
	MOVE E,TYSTAT		;GET TTY FLAGS
	PUSH P,C		;SAVE AC
	PUSHJ P,TTCLRB		;CLEAR BINARY MODE FIRST
	POP P,C			;RESTORE AC
	SETOM TTWDTH		;(316)FREE CRLF NOT SET (TRMOP .TONFC)
	POPJ P,

;ROUTINE TO SET THE STATUS FOR THE TTY

;TTYSTS - ROUTINE TO CALL IF NOT THE CONTROLING TTY

TTPSTS:	CAMN E,TYSTAT		;SEE IF A CHANGE IS DESIRED IN TTY STATE
	  POPJ P,		;NO, DONT DO ANY JSYS'S
	MOVEM E,TYSTAT		;YES, STORE NEW STATUS BITS
	JRST TTYST0		;GO CHANGE THE MODE

TTYSTS:	MOVE A,JFNTAB(BB)	;GET JFN OF TTY
	TLNE E,TT.CTY		;IS THIS THE CONTROLING TTY?
	  JRST TTPSTS		;YES, GO LET THE OTHER ROUTINE DO THIS
	CAMN E,FLAGWD(BB)	;SAME AS THE LAST TIME?
	  POPJ P,		;YES, THEN THERE IS NO NEED TO CHANGE
	MOVEM E,FLAGWD(BB)	;NO, STORE NEW MODE
TTYST0:	RFMOD			;READ IN MODE OF TTY
	trz b,tm.wak!TM.ECH!tm.iod	;initialize mode word
	trnn e,io.sup		;echo on?
	  ior b,echini		;yes, set up echo mode
	tlne e,tt.bin		;binary mode desired?
	  TRZA B,TM.ATE		;(320) YES, SET BINARY MODE
	TRO B,TM.ATE		;(320) NO, SET ASCII MODE/no output translation
	tlne e,tt.bin!tt.bke	;break on everything mode?
	  tro b,tm.bke		;yes, set the correct bits
	trne e,io.fcs		;full character set?
	  tro b,tm.fcs		;yes, set break on all controls
	tro b,tm.fwk		;always set break on format controls
	sfmod			;set the mode
	tdne e,[tt.bin,,io.tec]	;want truth in echoing?
	  jrst ttyst2		;yes, go set up echo mode for this
	move b,fcoc2		;get first half of control bits
	tlne pf,l.indf		;user want to simulate form feeds
	  trc b,3b25		;no, indicate forms by ^l
	move c,fcoc3		;get other control bits
	tdnn e,[tt.bke,,io.fcs]	;want echo of ^r OR ^W?
	  tlz c,(3b1!3B11)	;NO, ^R MEANS RETYPE LINE, ^W IS WORD DEL
	tlne e,tt.xon		;user in tape mode?
	  trz c,3b27		;yes, dont echo eol
	sfcoc			;set the bits
	popj p,

ttyst2:	move b,selfec		;echo controls as self
	move c,b		;all of them
	sfcoc
	popj p,

;ECHO BYTES FOR CONTROL CHARACTERS:
; 00 MEANS IGNORE, DISCARD.
; 01 MEANS INDICATE BY ^X
; 10 MEANS SEND AND ACCT (SIM IF NECESSARY ONLY)
; 11 MEANS SIMULATE AND ACCT

;		 @,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q
FCOC2:	BYTE (2) 0,1,1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1
;		 R,S,T,U,V,W,X,Y,Z,[ \ ] ^ _
FCOC3:	BYTE (2) 1,1,1,0,1,1,1,1,1,3,1,1,1,2
SELFEC:	BYTE (2) 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2




DDTOUT:	PUSHJ P,DDTOU1		;GO DO OUTPUT
	JRST MRETN		;AND EXIT

DDTOU1:	MOVE D,CAC		;ADDRESS OF STRING TO TYPE OUT
	TLOA D,-1		;MAKE STRING POINTER, SKIP TO OUTPUT
TTCL3:	HRRO D,FORTY
	TRNN D,-20		;IN THE USERS AC'S?
	HRRI D,ACS(D)		;YES. MOVE POINTER
	MOVEI A,PROJFN		;JFN FOR "TTY"
	MOVE E,TYSTAT		;SET UP STATUS WORD FOR TTY
	PUSHJ P,TTCLRB		;CLEAR BINARY MODE IF ON

;**; INSTEAD OF DOING BOUT'S TO CHECK FOR ALTMODE AND ^L DURING
;**; AN OUTSTR, SET UP THE CCOC WORD TO DO THEM CORRECTLY AND
;**; DO A SOUT.

;**; BUT SFMOD set to TM.ATE means ^L will always come out FF on SOUT
;**; (regardless of TERM INDICATE) so pre-scan output & do BOUT loop if
;**; ^L is present

	MOVE C,D		;(324) don't clobber string ptr for later
	HRLI C,440700		;(324) scan string in bytes
	ILDB B,C		;(324) get a byte
	JUMPE B,TTCL3A		;(324) NULL means end & no ^L so use SOUT
	CAIE B,C.FF		;(324) is it an ^L?
	  JRST .-3		;(324) no, get next byte

	HRLI D,440700		;(324) string contains ^L so BOUT loop
	ILDB B,D		;(324) get a byte
	JUMPE B,CPOPJ		;(324) quit on first NULL
	PUSHJ P,TTYBOU		;(324) output, checking ^O, indicate ^L
	JRST .-3		;(324) loop till end of string

TTCL3A:				;(324)
	RFCOC			;(322) GET CCOC WORDS
	PUSH P,B		;(322) SAVE THEM ON THE STACK
	PUSH P,C		;(322)
	TRZ C,3B19		;(322) TURN OFF ALTMODE BITS
	TRO C,2B19		;(322) AND MAKE ALTMODE CODE 2 (SEND)
	TRZ B,3B25		;(322) TURN OFF ^L BITS
	TLNN PF,L.INDF		;(322) SEND OR INDICATE ^L?
	TROA B,2B25		;(322) SEND
	TRO B,1B25		;(322) INDICATE
	SFCOC			;(322) SET THE CCOC WORDS
	HRRO B,D		;(322) GET BYTE PTR TO STRING
	SETZ C,			;(322) THE STRING IS ASCIZ
	SOUT			;(322) PRINT IT
	POP P,C			;(322) RESTORE THE CCOC WORDS
	POP P,B			;(322)
	SFCOC			;(322) TO WHAT THEY USED TO BE.
	POPJ P,			;(322) RETURN

TTCL11:	MOVEI A,PRIJFN		;CLEAR INPUT BUFFER
	CFIBF
	PUSHJ P,TTBINI		;AND CLEAR MY BUFFER
	POPJ P,

TTCL12:	MOVEI A,PROJFN		;CLEAR OUTPUT BUFFER
	PUSHJ P,TTCLRB		;CLEAR BINARY MODE IF ON
	CFOBF
	POPJ P,

TTCL13:	PUSHJ P,NOCTRO		;CLEAR CONTROL O FLAG
;**;[409] At TTCL13: +1L, Inserted 3 lines                  SM 15-Mar-83
	HLRZ A,@MONUPC		;[409] FOLLOWED BY JFCL?
	CAIN A,(JFCL)		;[409] ..?
	  JRST MRETN2		;[409] YES, JUST WANTS ^O CLEARED
	MOVEI A,PRIJFN		;SKIP IF CHAR AVAIL FOR INPUT
	SKIPG TTCNT		; ANY CHAR IN MY BUFFER?
	SIBE
	JRST CPOPJ1		;YES. SKIP RETURN.
	POPJ P,			;NO


TTCL14:	PUSHJ P,NOCTRO		;CLEAR CONTROL O FLAG
;**;[409] At TTCL14: +1L, Modified 1 line                   SM 15-Mar-83
	HLRZ B,@MONUPC		;GET INSTRUCTION AFTER TTCALL 14,;[409] NO XCTUM
	CAIN B,(JFCL)		;IS THIS A CLEAR CONTROL-O CALL?
	  JRST MRETN2		;YES, JUST RETURN
	PUSHJ P,TTFILL		;NO, TRY TO GET ONE
	JFCL
	SKIPE TTLINE		;ONE THERE NOW?
	  AOS (P)		;YES, SET UP FOR SKIP RETURN
	TLNE PF,L.DBUG		;DEBUGGING?
	  POPJ P,		;YES, DONT DO RESCAN SINCE DDT EATS LINE
	JRST TTRLIN		;GO PUT ALL CHARACTERS BACK INTO RESCAN BUFFER

TTRLIN:	SKIPG C,TTCNT		;ANY CHARACTERS TO BE GOTTEN
	  POPJ P,		;NO, DONT DO ANYTHING
	MOVE D,[POINT 7,STRNG1]	;SET UP A TEMPORARY STRING
	PUSHJ P,TTGETC		;GET A CHARACTER IN B
	IDPB B,D		;STORE IT IN THE STRING
	SOJG C,.-2		;LOOP FOR ALL AVAILABLE CHARACTERS
	MOVEI B,0		;END STRING WITH NULL
	IDPB B,D
	HRROI A,STRNG1		;NOW PUT STRING IN INPUT BUFFER
	RSCAN
	  JRST TRLIN1		;OPPS, GO PUT THE LINE BACK IN INTERNAL BUFFER
	SETZ A,			;AND MAKE IT AVAILABLE TO JOB
	RSCAN
	  JFCL
	POPJ P,

TRLIN1:	MOVE D,[POINT 7,STRNG1]
TRLIN2:	ILDB B,D		;GET NEXT CHAR FROM TEMP STRING
	JUMPE B,CPOPJ		;IF ZERO, THEN WE ARE THRU
	PUSHJ P,TTPUTC		;PUT CHARACTER INTO INTERNAL BUFFER
	JRST TRLIN2		;LOOP FOR ALL CHARACTERS

TTCL6:	PUSHJ P,TBOUND
	UMOVE D,0(C)
	JUMPGE D,TTCL6A		;SPECIFIC TTY ASKED FOR
	PUSH P,A		;
	SETO A,			;(327) CHECK TO SEE IF THIS JOB IS DETACHED
;**;[433] REPLACE 2 LINES AT TTCL6:+5L	DSW	28-MAR-85
	MOVE B,[-1,,F]		;[433]DON'T RETURN JOB # IN E, GET TTY# IN F
	MOVX C,.JITNO		;[433]ALL WE WANT IS THE TTY #
	GETJI
	  JFCL			;TRY AS USUAL IF THIS FAILS
	POP P,A
	JUMPGE F,TTCL6D		;THERE IS A TTY, GO FIND OUT ABOUT IT
	SETZ C,			;DETACHED, RETURN 0 TO CALLER
	JRST TTCL6E		;
TTCL6D:	DVCHR			;GET THE TRUE POOP ON TTY
	HRLI C,0		;CLEAR LEFT HALF. JUST LINE NUMBER
TTCL6B:	CAML C,FIRPTY		;IS THIS A PTY LINE?
	  TLO C,(1B0)		;YES, REMEMBER THAT
	SKIPL TTLINE		;IS THERE A LINE NOW?
	SIBE			;OR EVEN A CHARACTER?
	  TLO C,(1B11)		;YES, MARK THAT FACT
	MOVEI A,-1		;CONTROLING TERMINAL
	RFMOD			;GET TERMINAL CHARACTERISTICS
	TRNE B,3B33		;SHUFFLE BETWEEN TOPS-20 AND 1050 BITS
	TLO C,(1B5)		;HALF DUPLEX BIT
	TLNE B,(1B2)		;TABS?
	TLO C,(1B14)		;TABS.
	TLNE B,(1B3)		;LOWERCASE?
	TRNE B,1B31		;RAISE?
	  TLZA C,(1B13)		;NO LOWERCASE
	TLO C,(1B13)		;LOWERCASE
	TLNE E,TT.XON		;PAPER TAPE MODE ON?
	  TLO C,(1B16)		;YES
	TRNE E,IO.SUP		;NO ECHO IN INIT FLAGS?
	TLO C,(1B15)		;YES.
TTCL6C:	TRO C,200000		;SET UNIVERSAL I/O INDEX #
TTCL6E:	UMOVEM C,@FORTY		;RETURN THE ANSWER TO USER
	POPJ P,			;END OF UUO

TTCL6A:	ANDI D,177777		;CLEAR UNIVERSAL I/O INDEX BITS
	DVCHR			;GET TTY CHARACTERISTICS
	HRLI C,0		;GET JUST LINE #
	CAMN C,D		;IS THIS OUR LINE BEING ASKED ABOUT
	  JRST TTCL6B		;YES
	MOVE C,D		;GET LINE # TO BE CHECKED
	CAML C,FIRPTY		;IS THIS A PTY LINE?
	  TLO C,(1B0)		;YES, REMEMBER THAT
	HRRZ A,D		;SET UP TTY DEVICE DESIGNATOR
	TRO A,400000		;...
	JRST TTCL6C		;GO GET CHARACTERISTICS

TTCL7:	PUSHJ P,TBOUND		;CHECK ARGUMENT
	RFMOD			;GET CHARACTERISTICS OF TERMINAL
	UMOVE C,0(C)		;GET USER'S DESIRED BITS
	TLNE C,(1B13)		;(346) WANT LOWER CASE?
	TRZA B,1B31		;(346) YES, CLEAR CONVERSION BIT ALSO
	TRO B,1B31		;(346) NO, SET CONVERSION FROM LOWER TO UPPER CASE
	TLNE C,(1B14)		;WANT TABS?
	  TLOA B,(1B2)		;YES
	TLZ B,(1B2)		;NO
	TLNE C,(1B15)		;WANT ECHO?
	TROA E,IO.SUP		;YES. TURN IT ON.
	TRZ E,IO.SUP		;CLEAR NO-ECHO IN INIT
	TLNE C,(1B16)		;TAPE MODE ON?
	TLOA E,TT.XON		;YES, SET FLAG IN STATUS WORD
	TLZ E,TT.XON		;NO, CLEAR FLAG
	SFMOD			;GIVE TO MONITOR
	STPAR			;SET THOSE BITS NOT CONTROLED BY SFMOD
	JRST TTPSTS		;GO SET UP NEW MODE, AND RETURN

TTCL10:	SKIPG B,OTTCNT		;WAS THERE A LINE TYPED IN?
	  JRST TCL10A		;NO, GIVE SKIP RETURN
	MOVEM B,TTCNT		;YES, SET UP TTCNT
	PUSHJ P,TTBRK		;GO SET UP TTPNT AND TTLINE
	POPJ P,

TCL10A:	SETZ A,			;DO THE RESCAN
	RSCAN			;ONLY IF FIRST TIME THROUGH
	  JFCL			;DONT CARE IF NOT IMPLEMENTED
	MOVEI A,PRIJFN		;SET UP JFN AGAIN
	PUSHJ P,TTFILL		;GO READ IN CHARACTERS IF ANY
	JFCL
	HRROI A,[0]		;NOW CLEAR THE RESCAN BUFFER
	RSCAN
	  JFCL			;DONT CARE AGAIN IF NOT IMPLEMENTED
	SKIPLE TTCNT		;ANY CHARACTERS READY
	  POPJ P,		;YES, THERE IS DATA THERE
	MOVE A,FORTY		;SEE IF USER WANTS SKIP RETURN
	TRNE A,1		;IF BIT 35 IS ON,
	  JRST CPOPJ1		; THEN SKIP RETURN
	POPJ P,


INTTY:	MOVE A,JFNTAB(BB)	;GET JFN OF TTY
	MOVE E,FLAGWD(BB)	;AND FLAGS FOR TTY
	TLNE E,TT.CTY		;IS THIS THE CONTROLING TTY
	  MOVE E,TYSTAT		;YES, GET CORRECT FLAGS
	PUSHJ P,NOCTRO		;CLEAR CONTROL-O
	TLZ E,TT.BKE		;CLEAR BREAK ON EVERYTHING
	TRNE E,IO.BIN		;IN BINARY MODE?
	  PUSHJ P,TTSETB	;YES, GO SET TT.BIN
	TRNN E,IO.BIN		;IN BINARY MODE?
	  PUSHJ P,TTCLRB	;NO, CLEAR BINARY MODE
	PUSHJ P,TTYSTS		;SET UP TTY STATUS MODE
	TLNE E,TT.CTY		;IS THIS THE CONTROLING TTY?
	  JRST INCTY		;YES, HANDLE IT SPECIALLY
	TDNE E,[TT.BIN!TT.BKE,,IO.FCS]
	  JRST INTTYB		;CANNOT USE RDTXT, USE BIN
	MOVE A,JFNTAB(BB)	;GET JFN OF TTY
	HRLS A			;IN BOTH HALVES
	MOVE B,IOBPT		;GET POINTER TO USER'S BUFFER
	MOVE C,IOCNT		;AND COUNT OF CHARACTERS IN BUFFER
	HRLI C,(RD%TOP!RD%JFN)
	PUSHJ P,DORDTX		;GO READ IN A LINE
	MOVEM B,IOBPT		;STORE UPDATED BYTE POINTER
	HRRZM C,IOCNT		;AND COUNT OF CHARACTERS LEFT IN BUFFER
	JRST INTTY9		;RETURN TO USER

INTTYB:	SOSGE IOCNT		;ANY MORE ROOM IN BUFFER
	  JRST INDON1		;NO
	MOVE A,JFNTAB(BB)	;GET JFN
	PUSHJ P,TTYBIN		;GET A CHARACTER
INTTB1:	IDPB B,IOBPT		;STORE IT IN THE BUFFER
	TLNE E,TT.BIN		;IN BINARY MODE?
	  JRST INTTB2		;YES
	CAIN B,C.EOF		;END OF FILE?
	  JRST INTTY8		;YES, GO SET EOF
INTTB2:	HRRZ A,DEVNUM(BB)	;GET UNIT NUMBER
	TRO A,400000		;MAKE TTY DEV DESIGNATOR
	SIBE			;ANY MORE CHARACTERS?
	  JRST INTTYB		;YES, GO READ THEM IN
	JRST INTTY9		;NO, RETURN TO USER

INCTY:	SOSGE IOCNT		;ANY MORE ROOM?
	  JRST INDON1		;NO
	PUSHJ P,TTPGET		;GET A CHARACTER FROM CONTROLING TTY
	IDPB B,IOBPT		;STORE IT IN BUFFER
	TLNE E,TT.BIN		;BINARY MODE
	JRST INCTY1		;YES, DONT TRANSLATE ^Z
	CAIN B,C.EOF		;CONTROL-Z?
	  JRST INTTY8		;YES, SET EOF
INCTY1:	SKIPLE TTCNT		;ANY MORE CHARACTERS
	  JRST INCTY		;YES, LOOP BACK FOR THEM
	JRST INTTY9		;NO, RETURN TO USER

DORDTX:	IJSYS (RDTXT)		;READ IN A LINE
	  PUSHJ P,BUGSTP	;ERROR, SHOULD NEVER HAPPEN
	POPJ P,			;RETURN TO CALLER

TTYBIN:	CAIN A,PROJFN		;IS IT PRIMARY OUTPUT?
	MOVEI A,PRIJFN		;YES. MAKE PRIMARY INPUT.
	SKIPE CSTFLG		;^C BEEN TYPED
	  JRST CCTRAP		;YES, DONT GO INTO INPUT WAIT
	IJSYS (BIN)		;GET THE CHAR FROM TTY
NOCTRO:	TLNN E,TT.CTY		;IS THIS THE CONTROLING TTY
	  POPJ P,		;NO, CONTROL-O NO SUPPORTED ON OTHER LINES
	PUSH P,B		;SAVE CHARACTER
	RFMOD			;GET MODE WORD
	TLZE B,(1B0)		;IS CONTROL-O IN EFFECT?
	SFMOD			;YES, CLEAR IT
	POP P,B			;RESTORE CHARACTER
	POPJ P,			;RETURN

;ASCII OUTPUT ROUTINES
OUTTTY:	LDB B,[POINT 4,FLAGWD(BB),35]	;IO MODE
	CAIL B,10		;BINARY?
	JRST OUTTTB		;YES.
	MOVE E,FLAGWD(BB)	;SET UP MODE WORD
	TLNE E,TT.CTY		;IS THIS THE CONTROLING TTY?
	  MOVE E,TYSTAT		;YES, GET CORRECT FLAG WORD
	PUSHJ P,TTCLRB		;CLEAR BINARY MODE IF ON
	TLNN E,TT.CTY		;IS THIS THE CONTROLING TTY
	  MOVEM E,FLAGWD(BB)	;NO, STORE NEW FLAG WORD
OUTTTL:	SOSGE IOCNT		;COUNT DOWN THE BYTES
	POPJ P,0		;NO MORE IN BUFFER
	XCTLB <ILDB B,IOBPT>	;GET ANOTHER BYTE FROM USER BUFFER
	SKIPE B			;DONT OUTPUT NULLS
	PUSHJ P,TTYBOU		;OUTPUT THE BYTE, CHECK ^O, INDICATE.
	JRST OUTTTL		;LOOP FOR MORE FROM BUFFER

OUTTTB:	RFMOD			;GET FILE MODE
	PUSH P,B		;SAVE IT
	TRZ B,3B29		;SET TO BINARY FOR OUTPUT
	SFMOD			; ..
OUTTBL:	SOSGE IOCNT		;COUNT OF BYTES
	JRST OUTTTX		;DONE
	XCTLB <ILDB B,IOBPT>	;GET A BYTE
	PUSHJ P,TTYBO1		;DO THE BOUT AT COMMON PC
	JRST OUTTBL		;LOOP THRU BUFFER
OUTTTX:	POP P,B			;GET BACK OLD TTY MODE
	SFMOD
	POPJ P,0

OUTASC:	SOSGE IOCNT		;COUNT BYTES
	POPJ P,			;NO MORE IN BUFFER
	XCTLB <ILDB B,IOBPT>	;FETCH BYTE FROM BUFFER, PTR IN HEADER
	JUMPE B,OUTASC		;IGNORE NULLS
	BOUT			;OUTPUT TO FILE.
	JRST OUTASC

;ROUTINES FOR SETTING AND CLEARING BINARY MODE STATE
;	CALL WITH JFN IN A

TTCLRB:	TLZN E,TT.BIN		;IN BINARY MODE?
	POPJ P,			;NO, DO NOTHING
	TLNN E,TT.CTY		;IS THIS THE CONTROLING TTY?
	  POPJ P,		;NO, DONT STORE TERMINAL INTERRUPT WORD
	PUSH P,A		;SAVE JFN
	MOVNI A,5		;FOR WHOLE JOB...
	SKIPE B,SAVTIW		;GET OLD TERMINAL INTERRUPT WORD
	STIW			;RESTORE IT
	SETZM SAVTIW		;CLEAR OLD INTERRUPT WORD
	POP P,A			;RESTORE JFN
	JRST TTPSTS		;GO SET UP NEW STATUS MODE

TTSETB:	TLOE E,TT.BIN		;BINARY MODE ALREADY IN EFFECT?
	  POPJ P,		;YES, DO NOTHING
	TLNN E,TT.CTY		;IS THIS THE CONTROLING TTY
	  POPJ P,		;DONT STORE TERMINAL INT WORD
	PUSH P,A		;SAVE JFN
	PUSHJ P,SETCCE		;ENABLE TO INTERRCEPT CONTROL C'S
	  JRST TTSTB1		;CONTROL-C ENABLING IS NOT ALLOWED
	MOVNI A,5		;GET TIW FOR WHOLE JOB
	RTIW
	MOVEM B,SAVTIW		;SAVE THIS STATE
	SETZ B,
	STIW			;TURN OFF ALL INTERRUPT WORDS
TTSTB1:	POP P,A			;RESTORE JFN
	JRST TTPSTS		;GO SET UP NEW MODE
SUBTTL	THE COMPT. UUO

;THIS UUO ALLOWS FILE WITH NAMES LONGER THAN 6 CHARACTERS TO BE
;CREATED AND READ FROM TOPS-10 PROGRAMS THROUGH THE COMPATIBILITY
;PACKAGE.
;CALLING SEQUENCE:
;	MOVE AC,[COUNT,,ADR]
;	CALLI AC,147
;	  ERROR RETURN  (AC UNCHANGED MEANS USE NORMAL FILE UUOS
;			 OTHERWISE AC CONTAINS AN ERROR CODE)
;	SUCCESSFUL RETURN

COMPT.:	HLRE C,CAC		;GET COUNT
	JUMPL C,CMPTE1		;IT MUST BE POSITIVE
	XCTUM <HRRE A,.CMPFN(CAC)>	;GET THE FUNCTION CODE
	JUMPLE A,CMPTE1		;FIRST LEGAL FUNCTION IS 1
	CAILE A,COMPTL		;SEE IF WITHIN DEFINED BOUNDS
	  JRST CMPTE1		;NO, RETURN ERROR CODE
	HLRZ B,COMPTT-1(A)	;GET REQUIRED ARGUMENT COUNT
	CAMLE B,C		;DOES USER HAVE ENOUGH ARGUMENTS?
	  JRST CMPTE1		;NO
	HRRZ A,COMPTT-1(A)	;GET DISPATCH
	JRST (A)		;AND DO SO

COMPTT:	10,,COMPT1		;FUNCTION 1, OPEN, LOOKUP, AND ENTER
	3,,COMPT2		;FUNCTION 2, RENAME
	3,,COMPT3		;FUNCTION 3, PPN TO DIRECTORY
	3,,COMPT4		;FUNCTION 4, RUN
	3,,COMPT5		;FUNCTION 5, JFNS
	2,,COMPT6		;FUNCTION 6, SET UP PSI CHANNEL
	3,,COMPT7		;FUNCTION 7, ERSTR
	1,,COMP10		;FUNCTION 10, GET JFN OF CHANNEL
	0,,COMP11		;FUNCTION 11, COMMIT SUICIDE AND RETURN
;**;[376] At COMPTT: +9L, Added 1 line          	SM	25-Jan-82
	0,,COMP12		;[376] FUN 12, LIKE 11 BUT LEAVE VEST ALONE!
	11,,COMP13		;FUNCTION 13, OPEN EXTEND (APPEND)
REPEAT 0,<			;MAY NOT BE NEEDED BY COBOL
	10,,COMP14		;FUNCTION 14, SAME AS 1 BUT WITH JFN ALREADY SET UP
	11,,COMP15		;FUNCTION 15, SAME AS 12 BUT WITH JFN ALREADY SET UP
>
	COMPTL==.-COMPTT	;END OF DEFINED FUNCTIONS

COMPT1:	XCTUM <HLRZ AC,.CMPCH(CAC)>	;GET THE CHANNEL NUMBER
	TRZN	AC,(FO.ASC)	;WANT EXTENDED CHAN?
	JRST	CMPT1X		;NO
	PUSHJ	P,GETXCH	;YES, GET ONE
	  JRST	CMPTE1		;NONE AVAILABLE
	XCTUM	<HRLM	AC,.CMPCH(CAC)>	;GIVE IT BACK TO USE
CMPT1X:	CAILE AC,MAXCHN		;CHECK IT FOR LEGALITY
	  JRST CMPTE1		;MUST BE AN AC FIELD
	UMOVE A,.CMPXF(CAC)	;GET POINTER TO LOOKUP BLOCK
	HRRM A,FORTY		;PUT IN FORTY FOR SETDAT
	PUSHJ P,SETUPG		;SET UP BB
	  TRNA			;THIS CHANNEL NOT ALREADY INITED
	PUSHJ P,URELR		;ALREADY INITED, RELEASE THIS CHANNEL
	XCTUM <HRRZ A,.CMPOM(CAC)>	;GET THE MODE
	HRRZM A,FLAGWD(BB)	;INITIALIZE FLAGS
	XCTUM <HRR A,.CMPIB(CAC)>	;GET POINTER TO INPUT BUFFER HEADER
	XCTUM <HRL A,.CMPOB(CAC)>	;GET POINTER TO OUTPUT BUFFER HEADER
	MOVEM A,BUFHTB(BB)	;STORE OBUF,,IBUF
CMPT1C:	MOVEI A,10		;ADDR+10 AND 11 ARE GTJFN RETURN LOCS
	PUSHJ P,COMPTG		;DO A GTJFN FOR USER
	  JRST [JUMPE A,MRETN	;TOPS-10 PACK
		JRST CMPTE2]	;GO RETURN ERROR CODE
	MOVEM A,JFNTAB(BB)	;SAVE JFN
	UMOVE B,.CMPG1(CAC)	;GET GTJFN BITS
	TXNE B,GJ%SHT		;SHORT OR LONG FORM?
	JRST CMPT1A		;SHORT, HAVE FLAGS
	UMOVE B,(B)		;LONG, GET FLAGS
CMPT1A:	TXNE B,GJ%OFG		;GJ%OFG? (PARSE)
	JRST CMPT1D		;IF PARSE ONLY, RETURN TO USER NOW

;Enter here from COMPT. UUO. function 13
CMPT1R:	DVCHR			;GET DEVICE DESIGNATOR
	MOVEM A,DEVNUM(BB)	;SAVE DEVICE DESIGNATOR
	PUSHJ P,UOPENF		;GO DO OPEN STUFF
	  JRST [MOVE A,JFNTAB(BB) ;ERROR, RELEASE JFN
		RLJFN
		  JFCL
		SETZM JFNTAB(BB)
		JRST MRETN]	;GIVE ERROR RETURN
	JRST CMPT1B		;DISK OR DTA
	CAIE AA,PTY		;IS IT A PTY?
	  JRST CMPT1B		;NO
	PUSHJ P,PTYSTF		;GO INITIALIZE THE PTY
	  TRNA			;ERROR
	JRST MRETN2		;OK, RETURN TO USER
	PUSHJ P,URELJ		;CLEAN UP AFTER ERROR
	JRST MRETN
CMPT1B:	HRROI A,STRNG1		;GET DEVICE NAME
	HRRZ B,JFNTAB(BB)	;GET JFN
	MOVSI C,(1B2)		;GET DEVICE NAME
	JFNS
	PUSHJ P,SEVN26		;MAKE IT SIXBIT
	MOVEM A,DEVNAM(BB)	;STORE IT FOR DEVCHR AND OTHER UUO'S
	HRROI A,STRNG1		;NOW GET EXT
	HRRZ B,JFNTAB(BB)	;FOR ENTER
	MOVSI C,(1B11)
	JFNS
	PUSHJ P,SEVN26		;GET SIXBIT EXT
	MOVEM A,EXT(BB)		;NEEDED BY ENTFIN
	TRO PF,R.UEXT		;MARK THAT THIS IS AN EXTENDED CALL
	MOVE A,JFNTAB(BB)	;GET JFN
	UMOVE G,.CMPXF(CAC)	;SET UP POINTER TO ARGUMENT BLOCK
	UMOVE B,.CMPO2(CAC)	;GET OPENF BITS
	JUMPE B,CMPT1L		;IF 0 ASSUME LOOKUP WITHOUT OPEN
	TXNN B,OF%RD		;WANT TO READ THE FILE?
	  JRST CMPT1F		;NO. GO CHECK ENTER.
	PUSHJ P,ULKOP0		;YES, GO DO LOOKUP STUFF
	 SKIPA			;ERROR DURING LOOKUP
	JRST CMPT1F		;SEE IF ENTER IS ALSO BEING DONE
	UMOVE B,.CMPO2(CAC)	;GET BACK OPENF BITS AGAIN
	TRNE B,1B20		;WANT TO ENTER FILE?
	CAIE A,OPNX2		;GOT A FILE NOT FOUND ERROR?
	JRST CMPTE2		;NO. GIVE ERROR MSG.
	JRST CMPT1G		;YES. DO OPEN ANYHOW.
CMPT1F:	UMOVE B,.CMPO2(CAC)	;GET BACK OPENF BITS.
	TXNN B,OF%WR		;WRITE?
	  JRST MRETN2		;NO, THEN ALL DONE
CMPT1G:	PUSHJ P,OPENX		;GO DO THE OPENING
	  JRST [PUSHJ P,WARN	;ERROR DURING OPEN, SEE IF OVER QUOTA
		  JRST CMPTE2	;NO, RETURN ERROR CODE TO USER
		HRRZ A,JFNTAB(BB)
		RLJFN		;RELEASE JFN
		  JFCL
		SETZM JFNTAB(BB)
		JRST CMPT1C]	;GO TRY AGAIN
;**;[436] INSERT 4 LINES AT CMPT1G:2.L	DSW	4/26/85
	MOVSI A,IOPENF+LOOKPF	;[436] FLAGS TO SET
	UMOVE B,.CMPO2(CAC)	;[436] GET BACK OPENF BITS.
	TRNE B,OF%RD		;[436] IF OPENED FOR READ,
	 IORM A,FLAGWD(BB)	;[436] SAY, LOOKUP AND OPEN DONE
	PUSHJ P,ENTFIN		;[356] Finish up processing
	  JFCL			;[356] Can not get an error return now
	JRST MRETN2		;[356] Return to the user

CMPT1D:	SETOM DEVNAM(BB)	;THIS WILL ALLOW COMPT. UUOS LATER
	JRST MRETN2		;RETURN SUCCESS

CMPT1L:	PUSHJ P,ULKOP1		;DONT OPEN JFN
	  JRST CMPTE2		;ERROR DURING OPENF
	JRST MRETN2

;**;[436] REPLACE 1 LINE AT COMPT2:+0.L	DSW	4/26/85
COMPT2:	HLLZS FORTY		;[436] NO LOOKUP BLOCK POINTER
	XCTUM <HLRZ AC,.CMPCH(CAC)>	;SET UP CHANNEL NUMBER
	CAILE AC,MAXCHN		;CHECK IT FOR LEGALITY
	JRST CMPTE1		;ILLEGAL
	PUSHJ P,SETUP		;SET UP AA AND BB
	MOVEI A,3		;ADDR+3 AND 4 ARE GTJFN RETURN LOCS
	PUSHJ P,COMPTG		;DO THE GTJFN
	  JRST [JUMPE A,MRETN	;TOPS-10 PACK
		JRST CMPTE2]	;STORE ERROR CODE
	PUSHJ P,URENAM		;GO DO THE RENAME
	  JRST CMPTE2		;FAILED
	JRST MRETN2		;SUCCESSFUL

COMPT4:	PUSHJ P,RRESET		;RESET ALL CHANNELS
	TRO PF,R.RUNU		;MARK THAT A RUN IS BEING DONE
	MOVEI A,4		;ADDR+4 AND 5 ARE GTJFN RETURN LOCS
	PUSHJ P,COMPTG		;DO GTJFN
	  JRST [JUMPE A,MRETN	;TOPS-10 PACK
		XCTUM <HLRZ B,@MONUPC>
		CAIN B,(JRST 4,) ;IS NEXT INST A HALT?
		JRST RUNFA1	;YES, GO TYPE OUT MESSAGE
		JRST CMPTE2]	;RETURN ERROR CODE
	MOVEM A,JFNTAB		;SAVE JFN
	HRROI A,STRNG1		;GET NEW PROGRAM NAME
	HRRZ B,JFNTAB
	MOVSI C,(1B8)		;JUST ITS NAME
	JFNS
	PUSHJ P,SEVN26		;TRANSLATE IT TO SIXBIT
	MOVE B,A		;PUT NAME IN B
	SETZM MTDUMP		;CLEAR OFFSET
;****** NEXT INSTRUCTION TO KEEP PROGRAMS WORKING
;****** UNTIL PAT FIGURES OUT WHAT TO DO ABOUT OFFSETS
	AOS MTDUMP		;DO START+1 IF NO OFFSET GIVEN
;******
	HLRZ C,CAC		;GET COUNT
	CAIGE C,4		;GIVING AN OFFSET?
	JRST CMPRUN		;NO, GO DO RUN
	UMOVE C,3(CAC)		;GET OFFSET
	MOVEM C,MTDUMP		;STORE OFFSET
	JRST CMPRUN		;ENTER RUN CODE

COMPTG:	MOVEM A,STRRET		;SAVE INDEX FOR RETURNING GTJFN INFO
CMPTG3:	UMOVE A,1(CAC)		;GET AC1 BITS FOR GTJFN
	TXNN A,GJ%SHT		;SHORT OR LONG FORM?
	  JRST [UMOVE A,(A)	;LONG FORM, GET FLAGS
		JRST .+1]
	TXNE A,GJ%FNS		;STRING POINTER IN AC2?
	  JRST [XCTU2 <DMOVE A,1(CAC)>	;NO, SET UP FOR STRAIGHT GTJFN
		JRST CMPTG1]		;GO DO GTJFN
	UMOVE A,2(CAC)		;GET STRING POINTER
	PUSHJ P,STPARS		;GO SET UP DECODED STRING IN STRNG1
	  PUSHJ P,CMPTG5	;ERROR PARSING, USE ORIGINAL STRING
	UMOVE A,1(CAC)		;GET AC1 BITS
	HRROI B,STRNG1		;USE TRANSLATED STRING AS MAIN STRING
CMPTG1:	GTJFN			;GET A JFN FOR THIS FILE
	  JRST [PUSHJ P,WARN	;SEE IF DIRECTORY FULL
		  JRST CMPTG2	;NO, FIXUP POINTERS AND RETURN ERROR TO USER
		JRST CMPTG3]	;YES, GO TRY AGAIN
	AOS (P)			;GIVE SUCCESSFUL RETURN WITH JFN IN A
;RETURN GTJFN STRING AND POINTER TO IT
CMPTG2:	PUSH P,A
	PUSH P,B
	PUSH P,C
	HLRZ B,CAC		;GET COUNT OF ARGS
	SUB B,STRRET		;COMPARE WITH RETURN LOC OFFSET
	CAIGE B,2		;2 ARGS TO RETURN
	JRST CMPTG4
	MOVE B,CAC
	ADD B,STRRET		;GET POINTER TO USER ARG
	UMOVE B,(B)		;GET IT
	JUMPE B,CMPTG4		;DON'T RETURN IF 0
	LDB A,-1(P)		;GET CHARACTER POINTER POINTS AT
	PUSH P,A		;SAVE IT
	SETZ A,
	DPB A,-2(P)		;CLOBBER IT TO A NULL
	MOVE A,CAC
	ADD A,STRRET		;CALC INDEX OF USERS RETURN STRING POINTER
	UMOVE A,(A)		;GET STRING POINTER
	HRROI B,STRNG1		;THIS IS STRING WE WILL RETURN
	SOUT			;ADVANCE USER POINTER TO CHARACTER IN QUESTION
	IBP A			;MAKE IT POINT AT CHARACTER
	MOVEI B,1(CAC)
	ADD B,STRRET		;WHERE TO RETURN POINTER
	UMOVEM A,(B)		;GIVE IT TO USER
	POP P,A
	DPB A,-1(P)		;PUT ORIGINAL CHAR BACK
	MOVE A,CAC
	ADD A,STRRET		;CALC INDEX OF USERS RETURN STRING POINTER
	UMOVE A,(A)		;GET STRING POINTER
	HRROI B,STRNG1
	SETZ C,
	SOUT			;THIS TIME MOVE WHOLE STRING
	MOVE B,CAC
	ADD B,STRRET
	UMOVEM A,(B)		;RETURN END OF STRING TO USER
CMPTG4:	POP P,C
	POP P,B
	POP P,A
	POPJ P,			;FIXUP POINTERS HERE LATER

CMPTE1:	MOVEI A,-1		;SET UP ERROR RETURN
CMPTE2:	LDB AC,ACPTR		;SET AC UP AGAIN
	JRST STOTAC

CMPTG5:	UMOVE A,2(CAC)		;GET USER STRING POINTER
	HRROI B,STRNG1
	SETZ C,
	SIN			;MOVE USER STRING TO BUFFER
	POPJ P,			;GO DO GTJFN WITH IT

;THIS ROUTINE PARSES A FILE NAME TYPED IN AND RETURNS A TOPS-20
;FILE SPEC IN STRING1.

;FIRST DEFINE SOME PARAMETERS

SP0==0				;STACK OFFSET FOR MAIN STRING PONTER
CNT0==-1			;COUNT OF CHARACTERS IN MIN STRING
SP1==-2				;POINTER TO STRING AFTER PPN
SPD==-3				;STRING POINTER TO DEVICE
CNTD==-4			;COUNT OF CHARACTERS IN DEVICE
DESIG==-5			;DEVICE DESIGNATOR
CELLS==6			;WORDS OF STACK SPACE NEEDED


STPARS:	TLC A,-1		;SEE IF -1 IN LEFT HALF
	TLCN A,-1
	  HRLI A,(POINT 7,0)	;YES, SET IT UP CORRECTLY
	MOVE C,A		;SAVE STRING POINTER
	MOVEI B,CELLS		;WORDS OF STACK NEEDED
	PUSH P,[0]		;RESERVE IT
	SOJG B,.-1		;GET EM ALL
	MOVEM A,SPD(P)		;SAVE POTERNTIAL DEVICE POINTER
LOKDEV:				;LOOK FO DEVICE FIELD
	ILDB B,A		;GET NEXT BYTE
	CAIN B,":"		;THIS IT?
	JRST DIRLOK		;YES. GO PROCESS IT
	SOS CNTD(P)
	JUMPN B,LOKDEV		;AT STRING END? NO. DO MORE LOOKING
	SETZM CNTD(P)		;YES. BLOT OUT DEVICE COUNT
	MOVE A,C		;AND RESTORE POINTER

;THIS CODE LOOKS FOR THE PPN OR DIRECTORY NUMBER

DIRLOK:	MOVEM A,SP0(P)		;PREFIXING STRING STRT
DIRLK:	ILDB B,A		;GET NEXT BYTE
	CAIE B,"<"		;START OF PPN FIELD?
	CAIN B,"["		;OR THIS TOO?
	JRST COPY0		;YES. GO FIND IT ALL
	JUMPE B,WHOLE		;NO; ATSTRING END?
	SOS CNT0(P)		;NO. BUMP COUNT OF THIS FILED
	JRST DIRLK		;AND GO DO MORE
COPY0:	MOVE C,[POINT 7,DIRNAM]
FND1:	ILDB B,A		;GET PPN TO STRNG2 FOR ANALYSIS
	JUMPE B,FOUND1		;IF AT END WE GOT IT
	CAIE B,">"		;FIELD TERMINATOR?
	CAIN B,"]"		;""""
	JRST FOUND		;YES. AT THE END
	CAIE B,15		;CARRAIGE RETURN AND
	CAIN B,12		;LINE FEED MAY ALSO END PPN
	JRST FND12		;
	IDPB B,C		;SAVE BYTE
	JRST FND1		;AND DO ALL OF PNNN

FND12:	ADD A,[070000,,]	;BACKUP BYTE POINTER
FOUND:	MOVEM A,SP1(P)		;SAVE TERMINATING STRING START
FOUND1:	SETZ B,
	IDPB B,C		;TIE OFF DRECTORY OR PPNM
	MOVE C,SPD(P)		;NOW GET STR:<DIR> INTO STRNG1
	MOVE B,[POINT 7,STRNG1]
FOUND2:	ILDB A,C		;GET A CHARACTER
	IDPB A,B		;STORE IT INTO STRNG1
	CAIE A,">"		;FINISHED?
	CAIN A,"]"		;...
	JRST FOUND3		;YES
	JUMPN A,FOUND2		;IF NOT NULL, LOOP BACK
FOUND3:	MOVEI A,0		;TIE OFF STRING
	IDPB A,B

;NOW ANALYZE DIR OR PPN NAME IN STRNG1 AND DETERMINE ITS TOPS-20
;DIRECTORY NUMBER

	MOVX A,RC%EMO		;NO RECOGNITION
	HRROI B,STRNG1		;GET POINTER TO STR:<DIR>
	RCDIR			;GET DIR NUMBER
	 ERJMP NODIR0		;FAILED, GO SEE IF PPN
	TXNE A,RC%NOM!RC%AMB
	JRST NODIR0		;FAILED IN ANOTHER WAY
	MOVE A,C		;GET DIR NUMBER INTO A

;WAS A LEGAL DIRECTORY. CAN BUILD FILE NAME NOW


DODIR:	MOVE B,[POINT 7,STRNG1]
	MOVE D,A		;SAVE DIR NUMBER
FAKES:	EXCH A,B		;SET UP FOR DIRST
	MOVE D,A		;SAVE BYTE POINTER
	DIRST			;GET STR:<DIR>
	 MOVE A,D		;FAILED, GET BACK STRING POINTER
	MOVE B,A		;GET STRING POINTER INTO B
	JRST WHOLE1		;SKIP NEXT DEVCPY CALL

WHOLE:	MOVE B,[POINT 7,STRNG1]
	SETZ D,			;NO DIRECTORY
	JSP E,DEVCPY		;COPY DEVICE IF NOT ALREADY DONE
WHOLE1:	MOVE A,SP0(P)		;PREFIXING STRING
	SKIPE C,CNT0(P)		;ANYTHING THERE?
	SIN			;YES. DO IT
	MOVE A,SP1(P)		;TERMINATING STRING
	JUMPE A,FNAL		;IF NONE THERE, DONE
	SETZ C,			;UNTIL THE END
	SIN
	SETZ A,
FNAL:	IDPB A,B		;FINAL CHARACTER
	MOVE A,DESIG(P)		;RETURN DEVICE DESIGNATOR
	SUB P,[CELLS,,CELLS]	;FAST POP
	JRST CPOPJ1		;AND DONE

;COPY DEVICE NAME IF PERTINENT
DEVCPY:	HRROI A,[ASCIZ /DSK/]	;DEFAULT DEVICE
	PUSH P,B
	STDEV			;GET DESIG OF DSK
	 JFCL			;MUST BE A DSK
	POP P,A
	MOVEM B,DESIG(P)	;STASH AWAY DESIGNATOR
	MOVE B,A
	SKIPN C,CNTD(P)		;A COUNT?
	JRST 0(E)		;NO. GO BACK
	SETZM CNTD(P)		;WILL BE NONE FROM NOW ON
	MOVE A,SPD(P)		;POINTER
	SIN			;COPY IT
	PUSH P,B		;SAEV B AGAIN
	SETZ A,
	IDPB A,B		;TIE OFF DEVICE STRING
	HRROI A,STRNG1
	STDEV			;GET DESIG OF THIS DEVOCE
	 JRST UHOH		;NOT A REAL DEVICE
	POP P,A
	MOVEM B,DESIG(P)	;RETURN DEVICE DEVICE DESIG
	MOVE B,A
	MOVEI A,":"		;PUT : BACK ON FOR DEVICE NAME
	IDPB A,B
	JRST 0(E)		;AND GO BACK

UHOH:	MOVE A,STRNG1		;NOT A REAL DEVICE. SEE IF SYS
	TRZ A,377		;CLEAR OUT CRUFT IN LAST CHARACTER SLOT
	CAME A,[ASCIZ /SYS/]	;WELL, IS IT?
	JRST NOSYS		;NOPE.
	POP P,B			;GET ABCK SP
	MOVE B,[POINT 7,STRNG1]	;GO BACK TO START OF BUFFER
	JUMPN D,DEVCPY		;ALREADY A DIRECTORY. JUST FAKE IT
	MOVX A,RC%EMO		;NO RECOGNITION
	MOVE D,B		;SAVE B
	HRROI B,[ASCIZ /PS:<SUBSYS>/] ;SYS IS SUBSYS BY DEFAULT
	RCDIR
	TXNE A,RC%NOM!RC%AMB	;IS IT THERE?
	MOVEI C,0		;NO
	MOVE B,D
	MOVE D,C		;DIR NUMBER TO D
	JRST FAKES		;AND FAKE OUT EVERYBODY

NOSYS:	POP P,(P)		;THROW AWAY POINTER
IFN FTFILSER,<		;DONT DO DPA'S IF NO FILSER
	SETZ A,			;COLLECT SIXBIT DEVICE NAME HERE
	MOVE B,[POINT 6,A]
	MOVE C,[POINT 7,STRNG1]
BGLOOP:	ILDB D,C		;GET  BYTE
	JUMPE D,CALIT		;IF AT THE END GO LOOK FOR DPA
	SUBI D,40		;MAKE IT SIXBIT
	IDPB D,B		;STASH IT AWAY
	TLNE B,770000		;PUT IN SIX?
	JRST BGLOOP		;NO. GO GOBBLE MORE
CALIT:	PUSHJ P,DPACHK		;SEE IF A DPA
>				;END OF FTFILSER CONDITIONAL
	SKIPA A,[0,,GJFX16]	;NO. BAD
	SETZ A,			;YES. GOOD
	SUB P,[CELLS,,CELLS]
	POPJ P,			;DONE

;WAS NOT A TOPS-20 DIRECTORY NAME. TRY A PPN

NODIR0:	PUSH P,[0]
	PUSH P,[0]		;FOR PPN STORAGE
	HRROI A,DIRNAM
	MOVEI C,10		;OCTAL NUMBERS
	NIN			;GET A NUMBER
	 JRST	[LDB B,A	;GET TERMINATOR
		 CAIE B,"-"	;DEFAULT?
		 JRST DO2	;NO, USE NULL FOR FIRST
		 IBP A		;ADVANCE OVER "-"
		 JRST DFLT]	;YES
	MOVEM B,(P)		;SAVE CONVERTED NUMBER
DO2:	LDB B,A			;GET TERMINATOR
	CAIE B,","		;LEGAL SEPERATOR?
	JRST ERR		;NO
	NIN			;NEXT NUMBER
	 CAIA			;DON'T STORE B IF NO NUMBER READ
	MOVEM B,-1(P)		;SAVE VALUE
DFLT:	LDB B,A			;GET TERMINATOR
	JUMPN B,ERR		;LOSE IF WHOLE STRING NOT EATEN
	GJINF			;GET DIR
	MOVE A,B		;CONNECTED
	PUSHJ P,PPNUNM		;CONVERT IR
	POP P,B			;GET TOP VALUE
	SKIPE B			;ANYTHING THER4?
	HRLI A,(B)		;YES. USE IT
	POP P,B			;NEXT VALUE
	SKIPE B
	HRRI A,(B)		;USE THIS IF THERE
	MOVE B,SPD(P)		;GET POINTER TO STR:<DIR>
	SKIPN CNTD(P)		;IS THERE A DEVICE STRING?
	HRROI B,[ASCIZ/DSK:/]	;NO, ASSUME DSK:
	PUSHJ P,PPN2DR		;GO GET A DIR NUMBER FROM PPN
	  JRST ERR1		;NO CONVERSION
	JRST DODIR		;MADE IT. GO OFF

ERR:	SUB P,[2,,2]
ERR1:	MOVE A,SP0(P)
	MOVEM A,SP1(P)
	SETZM CNT0(P)
	JRST WHOLE

COMPT3:	XCTUM <SKIPN A,1(CAC)>	;GET PPN IF ANY
	  JRST CMPT3A		;NONE
	CAIGE C,4		;FOR THIS DIRECTION, MUST HAVE 4 ARGS
	  JRST CMPTE1		;ELSE ARG ERROR
	UMOVE D,3(CAC)		;GET POINTER TO STR NAME STRING
	HRROI E,DEVNM7		;GET OUTPUT STRING POINTER
	PUSHJ P,SIXTO7		;CONVERT SIXBIT DEV NAME TO ASCIZ
	HRROI B,DEVNM7		;NOW CONVERT PPN TO DIR NUMBER
	UMOVE A,1(CAC)		;GET PPN AGAIN
	PUSHJ P,PPN2DR		;GET DIR NUMBER
	  JRST CMPT3E		;NONE
	MOVE B,A		;NOW TURN IT INTO A STRING
	UMOVE A,2(CAC)		;GET STRING POINTER
	DIRST
	  JRST CMPT3E		;ERROR
	UMOVEM A,2(CAC)		;STORE UPDATED STRING POINTER
	JRST MRETN2		;ALL DONE

CMPT3A:	UMOVE B,2(CAC)		;GET STRING POINTER
	MOVX A,RC%EMO		;NO RECOGNITION
	RCDIR			;GET DIR NUMBER
	 ERJMP CMPT3E		;FAILED
	TXNE A,RC%NOM!RC%AMB	;FOUND ONE?
	JRST CMPT3E		;NO
	UMOVEM B,2(CAC)		;STORE UPDATED STRING POINTER
	MOVE A,C		;GET DIR NUMBER IN A
	PUSHJ P,PPNUNM		;GET A PPN FROM DIR NUMBER
	UMOVEM A,1(CAC)		;RETURN PPN IN ARG BLOCK
	JRST MRETN2

CMPT3E:	MOVEI A,1
	JRST STOTAC		;GIVE NON-SKIP RETURN WITH ERROR 1

COMPT5:	XCTUM <HLRZ AC,0(CAC)>	;SET UP CHANNEL NUMBER
	CAILE AC,MAXCHN		;LEGAL CHANNEL NUMBER?
	  JRST CMPTE1		;NO
	PUSHJ P,SETUP		;SET UP BB AND AA
	UMOVE A,1(CAC)		;GET STRING POINTER
	SKIPG B,JFNTAB(BB)	;GET JFN
	  JRST MRETN		;NO JFN, GIVE ERROR RETURN
	HRRZS B			;CLEAR OUT WILD CARD FLAGS
	CAIE B,.PRIIN		;(343) IS IT A 100?
	CAIN B,.PRIOU		;(343) NO, IS IT A 101?
	JRST CMPT5A		;(343) YES SET UP FOR TTY
	UMOVE C,2(CAC)		;GET FLAGS
	JFNS			;DO THE JFN
	ERJMP CMPT5		;ERROR
	JRST MRETN2		;SUCCESSFUL
CMPT5:	MOVEI 1,-1
	HRLOI 2,.FHSLF
	ERSTR
	 JFCL
	 JFCL
	JRST EXIT2
CMPT5A:	HRROI B,[ASCIZ/TTY:/]	;(343)
	SETZ C,			;(343)
	SOUT			;(343)
	JRST MRETN2		;(343)


;COMPAT FUNCTION 6 - SET UP A PSI CHANNEL
;ACCEPTS IN ARG/	LEVEL # ,, LOCATION TO TRAP TO
;	    ARG+1/	PSI CHANNEL # ,, ADR OF PLACE TO STORE PC
;			ARG = 0 MEANS REMOVE PSI CHANNEL IN ARG+1

COMPT6:	XCTUM <HRRZ A,1(CAC)>	;GET TRAP ADDRESS
	PUSHJ P,ADRCHK		;MAKE SURE IT IS A LEGAL ADDRESS
	XCTUM <HRRZ A,2(CAC)>	;GET ADRESS OF PC STORAGE WORD
	PUSHJ P,ADRCHK		;CHECK IT TOO
	XCTUM <HLRZ C,2(CAC)>	;GET PSI CHANNEL NUMBER
	CAILE C,USRMXC		;IS IT LEGAL?
	 JRST RETZER		;NO, GIVE ERROR RETURN
	MOVN B,C		;SET UP MASK
	MOVSI D,400000
	LSH D,(B)
	XCTUM <HLRZ B,1(CAC)>	;GET LEVEL NUMBER
	JUMPE B,CMPT6R		;IF ZERO, REMOVE PSI CHANNEL
	CAIE B,USRLVL		;LEGAL LEVEL #
	 JRST RETZER		;NO, GIVE ERROR RETURN
	IORM D,USRMSK		;ADD THIS CHANNEL TO THOSE TURNED ON
CMPT6A:	MOVEM A,LEVTAB-1(B)	;STORE PC ADDRESS WORD
	UMOVE B,1(CAC)		;GET BACK CHNTAB WORD AGAIN
;**;[405] At CMPT6A: +2L, Modified 2 lines		 SM 17-Sep-82
	HRRZM B,UITRAP(C)	;[405] SAVE TRAP ADDRESS
;**;[432] AT CMPT6A:+3L, INSERT 4 LINES		DSW	6-MAR-85
;**;[437] AT CMPT6A:+3L, REMOVE 4 LINES, REMOVE LABEL	DSW	20-MAY-85
	HRRI B,INTUSR(C)	;[405] SET UP TRAP ADDRESS
	MOVEM B,CHNTAB(C)	;STORE IN CHNTAB
	PUSHJ P,SETPSI		;GO SET UP NEW PSI SETTINGS
	JRST MRETN2		;AND EXIT

CMPT6R:	ANDCAM D,USRMSK		;TURN OFF THIS CHANNEL
	JRST CMPT6A		;GO CLEAN UP

;COMPAT FUNCTION 7 - CONVERT ERROR NUMBER TO STRING
;ACCEPTS IN ARG+1/	DESTINATION STRING POINTER
;	    ARG+2/	COUNT,,ERROR #
COMPT7:	UMOVE A,1(CAC)		;GET STRING POINTER
	XCTUM <HRRZ B,2(CAC)>	;GET ERROR #
	HRLI B,.FHSLF		;CURRENT FORK
	XCTUM <HLLZ C,2(CAC)>	;GET COUNT
	MOVN C,C
	ERSTR
	 JRST CMPTE1		;RETURN -1 FOR NO MESSAGE
	 JFCL			;ASSUME TRUNCATED STRING, AND JUST RETURN
	UMOVEM A,1(CAC)		;RETURN UPDATED STRING POINTER
	JRST MRETN2		;SUCCESSFUL


;FUNCTION 10 - GET JFN OF A CHANNEL

COMP10:	XCTUU <HLRZ A,0(CAC)>	;GET CHANNEL #
	TRZ A,777760		;MAKE SURE IN RANGE
	CAILE A,MAXCHN		;CHECK IT FOR LEGALITY
	JRST CMPTE1		;ILLEGAL
	IMULI A,NTABS		;CONVERT TO TABLE ADDRESS
	HRRZ A,JFNTAB(A)	;GET THE JFN NOW ON THIS FILE
	JUMPE A,STOTAC		;RETURN NON-SKIP IF NULL
	JRST STOTC1		;AND SKIP IF OK.

;FUNCTION 11 & 12 - BLOW AWAY PAT. FUNCTION 11 ALLOWS A CALL TO MAKVES,
;WHICH PLAYS WITH THE JOB VESTIGAL AREA. FUNCTION 12 DOES NOT ALLOW THAT CALL.

COMP12:	TROA	PF,R.SU2!R.SUIC	;[401] FUNCTION 12
COMP11:	TRO PF,R.SUIC		;THREATEN SUICIDE
	JRST EXIT2		;PULL THE TRIGGER
;FUNCTION 13 - OPEN EXTEND (APPEND)
;THIS IS COMPT. FUNCTION 1 PLUS FILOP. FUNCTION 6

COMP13:	XCTUM <HLRZ AC,.CMPCH(CAC)>	;GET THE CHANNEL NUMBER
	TRZN AC,(FO.ASC)	;WANT EXTENDED CHAN?
	JRST CMP13X		;NO
	PUSHJ P,GETXCH		;YES, GET ONE
	  JRST CMPTE1		;NONE AVAILABLE
	XCTUM <HRLM AC,.CMPCH(CAC)>	;GIVE IT BACK TO USE
CMP13X:	CAILE AC,MAXCHN		;CHECK IT FOR LEGALITY
	UMOVE A,.CMPXF(CAC)	;GET POINTER TO LOOKUP BLOCK
	HRRM A,FORTY		;PUT IN FORTY FOR SETDAT
	PUSHJ P,SETUPG		;SET UP BB
	  TRNA			;THIS CHANNEL NOT ALREADY INITED
	 PUSHJ P,URELR		;ALREADY INITED, RELEASE THIS CHANNEL
	XCTUM <HRRZ A,.CMPOM(CAC)>	;GET THE MODE
	HRRZM A,FLAGWD(BB)	;INITIALIZE FLAGS
	XCTUM <HRR A,.CMPIB(CAC)>	;GET POINTER TO INPUT BUFFER HEADER
	XCTUM <HRL A,.CMPOB(CAC)>	;GET POINTER TO OUTPUT BUFFER HEADER
	MOVEM A,BUFHTB(BB)	;STORE OBUF,,IBUF
CMP13C:	MOVEI A,10		;ADDR+10 AND 11 ARE GTJFN RETURN LOCS
	PUSHJ P,COMPTG		;DO A GTJFN FOR USER
	  JRST [JUMPE A,MRETN	;TOPS-10 PACK
		JRST CMPTE2]	;GO RETURN ERROR CODE
	MOVEM A,JFNTAB(BB)	;SAVE JFN
	UMOVE B,.CMPG1(CAC)	;GET GTJFN BITS
	TXNE B,GJ%SHT		;SHORT OR LONG FORM?
	JRST CMP13A		;SHORT, HAVE FLAGS
	UMOVE B,(B)		;LONG, GET FLAGS
CMP13A:	TXNE B,GJ%OFG		;GJ%OFG? (PARSE)
	JRST CMPT1D		;IF PARSE ONLY, RETURN TO USER NOW
CMP13R:	DVCHR			;GET DEVICE DESIGNATOR
	MOVEM A,DEVNUM(BB)	;SAVE DEVICE DESIGNATOR
	PUSHJ P,UOPENF		;GO DO OPEN STUFF
	  JRST [MOVE A,JFNTAB(BB) ;ERROR, RELEASE JFN
		RLJFN
		  TRN
		SETZM JFNTAB(BB)
		JRST MRETN]	;GIVE ERROR RETURN
	  JRST CMP13B		;DISK OR DTA RETURNS HERE
	CAIE AA,PTY		;IS IT A PTY?
	  JRST CMP13B		;NO
	PUSHJ P,PTYSTF		;GO INITIALIZE THE PTY
	  TRNA			;ERROR
	JRST MRETN2		;OK, RETURN TO USER
	PUSHJ P,URELJ		;CLEAN UP AFTER ERROR
	JRST MRETN

CMP13B:	HRROI A,STRNG1		;GET DEVICE NAME
	HRRZ B,JFNTAB(BB)	;GET JFN
	MOVSI C,(1B2)		;GET DEVICE NAME
	JFNS
	PUSHJ P,SEVN26		;MAKE IT SIXBIT
	MOVEM A,DEVNAM(BB)	;STORE IT FOR DEVCHR AND OTHER UUO'S
	XCTUU <HRRE B,.CMPNB(CAC)>	;GET NUMBER OF INPUT BUFFERS
	JUMPE B,CMP13D		;0 INDICATES NO BUFFERS
	SKIPG B			;-1 INDICATES DEFAULT BUFFERS
	SETZ B,			;  ..
	MOVEM B,FORTY		;STORE FOR INBUF UUO
	AOS SUCNT		;MARK SIMULATED UUO
	PUSHJ P,UINBUF		;CALL INBUF UUO
CMP13D:	XCTUU <HLRE B,.CMPNB(CAC)>	;GET NUMBER OF OUTPUT BUFFERS
	JUMPE B,CMP13E		;0 INDICATES NO BUFFERS
	SKIPG B			;-1 INDICATES DEFAULT BUFFERS
	SETZ B,			;  ..
	MOVEM B,FORTY		;STORE FOR OUTBUF UUO
	AOS SUCNT		;MARK SIMULATED UUO
	PUSHJ P,UOUTBF		;CALL INBUF UUO
CMP13E:	HLRZ CC,BUFHTB(BB)	;GET BUFFER RING HEADER ADDRESS
	JUMPE CC,CMP13F		;NO BUFFER RING HEADER
	XCTUU <SKIPLE A,0(CC)>	;FIRST BUFFER ALREADY SETUP?
	JRST CMP13F		;YES, DON'T NEED TO DO IT
	TRNN A,-1		;BUFFER RING SETUP PROPERLY?
	JRST CMP13F		;NO
	XCTUU <HRRZM A,0(CC)>	;SETUP FIRST BUFFER
	PUSHJ P,INIBUF		;  ..
CMP13F:	HRROI A,STRNG1		;NOW GET EXT
	HRRZ B,JFNTAB(BB)	;FOR ENTER
	MOVSI C,(1B11)
	JFNS
	PUSHJ P,SEVN26		;GET SIXBIT EXT
	MOVEM A,EXT(BB)		;NEEDED BY ENTFIN
	TRO PF,R.UEXT		;MARK THAT THIS IS AN EXTENDED CALL
	MOVE A,JFNTAB(BB)	;GET JFN
	UMOVE G,.CMPXF(CAC)	;SET UP POINTER TO ARGUMENT BLOCK
	UMOVE B,.CMPO2(CAC)	;GET OPENF BITS
	JUMPE B,CMPT1L		;IF 0 ASSUME LOOKUP WITHOUT OPEN
	TXNN B,OF%RD		;WANT TO READ THE FILE?
	  JRST CMP13G		;NO. GO CHECK ENTER.
	PUSHJ P,ULKOP0		;YES, GO DO LOOKUP STUFF
	 TRNA			;ERROR DURING LOOKUP
	JRST CMP13G		;SEE IF ENTER IS ALSO BEING DONE
	UMOVE B,.CMPO2(CAC)	;GET BACK OPENF BITS AGAIN
	TXNE B,OF%WR		;WANT TO ENTER FILE?
	CAIE A,OPNX2		;GOT A FILE NOT FOUND ERROR?
	JRST CMPTE2		;NO. GIVE ERROR MSG.
	JRST CMP13H		;YES. DO OPEN ANYHOW.

CMP13G:	UMOVE B,.CMPO2(CAC)	;GET BACK OPENF BITS.
	TXNN B,OF%WR
	  JRST MRETN2		;NO, THEN ALL DONE
CMP13H:	PUSHJ P,OPENX		;GO DO THE OPENING
	  JRST [PUSHJ P,WARN	;ERROR DURING OPEN, SEE IF OVER QUOTA
		  JRST CMPTE2	;NO, RETURN ERROR CODE TO USER
		HRRZ A,JFNTAB(BB)
		RLJFN		;RELEASE JFN
		  TRN
		SETZM JFNTAB(BB)
		JRST CMP13C]	;GO TRY AGAIN
	MOVSI B,IOPENF!LOOKPF
	IORM B,FLAGWD(BB)	;DENOTE FILE OPEN SO CLOSE WILL REALLY CLOSE
	SKIPN AA		;IS THIS THE DISK?
	  PUSHJ P,OPNDSK	;YES, GO SET UP EOF POINTER
;**;[442] INSERT 2 LINES AT CMP13H:+12.L	DSW	8/29/85
	UMOVE A,.CMPXF(CAC)	;[442] GET BACK POINTER TO LOOKUP BLOCK
	HRRM A,FORTY		;[442] PUT IN FORTY FOR SETDAT
	PUSHJ P,ENTFIN		;Finish up processing
	  TRN			;Can not get an error return now
	AOS	SUCNT		;SO WE DON'T RETURN TO USER YET
	PUSHJ	P,FILO69	;CALL FILOP. CODE TO FILL BUFFER
	  JRST	MRETN		;Error somewhere
	JRST	MRETN2		;Return to the user

;FUNCTION 14 - SAME AS FUNCTION 1 EXCEPT JFN IS ALREADY SET UP
;ARG 1 = JFN, ARG 2 = JUNK

REPEAT 0,<			;MAY NOT BE NEEDED BY COBOL

COMP14:	XCTUM <HLRZ AC,.CMPCH(CAC)>	;GET THE CHANNEL NUMBER
	TRZN AC,(FO.ASC)	;WANT EXTENDED CHAN?
	JRST CMP14A		;NO
	PUSHJ P,GETXCH		;YES, GET ONE
	  JRST CMPTE1		;NONE AVAILABLE
	XCTUM <HRLM AC,.CMPCH(CAC)>	;GIVE IT BACK TO USE
CMP14A:	CAILE AC,MAXCHN		;CHECK IT FOR LEGALITY
	  JRST CMPTE1		;MUST BE AN AC FIELD
	UMOVE A,.CMPXF(CAC)	;GET POINTER TO LOOKUP BLOCK
	HRRM A,FORTY		;PUT IN FORTY FOR SETDAT
	PUSHJ P,SETUPG		;SET UP BB
	  TRNA			;THIS CHANNEL NOT ALREADY INITED
	 PUSHJ P,URELR		;ALREADY INITED, RELEASE THIS CHANNEL
	XCTUM <HRRZ A,.CMPOM(CAC)>	;GET THE MODE
	HRRZM A,FLAGWD(BB)	;INITIALIZE FLAGS
	XCTUM <HRR A,.CMPIB(CAC)>	;GET POINTER TO INPUT BUFFER HEADER
	XCTUM <HRL A,.CMPOB(CAC)>	;GET POINTER TO OUTPUT BUFFER HEADER
	MOVEM A,BUFHTB(BB)	;STORE OBUF,,IBUF
	UMOVE A,.CMPG1(CAC)	;GET JFN
	MOVEM A,JFNTAB(BB)	;SAVE JFN
	JRST CMPT1R		;REJOIN FUNCTION 1 CODE

;FUNCTION 15 - SAME AS FUNCTION 13 BUT WITH JFN SET UP

COMP15:	XCTUM <HLRZ AC,.CMPCH(CAC)>	;GET THE CHANNEL NUMBER
	TRZN AC,(FO.ASC)	;WANT EXTENDED CHAN?
	JRST CMP15A		;NO
	PUSHJ P,GETXCH		;YES, GET ONE
	  JRST CMPTE1		;NONE AVAILABLE
	XCTUM <HRLM AC,.CMPCH(CAC)>	;GIVE IT BACK TO USE
CMP15A:	CAILE AC,MAXCHN		;CHECK IT FOR LEGALITY
	UMOVE A,.CMPXF(CAC)	;GET POINTER TO LOOKUP BLOCK
	HRRM A,FORTY		;PUT IN FORTY FOR SETDAT
	PUSHJ P,SETUPG		;SET UP BB
	  TRNA			;THIS CHANNEL NOT ALREADY INITED
	 PUSHJ P,URELR		;ALREADY INITED, RELEASE THIS CHANNEL
	XCTUM <HRRZ A,.CMPOM(CAC)>	;GET THE MODE


	HRRZM A,FLAGWD(BB)	;INITIALIZE FLAGS
	XCTUM <HRR A,.CMPIB(CAC)>	;GET POINTER TO INPUT BUFFER HEADER
	XCTUM <HRL A,.CMPOB(CAC)>	;GET POINTER TO OUTPUT BUFFER HEADER
	MOVEM A,BUFHTB(BB)	;STORE OBUF,,IBUF
	UMOVE A,.CMPG1(CAC)	;GET JFN
	MOVEM A,JFNTAB(BB)	;SAVE JFN
	JRST CMP13R		;REJOIN FUNCTION 13 CODE
>;END REPEAT 0
;**;[432] AT ONCE:-1L, INSERT ROUTINE COMP31	DSW	6-MAR-85
;**;[437] REMOVE ROUTINE COMP31:	DSW	20-MAY-85
SUBTTL ONCE AND OTHER RARE ROUTINES

;FIRST TIME INITIALIZATION

ONCE:	MOVE A,20		;REFERENCE PAGE 0 TO CREATE IT IF NEEDED
	IFN FTDEB,<
 TMSGS	.CR,< Doing ONCE>
>
	MOVE A,[XWD TSLOC,TSLOC+1]
	SETZM -1(A)
	BLT A,CLRTOP		;AND CLEAR VARIABLE SPACE
;**;[400] At ONCE: +4L, Added 3 lines           	SM	28-Jan-82
	MOVEI	T4,TTSTI	;[400] PREPARE TO SAVE USER TTY STATE
	SKIPN	(T4)		;[400] UNLESS ALREADY DONE
	PUSHJ	P,TERSAV	;[400] OK, GOT'M!
	MOVSI PF,L.DBUG		;CLEAR ALL FLAGS BUT THIS ONE
	ANDM PF,PFLAGS		; ..
	MOVSI PF,L.ONCE		;AND SET THIS ONE, BEEN THRU ONCE CODE
	IORB PF,PFLAGS		;AND LOAD FLAGS INTO AC.
	PUSHJ P,SETPSI		;SET UP PSEUDO INTERRUPT SYSTEM
	PUSHJ P,SETJDA		;SET UP JOB DATA AREA
	PUSHJ P,SETHSN		;GO SET UP HI SEG NAME, DEV, AND PPN
	PUSHJ P,SETLSN		;SAME FOR LOW SEG
	MOVEI A,PROJFN		;CONTROLLING TERMINAL
	RFMOD			;GET STARTING ECHO CHARACTERISTICS
	ANDI B,TM.ECH		;FOR TTYSTS ROUTINE
	MOVEM B,ECHINI
	MOVSI E,TT.CTY!TT.ALT	;SET CONTROLING TTY BIT IN STATUS WORD
	RFCOC			;SEE WHAT ECHOING OF CONTROLS IS SET AT
	TRNN B,4000		;HAS USER REQUESTED ^L BE INDICATED?
	TLO PF,L.INDF		;YES. CARRY THAT DATUM AROUND IN FLAGS
	PUSHJ P,TTPSTS		;ALSO SET UP CORRECT MODE
	PUSHJ P,TTBINI		;GO INITIALIZE TTCALL BUFFER
	MOVSI A,400000		;INITIALIZE MAPLST
	ASH A,-<NIOPGS/NPLPGS-1> ;TURN ON ALL ALL AVAILABLE SLOTS
	MOVEM A,MAPLST		;STORE AVAILABLE SLOT MASK
	MOVE A,[SIXBIT/NCPGS/]	;SEE IF THIS IS A SMALL SYSTEM
	SYSGT			;GET # OF USER PAGES
	CAIG A,^D130*2		;IS THIS GREATER THAN 130 K CORE?
	TLO PF,L.SMAL		;NO, MARK THIS AS A SMALL SYSTEM
	SYSGTA (<PTYPAR>)	;GET FIRST PTY # IN TTYJOB TABLE
	HRRZM A,FIRPTY		;STORE FOR LATER USE
	MOVE A,[SIXBIT/JOBRT/]	;GET NJOBS
	SYSGT
	HLRO A,B		;LH = NEG NUMBER OF JOBS
	MOVNM A,NJOBS		;STORE NJOBS
	MOVNM A,HGHSGN
	GJINF			;GET TSS JOB #
	MOVEM C,JOB
ONCE3:	SETO B,			;NOW GET TIME SINCE MIDNIGHT
	SETZ D,			;...
	ODCNV
	MOVEI E,0(D)		;SAVE FOR FUTURE USE
;**;[443]At ONCE3:+4L replace 8 lines with 5 lines  JYCW  5/29/86
	IMULI E,^D1000		;[443]Convert seconds to milliseconds
	TIME			;[443]Get time since load
	IDIV A,B		;[443]Convert to sec
	MOVE A,B		;[443]Only want the millisecond part
	CAIL A,^D500		;[443]Was there a round off for ODCNV
	SUBI E,^D1000		;[443]Yes, subtract 1 sec
	ADD E,A			;[443]No, get actual time in milliseconds
	MOVEM E,ITIME		;STORE IT FOR USE WITH MSTIME UUO
IFN FTSTAT,<
	MOVSI A,100001		;GET THE STATISTICS FILE
	HRROI B,[ASCIZ /PA1050.STATISTICS/]
	GTJFN
	  JRST NOSTAT		;HASN'T BEEN MADE ON SYS
	PUSH P,A		;SAVE JFN
	MOVEI B,302000		;OPEN THAWED, READ, WRITE
	OPENF
	  JRST [POP P,A		;CAN'T OPEN IT. RELEASE JFN
		RLJFN		; ..
		  JFCL		;REALLY CAN'T. IGNORE.
		JRST NOSTAT]	;AND SKIP THIS
	POP P,A			;GET THE JFN
	MOVSI A,(A)		;PAGE 0 OF THE FILE
	MOVE B,[.FHSLF,,STATLP]	;STATISTICS PAGE IN THIS FORK
	MOVSI C,140000		;R/W ACCESS
	PMAP			;MAKE THEM EQUIVALENT
	HLRZS A			;GET JFN
	CLOSF			;CLOSE THE JFN
	  JFCL
	TLO PF,L.LSTA		;MARK THAT STATISTICS FILE WAS FOUND
	MOVE A,PVLOC		;LOAD UP THIS VERSION NUMBER
	MOVEM A,ST.VER+STATLC	;STORE FOR STATISTICS GATHERER
	MOVE A,[STATFW]		;GET FORMAT WORD
	MOVEM A,ST.FMT+STATLC	;STORE IN FILE
NOSTAT:	MOVSI A,100001		;GET THE STATISTICS FILE
	HRROI B,[ASCIZ /<SYSTEM>PA1050.STATISTICS/]
	GTJFN
	  JRST NOSTA1		;HASN'T BEEN MADE ON SYS
	PUSH P,A		;SAVE JFN
	MOVEI B,302000		;OPEN THAWED, READ, WRITE
	OPENF
	  JRST [POP P,A		;CAN'T OPEN IT. RELEASE JFN
		RLJFN		; ..
		  JFCL		;REALLY CAN'T. IGNORE.
		JRST NOSTA1]	;AND SKIP THIS
	POP P,A			;GET THE JFN
	MOVSI A,(A)		;PAGE 0 OF THE FILE
	MOVE B,[.FHSLF,,STATGP]	;STATISTICS PAGE IN THIS FORK
	MOVSI C,140000		;R/W ACCESS
	PMAP			;MAKE THEM EQUIVALENT
	HLRZS A			;GET JFN BACK
	CLOSF			;CLOSE IT
	  JFCL
	TLO PF,L.GSTA		;MARK THAT GLOBAL STATISTICS LILE WAS FOUND
	MOVE A,PVLOC		;GET PAT VERSION NUMBER
	MOVEM A,ST.VER+STATGC	;STORE FOR ANALYSIS PROGRAM
	MOVE A,[STATFW]		;GET FORMAT WORD
	MOVEM A,ST.FMT+STATGC	;STORE IN FILE
NOSTA1:	MOVEI A,1		;READ HIGH PRECISION CLOCK
	HPTIM			;GET RUNTIME IN MICROSECOND UNITS
	  TLZ PF,L.GSTA!L.LSTA	;NO SENSE IN DOING ANY MORE HPTIM'S
	MOVE B,A
	SUB B,STIME		;CALCULATE TIME TO DO ONCE STUFF
	MOVEM A,STIME		;DONT ADD THIS TO FIRST UUO TIME
	MOVEI A,0		;COUNT UP TIMES THAT PAT HAS BEEN STARTED
	STAT A,B,<ST.ONC>
>				;END OF STATISTICS OPENER
	MOVEM PF,PFLAGS		;STASH PF IN CORE ON EXIT FROM ONCE
	POPJ P,0		;AND RETURN FROM ONCE-ONLY ROUTINE


;**;[367] At NOSTA1: +13L, Added 60 lines      	SM	16-Sep-81

;TERMINAL SAVE/RESTORE STATES ROUTINES. ENTER /W T4 POINTING TO
;BLOCK WHERE TERM STATES ARE TO BE STORED (TERSAV) OR READ FROM (TERRES).
TERSAV:	PUSH P,E		;[367] SAVE SOME AC'S
	PUSH P,T3		;[367] ..
	PUSH P,T2		;[367] ..
	PUSH P,T1		;[367] ..
	IFN FTDEB,<
 TMSG	< Doing TERSAV:>
>
	MOVEI T1,PROJFN		;[367] READ TTY JFN MODE WORD
	RFMOD			;[367] ..
	TLZ T2,(TT%OSP)		;[367] TURN OFF ^O; WE DONT WANT IT SAVED.
	IORI T2,TT%CAR		;[367] MAKE *SURE* ITS NON-ZERO
	MOVEM T2,(T4)		;[367] AND STORE ON TOP OF BLOCK
;**;[372] At TERSAV: +9L, Added 4 lines         	SM	 2-Dec-81
	MOVEI T1,PROJFN		;[372] MUST SAVE CCOC'S AS WELL
	RFCOC			;[372] FETCH'EM
	DMOVEM T2,1(T4)		;[372] SAVE IN BLOCK+1,+2
	ADDI T4,2		;[372] AND ADVANCE POINTER INTO BLOCK
	MOVSI E,TERTLN		;[367] GET LEN OF SETTABLE/READABLES FOR LOOP
RTYLP:	ADDI T4,1		;[367] OK, NEXT WORD TO STORE
	MOVEI T1,PROJFN		;[367] DEVICE TO READ ATTRIBUTES FROM (TTY)
	HLRZ T2,TTFTAB(E)	;[367] WHICH ATTRIBUTE?
	MTOPR			;[367] READ IT
	 ERJMP .+2		;[367] QUITE UNLIKELY
	MOVEM T3,(T4)		;[367] GOT IT, NOW SAVE IT
	AOBJN E,RTYLP		;[367] NEXT, IF ANY
	POP P,T1		;[367] RESTORE AC'S
	POP P,T2		;[367] ..
	POP P,T3		;[367] ..
	POP P,E			;[367] ..
	POPJ P,			;[367] AND GO HOME

TERRES:	PUSH P,E		;[367] SAVE AC'S
	PUSH P,T3		;[367] ..
	PUSH P,T2		;[367] ..
	PUSH P,T1		;[367] ..
	IFN FTDEB,<
 TMSGS	.CR,< Doing TERRES:>
>
	MOVEI T1,PROJFN		;[367] SET UP TO RESTORE STORED STATES
	MOVE T2,(T4)		;[367] MODE WORD IN TOP OF BLOCK
;**;[372] At TERRES: +6L, Deleted 1 line        	SM	 9-Dec-81
	SFMOD			;[367] GET THE REST
	STPAR			;[367] ..
;**;[372] At TERRES: +9L, Added 4 lines         	SM	 2-Dec-81
	MOVEI T1,PROJFN		;[372] SET UP TO GET CCOC BACK
	DMOVE T2,1(T4)		;[372] FROM BLOCK+1,+2...
	SFCOC			;[372] SET!
	ADDI T4,2		;[372] AND ON TO NEXT TASK.
	MOVSI E,TERTLN		;[367] NOW SET UP TO LOOP THRU MTOPR SETS
STYLP:	ADDI T4,1		;[367] NEXT WORD IN BLOCK
	MOVEI T1,PROJFN		;[367] MAKE SURE WE HIT TTY
	HRRZ T2,TTFTAB(E)	;[367] GET FUNCTION #
	MOVE T3,(T4)		;[367] GET VALUE STORED BY TERSAV:
	MTOPR			;[367] AND SET IT
	 ERJMP .+1		;[367] FAIL RET IS UNLIKELY
	AOBJN E,STYLP		;[367] DO NEXT, IF ANY
	POP P,T1		;[367] RESTORE AC'S
	POP P,T2		;[367] ..
	POP P,T3		;[367] ..
	POP P,E			;[367] ..
	POPJ P,			;[367] ALL DONE!

;[367] THESE ARE THINGS THAT PA1050 OUGHT TO REMEMBER ON ENTRY (CALL TO TTYSAV)
;[367] AND RESTORE ON EXIT (CALL TO TERRES), ALONG WITH THE MODE WORD FOR THE
;[367] TTY. THE CODE EXPECTS THEM ALL TO TAKE/RETURN ARGS IN T3; BE CAREFUL
;[367] IN CHANGING THIS TABLE.

TTFTAB:	.MORLW,,.MOSLW		;[367] PAGE WIDTH
	.MORLL,,.MOSLL		;[367] PAGE LENGTH
	.MORNT,,.MOSNT		;[367] SYSTEM MESSAGES
	.MORFW,,.MOSFW		;[367] FIELD WIDTH
	.MORXO,,.MOXOF		;[367] END-OF-PAGE
	  TERTLN=TTFTAB-.	;[367] LENGTH OF TABLE


;DEBUG$G AFTER LOADING SETS UP SO SYSTEM'S PAT WONT BE LOADED.

DEBUG1:	TDZA A,A	;ENTRY FLAG
DEBUG:	MOVEI A,1
	MOVE P,PATSTK		;SET UP A STACK POINTER
	PUSH P,A		;SAVE ENTRY FLAG
	SETOM INPAT		;FLAG FOR UUO PROCESSOR
	MOVSI PF,L.DBUG		;SET FLAG NOT TO GRAB ^C INT
	IORB PF,PFLAGS		;IN CORE AND AC FLAG WORDS
	PUSHJ P,ONCE		;SET UP TEMP STORAGE AND PSI SYS
	PUSHJ P,SETCV		;SET COMPATIBILITY VECTOR
	SETZM INPAT		;NOT PROCESSING IN PAT NOW
	POP P,A			;GET ENTRY FLAG. FROM EXEC?
	JUMPN A,DDTLOC		;GO TO DDT
	HALTF			;YES. STOP

SETCV:	MOVEI A,.FHSLF		;THIS FORK
	MOVE B,[XWD EVECL,EVEC]	;SIZE AND LOCATION OF COMPAT VECTOR
	MOVE C,[XWD MONUUO,MONUPC] ;PLACE FOR MONITOR TO STASH UUO, PC
	SCVEC			;SET COMPATIBILITY VECTOR
	POPJ P,0		;RETURN

;ROUTINE TO SET UP JOB DATA AREA

SETJDA:	MOVEI A,140		;GIVE USER AT LEAST 140 WORDS
	HRRZM A,JBREL		;SO UMOVE .JBREL DOESNT FAIL
	UMOVE A,.JBREL
	JUMPN A,SETJD1		;SETUP?
	HRRZ A,.JBCOR		;GET JOB CORE
	JUMPN A,SETJD1		;USE THIS AS .JBREL
	PUSHJ P,HSOCHK		;COMPUTE HI SEG ORIGIN
	 JRST [	PUSHJ P,SETVES	;FOUND IT, SETUP .JBDAT FROM VESTIG
		UMOVE A,.JBREL	;SHOULD NOW HAVE GOODIES
		JRST SETJD1]
	MOVE A,[.FHSLF,,.HSLOC/1000] ;NO, IS THERE A READABLE PAGE 400?
	RPACS
	TLNE B,(1B2)
	PUSHJ P,SETVES		;YES,SETUP JOB DATA AREA FROM VESTIG
	MOVEI C,PATPAG-1	;SCAN MAP TO FIND HIGHEST USED PAGE
	TLNE PF,L.FLSR		;IS FILSER MAPPED IN?
	MOVEI C,FLSRPG-1	;YES, START AT FIRST PAGE UNDER FILSER
	MOVSI A,.FHSLF
	HRRI A,0(C)
	RPACS
	TLNN B,(1B2)		;IS PAGE READABLE?
	SOJG C,.-3		;NO
	MOVEI A,0(C)		;THIS IS HIGHEST PAGE
	LSH A,^D9
	HRRZ B,.JBCOR		;HIGHEST LOAD ADDRESS
	CAIGE A,0(B)		;MAX OF THAT AND HIGHEST PAGE
	MOVEI A,0(B)
SETJD1:	TRO A,777		;EVEN PAGES
	TLNE PF,L.FLSR		;IS FILSER MAPPED IN
	CAIGE A,FLSRLC		;YES, SEE IF FILSER IS OVERLAPPED
	CAIL A,PATLOC		;WITHIN BOUNDS
	  PUSHJ P,CORBUG	;NO, TYPE OUT MESSAGE AND HALT
	UMOVEM A,.JBREL
	HRRZM A,JBREL
	UMOVE A,JOBS41		;SAVED CONTENTS OF 41
	XCTUU <SKIPE 41>	;41 NEEDS SETUP?
	JRST SETJD2
	UMOVEM A,41		;YES
SETJD2:	XCTUU <HRRZ A,.JBHRL>
	JUMPE A,SETJD3		;SKIP SETUP IF NO HIGHSEG
	TRO A,777		;EVEN PAGE
	TLNE PF,L.FLSR		;IS FILSER MAPPED IN
	CAIGE A,FLSRLC		;YES, SEE IF FILSER IS OVERLAPPED
	CAIL A,PATLOC		;WITHIN BOUNDS
	  PUSHJ P,CORBUG	;NO, TYPE OUT MESSAGE AND HALT
	HRRZM A,JBHRL
SETJD3:	PUSHJ P,HSOCHK		;TRY TO CALC HI SEG ORIGIN
	 JFCL			;IF IT LOSES, IT LOSES
	POPJ P,

;COMPUTE BEST GUESS FOR HI SEGMENT ORIGIN
HSOCHK:	XCTUM <SKIPLE A,.JBHSO>		;[363] HIGH-SEG ORIGIN SET PROPERLY
	CAILE	A,777			;[363] AND IT COULD BE A PAGE NUMBER
	JRST HSOCK1			;NO
	LSH A,9				;YES, MAKE IT ADDRESS
	JRST HSOCK2

HSOCK1:	XCTUM <HRRZ A,.JBHRL>		;GET HI SEG END FROM LOW SEG
	JUMPE A,HSOCK3			;JUMP IF NONE
	XCTUU <HLRZ B,.JBHRL>		;GET HI SEG FREE POINTER
	SUBI A,-1(B)			;SUBTRACT FROM HI SEG END
	TRZ A,777			;FORCE PAGE BOUNDARY
HSOCK2:	CAMG A,JBREL			;IS DESIRED HI SEG ORIGIN LEGAL?
	JRST HSOCK3			;NO
	MOVEM A,HSORG			;YES, USE IT
	POPJ P,				;INDICATE BEST GUESS OK

HSOCK3:	MOVE A,JBREL			;GET END OF LOW SEG
	TRO A,777			;FORCE TO END OF PAGE
	ADDI A,1			;MAKE IT NEXT PAGE
	CAIGE A,.HSLOC			;IS IT ABOVE DEFAULT HI SEG ORIGIN?
	MOVEI A,.HSLOC			;NO, USE DEFAULT
	MOVEM A,HSORG			;STORE HI SEG ORIGIN
	JRST CPOPJ1			;INDICATE BEST GUESS FAILED

;COPY VESTIGAL JOB DATA AREA FROM HISEG TO LOSEG

SETVES:	MOVSI B,-NVSTIG
	MOVE A,HSORG
	HRLI A,B		;CONSTRUCT INDIRECT WORD HISEG(B)
SETVS0:	UMOVE C,@A
	JRST @VESTIG(B)
SETVS1:	AOBJN B,SETVS0
	XCTUM <HRRZ B,.JBHRL>
	TLNE PF,L.FLSR		;IS FILSER MAPPED IN?
	CAIGE B,FLSRLC		;YES, DONT LET IT BE OVERLAPPED
	CAIL B,PATLOC		;WITHIN BOUNDS
	  PUSHJ P,CORBUG	;NO, TYPE OUT MESSAGE AND BOMB
	HRRZM B,JBHRL
	POPJ P,

VESTIG:	[UMOVEM C,.JBSA
		JRST SETVS1]
	[UMOVEM C,41
		JRST SETVS1]
	[UMOVEM C,.JBCOR
		XCTUU <HRRZM C,.JBREL>
		JRST SETVS1]
	JRST [	XCTUU <HRRZM C,.JBREN>
		HLR C,C		;REL TOP OF HIGH SEG
		HRRI C,-1(C)	;ACCOUNT FOR EXACT MULTIPLE OF PAGE
		TRO C,777	;ROUND TO TOP OF PAGE
		ADD C,HSORG	;INCLUDE HISEG ORIGIN
		TLNE C,-1	;HAD ANYTHING?
		UMOVEM C,.JBHRL	;YES, STORE IT
		JRST SETVS1]
	[UMOVEM C,.JBVER
		JRST SETVS1]
NVSTIG==.-VESTIG

;ROUTINE TO READ IN GETJI INFO.  PASS IT GETJI AC1 ARG.  IT
;SETS UP THE REST
;SKIPS/NON-SKIPS PER GETJI.  ON NON-SKIP, GETJI STUFF IN AC1 (PRESUMABLY
;ERROR CODE)

DGETJI:	SETZM STRNG1+.JISRM	;WE DON'T WANT SESSION REMARK
	MOVE B,[-BLLEN,,STRNG1]	;TELL GETJI HOW MANY ENTRIES AND WHERE TO PUT 'EM
	MOVEI C,0		;START WITH FIRST ENTRY
	GETJI			;DO IT
	 RET			;NON-SKIP ON ERROR
	JRST CPOPJ1		;SKIP ON SUCCESS STORY

;ROUTINE WHICH SKIPS IF JOB IS IN "USER" MODE INSTEAD OF "MONITOR"
;MODE.  THIS ROUTINE ASSUMES THE GETJI DATA BLOCK HAS BEEN SET UP
;(BY CALLING DGETJI).  NO AC'S ARE CLOBBERED

SKPUSR:	SAVEAC <A,B,C,D>
	SKIPE STRNG1+.JIT20	;TOPS20 EXEC MODE?
	RET			;YES, NON-SKIP
	JRST CPOPJ1		;NO, SKIP

;SUBROUTINE SETPSI TO SET UP THE PSEUDO INTERRUPT SYSTEM, AND
; SET FOR ^O AS AN INTERRUPT.

SETPSI:	MOVEI A,.FHSLF		;THIS FORK
	DIR			;DISABLE INTERRUPT SYSTEM
	MOVE B,[XWD PSITAB,LEVTAB] ;COPY PURE TABLES TO
	SKIPN LEVTAB		; IMPURE AREA, FIRST TIME ONLY.
	BLT B,CHNTAB+^D35	;FIRST TIME. COPY IT.
;**;[437] REMOVE 9 LINES AND 2 LABELS AT SETPSI:+5L	DSW	20-MAY-85
	MOVE B,[XWD LEVTAB,CHNTAB] ;[432][437]TELL MONITOR WHERE THEY ARE
	SIR			; ..
	MOVSI A,3		;[432][437]SET UP TO ENABLE ^C IF DESIRED
	HRRI A,CCIPSN		;^C CHANNEL #
	SKIPN CCIENB		;(323) ^C interrupt enabled?
	  JRST EDONE		;(323) no
;**; if user is trapping control-C, also trap BREAK (or ATTN) key
;**; which is equivalent to a NULL
	ATI			;(323) enable ^C
;**;[374] At SETPSI: +14L, Added 1 line         	SM	 7-Dec-81
	 IFN FTBKCC,<		 ;[374] DOES USER WANT BREAK = ^C^C?
	HRLI A,.TICBK		;(323) enable BREAK (ie, NULL)
	ATI			;(323)
		    >		 ;[374] END FTBKCC COND.
EDONE:				;(323)
;**;[405] At EDONE: +1L, Inserted 2 lines                   SM 17-Sep-82
	MOVE A,[JRST USRINT]	;[405] Get routine to call on a user interrupt
	MOVEM A,UTRPPC+1	;[405] Store after the place we JSR to
	MOVEI A,.FHSLF		;THIS FORK
	MOVE B,ONCHNS		;CHANNELS ALWAYS DESIRED
	MOVE C,USRENB		;THOSE USER MAY WANT
	TRNE C,1B19		;PDL OV?
	TLO B,(1B9)		;YES
	TRNE C,1B23!1B22	;ILL MEM REF, NXM?
	TDO B,[EXP 1B16!1B17!1B18]
;	TRNE C,1B26		;CLOCK FLAG
;	TLO B,(1B14)		;TIME OF DAY? *** NOT YET IMPL
	TRNE C,1B29		;FOV?
	TLO B,(1B7)		;YES
	TRNE C,1B32		;AR OV?
	TLO B,(1B6)		;YES.
	SKIPE CCIENB		;^C INTERCEPT ENABLED
	  TRO B,1B<CCIPSN>	;YES, TURN ON THIS CHANNEL
	TDO B,USRMSK		;TURN ON CHANNELS FOR USER (COMPT. 6)
	AIC			;TURN ON THOSE CHANNELS
	ANDCA B,ALLCHN		;TURN OFF UNSELECTED ONES FROM ABOVE
	DIC			; ..
	EIR			;AND ENABLE THE INTERRUPT SYSTEM
	POPJ P,0		;RETURN FROM SETPSI

ONCHNS:	EXP <1B<CCPSIN>>!<1B<CCIPSN>>!<3B<IOCHN+1>>!1B11!1B12!1B15!1B19!1B20!1B22!<1B<TTYCHN>>	;^O,IO ERR, ILL INST, NXPAGE
;AND MASK OF ALL THAT MIGHT WANT TO BE ON
ALLCHN:	EXP <1B<CCPSIN>>!<1B<CCIPSN>>!<3B<IOCHN+1>>!77B5!1B6!1B7!1B9!1B11!1B15!7B18!1B19!1B20!1B22!<1B<TTYCHN>>
;**;[428] INSERT 3 LINES AT CLRPSI+6 (QAR 706260)
CLRPSI:	MOVEI A,.FHSLF		;THIS FORK
	CIS			;CLEAR WAITING INTS
	DIR			;DISABLE INT SYSTEM
	SETO B,			;ALL CHANNELS
	DIC			;DISABLE ALL CHANNELS
	SETZ B,			;INITIALIZE TERMINAL INTERRUPT WORD
	STIW
	MOVEI T1,.FHSLF		;[428] CLEAR UP LEVTAB AND CHNTAB
	SETZM T2		;[428]
	SIR			;[428]
CLRCCI:	MOVEI A,3		;CLEAR ^C INTERCEPT
	SKIPE CCIENB		;ONLY IF ENABLED
	  DTI
	SETZM CCIENB		;MARK THAT IT IS NOT SET
	POPJ P,0		;AND RETURN FROM CLRPSI

CLRALL:	PUSHJ P,CLRPSI		;CLEAR INTERRUPT SYSTEM
	MOVEI A,.FHSLF		;THIS FORK
	SETZB C,B		;CLEAR COMPATIBILITY VECTOR
	SCVEC			;SO WILL GET NEW ONE AFTER LOADING
				;AND NOT CONFUSE NON-1050 PROGRAMS
	POPJ P,
;**;[432] AT PSITAB:-1L, INSERT MANY LINES	DSW	6-MAR-85
;**;[437] REMOVE ROUTINE PSIFLP:	DSW	20-MAY-85

PSITAB:
				;LEVTAB
	EXP RETSAV		;STORAGE FOR CHANNEL 1 PC
	EXP LV2SAV		;STORAGE FOR LEVEL 2 PC
	0
				;CHNTAB
	0			;CHANNEL 0
	0			;CHANNEL 1
	0			;CHANNEL 2
	0			;CHANNEL 3
	0			;CHANNEL 4
	0			;CHANNEL 5
	XWD 1,OVINT		;OVERFLOW ON CHANNEL 6
	XWD 1,FOVINT		;FLOATING OVERFLOW ON CHANNEL 7
	0			;CHANNEL 8
	XWD 1,PDLINT		;PDL OVERFLOW ON CHANNEL 9
	0			;EOF ON CHANNEL 10
	XWD 1,IOERR		;IO DATA ERROR (11)
	XWD 1,QUOINT		;QUOTA EXCEEDED INTERRUPTS (12)
IOCHN==.-PSITAB-3		;PTY CHANNELS
	XWD 1,PTYINT		;CHANNEL 13 RESERVED FOR PTY HUNGRY
	XWD 1,PTYINT		;CHANNEL 14 RESERVED FOR PTY OUTPUT READY
	XWD 1,INSINT		;ILLEGAL INST, CH 15
	XWD 1,MEMINT		;CHANNEL 16 ILLEGAL READ
	XWD 1,MEMINT		;CHANNEL 17 ILLEGAL WRITE
	XWD 1,MEMINT		;CHANNEL 18 ILLEGAL EXECUTE
TTYCHN==.-PSITAB-3
	XWD 1,TTYINT		;CHANNEL 19 SUBSIDIARY FORK TERMINATION
				;TTY FORK INTERRUPTS HERE
	XWD 1,MACHSZ		;CHANNEL 20 MACHINE SIZE ERROR
	0			;CHANNEL 21 TRAP TO USER
	XWD 1,NXPINT		;CHAN 22, NONEXISTENT PAGE
	0			;CHANNEL 23
	0			;CHANNEL 24
	0			;CHANNEL 25
	0			;CAHNNEL 26
	0			;CHANNEL 27
	0			;CHANNEL 28
	0			;CHANNEL 29
	0			;CHANNEL 30
CCPSIN==.-PSITAB-3		;CHANNEL FOR REENTER HANDLER
	XWD 1,CSTART		;CHANNEL 31
CCIPSN==.-PSITAB-3		;CHANNEL 32 IS FOR ^C INTERCEPT
	XWD 1,CCIINT
	0			;CHANNEL 33
	0			;CHANNEL 34
	0			;CHANNEL 35 IS FOR WATCH; LEAVE 0
WATCHN==1B35

IFN .-PSITAB-^D36-^D3,<PRINTX PSITAB LENGTH WRONG>

SUBTTL ENVIRONMENT STUFF. SAVGET.

RUN:	PUSHJ P,RRESET		;RELEASE ALL THE CHANNELS
	TROA PF,R.RUNU		;DENOTE GETSEG, NOT RUN
GETSEG:	TRZ PF,R.RUNU		;DENOTE RUN, NOT GETSEG
	PUSHJ P,JBKSET		;SET UP JBLOCK FOR GTJFN
	PUSHJ P,REL0		;RELEASE CHANNEL 0
	HLRZM CAC,MTDUMP	;STASH THE CCL OFFSET
	UMOVE A,@PDL		;GET RETURN INSTRUCTION
	LSH A,-30		;SEE IF IT'S A HALT
	CAIN A,2542		; ..
	TRO PF,R.RHLT		;YES. REMEMBER THAT.
	MOVEI AA,1(CAC)		;POINTER TO NAME IN ARG LIST
	UMOVE D,-1(AA)		;DEVICE NAME
	MOVEM D,RUNDEV		;SAVE DEV NAME FOR LATER
	HRROI E,DEVNM7
	MOVEM E,JBLOCK+2
	CAME D,[SIXBIT /SYS/]	;PROGRAM FROM SYS?
	JRST RUN11		;NO
	TRO PF,R.SYS		;YES, REMEMBER THAT
	HRROI A,[ASCIZ/SYS/]	;SEE IF SYS IS A REAL DEV
	STDEV			;OR MAYBE A LOGICAL NAME
	  SKIPA D,[ASCIZ/PS/]	;IT IS NOT, MAKE IT PS:<SUBSYS>
	JRST RUN11		;IT IS, GO USE IT DIRECTLY
	MOVEM D,DEVNM7
	HRROI D,[ASCIZ /SUBSYS/]
	MOVEM D,JBLOCK+3
	MOVSI D,'PS '		;SET UP DEVICE NAME
	MOVEM D,RUNDEV
	MOVE D,[1,,4]		;AND PPN
	MOVEM D,RUNPPN
	JRST RUN12

RUN11:	HRLI E,(POINT 7,0)	;GET LEGAL STRING POINTER
	PUSHJ P,SIX27V		;PUT IN DEVICE NAME FROM USER
	UMOVE D,3(AA)		;PPN FROM USER
	MOVEM D,RUNPPN		;SAVE PPN
	JUMPE D,RUN11A		;SELF IF .LE. 0
	PUSHJ P,PPNMAP		;GET MAPPED DIRECTORY
	  JRST RUN11B		;NO MAPPING
	MOVE A,[POINT 7,DIRNAM]	;(352) SETUP POINTER
	PUSHJ P,GETDR1		;(352) STRIP OFF STR:, DELIMITERS
	JRST RUN11A		;(352) IF FAILURE
	MOVEM A,JBLOCK+3	;(352)STORE DIRECTORY POINTER WORD
	TRO PF,R.SYS		;MARK CAME FROM SYS DIRECTORY
	JRST RUN12		;CONTINUE...

RUN11B:	UMOVE A,-1(AA)		;GET STR NAME
	PUSHJ P,GETDIR		;GET ASCII TRANSLATION
RUN11A:	  SETZM A		;NO. TRY IN OWN DIRECTORY
	MOVEM A,JBLOCK+3	;STORE POINTER IF ANY

	;FALL THRU

RUN12:	MOVSI A,100000
	MOVEM A,JBLOCK
	UMOVE D,(AA)
	MOVEM D,RUNNAM		;SAVE NAME OF PROGRAM TO RUN
	MOVE E,[POINT 7,STRNG1]	;GET MAIN STRING
	PUSHJ P,SIX27V
	MOVEI A,"."		;FOLLOW NAME WITH A DOT
	IDPB A,E		;IN MAIN STRING
	MOVE G,E		;SAVE UPDATED STRING POINTER IN G
RUN12A:	XCTUU <HLLZ D,1(AA)>	;GET EXTENSION
	JUMPE D,RUN19		;NONE THERE- TRY DEFAULTS
	TRNN PF,R.RUNU		;GETSEG?
	JRST RUN19		;YES. IGNORE SUPPLIED EXT.
	PUSHJ P,RUN15		;USE GIVEN EXT
	  JRST RUN13		;SUCCESS- FOUND IT
	JRST RUNFAI		;FAILED, GO RETURN TO USER

;HERE FOR DEFAULT EXTENSION(S)

RUN19:	PUSHJ P,RUN10		;TRY FOR .EXE
	JRST [	TRNN PF,R.RUNU	;FOUND .EXE - GETSEG OR RUN?
		JRST RUN13	;GETSEG. JUST HIGH PART.
		PUSHJ P,SETHN1	;SET UP NEW NAME
		JRST RUN18]	;RUN. LOAD WHOLE THING.
	PUSHJ P,RUN09A		;TRY NEXT FOR .SAV
	 JRST RUN13		;FOUND A .SAV
	PUSHJ P,RUN08		;TRY TO GET EXTENSION .SHR
	  JRST RUN13		;SUCCESS
	PUSHJ P,RUN09		;NO GOOD- TRY FOR .HGH
	  JRST RUN13		;SUCCESS
RUNFAI:	XCTUM <HLRZ A,@MONUPC>	;GET INST AFTER UUO
	CAIE A,(JRST 4,)	;IS IT A HALT
	  JRST RETZER		;NO, RETURN TO USER
;**;[406] At RUNFA1:, Modified 1 line                       SM 15-Nov-82
RUNFA1:	TMSGS	.CRQ		;YES, TYPE "FILE.EXT NOT FOUND"
	HRROI A,STRNG1
	PSOUT			;TYPE OUT NAME.EXE
;**;[406] At RUNFA1: +3L, Modified 1 line                   SM 15-Nov-82
	TMSG < not found.>
	JRST EXITM1		;GO EXIT

;HERE AFTER GTJFN SUCCEEDS

RUN13:	MOVEM A,JFNTAB
	PUSHJ P,SETHN1		;SET UP NEW NAME
	TRNE PF,R.RUNU		;RUN UUO? (NOT GETSEG)
	JRST RUN23		;YES
	LDB B,[PAGEN HSORG]	;GET FIRST PAGE OF CURRENT HISEG
	MOVEI C,PATPAG	;GET COUNT OF PAGES TO BE DELETED
	TLNE PF,L.FLSR		;FILSER MAPPED IN?
	  MOVEI C,FLSRPG	;YES, GO ONLY TO START OF FILSER
	SUB C,B			;COMPUTE COUNT OF PAGES TO DELETE
	HRLI B,.FHSLF		;NOTE THIS FORK
	SETO A,
	TLO C,(1B0)		;MARK THAT THERE IS A COUNT IN THE RH OF C
	PMAP			;AWAY GOES THE HIGH SEG
	HRLI A,.FHSLF		;NOW GET THE NEW HIGH SEG INTO THIS FORK
	HRR A,JFNTAB		;CHANNEL 0 HAS JFN
	TRO A,1B19		;MARK THAT THIS IS A BOUNDED GET
	LDB B,[PAGEN HSORG]	;START AT FIRST HISEG PAGE
	HRLZ B,B
	HRRI B,PATPAG-1		;END AT PAT
	TLNE PF,L.FLSR		;FILSER MAPPED IN?
	  HRRI B,FLSRPG-1	;YES, GO ONLY TO START OF FILSER
;**;[425] MERGE 4 LINES AT RUN13+22 SPR #18040
	GET
	ERJMP [MOVEI A,ILUERR	;[425] TOPS-10 ERROR CODE
	       MOVE B,ACS(AC)	;[425] AC IN CALL TO B
	       MOVEM A,2(B)	;[425] STORE ERROR CODE
	       JRST MRETN]	;[425] NON-SKIP RETURN TO THE USER
	JRST RUN24		;OK, GO FINISH UP

RUN18:	MOVEM A,JFNTAB
RUN23:	UMOVE B,0(AA)		;GET SIXBIT PROGRAM NAME
CMPRUN:	PUSH P,B		;SAVE NEW PROGRAM NAME
	PUSH P,.JBERR		;AND ERROR COUNT
	PUSHJ P,CLRCOR		;CLEAR CURRENT CORE IMAGE
	MOVE A,JFNTAB		;GET JFN OF PROGRAM TO BE RUN AGAIN
	HRLI A,.FHSLF		;CURRENT FORK, THIS JFN
	TRO A,1B19		;DO A BOUNDED GET
	MOVEI B,PATPAG-1	;FROM 0 TO PAT
	TLNE PF,L.FLSR		;FILSER MAPPED IN?
	  MOVEI B,FLSRPG-1	;YES, GO ONLY TO START OF FILSER
;**;[425] MERGE 4 LINES AT CMPRUN+10 SPR #18040
	GET
	ERJMP [MOVEI A,ILUERR	;[425] TOPS-10 ERROR CODE
	       MOVE B,ACS(AC)	;[425] AC IN CALL TO B
	       MOVEM A,2(B)	;[425] STORE ERROR CODE
	       JRST MRETN]	;[425] NON-SKIP RETURN TO THE USER
	MOVEI A,.FHSLF		;THIS FORK
	GEVEC			;GET ENTRY VECTOR
	HLRZ A,B		;GET LEFT HALF
	CAIN A,(JRST)		;IS THIS A TOPS10 STYLE ENTRY VECTOR?
	  JRST RUN23A		;YES, DONT SET .JBSA
	XCTUU <HRRM B,.JBSA>	;STORE STARTING ADDRESS
RUN23A:	POP P,.JBERR		;RESTORE ERROR COUNT
	POP P,A			;NAME OF PROGRAM
	MOVEM A,LOWNAM		;SAVE THE NEW PROGRAM NAME
	MOVE B,A		;START WITH SAME NAME FOR BOTH
	TRNN PF,R.SYS		;FROM SUBSYS DIRECTORY?
	MOVE A,[SIXBIT/(PRIV)/]	;NO, SET SUBSYS NAME TO PRIV
	SETSN			;YES. UPDATE SYSTEM TABLES
	  JFCL			;IGNORE ERROR RETURN
	PUSHJ P,CHKRHN		;GO CLEAR HIGH SEG NAME IF NONE
;**;[434] REMOVE 3 LINES, LEAVING LABEL, AT RUN24:	DSW	4/11/85
RUN24:	TRNE PF,R.RUNU		;[434]WAS THIS A RUN UUO?
	JRST RUN21		;YES
	MOVE B,HSORG		;ALLOW ACCESSING OF VESTIGAL AREA
	ADDI B,10
	HRRZM B,JBHRL		;FOR FOLLOWING UMOVE
	MOVE B,HSORG
	UMOVE B,3(B)		;GET NEW HISEG LENGTH
	HLR B,B
;V(347)	HRRI B,-1(B)		;ACCOUNT FOR EXACT MULTIPLE OF PAGE LENGTH
	TRO B,777		;ROUND TO PAGE
	ADD B,HSORG
	TLNN B,-1		;IS NON-0?
	SETZ B,			;NO
	HRRZM B,JBHRL
	UMOVEM B,.JBHRL
	JRST RUN14

RUN21:	PUSHJ P,SETJDA		;SET UP LOW CORE STUFF
RUN14:	HRRZ A,JBHRL		;GET HIGH SEG CORE ASSIGNMENT
	SKIPN A			;IF NONE CLEAR HIGH SEG NAME
	PUSHJ P,CLRHSQ		;CLEAR THE HIGH SEG NAME QUIETLY
	SETZ BB,
	PUSHJ P,UREL2		;RELEASE CHANNEL 0
	MOVEI A,.FHSLF		;NOTIFY EXEC OF NAME CHANGE
	MOVEI B,WATCHN
	IIC			;WE WONT GET INTERRUPT SINCE CHANNEL NOT ON
	TRNN PF,R.RUNU		;WAS IT A RUN UUO?
	JRST MRETN2		;RETURN SKIPPING FROM GETSEG
	MOVE A,RUNDEV		;SET UP USER ACS
	MOVEM A,ACS+11		;DEVICE NAME
	MOVE A,RUNNAM
	MOVEM A,ACS+0		;PROGRAM NAME
	MOVE A,RUNEXT
	MOVEM A,ACS+17		;EXTENTION
	MOVE A,RUNPPN
	MOVEM A,ACS+7		;PPN
	UMOVE A,.JBSA		;RUN GOES OFF TO PROG START ADR
	ADD A,MTDUMP		;PLUS USER'S CCL OFFSET
	UMOVEM A,.JBSA		;UPDATE .JBSA BY OFFSET
				;;;IF OFFSET OVER 1, MEDDLING...
	HRRZM A,(P)
	JRST MRETN

RUN08:	MOVSI D,(SIXBIT/SHR/)
	JRST RUN15
RUN09:	MOVSI D,(SIXBIT/HGH/)
	JRST RUN15
RUN09A:	MOVSI D,(SIXBIT/SAV/)
	JRST RUN15
RUN10:	MOVSI D,(SIXBIT/EXE/)
RUN15:	MOVE E,G		;GET MAIN STRING POINTER
	PUSHJ P,SIX27V
	MOVEI A,JBLOCK
	HRROI B,STRNG1		;STRNG1 HAS FILE.EXT TO BE RUN
	GTJFN
	  JRST CPOPJ1		;FAILED, GO TRY OTHER EXTENSIONS
	POPJ P,			;SUCCESSFULLY GOT JFN

RUN20:	SETZ BB,
	PUSHJ P,UREL2		;RELEASE CHANNEL 0
	JRST MRETN		;TAKE ERROR EXIT

CLRCOR:	SETO A,			;CLEAR CORE IMAGE
	MOVSI B,.FHSLF
	TLNE PF,L.FLSR		;FILSER MAPPED IN?
	  SKIPA C,[PM%CNT+FLSRPG]	;YES, FROM 0 TO 577
	MOVE C,[PM%CNT+PATPAG]	;FROM 0 TO 677
	PMAP
	POPJ P,

SETHSN:	SETZM SEGNAM		;INIT NAME
	SETZM SEGDEV
	SETZM SEGPPN
	SKIPN JBHRL
	POPJ P,
	LDB A,[PAGEN HSORG]
	MOVE B,A
	LDB C,[PAGEN JBHRL]
	SUBI B,1(C)
	HRL A,B			;MAKE AOBJN POINTER FOR PAGES
	PUSHJ P,GETSN		;GET NAME,DEV,PPN FROM PAGES
	MOVEM A,SEGNAM
	MOVEM B,SEGDEV
	MOVEM C,SEGPPN
	POPJ P,

SETLSN:	LDB A,[PAGEN JBREL]
	MOVNI A,1(A)
	HRLZ A,A
	PUSHJ P,GETSN
	MOVEM A,LOWNAM
	MOVEM B,LOWDEV
	MOVEM C,LOWPPN
	POPJ P,

GETSN:	PUSH P,[0]
	PUSH P,[0]
	PUSH P,[0]
GETSN1:	PUSH P,A
	HRLI A,.FHSLF		;CHECK READ ACCESS OF HIGH SEG
	RPACS
	TLNE B,(1B5)		;PAGE EXIST?
	TLNE B,(1B10)		;PRIVATE PAGE?
	JRST GETSN2		;NOT FILE PAGE, TRY NEXT
	RMAP			;REMAP PAGE TO GET ITS HANDLE
	CAMN A,[-1]		;UNACCESSIBLE?
	JRST GETSN2		;YES
	HLRZ F,1		;GET HANDLE
	MOVSI C,1000		;GET NAME OF HIGH SEG
	PUSHJ P,GTHSNS		;  USING THE JFNS JSYS
	MOVEM A,-1(P)		;STORE FOR RETURN
	MOVSI C,100000		;GET DEVICE
	PUSHJ P,GTHSNS		;  USING JFNS
	MOVEM A,-2(P)		;STORE DEVICE NAME
	MOVE C,[1B2!1B5!1B35]	;GET STR:<DIR>
	MOVE B,F		;...
	HRROI A,STRNG1		;INTO STRNG1
	JFNS
	 ERJMP GETSN2
	MOVX A,RC%EMO		;CONVERT DIRECTORY TO NUMBER
	HRROI B,STRNG1		; INSTEAD OF STRING
	RCDIR
	 ERJMP GETSN2
	TXNE A,RC%NOM!RC%AMB	;FOUND ONE?
	JRST GETSN2		;LOSE
	MOVE A,C		;YES, GET DIR NUMBER INTO A
	PUSHJ P,PPNUNM		;GET UNMAPPING OF PPN
	MOVEM A,-3(P)		;STORE PPN (I.E. DIRECTORY #)
	POP P,(P)		;WIN, FLUSH AOBJN POINTER
GETSN3:	POP P,A			;NAME
	POP P,B			;DEV
	POP P,C			;PPN
	POPJ P,

GETSN2:	POP P,A
	AOBJN A,GETSN1
	JRST GETSN3

CHKRHN:	LDB A,[PAGEN HSORG]
	HRLI A,.FHSLF		;CHECK READ ACCESS OF HIGH SEG
	RPACS
	TLNE B,(1B5)		;PAGE EXIST?
	TLNE B,(1B10)		;YES, PRIVATE?
	JRST CLRHSQ		;NO PAGE OR PRIVATE
	POPJ P,			;LEAVE NAME AS IS

SETHN1:	PUSH P,A		;SAVE ALL ACS USED
	UMOVE A,0(AA)		;GET SIXBIT NAME FROM USER CALL
	MOVEM A,SEGNAM		;STORE IT
	TRNE PF,R.RUNU		;RUN UUO? (NOT GETSEG)
	MOVEM A,LOWNAM		;STORE IT
	UMOVE A,-1(AA)		;GET DEVICE FROM WHENCE IT CAME
	MOVEM A,SEGDEV		;STORE DEV
	TRNE PF,R.RUNU		;RUN UUO? (NOT GETSEG)
	MOVEM A,LOWDEV		;STORE DEV
	UMOVE A,3(AA)		;GET PPN THAT USER USED
	MOVEM A,SEGPPN		;SAVE IT TOO
	TRNE PF,R.RUNU		;RUN UUO? (NOT GETSEG)
	MOVEM A,LOWPPN		;SAVE IT TOO
	JRST APOPJ		;RESTORE ACS AND RETURN

CLRHSQ:	TDZA C,C		;DONT TELL WATCHERS ABOUT THIS
CLRHSN:	MOVE C,SEGNAM		;SAVE CURRENT NAME
	SETZM SEGNAM		;CLEAR HIGH SEG NAME
	SETZM SEGDEV		;AND HIGH SEG DEVICE
	SETZM SEGPPN		;AND PPN
	MOVEI A,.FHSLF		;IF NAME CHANGED INFORM WATCHERS
	MOVEI B,WATCHN
	SKIPE C			;BUT ONLY IF THERE WAS A HIGH SEG BEFORE
	  IIC
	POPJ P,			;AND RETURN

;CALLI 0 RESET HANDLER

RESET:
IFN FTFILSER,<
	TLNE PF,L.FLSR		;HAS FILSER BEEN LOADED?
	  PUSHJ P,TRESET	;YES, GO CLEAN UP OPEN FILES
>
	PUSHJ P,RRESET		;RESET ALL CHANNELS WITHOUT CLOSING
	JRST MRETN		;ALL DONE

;ROUTINE TO RESET EVERYTHING WITHOUT CLOSING OPENED FILES

RRESET:	SETZB AC,BB		;SET UP TO RELEASE ALL JFNS
RS3:	SKIPG A,JFNTAB(BB)	;IS THERE A JFN FOR THIS CHANNEL?
	  JRST RS2		;NO
	HRRZS A			;ONLY WANT RIGHT HALF OF JFN
	CAIE A,PRIJFN		;PRIMARY JFN?
	CAIN A,PROJFN
	  JRST RS2		;YES, DONT CARE ABOUT THESE
	SKIPE MAPTAB(BB)	;IS THERE A PAGE MAPPED?
	  PUSHJ P,UNMAPP	;YES, UNMAP THE PAGE
RS2:	ADDI BB,NTABS		;STEP TO NEXT CHANNEL
	CAIGE AC,MAXCHN		;DONE ALL OF THEM?
	  AOJA AC,RS3		;NO,LOOP BACK TILL DONE
	MOVE A,[CZ%ABT!.FHSLF]	;NOW CLOSE ALL FILES
	CLZFF			;DELETING ALL FILES BEING CREATED
	MOVE 1,[XWD CHTABS,CHTABS+1]
	SETZM -1(1)
	BLT 1,CHTEND-1		;CLEAR FILE DATA AREA
	XCTUU <HLRZ A,.JBSA>
	XCTUU <MOVEM A,.JBFF>
	PUSHJ P,TTYSST		;GO SET TTY STATUS
	PJRST SETPSI		;SET UP THE PSI SYSTEM & RETURN
;ROUTINE TO SIMULATE RESDV UUO

RESDV:	JUMPL CAC,RETM1		;NEGATIVE CHANNEL IS ILLEGAL
	CAILE CAC,MAXCHN	;CHECK FOR LEGAL CHANNEL #
	JRST RETM1		;NOT LEGAL, RETURN -1
	MOVE BB,CAC
	IMULI BB,NTABS		;GET INDEX INTO DEVICE TABLES
	SKIPG A,JFNTAB(BB)	;IS THERE A FILE OPEN HERE?
	JRST RESDV1		;NO
	SKIPE MAPTAB(BB)	;ANY MAPPED PAGES HERE?
	PUSHJ P,UNMAPP		;YES, GO UNMAP THEM
	MOVX A,CZ%ABT		;NOW CLOSE AND ABORT THE FILE
	HRR A,JFNTAB(BB)	;GET JFN BACK
	CLOSF
	 HRRZ A,JFNTAB(BB)	;FAILED, TRY TO RELEASE THE JFN
	RLJFN
	 JFCL
RESDV1:	SETZM CHTABS(BB)	;NOW ZERO THE STORAGE AREA
	HRLI A,CHTABS(BB)	;NOW SET UP THE BLT
	HRRI A,CHTABS+1(BB)
	BLT A,CHTABS+NTABS-1(BB)
	JRST MRETN2		;AND GIVE THE SUCCESS RETURN

IRESET:	PUSHJ P,CLRUFD		;CLEAR UFD JFN IF SAVED
	SETZM USRENB		;CLEAR USER-REQUESTED INTERRUPTS
	PUSHJ P,SETPSI		;AND ADJUST PSI SYSTEM ACCORDINGLY
	MOVEI A,PRIJFN		;SET UP JFN FOR TTY
	MOVE E,TYSTAT		;AND MODE
	PUSHJ P,NOCTRO		;CLEAR CONTROL-O FLAG
	MOVEI BB,NTABS		;CHANNEL 1
	MOVEI AC,1		;PUT CHANNEL # IN AC
	PUSHJ P,URELR		;RELEASE IT
	ADDI BB,NTABS
	CAIE BB,20*NTABS
	AOJA AC,.-3		;NEXT CHANNEL
REL0:	SETZB BB,AC		;CHANNEL 0
	PUSHJ P,URELR		;RELEASE IT
	POPJ P,

CLRUFD:	SKIPN A,LSTUFJ		;IS THERE A SAVED UFD JFN
	  POPJ P,		;NO
	HRRZS A			;YES, RELEASE IT
	RLJFN
	JFCL
	SETZM LSTUFJ		;CLEAR SAVED JFN
	POPJ P,

;CLOSE COMMAND

CLSCMD:	MOVEM 17,ACS+17		;SAVE ALL ACS
	MOVEI 17,ACS
	BLT 17,ACS+16
	SETOM INPAT		;ACS NOW SAVED
	MOVE P,PATSTK		;GET PUSH DOWN LIST
	HLLZ PF,PFLAGS		;AND FLAGS
	SKIPE CAC,CLSDEV	;ANY SPECIFIC DEV TO CLOSE?
	  JRST CLSCM1		;YES, GO DO IT
	PUSHJ P,IRESET		;NO, CLOSE THEM ALL
	JRST CLSDON		;AND CLEAN UP

CLSCM1:	SETZB AC,BB		;INIT ACS
CLSCM2:	HRRZ B,JFNTAB(BB)	;GET THE JFN
	CAME CAC,B		;IS THIS THE JFN TO BE CLOSED?
	CAMN CAC,DEVNAM(BB)	;OR IS THIS A DEV TO BE CLOSED
	  PUSHJ P,URELR		;YES, GO CLOSE IT
	ADDI BB,NTABS		;INCREMENT INDEX
	CAIGE AC,MAXCHN		;CHECKED ALL CHANNELS?
	  AOJA AC,CLSCM2	;NO, LOOP BACK
CLSDON:	MOVEM PF,PFLAGS		;SAVE FLAGS
	MOVSI 17,ACS		;AND THEN RESTORE ACS
	BLT 17,17
	SETZM INPAT		;AND LEAVE PAT
	HALTF


;ROUTINE TO DO A -5 TYPE OF CLOSE - JUST UNMAP THE FILE PAGES
;	AND SET THE EOF PROPERLY
;THIS ROUTINE IS CALLED BY THE EXEC

UNMCMD:	MOVEM 17,ACS+17		;SAVE ALL ACS
	MOVEI 17,ACS
	BLT 17,ACS+16
	SETOM INPAT		;ACS NOW SAVED
	MOVE P,PATSTK		;GET PUSH DOWN LIST
	HLLZ PF,PFLAGS		;AND FLAGS
	SETZB AC,BB		;SET UP FILE ACS
UNMCM1:	PUSHJ P,UNMAPP		;UNMAP THE PAGES
	LDB AA,PDVNUM		;GET DEVICE TYPE CODE
	CAIN AA,DSK		;DISK?
	PUSHJ P,SETEOF		;YES, SET THE EOF
	ADDI BB,NTABS		;STEP TO THE NEXT JFN
	CAIGE AC,MAXCHN		;STEPPED THRU THEM ALL YET?
	AOJA AC,UNMCM1		;NO, LOOP BACK FOR THE NEXT ONE
	MOVEM PF,PFLAGS		;SAVE FLAGS
	MOVSI 17,ACS		;AND THEN RESTORE ACS
	BLT 17,17
	SETZM INPAT		;AND LEAVE PAT
	HALTF
SUBTTL	THE TMPCOR UUO AND ITS ROUTINES

;THE TMPUUO CODE WAS LIFTED DIRECTLY FROM THE TOPS-10 MONITOR

;AC DEFINITIONS FOR TOPS-10 ACS

	S=PF
	T1=A
	T2=B
	T3=C
	T4=D
	J=E
	F=F
	M=G
	P1=AA
	P2=BB
	P3=CC
	P4=AC

	TMPBL==4		;BLOCK SIZE FOR DATA
	TMPBKS==<1000/<TMPBL+1>>-1 ;NUMBER OF DATA BLOCKS
	TMPSZ==TMPBKS*TMPBL	;AMOUNT OF DATA STORAGE AVAILABLE
	TMPBKJ==TMPBKS		;BLOCKS PER JOB
	TMPSZJ==TMPBKJ*TMPBL	;DATA SPACE PER USER

	JBTTMP=TMPPAG_11
	TMPTAB=TMPPAG_11+2

;PRARG BLOCK FORMAT:

;0:	NUMBER OF FILES
;1:	ADR OF FIRST FILE
;2:	ADR OF SECOND FILE
;		.
;		.
;N:	ADR OF N'TH FILE
;N+1:	XWD NAME , LEN		;FIRST FILE NAME AND LENGTH
;	   FIRST FILE DATA

;		ETC.

TMPCOR:	SKIPE TMPJFN		;READ IN TMPCOR YET?
	JRST PRATM1		;YES, GO USE IT
	MOVE A,[.PRARD,,.FHSLF]	;GET PROCESS ARGUMENTS
	MOVEI B,JBTTMP
	MOVEI C,1000		;MAX OF ONE PAGE
	PRARG
	JUMPLE C,NOPRA		;NO PROCESS ARGUMENTS SET, USE FILE
	SETOM TMPJFN		;MARK THAT PRARG WAS SUCCESSFUL
PRATM1:	SKIPL TMPJFN		;IS PRARG IN EFFECT
	JRST NOPRA		;NO, GO USE FILE
	HLRZ A,CAC		;GET CODE
	CAILE A,5		;LEGAL CODE
	JRST CMRETN		;NO, BOMB OUT
	JRST @PRATAB(T1)	;DISPATCH

PRATAB:	RETZR1			;SIZE IS ALWAYS 0
	PRARDF			;READ FILE
	PRARDF			;READ AND DELETE
	RETZER			;WRITE
	PRADIR			;READ DIR
	PRADIR			;READ AND DELETE DIR

;READ AND READ AND DELETE

PRARDF:	XCTUU <HLLZ A,0(CAC)>	;GET FILE NAME
	PUSHJ P,PRASRC		;SEARCH FOR THE NAME
	 JRST RETZER		;NOT FOUND
	UMOVE D,1(CAC)		;GET POINTER TO BUFFER
	HRRZ C,0(A)		;GET LENGTH OF FILE
	UMOVEM C,0(AC)		;STORE LENGTH IN AC
	TLNN CAC,1		;DELETE FILE?
	SETZM 0(A)		;YES, DELETE THIS ENTRY
	JUMPE D,PRARDD		;IF USER DOESNT WANT ANY, GO EXIT
PRARDL:	SOJL C,PRARDD		;IF DONE, GO EXIT
	AOS A			;STEP POINTER TO FILE AREA
	MOVE B,0(A)		;GET NEXT WORD OF FILE
	UMOVEM B,1(D)		;STORE IT IN USER BUFFER
	AOBJN D,PRARDL		;LOOP BACK FOR ALL WORDS
PRARDD:	JRST MRETN2		;DONE

;ROUTINE TO SEARCH FOR A NAME
;ACCEPTS IN A/	NAM,,0

PRASRC:	JUMPE A,CPOPJ		;IF NULL NAME, RETURN FAILURE
	MOVN D,JBTTMP		;GET NUMBER OF FILES
	HRLZS D			;SET UP AOBJN COUNTER
	JUMPE D,CPOPJ		;IF NONE, EXIT
PRASR1:	MOVE C,JBTTMP+1(D)	;GET NEXT ARG POINTER
	HLLZ B,JBTTMP(C)	;GET FILE NAME
	CAMN A,B		;FOUND THE ONE WE WANT?
	JRST PRASR2		;YES
	AOBJN D,PRASR1		;NO, LOOP BACK TIL FOUND
	POPJ P,			;NOT FOUND

PRASR2:	MOVEI A,JBTTMP(C)	;FOUND IT, RETURN ADR OF BLOCK
	JRST CPOPJ1


;ROUTINE TO READ THE DIRECTORY

PRADIR:	HRRZ A,JBTTMP		;GET NUMBER OF FILES
	XCTUU <SETZM 0(AC)>	;START WITH 0 FILES
	JUMPE A,MRETN2		;IF NONE, RETURN
	TLNE CAC,1		;DELETE DIR?
	SETZM JBTTMP		;YES
	UMOVE D,1(CAC)		;GET USER BUFFER
	JUMPE D,MRETN2		;USER WANT ANY?
PRADIL:	SKIPE C,JBTTMP+1(A)	;GET NEXT ARG
	SKIPN B,JBTTMP(C)	;GET NAME AND LENGTH OF FILE
	JRST PRADI1		;NOT THERE
	UMOVEM B,1(D)		;STORE NAME AND LEN IN USER BUFFER
	XCTUU <AOS 0(AC)>	;COUNT UP NUMBER OF FILES STORED
	AOBJP D,MRETN2		;RAN OUT OF SPACE YET?
PRADI1:	SOJG A,PRADIL		;LOOP BACK FOR ALL NAMES
	JRST MRETN2		;DONE

NOPRA:	SKIPE A,TMPJFN		;HAS THE TMP FILE BEEN OPENED YET?
	  JRST TMPCR1		;YES, DONT OPEN IT NOW
	HRROI A,STRNG1		;MAKE A FILE NAME FOR THIS TMPCOR FILE
	MOVE B,JOB		;IT SHOULD BE "XXXTMPCOR-DATA-BASE.TMP"
	MOVE C,[XWD 140003,12]	;GET JOB # INTO ASCIZ WITH LEADING 0'S
	NOUT
	  JRST MRETN		;JOB NUMBER TO BIG ( >999 )
	MOVE B,[POINT 7,[ASCIZ/TMPCOR-DATA-BASE.TMP;T/]]
	ILDB C,B		;ADD REST OF FILE NAME TO STRING
	IDPB C,A
	JUMPN C,.-2		;LOOP BACK UNTIL NULL SEEN
	MOVSI A,110001		;NOW SEE IF FILE ALREADY EXISTS
	HRROI B,STRNG1
	GTJFN
	  JRST NOTMPF		;FILE NOT THERE, GO CREATE IT
	MOVE B,[XWD 440000,300000]
	OPENF			;OPEN FILE FOR READ AND WRITE ACCESS
	  JRST MRETN		;FAILED, CANNOT DO TMPCOR UUO
	HRRZM A,TMPJFN		;SAVE THIS JFN FOR ALL SUBSEQUENT UUOS
	HRLZS A			;NOW PMAP FILE INTO CORE
	RPACS			;SEE IF PAGE EXISTS
	TLNN B,(1B5)		;...
	  JRST NOTMP1		;NOT THERE, GO INITIALIZE IT
	MOVSI B,.FHSLF		;INTO THIS FORK
	HRRI B,TMPPAG		;INTO PRESERVED PAGE FOR TMPCOR
	MOVSI C,140000		;READ AND WRITE ACCESS
	PMAP
TMPCR0:	HRRZ T1,TMPJFN		;CLOSE JFN OF TMPCOR
	CLOSF			;SO IT GOES AWAY ON EXIT
	JFCL
TMPCR1:	MOVEI J,1		;ALWAYS BE JOB 1
	MOVE T1,CAC		;GET CONTENTS OF USERS AC
	MOVE M,FORTY		;GET UUO
	MOVEM PF,PFLAGS		;PRESERVE FLAGS
	PUSHJ P,TMPUUO		;GO DO UUO
	  SKIPA
	AOS (P)			;SUCCESSFUL
	MOVE PF,PFLAGS		;RESTORE FLAGS
	JRST MRETN		;RETURN

NOTMPF:	MOVSI A,410001		;NO TMP FILE, SO WE WILL CREATE ONE
	HRROI B,STRNG1		;GET POINTER TO NAME
	GTJFN			;OPEN A NEW TMP FILE
	  JRST [PUSHJ P,WARN	;IF OVER QUOTA OR DIR FULL WARN USER
		JRST MRETN	;GIVE ERROR RETURN
		JRST NOTMPF]	;DID AN EXPUNGE, TRY AGAIN
   IFN 0,<;DON'T DELETE TMPCOR
	HRLI A,FDBCTL		;SET THE DELETED BIT IN FDB
	MOVSI B,(FDBDEL)
	MOVSI C,(FDBDEL)	;MAKE FILE BE DELETED SO IT WONT BE IN
	XJSYS <CHFDB>		;  DIRECTORY
	  JFCL
   >;END IFN 0
	HRRZS A			;RESTORE JFN
	MOVE B,[XWD 440000,300000]
	PUSH P,A		;SAVE JFN
	OPENF			;OPEN IT FOR READING AND WRITING
	  JRST [PUSHJ P,WARN	;WARN USER IF OVER QUOTA
		JRST MRETN	;THEN GIVE ERROR RETURN
		POP P,A		;GET BACK JFN
		RLJFN		;RELEASE IT
		 JFCL
		JRST NOTMPF]	;DID AN EXPUNGE, TRY AGAIN
	HRLZS A			;NOW PMAP FILE INTO CORE
NOTMP1:	MOVSI B,.FHSLF		;INTO THIS FORK
	HRRI B,TMPPAG		;INTO PRESERVED PAGE FOR TMPCOR
	MOVSI C,140000		;READ AND WRITE ACCESS
	PMAP
	MOVEI A,TMPPAG_11+4	;GET START OF TMPCOR SPACE
	HRLI A,TMPSZ		;GET AMOUNT OF DATA SPACE AVAILABLE
	MOVEM A,TMPTAB		;INITIALIZE TABLE
	HRLZI A,TMPSZJ		;GET DATA SPACE PER USER
	HRRI A,TMPBKS		;AND NUMBER OF BLOCKS ALLOWED
	MOVEM A,TMPTAB+1	;SAVE IN TABLE
	HLLZ B,TMPTAB+1		;GET FILE LIMIT PER USER
	MOVEM B,JBTTMP+1	;SAVE IN JBT TABLE
	MOVE A,TMPTAB		;GET START OF SPACE
	MOVEM A,JBTTMP		;STORE
	HRRZ B,TMPTAB+1		;GET COUNT OF BLOCKS
TMPIN1:	ADDI A,TMPBL+1		;LINK ALL BLOCKS TOGETHER
	HRRZM A,-TMPBL-1(A)
	SOJG B,TMPIN1		;LOOP FOR ALL BLOCKS
	HLLZS -TMPBL-1(A)	;ZERO LAST LINK
	POP P,A			;RESTORE JFN
;**;[436] CHANGE 1 LINE AT TMPIN1:+5.L	DSW	4/23/85
	HRLI A,FDBSIZ(CF%NUD)	;[436] CHANGE FDB TO HAVE A 1 PAGE FILE
	MOVNI B,1		;SET UP EOF POINTER
	MOVEI C,1000		;ONE PAGE LONG
	XJSYS <CHFDB>
	  JFCL
;**;[436] CHANGE 1 LINE AT TMPIN1:+10.L	DSW	4/23/85
	HRLI A,FDBBYV(CF%NUD)	;[436] NOW SET UP BYTE SIZE
	MOVSI B,7700		;..
	MOVSI C,(^D36B11)	;36 BIT BYTES
	XJSYS <CHFDB>
	  JFCL
	HRRZM A,TMPJFN		;SAVE JFN OF TMPCOR FILE
	JRST TMPCR0		;NOW GO PMAP FILE IN

UUOERR:	MOVE PF,PFLAGS		;GET THE CORRECT FLAGS
	PUSHJ P,BUGSTP		;BOMB THE JOB

GETWD1:	HRRI M,1(M)		;INCREMENT M
GETWDU:	TLZ M,37
	PUSH P,PF		;SAVE AC
	MOVE PF,PFLAGS		;IN CASE ARG OUT OF BOUNDS
	UMOVE T1,@M		;GET VALUE
	POP P,PF		;RESTORE PF
	POPJ P,

PUTWD1:	HRRI M,1(M)		;INCREMENT M
PUTWDU:	TLZ M,37
	PUSH P,PF		;SAVE AC
	MOVE PF,PFLAGS		;SET UP FLAGS IN CASE OF ADRCHK ERROR
	UMOVEM T1,@M		;STORE WORD
	POP P,PF		;RESTORE PF
	POPJ P,
REPEAT 0,<
	TITLE	TMPUUO -- TEMPORARY FILE STORAGE UUO - V010
	SUBTTL	TONY LAUCK  11 APR 72
	XP	VTMPUU,10	;PUT VERSION NUMBER IN GLOB AND MAP


		TEMPORARY FILE STORAGE FOR JOB UUO.

	THE	"TMPCOR" UUO IS USED TO ENABLE A JOB TO LEAVE SEVERAL SHORT
FILES IN CORE FROM THE RUNNING OF ONE USER PROGRAM OR CUSP TO THE
NEXT. THESE FILES MAY BE REFERRED TO BY A THREE CHARACTER FILE NAME,
AND ARE UNIQUE TO EACH JOB, I.E. A JOB CAN ONLY REFERENCE ITS OWN
FILES. ALL FILES ARE ALWAYS DELETED WHEN A JOB IS KILLED.

	EACH FILE APPEARS TO THE USER AS ONE DUMP MODE BUFFER.
THE ACTUAL SIZE OF A
TEMPORARY FILE, THE NUMBER OF TEMPORARY FILES A USER CAN HAVE,
AND THE TOTAL CORE SPACE A USER CAN TIE UP ARE PARAMETERS DETER-
MINED AT MONGEN TIME. ALL TEMPARARY FILES RESIDE IN A FIXED AREA
IN THE MONITOR, BUT THE SPACE IS DYNAMICALLY ALLOCATED AMOUNG
DIFFERENT JOBS AND THE SEVERAL DIFFERENT FILES OF ANY GIVEN JOB.

	THE PRIMARY PURPOSE OF THE TEMPORARY STORAGE SYSTEM IS FOR SHORT
CONTROL FILES, E.G. CCL FILES, TO LIVE IN CORE, THEREBY SPEEDING
UP RESPONSE TIMES AND REDUCING DISK OPERATIONS. ACCORDINGLY,
SHOULD A PROGRAM ATTEMPT TO WRITE A FILE WHEN THERE IS
INSUFFICIENT SPACE, EITHER IN THE ENTIRE BUFFER AREA OR BECAUSE
THE USER HAS EXCEEDED HIS QUOTA, THE UUO GIVES AN ERROR RETURN.
THE CUSP CAN THEN WRITE THE DATA AS A SHORT DISK FILE.
SIMILARLY, SHOULD A PROGRAM FAIL TO FIND A FILE UPON READING IT,
IT WILL GET AN ERROR RETURN AND CAN THEN LOOKUP A SHORT DISK FILE.


	IT	IS VERY IMPORTANT TO REALIZE THE TEMPORARY NATURE OF THESE
FILES. FOR EXAMPLE, UPON WRITING, THE OLD FILE IS DELETED BEFORE
CHECKING FOR SPACE FOR A NEW VERSION. THE OLD FILE COULD BE LOST WITHOUT
A NEW ONE REPLACING IT. ALSO, THERE CAN BE NO GUARANTEE THAT FILES
WILL FIT IN CORE.


	THE	TMPCOR UUO IS NOT INTENDED TO REPLACE A FUTURE, MORE
GENERAL, DEVICE INDEPENDENT SERVICE ROUTINE FOR "CORE". HOWEVER,
THE SPACE TAKEN UP BY DEVICE DATA BLOCKS, ETC., IN THAT MORE
GENERAL ROUTINE WOULD REPRESENT UNNECESSARY OVERHEAD FOR EXTREMELY
SHORT DATA, SUCH AS CCL COMMAND FILES.
>
	REPEAT	0,<
	FORMAT	OF TEMPORARY FILE STORAGE UUO.

	CALL	AC, [SIXBIT /TMPCOR/]	;CALLI INDEX=44
	;ERROR RETURN
	;NORMAL RETURN

	C(AC) MUST ALWAYS BE SET UP BY THE USER PROGRAM PRIOR TO EXECUTING
THE UUO. IT IS CHANGED BY THE UUO AND RETURNS A VALUE THAT DEPENDS
ON THE PARTICULAR FUNCTION PERFORMED.

	C(AC) = XWD CODE,BLOCK

BLOCK:	XWD	NAME,0		;NAME IS FILE NAME
	IOWD	BUFLEN,BUFFER	;USER BUFFER AREA (ZERO  FOR NO BUFFER)
>
	REPEAT	0,<
		CODE-0	--  GET FREE SPACE

	THE	IS THE ONLY FORM OF THE TEMP UUO THAT DOES NOT USE A TWO
WORD PARAMETER BLOCK. C(AC) WOULD ORDINARLY BE SET TO ZERO FOR THE
GET FREE SPACE UUO. THE USER PROGRAM ALWAYS GETS A NORMAL RETURN
(UNLESS THE SYSTEM DOES NOT HAVE THE TEMP UUO). C(AC) IS SET TO
THE NUMBER OF WORDS OF FREE SPACE AVAILABLE TO THE USER.


		CODE=1	--  READ FILE

	IF	THE SPECIFIED FILE NAME IS NOT FOUND, C(AC) IS SET TO THE
NUMBER OF FREE WORDS OF SPACE AVIALABLE FOR TEMP FILES, AND THE
ERROR RETURN IS TAKEN.

	IF	THE FILE IS FOUND, C(AC) IS SET TO THE LENGTH OF THE
FILE IN WORDS, AND AS MUCH OF THE FILE AS WILL FIT IS COPIED INTO
THE USERS BUFFER. THE USER CAN CHECK FOR TRUNCATION BY COMPARING
C(AC) WITH BUFLEN UPON SUCCESSFUL RETURN FROM THE TEMP UUO.


		CODE=2	--  READ AND DELETE FILE

	THIS	IS THE SAME AS CODE=1, EXCEPT THAT IF A FILE WAS FOUND
IT IS ALSO DELETED AND ITS SPACE RECLAIMED.
>
	REPEAT	0,<
		CODE=3	--  WRITE FILE

	IF	THERE IS ALREADY A FILE OF THE SPECIFIED NAME, IT IS
DELETED AND ITS SPACE IS RECLAIMED.

	THE	REQUESTED SIZE OF THE FILE IS SPECIFIED BY BUFLEN.
IF THERE IS NOT ENOUGH SPACE TO WRITE THE ENTIRE FILE, NOTHING
IS WRITTEN, C(AC) IS SET TO THE NUMBER OF FREE WORDS OF SPACE
AVAILABLE TO THE USER, AND THE ERROR RETURN IS TAKEN.

	IF	THERE IS ENOUGH SPACE, THE FILE IS WRITTEN. C(AC) IS SET TO
THE AMOUNT OF SPACE LEFT AFTER THE FILE HAS BEEN WRITTEN AND THE
NORMAL RETURN IS TAKEN. FILES ARE ALWAYS FILLED UP WITH ZEROS TO THE
NEXT EVEN MULTIPLE OF THE BLOCK LENGTH (TMPBL).
	THIS	EVEN LENGTH IS READ BACK IN.


		CODE=4	--  READ DIRECTORY

	THE	ERROR RETURN IS NEVER TAKEN.

	C(AC) IS SET TO THE NUMBER OF DIFFERENT FILES IN THE JOB'S
TEMPORARY FILE AREA. IN ADDITION, AN ENTRY IS MADE FOR EACH FILE
IN THE USER BUFFER AREA UNTIL THERE IS NO MORE SPACE OR ALL FILES HAVE
BEEN LISTED. THE USER PROGRAM CAN CHECK FOR TRUNCATION BY COMPARING
C(AC) UPON RETURN WITH BUFLEN.

	DIRECTORY ENTRY FORMAT
	XWD  NAME,SIZE	;NAME=FILE NAME, SIZE =FILE LENGTH IN WORDS.


		CODE=5	--  READ AND CLEAR DIRECTORY

	THIS	IS THE SAME AS CODE=4 EXCEPT THAT ANY FILES IN THE JOB'S
TEMPORARY STORAGE AREA ARE ALSO DELETED AND THEIR SPACE RECLAIMED.

	THIS	UUO IS EXECUTED BY THE LOGOUT CUSP.
>
	REPEAT	0,<
		IMPLEMENTATION

	MASTER	DIRECTORY

	THIS	IS A TABLE JOBN+1 ENTRIES LONG.

JBTTMP:	XWD	FREE,IDLE
JBTTM1:	XWD	SPACE,LINK
	   .
	   .
	   .

MREE = NO. OF FREE BLOCKS IN MONITOR BUFFER AREA
IDLE  =  LINK TO FIRST FREE BLOCK OR 0 IF NO FREE BLOCKS
SPACE  =  NO OF FREE BLOCKS REMAINING IN JOBS QUOTA
LINK  =  LINK TO FIRST BLOCK OF FIRST FILE OF JOB, 0 IF NONE.


	IDLE	BLOCK FORMAT

	XWD	0,LINK
	REPEAT	TMPBL, <0
			>

	LINK  = LINK TO NEXT BLOCK ON IDLE CHAIN, 0 IF NO MORE.

	USER	BLOCK FORMAT

	XWD	NAME,LINK
	BLOCK	TMPBL		;USER DATA OR ZERO FILL.

	NAME	= USER FILE NAME.
	LINK	= LINK TO NEXT BLOCK IN THIS FILE OR NEXT FILE OF THIS USER

	IF	A FILE IS SEVERAL BLOCKS LONG, EACH BLOCK HAS THE FILE NAME.
	A	LINK OF 0 INDICATES NO MORE DATA IN THE FILE, AND NO MORE FILES
FOR THIS USER.

	THEREFORE, A FILE ENDS WHEN ITS LAST BLOCK HAS A ZERO LINK, OR
WHEN IT LINKS TO A FILE OF DIFFERENT NAME.



	MONITOR	BUFFER AND PARAMETERS

TMPBUF:	BLOCK	TMPBKS*<TMPBL+1>	;BUFFER AREA FOR ALL FILES.

	TMPBKS	IS THE NUMBER OF BLOCKS THE STORAGE AREA IS COMPUTED.
	IT	IS COMPUTED BY MACRO DURING THE ASSEMBLY OF COMMON.
	TMPBL	IS A PARAMETER IN S.MAC.
>
	REPEAT	0,<
	FACTORS	AFFECTING SYSTEM

	1. MONITOR MUST INITALIZE THE TEMP FILES ON RESTART.
	A) CLEAR ENTIRE BUFFER AREA
	B) SET FREE COUNT TO TOTAL NUMBER OF 5 WORD BLOCKS
	C) LINK ALL BLOCKS ON IDLE CHAIN
	D) SET ALL USERS SPACE TO THEIR QUOTA AND LINKS TO 0


	2.  LOGOUT MUST DO A CLEAR OF USERS DIRECTORY

	3. PIP SHOULD CLEAR USERS DIRECTORY ON A DEL *.TMP COMMAND

	4.  PIP SHOULD READ AND WRITE TEMP FILES. DEVICE TMP:?

	5.  ALL CCL CUSPS MUST BE CHANGED TO DO TEMP UUO.
>
;	ENTRY	TMPUUO
;	INTERN	TMPUUO,TMPTAB
;	EXTERN	CPOPJ,CPOPJ1,STOTAC,GETWDU,UUOERR,JBTTMP,GETWD1,PUTWD1

;TMPTAB:	0			;FREE DATA SPACE,ADDRESS OF TABLE
;	0			;USER QUOTA,NUMBER OF BLOCKS

TMPUUO:
;	PUSHJ	P,SAVE4##	;SAVE P1-P4
	AOS	(P)		;SET FOR GOOD RETURN
	MOVE	P4,T1		;GET USERS AC
	TLNN	P4,-1		;IS CODE = 0?
	JRST	TMPSP		;YES, SO JUST RETURN SPACE LEFT
	HRR	M,P4		;SETUP M TO GET FIRST WORD OF BLOCK
	PUSHJ	P,GETWDU	;GET FIRST WORD
	HLLZ	S,T1		;SAVE FILE NAME
	PUSHJ	P,GETWD1	;GET SECOND WORD
	HLRE	F,T1		;GET USER'S BUFFER LENGTH
	MOVNS	F
	HRR	M,T1		;USER'S BUFFER ADDRESS
	HLRZS	P4		;GET CODE
	CAILE	P4,TMPDL		;CHECK IF IT IS LEGAL
	JRST	UUOERR		;NO
	JRST	@TMPDIS-1(P4)	;DISPATCH TO APPROPRIATE ROUTINE

TMPDIS:	JRST	TMPREA
	JRST	TMPREA
	JRST	TMPWR
	JRST	TMPDIR
	JRST	TMPDIR

	TMPDL== .-TMPDIS
	;ROUTINE TO READ, OR READ AND DELETE A TEMPORARY FILE

TMPREA:	PUSHJ	P,TMPSRC	;FIND FILE
	JRST	TMPSPB		;NONE, SO RETURN SPACE
	SETZ	T3,		;ZERO USER COUNT
TMPRE1:	HRLI	P1,-TMPBL	;SET COUNT TO NO WORDS IN BLOCK
TMPRE2:	SOJL	F,TMPR2A	;COUNT DOWN USER BUFFER SPACE
	MOVE	T1,1(P1)
	PUSHJ	P,PUTWD1	;IF SPACE, COPY 1 WORD
TMPR2A:	ADDI	T3,1		;ADD TO USER COUNT
	AOBJN	P1,TMPRE2	;GO ON WITH BUFFER IF MORE WORDS
	SUBI	P1,TMPBL	;GET BACK TO START OF BLOCK
	TRNN	P4,1		;SHOULD WE DELETE?
	PUSHJ	P,TMPDEL	;DELETE THIS BLOCK
	PUSHJ	P,TMPCHA	;CHAIN TO NEXT BLOCK IN FILE
	JRST	TMPRE1		;FOUND, GO HANDLE IT
TMPRE3:	SETZ	T1,
TMPFLL:	SOJL	F,STOT3		;FILL REST OF USERS BUFFER
	PUSHJ	P,PUTWD1	;WITH ZEROS, THEN GIVE HIM COUNT
	AOJA	T4,TMPFLL


	;ROUTINE TO CHAIN TO NEXT BLOCK OF A FILE

TMPCHA:	HRRZ	P1,(P1)		;CHAIN TO NEXT BLOCK
	HLLZ	P3,(P1)		;GET FILE NAME
	CAMN	P3,S		;MATCH?
	JUMPN	P1,CPOPJ	;YES, IS THERE A BLOCK?
	JRST	CPOPJ1		;NO, SKIP RETURN


	;ROUTINE TO FIND A FILE

TMPSRC:	MOVEI	P2,JBTTMP(J)	;GET ADDRESS OF FIRST LINK
TMPSR1:	HRRZ	P1,(P2)		;CHAIN FORWARD
	JUMPE	P1,CPOPJ	;NONE, FILE NOT FOUND
	HLLZ	T2,(P1)		;GET FILE NAME
	CAMN	T2,S		;MATCH?
	JRST	CPOPJ1		;YES, SKIP RETURN
	HRRZ	P2,P1		;SAVE OLD POINTER
	JRST	TMPSR1		;AND KEEP ON LOOKING


	;ROUTINE TO DELETE A BLOCK

TMPDEL:	HRRZ	P3,(P1)		;LINK AROUND BLOCK
	HRRM	P3,(P2)
	HRRZ	P3,JBTTMP	;LINK OLD BLOCK TO IDLE
	MOVEM	P3,(P1)
	HRRM	P1,JBTTMP	;LINK START OF IDLE CHAIN TO BLOCK
	HRRZ	P1,P2		;RESTORE P1 FOR TMPCHA
	MOVSI	P3,TMPBL	;UPDATE FREE COUNTERS
	ADDM	P3,JBTTMP
	ADDM	P3,JBTTMP(J)
	POPJ	P,
	;ROUTINE TO WRITE A FILE FOR USER

TMPWR:	PUSHJ	P,TMPSRC	;SEE IF THERE WAS AN OLD FILE
	JRST	TMPWR2		;NO
TMPWR1:	PUSHJ	P,TMPDEL	;DELETE A BLOCK
	PUSHJ	P,TMPCHA	;CHAIN TO NEXT BLOCK
	JRST	TMPWR1		;THERE WAS ONE, GO ON

TMPWR2:	PUSHJ	P,TMPSPC	;GET SPACE FOR USER
	SKIPE	T3
	CAMLE	F,T3		;DOES HE WANT MORE?
	JRST	TMPSPB		;YES, SO TELL HIM HE LOST

	HRRZ	P3,JBTTMP(J)	;SAVE LINK TO FIRST FILE
	MOVEI	P2,JBTTMP(J)	;SET OLD BLOCK ADDRESS

TMPWR3:	HRRZ	P1,JBTTMP	;GET ADDRESS OF FIRST IDLE BLOCK
	HRRZ	T2,(P1)		;GET ITS SUCCESSOR
	HRRM	T2,JBTTMP	;LINK THAT BLOCK TO IDLE CHAIN
	HRRM	P1,(P2)		;LINK LAST BLOCK OF USER TO NEW BLOCK
	HRRZ	P2,P1		;SAVE OLD BLOCK ADDRESS
	MOVSI	T2,-TMPBL	;DECREASE JOB AND TOTAL SPACE
	ADDM	T2,JBTTMP
	ADDM	T2,JBTTMP(J)

	HLLM	S,(P1)		;INSERT FILE NAME
	HRLI	T4,-TMPBL	;SET FOR NO WORDS/BLOCK
TMPWR4:	SOJL	F,TMPWR6	;DOES HE WANT TO WRITE MORE?
	PUSHJ	P,GETWD1	;GET A WORD
	PUSH	P1,T1		;YES, SO STICK IN HIS WORD
TMPWR5:	AOBJN	T4,TMPWR4	;UPDATE USER ADDR, IS BLOCK DONE?
	JUMPG	F,TMPWR3	;YES, DOES HE HAVE MORE?

	HRRM	P3,-TMPBL(P1)	;NO, LINK LAST BLOCK TO HIS FILES
	JRST	TMPSP		;GET SPACE AND RETURN

TMPWR6:	SETZM	1(P1)		;FILL FINAL BLOCK WITH ZERO
	AOJA	P1,TMPWR5	;AND GO ON UNTIL BLOCK DONE


	;ROUTINE TO COMPUTE SPACE FOR USERS TMP FILES

TMPSPC:	HLRZ	T3,JBTTMP	;TOTAL FREE SPACE
	HLRZ	T2,JBTTMP(J)	;USER LIMIT
	CAMLE	T3,T2		;SPACE IS MINIMUM OF THE TWO
	MOVE	T3,T2
	POPJ	P,


	;ROUTINE TO GET SPACE AND RETURN TO USER (SKIP AND NO SKIP)

TMPSPB:	SOS	(P)		;NO SKIP RETURN
TMPSP:	PUSHJ	P,TMPSPC	;GET SPACE
STOT3:
;	MOVE	T1,T3		;SET TO STORE T3
;	JRST	STOTAC		;RETURN IT
	LDB T1,ACPTR		;GET USER AC
	MOVEM T3,ACS(T1)	;STORE AC
	POPJ P,			;AND RETURN
	;READ DIRECTORY, READ AND CLEAR DIRECTORY

TMPDIR:	SETZ	T3,		;ZERO COUNT OF FILES
	MOVEI	P2,JBTTMP(J)	;SET LINK TO DELETE
	HRRZ	P1,(P2)		;LINK TO FIRST BLOCK
TMPDI1:	JUMPE	P1,TMPRE3	;IF NONE, ZERO REST OF USERS BUFFER
	HLLZ	S,(P1)		;GET FILE NAME
	MOVEI	T1,1		;SET LENGTH TO 1
TMPDI2:	TRNE	P4,1		;DELETE?
	PUSHJ	P,TMPDEL	;YES, DELETE BLOCK
	PUSHJ	P,TMPCHA	;GET NEXT BLOCK OF FILE
	AOJA	T1,TMPDI2	;THERE IS ONE, SO COUNT BLOCKS
	IMULI	T1,TMPBL	;GET LENGTH IN WORDS
	HLL	T1,S		;DONE, GET LENGTH, NAME OF OLD ONE
	SOSL	F		;IS THERE SPACE LEFT IN USER AREA?
	PUSHJ	P,PUTWD1	;YES, STOW ENTRY
	AOJA	T3,TMPDI1	;COUNT FILES, GO ON FOR NEXT ONE

SUBTTL TRAP HANDLING

;APR TRAPS ENABLE
; USER CALL IS
;	MOVEI AC,BITS
;	CALLI AC,16
;
;WHERE BITS ARE 1B18 FOR REPEATED TRAPS (EXCEPT CLK)
;	1B19 FOR PDLOV, 1B22 FOR ILL MEM REF, 1B23 FOR NXM
;	1B26 FOR CLOCK (NOT YET SUPPORTED), 1B29 FOR FOV, 1B32 FOR AROV

APRENB:	MOVEI A,.FHSLF		;THIS FORK
;**;[432] INSERT 5 LINES AT APRENB:+1L		DSW	6-MAR-85
;**;[437] DELETE 5 LINES AT APRENB:+1L, REMOVE LABELS	DSW	20-MAY-85
	MOVE B,[XWD LEVTAB,CHNTAB]
	SIR			;NEW PSEUDOINTERRUPT CHANNELS
	MOVEM CAC,USRENB	;SAVE FOR LATER REFERENCE
	LSH CAC,1		;MATCH UP WITH ENABLE FLAGS
	ANDI CAC,220		;FOR OV AND FOV
	MOVEM CAC,CNIWRD	;AND REMEMBER FOR APR CONI
	PUSHJ P,SETPSI		;SET UP PSI AS INDICATED BY USRENB
	EIR			;ENABLE INTERRUPT SYSTEM
	JRST MRETN

LIGHTS:	MOVEI A,.FHSLF		;THIS FORK
	RPCAP			;GET PROCESS CAPABILITIES
	MOVE A,CAC		;GET ARGUMENT TO DISPLAY
	TRNE C,WHEEL!OPER!MAINT	;WILL MONITOR COMPLAIN ABOUT LITES?
	LITES			;NO. DO IT.
	JRST MRETN

SWITCH:	SWTCH
	JFCL			;IGNORE ERROR RETURN
	JRST MRETN

;ADDRESS CHECK ROUTINES
;CALL:	MOVE A,ADDRESS
;	MOVE B,LENGTH		;OPTIONAL IF A BLOCK IS TO BE CHECKED
;	PUSHJ P,ADRCHK		;CALL ADRCKB IF CHECKING A BLOCK
;	RETURN HERE IF OK	;NO RETURN IF OUT OF BOUNDS

ADRCHK:	MOVEI B,1		;MAKE THIS A ONE WORD BLOCK
ADRCKB:	CAIGE A,20		;IN THE AC'S
	  JRST ADRCKL		;YES, GO CHECK END OF BLOCK
	CAML A,HSORG		;HIGH SEG ADDRESS?
	  CAMLE A,JBHRL		;YES, IS IT A LEGAL HIGH SEG?
	CAMG A,JBREL		;NO, IS THIS A LEGAL LOW SEG ADDRESS?
	CAIG A,.JBPFI		;IS THIS ADDRESS ABOVE THE PROTECTED AREA
	  JRST ITRAP		;ONE OF THE ABOVE FAILED
ADRCKL:	ADDI B,-1(A)		;GET LAST WORD IN BLOCK TO CHECK
	CAIGE B,20		;IN THE ACS?
	  POPJ P,		;YES, OK RETURN
	CAML B,HSORG		;HIGH SEG?
	  CAMLE B,JBHRL		;YES, OK?
	CAMG B,JBREL		;NO, OK LOW SEG ADR?
	CAIG B,.JBPFI		;CHECK ALSO PROTECTED DATA AREA
	  JRST ITRAP		;TOO BAD!
	POPJ P,			;BLOCK IS OK

SETDDT:	UMOVEM CAC,.JBDDT	;SET DDT ADDR
	HRRZM CAC,JBDDT		;SAVE DDT ADDR
	JRST MRETN

GETLIN:	GJINF			;GET TTY NUMBER FOR THIS JOB
	JUMPL D,RETZER		;DETACHED, RETURN ZERO
	MOVE B,D		;GET TTY NUMBER
	PUSHJ P,LIN26		;TRANSLATE TO 'TTYN'
	JRST STOTAC		;AND GIVE IT TO USER

;ROUTINE TO TURN TTY LINE # TO SIXBIT/TTYN/
;ACCEPTS IN B/	LINE NUMBER
;RETURNS IN A/	SIXBIT/TTYN/

LIN26:	HRROI A,STRNG1		;NOW GET TTY NUMBER IN ASCII
	MOVEI C,10		;RADIX 8 (OCTAL)
	NOUT
	  PUSHJ P,ERROR
	PUSHJ P,SEVN26		;TRANSLATE SEVEN BIT TO SIXBIT
	MOVSS A			;GET TTY# INTO RH
	HRLI A,'TTY'		;ADD IN TTY
	POPJ P,			;RETURN WITH ANSWER IN A

REASSI:	MOVEI A,0		;PRETEND IT FAILED
	UMOVEM A,1(AC)		;SET AC+1 TO 0
	JRST STOTAC		;AND AC TO 0

	SUBTTL MORE UUOS

;REMAP
; CAC/	DESIRED HISEG ORIGIN ,, DESIRED NEW LOWSEG END
; BLOCK BETWEEN NEW LOWSEG END AND OLD LOWSEG END WILL BE MOVED
; TO NEW HISEG

REMAP:	MOVE A,JBREL		;GET CURRENT LOW SEG END
	SUBI A,(CAC)		;LENGTH OF DATA TO MOVE
	JUMPLE A,MRETN		;RETURN IF .LE. 0
	HRRZ B,CAC		;GET NEW LOW SEG END
	TRO B,777		;FORCE END OF PAGE
	MOVEI C,.HSLOC		;GET DEFAULT HI SEG ORIGIN
	CAMG C,B		;ABOVE LOW SEG END?
	MOVEI C,1(B)		;NO, FORCE ABOVE
	HLRZ D,CAC		;GET DESIRED HI SEG ORIGIN
	SKIPN D			;DID HE SPECIFY
	MOVE D,C		;NO, USE DEFAULT
	TRZ D,777		;FORCE BEGINNING OF PAGE
	CAMG D,B		;ABOVE NEW LOW SEG END?
	JRST MRETN		;NO, RETURN
	MOVE C,D		;COPY HI SEG ORIGIN
	ADDI C,-1(A)		;COMPUTE LAST WORD OF NEW HI SEG
	TRO C,777		;FORCE END OF PAGE
	TLNE PF,L.FLSR		;FILSER MAPPED?
	CAIGE C,FLSRLC		;YES, MUST BE BELOW IT
	CAIL C,PATLOC		;ELSE MUST BE BELOW US
	JRST MRETN		;NEW TOP TO HIGH, RETURN
	XCTUU <HRRZM C,.JBHRL>	;STORE NEW HI SEG END FOR USER
	EXCH C,JBHRL		;EXCHANGE NEW END FOR OLD
	JUMPE C,REMAP1		;JUMP IF NO OLD TO FLUSH
	SETO A,			;PREPARE TO FLUSH OLD HI SEG
	LDB B,[PAGEN HSORG]	;OLD ORIGIN PAGE
	HRLI B,.FHSLF		;OUR FORK
	MOVEI C,PATPAG		;UP TO HERE
	TLNE PF,L.FLSR		;UNLESS FILSER MAPPED
	MOVEI C,FLSRPG		;THEN HERE
	SUBI C,(B)		;NUMBER OF PAGES TO FLUSH
	TLO C,(1B0)		;REPEAT ARG
	PMAP			;GOODBYE TO OLD HI SEG
REMAP1:	HRRZM D,HSORG		;STORE NEW HI SEG ORIGIN
	MOVE B,JBREL		;CURRENT LOW SEG END
	SUBI B,(CAC)		;LENGTH OF DATA TO MOVE
	MOVE C,B		;SAVE COPY OF HI SEG LENGTH
	XCTUU <HRLM B,.JBHRL>	;STORE NEW HI SEG FREE POINTER
	ADDI B,-1(D)		;COMPUTE LAST WORD OF DESTINATION
	CAMG D,JBREL		;IS NEW ORIGIN ABOVE CURRENT END?
	JRST REMAP2		;NO, MUST USE SLOW CODE
	HRLI D,1(CAC)		;NO OVERLAP, GET SOURCE FOR BLT
	BLT D,(B)		;MOVE DATA
	JRST REMAP3

REMAP2:	HRRO A,JBREL		;GET LAST WORD OF SOURCE
REMP2A:	POP A,(B)		;MOVE A WORD ADJUSTING SOURCE
	SUBI B,1		;ADJUST DESTINATION
	SOJG C,REMP2A		;TEST FOR ALL WORDS MOVED AND LOOP
REMAP3:	HRRZ A,CAC		;GET NEW END AGAIN
	TRO A,777		;FORCE END OF PAGE
	MOVEM A,JBREL		;SAVE HERE
	XCTUU <HRRM A,.JBREL>	;AND HERE
	LDB B,[PAGEN JBREL]	;GET LOW SEG END PAGE
	ADDI B,1		;GET FIRST PAGE TO FLUSH
	LDB C,[PAGEN HSORG]	;GET HIGH SEG START PAGE
	SUBI C,(B)		;COMPUTE # OF PAGES TO FLUSH
	JUMPE C,MRETN2		;ALL DONE IF NONE, SUCCESS
	SETO A,			;PREPARE TO FLUSH SOURCE PAGES
	HRLI B,.FHSLF		;FROM US
	TLO C,(1B0)		;INDICATE REPEAT COUNT
	PMAP			;FLUSH
	JRST MRETN2		;SUCCESS
;GETTAB UUO SIMULATOR ROUTINES
;	ONLY CERTAIN TABLES AND INDEXES ARE IMPLEMENTED
;	INDEX = -1, -2, OWN JOB, OR OWN HIGH SEGMENT #


GETTAB:	MOVEI A,.GTTBV		;GET ADDRESS OF BIT TABLE
	MOVEI B,.GTTBC		;AND ADDRESS OF TABLE OF COUNTS
	HRRE C,CAC		;GET DESIRED FUNCTION NUMBER
	JUMPL C,CMRETN		;NEGATIVE NUMBERS NOT SUPPORTED
	CAIG C,.GTMAX		;WITHIN BOUNDS?
	PUSHJ P,.GTDSP		;GET DISPATCH VALUE
	  JRST CMRETN		;NOT SUPPORTED
	XCT .GTTBL(C)		;DO THE FUNCTION
	JRST STOTC1		;STORE ANSWER AND SKIP RETURN

;ROUTINE TO GET A DISPATCH VALUE FROM GETTAB BIT TABLE
;CALLING SEQUENCE:
;	MOVE A,ADR OF BIT TABLE
;	MOVE B,ADR OF COUNT TABLE
;	MOVE C,DESIRED INDEX
;	PUSHJ P,.GTDSP
;	  NOT SUPPORTED INDEX
;	SUCCESSFUL, DISPATCH VALUE IN C

.GTDSP:	IDIVI C,^D36		;GET BIT POSITION IN TABLE
	MOVE E,C		;SAVE WORD INDEX VALUE
	JUMPE C,.GTDS1		;IF IN FIRST WORD, DONT GET COUNT
	ADDI C,-1(B)		;GET INDEX INTO COUNT TABLE
	MOVE C,0(C)		;GET COUNT OF PREVIOUS WORDS
.GTDS1:	SETO B,			;INITIALIZE MASK
	MOVNI D,1(D)		;GET NEGATIVE BIT POS WITHIN WORD
	LSH B,(D)		;GET MASK OF UNWANTED BITS
	ADDI E,(A)		;GET INDEX INTO BIT TAIBLE
	MOVE E,(E)		;GET BIT WORD
	MOVSI F,400000		;SEE IF BIT IS ON
	LSH F,1(D)		;GET MASK
	TDNN F,E		;IS THIS BIT ON?
	  POPJ P,		;NO, UNSUPORTED FUNCTION
	ANDCM E,B		;MASK OUT UNWANTED BITS
	MOVE D,E		;NOW COUNT THE BITS
	LSH E,-1		;SEE HACK MEM ITEM 169 FOR EXPLAINATION
	AND E,[333333,,333333]
	SUB D,E
	LSH E,-1
	AND E,[333333,,333333]
	SUBB D,E		;EACH OCTAL DIGIT IS REPLACED BY THE
	LSH E,-3		;  NUMBER OF 1'S IN IT
	ADD D,E
	AND D,[070707,,070707]
	IDIVI D,77		;CASTING OUT 77'S
	ADDI C,0(E)
	SOJA C,CPOPJ1		;RETURN WITH DISPATCH VALUE IN C


DEFINE GTABLE(NAM),<

NAM'TBL:	GTDEF (NAM)

NAM'TBC:	GTCGEN(NAM,\NAM'L)

NAM'TBV:	GTVGEN(NAM,\NAM'L)
>

DEFINE GVAL(X,Y,Z,NAM),<
IF1,<	IFNDEF NAM'V'Y,<NAM'V'Y==0
		NAM'C'Y==0>
	IFNDEF NAM'MAX,<NAM'MAX==0>
	IFL NAM'MAX-X,<NAM'MAX==X>
	NAM'V'Y==NAM'V'Y!1B<^O'X-^O'Z>
	NAM'C'Y==NAM'C'Y+1
	NAM'L==Y>>

DEFINE GTGEN(A,B,C),<
	A
	ZZ==B/^D36
	ZZZ==ZZ*^D36

	GVAL(B,\ZZ,\ZZZ,<C>)
>

DEFINE GTCGEN(NAM,LEN),<
	ZZ==0
	ZZZ==0
	REPEAT LEN,<
	GTCGN1(<NAM>,\ZZ)
	ZZ==ZZ+1>>

DEFINE GTCGN1(A,B),<
	IFNDEF A'C'B,<A'C'B==0>
	A'C'B+ZZZ
	ZZZ==ZZZ+A'C'B>

DEFINE GTVGEN(A,B),<
	ZZ==0
	REPEAT B+1,<
	GTVGN1(<A>,\ZZ)
	ZZ==ZZ+1>>

DEFINE GTVGN1(A,B),<
	IFNDEF A'V'B,<A'V'B==0>
	A'V'B>



.GTIDX:	HLRZ A,CAC		;GET INDEX VALUE
	CAIN A,-1		;THIS JOB?
	JRST CPOPJ2		;YES, GIVE SKIP RETURN
	CAIN A,-2		;THIS JOB'S HIGH SEGMENT?
	JRST CPOPJ1		;YES, 1-SKIP RETURN
	CAMN A,JOB		;THIS JOB?
	JRST CPOPJ2		;YES
	CAMN A,HGHSGN		;THIS JOB'S HIGH SEG?
	JRST CPOPJ1		;YES
	POPJ P,			;NO, THIS IS AN ERROR

.GTSTS:	PUSHJ P,.GTIDX		;CHECK INDEX VALUE
	JRST [HLRZ E,CAC	;GET JOB NUMBER
		JRST .GTST1]
	  JRST CMRETN		;NO HIGH SEG'S ALLOWED
.GTST2:	MOVSI A,440004		;RUNABLE, LOGGED IN, AND JNA
	JRST STOTC1		;RETURN IT TO USER
.GTST1:	HRRZ A,E		;GET JOB NUMBER
	PUSHJ P,DGETJI		;DO THE GETJI
	 JRST [	CAIE A,GTJIX4	;NOT LOGGED IN ERROR?
		JRST CMRETN	;NO, ILLEGAL JOB NUMBER
		JRST RETZR1]	;YES, RETURN 0
	SKIPN STRNG1+.JIUNO	;IS JOB LOGGED IN?
	  JRST RETZR1		;NO, RETURN 0
	MOVSI A,440004		;ASSUME RUNABLE
	SKIPGE C,STRNG1+.JITNO	;IS THERE A TTY FOR IT?
	  JRST .GTST3		;NO, CAN'T CHECK INPUT WAIT
	SYSGET<TTYJOB>		;SEE IF IN TTY INPUT WAIT
	HRL A,C			;GET TTY LINE NUMBER
	HRR A,B			;AND TTYJOB TABLE NUMBER
	GETAB			;RH = -1 IF NOT IN TTY INPUT WAIT
	  JRST CMRETN
	TRC A,-1		;CHECK FOR -1
	TRCN A,-1
	  JRST .GTST2		;NO, JUST RETURN RUNNABLE
	MOVSI A,440164		;NO, JUST SAY JOB IS IN TTY WAIT
.GTST3:	PUSHJ P,SKPUSR		;SKIP IF USER MODE
	  MOVSI A,40224		;NO, RETURN JOB IN STOP QUEUE
	JRST STOTC1

.GTADR:	PUSHJ P,.GTIDX		;GET ARG TYPE
	JRST [	HLRZ E,CAC	;SOME OTHER JOB
		JRST .GTAD1]	;GET ITS JOB NUMBER
	JRST RETZR1		;ALL HIGH SEGS ARE 0
	MOVE E,JOB		;THIS JOB
.GTAD1:	SYSGET<JOBNAM>		;NOW GET THE WORKING SET SIZE OF JOB
	HRR A,B
	HRL A,E			;GET JOB #
	GETAB
	  JRST RETZR1
	MOVE C,A		;SAVE INDEX INTO NAME TABLES
	SYSGET<SNBLKS>		;GET TABLE #
	HRR A,B			;GET NUMBER
	HRL A,C			;AND INDEX
	GETAB			;GET NUMBER OF BLOCKS THAT HAVE OCCURED
	  JRST RETZR1
	MOVE D,A		;SAVE NUMBER OF BLOCKS
	SYSGET <SSIZE>		;GET SIZE INTEGRAL
	HRR A,B			;GET TABLE NUMBER
	HRL A,C			;GET INDEX INTO TABLE
	GETAB			;GET SIZE
	  JRST RETZR1
	IDIV A,D		;GET AVERAGE SIZE
	SKIPE B			;ANY REMAINDER?
	  AOS A			;YES, COUNT UP AVERAGE SIZE
	ASH A,9			;TURN PAGES INTO WORDS
	HRLZI A,-1(A)		;GET HIGHEST LEGAL ADR IN LH
	JRST STOTC1		;AND GIVE IT TO USER

.GTPPN:	PUSHJ P,.GTIDX		;LEGAL INDEX?
	JRST .GTPPJ		;GET THE PPN OF ANOTHER JOB
	JRST .GTSPP		;YES, HIGH SEGMENT PPN NEEDED
.GTPPS:	AOS (P)			;SET UP SKIP RETURN
	JRST GETPPN		;YES, RETURN JOB'S PPN

.GTPPJ:	HLRZ A,CAC		;GET JOB NUMBER
	HRROI B,D		;GET LOGGED IN DIR
	MOVEI C,.JILNO
	GETJI
	 JRST [	CAIE A,GTJIX4	;NOT LOGGED IN ERROR?
		JRST CMRETN	;NO, ILLEGAL JOB NUMBER
		JRST RETZR1]	;YES, RETURN 0
	MOVE A,D		;GET LOGGED IN DIR #
	JUMPE A,STOTC1		;NO JOB LOGGED IN IF 0
	PUSHJ P,PPNUNM
	JRST STOTC1		;STORE ANSWER

.GTPRG:	PUSHJ P,.GTIDX		;CHECK LEGALITY OF INDEX
	JRST [HLRZ E,CAC	;GET JOB # DESIRED
		JRST .GTPR1]
	JRST .GTSNM		;HIGH SEG NAME WANTED
	SKIPE A,LOWNAM		;HAS THE USER DONE A SETNAM UUO?
	  JRST STOTC1		;YES, RETURN THIS NEW NAME
	MOVE E,JOB		;GET OUR JOB NUMBER
.GTPR1:	PUSHJ P,GTJBNM		;GET JOB NAME
	  JRST CMRETN
	JRST STOTC1		;GO STORE DATA AND SKIP RETURN

GTHSNS:	MOVE B,F		;GET HANDLE FOR HIGH SEG
	HRROI A,STRNG1		;SET UP STRING AREA FOR JFNS
	JFNS
	 ERJMP [SETZ A,
		POPJ P,]
SEVN26:	MOVE B,[POINT 7,STRNG1]
SVN26B:	SETZ A,			;INITIALIZE ANSWER AC
	MOVE D,[POINT 6,A]	;SET UP SIXBIT BYTE POINTER
	MOVEI C,6		;ONLY 6 CHARACTER NAME ALLOWED
.GTLOP:	ILDB E,B
	JUMPE E,CPOPJ		;END OF STRING
	SUBI E,40		;TRANSLATE TO 6-BIT
	IDPB E,D		;STORE THIS CHARACTER
	SOJG C,.GTLOP		;LOOP BACK
	POPJ P,			;DO ONLY 6 CHARACTERS

.GTSPP:	MOVE A,SEGPPN		;GET HIGH SEG PPN IF ANY
	JRST STOTC1		;GO RETURN IT TO USER

.GTSNM:	MOVE A,SEGNAM		;GET HIGH SEG NAME IF ANY
	JRST STOTC1		;SKIP RETURN TO CALLER

.GTDEV:	PUSHJ P,.GTIDX		;CHECK INDEX VALUE
	JRST RETZR1		;RETURN 0 FOR ALL OTHER JOB #'S
	SKIPA A,SEGDEV		;GET HIGH SEG DEVICE
	JRST CMRETN		;GETTAB FOR DEVICE OF LOW SEG IS ILLEGAL
	JRST STOTC1		;GO RETURN VALUE TO CALLER

.GTWSN:	HLRZ C,CAC		;GET INDEX
	CAIL C,.GTWLN		;GET LENGTH OF TABLE
	  JRST RETZER		;FAIL
	MOVE A,.GTWTB(C)	;GET SIXBIT QUEUE STATES
	JRST STOTC1

.GTWTB:	SIXBIT/RNWSTS/
	SIXBIT/DSAUMQ/
	SIXBIT/DACBD1/
	SIXBIT/D2DCMT/
	SIXBIT/CAIOTI/
	SIXBIT/DISLNU/
	SIXBIT/STJD/
.GTWLN=.-.GTWTB

.GTCNF:	HLRZ C,CAC		;GET INDEX
	CAILE C,CNFMAX		;IN BOUNDS?
	  JRST CMRETN		;NO
	MOVEI A,CNFTBV		;GET ADR OF BIT TABLE
	MOVEI B,CNFTBC		;AND COUNT TABLE
	PUSHJ P,.GTDSP		;GET DISPATCH INDEX
	  JRST CMRETN		;NO IMPLIMENTED
	XCT CNFTBL(C)		;DO THE FUNCTION
	JRST STOTC1		;GO STORE VALUE AND SKIP RETURN

.GTCNM:	SYSGET (<SYSVER>)	;GET TABLE NUMBER OF VERSION
	HLRE C,B		;GET NEG NUMBER OF ENTRIES
	MOVMS C			;MAKE IT POSITIVE
	HLRZ A,CAC		;GET WORD NUMBER WANTED
	CAML A,C		;IS IT IN BOUNDS?
	JRST CMRETN		;NO!
	HLLZ A,CAC		;SET UP FOR GETAB
	HRR A,B			;GET TABLE #
	GETAB
	JRST CMRETN		;GETAB FAILED
	JRST STOTC1		;RETURN VALUE TO USER

.GTCTM:	AOS (P)			;SKIP RETURN
	JRST TIMER		;LET TIMER ROUTINE DO THE WORK
.GTCDT:	AOS (P)			;SKIP RETURN
	JRST DATE		;LET DATE UUO DO THE WORK

.GTCJN:	HRRO A,NJOBS		;ANSWER IS HGHSGN,,NJOBS
	JRST STOTC1

.GTPTY:	SYSGTA (<PTYPAR>)	;GET # OF TTY'S
	HLRZ A,A		;GET NUM OF PTY'S
	HRL A,FIRPTY		;GET FIRST PTY # IN LH
	JRST STOTC1		;SKIP RETURN

.GTNSW:	HLRZ C,CAC		;GET INDEX
	CAILE C,NSWMAX		;IN BOUNDS?
	  JRST CMRETN		;NO
	MOVEI A,NSWTBV		;GET ADR OF BIT TABLE
	MOVEI B,NSWTBC		;AND COUNT TABLE
	PUSHJ P,.GTDSP		;GET DISPATCH
	  JRST CMRETN		;NOT SUPPORTED
	XCT NSWTBL(C)		;DO FUNCTION
	JRST STOTC1		;STORE VALUE

.GTOHT:	SYSGET (<SYSTAT>)	;GET OVERHEAD TIME
	HRLI A,2		;ITEM 2 IN SYSTAT TABLE
	JRST .GTLS1		;GO RETURN IT TO USER

.GTLST:	SYSGET (<SYSTAT>)	;GET LOST TIME
	HRLI A,1
.GTLS1:	HRR A,B
	GETAB
	  JRST CMRETN
.GTJIF:	AOS (P)
.GTJF1:	MOVEI E,^D60		;GET TIME IN JIFFIES
	JRST RUNTM2

.GTNUP:	TIME
	JRST .GTJIF

.GTKTM:	SYSGET (<DWNTIM>)	;GET TABLE NUMBER OF CEASE TABLE
	HRRZ A,B		;SET UP FOR GETAB
	GETAB			;GET DOWN TIME
	  JRST CMRETN
	JUMPE A,STOTC1		;IF NOT SET, RETURN 0
	CAMN A,[-1]		;IS SHUTDOWN PAST
	JRST STOTC1		;YES, RETURN -1
	PUSH P,A		;SAVE SHUTDOWN TIME
	GTAD			;GET CURRENT TIME
	HRRZ B,0(P)		;GET SHUTDOWN SECONDS FROM MIDNIGHT
	HRRZ C,A		;GET CURRENT SECS
	SUB B,C			;GET DIFFERENCE
	HLRZS A			;GET DAYS IN RH OF A
	HLRZ C,0(P)		;GET SHUT DOWN DAYS
	JUMPGE B,GTKTM1		;IF OVERFLOWED,
	ADDI B,^D24*^D3600	;ADD IN A DAY
	SOS C			;DECREMENT DAYS
GTKTM1:	SUBM C,A		;GET DAYS TIL SHUTDOWN
	IMULI A,^D24*^D60	;CONVERT TO MINUTES
	IDIVI B,^D60		;TURN SECONDS INTO MINUTES
	ADD A,B			;TOTAL SECONDS TIL SHUTDOWN
	SKIPGE A		;ALREADY GONE BY?
	  SETO A,		;YES, RETURN -1
	POP P,(P)		;CLEAR OUT STACK
	JRST STOTC1


.GTNMS:	MOVE A,[SIXBIT/NCPGS/]	;GET USER CORE AVAILABLE
	SYSGT
	ASH A,9			;PAGES TO WORDS
	JRST STOTC1

.GTSGN:	PUSHJ P,.GTIDX		;GET INDEX TYPE
	JRST RETZR1		;RETURN 0 FOR ALL OTHER JOBS
	JRST CMRETN		;HIGH SEG NOT ALLOWED
	HRRZ 1,JBHRL		;GET HIGH SEG SIZE
	JUMPE 1,RETZR1		;IF ZERO THEN RETURN ZERO
	MOVE A,HGHSGN		;GET HGHSGN VALUE
	HRLI A,200000		;MARK THAT HIGH SEG IS SHARABLE
	JRST STOTC1		;GO STORE THIS VALUE

.GTNAM:	PUSHJ P,.GTIDX		;IS THIS A REQUEST FOR THIS JOB
	JRST .GTNMJ		;GO GET NAME OF OTHER JOBS
	 JRST CMRETN		;HIGH SEG IS ILLEGAL
	GJINF			;GET JOB INFO
	MOVE B,A		;ALWAYS USE LOGGED IN NAME
.GTNM1:	HRROI A,STRNG1		;SET UP STRING POINTER
	DIRST			;TRANSLATE NUMBER TO ASCII STRING
	  JRST CMRETN		;NO TRANSLATION
	PUSHJ P,SEVN26		;TRANSLATE TO SIXBIT
	HRRZ C,CAC		;GET GETTAB INDEX
	CAIE C,32		;WAS THIS A REQUEST FOR THE SECOND WORD
	JRST STOTC1		;NO, RETURN THIS VALUE
	LDB A,B			;GET LAST CHAR SEEN
	JUMPE A,RETZR1		;IF ZERO, DONT RETURN GARBAGE FROM STRNG1
	PUSHJ P,SVN26B		;GO GET SECOND SIX CHARACTERS
	JRST STOTC1		;RETURN SECOND WORD

.GTNMJ:	HLRZ A,CAC		;GET JOB NUMBER
	HRROI B,D		;GET LOGGED IN DIR NUMBER
	MOVEI C,.JIUNO
	GETJI
	  JRST RETZR1		;ILLEGAL OR NOT LOGGED IN
	SKIPN B,D		;IS JOB LOGGED IN?
	  JRST RETZR1		;NO
	JRST .GTNM1		;YES, GO GIVE NAME TO CALLER

.GTKCT:	SKIPA E,[^D60*^D20]	;ASSUME AVERAGE 20K CORE
.GTTIM:	MOVEI E,^D60		;GET JIFFIES
	PUSHJ P,.GTIDX
	JRST [	AOS (P)
		HLRZS CAC
		JUMPE CAC,NULTIM ;GIVE NULL TIME FOR JOB 0
		JRST RUNTM0]	;SAME AS RUMTIM UUO
	JRST CMRETN		;ILLEGAL FOR HIGH SEG
	AOS (P)
	JRST RUNTM9		;GET OWN JOB'S RUNTIM

.GTNUL:	AOS (P)			;SET UP FOR SKIP RETURN
NULTIM:	MOVE A,[SIXBIT/SYSTAT/]	;GET NULL TIME FROM WORD 0 OF SYSTAT TAB
	SYSGT
	MOVE D,A		;SAVE NULLTIME
	HRLI A,1		;NOW GET LOST TIME
	HRR A,B
	GETAB
	  JRST [SOS 0(P)	;DECREMENT SKIP RETURN
		JRST CMRETN]
	ADD A,D			;TOPS-10 NULL TIME = LOST + IDLE
	JRST .GTJF1		;GO CHANGE UNITS TO JIFFIES

.GTSWP:	PUSHJ P,.GTIDX		;CHECK LEGALITY OF #
	JRST RETZR1		;OTHER JOB = 0
	SKIPA A,JBHRL		;GET SIZE OF HIGH SEG
	JRST RETZR1
	AOS A			;MAKE IT PAGES
	LSH A,-9
	JRST STOTC1

.GTTTY:	PUSHJ P,.GTIDX		;CHECK LEGALITY OF #
	JRST [	HLRZ C,CAC	;GET JOB #
		JRST .GTTY1]
	JRST CMRETN		;ILLEGAL FOR HIGH SEG
	MOVE C,JOB		;GET THIS JOB'S JOB NUMBER
.GTTY1:	HRRZ A,C		;GET JOB NUMBER
	HRROI B,D		;GET TTY NUMBER FOR THIS JOB
	MOVEI C,.JITNO
	GETJI
	 JRST [	CAIE A,GTJIX4	;NOT LOGGED IN ERROR?
		JRST CMRETN	;NO, ILLEGAL JOB NUMBER
		JRST RETZR1]	;YES, RETURN 0
	MOVE A,D		;GET TTY NUMBER
	JRST STOTC1		;AND RETURN IT

.GTLVD:	HLRZ C,CAC		;GET INDEX
	CAILE C,LVDMAX		;WITHIN BOUNDS?
	  JRST CMRETN		;NO
	MOVEI A,LVDTBV		;GET ADR OF BIT TABLE
	MOVEI B,LVDTBC		;AND TABLE OF COUNTS
	PUSHJ P,.GTDSP		;GET DISPATCH VALUE
	  JRST CMRETN		;NOT LEGAL
	XCT LVDTBL(C)		;GET ANSWER
	JRST STOTC1		;RETURN IT TO USER

.GTC0V:	HLRZ C,CAC		;GET INDEX
	CAILE C,C0VMAX		;WITHIN BOUNDS?
	  JRST CMRETN		;NO
	MOVEI A,C0VTBV		;GET ADR OF BIT TABLE
	MOVEI B,C0VTBC		;AND TABLE OF COUNTS
	PUSHJ P,.GTDSP		;GET DISPATCH VALUE
	  JRST CMRETN		;NOT IMPLEMENTED
	XCT C0VTBL(C)		;GET ANSWER
	JRST STOTC1		;RETURN IT TO USER

.GTLIM:	PUSHJ P,.GTIDX		;CHECK JOB #
	JRST [	HLRZ C,CAC	;GET JOB #
		JRST .GTLM1]
	JRST CMRETN		;ILLEGAL FOR HI SEG
	MOVE C,JOB		;OURSELF
.GTLM1:	HRRZ A,C		;SET UP FOR GETJI
	MOVE B,[-2,,C]		;-LENGTH,,BLOCK
	MOVEI C,.JIRTL		;WORD TO START AT
	GETJI
	 JRST CMRETN		;BOO... HISS...
	MOVSI A,(677B9)		;RETURN INFINITE CORE LIMIT MINUS PA1050
	SKIPE D			;BATCH JOB?
	TXO A,1B10		;YES, LIGHT JB.LBT
	IMULI C,^D1000		;CONVERT MSEC TO SEC
	IDIVI C,^D60		; AND SEC TO JIFFIES
	HRR A,C			;STUFF INTO AC 1
	JRST STOTC1		;AND RETURN

.GTUPM:	PUSHJ P,.GTIDX		;FOR WHO?
	 JRST CMRETN		;ILLEGAL FOR OTHER JOBS
	 CAIA			;OK FOR OUR HI SEG
	JRST CMRETN		;ILLEGAL FOR OUR JOB
	SKIPE A,JBHRL		;ANY HI SEG? (0 IF NONE)
	MOVS A,HSORG		;YES, RETURN HI SEG ORIGIN IN LEFT HALF
	JRST STOTC1		;RETURN TO USER

.GTRDV:	PUSHJ P,.GTIDX
	 JRST RETZR1		;RETURN 0 IF NOT US
	 SKIPA A,SEGDEV		;SEGMENT
	MOVE A,LOWDEV		;PROGRAM
	JRST STOTC1

.GTRDI:	PUSHJ P,.GTIDX
	 JRST RETZR1		;RETURN 0 IF NOT US
	 SKIPA A,SEGPPN		;SEGMENT
	MOVE A,LOWPPN		;PROGRAM
	JRST STOTC1

;SET UP MAIN DISPATCH TABLE FOR GETTAB UUO

DEFINE GTDEF (A),<
XLIST
	GTGEN (<JRST .GTSTS>,0,A)
	GTGEN (<JRST .GTADR>,1,A)
	GTGEN (<JRST .GTPPN>,2,A)
	GTGEN (<JRST .GTPRG>,3,A)
	GTGEN (<JRST .GTTIM>,4,A)
	GTGEN (<JRST .GTKCT>,5,A)
	GTGEN (<JRST .GTSWP>,7,A)
	GTGEN (<JRST .GTTTY>,10,A)
	GTGEN (<JRST .GTCNF>,11,A)
	GTGEN (<JRST .GTNSW>,12,A)
	GTGEN (<JRST .GTSGN>,14,A)
	GTGEN (<JRST .GTLVD>,16,A)
	GTGEN (<JRST .GTDEV>,24,A)
	GTGEN (<JRST .GTWSN>,25,A)
	GTGEN (<JRST .GTNAM>,31,A)
	GTGEN (<JRST .GTNAM>,32,A)
	GTGEN (<JRST .GTLIM>,40,A)
	GTGEN (<JRST .GTC0V>,56,A)
	GTGEN (<JRST .GTUPM>,100,A)
	GTGEN (<JRST .GTRDV>,135,A)
	GTGEN (<JRST .GTRDI>,136,A)
LIST
>

	GTABLE (.GT)	;GENERATE .GTTBL,.GTTBC,.GTTBV, AND .GTMAX

;SET UP CONFIGURATION TABLE DISPATCH (TABLE 11)

DEFINE GTDEF (NAM),<
XLIST
	GTGEN (<JRST .GTCNM>,0,NAM)
	GTGEN (<JRST .GTCNM>,1,NAM)
	GTGEN (<JRST .GTCNM>,2,NAM)
	GTGEN (<JRST .GTCNM>,3,NAM)
	GTGEN (<JRST .GTCNM>,4,NAM)
	GTGEN (<JRST .GTCNM>,5,NAM)
	GTGEN (<JRST .GTCNM>,6,NAM)
	GTGEN (<MOVSI A,'DSK'>,7,NAM)
	GTGEN (<JRST .GTCTM>,10,NAM)
	GTGEN (<JRST .GTCDT>,11,NAM)
	GTGEN (<MOVEI A,0>,12,NAM)	;SIZE OF MONITOR
	GTGEN (<JRST .GTCJN>,15,NAM)	;# OF JOBS IN SYSTEM
	GTGEN (<SETO A,>,16,NAM)	;DUAL REGISTER SOFTWARE SUPPORTED
	GTGEN (<MOVSI A,751317>,17,NAM)	;DISK SYSTEM
	GTGEN (<JRST .GTPTY>,22,NAM)	;XWD PTY TO TTY CORR, # OF PTY'S
	GTGEN (<MOVEI A,40000>,112,NAM)	;TOPS-20 MONITOR
LIST
>

	GTABLE (CNF)		;GENERATE CNFTBL, CNFTBC, CNFTBV, CNFMAX

;SET UP NON-SWAPING DATA TABLE (TABLE 12)

DEFINE GTDEF (NAM),<
XLIST
	GTGEN (<MOVSI A,1>,10,NAM)	;CORMAX
	GTGEN (<JRST .GTNUP>,15,NAM)	;UP TIME
	GTGEN (<JRST .GTCJN>,20,NAM)	;HIGHEST JOB NUMBER AVAILABLE
	GTGEN (<JRST .GTLST>,22,NAM)	;LOST TIME
	GTGEN (<JRST .GTNMS>,23,NAM)	;USER CORE AVAILABLE
	GTGEN (<MOVSI A,1>,34,NAM)	;HIGHEST VALUE OF CORMAX
	GTGEN (<JRST .GTKTM>,35,NAM)	;KSYS TIME
LIST
>

	GTABLE (NSW)

;SET UP LEVEL-D TABLE (TABLE 16)

DEFINE GTDEF (NAM),<
XLIST
	GTGEN (<MOVE A,[1,,1]>,0,NAM)	;MFD PPN
	GTGEN (<MOVE A,[1,,4]>,1,NAM)	;SYS PPN
	GTGEN (<MOVE A,[1,,2]>,2,NAM)	;FAILSAFE PPN
	GTGEN (<MOVE A,[3,,3]>,4,NAM)	;SPOOLER PPN
	GTGEN (<MOVSI A,(STDPRT)>,12,NAM) ;STANDARD PROTECTION
	GTGEN (<MOVSI A,775000>,13,NAM)	;STANDARD UFD PROTECTION
	GTGEN (<MOVSI A,'DSK'>,15,NAM)	;SPOOLER PPN
	GTGEN (<MOVSI A,077000>,20,NAM)	;PROTECTION OF SPOOLED FILES
	GTGEN (<MOVSI A,155000>,21,NAM)	;SYSTEM FILE PROTECTION
	GTGEN (<MOVSI A,157000>,22,NAM)	;FILE PROTECTION FOR SYS FILES
LIST
>

	GTABLE (LVD)

;TABLE 56 - CPU0 CDB VARIABLE TABLE

DEFINE GTDEF (NAM),<
XLIST
	GTGEN (<JRST .GTNUP>,5,NAM)	;UPTIME IN JIFFIES
	GTGEN (<JRST .GTLST>,12,NAM)	;LOST TIME IN JIFFIES
	GTGEN (<JRST .GTNUL>,37,NAM)	;NULL TIME IN JIFFIES
	GTGEN (<JRST .GTOHT>,42,NAM)	;OVERHEAD TIME IN JIFFIES
LIST
>

	GTABLE (C0V)
SUBTTL	UUO'S NOT EXECUTED VERY OFTEN

SYSPHY:
SYSSTR:	JUMPE CAC,SYSTR1	;IF 0 RETURN 'DSK'
IFN FTFILSER,<
	MOVE A,CAC		;GET DEVICE NAME
	PUSHJ P,DPACHK		;SEE IF IT IS A TOPS-10 PACK
	  SKIPA			;IT ISNT
	JRST TDOUUO		;YES, GO CALL FILSER
>
	CAME CAC,[SIXBIT/DSK/]	;IS IT DSK?
	 JRST SYSTR2		;NO, CHECK IF OTHER STR
	TDZA A,A		;FENCE, RETURN ZERO
SYSTR1:	MOVSI A,'DSK'		;RETURN DSK
	JRST STOTC1

SYSTR2:	MOVE D,CAC		;GET NAME
	PUSHJ P,CHKDSK		;SEE IF IT IS A DSK
	 JRST MRETN		;NO
	JRST RETZR1		;YES, MAKE IT BE AT THE END

GETSTR:	MOVEI A,1		;SET A POSITIVE
	CAMN B,[-1]		;-1 = DSK
	  MOVSI A,'DSK'
	CAMN B,[SIXBIT/DSK/]	;DSK = 0
	  SETZ A,
	SKIPN B			;0 = -1
	  MOVNI A,1
	JUMPG A,CPOPJ		;A POSITIVE MEANS ILLEGAL VALUE IN B
	JRST CPOPJ1		;SKIP RETURN

JOBSTR:	UMOVE B,(CAC)		;GET LOC
	PUSHJ P,GETSTR		;GET STR VALUE OF NEXT STR
	  JRST MRETN		;ILLEGAL VALUE IN LOC
	UMOVEM A,(CAC)		;STORE ANSWER
	HLRZ B,CAC		;GET NUMBER OF ARGS
	CAIGE B,3		;ENOUGH FOR STATUS
	  JRST MRETN2		;NO, SKIP RETURN
	XCTUU <SETZM 2(CAC)>	;YES, RETURN ZERO AS STATUS
	JRST MRETN2

GOBSTR:	HLRZ D,CAC		;GET COUNT
	UMOVE B,2(CAC)		;GET STR VALUE
	PUSHJ P,GETSTR		;TRANSLATE IT
	  JRST GOBST1		;ILLEGAL, GO GIVE ERROR RETURN
	UMOVEM A,2(CAC)		;STORE ANSWER
	CAIGE D,5		;ENOUGH ROOM FOR STATUS
	  JRST MRETN2		;NO
	XCTUU <SETZM 4(CAC)>	;YES, GIVE ZERO
	JRST MRETN2
GOBST1:	SKIPA A,[3]		;RETURN 3
GOBST2:	MOVEI A,6		;RETURN 6
	JRST STOTAC		; IN USERS AC

STRUUO:
IFN FTFILSER,<
	UMOVE A,1(CAC)		;GET STRUCTURE NAME
	PUSHJ P,DPACHK		;SEE IF THIS IS A TOPS-10 PACK
	  SKIPA			;IT ISNT
	JRST TDOUUO		;YES, CALL FILSER
>
	SETZ A,			;INITIALIZE ANSWER
	HLRZ D,CAC		;GET N
	CAIE D,4		;4 IS THE ONLY ALLOWED VALUE
	  JRST STRU1		;GIVE 4 ERROR RETURN
	XCTUU<SKIPE (CAC)>	;0 IS THE ONLY FUNCTION IMPLEMENTED
	  JRST STOTAC		;GO RETURN 0 TO USER
	UMOVE B,1(CAC)		;GET STR
	CAME B,[SIXBIT/DSK/]	;DSK IS THE ONLY ONE ALLOWED
	  AOJA A,STOTAC		;GO GIVE 1 ERROR
	JRST MRETN2		;OK, GIVE SKIP RET
STRU1:	MOVEI A,4		;GIVE 4 ERROR
	JRST STOTAC

DEVPPN:	MOVE A,CAC		;GET ARGUMENT, DEV NAME OR CHNL #
	PUSHJ P,GDVPPN		;GET PPN OF DEVICE
	  JRST MRETN		;NOT A DSK
	MOVE A,B		;GET PPN
	JRST STOTC1		;RETURN IT TO USER

GDVPPN:	PUSH P,A		;SAVE ARG, EITHER DEV NAME OR CHANEL #
	SKIPL A			;CHECK FOR A CHANNEL #  0-17
	CAILE A,17
	  SKIPA 		;NOT A CHANNEL
	JRST [	IMULI A,NTABS	;GET INDEX INTO CHANNEL TABLES
		MOVE B,DEVNAM(A) ;GET DEVICE NAME
		MOVEM B,0(P)	;STORE DEVICE NAME INSTEAD OF CHANNEL #
		MOVE A,DIRNUM(A) ;GET DIRECTORY NUMBER OF FILE
		JRST GDVPPD]	;GO TRANSLATE TO PPN
	PUSHJ P,GETPHY		;SEE IF THERE IS A PPN FOR THIS DEV
	  JUMPE B,GDVPP0	;NO LOGICAL NAME OR NO DIR NUM
	JUMPE B,GDVPP1		;NO PPN FOR THIS LOGICAL NAME
GDVPD0:	MOVE A,B		;GET DIR NUMBER
GDVPPD:	PUSHJ P,PPNUNM		;GET PPN FROM DIR NUMBER
GDVPD1:	MOVE B,A		;RETURN WITH PPN IN B
	POP P,A			;AND DEV NAME IN A
	JRST CPOPJ1		;GIVE SKIP RETURN

GDVPP0:	MOVE A,0(P)		;GET BACK DEVICE NAME
	CAME CAC,[SIXBIT/SYS/]	;SYS?
	  JRST GDVPP1		;NO, GIVE ERROR RETURN
	MOVE B,[XWD 1,4]	;RETURN SYS PPN
	JRST GDVPD1

GDVPP1:	MOVE D,0(P)		;NOW CHECK FOR DSK
	PUSHJ P,CHKDSK
	  JRST APOPJ		;NOT A DSK
	GJINF			;GET CONNECTED DIR
	JRST GDVPD0		;GO RETURN OWN PPN

;ROUTINE TO GET THE PHYSICAL DEVICE NAME FROM A LOGICAL NAME
;CALL:
;	MOVE A,SIXBIT DEVICE NAME
;	PUSHJ P,GETPHY
;	  NO LOGICAL NAME FOR THIS DEVICE
;	LOGICAL NAME IS IN A (SIXBIT)
;	DIR NUMBER OF DEVICE IN B (0 IF NONE SPECIFIED)

;GETPHY USES DEVNM7 AND STRNG1 AS SCRATCH STRINGS

GETPHY:	PUSH P,A		;SAVE SIXBIT NAME
	MOVE D,A		;GET SIXBIT NAME INTO ASCII
	HRROI E,STRNG1
	PUSHJ P,SIXTO7		;CONVERT IT TO ASCII IN STRNG1
	MOVEI B,":"		;ADD A COLON AFTER DEVICE
	IDPB B,E
	MOVEI B,0		;FOLLOWED BY A NULL
	IDPB B,E
	HRROI B,STRNG1		;NOW GET A DIR NUMBER FOR THIS DEV
	MOVX A,RC%EMO		;NO RECOGNITION
	RCDIR			;GET DIR NUMBER
	 ERJMP [MOVEI C,0	;NO SUCH DEVICE, SET DIR # TO 0
		JRST GETPH0]	;AND CONTINUE ON
	TXNE A,RC%NOM!RC%AMB	;DID THIS SUCCEED?
	JRST GETPH1		;NO, NO SUCH DEVICE
GETPH0:	HRROI A,STRNG1		;NOW GET PHYSICAL DEVICE
	STDEV			;GET DEVICE DESIGNATOR
	 ERJMP GETPH1
	DEVST			;AND BACK TO THE PHYSICAL NAME
	 ERJMP GETPH1
	PUSH P,C		;SAVE THE DIRECTORY NUMBER
	PUSHJ P,SEVN26		;GET SIXBIT DEVICE NAME
	POP P,B			;RETURN DIR NUMBER IN B
	POP P,(P)		;CLEAN UP STACK
	JRST CPOPJ1		;GIVE SUCCESSFUL RETURN

GETPH1:	MOVEI B,0		;NO DIR
	JRST APOPJ		;EXIT CLEANING UP THE STACK

DVNAM.:	TLNE CAC,-1		;SIXBIT NAME?
	JRST DEVNM1		;YES
	TRZE CAC,200000		;UDX OF TTY?
	JRST [	MOVE B,CAC	;GET LINE NUMBER
		PUSHJ P,LIN26	;GET SIXBIT NAME
		JRST STOTC1]	;AND GIVE IT TO USER
	SKIPL CAC		;CHECK FOR A CHANNEL NUMBER
	CAILE CAC,17
	  JRST DEVNM1		;NOT A CHANNEL #
	IMULI CAC,NTABS		;GET INDEX INTO CHANNEL TABLES
	SKIPE A,DEVNAM(CAC)	;IS THERE A DEVICE ON THIS CHANNEL
	  JRST STOTC1		;YES, GO RETURN ITS NAME
	JRST MRETN		;NO, GIVE ERROR RETURN

DEVNM1:	MOVE A,CAC		;GET SIXBIT DEV NAME FOR GETPHY
	PUSHJ P,GETPHY
	  SKIPA A,CAC		;NONE, USE WHAT WAS GIVEN BY USER
	EXCH CAC,A		;USE THIS PHYSICAL NAME
	HRROI A,STRNG1		;NOW SEE IF DEVICE EXISTS
	STDEV
	  JRST DEVNM2		;IT DOES NOT EXIST
	MOVE A,CAC		;RETURN SAME NAME
	JRST STOTC1

DEVNM2:
IFN FTFILSER,<
	MOVE A,CAC		;SEE IF THIS IS A TOPS-10 PACK
	PUSHJ P,DPACHK
	  JRST DEVNM5		;NO
	MOVE A,B		;YES, GET ACTUAL NAME
	JRST STOTC1		;AND RETURN IT TO THE USER
>
DEVNM5:	MOVS B,CAC		;CHECK GENERIC NAMES NOW
	SETZB AC,BB		;START AT CHANNEL 0
DEVNM3:	HLRZ A,DEVNAM(BB)	;GET LEFT HALF NAME ONLY
	CAMN A,B		;IS THIS A MATCH?
	  JRST DEVNM4		;YES, GO RETURN ACTUAL DEVICE
	ADDI BB,NTABS
	CAILE AC,17		;LOOKED AT ALL CHANNELS?
	  AOJA 17,DEVNM3	;NO, LOOP BACK
	JRST MRETN		;YES, GIVE ERROR RETURN

DEVNM4:	MOVE A,DEVNAM(BB)	;GET FULL DEVICE NAME
	JRST STOTC1		;GIVE IT TO USER

MTCHR:	SKIPL BB,CAC		;CHECK FOR CHANNEL #
	CAILE BB,17
	  JRST MTCHR1		;NOT A CHANNEL #
	IMULI BB,NTABS		;GET CHANNEL INDEX
MTCHR0:	LDB AA,PDVNUM		;GET NUMERIC DEVICE TYPE
	CAIE AA,MTA		;IS IT A MTA
	  JRST MTCHR2		;NO, THIS IS AN ERROR
	HRRZ A,JFNTAB(BB)	;GET JFN OF TAPE
	MOVEI B,.MORDN		;READ IN DENSITY
	MTOPR
	 ERJMP MTCHR3		;NOT SET YET
	PUSH P,C		;(326) save density
	GDSTS			;(326) get device status
MTCHR4:				;(326)
	HLRZS C			;(326) right-justify byte count
	PUSH P,C		;(326) save byte count
	MOVEI B,.MORDM		;(326) read tape data mode (JFN already set)
	MTOPR			;(326) should never return 0 == system default
	  ERJMP [POP P,C	;FAILED, RESTORE AC
		 SETZ C,	;MAKE ZERO
		 JRST MTCHR5]	;AND RETURN RESULT
	HLRZ B,TPRDMT(C)	;(326) get bytes per word
	POP P,C			;(326) get byte count
	IDIV C,B		;(326) convert bytes to words
	SKIPE D			;(326) round up to next higher word
	  AOS C			;(326) if needed
MTCHR5:	POP P,A			;(326) get density
	HRL A,C			;(326) put in word count
	JRST STOTC1		;RETURN ANSWER

MTCHR3:	GDSTS			;(326) get device chars (JFN already set)
	LDB B,[POINT 2,B,28]	;(326) get density
	SKIPN B			;(326) is it 0 ?
	  MOVEI B,3		;(326) yes, make it 3
	PUSH P,B		;(326) save density
	JRST MTCHR4		;(326) C already set by GDSTS

MTCHR1:	MOVEI D,17		;SEARCH FOR THIS DEV INITED
	TDZA E,E
	ADDI E,NTABS
	CAME CAC,DEVNAM(E)	;IS THIS A MTACH
	  SOJGE D,.-2		;NO, KEEP LOOKING
	JUMPL D,MTCHR2		;NO MATCH, GO GIVE ERROR RET
	MOVE BB,E
	JRST MTCHR0		;GO SEE IF THIS IS A MTA

MTCHR2:	SETO A,
	JRST STOTAC

;TRMOP UUO SIMULATION

.TRMOP:	UMOVE C,1(CAC)		;GET IO INDEX
	TRC C,200000		;CHECK ITS LEGALITY
	MOVE A,[SIXBIT/TTYJOB/]
	SYSGT			;GET MAX # OF TTY'S SUPPORTED
	HLRES B			;...
	MOVNS B			;MAKE COUNT POSITIVE
	CAMLE C,B		;IS THIS A GOOD TTY #
	  JRST RETZER		;NO, GIVE ERROR RETURN
	UMOVE C,2(CAC)		;GET SET VALUE
	UMOVE A,1(CAC)		;GET IO INDEX
	TRC A,600000		;CHANGE INDEX TO TTY NUMBER
	XCTUM <HRRZ B,0(CAC)>	;GET FUNCTION TO BE DONE
	TRNN B,777000		;FUNCTION TYPE 0?
	  JRST TRMOP0		;YES
	TRNN B,776000		;FUNCTION TYPE 1?
	  JRST TRMOP1		;YES
	TRNE B,775000		;FUNCTION TYPE 2?
	  JRST MRETN		;NO, THEN THIS IS AN ERROR
	ANDI B,777		;GET INDEX INTO FUNCTION TABLE
	CAIL B,TRMRSL		;WITHIN BOUNDS?
	  JRST MRETN		;NO, ERROR
	HLRZ D,TRMRST(B)	;GET ADR OF FUNCTION TO BE DONE
	JRST (D)		;GO DO SET FUNCTION SPECIFIED

TRMOP1:	ANDI B,777		;GET FUNCTION INDEX
	CAIL B,TRMRSL		;WITHIN BOUNDS?
	  JRST MRETN		;NO, ERROR
	HRRZ D,TRMRST(B)	;GET ADR OF ROUTINE
	JRST (D)		;GO DO IT

TRMOP0:	CAIL B,TRM0TL		;WITHIN BOUNDS?
	 JRST MRETN		;NO, ERROR
	JRST @TRM0TB(B)		;GO DO FUNCTION

TRM0TB:	MRETN			;0 NOT IMPLEMENTED
	TOSIP			;1 SKIP IF INPUT BUFFER NOT EMPTY
	TOSOP			;2 SKIP IF OUTPUT BUFFER NOT EMPTY
	TOCIB			;3 CLEAR INPUT BUFFER
	TOCOB			;4 CLEAR OUTPUT BUFFER
TRM0TL==.-TRM0TB

TOSIP:	SIBE			;SKIP IF INPUT BUFFER FULL
	JRST MRETN2		;YES, SKIP RETURN
	PUSH P,A		;SAVE TTY NUMBER
	GJINF			;GET OUR CONTROLING TTY
	POP P,A			;GET BACK TTY NUMBER
	TRZ A,TTYDSG		;CLEAR DEVICE TYPE
	CAMN A,D		;IS THIS OUR OWN TTY
	  SKIPG TTCNT		;YES, ANY CHARS IN INTERNAL BUFFER
	JRST MRETN		;NO, THEN NO CHARACTERS
	JRST MRETN2		;THERE ARE CHARACTERS, GIVE SKIP RETURN

TOSOP:	SOBE			;SKIP IF OUTPUT BUFFER FULL
	JRST MRETN2		;YES, SKIP
	JRST MRETN		;NO, DONT SKIP

TOCIB:	CFIBF			;CLEAR MONITOR BUFFER
	PUSHJ P,TTXTST		;SEE IF THIS IS THE CONTROLING TTY
	  JRST MRETN2		;DONT CLEAR INTERNAL BUFFER
	PUSHJ P,TTCL11		;YES, CLEAR THE INTERNAL BUFFER ALSO
	JRST MRETN2		;GIVE SUCCESSFUL RETURN

TOCOB:	CFOBF			;CLEAR OUTPUT BUFFER
	JRST MRETN2		;AND RETURN

TRMRST:	MRETN,,TOOIPR		;0 OUTPUT IN PROGRESS
	MRETN,,TOCOMR		;1 - MONITOR MODE
	TOXONS,,TOXONR		;2 - TAPE MODE
	TOLCTS,,TOLCTR		;3 - LOWER CASE
	MRETN,,MRETN		;4
	TOTABS,,TOTABR		;5 - HARDWARE TABS
	TOFRMS,,TOFRMR		;6 - HARDWARE FORM FEED
	TOLCPS,,TOLCPR		;7 - LOCAL COPY
	TONFCS,,TONFCR		;10 - CR-LF SWITCH
	MRETN,,MRETN		;11
	TOWIDS,,TOWIDR		;12 - PAGE WIDTH
	MRETN,,MRETN		;13
	MRETN,,TOHLFR		;14 - HALF DUPLEX
	MRETN,,MRETN		;15
	MRETN,,MRETN		;16
	TOFLCS,,TOFLCR		;17 - FILLER CLASS
	MRETN,,MRETN		;20
	TOPAGS,,TOPAGR		;21 - TTY PAGE
	MRETN,,MRETN		;22
	TOPSZS,,TOPSZR		;23 - TTY PAGE LENGTH
	MRETN,,MRETN		;24
	MRETN,,MRETN		;25
	TOALTS,,TOALTR		;26 - SUPRESS ALTMODE CONVERSION
TRMRSL==.-TRMRST

TOOIPR:	SOBE			;OUTPUT IN PROGRESS
	  JRST TRMB1R		;YES
	JRST RETZR1		;NO

TRMB1R:	MOVEI A,1		;RETURN A 1
	JRST STOTC1		;SKIP RETURN

TOCOMR:	XCTUM <HRRZ A,1(CAC)>	;GET TTY NUMBER
	TRC A,600000		;MAKE IT 400000+TTY
	PUSHJ P,DGETJI		;DO THE GETJI
	  JRST MRETN		;ILLEGAL TTY NUMBER
	SKIPGE STRNG1+.JIJNO	;IS JOB NUMBER IN USE?
	  JRST TRMB1R		;NO, SAY IT IS IN MONITOR MODE
	PUSHJ P,SKPUSR		;MONITOR MODE?
	  JRST TRMB1R		;YES, GIVE ON RETURN
	JRST RETZR1		;NOT IN MONITOR MODE

TOXONS:	PUSHJ P,TTXTST		;SEE IF THIS IS THE CONTROLING TTY
	  JRST MRETN		;NO, FUNCTION NOT SUPPORTED
	MOVE E,TYSTAT		;GET MODE WORD
	TRNE C,1B35		;SET OR CLEAR
	  TLOA E,TT.XON		;SET
	TLZ E,TT.XON		;CLEAR
	PUSHJ P,TTPSTS		;GO SET UP NEW MODE
	JRST MRETN2		;AND RETURN

TOXONR:	PUSHJ P,TTXTST		;IS THIS THE CONTROLING TTY?
	  JRST MRETN		;NO, NOT SUPPORTED
	TLNN E,TT.XON		;IS TAPE MODE ON OR OFF
	  JRST RETZR1		;OFF
	JRST TRMB1R		;ON

TTXTST:	PUSH P,A		;SAVE ACS
	PUSH P,C
	GJINF
	POP P,C
	POP P,A
	TRO D,TTYDSG		;GET TERMINAL UNIT
	CAME A,D		;SAME AS DESIRED TTY?
	  POPJ P,		;NO, NON-SKIP RETURN
	JRST CPOPJ1		;YES, SKIP

TOLCTR:	RFMOD
	TLNE B,(1B3)		;LOWER CASE MODE ON?
	TRNE B,1B31		;AND NO CONVERSION BEING DONE?
	 JRST TRMB1R		;NO, THIS IS NOT A LOWER CASE TERMINAL
	JRST RETZR1		;LOWER CASE

TOLCTS:	RFMOD
	TRNE C,1B35		;SET OR CLEAR
;[355]	  TLZA B,(1B3)		;CLEAR
;[355]	TLOA B,(1B3)		;SET
	  TROA B,1B31		;CONVERT TO UPPER CASE
	TRZ B,1B31		;DONT CONVERT
	STPAR
	JRST MRETN2

TOTABR:	RFMOD
	TLNE B,(1B2)		;TAB?
	  JRST TRMB1R		;YES
	JRST RETZR1		;NO

TOTABS:	RFMOD
	TRNN C,1B35		;SET OR CLEAR?
	  TLZA B,(1B2)		;CLEAR
	TLO B,(1B2)		;SET
	STPAR
	JRST MRETN2

TOFRMR:	RFMOD
	TLNE B,(1B1)		;HARDWARE FORM FEED
	  JRST TRMB1R		;YES
	JRST RETZR1		;NO

TOFRMS:	RFMOD
	TRNN C,1B35		;SET OR CLEAR?
	  TLZA B,(1B1)		;CLEAR
	TLO B,(1B1)		;SET
	STPAR
	JRST MRETN2

TOLCPR:	RFMOD
	TRNE B,3B25		;LOCAL COPY ON?
	 JRST RETZR1		;NO
	JRST TRMB1R		;YES

TOLCPS:	RFMOD
	TRZ B,3B25		;ASSUME NO ECHO
	TRNN C,1B35		;SET OR CLEAR?
	  TRO B,1B24		;MAKE ECHOS HAPPEN
	SFMOD
	JRST MRETN2

TONFCR:	PUSHJ P,GETWID		;(316) GET WIDTH =0?
	JUMPE C,TRMB1R		;(316)YES, THEN CR-LF IS OFF
	JRST RETZR1

TONFCS:	TRNN C,1B35		;SET OR CLEAR?
	  JRST [PUSHJ P,GETWID	;(316)CLEAR, GET CURRENT LINE WIDTH
		JUMPN C,MRETN2	;(316)IF 0, CR CLEARED, RETURN
		SKIPGE C,TTWDTH	;(316)DO WE HAVE PREVIOUS WIDTH?
		MOVEI C,^D72	;(316)NO, SET WIDTH TO STANDARD 72
		JRST TOWIDS]	;GO SET WIDTH
	PUSHJ P,GETWID		;(316)GET LINE WIDTH
	MOVEM C,TTWDTH		;(316)REMEMBER THIS WIDTH TO RESTORE IT LATER
	JUMPE C,MRETN2		;IF ALREADY 0, RETURN
	MOVEI C,0
	JRST TOWIDS		;GO SET WIDTH TO 0

TOWIDR:	PUSHJ P,GETWID		;(316) GET LINE WIDTH
	SKIPG A,C		;(316) IF WIDTH =0
	MOVEI A,^D255		;(316) RETURN THE MAXIMUM
	JRST STOTC1		;RETURN IT TO USER

TOWIDS:	MOVEI B,.MOSLW		;(316)SET LINE WIDTH
	MTOPR			;(316)
	  ERJMP CMRETN		;(316)
	JRST MRETN2

GETWID:	MOVEI B,.MORLW		;(316)READ LINE WIDTH
	MTOPR			;(316)
	  ERJMP CMRETN		;(316)
	POPJ P,			;(316)


TOHLFR:	RFMOD
	TRNE B,3B33		;HLAF DUPLEX
	  JRST TRMB1R		;YES
	JRST RETZR1		;NO

TOALTR:	PUSHJ P,TTXTST		;SEE IF THIS IS THE CONTROLING TTY
	  JRST MRETN		;NO, ERROR
	MOVE E,TYSTAT		;GET CONTROLING STATUS
	TLNE E,TT.ALT		;CONVERTING ALTMODES?
	  JRST TRMB1R		;NO
	JRST RETZR1		;YES

TOALTS:	PUSHJ P,TTXTST		;SEE IF THIS IS THE CONTROLING TTY
	  JRST MRETN		;NO, GIVE ERROR RETURN
	MOVE E,TYSTAT		;YES
	UMOVE C,2(CAC)		;GET ARG AGAIN
	TRNN C,1B35		;SET OR CLEAR?
	  TLZA E,TT.ALT		;CLEAR
	TLO E,TT.ALT		;SET
	MOVEM E,TYSTAT
	JRST MRETN2

TOFLCR:	GTTYP			;GET TERMINAL TYPE
	CAIN B,9		;TERMINAL TYPE 9 IS NO FILLER
	  MOVEI B,0
	MOVE A,B
	JRST STOTC1		;RETURN TERMINAL TYPE

TOFLCS:	SKIPN B,C		;USER WANT NO FILL
	MOVEI B,9		;YES, GIVE HIM TYPE 9, NO FILL
	STTYP
	JRST MRETN2

TOPAGS:	RFMOD			;READ IN TTY STATUS
	TRNE C,1B35		;SET OR CLEAR?
	  TROA B,TT%PGM		;SET
	TRZ B,TT%PGM		;CLEAR
	STPAR
	JRST MRETN2

TOPAGR:	RFMOD			;READ PAGE BIT
	TRNE B,TT%PGM		;IS IT SET?
	  JRST TRMB1R		;YES, RETURN ANSWER
	JRST RETZR1		;NO

TOPSZS:	RFMOD			;SET PAGE SIZE
	DPB C,[POINT 7,B,10]
	STPAR
	JRST MRETN2

TOPSZR:	RFMOD			;READ PAGE SIZE
	LDB A,[POINT 7,B,10]
	JRST STOTC1

;**;[364] At TRMNO:, Replaced 1 line            	SM	 9-Sep-81
TRMNO:	MOVE A,CAC		;[364] GET JOB # OR -1
	PUSHJ P,DGETJI		;DO THE GETJI
	  JRST RETZER		;ILLEGAL JOB NUMBER
	SKIPL A,STRNG1+.JITNO	;IS THERE A TTY FOR THIS JOB?
	SKIPN STRNG1+.JIUNO	;AND IS IT LOGGED IN?
	  JRST RETZER		;NO
	TRO A,200000		;MAKE TTY INTO UNIVERSAL IO INDEX
	JRST STOTC1		;GIVE IT TO USER

CTLJOB:	MOVE A,CAC		;GET JOB NUMBER
	HRROI B,D		;GET ONLY ONE WORD BACK IN D
	MOVEI C,.JICPJ		;GET CONTROLING JOB IF ANY
	GETJI
	 JRST [	CAIE A,GTJIX4	;NOT LOGGED IN ERROR?
		JRST CMRETN	;NO, BAD ARGUMENT
		SETO D,		;YES, RETURN -1
		JRST .+1]
	MOVE A,D		;GET ANSWER
	JRST STOTC1		;AND RETURN IT TO USER

PATH:	UMOVE E,0(CAC)		;GET LOC
	GJINF			;GET OUR PPN INTO AC B
	HRRZ A,E		;GET RH OF ARG 0
	CAIE A,-4		;ALLOW ONLY READING OF PATHS
	CAIN A,-1
	  JRST PATH1		;GO RETURN PATH
	CAIE A,-3		;DONT ALLOW SETTING OF PATHS
	CAIN A,-2
	  JRST CMRETN
	UMOVE A,0(CAC)		;GET DEVICE NAME OR CHANNEL #
	PUSHJ P,GDVPPN		;GET ITS PPN
	  JRST PATH2		;NOT A DISK
IFN FTFILSER,<
	PUSH P,A		;SAVE DEVICE NAME
	PUSH P,B		;SAVE PPN
	PUSHJ P,DPACHK		;SEE IF THIS IS A TOPS-10 PACK
	 JRST [	POP P,B		;GET BACK PPN
		POP P,A		;GET BACK DEVICE
		UMOVEM A,0(CAC)	;STORE DEVICE NAME
		JRST PATH3]
	POP P,B			;YES
	POP P,A
	JRST TDOUUO		;GO CALL FILSER TO DO UUO
>
IFE FTFILSER,<
	UMOVEM A,0(CAC)		;STORE NEW DEVICE NAME
	JRST PATH3		;AND THEN STORE PPN

PATH1:	MOVE A,B		;GET DIR NUM
	PUSHJ P,PPNUNM		;UNMAP IT INTO A PPN
	MOVE B,A
PATH3:	UMOVEM B,2(CAC)
	PUSH P,B		;SAVE PPN
	MOVEI A,0		;GET OWN PPN
	PUSHJ P,PPNUNM
	POP P,B			;GET BACK PPN OF THIS DEV
	CAME A,B		;ARE THEY THE SAME?
	  SKIPA A,[1B30!1B35] ;NO, SET IGNORE BIT
	MOVEI A,1B29!1B35	;YES, DONT SET IGNORE BIT
	UMOVEM A,1(CAC)
	HLRZ A,CAC		;GET ARG COUNT
	CAIGE A,4		;OK TO STORE HERE
	  JRST MRETN2		;NO
	XCTUU <SETZM 3(CAC)>	;MARK END OF PATH
	JRST MRETN2

PATH2:
IFN FTFILSER,<
	UMOVE A,0(CAC)		;GET DEVICE NAME OR CHANNEL #
	TLNN A,-1		;CHANNEL NUMBER?
	CAILE A,17		;...
	JRST PATH4		;NO
	IMULI A,NTABS		;YES, GET INDEX
	MOVE A,DEVNAM(A)	;GET SIXBIT DEVICE NAME
PATH4:	PUSHJ P,DPACHK		;SEE IF IT IS A TOPS-10 PACK
	  SKIPA			;NO
	JRST TDOUUO		;YES, CALL FILSER
>
	JRST RETZR1		;RETURN A 0

;THE CHKACC UUO

CHKACC:
	JRST RETZR1		;ALWAYS SUCCEED

REPEAT 0,<			;CHKACC DOES NOT WORK WHEN CONNECTED TO
				;A DIRECTORY OTHER THAN THE LOGGED IN
				;DIRECTORY (IF USER GROUPS ARE IN USE)
	MOVE A,[1,,2]		;SEE IF THIS IS OPERATOR
	XCTUU <CAMN A,2(CAC)>	;...
	 JRST RETZR1		;YES, ACCESS IS ALWAYS ALLOWED
	XCTLB <LDB D,[POINT 9,0(CAC),35]> ;GET FIL PROT
	JUMPE D,[MOVEI D,-1	;IF 0, ASSUME NO PROTECTION
		JRST CHKAC1]
	PUSHJ P,GTPROT		;GET THE PROTECTION TRANSLATION IN D
CHKAC1:	PUSH P,D		;SAVE PROTECTION
	UMOVE A,1(CAC)		;GET THE DIR PPN
	HRROI B,[ASCIZ/DSK/]	;MUST SUPPLY A STR
	PUSHJ P,PPN2DR		;TRANSLATE IT TO A DIR NUMBER
	 JRST RETZER		;UNKNOWN PPN
	PUSH P,A		;SAVE DIR NUMBER
	UMOVE A,2(CAC)		;GET PPN OF USER
	HRROI B,[ASCIZ/DSK/]
	PUSHJ P,PPN2DR		;TRANSLATE IT TO DIR NUMBER
	 JRST RETZER		;ILLEGAL PPN
	MOVEM A,STRNG1+.CKALD	;LOGGED IN DIR
	MOVEM A,STRNG1+.CKACD	;AND ALSO CONNECTED DIR
	SETZM STRNG1+.CKAEC	;NO ENABLED CAPABILITIES
	POP P,STRNG1+.CKAUD	;SET UP DIR NUMBER
	POP P,STRNG1+.CKAPR	;AND PROTECTION
	XCTUU <HLRZ A,0(CAC)>	;GET ACCESS CODE
	CAIL A,CHKACL		;IS THIS A LEGAL CODE?
	 JRST RETZER		;NO
	MOVE A,CHKACT(A)	;GET TRANSLATED ACCESS CODE FOR JSYS
	MOVEM A,STRNG1+.CKAAC	;STORE FOR THE CHKAC JSYS
	MOVEI A,6		;SIX ARGUMENTS
	MOVEI B,STRNG1		;ADDRESS OF ARGUMENTS
	CHKAC			;CHECK THE ACCESS
	 JRST RETZER		;SOMETHING WAS BAD
	SETCA A,		;TOPS-10 LIKES IT -1=FALSE, 0=TRUE
	JRST STOTC1		;GO RETURN ANSWER

CHKACT:	.CKACF			;(0) CHANGE PROT
	.CKACF			;(1) RENAME
	.CKAWT			;(2) WRITE
	.CKAWT			;(3) UPDATE
	.CKAAP			;(4) APPEND
	.CKARD			;(5) READ
	.CKAEX			;(6) EXECUTE
	.CKACF			;(7) CREATE IN UFD
	.CKADR			;(10) READ DIRECTORY
CHKACL==.-CHKACT		;LENGTH OF TABLE
>			;END OF REPEAT 0 AROUND CHKACC

UUFDST:	TRNE PF,R.DIRN		;USETI?
	JRST MRETN		;NO, ILLEGAL
	HRRZ C,FORTY		;HOW MANY BLOCKS TO SKIP
	SOSGE C			;GET START OF BLOCK INSTEAD OF END
	  PUSHJ P,ERRARG	;ILLEGAL ARGUMENT
	ASH C,6			;100 ENTRIES PER DISK BLOCK
	MOVSI A,RDMFDF		;SEE IF WE ARE READING MFD
	TDNE A,FLAGWD(BB)	;...
	  JRST UMFDST		;YES, GO SIMULATE IT
	SKIPN LSTUFJ		;IS THERE A SAVED UFD?
	  JRST UUFDS0		;NO
	MOVE A,DIRNUM(BB)	;GET DIR NUM OF UFD
	CAMN C,LSTUFP		;IS WORD OF DIR SAME AS SAVED DIR
	CAME A,LSTUFD		;AND IS DIR NUM THE SAME AS SAVED UFD?
	  JRST UUFDS0		;NO, TOO BAD
	HRRZ A,JFNTAB(BB)	;YES, WE WILL USE THE SAVED JFN INSTEAD
	MOVE B,LSTUFJ		;GET SAVED JFN
	CAIE A,(B)		;THE SAME?
	RLJFN			;NO, RELEASE OLD JFN
	 JFCL
	MOVEM B,JFNTAB(BB)	;SAVE NEW JFN
	SETZM LSTUFJ		;CLEAR SAVED JFN WORD
	MOVEM C,IOBYTP(BB)	;STORE CORRECT POINTER WORD
	JRST UUFDSD		;USETI IS DONE
UUFDS0:	CAMGE C,IOBYTP(BB)	;DO WE NEED TO BACK UP
	  JRST UUFDS2		;YES
	SUB C,IOBYTP(BB)	;GET COUNT OF GNJFN'S TO BE DONE
	JUMPE C,UUFDSD		;NONE, JUST RETURN
UUFDS1:	MOVE A,JFNTAB(BB)	;GET FULL JFN
	GNJFN
	  JRST [MOVSI A,UFDEOF	;NO MORE ENTRIES,
		IORM A,FLAGWD(BB); SET UFDEOF FLAG
		SETZM JFNTAB(BB) ;GET RID OF RELEASED JFN POINTER
		JRST UUSETE]	; AND SET EOF FOR FUTURE INPUT'S
	AOS IOBYTP(BB)		;KEEP COUNT OF WHERE WE ARE
	SOJG C,UUFDS1		;LOOP FOR MANY TIMES
	JRST UUFDSD		;FINALLY DONE

UUFDS2:	HRRZ A,JFNTAB(BB)	;GIVE UP OLD JFN
	RLJFN
	  JFCL
	PUSHJ P,ULKUFA		;SET UP NAME AND DIRECTORY
	  JFCL
	MOVEM A,JBLOCK		;SAVE FLAGS
	MOVEI A,JBLOCK		;SET UP FOR GTJFN
	HRROI B,STRNG1
	GTJFN			;GET NEW JFN
	  PUSHJ P,ERROR		;SHOULD WORK!
	MOVEM A,JFNTAB(BB)	;STORE NEW JFN
	SETZM IOBYTP(BB)	;MARK THAT WE STARTED OVER
	JRST UUFDST		;GO TRY AGAIN

UMFDST:	CAMN C,LSTMFP		;IS THIS TO A KNOWN PLACE
	  JRST [MOVEM C,IOBYTP(BB) ;YES, SAVE POINTER
		MOVE C,LSTMFN	;GET LAST DIR NUMBER USED
		MOVEM C,MFDPT(BB)
		JRST UUFDSD]	;USETI IS DONE
	CAMGE C,IOBYTP(BB)	;DO WE NEED TO BACK UP?
	  JRST [SETZM IOBYTP(BB) ;RESET POINTER
		MOVEI A,1	;SET DIR NUM TO 1
		HRRM A,MFDPT(BB)
		JRST .+1]
	SUB C,IOBYTP(BB)	;GET COUNT OF DIR'S TO BE SKIPPED
	JUMPE C,UUFDSD		;IF NONE, JUST RETURN
UMFDS1:	PUSHJ P,RDMFD		;GET NEXT DIR
	MOVSI A,UFDEOF		;ALL THROUGH?
	TDNE A,FLAGWD(BB)	;...
	  JRST UUSETE		;YES, GO SET EOF
	SOJG C,UMFDS1		;LOOP BACK
UUFDSD:	MOVE A,[XWD UFDEOF,1B22] ;TURN OFF ALL EOF BITS
	ANDCAM A,FLAGWD(BB)
	JRST MRETN		;DONE

ULKUFA:	MOVE D,DIRNUM(BB)	;UFD HAS BEEN LOOKED UP ONCE
	JRST ULKUF1		;SO DONT NEED TO TRANSLATE DIR NUMBER

ULKUFD:	MOVE D,FILNAM(BB)	;GET UFD #
	MOVE A,DEVNAM(BB)	;GET SIXBIT STR NAME
	CAMN D,[XWD 1,1]	;IS THIS THE MFD
	  JRST ULKMFD		;YES
	PUSHJ P,GETDR0		;GET MATCHING DIRECTORY NUMBER
	  POPJ P,		;GIVE ERROR RETURN
	MOVEM D,DIRNUM(BB)	;STORE NEW DIRECTORY NUMBER
ULKUF1:	MOVSI A,RDUFDF		;MARK THAT WE ARE READING A UFD
	IORM A,FLAGWD(BB)
	HRROI A,STRNG1		;SET UP THE MAIN STRING
	MOVE B,D		;GET DIR NUMBER
	DIRST			;PUT STR:<DIR> IN MAIN STRING
	 HRROI A,STRNG1		;FAILED, RESET STRING POINTER
	HRROI B,[ASCIZ/*.*.0/]	;FINISH THE MAIN STRING
	SETZ C,
	SOUT
	MOVSI A,100100		;SET UP PROPER FLAGS
	JRST CPOPJ1		;SKIP RETURN

ULKMFD:	PUSHJ P,GETDR0		;GET A DIR NUMBER
	 POPJ P,		;NONE, FAIL RETURN
	HRRI D,1		;START AT DIR NUMBER 1
	MOVEM D,MFDPT(BB)	;INITIALIZE MFD POINTER
	MOVSI A,RDUFDF!RDMFDF	;SET PORPER FLAGS
	IORM A,FLAGWD(BB)	; IN FLAG WORD
	POP P,(P)		;DONT POPJ AND DO GTJFN
	SETOM JFNTAB(BB)	;SO OPENX WONT COMPLAIN
	JRST ULK7		;THERE IS NO JFN FOR THIS SIMULATION


INDUFD:	TLNE B,UFDEOF		;IS THIS THE END
	  JRST INDM4B		;YES, GO SET EOF BIT
	PUSH P,D		;SAVE THE COMMAND LIST POINTER
INDUF1:	MOVE D,FLAGWD(BB)	;GET FLAGS
	TLNE D,UFDEOF		;ARE WE THROUGH?
	  JRST INDUFE		;YES, GO CLEAR REST OF BUFFER
	PUSHJ P,RDUFD		;NO, GO GET NEXT FILE NAME
	JUMPE D,INDUF1		;IF NO NAME LOOP BACK
	UMOVEM D,1(C)		;STORE FILE NAME
	AOBJP C,INDUE1		;END OF COMMAND?
	UMOVEM E,1(C)		;NO, STORE EXTENSION
	AOBJP C,INDUE1		; END OF COMMAND?
	JRST INDUF1		;NO, LOOP BACK AGAIN

INDUFE:	XCTUU <SETZM 1(C)>	;ZERO THE REST OF THE COMMAND
	AOBJN C,INDUFE
INDUE1:	POP P,D
	AOJA D,INCML		;GO SEE IF MORE COMMANDS

RDUFD:	MOVE D,FLAGWD(BB)	;GET FLAGS
	TLNE D,RDMFDF		;READING MFD?
	  JRST RDMFD		;YES, GO DO IT INSTEAD
	PUSH P,C
RDUFD1:	HRRZ B,JFNTAB(BB)	;GET RH OF JFN ONLY FOR JFNS
	HRROI A,STRNG1		;SET UP TEMPORARY STRING POINTER
	MOVE C,[XWD 1100,2]	;GET NAME AND EXT SEPARATED BY TAB
	JFNS
	MOVE A,[POINT 7,STRNG1]	;NOW DO ASCII TO SIX BIT CONVERSION
	MOVE B,[POINT 6,D]
	SETZB D,E
	MOVEI C,6		;6 CHARACTER NAME ONLY
RDULP:	ILDB F,A		;GET ASCII CHARACTER
	CAIN F,C.CNTV		;CONTROL-V?
	  ILDB F,A		;YES, GET NEXT CHAR
	CAIN F,C.TAB		;TAB?
	JRST RDUEXT		;YES, GO READ THE EXTENSION
	SUBI F,40		;MAKE SIXBIT
	IDPB F,B		;STORE IN D
	SOJG C,RDULP		;LOOP BACK FOR MORE
	ILDB F,A		;SCAN FOR A TAB
	CAIE F,C.TAB		;SINCE LONGER THAN 6 CHARACTER NAMES ALLOWED
	JRST LNGFIL		;LONG FILES ARE NOT ALLOWED
RDUEXT:	MOVEI C,3		;3 CHARACTER EXTENSION MAXIMUM
	MOVE B,[POINT 6,E]
RDULP1:	ILDB F,A		;GET ASCII CHAR
	JUMPE F,RDUFDN		;DONE?
	SUBI F,40		;NO, MAKE IT SIXBIT
	IDPB F,B		;STORE IN E
	SOJG C,RDULP1		;LOOP BACK
	ILDB F,A		;GET NEXT CHARACTER IN EXTENSION
	JUMPN F,LNGFIL		;TOO LONG?  DONT ALLOW LONG FILES.
RDUFDN:	HRRZ A,JFNTAB(BB)	;GET JFN
	MOVE B,[XWD 1,7]	;SET UP TO GET FILE VERSION #
	MOVEI C,C		;INTO AC C
	GTFDB
	 ERJMP .+1
	HLR E,C			;SAVE VERSION # IN RH OF EXTENSION WORD
	AOS IOBYTP(BB)		;COUNT UP # OF FILES SEEN
	MOVE A,JFNTAB(BB)	;ADVANCE THE JFN POINTER
	GNJFN			;ADVANCE JFN
RDUFDE:	JRST [	MOVSI B,UFDEOF
		IORM B,FLAGWD(BB) ;NO MORE FILES, SET EOF FOR NEXT TIME
		SETZM JFNTAB(BB) ;MARK THAT THE JFN WAS RELEASED
		JRST .+1]
	POP P,C
	POPJ P,			;RETURN

LNGFIL:	SETZB D,E		;NO FILE NAME THIS TIME
	MOVE A,JFNTAB(BB)	;ADVANCE THE FILE POINTER
	GNJFN
	  JRST RDUFDE		;NO MORE FILES
	JRST RDUFD1		;LOOP BACK FOR NEXT FILE NAME

RDMFD:	HRROI A,STRNG1		;SET UP DUMMY STRING POINTER
	MOVE B,MFDPT(BB)	;GET CURRENT MFD POINTER
	DIRST			;SEE IF THIS DIRECTORY NUMBER EXISTS
	  JRST NODIR		;IT DOESNT
	MOVE A,MFDPT(BB)	;GET DIR NUMBER
	PUSHJ P,PPNUNM		;GET PPN
	MOVE D,A		;INTO AC D
	MOVSI E,'UFD'		;MAKE THIS A UFD ENTRY
	AOS A,MFDPT(BB)		;COUNT UP DIR POINTER
	MOVEM A,LSTMFN		;SAVE LAST NUMBER POINTED TO
	SETZM NOMFDC(BB)	;SEEN A LEGAL DIR #
	AOS A,IOBYTP(BB)	;COUNT UP BYTE POINTER
	MOVEM A,LSTMFP		;SAVE LAST MFD POINTER VALUE
	POPJ P,			;AND RETURN

NODIR:	MOVSI B,UFDEOF		;PREPARE FOR EOF
	AOS MFDPT(BB)		;COUNT UP DIR POINTER
	AOS A,NOMFDC(BB)	;GET CURRENT COUNT OF ILLEGAL DIR'S
	CAIG A,MAXDIR		;DONE?
	  JRST RDMFD		;NO, GO LOOK FOR ANOTHER DIR
	IORM B,FLAGWD(BB)	;SET EOF BIT
	SETZB D,E		;CLEAR NAME AND EXTENSION
	POPJ P,			;RETURN WITHOUT COUNTING UP IOBYTP

INUFD:	MOVN A,IOCNT		;GET NEG WORD COUNT
	HRL C,A
	HRR C,IOBPT
INUFD1:	MOVE A,FLAGWD(BB)	;GET FLAGS
	TLNE A,UFDEOF		;ARE WE DONE?
	  JRST INUFD2		;YES, GO SET EOF
	PUSHJ P,RDUFD		;NO, GO GET NEXT FILE NAME
	JUMPE D,INUFD1		;IF NO NAME DONT STORE IT
	UMOVEM D,1(C)		;STORE NAME
	UMOVEM E,2(C)		;AND EXTENSION
	ADD C,[XWD 2,2]		;UPDATE C
	SKIPGE C		;DID WE FINISH A FULL BUFFER
	JRST INUFD1		;NO, GO GET NEXT FILE NAME
INUFD2:	HLRES C			;NOW UPDATE IOCNT AND IOBPT
	ADD C,IOCNT		;GET WORDS NOT USED
	JUMPE C,INTY8A		;IF NO WORDS PUT IN BUFFER, GIVE EOF
	ADDM C,IOBPT		;UPDATE IOBPT
	MOVNS C
	ADDM C,IOCNT		;AND IOCNT
	JRST INTTY9		;AND RETURN TO USER

SLEEP:	MOVE A,CAC		;NUMBER OF SECONDS TO SLEEP
	IMULI A,^D60		;CONVERT TO JIFFIES
	ANDI A,7777		;TRUNCATE TO 12 BITS
				;THIS EXTRA CONVERSION MAKES SLEEP ^D751 WORK
				;WHICH SOME FOLKS EXPECT TO TURN INTO 4 JIFFIES
	IMULI A,^D1000		;CONVERT SECONDS TO MS
	IDIVI A,^D60		;GET IT BACK INTO MILLISECONDS
	SKIPG A			;IS TIME 0
	MOVEI A,^D16		;YES, ALWAYS SLEEP 16 MS
	PUSH P,[MRETN]		;SET UP RETURN PC
	HRRZ B,A		;SAVE LAST HIBERNATE REQUEST
	HRLI B,(HB.RPT)		;ALWAYS MAKE SLEEP WAKE ON PTY ACTIVITY
	MOVEM B,HIBWRD
	SETOM IOWATF		;ALLOW PTY'S TO WAKE US UP
	JRST IOWAT1		;GO TO SLEEP FOR SEPCIFIED AMOUNT

	HB.RTC=1B14		;WAKE ON CHARACTER READY
	HB.RTL=1B13		;WAKE ON LINE READY
	HB.RPT=1B12		;WAKE ON PTY ACTIVITY

HIBER:	PUSH P,[HIBER2]		;SET UP RETURN
	MOVEM CAC,HIBWRD	;REMEMBER LAST COMMAND
	TLNE CAC,(HB.RPT!HB.RTC!HB.RTL)
	  SETOM IOWATF		;ENABLE FOR WAKE UPS
	TLNE CAC,(HB.RTC!HB.RTL) ;ENABLED FOR TTY WAKEUP?
	  JRST STTTYF		;YES, GO START THE TTY FORK
HIBER1:	HRRZ A,CAC		;GET SLEEP TIME
	JUMPE A,IOWAIT		;IF ZERO, DO AN INFINITE SLEEP
	JRST IOWAT1		;GO SLEEP FOR SPECIFIED TIME

STTTYF:	SKIPE TTLINE		;LINE ALREADY THERE?
	  POPJ P,		;YES, RETURN IMMEDIATELY
	TLNN CAC,(HB.RTL)	;WAITING FOR A LINE?
	SKIPG TTCNT		;NO, ANY CHARACTERS ALREADY?
	SKIPA A,TTYFRK		;NO, GET TTY FORK HANDLE
	  POPJ P,		;THERE IS A CHAR, SO JUST RETURN
	JUMPN A,STTTY1		;IF THERE IS A FORK ALREADY, GO USE IT
	MOVE A,[XWD 640000,TTFKST]
	MOVEI B,0		;CREATE A FORK IN SAME SPACE WITH SAME ACS
	CFORK			;AND START IT AT TTFKST
	  PUSHJ P,ERROR		;SOMETHING WENT WRONG
	MOVEM A,TTYFRK		;SAVE FORK HANDLE
STTTY1:	FFORK			;FREEZE THE FORK
	MOVEI B,0		;SET THE ACS TO COPY OF THIS FORKS
	SFACS
	MOVEI B,TTFKST		;GET STARTING ADR
	SFORK			;START THE FORK
	TLO PF,L.TFA		;MARK THAT FORK IS NOW ACTIVE
	RFORK			;AND THAW IT
	JRST HIBER1		;THEN GO TO SLEEP

HIBER2:	SKIPN A,TTYFRK		;HERE WHEN WOKEN UP
	  JRST MRETN2		;NO TTYFRK TO FREEZE
	TLZE PF,L.TFA		;IS THE TTY FORK ACTIVE?
	  FFORK			;YES, ALWAYS FREEZE IT
	JRST MRETN2		;SUCCESFUL RETURN

TTFKST:	MOVE P,[IOWD FPDLEN,FRKPDL]
	MOVEI A,PRIJFN		;GET PRIMARY INPUT JFN
	MOVE E,TYSTAT		;GET TTY STATUS WORD
	TLNN E,TT.BIN		;BINARY MODE?
	TLNE CAC,(HB.RTC)	;OR CHARACTER MODE?
	  TLOA E,TT.BKE		;YES, SET BREAK ON EVERYTHING
	TLZ E,TT.BKE		;NO, CLEAR BKE
	PUSHJ P,TTPSTS		;SET UP NEW MODE
	PUSHJ P,TTFILL		;GO SEE IF ANY CHARACTERS THERE
	  PUSHJ P,TTFILW	;NO, GO WAIT FOR ONE
	HALTF			;HALT
	PUSHJ P,BUGSTP		;IF CONTINUED, PRINT ERROR MESSAGE

WAKE:	CAME CAC,JOB		;DOING A WAKE ON HIMSELF?
	JUMPG CAC,WAKE1		;GO WAKE THE DESIRED JOB
	SETOM WAKEF		;MARK THAT HIBER SHOULD WAKE UP ONCE
	JRST MRETN2		;SKIP RETURN

WAKE1:	HRRZ A,CAC		;GET JOB NUMBER TO BE WOKEN
	TWAKE			;WAKE IT ******** TEMPORARY
	  JFCL
	JRST MRETN2

;PTY SIMULATION ROUTINES

PTYSTF:	MOVEI B,1B19!1B20	;OPEN THE PTY FOR READ AND WRITE
	PUSHJ P,OPENX
	  POPJ P,		;OPEN FAILED, GIVE ERROR RETURN
	MOVSI B,IOPENF!OOPENF	;MARK THIS IN FLAGWD
	IORM B,FLAGWD(BB)
	HRRZ A,JFNTAB(BB)	;NOW ENABLE INTERUPTS FOR THIS PTY
	MOVE B,[1B0+1B1+<IOCHN>B17+24]
	MTOPR
	 ERJMP .		;IGNORE ERRORS
	JRST CPOPJ1

OPNPTY:	MOVSI A,IOPENF!OOPENF	;MARK THAT IT WAS OPENED FOR BOTH
	IORM A,FLAGWD(BB)	;INPUT AND OUTPUT
	JRST CPOPJ1

INPTY:	HRRZ A,DEVNUM(BB)	;GET UNIT #
	ADD A,FIRPTY		;MAKE TTY #
	IORI A,TTYDSG		;MAKE IT A FILE DESIGNATOR
	SOBE			;ANY CHARACTERS TO GET?
	  SKIPN A,JFNTAB(BB)	;YES, GO READ IN ONE
	JRST INTTY9		;NO, WE ARE THROUGH
	HRRZS A
	MOVE C,B		;SAVE COUNT OF CHARACTERS IN BUFFER
INPTY1:	SOSGE IOCNT		;ANY MORE TO DO?
	  JRST INDON1		;NO, RETURN TO CALLER
	BIN			;READ IN NEXT CHAR
	IDPB B,IOBPT		;STORE IN USERS BUFFER
	SOJG C,INPTY1		;LOOP BACK FOR MORE
	JRST INPTY		;SEE IF MORE CHARS JUST CAME IN

OUTPTY:	PUSHJ P,PTYSHD		;YES, GO SET HALF DUPLEX MODE
	PUSHJ P,PTYPRM		;GO SEE IF PTY NEEDS PRIMING
	  JRST OUTPT4		;NEEDS A CONTROL-C
	  JRST OUTPT0		;DOES NOT NEED A CONTROL-C, JUST WAIT
	JRST OUTPT1		;DOES NOT NEED PRIMING
OUTPT4:	SKIPG C,IOCNT		;SET UP TO SCAN FOR A ^C IN BUFFER
	 POPJ P,		;NO MORE CHARACTERS
	MOVE A,IOBPT		;...
OUTPT3:	ILDB B,A		;GET A CHARACTER
	CAIN B,C.CC		;IS THIS A CONTROL-C
	  SOJA C,[MOVEM C,IOCNT	;SET BUFFER PAST THIS ^C
		MOVEM A,IOBPT
		JRST OUTPT4]	;GO SEND A CONTROL-C
	SKIPN B			;IS THIS A NULL
	SOJG C,OUTPT3		;LOOP BACK UNTIL A NON-NULL IS SEEN
OUTPT2:	MOVE A,JFNTAB(BB)	;GET THE JFN FOR THIS PTY
	MOVEI B,C.CC		;SEND OUT A CONTROL-C TO PRIME LINE
	BOUT
	MOVEI C,^D300		;LOOP FOR 30 SECONDS ONLY
OUTPT0:	MOVEI A,^D100		;AND SLEEP SOME
	IJSYS (DISMS)
	PUSHJ P,PTYPRM		;LINE STILL NEED PRIMING?
	  JRST OUTPTY		;NEEDS A CONTROL-C
	SOJG C,OUTPT0		;LOOP BACK UNTIL LINE IS PRIME
OUTPT1:	SOSGE IOCNT		;ANY CHARS TO SEND OUT
	  POPJ P,		;NO
	XCTLB <ILDB B,IOBPT>	;GET NEXT CHAR
	JUMPE B,OUTPT1		;SKIP NULLS
	HRRZ A,JFNTAB(BB)	;GET JFN FOR PTY
	MOVSI C,PTYCRF		;GET <CR> FLAG
	CAIN B,C.LF		;SENDING OUT A LINE FEED?
	TDNN C,FLAGWD(BB)	;WAS LAST CHAR A <CR>
	BOUT			;SEND OUT CHAR (EXCEPT <CR>)
	ANDCAM C,FLAGWD(BB)	;CLEAR <CR> FLAG
	CAIN B,C.CR		;DID WE JUST SEND A <CR>
	  IORM C,FLAGWD(BB)	;YES, SET <CR> FLAG
	MOVSI C,PTYCWF		;PREPARE TO SET ^C BIT
	CAIN B,C.CC		;WAS THIS A ^C?
	  IORM C,FLAGWD(BB)	;YES, REMEMBER THAT
	AOS C,IOBYTP(BB)	;COUNT UP CHARACTERS SENT OUT
	CAIN B,C.CR		;WAS THIS A BREAK CHARACTER?
	  SETZB C,IOBYTP(BB)	;YES, CLEAR THE COUNT
	CAIGE C,^D80		;FULL BUFFER?
	  JRST OUTPT1		;NO, LOOP BACK
	HRRZ A,DEVNUM(BB)	;GET UNIT NUMBER
	ADD A,FIRPTY		;GET TTY NUMBER
	IORI A,TTYDSG		;MAKE DEVICE DESIGNATOR
	RFMOD			;FORCE THIS BUFFER OUT
	SFMOD
	SETZM IOBYTP(BB)	;CLEAR COUNT
	MOVE A,JFNTAB(BB)	;RESTORE JFN
	JRST OUTPT1		;LOOP BACK UNTIL DONE

PTYSHD:	HRRZ A,DEVNUM(BB)	;GET PTY UNIT #
	ADD A,FIRPTY		;MAKE IT INTO A TTY #
	IORI A,TTYDSG		;CREATE TTY DEVICE DESIGNATOR
	RFMOD			;GET TTY CHARACTERISTICS
	TXO B,TT%ECM		;TURN ON ECHO MODE
	TXZ B,TT%ECO		;AND TURN OF ECHOING
	SFMOD			;SET IT UP
	STPAR			;...
	POPJ P,			;RETURN

PTYPRM:	SYSGET (<TTYJOB>)	;SEE IF PTY IS PRIMED FOR OUTPUT
	HRRZ A,DEVNUM(BB)	;GET UNIT NUMBER
	ADD A,FIRPTY		;TURN IT INTO TTY NUMBER
	HRLZS A
	HRR A,B			;GET TABLE NUMBER FOR TTYJOB
	GETAB
	  JRST CPOPJ1		;FAILED, TRY TO SEND ANYWAY
	JUMPGE A,CPOPJ2		;LINE IS PRIMED
	TLC A,-1		;SEE IF LINE NEEDS A CONTROL-C
	TLCE A,-1		;-1 MEANS YES, -2 MEANS NO
	  JRST CPOPJ1		;-2 GIVE SINGLE SKIP RETURN
	POPJ P,			;LINE NEEDS PRIMING

TTYINT:	MOVEM A,IAC+A		;SAVE AN AC
	MOVSI A,(HB.RTC!HB.RTL)	;GET TTY WAKE UP BITS
	JRST PTYIN1		;GO OR THEM INTO WAKEF

PTYINT:	MOVEM A,IAC+A		;SAVE AN AC
	MOVSI A,(HB.RPT)	;SET PTY ACTIVITY FLAG
PTYIN1:	IORM A,WAKEF		;SET WAKE UP FLAG WITH WAKE CONDITIONS
	SKIPE INPAT		;IN COMPATIBILITY PACKAGE?
	SKIPN IOWATF		;YES, WAITING FOR INPUT OR OUTPUT
	  JRST IOINR		;NO, JUST RETURN
	MOVE A,HIBWRD		;GET LAST HIBERNATE WORD
	TDNN A,WAKEF		;SEE IF JOB SHOULD BE WOKEN
	  JRST IOINR		;NO, JUST RETURN
;**;[432] INSERT 8 LINES AT PTYIN1:+7L		DSW	6-MAR-85
;**;[437] REMOVE 8 LINES AND 2 LABELS AT PTYIN1:+7L	DSW	20-MAY-85
	POP P,RETSAV		;YES, DISMIS TO DIFFERENT ADDR
	SETZM WAKEF		;MARK THAT A WAKE WAS DONE
	SETZM IOWATF		;CLEAR IO FLAG SO WE DONT COME HERE AGAIN
IOINR:	MOVE A,IAC+A		;RESTORE AC
	DEBRK

IOWAIT:	MOVSI A,100000		;WAIT FOR A LONG LONG TIME
IOWAT1:	MOVE B,A		;
	SKIPN UIFLAG		;USER INTERUPT WAITING?
	SKIPE CSTFLG		;OR ^C BEEN TYPED?
	  JRST CCTRAP		;YES, DONT GO TO SLEEP

IOWAT3:	SKIPN A,B		;IS IT ZERO STILL
	  MOVEI A,1		;YES, SLEEP FOR AT LEAST 1 MS
	MOVE B,HIBWRD		;GET FLAGS
	TDNE B,WAKEF		;SEEN A WAKE YET
	  JRST IOWAT2		;YES, DONT SLEEP

IOWAT4:	IJSYS (DISMS)		;NO, GO TO SLEEP
IOWAT2:	SETZM IOWATF		;CLEAR IO WAIT FLAG
	SETZM WAKEF		;CLEAR EVENT FLAG
	POPJ P,			; BEFORE STARTING AGAIN

GETPTY:	PUSH P,A		;GET A PHYSICAL PTY
	MOVSI A,600000+PTY	;PTY DEV DESIGNATOR
GETPT1:	MOVE B,A		;SAVE A
	HRROI A,STRNG1		;SEE IF DEVICE IS LEGAL
	DEVST
	  JRST [ MOVSI C,'PTY'
		 JRST GETPT4]	;DEVICE NOT LEGAL, NO MORE PTY'S
	MOVE A,B
	DVCHR			;GET CHARACTERISTICS
	TLNN B,(1B5)		;IS THIS DEVICE AVAILABLE
	  AOJA A,GETPT1		;NO TRY AGAIN
	HRRZ D,A		;GET DEVICE #
	PUSHJ P,GETPT6		;GET 6 BIT PTY NAME
	MOVEI B,17		;NOW SEE IF THIS DEV IS ALREADY INITED
	SETZ D,
GETPT3:	CAME D,BB		;SAME CHANNEL #?
	CAME C,DEVNAM(D)	;MATCH?
	SKIPA			;NO MATCH OR SAME CHANNEL
	  AOJA A,GETPT1		;YES, GO TRY FOR ANOTHER
	ADDI D,NTABS		;UPDATE INDEX
	SOJGE B,GETPT3		;LOOP FOR ALL CHANNELS
GETPT4:	POP P,A
	POPJ P,			;RETURN WITH PTY NAME IN C

GETPT6:	MOVSI C,'PTY'		;SET UP ANSWER AC
	MOVE B,[POINT 6,C,17]
GETPT2:	IDIVI D,10		;GET LOW ORDER CHARACTER
	ADDI E,20		;MAKE IT SIXBIT
	PUSH P,E		;SAVE IT
	SKIPE D			;DONE YET?
	PUSHJ P,GETPT2		;NO, GO GET NEXT CHAR
	POP P,E			;POP OFF NEXT CHAR
	IDPB E,B		;PUT IT IN C
	POPJ P,			;RETURN

JOBSTS:	JUMPL CAC,JBSJOB	;THIS IS A JOB NUMBER
	MOVE BB,CAC		;GET CHANNEL #
	IMULI BB,NTABS		;GET INDEX VALUE
	LDB AA,PDVNUM		;GET DEVICE TYPE
	CAIE AA,PTY		;IS IT A PTY?
	  JRST RETZER		;NO, THIS IS AN ERROR
	HRRE A,DEVNUM(BB)	;GET PTY UNIT NUMBER
	JUMPL A,BUGSTP
	ADD A,FIRPTY		;TURN IT INTO A TTY NUMBER
	MOVEM A,STRNG1+.JITNO	;SAVE TERMINAL NUMBER
	IORI A,TTYDSG		;MAKE IT A TTY NUMBER
	PUSHJ P,DGETJI		;DO THE GETJI
	 SETOM STRNG1+.JIJNO	;FLAG NO JOB ON TTY
JOBST0:	PUSHJ P,JOBST2		;GET BITS IN E
	  JRST RETZER		;SOMETHING WAS WRONG, GIVE ERROR RETURN
	MOVE A,E		;GET ANSWER
	JRST STOTC1		;RETURN

JOBST2:	SETZ E,			;INITIALIZE ANSWER
	SKIPGE STRNG1+.JIJNO	;IS THIS JOB LOGGED IN?
	  JRST JBST2B		;NO
	HRRZ A,JFNTAB(BB)	;NOW CHECK FOR TTY HUNGRY
	MOVEI B,25
	MTOPR			;0=NOT HUNGRY  -1=HUNGRY
	 ERJMP .+1		;IGNORE ERRORS
	SKIPE B
	  TLO E,(1B4)		;MARK THAT TTY IS HUNGRY
JBST2B:	SKIPGE A,STRNG1+.JITNO	;GET TTY NUMBER
	  JRST JBST2A		;THERE ISNT ONE
	IORI A,TTYDSG		;XWD 0,400000+TTY#
	SOBE			;IS BUFFER EMPTY
	  TLO E,(1B3)		;NO, MARK THAT OUTPUT IS READY
JBST2A:	SKIPG A,STRNG1+.JIJNO	;IS THE JOB LOGGED IN?
	  TLO E,(1B4)		;NO, SET HUNGRY BIT
	JUMPL A,JOBST1		;IF NO JOB, SET MONITOR MODE BIT
	TLO E,(1B0)		; SET JOB # ASSIGNED BIT
	HRR E,A			;STORE TSS JOB #
	SKIPE STRNG1+.JIUNO	;IS JOB LOGGED IN?
	  TLO E,(1B1)		;YES, THEN JOB IS LOGGED IN
	PUSHJ P,SKPUSR		;SEE IF IN USER MODE
JOBST1:	TLO E,(1B2)		;LITE MONITOR MODE BIT
	MOVSI A,PTYCWF		;CHECK IF JOB WAITING FOR ^C
	TDNN A,FLAGWD(BB)
	  JRST CPOPJ1		;NO, THEN OK TO RETURN
	TLNN E,(1B2)		;YES, IS JOB IN MONITOR MODE ALREADY?
	  TLZA E,(1B4)		;NO, CLEAR INPUT WAIT BIT
	ANDCAM A,FLAGWD(BB)	;IN MONITOR MODE, CLEAR ^C BIT
	JRST CPOPJ1

;ROUTINE TO GET JOB NAME IN A
;CALL WITH JOB NUMBER IN RH OF E

GTJBNM:	HRRZ A,E		;GET JOB NUMBER
	HRROI B,STRNG1		;GET JOB NAME
	MOVEI C,.JIPNM
	GETJI
	 JRST [	CAIE A,GTJIX4	;NOT LOGGED IN ERROR?
		POPJ P,		;NO, ERROR
		SETZ A,		;RETURN 0 JOB NAME
		JRST CPOPJ1]
	MOVE A,STRNG1		;GET NAME
	JRST CPOPJ1		;SKIP RETURN WITH NAME IN A

JBSJOB:	MOVN A,CAC		;GET JOB NUMBER
	PUSHJ P,DGETJI		;DO THE GETJI
	  JRST RETZR1		;ILLEGAL #
	SKIPN STRNG1+.JIUNO	;IS JOB LOGGED IN?
	  JRST RETZR1		;NO, GIVE BAD RETURN
	SKIPG D,STRNG1+.JITNO	;GET TTY NUMBER
	  JRST JOBST3		;-1 MEANS NO TTY FOR JOB
	SUB D,FIRPTY		;GET PTY NUMBER FROM TTY NUMBER
	HRLI D,600000+PTY	;GET DEVICE DESIGNATOR
	SETZB B,BB		;NOW SEE IF THIS PTY IS INITED
JBSJ0:	CAMN D,DEVNUM(BB)	;MATCH?
	  JRST JOBST0		;YES, GO DO UUO
	CAIL B,17		;CHECKED ALL CHANNELS
	  JRST JOBST3		;YES, GIVE ERROR RETURN
	ADDI BB,NTABS		;INCREMENT INDEX
	AOJA B,JBSJ0		;LOOP BACK FOR ALL CHANNELS

JOBST3:	MOVN A,CAC		;GET JOB NUMBER IN RH OF A
	HRLI A,(1B0!1B1)	;MARK THAT JOB IS LOGGED IN
	JRST STOTC1		;GIVE THIS PARTIAL ANSWER TO CALLER

PTYSTS:	HRRE A,DEVNUM(BB)	;GET TTY NUMBER
	JUMPL A,BUGSTP		;ERROR IF NEGATIVE
	ADD A,FIRPTY		;GET TTY #
	MOVEM A,STRNG1+.JITNO	;SAVE TERMINAL #
	IORI A,TTYDSG		;GET DEVICE DESIGNATOR
	PUSHJ P,DGETJI		;DO THE GETJI
	 SETOM STRNG1+.JIJNO	;MARK NO JOB
	PUSHJ P,JOBST2		;GET BITS IN LH OF E
	  JFCL			;IGNORE ERROR RETURN
	TLNE E,(1B3)		;ANY OUTPUT READY?
	  TRO E,1B25		;YES
	TLNE E,(1B4)		;INPUT WANTED?
	  TRO E,1B24		;YES
	TLNE E,(1B2)		;MONITOR MODE?
	  TRO E,1B26		;YES
	ANDI E,7000		;GET ONLY DESIRED BITS
	HRRZ A,FLAGWD(BB)	;GET OTHER STATUS BITS
	TRO A,(E)		;SET PTY DEPENDENT STATUS BITS
	POPJ P,			;AND RETURN
UTPCLR:	PUSHJ P,SETUPG
	JRST MRETN
	CAIE AA,DTA		;IS IT DECTAPE?
	JRST MRETN		;NO, UTPCLR IS A NOP
	PUSHJ P,DTAINI		;GO CLOSE ANY OPEN JFNS FOR THIS DTA
	MOVE A,DEVNUM(BB)	;GET DECTAPE DEVICE DESIGNATOR
	INIDR
	  PUSHJ P,ERROR
	JRST MRETN


;MNTFAI CHECKS IF AN ERROR WAS CAUSED BECAUSE THE DEVICE WAS NOT MOUNTED
;MNTFAI IS CALLED WITH A PUSHJ SO THAT ERROR WILL TYPE OUT A REASONABLE
;  ERROR ADDRESS.
;MNTFAI GIVES A NO SKIP RETURN IF THE USER DOES NOT WANT THE TRAP
;  AND A SKIP RETURN IF THE DEVICE IS NOT MOUNTED AND NO TRAP IS SET UP

MNTFAI:	CAIN A,GJFX28		;NOT MOUNTED?
	 JRST MNTFA1		;YES
	CAIE A,MNTX2		;AND IS DEVICE NOT MOUNTED?
	CAIN A,OPNX8		;ANOTHER UNMOUNTED MESSAGE TYPE
	  SKIPA			;DEVICE IS NOT MOUNTED, GO TRAP
	  POPJ P,		;ERROR
MNTFA1:	PUSHJ P,DOKTRP		;GO SEE IF OK TO TRAP
	  JRST CPOPJ1		;LET CALLER TYPE MESSAGE OR WHATEVER
	JRST MRETN		;TRAP TO C(.JBINT)

DOKTRP:	HRRZ A,.JBINT		;GET TRAP VECTOR
	JUMPE A,CPOPJ		;IF NOT SET UP JUST RETURN
	XCTUU <SKIPE 2(A)>	;IS PC ZERO
	  POPJ P,		;NO, GIVE ERROR RETURN
	UMOVE B,1(A)		;GET FLAGS
	TRNN B,1B35		;IS THIS USER SET UP FOR DEVICE TRAPS
	  POPJ P,		;NO
	UMOVE C,0(A)		;GET ENTRY ADDRESS
	HRRM C,PDL		;STORE FOR RETURN
	SOS B,JOBPD1		;GET USER PC
	UMOVEM B,2(A)		;STORE TRAPPED ADR
	HRRI B,0(AC)		;GET CHANNEL #
	HRLI B,1B35		;SET TYPE OF TRAP
	UMOVEM B,3(A)		;STORE FOR USER
	JRST CPOPJ1		;SKIP RETURN

DTAMNT:	HRRZ A,DEVNUM(BB)	;GET THE DEVICE NUMBER
	HRLI A,600003		;MOUNT AND READ THE DIRECTORY
	MOUNT			;NO, DO THE MOUNT
	  POPJ P,
	MOVSI C,DTAMF		;MARK THAT DTA WAS MOUNTED
	IORM C,FLAGWD(BB)	;SET THAT WE DID A MOUNT
	JRST CPOPJ1

DTMNTF:	PUSHJ P,MNTFAI		;GO SEE IF IT NEEDS TRAPING
	PUSHJ P,ERROR		;NO, TYPE ERROR MESSAGE
;**;[406] At DTMNT1:, Modified 1 line                       SM 15-Nov-82
DTMNT1:	TMSGS .CRQ,<device >
	PUSHJ P,TMSGDV
;**;[406] At DTMNT1: +2L, Modified 1 line                   SM 15-Nov-82
	TMSG <: not mounted>
	JRST EXITM1		;EXIT TO MONITOR AND DO UUO OVER
				;  AGAIN IF USER TYPES CONTINUE

UUGETF:	PUSHJ P,SETUP		;GET AA AND BB
	MOVE A,FLAGWD(BB)	;CHECK FOR A LOOKUP OR ENTER
	TLNN A,LOOKPF!ENTERF
	  JRST MRETN		;IF NOT MAKE THIS A NOP
	PUSHJ P,PTRGET		;FIRST FREE WORD
	JRST MRETN
	IDIV B,DEVTB2(AA)
	SKIPE C			;FIRST WORD OF BUFFER?
	ADDI B,1		;NO-GO TO NEXT BUFF
	HRRZ A,FORTY		;TARGET ADDRESS
	UMOVEM B,(A)
	JRST MRETN

DTASET:	PUSHJ P,DTAINI		;CLOSE ANY OPEN JFNS FOR THIS DTA
	HRRZ A,JFNTAB(BB)
	JUMPG A,DTAST2		;IS DTA ALREADY OPENED?
	PUSHJ P,DTGTJF		;NO, GO GET A JFN FIRST
	  JRST DTMNTF		;GO PROCESS ERROR
DTAST2:	MOVE B,FLAGWD(BB)	;GET FLAGS
	TLNN B,OOPENF!IOPENF	;IS DECTAPE ALREADY OPENED?
	  JRST DTAST3		;NO, GO OPEN IT
	TLNE B,DTADMP		;YES, IS IT IN DUMP MODE?
	  JRST DTAST4		;YES, DONT REOPEN IT
	HRLI A,(1B0)		;CLOSE IT FIRST
	CLOSF
	  JFCL
DTAST3:	PUSHJ P,DTMTND		;MOUNT IT WITHOUT READING DIR
	  JRST DTMNTF		;MOUNT FAILED
	HRRZ A,JFNTAB(BB)	;GET JFN AGAIN
	MOVE B,[XWD 447400,300000]	;OPEN IN DUMP MODE
	OPENF
	PUSHJ P,ERROR
	MOVSI B,OOPENF!IOPENF!DTADMP
	IORM B,FLAGWD(BB)	;MARK IT AS OPEN
DTAST4:	HRRZ A,JFNTAB(BB)
	MOVEI B,30		;DECLARE BLOCK FOR DUMP I/O
	HRRZ C,FORTY		;BLOCK TO POSITION TO
	TRNN PF,R.DIRN		;DOING USETI
	CAIG C,1101		;HIGHER THAN LIMIT?
	SKIPA			;OK, GO DO MTOPR
	  JRST UUSETE		;OFF THE END, GO SET EOF BIT
	MTOPR
	 ERJMP .		;IGNORE ERRORS
	MOVSI A,UFDEOF		;CLEAR EOF INDICATIONS
	ANDCAB A,FLAGWD(BB)
	TRNN A,100		;IS THIS MODE 100?
	CAIE C,144
	  JRST MRETN		;MODE 100 OR NOT DIRECTORY BLOCK
	MOVSI B,RDUFDF		;READING DIRECTORY
	IORM B,FLAGWD(BB)	;SET UFD BIT
	JRST MRETN

DTGTJF:	PUSHJ P,DTMTND		;GO MOUNT THE TAPE WITHOUT READING DIR
	  POPJ P,		;MOUNTING FAILED
	PUSHJ P,DEV67		;GET ASCIZ STRING FOR DTA
	SETZB B,JBLOCK		;SET UP FOR GTJFN
	PUSHJ P,JBKSET		;SET UP JBLOCK
	HRROI A,DEVNM7		;GET DEVICE NAME
	MOVEM A,JBLOCK+2
	MOVEI A,JBLOCK
	GTJFN
	  PUSHJ P,ERROR
	HRRZM A,JFNTAB(BB)	;STORE JFN
	JRST CPOPJ1

DTMTND:	HRRZ A,DEVNUM(BB)	;GET UNIT NUMBER
	HRLI A,640003		;DONT READ DIRECTORY
	MOUNT			;MOUNT THE DTA
	  POPJ P,		;GIVE ERROR RETURN
	MOVSI A,DTAMF		;MARK THAT DTA IS NO LONGER MOUNTED
	ANDCAM A,FLAGWD(BB)
	JRST CPOPJ1		;SUCCESSFUL

DTAINI:	MOVE E,DEVNUM(BB)	;GET DEVICE DESIGNATOR FOR THIS DTA
	MOVNI F,NTABS		;INITIALIZE INDEX INTO CHANNEL TABLE
	MOVEI G,20		;CHECK ALL CHANNELS
DTAINL:	ADDI F,NTABS		;INCREMENT INDEX
	HRRZ A,JFNTAB(F)	;IS THERE A JFN ON THIS CHANNEL
	  JUMPE A,DTAIN0	;NO, DONT BOTHER WITH THIS CHANNEL
	CAME F,BB		;IS THIS THE CURRENT CHANNEL
	CAME E,DEVNUM(F)	;NO, IS THIS THE SAME DTA
DTAIN0:	SOJG G,DTAINL		;NO, LOOP BACK FOR OTHER CHANNELS
	JUMPLE G,DTAIN2		;CHECKED ALL CHANNELS?
	MOVE D,FLAGWD(F)	;NO, THIS IS A MATCH
	TLNE D,DTACLS		;IS THIS DTA CLOSED ALREADY?
	  JRST DTAIN0		;YES, DONT BOTHER WITH IT
	HRLI A,(1B0)		;KEEP THE JFN
	CLOSF			;BUT CLOSE IT
	  JFCL
	MOVSI B,DTACLS		;MARK THAT THE JFN WAS CLOSED
	IORM B,FLAGWD(F)
	JRST DTAIN0		;CHECK OTHER CHANNELS

DTAIN2:	HRRZ A,JFNTAB(BB)	;GET JFN IF ANY OF THIS DTA
	  JUMPE A,CPOPJ		;NONE, THEN WE'RE DONE
	MOVE E,FLAGWD(BB)	;GET FLAGS
	TLNN E,DTACLS		;WAS THIS JFN CLOSED BEFORE
	  POPJ P,		;NO, THEN RETURN
	TLNE E,DTADMP		;WAS THE TAPE IN DUMP MODE?
	  JRST DTODMP		;YES, GO MOUNT AND OPEN IT AS SUCH
	PUSHJ P,DTAMNT		;GO RE MOUNT THIS TAPE
	  JRST DTMNTF		;MOUNT FAILED
	PUSHJ P,MDTAER		;MULTIPLE DTA FILES OPEN IS NOT ALLOWED

DTODMP:	PUSHJ P,DTMTND		;MOUNT THE DTA WITHOUT READING DIR
	  JRST DTMNTF		;FAILED
	MOVE B,[447400,,300000]	;OPEN DTA IN DUMP MODE
	OPENF
	  PUSHJ P,BUGSTP	;FAILED
	POPJ P,
;THE TAPOP UUO - ONLY PARTIALLY IMPLEMENTED TO SUPPORT COBOL

TAPOP:	PUSH P,AC		;SAVE UUO AC
	UMOVE AC,1(CAC)		;GET CHANNEL NUMBER
	PUSHJ P,SETUP		;SET UP AA AND BB
	POP P,AC		;RESTORE AC VALUE
	HRRZ A,JFNTAB(BB)	;GET JFN INTO A IF THERE IS ONE
	UMOVE C,2(CAC)		;GET ARGUMENT VALUE
	UMOVE D,0(CAC)		;GET FUNCTION
	CAIGE D,1000		;0 - 777?
	JRST TAPOP0		;YES
	CAIGE D,2000		;1000 - 1777?
	JRST TAPOP1		;YES
	CAIL D,3000		;2000 - 2777?
	JRST RETZER		;NO, ILLEGAL FUNCTION
	ANDI D,777		;GET INDEX
	CAIL D,TAPT2L		;LEGAL INDEX?
	JRST RETZER		;NO
	JRST @TAPTB2(D)		;DISPATCH FOR THIS FUNCTION

TAPOP0:	CAIL D,TAPT0L		;LEGAL FUNCTION?
	JRST RETZER		;NO
	JRST @TAPTB0(D)		;DISPATCH

TAPOP1:	ANDI D,777		;MASK OFF 1000
	CAIL D,TAPT1L		;LEGAL FUNCTION?
	JRST RETZER		;NO
	JRST @TAPTB1(D)		;YES, DISPATCH

TAPTB0:
TAPT0L==.-TAPTB0

TAPTB1:	RETZER			;1000
	TAPRDN			;1001 - READ DENSITY
	TAPTYP			;1002 - GET CONTROLLER TYPE
	TAPRRB			;1003 - SEE IF READING BACKWARDS
	RETZER			;1004
	RETZER			;1005
	RETZER			;1006
	TAPRDM			;1007 - READ DATA MODE
TAPT1L==.-TAPTB1

TAPTB2:	RETZER			;2000
	TAPSDN			;2001 - SET DENSITY
	RETZER			;2002
	TAPSRB			;2003 - SET READ BACKWARDS
	RETZER			;2004
	RETZER			;2005
	RETZER			;2006
	TAPSDM			;2007 - SET DATA MODE
TAPT2L==.-TAPTB2
;GET CONTROLLER TYPE

;**;[366] At TAPTYP:, Replaced 1 line with 23   	SM	10-Sep-81
TAPTYP:	JUMPE A,MTGUS		;[366] IF NO JFN, WE CANT GUESS WELL
	MOVEI B,.MODVT+1	;[366] NEED ARG BLOCK SIZE
	MOVEM B,MTOPIN		;[366] AT BEGINNING OF ARG BLOCK.
	MOVEI B,.MOSTA		;[366] BEST GUESS ALGOR. FOR CONT. TYPE
	MOVEI C,MTOPIN		;[366] INFO FROM MTOPR WILL GO HERE
	MTOPR			;[366] PLEASE GIVE DRIVE TYPE
	 ERJMP RETZER		;[366] SNH! (Should Never Happen)
	MOVE B,MTOPIN+.MODVT	;[366] FETCH DRIVE TYPE
	MOVEI A,6		;[366] INITIAL GUESS IS 6 (TXO2/DX20)
	CAIE B,.MTT77		;[366] IS IT A TU77?
	CAIN B,.MTT45		;[366] IS IT A TU45?
MTGUS:	MOVEI A,4		;[366] YES. MUST BE TMO2,3/RH20 (TU77,45)
		;[366]      NOTE ON THE ABOVE:
		;[366] TOPS-10 ACTUALLY RETURNS CODES FOR CONTROLLER/DRIVE
		;[366] COMBINATIONS. IN TOPS-20 THERE IS NO WAY FOR THE USER
		;[366] TO GET THE CONTROLLER TYPE. IT IS POSSIBLE TO
		;[366] ASSUME THAT, IF IT ISN'T A TU45/77, IT MUST BE A
		;[366] TU70,1,2,3,8. THESE ARE *USUALLY* SET UP VIA
		;[366] TXO2/DX20, BUT THE UNIVERSE IS A FRIGHTENING PLACE
		;[366] AND THIS ASSUMPTION MAY NOT HOLD. THIS PATCH IS
		;[366] ONLY TO KEEP COBOL FROM DENYING ITS USERS 6250BPI
		;[366] TAPES, AND SHOULD NOT BE CONSIDERED A
		;[366] TRUSTWORTHY ARRANGEMENT. -SM
	JRST STOTC1

;READ DENSITY

TAPRDN:	JUMPE A,TPRDN1		;IF NO JFN, USE MTADEN
	GTSTS
	JUMPGE B,TPRDN1		;IF NOT OPEN, USE MTADEN
	MOVEI B,.MORDN		;MTA IS OPEN, READ DENSITY DIRECTLY
	MTOPR
	 ERJMP RETZER		;FAILED
	SKIPA A,C		;GET ANSWER INTO AC A
TPRDN1:	LOAD A,MTADEN		;GET DENSITY
	JRST STOTC1		;AND RETURN

;GET MAGTAPE BUFFER SIZE

GETMBS:	SETO A,			;GET THE DATA MODE
	HRROI B,C		;INTO C
	MOVEI C,.JIDM		;DATA MODE
	GETJI
	 ERJMP CPOPJ
	HLRZ F,TPRDMT(C)	;GET THE BYTES PER WORD
	SETO A,			;NOW GET DEFAULT RECORDS PER BUFFER
	HRROI B,D		;GET ANSWER IN D
	MOVEI C,.JIRS		;GET RECORD SIZE IN BYTES
	GETJI
	 JRST CPOPJ		;FAILED
	IDIV D,F		;GET NUMBER OF WORDS PER BUFFER
	SKIPE E			;ROUND UP TO NEXT HIGHEST WORD
	AOS D			;IF NEEDED
	MOVE A,D		;GET ANSWER INTO A
	JRST CPOPJ1		;AND RETURN

;READ DATA MODE

TAPRDM:	PUSHJ P,TAPRD0		;GET THE DATA MODE
	 JRST RETZER		;FAILED, RETURN 0
	JRST STOTC1		;RETURN THE ANSWER

TAPRD0:	MOVE B,FLAGWD(BB)	;SEE IF MODE HAS BEEN SET
	TLNN B,MTADMS
	JRST TPRDM1		;NO GO GET IT
	LOAD A,MTADM		;GET DATA MODE
	JRST CPOPJ1		;RETURN OK

TPRDM1:	HRRZ A,JFNTAB(BB)	;GET THE JFN
	JUMPE A,TPRDM2		;IS THERE A JFN
	GTSTS			;YES
	JUMPGE B,TPRDM2		;FILE NOT OPEN
	MOVEI B,.MORDM		;GET MODE
	MTOPR
	 ERJMP TPRDM2		;ON FALUIRE GIVE DEFAULT
	JRST TPRDM3		;GO CONVERT MODE TO 10 MODE

TPRDM2:	SETO A,			;SET UP TO GET DEFAULT MODE IN C
	HRROI B,C
	MOVEI C,.JIDM
	GETJI			;GET DEFAULT MODE
	 ERJMP CPOPJ
TPRDM3:	HRRZ A,TPRDMT(C)	;CONVERT 20 MODE TO 10 MODE
	JRST CPOPJ1

TPRDMT:	1,,0			;SYSTEM DEFAULT (USE CORE DUMP)
	1,,1			;DUMP MODE 9-TRK
	6,,5			;SIXBIT,7-TRK DUMP MODE
	5,,4			;ANSI ASCII (7 BITS IN 8-BIT BYTE)
	4,,2			;INDUSTRY COMPATIBLE MODE

;SET DENSITY

TAPSDN:	STOR C,MTADEN		;STORE DENSITY
	JUMPE A,MRETN2		;IF NO JFN, THEN DONE
	GTSTS			;SEE IF OPEN
	JUMPGE B,MRETN2		;IF NOT OPEN, RETURN
	MOVEI B,.MOSDN		;MTA IS OPEN
	MTOPR			;SET THE DENSITY
	 ERJMP RETZER		;ILLEGAL DENSITY
	JRST MRETN2		;SUCCESSFUL

;SET DATA MODE

TAPSDM:	PUSHJ P,TPSDM		;SAVE DATA MODE
	 JRST RETZER		;ILLIGAL MODE
	JRST MRETN2		;TAKE SKIP RETURN

TPSDM:	MOVSI B,MTADMS		;INDICATE DATA MODE SET
	IORM B,FLAGWD(BB)
	STOR C,MTADM		;SAVE DATA MODE
	SKIPGE C,TPSDMT(C)	;GET DATA MODE
	POPJ P,			;ILLEGAL DATA MODE
	JUMPE A,CPOPJ1		;IF NO JFN, THEN RETURN
	GTSTS			;SEE IF MTA IS OPEN
	JUMPGE B,CPOPJ1		;IF NOT OPEN, RETURN
	MOVEI B,.MOSDM		;SET UP TO SET DATA MODE
	HRRZS C			;GET MODE
	MTOPR
	 ERJMP CPOPJ
	JRST CPOPJ1		;RETURN OK

TPSDMT:	1,,.SJDDM		;CORE DUMP
	1,,.SJDMC		;CORE DUMP (9 TRACK)
	4,,.SJDM8		;INDUSTRY COMPATIBLE MODE
	-1			;6 BIT MODE (9 TRACK)
	5,,.SJDMA		;7 BIT MODE
	6,,.SJDM6		;SIXBIT (7 TRACK)


;READ BACKWARDS FUNCTIONS

TAPRRB:	JUMPE A,RETZR1		;IF NO JFN, THE DIRECTION IS FORWARD
	MOVE A,FLAGWD(BB)	;GET FLAGS
	TLNN A,MTARDB		;SET TO READ BACKWARDS?
	TDZA A,A		;NO, GET A ZERO
	MOVEI A,1		;YES, GET A ONE
	JRST STOTC1		;RETURN ANSWER

TAPSRB:	JUMPE A,CMRETN		;IF NO JFN, THIS IS AN ERROR
	MOVSI B,MTARDB		;GET READ BACKWARDS FLAG
	TRNN C,1		;WANT TO RESET TO NORMAL READING?
	ANDCAM B,FLAGWD(BB)	;YES, CLEAR BIT
	TRNE C,1		;WANT TO READ BACKWARDS INSTEAD?
	IORM B,FLAGWD(BB)	;YES, THEN SET THE BIT
	JRST MRETN2		;SUCCESSFUL

UMTAPE:	PUSHJ P,SETUP
	MOVE A,FLAGWD(BB)	;IS IT INIT'ED?
	TLNN A,INITF
	PUSHJ P,ERRCHN
	CAIN AA,2		;IS DEVICE A MAGTAPE?
	  JRST MTAPE0		;YES
	CAIN AA,DTA		;OR A DECTAPE?
	TLNE A,LOOKPF!ENTERF	;YES, IS IT ALREADY OPENED FOR A FILE?
	  JRST MRETN		; NOP
MTAPE0:	HRRZ A,JFNTAB(BB)	;GET JFN IF ANY
	HRRZ B,FORTY		;GET COMMAND
	CAIE B,100		;HANDLE 100 AND 101 DIFFERENTLY
	CAIN B,101
	JRST MTAPE5
	HRRZ A,JFNTAB(BB)	;GET JFN
	JUMPN A,MTAPE2		;NO GTJFN IF HAVE JFN
	CAIE AA,DTA		;DTA?
	  JRST MTAPE3		;NO
	PUSHJ P,DTMTND		;MOUNT WITH NO DIRECTORY
	  JRST MTMNTF		;GO TRAP TO USER
MTAPE3:	PUSHJ P,JBKSET		;INITIALIZE JBLOCK
	PUSHJ P,DEV67		;MOVE THE NAME TO ASCIZ BLOCK
	HRROI A,DEVNM7		;POINTER TO IT.
	MOVEM A,JBLOCK+2	;DEVICE NAME MTAX
	MOVSI A,(GJ%FOU)		;FOR OUTPUT
	MOVEM A,JBLOCK
	SETZ B,
	MOVEI A,JBLOCK
	GTJFN
	PUSHJ P,ERROR
	MOVEM A,JFNTAB(BB)

MTAPE2:	GTSTS
	JUMPGE B,MTAPE4		;JUMP IF NOT YET OPENED
	PUSHJ P,MTAPE1
	JRST MRETN
MTAPE4:	MOVE B,[XWD 447400,200000] ;OPEN IN DUMP MODE
	HRRZ C,FORTY
	CAIE C,3		;WRITE AN EOF?
	CAIN C,13		;OR ERASE TAPE?
	MOVE B,[447400,,100000]	;YES, OPEN IT FOR WRITE
	OPENF
	PUSHJ P,ERROR
	PUSHJ P,MTAPE1
	HRLI A,(CO%NRJ)		;OPENED IT ONLY TO DO THE MTOPR.
	CLOSF
	PUSHJ P,ERROR
	JRST MRETN

MTAPE5:	MOVEI C,1		;SET FOR 9-TRK CORE DUMP
	CAIE B,100		;IS IT 9-TRK CORE DUMP
	MOVEI C,2		;NO SET TO INDUSTRY COMPATIBLE MODE
	PUSHJ P,TPSDM		;SAVE MODE AND SET IF POSSIBLE
	JRST MRETN		;ILLEGAL MODE SHOULD NOT GET HERE
	JRST MRETN		;RETURN TO USER

MTAPE1:	HRRZ B,FORTY		;GET COMMAND
	MTOPR			;DO IT
	 ERJMP .		;IGNORE ERRORS
	POPJ P,

MTMNTF:	PUSHJ P,MNTFAI		;TRAP TO USER
	PUSHJ P,ERROR		;HE DID NOT WANT TRAP, TYPE MESSAGE
	JRST DTMNT1		;SAY THAT DEVICE IS NOT MOUNTED

INDMER:	PUSHJ P,DTAX3Q		;SEE IF SIZE ERROR ON DTA
	  JRST INDM4B		;EOF SEEN
	PUSH P,B		;YES. STASH POSITION OF OFFENDING IOWD
	PUSH P,0(B)		;STASH THE IOWD ON STACK
INDME1:	MOVSI A,MAXIOL		;SEE IF A K LEFT
	ADD A,0(P)		; ..
	JUMPG A,INDME2		;NO. SHOULD BE READY TO QUIT.
	MOVSI A,-MAXIOL		;A REASONABLE SIZE IOWD
	HRR A,0(P)		;FIRST PART OF THE BIG LIST
	MOVEM A,DMPLST		;PLACE TO STASH IOL
	SETZM DMPLST+1		;TERMINATE LIST
	HRRZ A,JFNTAB(BB)	;READY TO DO SOME I/O. GET JFN
	MOVEI B,DMPLST		;WHERE IO LIST IS
	DUMPI			;TRY THIS
	  JRST INDME4		;GO SEE IF EOF
	MOVE A,[XWD MAXIOL,MAXIOL]	;UPDATE PARTIAL IOWD ON STACK
	ADDM A,0(P)		; ..
	JRST INDME1		;TRY THE REST OF IOLIST
INDME2:	POP P,DMPLST		;SHOULD BE READY TO HANDLE THIS
	HRRZ A,JFNTAB(BB)	;GET THE JFN
	HLLZ B,DMPLST		;IS IT BY LUCK EMPTY NOW?
	JUMPE B,INDME3		;JUMP IF SO
	MOVEI B,DMPLST
	DUMPI			;READ IT
	  JRST INDME5		;GO SEE IF EOF
INDME3:	POP P,B			;RESTORE PLACE IN I/O LIST
	ADDI B,1		;NEXT WORD.
	SKIPE 0(B)		;END OF LIST, I HOPE?
	JRST INDM1		;NO. HAVE TO TRY THAT PART OF LIST
	JRST INDM3		;END. QUIT INDMP SUBR

INDME4:	POP P,DMPLST		;RESTORE DMPLST
INDME5:	POP P,B			;AND B
	CAIE A,IOX4		;IS THIS AN EOF
	  PUSHJ P,ERROR		;NO
	JRST INDM4B		;YES, GO SET EOF BIT

DTAX3Q:	CAIN A,IOX4		;EOF?
	  POPJ P,		;YES, GO SET THE BIT
	CAIE A,DUMPX3		;RECOVERABLE LENGTH ERROR?
	  JRST ERROR		;NO. GIVE ERROR MESSAGE
	LDB A,PDVNUM		;GET DEVICE TYPE CODE.
	CAIE A,DTA		;DECTAPE?
	JRST ERROR		;NOPE. LOSE.
	JRST CPOPJ1		;YES. RETURN.

INDTA:	PUSHJ P,DTAINI		;CLOSE ANY OTHER JFNS FOR THIS DTA
	MOVE B,FLAGWD(BB)	;ARE WE READING A DIRECTORY
	TLNN B,RDUFDF!DTADMP
	  JRST INBYT		;NO, LET INBYT DO THE WORK
	TLNE B,UFDEOF		;EOF YET?
	  JRST INTY8A		;YES
	MOVN C,IOCNT		;SET UP DUMPI COMMAND
	HRLZS C
	HRR C,IOBPT
	SETZ D,
	TDNE B,[XWD RDUFDF,100]	;READING THE DIRECTORY OR IN MODE 100?
	  JRST [SUB C,[XWD 1,1]	;YES, READ 200 WORDS INTO THE 177 WORD
		TRO PF,R.NOWC	;BUFFER. THIS USES THE BYTE COUNT WORD
		JRST .+1]	;AS THE EXTRA WORD.  TOPS-10 KLUDGE!!!
	MOVEI B,C		;POINT TO COMMAND LIST
	DUMPI
	  JRST INDTA1		;GO CHECK FOR EOF
	MOVSI A,RDUFDF
	MOVSI B,UFDEOF		;DIRECTORY IS ONLY ONE BLOCK LONG
	TDNE A,FLAGWD(BB)	;ARE WE READING A DIRECTORY
	  IORM B,FLAGWD(BB)	;YES, MAKE IT BE ONLY ONE BLOCK LONG
	MOVE A,IOCNT		;SET UP IOBPT
	ADDM A,IOBPT
	SETZM IOCNT
	JRST INTTY9		;RETURN

INDTA1:	CAIE A,IOX4		;EOF?
	  PUSHJ P,ERROR		;NO
	JRST INTY8A		;YES, GO SET BIT

INBYT:	HRRZ A,JFNTAB(BB)	;GET JFN (RH ONLY)
	BIN			;GET FIRST BYTE
	MOVE G,B		;SAVE IT
	GTSTS
	TLNE B,1000		;END OF FILE?
	JRST INTY8A		;YES
	MOVE B,G
	SOSGE IOCNT
	JRST INDON1
	IDPB B,IOBPT
	MOVE 2,IOBPT
	MOVN 3,IOCNT
	SIN			;LET MONITOR DO THE LOOPING
	MOVEM 2,IOBPT
	MOVNM 3,IOCNT		;STORE UPDATED BYTE COUNT
	JRST INTTY9

OUTDTA:	PUSHJ P,DTAINI		;CLOSE OTHER JFNS FOR THIS DTA
	MOVE B,FLAGWD(BB)	;GET FLAGS
	TLNN B,DTADMP		;IN DUMP MODE FOR DTA
	  JRST OUTBYT		;NO USE SOUT OR BOUT
	TLNE B,UFDEOF		;HAS DIR ALREADY BEEN WRITTEN
	  JRST [MOVEI B,1B22	;YES, SET END OF FILE
		IORM B,FLAGWD(BB)
		POPJ P,]	;AND RETURN
	MOVSI C,-200		;YES, SET UP FOR A FULL 200 WORDS
	HRR C,IOBPT		;GET START OF BUFFER
	SETZ D,
	TDNE B,[RDUFDF,,100]	;MODE 100 OR WRITING DIR?
	  HRRI C,-1(C)		;YES, THE FIRST WORD IS THE WORD COUNT WORD
	MOVEI B,C		;GET COMMAND LIST POINTER
	DUMPO
	  PUSHJ P,ERROR
	MOVE A,IOCNT
	ADDM A,IOBPT
	SETZM IOCNT
	MOVSI B,UFDEOF		;SET EOF FLAG IF THIS WAS THE DIR
	MOVE C,FLAGWD(BB)
	TLNE C,RDUFDF		;ONLY IF WRITING THE DIR
	  IORM B,FLAGWD(BB)	;THEN CLOSE WONT WRITE GARBAGE ON TAPE
	POPJ P,

OUTMTA:	TROA PF,R.DIRN		;FLAG OUTPUT DIRECTION
INMTA:	TRZ PF,R.DIRN		;FLAG INPUT DIRECTION
	SKIPG B,IOCNT
	POPJ P,
	MOVSI A,MTABFS		;SEE IF THE BUFFERS ARE SET UP
	TDNN A,FLAGWD(BB)
	JRST [	IORM A,FLAGWD(BB) ;NO, SET THEM UP BEFORE FIRST USE
		HRRZ A,JFNTAB(BB) ;GET THE JFN OF THE MTA
		MOVEI B,.MORDM	;READ THE DATA MODE
		MTOPR
		 ERJMP .+1	;IF THIS FAILS, USE DEFAULTS FOR JOB
		HLRZ D,TPRDMT(C) ;GET NUMBER OF BYTES PER WORD
		MOVEI B,.MORRS	;READ THE RECORD SIZE
		MTOPR
		 ERJMP .+1	;IF FAILS, DONT CHANGE IT
		HRRZ B,BUFHTB(BB) ;GET POINTER TO BUFFER RING
		TRNE PF,R.DIRN	;DOING OUTPUT?
		HLRZ B,BUFHTB(BB) ;YES, GET OUTPUT BUFFER
		HRRZ B,0(B)	;GET ADDRESS OF FIRST BUFFER IN RING
		LDB B,[POINT 17,0(B),17] ;GET BUFFER SIZE
		IMULI B,0(D)	;GET NUMBER OF RECORDS PER BUFFER
		CAIL C,-1(B)	;IS THE MTA RECORD SIZE TOO SMALL?
		JRST .+1	;NO, DONT CHANGE ANYTHING
		MOVEI C,776(B)	;YES, SET UP LARGER BUFFER
		TRZ C,777	;ROUNDED UP TO THE NEXT PAGE
		MOVEI B,.MOSRS	;SET THE RECORD SIZE
		MTOPR
		 ERJMP .+1
		JRST .+1]
	HRRZ A,JFNTAB(BB)	;GET JFN
	MOVE B,IOBPT		;GET BYTE POINTER
	MOVN C,IOCNT		;AND NEGATIVE COUNT OF BYTES
	TRNE PF,R.DIRN		;IN OR OUT?
	JRST OUTMT1		;OUTPUTTING
	SINR			;READ IN THE RECORD
	 ERJMP SEQMTE		;ERROR OCCURED
SEQMTR:	MOVEM B,IOBPT		;STORE UPDATED BYTE POINTER
	MOVNM C,IOCNT		;AND UPDATED COUNT
	POPJ P,			;AND EXIT

OUTMT1:	SOUTR
	 ERJMP SEQMTE		;ERROR OCCURED ON THE WRITE
	JRST SEQMTR		;GO EXIT

SEQMTE:	MOVEM B,IOBPT		;STORE UPDATED BYTE POINTER
	MOVNM C,IOCNT		;AND COUNT
	HRRZ A,JFNTAB(BB)	;NOW GET ERROR STATUS
	GDSTS
	TRNN B,MT%EOF		;END OF FILE?
	JRST TAPERR		;NO, GO ANALIZE IT
	JRST RECCH1		;YES, GO SET EOF BIT AND EXIT

MTALP2:	MOVEM B,SPDELC		;INITIAL COMMAND
MTALP:	MOVE B,SPDELC		;NEXT OR CORRECTED IOL
	TRNE PF,R.DIRN		;OUTPUT?
	JRST DMP2		;YES. GO DO OUTPUT
	MOVSI C,MTALTW		;MARK LAST TRANSFER NOT A WRITE
	ANDCAM C,FLAGWD(BB)
	DUMPI
	  JRST EOFCHK
	JRST DMP3

MTALP1:	SETOM MTDUMP		;FLAG DUMP MODE REQUEST
	SETZM IOCNT		;SET POSITIVE COUNT SO RECORD LENGTH
	AOS IOCNT		;ERROR DOESN'T HAPPEN SPURIOUSLY
	JRST MTALP2		;GO TO IT

DMP2:	MOVSI C,MTALTW		;MARK LAST TRANSFER WAS A WRITE
	IORM C,FLAGWD(BB)
	DUMPO
	  JRST MTAER2		;(360) ERROR, GIVE USER THE ERROR BITS
DMP3:	MOVE C,IOCNT		;GET SIZE OF BUFFER
	ADDM C,IOBPT		;UPDATE BUFFER POINTER
DMP4:	SETZM IOCNT		;OK
	JRST RECCH1		;UPDATE THE STATUS

EOFCHK:	CAIE A,IOX4		;EOF?
	JRST RECCHK		;NO
	MOVEI A,1B22
	IORM A,FLAGWD(BB)
	JRST DMP4

CLSMTA:	MOVSI A,OUFIRF		;WAS A WRITE DONE?
	MOVE B,FLAGWD(BB)
	ANDI B,17		;GET MODE OF OPEN
	CAIL B,15		;SEQUENTIAL MODE?
	TDNN A,FLAGWD(BB)	;OR NO WRITE DONE?
	  POPJ P,		;YES, DONT DO ANYTHING
	MOVE A,JFNTAB(BB)	;NO, NOW WRITE OUT EOF
	MOVEI B,3		;MTOPR CODE 3 = EOF
	MTOPR
	 ERJMP .		;IGNORE ERRORS
	MTOPR			;DO 2 EOF'S AND BACK OVER ONE
	 ERJMP .		;IGNORE ERRORS
	MOVEI B,7		;MTOPR CODE 7 = BACKSPACE
	MTOPR
	 ERJMP .		;IGNORE ERRORS
	POPJ P,			;THRU
;INPUT ERROR OTHER THAN EOF FROM DUMPI

RECCHK:	HLRO A,(B)		;GET -WC FROM TRANSFER IN PROGRESS
	SKIPE MTDUMP		;AND IF DUMP MODE,
	MOVNM A,IOCNT		;STORE AS LAST TRANSFER ATTEMPT
	HRRZ A,JFNTAB(BB)	;GET THE JFN
	GDSTS			;GET THE TOPS-20 STATUS
	TRNN B,10000		;RECORD LENGTH ERROR?
	  JRST TAPERR		;CHECK OTHER ERRORS
	HLRZ D,C		;WORD COUNT
	MOVEI B,.MORDM		;SET UP TO GET DATA MODE
	MTOPR
	 ERJMP [MOVE C,D	;IF ERROR ASSUME DUMP MODE
		JRST RECCH2]	;AND SKIP DIVIDE
	HLRZ C,TPRDMT(C)	;CONVERT TO 10 MODE
	EXCH C,D		;SET UP FOR DIVIDE
	IDIVI C,(D)		;GET WORDS TRANSFERED
	SKIPE D			;REMAINDER?
	AOS C			;YES
RECCH2:	ADDM C,IOBPT		;UPDATE BUFFER POINTER WORD
	SUB C,IOCNT		;WORDS NOT TRANSFERRED
	MOVNM C,IOCNT

MTAERR:	PUSHJ P,GST2		;CONVERT TO 10/50 ERROR BITS
;**;[371] At MTAERR: +1L, Replaced 1 line           	SM	26-Oct-81
MTAER3:	SKIPLE IOCNT		;[371] WAS ERROR "TOO LONG?" (HERE FROM MTAER2)
	TRZ A,1B21		;YES. TOO SHORT ISN'T AN ERROR ON 10/50
	HRRM A,FLAGWD(BB)	;STORE STATUS BITS.
	HRRZ A,JFNTAB(BB)
	SETZ B,
	MTOPR			;CLR ERROR FLAGS
	 ERJMP .		;IGNORE ERRORS
	POPJ P,

;**;[371] At MTAER2:, Deleted 1 line            	SM	26-Oct-81
MTAER2:	MOVEI A,PROJFN		;(360) GET READY TO TYPE OUT MSG
	HRLOI B,.FHSLF		;(360) GET LAST ERROR MSG
	ERSTR			;(360) PRINT MSG
	JFCL			;(360)
	JFCL			;(360)
;**;[371] At MTAER2: +5L, Replaced 1 line with 3	SM	26-Oct-81
	PUSHJ P,GST2		;[371] GET ERROR BITS
	IORI A,1B18		;[371] LIGHT "IMPROPER I/O" FLAG
	JRST MTAER3		;[371] AND GO BACK TO OLD MTA ERROR CODE

;HERE ON SUCCESS FOR DUMPI OR DUMPO, NO ERRORS. JUST UPDATE
; THE PHYSICAL UNIT STATUS BITS

RECCH1:	PUSHJ P,GST2		;UPDATE FLAGS
	HRRM A,FLAGWD(BB)	;IN CHANNEL CONTROL BLOCK
	POPJ P,0		;AND RETURN TO DUMP IO PROCESSOR

TAPERR:	TRNE B,722000		;[353] OTHER KNOWN ERRORS
	JRST MTAERR		;[353] YES, MARK THESE ERRORS IN STATUS WORD
	SETZ	A,		;[353] NO,INDICATE GIVE LAST ERROR MESSAGE
	PUSHJ P,ERROR		; GO COMPLAIN

;ROUTINE TO DO SETSTS ON MTA

MTASET:	PUSHJ P,MTASTS		;CALL SUBR
	JRST MRETN

MTASTS:	HRRZ A,JFNTAB(BB)	;GET JFN OF MTA
	HRRZ B,FLAGWD(BB)	;GET MODES
	ANDI B,1700		;ONLY CARE ABOUT DENSITY, PARITY AND ERROR RETRY SUPPRESS
	TRZE B,100		;ERROR RETRY SUPPRESS?
	TRO B,40000		;YES, PUT IN POSITION FOR SDSTS
	SDSTS			;SET THESE BITS
	MOVEI B,.MOSDN		;SET UP TO SET DENSITY
	LOAD C,MTADEN		;GET DENSITY IF ANY
	SKIPE C			;HAS IT BEEN SPECIFIED
	MTOPR			;YES, SET IT
	 ERJMP .+1
	MOVEI B,.MOSDR		;SET UP READ BACKWARDS FUNCTION
	MOVSI C,MTARDB		;GET FLAG
	TDNN C,FLAGWD(BB)	;WANT TO READ BACKWARDS?
	TDZA C,C		;NO, GET A ZERO
	MOVEI C,1		;YES, GET A ONE
	MTOPR			;TELL MONITOR WHAT TO DO
	 ERJMP .+1		;IGNORE ERROR
	MOVE B,FLAGWD(BB)	;GET THE FLAGS
	TLNN B,MTADMS		;HAS THE DATA MODE BEEN SET
	POPJ P,			;NO, DO NOT SET IT TAKE SYSTEM DEFAULT
	MOVEI B,.MOSDM		;NOW DO THE DATA MODE SETTING
	LOAD C,MTADM
	HRRE C,TPSDMT(C)	;GET DATA MODE
	JUMPL C,CPOPJ		;IF NONE, RETURN
	MTOPR			;SET THE DESIRED DATA MODE
	 ERJMP .+1
	POPJ P,			;RETURN TO CALLER

OUDMER:	PUSHJ P,DTAX3Q		;SEE IF DTA SIZE ERROR.
	  JRST ERROR		;EOF SEEN
	PUSH P,B		;YES. SAVE POSITION OF IOWD
	PUSH P,0(B)		;STASH OFFENDING IOWD
OUDME1:	MOVSI A,MAXIOL		;A REASONABLE TOPS-20 LENGTH
	ADD A,0(P)		;WITHIN THAT FAR OF END?
	JUMPG A,OUDME2		;JUMP IF SO.
	MOVSI A,-MAXIOL		;MAKE A PARTIAL IOWD
	HRR A,0(P)		; ..
	MOVEM A,DMPLST		;STASH IT FOR DUMPO
	SETZM DMPLST+1		;AND CLEAR FOR A TERMINATOR
	HRRZ A,JFNTAB(BB)	;GET THE JFN
	MOVEI B,DMPLST		;AND WHERE THE SHORT IOL IS
	DUMPO			;TRY IT AGAIN, SAM
	  PUSHJ P,ERROR		;IF THIS LOSES, GIVE UP.
	MOVE A,[XWD MAXIOL,MAXIOL]	;UPDATE THE POINTER
	ADDM A,0(P)		; ..
	JRST OUDME1		;AND TRY THE REST OF IT
OUDME2:	POP P,DMPLST		;GET BACK THE PARTIAL IOLIST LEFT
	HRRZ A,JFNTAB(BB)	;GET THE JFN BACK
	HLLZ B,DMPLST		;DID IOL JUST NOW RUN OUT?
	JUMPE B,OUDME3		;IF SO, SKIP I/O
	MOVEI B,DMPLST		;POINT TO IO LIST
	DUMPO			;TRY TO OUTPUT REMAINING STUFF
	  PUSHJ P,ERROR		;CAN'T
OUDME3:		POP P,B			;GET THE POSITION IN ORIGINAL IOL
	ADDI B,1		;POINT AFTER TROUBLESOME GUY
	SKIPE 0(B)		;MORE TO DO YET?
	JRST OUTDM1		;YES. GO TRY NEXT IOWD
	JRST OUTDM3		;NO. QUIT.

;ENQ/DEQ TRANSLATION

.ENQ:	PUSHJ P,ENQSET		;SET UP THE ARGUMENT BLOCK
	 JRST ENQERE		;FAILED
	IJSYS <ENQ>		;DO THE FUNCTION
	 JRST ENQERR		;FAILED, GO TRANSLATE ERROR CODE
	JRST MRETN2		;SUCCESSFUL

.DEQ:	TLNE CAC,-1		;FUNCTION 0?
	JRST [	HLRZ A,CAC	;NO, GET FUNCTION CODE INTO A
		HRRZ B,CAC	;AND GET REQUEST ID INTO B (IF FUNC 1)
		JRST DEQ1]	;GO DO DEQ JSYS DIRECTLY
	PUSHJ P,ENQSET		;SET UP FOR JSYS
	 JRST ENQERE		;ILLEGAL ARGUMENT BLOCK
DEQ1:	IJSYS <DEQ>		;DO THE JSYS
	 JRST ENQERR		;ERROR, GO TRANSLATE ERROR CODE
	JRST MRETN2		;SUCCESSFUL

.ENQC:	TLNN CAC,-1		;FUNCTION 0 ONLY
	JRST [	MOVEI A,6	;INVALID FUNCTION
		JRST STOTAC]
	PUSHJ P,ENQSET		;SET UP ARG BLOCK FOR JSYS
	 JRST ENQERE		;FAILED
	MOVE C,ACS+1(AC)	;GET THIRD ARG - STATUS BLOCK ADR
	IJSYS <ENQC>
	 JRST ENQERR		;FAILED, TRANSLATE ERROR CODE
	JRST MRETN2

ENQSET:	XCTUU <HRRZ D,0(CAC)>	;GET LENGTH OF ARG BLOCK
	CAILE D,TMPBKL		;TOO BIG?
	 POPJ P,		;YES, GIVE ERROR RETURN
	HRLZ C,CAC		;GET ADR OF ARG BLOCK
	HRRI C,TMPBLK		;MOVE BLOCK TO INSIDE PAT
	ADDI D,TMPBLK-1		;GET END POINT
	BLT C,0(D)
	HLRZ D,TMPBLK		;GET # OF LOCKS
	MOVEI C,TMPBLK+2	;GET POINTER TO FIRST JFN WORD
ENQSLP:	HRRE B,0(C)		;GET LOCK TYPE
	JUMPL B,ENQSL1		;IF NOT A CHANNEL, IGNORE
	IMULI B,NTABS		;GET OFFSET INTO CHANNEL TABLE
	HRRZ A,JFNTAB(B)	;GET JFN
	HRRM A,0(C)		;REPLACE CHANNEL # WITH JFN
ENQSL1:	ADDI C,3		;STEP TO NEXT LOCK
	SOJG D,ENQSLP		;LOOP BACK FOR ALL LOCKS
	HLRZ A,CAC		;GET FUNCTION CODE
	MOVEI B,TMPBLK		;GET POINTER TO ARG BLOCK
	JRST CPOPJ1

ENQERR:	MOVSI D,-ENQTBL		;SET UP TO TRANSLATE ERROR CODE
ENQERL:	HRRZ C,ENQTAB(D)	;GET NEXT ERROR CODE
	CAMN A,C		;FOUND A MATCH YET?
	JRST ENQERF		;YES, GO USE IT
	AOBJN D,ENQERL		;LOOP BACK TILL FOUND
ENQERE:	TDZA A,A		;UNKNOWN ERROR, RETURN 0
ENQERF:	HLRZ A,ENQTAB(D)	;GET ERROR CODE TRANSLATION
	JRST STOTAC

ENQTAB:	6,,ENQX1
	17,,ENQX2
	25,,ENQX3
	22,,ENQX4
	23,,ENQX5
	1,,ENQX6
	24,,ENQX7
	20,,ENQX8
	10,,ENQX9
	7,,ENQX10
	11,,ENQX11
	2,,ENQX12
	15,,ENQX13
	4,,ENQX14
	26,,ENQX15
	12,,ENQX16
	14,,ENQX17
	21,,ENQX18
	5,,ENQX19
	0,,ENQX20
	3,,ENQX21
	13,,MONX01
ENQTBL==.-ENQTAB

;IO ERROR - THIS DOES NOT GET PASSED TO THE USER VIA CNIWRD
; RATHER IT CAUSES IO ERROR BITS TO BE SET IN THE FILE STATUS WORD

IOERR:	MOVEM 17,IAC+17		;SAVE SOME AC'S
	MOVEI 17,IAC
	BLT 17,IAC+16
	SKIPN INPAT
	JRST IOER2		;GIVE ERROR MESSAGE AND HALT.
	MOVEI 7,1B19+1B20	;PREPARE TO SET THESE BITS IN STAT WD
	MOVE 1,BB		;EXTENSIVE CHECK TO BE SURE WE KNOW
	CAIL 1,0		;WHAT WE'RE DOING
	CAIL 1,NTABS*20		;BB SHOULD HAVE INDEX TO IO CHANNEL
	JRST IOER2		;DOESN'T,ISSUE ERROR MESSAGE AND HALT
	IDIVI 1,NTABS		;SHOULD BE POINTING TO FIRST OF BLOCK
	JUMPN 2,IOER2		;NO, ISSUE ERROR MESSAGE AND HALT
	HRRZ A,RETSAV		;GET THE ADR OF THE INSTRUCTION
;**;[432] INSERT 2 LINES AT IOERR:+13L		DSW	6-MAR-85
;**;[437] DELETE 2 LINES AT IOERR:+13L		DSW	20-MAY-85
	CAIL A,MOVINS		;DOING THE BLT AT MOVBUF?
	CAILE A,MOVINE
	SKIPA			;NO
	JRST IOER0		;YES,THEN MARK THE ERROR BITS
	HRRZ 1,IAC+1		;AC1 AT TIME OF INTERRUPT
	HRRZ 2,JFNTAB(BB)	;GET JFN #
	CAME 1,2		;IS THIS A JFN IN 1
	JRST IOER2		;NO,ISSUE ERROR MESSAGE AND HALT
IOER0:	IORM 7,FLAGWD(BB)	;ALL SEEMS IN ORDER, SET ERROR BITS
IOER1:	MOVSI 17,IAC		;RESTORE AC'S
	BLT 17,17
	DEBRK			;AND RESUME IO

IOER2:	MOVE P,[IOWD IPDLL,IPDL]
;**;[406] At IOER2: +1L, Modified 1 line                    SM 15-Nov-82
	TMSGS .CRQ,<I-O Error at address > ;(317) FATAL ERROR MESSAGE
	MOVEI 1,PROJFN		;TYPE OUT ADR
	HRRZ 2,RETSAV
;**;[432] INSERT 2 LINES AT IOER2:+4L		DSW	6-MAR-85
;**;[437] REMOVE 2 LINES AT IOER2:+4L		DSW	20-MAY-85
	MOVEI 3,10
	NOUT
	 JFCL
;**;[406] At IOER2: +8L, Deleted 1 line                     SM 15-Nov-82
	HALTF			;(317) HALT IF NOT PAT GENERATED ERROR


	JRST IOER1		;GO EXIT

;CARD READER INPUT ROUTINE

INCDR:	MOVE A,FLAGWD(BB)	;GET MODE
	ANDI A,17
	CAIE A,10		;IMAGE MODE IS SPECIAL
	JRST INBYT		;DO NORMAL PROCESSING
INCDR1:	HRRZ A,JFNTAB(BB)	;GET JFN
	SOSG IOCNT		;ANY MORE TO DO?
	JRST INTTY9		;NO, GO EXIT
	BIN			;GET A 16 BIT BYTE
	ERJMP INERR		;ERROR OR EOF
	IDPB B,IOBPT		;STORE 12 BITS ONLY
	JRST INCDR1		;LOOP UNTIL DONE

INERR:	MOVEI A,.FHSLF		;GET ERROR CODE
	GETER
	HRRZS B			;GET CODE
	CAIN B,IOX4		;EOF?
	JRST INTY8A		;YES, GO SET EOF
	MOVEI A,1B19+1B20	;NO, SET ERROR BITS
	IORM A,FLAGWD(BB)
	JRST INTTY9		;AND RETURN

;MACHINE SIZE EXCEEDED INTERRUPT

MACHSZ:	MOVEM 17,IAC+17		;SAVE THE ACS
	MOVEI 17,IAC
	BLT 17,IAC+16
	MOVE P,[IOWD IPDLL,IPDL]
	MOVE A,RETSAV		;GET INTERRUPT PC
	TLNN A,10000		;INTERRUPT FROM USER MODE?
	JRST MACHS1		;NO, FATAL ERROR
	AOS A,DIECNT
	CAIL A,RETRY		;TRIED ENOUGH TIMES?
;**;[406] At MACHSZ: +9L, Inserted 1 line, Modified 1       SM 15-Nov-82
	JRST	[TMSGS .CRQ,<Internal system resources unavailable,
 continue to try again.>
		 HALTF
		 SETZM DIECNT
		 JRST .+1]
;**;[427] cancel edit 426
;**;[426] Changed 1 line at MACHSZ+15 (SPR# 19468)
;**;[406] At MACHSZ: +15L, Inserted 1 line, Modified 1      SM 15-Nov-82
	TMSGS .CRP,<Internal system resources currently depleted,
 waiting 30 seconds before attempting to continue.
>					;[406]
	TMSG	<Last error was: >	;[412] TYPE REASON FOR INTERRUPT
	MOVX	T1,.CTTRM		;[412] TO TERMINAL
	HRLOI	T2,.FHSLF
	SETZ	T3,
	ERSTR%				;[412] ...
	 JFCL
	 JFCL
	TMSG	<.
>					;[412] AND END NEATLY
	MOVEI T1,^D30000
	DISMS			;WAIT 30 SEC
MACHS0:	MOVSI 17,IAC		;RESTORE ACS
	BLT 17,17
	DEBRK

;**;[406] At MACHS1:, Modified 1 line                       SM 15-Nov-82
MACHS1:	TMSGS .CRQ,<Internal system resources currently depleted.>
	HALTF			;FATAL
	JRST MACHS0		;IF USER IS BRAVE, TRY TO CONTINUE

ABDBRK:	DMOVE A,IAC+A		;GET THE AC'S BACK
	MOVE C,IAC+C		; ..
	DEBRK			;AND DISMISS THE PSI

;CONTROL-C INTERCEPT ROUTINES

	ER.ICC==1B34		;CONTROL-C ENABLE BIT

CHKCCI:	SKIPE INFLSR		;IS THIS A CALL TO DISABLE CONTROL-C?
	  JRST CHKCC1		;YES, GO DO IT
	SKIPN A,.JBINT		;DOES USER WANT TO DISABLE CONTROL-C?
	  POPJ P,		;NO, RETURN
	MOVE A,1(A)		;GET ENABLE WORD
	TRNE A,ER.ICC		;NO, USER WANT IT TO BE ENABLED?
CHKCC1:	SKIPN CCIENB		;^C ALREADY ENABLED?
	PUSHJ P,SETCCE		;YES, ENABLE FOR INTERCEPTING ^C'S
	  POPJ P,		;CANNOT ENABLE FOR CONTROL-C INT
	SETOM CCIENB		;MARK THAT ^C IS NOW ENABLED
	JRST SETPSI		;GO ENABLE ^C CHANNEL

SETCCE:	MOVEI A,.FHSLF		;READ IN CAPABILITIES
	RPCAP
	TLNN B,(1B0)		;CAN CONTROL-C BE ENABLED?
	  JRST [TLO PF,L.NCCE	;NO, MARK THAT IT CANNOT BE SET
		POPJ P,]	;AND RETURN
	TLON C,(1B0)		;IS ^C ALREADY ON
	  EPCAP			;NO, ENABLE IT
	JRST CPOPJ1

CCIINT:	DMOVEM A,IAC+A		;COME HERE ON A ^C INTERRUPT
	MOVEM C,IAC+C
	AOS A,FRUSTC		;HOW MANY ^C'S SO FAR?
IFGE MAXFRU,<
	CAIL A,MAXFRU		;IS USER TRYING DESPARATLY TO STOP
	 JRST NOCCTP		;YES, STOP
>
	SKIPN A,.JBINT		;DOES USER WANT TO TRAP?
	  JRST NOCCI		;NO, DONT TRAP
	MOVE B,1(A)		;GET ENABLE BITS
	TRNE B,ER.ICC		;STILL SET?
	SKIPE 2(A)		;YES, PC WORD ZERO?
	  JRST NOCCI		;NO, LET ^C GO THROUGH TO EXEC
	MOVSI B,ER.ICC		;MARK WHICH TRAP CONDITION OCCURED
	IORM B,3(A)		;IN INTERRUPT BLOCK
CCINT1:	SETOM CCIFLG		;MARK THAT A ^C IS IN PROGRESS
	DMOVE A,IAC+A		;RESTORE ACS
	MOVE C,IAC+C
	JRST CSTART		;GO TRAP TO USER

NOCCI:	SKIPE INPAT		;IN COMPATIBILITY PACKAGE
	SKIPN INFLSR		;AND IN FILSER?
	  SKIPA			;NO
	JRST CCINT1		;YES, DONT LET CONTROL-C GO THROUGH
NOCCTP:	SETZM CCIENB		;DISABLE ^C INTERCEPT
	MOVEI A,3		;DEACTIVATE ^C CHANNEL
	DTI
	MOVEI A,-1		;GET CONTROLING TTY DESIGNATOR
	MOVEI B,C.CC		;GET A ^C
	STI			;PUT IT INTO TTY INPUT BUFFER
	STI			;AND AGAIN BECAUSE CONTROL-C IS DEFERED
	JRST ABDBRK		;NOW DISMIS, ALLOWING ^C TO INTERRUPT EXEC

CCTRAP:	SOS PDL			;BACK UP THE PC
	JRST MRETN		;GO TRAP TO HIM

;[356] The following are the misc routines that get called from a user
;[356] PSI interrupt.  These will JSR into the low segment, from there
;[356] we come back to USRINT.  That will figure out if we should delay
;[356] the interrupt or process it now.

INTUSR:	REPEAT <USRMXC+1>,<JSR UTRPPC>

USRINT:	EXCH	A,UTRPPC	;[356] Exchange the two locations
	SUBI	A,INTUSR+1	;[356] Dtermine the offset
	EXCH	A,UTRPPC	;[356] Restore A
	SKIPE UIIFLG		;DOING IIC FROM BELOW?
	JRST USRIN3		;YES
	MOVEM A,UIACA		;SAVE AN AC
	SKIPE INFLSR		;IN FILSER
	 JRST USRIN2		;YES, DELAY INTERRUPT
	HRRZ A,@USRSAV		;GET PC OF INTERRUPTED  PROGRAM
	CAIL A,PATLOC		;IN PAT?
	CAILE A,ENDFF
	 JRST USRIN1		;NO, GO TRAP TO USER
	SKIPN INPAT		;INSIDE PAT PROPER
	 JRST USRIN0		;NO, GO BACK UP PC AND TRAP
	CAIL A,INJSYS		;INTERRUPTABLE JSYS?
	CAIL A,INJSYE
	 JRST USRIN2		;NO
	SETZM IOWATF		;CLEAR WAITING FLAG
	MOVE A,MONUPC		;GET RETURN ADDRESS
	HRRI A,-1(A)		;BACK UP PC
	MOVEM A,@USRSAV		;SET UP INTERRUPT PC
	MOVSI 17,ACS		;RESTORE ACS
	BLT 17,17		;...
	JRST	USRIN4		;[356] Trap to the user

USRIN0:	MOVE A,MONUPC		;GET RETURN ADDRESS
	HRRI A,-1(A)		;BACK UP PC
	MOVEM A,@USRSAV		;SET UP INTERRUPT PC
USRIN1:	MOVE A,UIACA		;RESTORE AC

USRIN4:	EXCH	A,UTRPPC	;[356] Exchange
	ADDI	A,UITRAP	;[356] Calculate where to go to
	TLO	A,(<Z @>)	;[356] Turn on the indirect bit
	EXCH	A,UTRPPC	;[356] Restore the register
	JRST	@UTRPPC		;[356] Call the correct user routine

USRIN2:	MOVX	A,1B0		;[356] Get the flag to light
	LSH	A,@UTRPPC	;[356] Calculate it
	IORM	A,UIFLAG	;[356] Light the signal
	MOVE	A,UIACA		;[356] Restore A
	DEBRK			;FINISH UUO
	PUSHJ P,BUGSTP

USRIN3:	MOVE A,JOBPD1		;GET ADDRESS TO TRAP TO
	MOVEM A,@USRSAV
	MOVE A,ACS+A		;RESTORE ACS
	MOVE B,ACS+B
	SETZM UIIFLG		;CLEAR INTERRUPT FLAG
	JRST	USRIN4		;[356] Trap to the user job

NXPINT:	MOVEM A,IAC+A
	MOVEM B,IAC+B		;PRESERVE TWO AC'S
	MOVEM C,IAC+C
	HRRZ A,RETSAV		;GET PC OF INTERRUPT
;**;[432] INSERT 2 LINES AT NXPINT:+4L		DSW	6-MAR-85
;**;[437] REMOVE 2 LINES AT NXPINT:+4L		DSW	20-MAY-85
	CAIL A,PATLOC		;IS LESS THAN COMPATIBILITY PACKAGE
	  JRST ABDBRK		;YES, THIS IS OK,  PROBABLY DDT
	MOVEI A,.FHSLF		;THIS FORK
	GTRPW			;GET THE TRAP STATUS WORD
	SKIPN INPAT		;FROM INSIDE PAT?
	TLNE A,1		;OR FROM MONITOR MAP (SPURIOUS)?
	JRST ABDBRK		;YES. QUIT. PROCESS CONTINUES.
	HRRZS A			;ADDRESS REFERRED TO
	TRNE A,776000		;REFERENCE TO PAGE 0 OR 1 IS OK.
	CAMG A,JBREL		;ABOVE USER'S LEGIT AREA?
	JRST ABDBRK		;NO. FILLING IN SPACE. OK.
	CAMGE A,HSORG		;IN HISEG?
	JRST NXPBAD		;NO. BAD.
	CAMG A,JBHRL		;OUT OF BOUNDS IN HIGH SEG?
	JRST ABDBRK		;NO. SCRATCH PAGE IN HIGH SEG.
				;***SHOULD CHECK UWP BIT***
NXPBAD:	MOVEM A,ASAVE		;STASH ADDRESS FOR A MOMENT
	HRRZ B,A		;PAGE REFERENCED BY ACCIDENT
	LSH B,-11		;PAGE NUMBER FROM ADDRESS
	HRLI B,.FHSLF		;IN THIS FORK
	SETO A,			;TO OBLIVION
	SETZ C,			;CLEAR COUNT OF PAGES TO BE DELETED
	PMAP			;GET RID OF THE PAGE
	MOVE A,ASAVE		;GET THE ADDRESS BACK
	MOVE B,USRENB		;DID USER ASK FOR THESE ERRORS?
	TRNE B,1B22!1B23	;BY ILL MEM REF OR NXM?
	JRST MINT1		;YES. GO SNEAK INTO MEMINT CODE.
	MOVEI B,NXPTRP		;PC TO GET THIS TRAP
;**;[432] INSERT 4 LINES AND SOME LABELS AT NXPBAD:+12L	DSW	6-MAR-85
;**;[437] DELETE 4 LINES AND 2 LABELS AT NXPBAD:+12L	DSW	20-MAY-85
	EXCH B,RETSAV		;[432][437]PUT IT IN DE-BREAK PC
	HRL B,A			;[432][437]SAVE ADDRESS ATTEMPTED TOO
	MOVEM B,MONUPC		;***WHERE SHOULD THIS REALLY GO?
	JRST ABDBRK		;AND DEBREAK, STOPPING USER.

;HERE ON NON-PSI LEVEL AFTER STOPPING USER.
NXPTRP:	MOVEM 17,ACS+17		;STASH USER'S AC'S
	MOVEI 17,ACS
	BLT 17,ACS+16		; ..
	MOVE P,PATSTK		;GET THE STACK AC TO PDL
	MOVE PF,PFLAGS		;AND THE GENERAL FLAGS
;**;[406] At NXPTRP: +5L, Modified 1 line                   SM 15-Nov-82
	TMSGS .CRQ,<Illegal reference to address >
	MOVEI A,PROJFN		;TO TTY OUTPUT
	HLRZ B,MONUPC		;ADDRESS ATTEMPTED
	MOVEI C,10		;OCTAL RADIX
	NOUT			;TYPE OUT THE ADDRESS
	  JFCL
;**;[406] At ATUSER:, Replaced 2 lines, Modified 1          SM 15-Nov-82
ATUSER:	TMSG < at user >
	MOVEI A,PROJFN		;ADDRESS THE TTY AGAIN
	HRRZ B,MONUPC		;GET THE PC AT TIME OF ERROR
	TLO B,(1B5)		;USER MODE BIT
				; *** LOST OLD ARITH FLAGS. FOO.***
	MOVEM B,PDL		;IN CASE HE SAYS CONTINUE.
	HRRZS B			;CLEAR FOR NOUT
	MOVEI C,10		;RESET OCTAL IN CASE OF ATUSER ENTRY
	NOUT			;TYPE IT OUT
	  JFCL			;"CAN'T FAIL"
	MOVEI A,C.CR		;CRLF
	PBOUT			;TYPE CRLF
	MOVEI A,C.LF		;AND LF
	PBOUT
NXPHLT:	MOVSI 17,ACS		;RESTORE USER AC'S
	BLT 17,17		; ..
	SETZM INPAT		;OUT OF PAT
	HALTF			;HOW TO STOP AND ALLOW CONTINUE, MAKE
				; ALL THIS MORE GENERAL!!!
	MOVE P,PATSTK		;HE TYPED CONTINUE. CAN'T, BUT NEED
	MOVE PF,PFLAGS		;STACK AND FLAGS TO SAY SO.
	PUSHJ P,SETCV		;RESET EXEC CONTROL
	PUSHJ P,SETPSI		; ..
;**;[406] At NXPHLT: +9L, Modified 1 line                   SM 15-Nov-82
	TMSGS .CRQ,<Can't CONTinue>
	JRST NXPHLT


OVINT:	SKIPE INPAT
	JRST ERRINT
	MOVEM A,IAC+1
;**;[432] INSERT 5 LINES AND ADD 2 LABELS AT OVINT:+3L	DSW	6-MAR-85
;**;[437] DELETE 5 LINES AND 2 LABELS AT OVING:+3L	DSW	20-MAY-85
	MOVE A,RETSAV		;[432][437]
	TLO A,(1B0)		;[432][437]MARK OVERFLOW IN SAVED FLAGS
	MOVEM A,.JBTPC		;SETUP RETURN PC
	MOVE A,CNIWRD
	TRO A,10		;OVERFLOW
	JRST INT

FOVINT:	SKIPE INPAT
	JRST ERRINT
	MOVEM A,IAC+1
;**;[432] INSERT 5 LINES AND ADD 2 LABELS AT FOVINT:+3L	DSW	6-MAR-85
;**;[437] DELETE 5 LINES AND 2 LABELS AT FOVINT:+3L	DSW	20-MAY-85
	MOVE A,RETSAV		;[432][437]
	TLO A,(1B0+1B3)		;[432][437]MARK OV AND FOV IN FLAGS
	MOVEM A,.JBTPC		;SETUP RETURN PC
	MOVE A,CNIWRD
	TRO A,100		;FLOATING OVERFLOW
	JRST INT

PDLINT:	SKIPE INPAT
	JRST ERRINT
	MOVEM A,IAC+1
	MOVE A,RETSAV
;**;[432] INSERT 2 LINES AT PDLINT:+4L		DSW	6-MAR-85
;**;[437] DELETE 2 LINES AT PDLINT:+4L		DSW	20-MAY-85
	MOVEM A,.JBTPC		;SETUP RETURN PC
	MOVE A,CNIWRD
	TRO A,200000		;PDL OVERLFOW
	JRST INT

MINT1:	DMOVE A,IAC+A		;HERE FROM NXPBAD. FAKE MEMINT
	MOVE C,IAC+C		;BY RESETTING AC'S AND THEN
	JRST MINT2		; JUMPING INTO MEM INT ROUTINE

MEMINT:	SKIPE INPAT
	JRST ERRINT
MINT2:	MOVEM A,IAC+1
	MOVE A,RETSAV
;**;[432] INSERT 2 LINES AT MINT2:+2L		DSW	6-MAR-85
;**;[437] DELETE 2 LINES AT MINT2:+2L		DSW	20-MAY-85
	MOVEM A,.JBTPC		;SETUP RETURN PC
	MOVE A,CNIWRD
	TRO A,20000		;MEM PRO VIOLATION
INT:	MOVEM A,.JBCNI		;SETUP APR CONI
	MOVE A,.JBAPR
	TLZ A,440140		;CLEAR SAME BITS AS DOES TOPS10
;**;[432] INSERT 4 LINES AND ADD 2 LABELS AT INT:+3L	DSW	6-MAR-85
;**;[437] REMOVE 4 LINES AND 2 LABELS AT INT:+3L	DSW	20-MAY-85
	HRRM A,RETSAV		;[432][437] RETURN TO USER INTERRUPT ROUTINE
	MOVE A,IAC+1		;[432][437]
	SETZM INPAT		;TURN OFF PAT UUO SIMULATOR
	DEBRK
	HALTF
INSINT:				;HERE ON ILLEGAL INSTRUCTION TRAP
	MOVEM A,IAC+A		;STASH USER AC
	SKIPN INPAT		;IN COMPATIBILITY PACKAGE?
	  JRST INSIN1		;NO
	TRZE PF,R.ILLJ		;DOING AN XJSYS COMMAND?
	  JRST INSILJ		;YES, GO RETURN ERROR CODE IN A
INSIN1:	MOVEI A,INSTRP		;DIDDLE THE DEBREAK
;**;[432] INSERT 4 LINES AND ADD 2 LABELS AT INSIN1:+1L	DSW	6-MAR-85
;**;[437] DELETE 4 LINES AND 2 LABELS AT INSIN1:+1L	DSW	20-MAY-85
	EXCH A,RETSAV		;[432][437] TO COME BACK AT NON-PSI LEVEL
	HRRI A,-1(A)		;[432][437] DECREMENT PC
	MOVEM A,MONUPC		;STASH THE INT LOCATION
	MOVE A,IAC+A		;RESTORE THE AC
	DEBRK			;CLEAR OFF THE PSI CHANNEL
INSTRP:	MOVEM 17,ACS+17		;STASH ALL AC'S
	MOVEI 17,ACS		; ..
	BLT 17,ACS+16		; ..
	MOVE P,PATSTK		;GET A PDL STACK
	MOVE PF,PFLAGS		;AND SYSTEM FLAGS
	SETOM INPAT		;FLAG PAT STACK READY, ETC.
;**;[406] At INSTRP: +6L, Modified 1 line                   SM 15-Nov-82
	TMSGS .CRQ,<Illegal instruction >
	HRRZ A,MONUPC		;WHERE IT CAME FROM
	MOVE A,(A)		;GET INSTRUCTION
	PUSHJ P,TYPINS		;GO TYPE OUT INSTRUCTION
	JRST ATUSER		;AND THE PC, THEN STOP.

INSILJ:	MOVE A,[2,,IAC+2]	;SAVE SOME ACS
	BLT A,IAC+10		;  FOR GETER WHICH USES 10 ACS
	MOVEI A,.FHSLF		;GET ERROR CODE FOR THIS FORK
	GETER
	HRRZ A,B		;LEAVE ERROR CODE IN AC A
	MOVE 10,[IAC+2,,2]	;RESTORE ACS
	BLT 10,10
;**;[432] ADD 2 LINES AT INSILJ:+7L	DSW	6-MAR-85
;**;[437] DELETE 2 LINES AT INSILJ:+7L	DSW	20-MAY-85
	AOS RETSAV		;SKIP THE AOS 0(P) INSTRUCTION IN DOJSYS
	DEBRK			;RETURN

;ROUTINE TO HANDLE QUOTA EXCEEDED INTERRUPTS

QUOINT:	MOVEM 17,IAC+17		;SAVE ALL ACS
	MOVEI 17,IAC
	BLT 17,IAC+16
	MOVE 17,IAC+17		;(336) FIX STACK UP AGAIN
;**;[365] At QUOINT: +4L, Added 34 lines        	SM	 9-Sep-81
;**;[432] INSERT 2 LINES AT WHODID:+0L			DSW	6-MAR-85
;**;[437] DELETE 2 LINES AT WHODID:+0L			DSW	20-MAY-85
WHODID:	HRRZ A,RETSAV		;[365] GET ADDR OF INSTR THAT DID IT
	HLRZ B,0(A)		;[365] WHAT WAS THE OPCODE?
	CAIE B,104000		;[365] PERHAPS A JSYS?
	JRST NOJSQ		;[365] NO, ASSUME A MEM REF DID IT
	HRRZ A,0(A)		;[365] A JSYS. GET THE TYPE
	CAIE A,<PMAP&777777>	;[365] WAS IT A PMAP?
	SKIPA B,IAC+1		;[365] NO, FETCH USER AC 1
	HLRZ B,IAC+2		;[365] YES, JFN IS IN LF OF AC2
	HRRZ B,B		;[365] ISOLATE WHAT SHOULD BE A JFN
	JRST QUOTAJ		;[365] AND PROCESS IT
NOJSQ:	MOVSI A,(@0)		;[365] MEM REF HANDLING. GET THE INDIRECT BIT
;**;[432] INSERT 4 LINES AND ADD 2 LABELS AT NOJSQ:+1L	DSW	6-MAR-85
;**;[437] DELETE 4 LINES AND 2 LABELS AT NOJSQ:+1L	DSW	20-MAY-85
	ORM A,RETSAV		;[365][432][437]AND IGNITE IT IN RETSAV.
	MOVSI 17,IAC		;[365][432][437] PREPARE TO GET USER AC'S BACK
	BLT 17,17		;[365] ..GOT EM...
;**;[432] INSERT 4 LINES AND ADD 2 LABELS AT NOJS.1:+2L	DSW	6-MAR-85
;**;[437] DELETE 4 LINES AND 2 LABELS AT NOJSQ:+4L	DSW	20-MAY-85
	MOVEI B,@RETSAV		;[365][432][437]SO CAN DO ADDR CALC THAT DID IT
	LSH B,-9		;[365][432][437]MAKE IT A PAGE NUMBER
	MOVSI A,(@0)		;[365] OK, TURN OFF INDIRECT IN RETSAV
;**;[432] INSERT 4 LINES AND ADD 2 LABELS AT NOJS.3:+2L	DSW	6-MAR-85
;**;[437] DELETE 4 LINES AND 2 LABELS AT NOJSQ:+7L	DSW	20-MAY-85
	ANDCAM A,RETSAV		;[365][432][437] SNUFFED OUT
	MOVE A,B		;[365][432][437] SET UP PAGE # FOR RMAP
	HRLI A,.FHSLF		;[365] FOR THIS FORK, PLS.
	RMAP			;[365] WHAT FILE BELONGS TO THAT PAGE?
	 ERJMP NORECJ		;[365] IF WE DON'T KNOW... SKIP IT
	HLRZ B,A		;[365] ISOLATE THE JFN RETURNED
QUOTAJ:	CAILE B,777		;[365] HERE /W JFN IN B. IS IT REASONABLE?
	JRST NORECJ		;[365] NO, GIVE UP.
;**;[406] At QUOTAJ: +2L, Modified 1 line                   SM 15-Nov-82
	TMSGS .CRP,<While referencing file >
				;[365] ANNOUNCING...
	MOVEI A,PROJFN		;[365] TO THE PRIMARY JFN
;**;[404] At QUOTAJ: +5L, Replaced 1 line with 1            SM  4-Aug-82
	MOVX C,1B2+1B5+1B8+1B11+1B14+1B17+1B21+JS%PAF ;[404]
	JFNS			;[365] THE FILE THAT DID IT
	 ERJMP [ TMSG <(Name unknown)>
		 JRST NORECJ ]	;[365] IF WE DONT KNOW, BE HUMBLE
	TMSG < -->		;[365] BE NEAT
NORECJ:				;[365] AND BACK INTO OLD CODE
	SKIPN INPAT		;IN THE MIDDLE OF A UUO?
	JRST QUOTRP		;NO, BETTER NOT TRY TO HANDLE THIS
	MOVE A,RETSAV		;GET PC
	TLNN A,10000		;OUT OF USER MODE?
	JRST QUOTRP		;NO, THIS IS NOT GUARANTEED TO BE RECOVERABLE
	MOVEI A,.FHSLF		;GET THE ERROR CODE
	GETER
	HRRZ A,B		;ERROR CODE TO AC A
	PUSHJ P,WARN		;GO TRY TO EXPUNGE THE DELETED FILES
	 JRST QUOTRP		;DID NOT WORK
	MOVEM PF,IAC+PF		;SAVE THE UPDATED FLAGS
QUOCON:	MOVSI 17,IAC		;RESTORE THE ACS
	BLT 17,17
	DEBRK			;TRY TO CONTINUE

;**;[406] At QUOTRP:, Modified 1 line                       SM 15-Nov-82
QUOTRP:	TMSGS .CRQ
	MOVEI A,PROJFN		;TYPE OUT ERROR MESSAGE
	HRLOI B,.FHSLF		;GET LAST ERROR
	SETZ C,
	ERSTR
	 JFCL
;**;[406] At QUOTRP: +6L, Replaced 2 lines                  SM 15-Nov-82
	TMSG	<Quota exceeded or disk full>
	TMSG < at location >
	MOVEI A,PROJFN
;**;[432] INSERT 2 LINES AT QUOTRP:+9L.	DSW	6-MAR-85
;**;[437] DELETE 2 LINES AT QUOTRP:+9L.	DSW	20-MAY-85
	HRRZ B,RETSAV		;GET PC
	MOVEI C,10		;IN OCTAL
	NOUT
	 JFCL
	HALTF			;LET USER TRY TO CLEAN UP
	JRST QUOCON		;IN CASE OF A CONTINUE

CSTART:
	SKIPN INPAT		;HAVE AC'S AND STACK?
	JRST CSTNIP		;NO. NOT IN PAT.
	SETZM IOWATF		;CLEAR IOWAIT FLAG IF ON
	PUSH P,A		;STASH AN AC
	HRRZ A,RETSAV		;WHERE IS THE RETURN TO?
;**;[432] INSERT 2 LINES AT CSTART:+6L	DSW	6-MAR-85
;**;[437] DELETE 2 LINES AT CSTART:+6L	DSW	20-MAY-85
	CAIL A,INJSYS		;INTERRUPTABLE JSYS?
	CAIL A,INJSYE
	  JRST CSTRUN		;RUNNING A UUO, LET IT FINISH
	SETZM IOWATF		;CLEAR WAITING FLAG
	MOVE A,MONUPC		;GET ADDRESS OF UUO
	SUBI A,1		;POINT BACK AT THE UUO
	MOVEM A,.JBOPC		;STORE FOR USER
	SETZM INPAT		;SNEAK OUT THE BACK DOOR OF PAT
	PUSHJ P,CSTADR		;FIND ADDRESS OF THE START/ETC
;**;[432] INSERT 4 LINES AND ADD 2 LABES AT CSTART:+17L	DSW	6-MAR-85
;**;[437] DELETE 4 LINES AND 2 LABELS AT CSTART:+17L	DSW	20-MAY-85
	HRRZM A,RETSAV		;[432][437]DEBREAK TO HERE
	MOVE A,TTYFRK		;[432][437]MAKE SURE HIBER. TTY FORK IS STOPPED
	TLZE PF,L.TFA		; IS FORK ACTIVE?
	  FFORK			;YES, FREEZE IT
	SETZM CCIFLG		;CLEAR ^C INTERCEPT FLAG IF ON
	MOVSI 17,ACS		;GET THE USER'S AC'S BACK
	BLT 17,17		; ..
	DEBRK			;END OF INTERRUPT
CSTRUN:	PUSHJ P,CSTADR		;GET ADDRESS TO GO TO
	SKIPE CSTFLG		;WAS CSTFLG ALREADY SET?
	 JRST [	SKIPE CCIFLG	;ALREADY HANDLING INT?
		 JRST .+1
		PUSH P,B	;SAVE ACS
;**;[432] INSERT 7 LINES IN LITERAL AT CSTRUN:+2L	DSW	6-MAR-85
;**;[437] DELETE 7 LINES IN LITERAL AT CSTRUN:+2L	DSW	20-MAY-85
		MOVE B,RETSAV	;[432][437] GET INTERRUPTED PC
		HRRZM A,RETSAV	;DEBRK TO NEW ADDR
		MOVEM B,.JBOPC	;[432][437] GIVE PC TO USER
		POP P,B		;RESTORE ACS
		POP P,A
		DEBRK]		;AND GO TO NEW ADDRESS
	HRROM A,CSTFLG		;STORE IN FLAG FOR MRETN
	POP P,A			;RESTORE AC A
;**;[432] ADD LABEL AT CSTNIP:-1L.	DSW	6-MAR-85
;**;[437] REMOVE LABEL NOX4:	DSW	20-MAY-85
	DEBRK			;[432]END OF INTERRUPT
CSTNIP:	MOVEM P,SEE		;SAVE USER AC P
	MOVE P,PSISTK		;SET UP A STACK
	PUSH P,A		;AND STASH ANOTHER AC
	PUSH P,EE		;SAVE UMOVE ACS
	PUSH P,FF
;**;[432] INSERT 2 LINES AT CSTNIP:+5L	DSW	6-MAR-85
;**;[437] REMOVE 2 LINES AT CSTNIP:+5L	DSW	20-MAY-85
	HRRZ A,RETSAV		;WHERE WERE WE?
	CAIN A,EXITH		;DOING EXIT1? (SPECIAL CASE)
	JRST [	MOVE A,.JBOPC	;YES, .JBOPC IS CORRECT
		JRST CSTNI1]
	CAIG A,ENDFF		;IN PAT?
	CAIGE A,PATLOC		; ..
	SKIPA A,RETSAV		;NO. DEBREAK ADDRESS TO .JBOPC
;**;[432] INSERT NEW LITERAL AT CSTNIP:+13L	DSW	6-MAR-85
;**;[437] DELETE LITERAL AT CSTNIP:+13L	DSW	20-MAY-85
	JRST [MOVE A,MONUPC	;GET ADDRESS OF UUO+1
		SOJA A,.+1]	;ADDRESS TO RETURN TO
;**;[432] ADD LABEL AT CSTNI1:-1L.	DSW	6-MAR-85
;**;[437] REMOVE LABEL CSTNI0:	DSW	20-MAY-85
	MOVEM A,.JBOPC		;[432][437] STORE FOR USER TO SEE
CSTNI1:	PUSHJ P,CSTADR		;GET PLACE TO GO TO
;**;[432] INSERT 4 LINES AND ADD 2 LABELS AT CSTNI1:+1L	DSW	6-MAR-85
;**;[437] DELETE 4 LINES AND 2 LABELS AT CSTNI1:+1L	DSW	20-MAY-85
	MOVEM A,RETSAV		;[432][437] AND MAKE DEBRK GO THERE
	SETZM CCIFLG		;[432][437] CLEAR ^C INTERCEPT FLAG IF ON
	POP P,FF
	POP P,EE
	POP P,A			;RESTORE AC'S USED
	MOVE P,SEE		; ..
	DEBRK			;AND GO TO NEW ADDRESS

CSTADR:	PUSH P,B
	SKIPE CCIFLG		;IS THIS A ^C INTERCEPT?
	  JRST CCIADR		;YES, HANDLE IT DIFFERENTLY
	PUSH P,C
	PUSH P,E
	PUSHJ P,TTBINI		;GO CLEAR TTCALL BUFFER AFTER ^C
	PUSHJ P,SETPSI		;IN CASE NOT ALL CHANNELS ON WHEN
	POP P,E
	POP P,C			; USER TYPED ^C. GET THEM BACK
	POP P,B
	MOVE A,JBREL		;RESTORE .JBREL
	UMOVEM A,.JBREL
	MOVE A,JBHRL		;AND .JBHRL
	XCTMU <HRRM A,.JBHRL>
;**;[424]	INSERT 4 LINES AT CSTADR+13 (SPR #19453)
;**;[428]	INSERT 1 LINE AFTER .+3 (QAR 706262)
	MOVEI T4,TTSTI		;[424] SAVE TTY STATE
	PUSHJ P,TERSAV		;[424]
	MOVEI T4,TTSTO		;[424] RESTORE PREVIOUS TTY STATE
	SKIPE (T4)		;[428] IF NEEDED
	PUSHJ P,TERRES		;[424]
	SKIPL A,CSTCOD		;GET THE CODE FROM EXEC
	JRST CSTAD1		;POSITIVE IS GOTO ADDR
	MOVMS A			;MAKE CODE POSITIVE
	CAILE A,CSTMCD		;OR OUT OF RANGE?
	MOVEI A,0		;YES. GO STRAIGHT TO TOPS-20 DDT
	XCT [	MOVEI A,DDTLOC		;FORCE DDT
		HRRZ A,.JBSA		;START COMMAND
		HRRZ A,.JBREN		;REENTER COMMAND
		JRST [	HRRZ A,.JBDDT	;USER'S OWN DDT?
			TRNN A,-1	;ANYTHING THERE?
			MOVEI A,DDTLOC	;NO. USE TOPS-20 DDT
			JRST CSTAD1]
		MOVEI A,CLSCMD
		MOVEI A,UNMCMD](A)
	TRNN A,-1		;AN ADDRESS AVAILABLE?
	MOVEI A,CSTADX		;NO.
CSTAD1:	PUSH P,A		;SAVE ADDRESS OF WHERE TO START
	PUSH P,E		;THIS AC NEEDS SAVING IF ON INT LVL
	MOVEI A,PRIJFN		;GET TTY JFN
	MOVE E,TYSTAT		;AND STATUS WORD
	PUSHJ P,NOCTRO		;CLEAR CONTROL-O ON MON-USER XITION
	POP P,E			;RESTORE AC E
	JRST APOPJ		;RETURN WITH ADDRESS IN A

;**;[406] At CSTADX:, Modified 1 line                       SM 15-Nov-82
CSTADX:	TMSGS .CRQ,<No start address>
	PUSHJ P,CLRALL		;CLEAR PSI AND COMPAT VECTOR
	HALTF
	PUSHJ P,SETCV		;IF CONTINUED, PUT COMP VEC BACK
	PUSHJ P,SETPSI		;AND PSI SYSTEM.
	JRSTF @.JBOPC		;IF HE CONTINUES, GO HERE.

CCIADR:	MOVE B,.JBINT		;GET INTERCEPT ARGUMENT POINTER
	SKIPE INPAT		;IN PAT?
	SKIPN INFLSR		;AND DISABLING CONTROL-C?
	  SKIPN B		;NO
	JRST [JUMPN B,CCIAD0	;YES, IF INTERCEPT ENABLED, GET ADR
		JRST CCIAD1]
CCIAD0:	SKIPN INPAT		;DELAYED TRAP?
	  MOVEM A,2(B)		;NO, STORE INTERRUPTED PC
	HRRZ A,0(B)		;PICK UP TRAP ADRESS
	SETZM INFLSR		;DISABLE FILSER FLAG SO ^C IS NOT DONE
CCIAD1:	POP P,B			;RESTORE B
	POPJ P,			;AND RETURN

;UTILITY AND ERROR ROUTINES

;**;[406] At CCIAD1: +5L, Replaced 16 lines with 35             SM 16-Nov-82
;[406]
;TMSGQ is unusual. The calling arrangement is:
;	PUSHJ	P,TMSGQ
;	JRST loc or TRNA 0
;	pointerword to asciz string
;	{offset to prefix or 0,,0}
;
;	The {} word is not there if the word after the PUSHJ is a TRNA
;	The effect of all this is that TMSGQ can be "skipped over"
;	and also that you can specify a different address to get to
;	if you dont skip over the call. TMSG and TMSGS set up this call.

TMSGQ:	DMOVEM	A,TMSTMP
	MOVE	B,(P)
	MOVE	A,(B)		;PICK UP JRST n OR TRNA 0
	TRNN	A,-1		;WHICH?
	JRST	NLDIN		;TRNA FORM, NO SECOND WORD
	HLRZ	A,2(B)		;PICK UP OFFSET TO PREFIX
	JUMPE	A,NLDIN		;IF .EQ. 0, NO PREFIX
	HRRO	A,PREFX-1(A)	;YES
	PSOUT
NLDIN:	MOVE	A,1(B)		;WHAT DID CALLER WANT?
	PSOUT
	DMOVE	A,TMSTMP
	RET

PREFX:	[ASCIZ/
/]
	[ASCIZ/
?PA1050: /]
	[ASCIZ/
%PA1050: /]

;[406] end.

TMSGDV:	PUSHJ P,DEV67		;GET DEVICE NAME TO BE TYPED
	HRROI A,DEVNM7		;GET POINTER TO STRING
	PSOUT			;TYPE IT
	POPJ P,			;AND RETURN

WARN:	TROE PF,R.EXP		;ALREADY EXPUNGED?
	  POPJ P,		;YES, DONT DO IT AGAIN
	PUSH P,B		;SAVE AN AC
	MOVE B,TYSTAT		;GET CONTROLING TTY STATUS
	CAIN A,IOX11		;QUOTA EXCEEDED OR DISK FULL?
	JRST FULERR		;YES
	CAIN A,OPNX23		;QUOTA EXCEEDED
	 JRST QUOERR		;YES
	CAIN A,OPNX10		;NO ROOM?
	  JRST DSKFUL		;YES, TELL USER
	CAIN A,GJFX23		;DIR FULL
	  JRST DIRFUL		;YES
	POP P,B
	POPJ P,

FULERR:	TLNE B,TT.GAG!TT.BIN	;USER WANT MESSAGES?
	  JRST DIREX1		;NO JUST EXPUNGE
;**;[406] At FULERR: +2L, Modified 1 line                   SM 15-Nov-82
	TMSGS .CRP,<Quota exceeded or disk full>
	JRST DIREXP		;GO EXPUNGE

QUOERR:	TLNE B,TT.GAG!TT.BIN	;USER WANT MESSAGES?
	  JRST DIREX1		;NO JUST EXPUNGE
;**;[406] At QUOERR: +2L, Modified 1 line                   SM 15-Nov-82
	TMSGS .CRP,<Quota exceeded>
	JRST DIREXP		;GO EXPUNGE

DSKFUL:	TLNE B,TT.GAG!TT.BIN	;USER WANT MESSAGES?
	  JRST DIREX1		;NO
;**;[406] At DSKFUL: +2L, Modified 1 line                   SM 15-Nov-82
	TMSGS .CRP,<Disk is full>
	JRST DIREXP		;GO EXPUNGE

DIRFUL:	TLNE B,TT.GAG!TT.BIN	;USER WANT MESSAGES?
	  JRST DIREX1		;NO
;**;[406] At DIRFUL: +2L, Modified 1 line                   SM 15-Nov-82
	TMSGS .CRP,<Directory full>
;**;[406] At DIREXP:, Inserted 1 line                       SM 15-Nov-82
DIREXP:	TMSG < - deleted files being expunged
>
DIREX1:	SKIPN B,DIRNUM(BB)	;GET DIRECTORY OF PROBLEM FILE
	  GJINF			;GET CONNECTED DIR NUM
	SETZ A,			;NO SPECIAL FLAGS
	XJSYS <DELDF>		;EXPUNGE DIRECTORY
	  JFCL			;IGNORE ERROR RETURN
	POP P,B
	JRST CPOPJ1		;GIVE SKIP RETURN

;**;[406] At ERRARG:, Modified 1 line                       SM 15-Nov-82
ERRARG:	TMSGS .CRQ,<Bad argument for uuo call.>
	JRST ERROR2

;**;[406] At ERRCHN:, Modified 1 line                       SM 15-Nov-82
ERRCHN:	TMSGS .CRQ,<I-O to unassigned channel.>
	JRST ERROR2

;**;[406] At CORBUG:, Modified 1 line                       SM 15-Nov-82
CORBUG:	TMSGS .CRQ,<Program too large, COMPATIBILITY PACKAGE IS OVERLAPPED>
	JRST TRP3

;**;[406] At BUGSTP:, Modified 1 line                       SM 15-Nov-82
BUGSTP:	TMSGS .CRQ,<Compatibility error or unimplemented function>
	JRST ERROR1

ILLINP:	MOVE A,DEVTBL(AA)	;GET MODES
	TLNE A,2		;INPUT LEGAL?
	  JRST ILLIN1		;YES
;**;[406] At ILLINP: +3L, Modified 1 line                   SM 15-Nov-82
	TMSGS .CRQ,<Device >
	PUSHJ P,TMSGDV		;ADD IN DEVICE NAME
;**;[406] At ILLINP: +6L, Modified 1 line                   SM 15-Nov-82
	TMSG < cannot do input>
	JRST ERROR1

ILLIN1:	PUSHJ P,DOKTRP		;SEE IF USER WANTS TO TRAP ON THIS
	  JRST [PUSHJ P,ILLINM	;NO, THEN TYPE OUT MESAGE
		JRST EXITM1]	;AND HALT JOB
	HRRZ A,.JBINT		;NOW SEE IF MESSAGE SHOULD BE TYPED
	XCTUM <SKIPL 1(A)>	;CHECK BIT 0 OF INTLOC+1
	  PUSHJ P,ILLINM	;TYPE OUT MESSAGE
	JRST MRETN		;TRAP TO USER

;**;[406] At ILLINM:, Modified 1 line                       SM 15-Nov-82
ILLINM:	TMSGS .CRQ,<Device >
	PUSHJ P,TMSGDV		;DEVICE NAME
;**;[406] At ILLINM: +2L, Modified 1 line                   SM 15-Nov-82
	TMSG <: is offline, type CONTinue when device is ready>
	POPJ P,

ILLOUT:	MOVE A,DEVTBL(AA)	;GET MODES
	TLNE A,1		;OUTPUT LEGAL?
	 JRST ILLOU1		;YES
;**;[406] At ILLOUT: +3L, Modified 1 line                   SM 15-Nov-82
	TMSGS .CRQ,<Device >
	PUSHJ P,TMSGDV
;**;[406] At ILLOUT: +6L, Modified 1 line                   SM 15-Nov-82
	TMSG <: cannot do output>
	JRST ERROR1

ILLOU1:	PUSHJ P,DOKTRP		;SEE IF USER WANTS A TRAP
	  JRST [PUSHJ P,ILLOUM	;NO, TYPE OUT MESSAGE
		JRST EXITM1]	;AND HALT
	HRRZ A,.JBINT		;NOW SEE IF MESSAGE SHOULD BE TYPED
	XCTUM <SKIPL 1(A)>	;CHECK BIT 0 OF INTLOC+1
	  PUSHJ P,ILLOUM	;TYPE OUT MESSAGE
	JRST MRETN		;TRAP TO USER

;**;[406] At ILLOUM:, Modified 1 line                       SM 15-Nov-82
ILLOUM:	TMSGS .CRQ,<Device >
	PUSHJ P,TMSGDV
;**;[406] At ILLOUM: +2L, Inserted 1 line, Modified 1       SM 15-Nov-82
	TMSG <: is either off-line or write locked,
type CONTinue when device is ready>
	POPJ P,

;**;[406] At MDTAER:, Modified 1 line                       SM 15-Nov-82
MDTAER:	TMSGS .CRQ,<Multiple open files on a single DTA is not supported>
	JRST ERROR2

;**;[406] At CONERR:, Modified 1 line                       SM 15-Nov-82
CONERR:	TMSGS .CRQ,<Can't CONTinue>
	JRST EXIT2

;**;[406] At LBOPER:, Modified 1 line                       SM 15-Nov-82
LBOPER:	TMSGS .CRQ,<Error attempting to get tape label information>;[353]

;**;[406] At ERROR:, Modified 1 line                        SM 15-Nov-82
ERROR:	TMSGS .CRQ,<Error in job>
	HRLI B,.FHSLF
	HRR B,A			;GET ERROR CODE TO TRANSLATE
	;[353] CHANGE @ ERROR+3
	TRNN	B,-1		;[353] ANY CODE SET?
	TRO	B,-1		;[353] NO, INDICATE LAST JSYS ERROR
	SETZ C,
	MOVEI A,PROJFN
	ERSTR
	 JFCL
	 JFCL

;**;[406] At ERROR1:, Modified 1 line                       SM 15-Nov-82
ERROR1:	TMSGS .CR,<Compatibility location = >
	MOVEI A,PROJFN		;GET PRIMARY OUTPUT JFN FOR ERR MESSAGE
	HRRZ B,(P)
	SUBI B,1
	MOVEI C,10
	NOUT
	JFCL
	SETZ C,

;**;[406] At ERROR2:, Modified 1 line                       SM 15-Nov-82
ERROR2:	TMSGS .CR,<User location >
	JRST TRP2

;Try .JBINT manipulations here
;**;[406] At ITRAP:, Modified 1 line                        SM 15-Nov-82
ITRAP:	TMSGS .CRQ,<Address check or illegal UUO at location >
TRP2:	HRRZ 2,PDL
	SUBI 2,1
	MOVEI 3,^D8
	MOVEI 1,PROJFN
	NOUT
	  JFCL
;**;[406] At TRP2: +6L, Modified 1 line                     SM 15-Nov-82
	TMSGS .CR,<Instruction = >
	HRRZ 2,PDL
	MOVE 1,-1(2)
	PUSHJ P,TYPINS		;TYPE OUT INSTRUCTION
;**;[406] At TRP3:, Modified 1 line                         SM 15-Nov-82
TRP3:	TMSGS .CR
	MOVEI 1,PRIJFN		;CLEAR TYPE AHEAD
	CFIBF			;  ON ERRORS
	TRO PF,R.FERR		;FLAG ERROR TO PREVENT SUICIDE
	JRST EXIT2		;RESTORE ACS AND HALTF

TYPINS:	PUSH P,A		;SAVE INSTRUCTION TO BE TYPED
	HLRZ B,A		;GET LH
	MOVEI A,PROJFN		;GET OUTPUT DESIGNATOR
	MOVEI C,10		;OCTAL
	NOUT
	 JFCL
	TMSG<,,>		;LH,,RH
	HRRZ B,0(P)		;GET RH
	NOUT
	  JFCL
	HLLZ B,0(P)		;GET INSTRUCTION OP CODE
	TLC B,(<JRST 4,0>)	;IS THIS A HALT?
	TLNE B,777400
	  JRST APOPJ		;NO, EXIT
	TMSG< (HALT)>		;YES, TYPE HALT
	JRST APOPJ		;AND RETURN

ERRINT:
IFN FTSTAT,<
	TLNE PF,L.LSTA		;LOCAL STATISTICS BEING DONE?
	  AOS STATLC+ST.UEI	;YES, COUNT UP UNEXPECTED INTERRUPTS
	TLNE PF,L.GSTA		;GLOBAL STATISTICS BEING DONE?
	  AOS STATGC+ST.UEI	;YES
>
	DEBRK
	HALTF

;CALL SIXBIT TABLE HERE BECAUSE RARELY USED.
DEFINE CC (A,B)
<
	SIXBIT /A/ >

MCALT:			;TABLE FOR CALL FOR NEG CALLI'S
MCALLI				;SIXBIT NAMES OF NEGATIVE CALLS
NMCAL==.-MCALT			;NUMBER OF MINUS CALLS

CALLIT:
DEFINE CC (A,B)<
 IFL <.-CALLIT-MXSIXB-1>!<FTDEB>,<
	SIXBIT /A/
>> ;IF FTDEB ON, DO ALL, ELSE ONLY DO UP TO MXSIXB

PCALLI				;SIXBIT TABLE OF POSITIVE CALLI'S

NPCAL==.-CALLIT			;NUMBER OF POSITIVE CALLS

ILEGAL:	PUSHJ P,ITRAP		;ILLEGAL UUO CATCHER

EXIT:	TRZ PF,R.EXIT		;ASSUME EXIT 0,
	CAIE AC,0		;MONRET AS OPPOSED TO EXIT?
	TROA PF,R.EXIT		;YES. FLAG THAT.
	PUSHJ P,IRESET		;RELEASE IF CALLI 0,12

EXIT2:	MOVE A,PDL		;CALLING PC
	MOVEM A,JOBPD1		;TO STACK
	MOVEM A,.JBOPC		;AND TO .JBOPC EARLY, SINCE WILL KILL PAT.
;**; At EXIT2: +3L, shuffled code and old edits		SM	2-Feb-82
;**;[424] CANCEL 4 LINES AT EXIT2+3
;	MOVEI	T4,TTSTO	;[401] NEATEN UP AND GET TERM SET RIGHT
;	PUSHJ	P,TERSAV	;[401] (first save current state against CONT)
;	MOVEI	T4,TTSTI	;[401] (now get old state)
;	PUSHJ	P,TERRES	;[401] ..
	TRNE	PF,R.SU2	;[401] SUICIDE WITHOUT VESTIGALS?
	JRST	EXIT4		;[401] YES, SKIP MAKVES CALL
	SKIPE JBHRL
	PUSHJ P,MAKVES		;YES. MAY BE LOADER EXIT. MAKE HIGH VEST
;**;[367] At EXIT2: +8L, Deleted 2 lines        	SM	16-Sep-81
	TRNE PF,R.SUIC		;SUICIDE COMPT.?
	JRST EXIT4		;YES, TYPE NOTHING
	TRNE PF,R.EXIT!R.FERR	;EXIT OR MONRET, OR FATAL ERROR?
	JRST EXIT3		;MONRET. DON'T SAY "EXIT"
;**;[406] At EXIT2: +17L, Modified 1 line                   SM 15-Nov-82
	TMSGS .CR,<EXIT
>
EXIT4:	PUSHJ P,CLRALL		;CLEAR ALL PSI ACTIVITY
	SKIPLE A,TMPJFN		;IS THE TMPCOR FILE OPEN?
	  RLJFN			;YES, CLOSE IT
	  JFCL
	SETZM TMPJFN		;CLEAR ITS JFN
	MOVEI A,SUICA-1		;STASH SOME AC'S
	PUSH A,ACS+A		;IN LOW CORE
	PUSH A,ACS+B
	PUSH A,ACS+C
	SETZM INPAT		;NOTE THAT NO LONGER HAVE A STACK
	MOVE A,[XWD ACS+D,D]	;RESTORE REST OF USER'S AC'S
	BLT A,17		; ..
	MOVE A,[XWD KSUIC,SUICID] ;MOVE THE SUICIDE CODE TO LOW CORE
	BLT A,ESUIC		; ..
	MOVE A,[JRSTF @JOBPD1]	;INSTR TO REPLACE HALTF WITH
	TRNE PF,R.SUIC		;COMMITTING SUICIDE?
	MOVEM A,SUICX		;YES, REPLACE HALTF
	TRNE PF,R.SUIC		;ALSO INCR JOBPD1 IF SUICIDE FUNCTION
	AOS JOBPD1		; TO GIVE SKIP RETURN
	MOVSI B,.FHSLF		;THIS FORK FOR PMAP
	SETO A,			;TO NONEXISTENCE
	HRRI B,PATPAG		;CLEAR STARTING AT BEGINING OF PAT
	TLNE PF,L.FLSR		;FILSER MAPPED IN?
	  HRRI B,FLSRPG		;START AT FILSER START ADR
	MOVEI C,NPATPG		;THRU END OF PAT
	TLNE PF,L.FLSR		;FILSER MAPPED IN?
	  ADDI C,PATPAG-FLSRPG	;YES, GET UPDATED COUNT
	TLO C,(1B0)		;WITH A MULTIPLE PMAP
	MOVE 0,ACS		;RESTORE USER AC 0
	JRST SUICID		;AND GO DELETE PA1050 FROM MAP

EXITM1:	SOS PDL			;BACK UP PC TO POINT TO UUO
	SOS MONUPC		;THIS TOO IN CASE DDT IS TYPED (FOR .JBOPC)
;**;[367] At EXIT3:, Added 5 lines              	SM	16-Sep-81
EXIT3:	MOVEI T4,TTSTO		;[367] SET UP TO SAVE CURRENT TTY STATE
				;[367]  IN CASE A CONTINUE HAPPENS
	PUSHJ P,TERSAV		;[367] SAVE STATE
	MOVEI T4,TTSTI		;[367] GET STATE ON ENTRY
	PUSHJ P,TERRES		;[367] AND RESTORE IT FOR USER
	MOVEI A,EXIT1		;GET ADDRESS TO CONTINUE AT
	EXCH A,PDL		;GET USERS PC
	MOVEM A,EXITPC		;SAVE IN CASE HE CONTINUES
	MOVEM A,.JBOPC		;SAVE ADR OF LAST USER PC
	PUSHJ P,CLRCCI		;CLEAR CONTROL-C INTERCEPT
	JRST MRETN		;RESTORE AC'S AND HALT

EXIT1:	HALTF
EXITH==.			;PC OF HALTF
	MOVEM 17,ACS+17
	MOVEI 17,ACS
	BLT 17,ACS+16
	MOVE P,PATSTK		;SETUP LOCAL STACK
;**;[367] At EXIT1: +6L, Replaced 3 lines with 4 	SM	16-Sep-81
	MOVEI T4,TTSTI		;[367] SET UP TO SAVE TTY STATE AGAIN..
	PUSHJ P,TERSAV		;[367] ..
	MOVEI T4,TTSTO		;[367] AND RESTORE PA1050'S ON LAST EXIT
	PUSHJ P,TERRES		;[367] ..
	HLLZ PF,PFLAGS		;FLAGS TO AC FOR PAT'S FLAGS.
	PUSH P,EXITPC		;SET UP RETURN PC
	TRNE PF,R.FERR		;FATAL ERROR?
	  PUSHJ P,CONERR	;YES, CANT CONTINUE
	PUSHJ P,SETCV		;SET COMPATIBILITY VECTOR
;**;[435] REMOVE 1 LINE AT KSUIC:-2L	DSW	22-APR-85
;	PUSHJ P,SETPSI		;IF CONTINUED
	JRST MRETN		;IF CONTINUED

KSUIC:				;CODE FOR SUICIDE OF PAT

	PHASE 20			;WHERE TO MOVE IT TO

SUICID:	PMAP			;DO IT.
	MOVEI A,.FHSLF		;CLOSE ALL FILES
	CLZFF
	DMOVE A,SUICA		;RESTORE LAST 3 ACS
	MOVE C,SUICC
SUICX:	HALTF			;THIS INSTR GETS REPLACED WITH JRSTF @JOBPD1
				; IF SUICIDE COMPT. UUO INVOKED
	JRST .-1
ESUIC==.-1
SUICA:	BLOCK 1
SUICB:	BLOCK 1
SUICC:	BLOCK 1

	..LPH==.-SUICID		;LENGTH OF THIS PHASE BLOCK
	PHASE KSUIC+..LPH	;RESUME OUTER PHASE BLOCK

;**;[377] At SETNAM:, Replaced 8 lines with 3   	SM	26-Jan-82
SETNAM:	MOVE	B,CAC
	MOVEM	B,LOWNAM	;[377] SAVE 6BIT NAME OF PROGRAM
	MOVE	A,['(PRIV)']	;[377] AND SET SUBSYS NAME TO (PRIV)
	SETSN
	  JFCL			;IGNORE ERROR RETURN
	JRST MRETN

LOGOUT:	GJINF			;SEE IF JOB IS LOGGED IN
	JUMPN A,EXIT		;IF LOGGED IN, JUST EXIT
	MOVNI A,1		;LOG THE JOB OUT
	LGOUT
	  JRST EXIT		;FAILED, TURN INTO AN EXIT
	JRST EXIT		;SHOULD NOT GET HERE

;COPY VESTIGAL JOB DATA AREA FROM LOSEG TO HISEG

MAKVES:	LDB A,[PAGEN HSORG]	;GET VEST JDA PAGE NUMBER
	HRLI A,.FHSLF
	RPACS			;GET PAGE ACCESS
	TXNN B,PA%WT!PA%CPY	;WRITABLE?
	POPJ P,			;NO, GIVE UP NOW
	MOVSI B,-NVSTIG
	MOVE A,HSORG		;GET HISEG ORIGIN
	HRLI A,B		;CONSTRUCT INDIRECT WORD HIORG(B)
MAKVS0:	JRST @VESTG2(B)

MAKVS2:	UMOVE D,@A		;GET CURRENT VALUE
	CAMN D,C		;IF DIFERENT WE WILL CHANGE IT
	  JRST MAKVS1		;DONT CHANGE IT SINCE PAGE BECOMES PRIVATE
	UMOVEM C,@A

MAKVS1:	AOBJN B,MAKVS0
	POPJ P,

VESTG2:	[UMOVE C,.JBSA
		JRST MAKVS2]
	[UMOVE C,41
		JRST MAKVS2]
	[UMOVE C,.JBCOR
		JRST MAKVS2]
	JRST [XCTUU <HLL C,.JBHRL>
		XCTUU <HRR C,.JBREN>
		JRST MAKVS2 ]
	[UMOVE C,.JBVER
		JUMPE C,MAKVS1
		JRST MAKVS2]


IFN FTFILSER,<

;INTERFACE TO TOPS-10 FILSER ROUTINES

VIRVEC=600000			;ENTRY VECTOR FOR FILSER MODULE

	VTHRIC==0		;THRICE ENTRY
	VUUO==1			;VIRUUO ENTRY
	VMUUO==2		;MONUUO ENTRY
	VMUPC==3		;MONUPC ENTRY
	VTDAT==4		;THSDAT ENTRY
	VTIME==5		;TIME ENTRY
	VDAT==6			;DATE ENTRY
	VPPN==7			;PPN ENTRY
	VACS==10		;ACS ENTRY

TONCE:	PUSHJ P,SETVVV		;GO SET UP VIRVEC VARIABLES
	JRST @VIRVEC+VTHRIC	;CALL ONCE ONLY CODE

TOPEN:	PUSHJ P,TMAP		;SEE IF FILSER IS MAPPED
	  JRST MRETN		;COULD NOT FIND FILSER DATA BASE
	PUSHJ P,SETVVV		;GO SET UP VARIABLES
	MOVE A,[OPEN TOPNBL]	;GET OPEN INSTRUCTION
	DPB AC,[POINT 4,A,12]	;SET UP AC FIELD
	MOVEM A,@VIRVEC+VMUUO	;SET UP UUO TO BE DONE
	SETZM @VIRVEC+VMUPC	;PC IS 0
	MOVEI A,17		;MODE 17 ONLY
	MOVEM A,TOPNBL
	MOVE A,DEVNAM(BB)	;GET DEVICE TO BE OPENED
	MOVEM A,TOPNBL+1	;STORE IN OPEN BLOCK
	SETZM TOPNBL+2		;NO BUFFER HEADERS
	PUSHJ P,@VIRVEC+VUUO	;GO DO UUO
	SKIPG @VIRVEC+VMUPC	;WAS IT SUCCESFUL
	  JRST MRETN		;NO
	SETZ B,
	JRST UOPENE		;CONTINUE THE OPEN

TLKUP:	PUSHJ P,SETVVU		;GO SET UP THE VARIABLES AND UUO
	MOVSI B,IOPENF!LOOKPF	;MARK THAT IT IS OPENED
	IORM B,FLAGWD(BB)
	HRRZ G,FORTY		;GET FILE LENGTH
	UMOVE A,0(G)		;GET FIRST WORD TO SEE IF EXTENDED
	TLNN A,-1		;SIXBIT NAME?
	CAIGE A,3		;NO, GREATER THAN 3 ARGUMENTS?
	  TRZA PF,R.UEXT	;THIS IS AN OLD STYLE LOOKUP
	TRO PF,R.UEXT		;EXTENDED LOOKUP
	UMOVE A,5(G)		;GET EXTENDED LOOKUP VALUE
	TRNE PF,R.UEXT		;EXTENDED LOOKUP?
	  JRST TLKUP1		;YES
	UMOVE A,3(G)		;NO, GET # OF WORDS IN FILE
	JUMPL A,TLKUP0		;NEGATIVE?
	HLRZS A			;GET BLOCKS IN RH OF A
	ASH A,7			;THIS IS + BLOCKS
	JRST TLKUP1
TLKUP0:	HLRES A			;GET NEG WORDS
	MOVNS A
TLKUP1:	MOVEM A,IOEOFP(BB)	;STORE FILE LENGTH
	JRST MRETN		;AND RETURN

TENTER:	PUSHJ P,SETVVU		;GO DO UUO
	MOVSI A,OOPENF!ENTERF	;SET FLAGS
	IORM A,FLAGWD(BB)
	JRST MRETN		;AND RETURN

TRENME:	PUSHJ P,SETVVU		;GO DO UUO
	JRST MRETN		;AND RETURN

TCLOSE:	PUSHJ P,SETVVV		;SET UP VARIABLES
	MOVE A,IOCNT		;GET CLOSE BITS
	HRLI A,(CLOSE)		;SET UP UUO
	DPB AC,[POINT 4,A,12]	;SET UP AC FIELD
	MOVEM A,@VIRVEC+VMUUO	;SAVE UUO
	MOVE A,MONUPC
	MOVEM A,@VIRVEC+VMUPC	;SET UP PC
	PUSHJ P,@VIRVEC+VUUO	;DO THE CLOSE
	JRST UCL3		;RETURN TO THE SIMULATED CLOSE
TUSET:	JRST SETVVU		;GO DO THE UUO

TRELEA:	PUSHJ P,URELR		;GO FORCE OUT THE LAST BUFFERS
	PUSHJ P,SETVVV		;RELEASE UUO
	MOVSI A,(RELEASE)	;SET UP UUO
	DPB AC,[POINT 4,A,12]	;SET UP CHANNEL #
	MOVEM A,@VIRVEC+VMUUO
	MOVE A,MONUPC		;SET UP PC
	MOVEM A,@VIRVEC+VMUPC
	PUSHJ P,@VIRVEC+VUUO	;GO DO RELEASE
	JRST MRETN		;AND THEN RETURN

TMOVB:	MOVE A,IOEOFP(BB)	;CALCULATE # OF WORDS LEFT IN FILE
	SUB A,IOBYTP(BB)	;FOR INPUT ONLY
	TRNN PF,R.DIRN		;IS THIS INPUT
	CAML A,IOCNT		;ARE THERE ENOUGH CHARACTERS
	  MOVE A,IOCNT		;YES
	JUMPLE A,CPOPJ		;IF ZERO DONT DO ANYTHING
	ADDM A,IOBYTP(BB)	;UPDATE POINTER
	MOVN B,A		;GET NEGATIVE COUNT
	ADDM B,IOCNT		;DECREMENT IOCNT
	MOVSS B			;SET UP IOWD FOR UUO
	HRR B,IOBPT		;GET USERS BUFFER AREA
	MOVEM B,TOPNBL		;SAVE IOWD
	ADDM A,IOBPT		;UPDATE BYTE POINTER
	SETZM TOPNBL+1		;ZERO TO END IO COMMAND LIST
	MOVE A,[INPUT TOPNBL]	;GET UUO TO BE DONE
	TRNE PF,R.DIRN		;IS THIS AN OUTPUT
	  HRLI A,(OUTPUT)	;YES, CHANGE IT TO OUTPUT UUO
	DPB AC,[POINT 4,A,12]	;SET UP CHANNEL #
	MOVEM A,@VIRVEC+VMUUO	;SAVE UUO TO BE DONE
	SETZM @VIRVEC+VMUPC
	PUSH P,D		;SAVE D FOR PAT
	PUSHJ P,SETVVV		;SET UP TIME AND DATE
	POP P,D
	PUSHJ P,@VIRVEC+VUUO	;DO THE UUO
	JRST CPOPJ1


TDOUUO:	PUSHJ P,TMAP		;GO SEE IF FILSER IS MAPPED IN
	  JRST MRETN		;HAD SOME TROUBLE
	PUSHJ P,SETVU1		;GO DO THE CURRENT UUO
	JRST MRETN		;AND RETURN TO THE USER

TMAP:	SKIPE FLSJFN		;IS FILSER ALREADY MAPPED?
	  JRST TMAP2		;YES, DONT MAP IT AGAIN
	MOVE A,JBREL		;SEE IF ENOUGH CORE
	CAMG A,JBHRL		;ANY HI-SEG?
	  MOVE A,JBHRL		;YES, USE IT
	CAIL A,FLSRLC		;ROOM LEFT FOR FILSER?
	  JRST TNOCOR		;NO, GO BOMB OUT
	PUSH P,C		;SAVE C FOR OPEN
	HRROI A,STRNG1		;SET UP TO GET FILSER NAME
	MOVEI B,"<"		;SET UP DIRECTORY NAME
	BOUT
	PUSH P,A			;SAVE THE STRING POINTER
	GJINF			;GET LOGGED IN DIR
	MOVE B,A			;ADD IT TO STRING
	POP P,A			;GET BACK STRING POINTER
	DIRST			;GET DIRECTORY NAME INTO STRING
	  JFCL
	MOVEI B,">"		;TERMINATE DIR NAME
	BOUT
	MOVE B,JOB		;WITH JOB NUMBER AS FIRST THREE LETTERS
	MOVE C,[XWD 140003,12]
	NOUT			;GET ASCIZ JOB NUMBER
	  POPJ P,		;OPPS, GIVE ERROR RETURN
	HRROI B,[ASCIZ/FILSER-DATA-BASE.TMP/]
	SETZ C,			;END ON ZERO BYTE
	SOUT			;BUILD GTJFN NAME
	MOVSI A,100001		;GET OLD FILE ONLY
	HRROI B,STRNG1		;SET UP FOR GTJFN
	GTJFN
	  JRST APOPJ		;COULD NOT FIND FILSER FILE
	MOVE B,[XWD 440000,302000]
	OPENF			;OPEN FOR READ AND WRITE
	  JRST APOPJ		;ERROR RETURN
	HRRZM A,FLSJFN		;STORE THIS JFN
	HRLZS A			;NOW MAP IN FILSER
	MOVSI B,.FHSLF		;INTO THIS JOB AREA
	HRRI B,FILPAG
	MOVSI C,140000		;READ AND WRITE
	MOVEI D,FILEND		;LAST PAGE TO BE MAPPED
TMAP0:	PMAP			;MAP IN PAGE
	CAIG D,(B)		;DONE?
	  JRST TMAP1		;YES
	AOS A
	AOJA B,TMAP0		;LOOP BACK FOR REST OF PAGES
	HRRZS A,FLSJFN		;CLOSE AND RELEASE JFN
	CLOSF			;SO IT GOES AWAY ON EXIT
	 JFCL
TMAP1:	POP P,C			;RESTORE C
	TLO PF,L.FLSR		;MARK THAT FILSER HAS BEEN LOADED
	MOVSI A,(CALLI)		;FAKE UP A RESET UUO
	MOVEM A,@VIRVEC+VMUUO	;TO CLEAR OUT ANY UNCLOSED FILES
	SETZM @VIRVEC+VMUPC	;USER PC IS 0
	PUSHJ P,@VIRVEC+VUUO	;DO THE RESET
TMAP2:	JRST CPOPJ1		;GIVE SKIP RETURN

TRESET:	JRST SETVU1		;GO DO THE UUO AND POPJ

SETVVU:	SETZM IOBYTP(BB)	;START AT WORD 0
	SETOM JFNTAB(BB)	;PRETEND WE HAVE A JFN
SETVU1:	PUSHJ P,SETVVV		;GO SET TIME AND DATE
	MOVE A,FORTY		;GET UUO TO DO
	MOVEM A,@VIRVEC+VMUUO	;SAVE FOR FILSER
	MOVE A,MONUPC		;GET USER PC
	MOVEM A,@VIRVEC+VMUPC
	PUSHJ P,@VIRVEC+VUUO	;GO DO UUO
	MOVE A,@VIRVEC+VMUPC	;GET NEW USER PC
	MOVEM A,PDL		;STORE FOR RETURN
	POPJ P,			;AND RETURN

SETVVV:	SETO B,			;GET DATE
	PUSHJ P,NODATE
	ANDI D,7777		;12 BITS ONLY
	DPB C,[POINT 3,D,23]	;ADD IN 3 HIGH ORDER BITS ALSO
	MOVEM D,@VIRVEC+VTDAT	;STORE FOR FILSER
	GTAD			;GET TIME AND DATE
	HRRZ B,A		;TRANSLATE TIME TO TOPS-10 FORMAT
	FLTR B,B
	FMPR B,[3.03407407]	;MAGIC NUMBER TO TURN SECONDS INTO TOPS-10 FORMAT
	FIXR B,B
	HLLZS A			;ZERO TIME PART
	ADD A,B			;ADD IN FRACTION OF A DAY
	MOVEM A,@VIRVEC+VDAT
	SETO B,			;NOW GET LOCAL TIME IN SECONDS
	SETZ D,
	ODCNV
	HRRZ A,D
	IMULI A,^D60		;CREATE JIFFIES
	MOVEM A,@VIRVEC+VTIME	;STORE FOR FILSER
	GJINF
	HRRZ A,B		;GET PPN
	PUSHJ P,PPNUNM		;UNMAP IT
	MOVEM A,@VIRVEC+VPPN	;SAVE OUR PPN
	MOVEI A,ACS		;GET USER ACS
	MOVEM A,@VIRVEC+VACS
	SETOM INFLSR		;DISABLE CONTROL-C DURING UUO
	PUSHJ P,CHKCCI		;TO KEEP DATA BASE IN TACT
	  JFCL
	POPJ P,			;AND RETURN

;**;[406] At TNOCOR:, Modified 1 line                       SM 15-Nov-82
TNOCOR:	TMSGS .CRQ,<Not enough core to merge in filser-data-base>
	JRST EXITM1

;ROUTINE TO SEE IF THIS IS A TOPS-10 PACK
;CALLED WITH SIXBIT NAME IN A
;SKIP RETURNS IF TOPS-10 PACK WITH 'DPAX' IN A AND STR IN B

DPACHK:	PUSH P,A		;SAVE DEV NAME
	PUSHJ P,GETPHY
	  JRST [HLRZ A,0(P)	;NONE, SEE IF NAME WAS DPAX
		CAIE A,'DPA'
		  JRST APOPJ	;NO, RETURN
		POP P,A		;GET NAME BACK
		MOVE B,A	;PUT IT IN B ALSO
		JRST CPOPJ1]	;AND RETURN
	HLRZ B,0(P)		;SEE IF THIS IS DPAX
	CAIN B,'DPA'
	  JRST [MOVE B,A	;YES, PUT PHYSICAL NAME IN B
		POP P,A		;AND DPAX IN A
		JRST CPOPJ1]	;AND RETURN
	HLRZ B,A		;GET GENERIC NAME OF PHYSICAL NAME
	CAIE B,'DPA'		;IS THIS A TOPS-10 PACK?
	  JRST APOPJ		;NO, RETURN
	POP P,B			;YES, GET BACK ORIGINAL NAME INTO B
	JRST CPOPJ1		;AND RETURN
>

;PRODUCE <SUBSYS>'S SHARE FILE OF THIS CODE


MAKEPF:	RESET			;CLEAR THE WORLD
	MOVE P,PATSTK		;NEED A STACK HERE
	PUSHJ P,CLRALL		;MAKE SURE NO LEFTOVER INTS
	MOVEI 1,.FHSLF
	MOVE 2,[XWD EVECL,EVEC]	;EXEC WILL SCVEC FROM THIS EVEC
	SEVEC			; WHEN IT BRINGS IN PA1050 ON A UUO
	HRROI T1,[ASCIZ /
Output file: /]
	PSOUT
	MOVEI T1,[GJ%FOU+GJ%MSG+GJ%CFM
		.PRIIN,,.PRIOU
		0		;DEFAULT DEVICE
		0		;DEFAULT DIR
		-1,,[ASCIZ /PA1050/] ;DEFAULT NAME
		-1,,[ASCIZ /EXE/] ;DEFAULT EXT
		-1,,[ASCIZ /777752/] ;DEF PROTECTION
		0]		;DEFAULT ACCT
	SETZ T2,
	GTJFN
	PUSHJ P,ERROR
	MOVEM A,JFNTAB		;PRESERVE OVER TYPEOUT
	TMSG < Saved version >	;COMMENT COMPLETED
	SKIPN PVLOC
;**;[406] At Output +16L, Replaced 1 line              SM 15-Nov-82
	JRST	[TMSG	<0>
		 JRST	MAKPF0]
	MOVEI A,PROJFN
	LDB B,[POINT 9,PVLOC,11]
	MOVEI C,10
	SKIPE B
	NOUT
	 JFCL
	LDB B,[POINT 6,PVLOC,17]
	JUMPE B,MAKPF1
	MOVEI A,PROJFN
	SUBI B,1
	IDIVI B,^D26		;1 OR 2 LETTERS?
	JUMPE B,[MOVE B,C
		JRST MAKPF2]
	PUSH P,C		;SAVE SECOND LETTER
	ADDI B,"A"-1
	BOUT
	POP P,B
MAKPF2:	ADDI B,"A"
	BOUT
MAKPF1:	MOVEI A,PROJFN
	HRRZ B,PVLOC		;TYPE VERSION IN OCTAL
	JUMPE B,MAKPF3
	MOVEI B,"("
	BOUT
	HRRZ B,PVLOC
	MOVEI C,10
	SKIPE B			;DON'T PRINT 0
	NOUT			;ON TTY
	  JFCL
	MOVEI A,PROJFN
	MOVEI B,")"
	BOUT
MAKPF3:	LDB B,[POINT 3,PVLOC,2]
	JUMPE B,MAKPF0
	MOVEI A,PROJFN
	MOVEI B,"-"
	BOUT
	LDB B,[POINT 3,PVLOC,2]
	MOVEI C,10
	NOUT
	 JFCL
;**;[406] At MAKPF0:, Modified 1 line                       SM 15-Nov-82
MAKPF0:	TMSG < as file
 >
	MOVEI A,PROJFN
	HRRZ B,JFNTAB
	MOVE C,[211112,,110011]
	JFNS			;TYPE FILE NAME
	MOVE A,JFNTAB
	HRLI 1,.FHSLF		;THIS FORK,
	HLRE 2,SJBSYM		;GET LENGTH OF SYMBOL TABLE
	MOVNS 2			;POSITIVE LENGTH
	ADDI 2,ENDFF		;PLUS WHERE THEY START IS END OF SYMS.
	LSH 2,-11		;BEGINNING OF THAT PAGE
	MOVNI 2,1(2)		;-<PAGE AFTER END>
	MOVSI 2,PATPAG(2)	;(PLUS START IS -LENGTH) TO LH
	MOVEI 3,PATLOC
	LSH 3,-^D9		;FIRST PAGE
;**;[345] CHANGE WORD @MAKPF0+16
	HRRI 2,520000(3)	;[345] WITH READ, COPY-ON-WRITE, AND EXECUTE ALLOW BITS
	MOVEI C,0		;DOCUMENTED TO WANT 0 IN C
	SSAVE			;CREATE SHARE FILE
	PUSHJ P,CRLF
	HALTF

;GET 10/50 .SHR TYPE FILE

GETSHR:	RESET			;CLEAR TOPS-20 STUFF
	CALLI 0			;'FIRST' UUO
	MOVE P,PATSTK
	SETOM INPAT
	HRROI 1,[ASCIZ /
.SHR FILE TO BE LOADED: /]
	PSOUT
	MOVSI 1,120003
	MOVE 2,[XWD PRIJFN,PROJFN]
	GTJFN
	PUSHJ P,ERROR
	MOVE 2,[XWD 440000,200000]
	OPENF
	PUSHJ P,ERROR
	MOVEI 7,.HSLOC		;HIGH SEGMENT ADDRESS
	MOVEM 7,HSORG		;DEFAULT HIGHSEG ORG
GSHR1:	BIN
	JUMPN 2,GSHR3		;IF NON-0, CAN'T BE END OF FILE
	GTSTS
	TLNE 2,1000
	JRST GSHR2
	SETZ 2,			;NOT EOF, STORE THE 0
GSHR3:	MOVEM 2,0(7)
	AOJA 7,GSHR1

GSHR2:	CLOSF
	PUSHJ P,ERROR
	MOVEI A,.HSLOC+10		;GIVE USER AT LEAST SOME HIGH SEG
	MOVEM A,JBHRL		;SO UMOVE'S WONT FAIL
	PUSHJ P,SETVES		;SETUP VESTIGAL DATA
	MOVEI 1,.FHSLF
	HRRZ 2,.JBSA
	HRLI 2,<JRST>B53	;LH SPECIFYING 10/50 ENTRY VECTOR
	SEVEC
	SETZM INPAT
	HALTF

;CREATE 10/50 SHR TYPE FILE

MAKSHR:	CALLI 0
	MOVE P,PATSTK
	SETOM INPAT
	PUSHJ P,MAKVES		;COPY JOB DATA AREA TO VESTIGAL AREA
	MOVEI A,.FHSLF
	UMOVE B,.JBSA
	HRLI B,1
	SEVEC			;SETUP ENTRR VECTOR

MAKS2:	HRROI A,[ASCIZ/
SSAV ON FILE = /]
	PSOUT
	MOVSI A,460003
	MOVE B,[XWD PRIJFN,PROJFN]
	GTJFN
	JRST MAKS2
	HRLI A,.FHSLF
	SETZ C,
	MOVE B,[XWD -300,400+520B26]
	SSAVE			;SSAVE PAGES 400 TO 677 WITH
				;READ, EXECUTE, COPY ON WRITE.
	PUSHJ P,CLRALL		;NO PI'S OR COMPATIBILITY VECTOR
	SETZM INPAT
	HALTF

;AFTER-LOADING FIXUP

LIN2:	MOVE P,PATSTK		;GET A STACK
	PUSHJ P,CLRALL		;CLEAR COMPAT VECTOR AND PSI SYSTEM
	SETO 1,
	MOVSI 2,.FHSLF
	MOVE 3,[1B0!PATPAG]	;CLEAR 0 TO PAT-1
	PMAP			;FLUSH EVERYTHING NOT IN PAT
	HALTF

	XLIST			;LITERALS
	LIT			;HIGH CORE LITERALS
	LIST

FFF0:
FFF:	BLOCK 100		;PATCH SPACE
ENDFF:				;END OF EVERYTHING, USED BY MAKEPF,LINIT

	DEPHASE

	LOC 140			;IN LOW SEGMENT FOR FIXUPS

;START HERE AFTER LOADING

LINIT:!	RESET			;TURN OFF PI SYSTEM
	MOVE P,[IOWD TSTKL,TSTK] ;SET UP A STACK TO USE
	MOVEI A,.FHSLF		;CLOBBER THE PSI SYSTEM
	DIR			; DISABLE SYSTEM
	CIS			;CLEAR ANYTHING PENDING
	SETO B,			;ALL ONES
	DIC			;DISABLE ALL CHANNELS
	MOVE A,[JRST COMPAT]	;SHOULD BE FIRST WORD OF PROGRAM
	CAMN A,KEVEC-PATLOC+LODORG ;IS IT?
	JRST LIN0		;YES. OK.
	HRROI A,[ASCIZ /
? LOADING ERROR
/]
	PSOUT			;SOMEONE HAS CHANGED THE LOADER!
	HALTF
LIN0:!	MOVEI B,PATPAG		;PAGE WHERE PAT LIVES
	HRLI B,.FHSLF
	SETO A,
	MOVE C,[1B0!NPATPG]	;CLEAR ALL OF PAT
	PMAP			;CLEAR AREA TO PUT CODE
	MOVE A,[XWD LODORG,PATLOC]	;READY TO BLT THE CODE
	BLT A,ENDFF		;WHERE IT SHOULD END
	MOVE A,[KEVEC,,EVEC]	;MOVE LITERAL VECTOR TO RUNNING VECTOR
	MOVEI B,EVECL(A)	;END OF RUNNING VECTOR
	BLT A,-1(B)		;SEEMS TO BE ONLY WAY TO GET TO 700000.
	HLRE A,.JBSYM		;-LENGTH OF SYM TAB
	MOVMS A			;+ LENGTH OF SYM TAB
	HRLZ B,.JBSYM		;WHERE SYMTAB NOW STARTS
	HRRI B,ENDFF		;WHERE IT WILL START
	HRRM B,.JBSYM		;UPDATE .JBSYM ITSELF
	BLT B,ENDFF(A)		;MOVE THE SYMBOLS
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /SYS:UDDT.EXE/]
	GTJFN
	PUSHJ P,ERROR
	HRLI 1,.FHSLF
	GET			;GET DDT
	MOVE 1,.JBSYM
	MOVEM 1,@DDTLOC+1	;SETUP DDT SYMTAB PTR
	MOVEM 1,SJBSYM		;STORE AT ENTRY VECTOR+DELTA TOO
	MOVE 1,.JBUSY		;GET UNDEFINED SYMBOL TBL POINTER
	MOVEM 1,@DDTLOC+2	;STORE IT
	JRST LIN2		;COMPLETE FIXUP IN HIGH CORE

	TSTKL==10
TSTK:	BLOCK TSTKL

	END LINIT
