
!+
! This file, EDT.REQ, contains definitions for EDT.
!
!  COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATIO 1981, 1988 ALL RIGHTS RESERVED.
!
!  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
!  ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
!  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
!  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
!  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
!  TRANSFERRED.
!
!  THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
!  AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
!  CORPORATION.
!
!  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
!  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!
!
! Edit history:
!
! 1-001	- Beginning of edit history.
! 1-002	- Add ASSERT macro, remove bugcheck codes.  JBS 01-Jun-1981
! 1-003	- Offset the PDP-11 error codes, so they can be distinguished
!	   from system-specific error codes.  JBS 16-Jul-1981
! 1-004	- Remove the error messages, putting them in 
!	   ERRMSG.REQ.  JBS 20-Jul-1981
! 1-005 - Add two fields to TBCB ; one  points to the previous buffer,
!	   the other marks the buffer as a macro. Delete 
!	   the creation of the MAC_BLOCK structure TMV 6-Aug-81
! 1-006 - Add the verb number for the new bell verb. STS 10-Aug-1981
! 1-007	- Add INP_JOURNAL and INP_COMMAND to replace INP_FILE.  This
!	   lets us journal the responses to SUBSTITUTE/QUERY in
!	   the journal file.  JBS 16-Aug-1981
! 1-008 - Add the verb number for the new day/time verb. STS 31-Aug-1981
! 1-009	- Update the routine and variable names.  JBS & TMV 16-Aep-1981
! 1-010 - Add new verbs to set up default verb. STS 21-Sep-1981
! 1-011 - Add new verbs for delete select and toggle select. STS 23-Sep-1981
! 1-012 - Add new search and select verb. STS 24-Sep-1981
! 1-013 - Add literals for word and para types. STS 23-Oct-1981
! 1-014	- Add PREV_RANGE.  JBS 02-Nov-1981
! 1-015 - Add definitions for file i/o codes and streams.  STS 08-Dec-1981
! 1-016 - Change edt$$k to edt$k for file i/o definitions. STS 09-Dec-1981
! 1-017 - Add macro to set up address and length in string desc. STS 11-Jan-1982
! 1-036 - Fix above macro to work with 11's.  STS 13-Jan-1982
! 1-019 - Add literals for open output seq and open output noseq. STS 13-Jan-1982
! 1-020 - Chang string_desc macro for bliss16.  STS 15-Jan-1982
! 1-021 - Change 32-bit arithmetic to 48-bit arithmetic.  SMB 15-Jan-1982
! 1-022 - Modify block allocation so that odd address traps don't occur on 11's.  SMB 25-Jan-1982
! 1-023 - Remove original line numbers.  SMB 29-Jan-1982
! 1-024 - Make callable literals global. STS 08-Mar-1982
! 1-025 - Remove callable literals. STS 08-Mar-1982
! 1-026	- Add symbols for control C handling.  JBS 24-May-1982
! 1-027 - Change VMS multiply.  SMB 25-May-1982
! 1-028	- Add FMT_BUFLEN.  JBS 05-Jul-1982
! 1-029 - Add verb for xlate. STS 13-Aug-1982
! 1-030	- Remove the keypad definitions to KEYPADDEF.REQ.  JBS 13-Aug-1982
! 1-031	- Add ASC_K_CSI, for 8-bit keyboards.  JBS 17-Aug-1982
! 1-032	- Add ASC_K_SS3, for 8-bit keyboards.  JBS 20-Aug-1982
! 1-033 - Add verb_k_clss. STS 26-Aug-1982
! 1-034	- Add K_RDAHED_LEN.  JBS 31-Aug-1982
! 1-035 - Add new screen data structures.  SMB 11-Sep-1982
! 1-036 - Put back a line that was deleted by mistake.  SMB 15-Sep-1982
! 1-037	- Revise the EDIT section of the new screen data structures.  JBS 17-Sep-1982
! 1-038	- Add CC_RDCNT.  JBS 17-Sep-1982
! 1-039 - Remove CC_RDCNT. STS 20-Sep-1982
! 1-040 - Work on conditionalizing addline macro for speed. STS 30-Sep-1982
! 1-041 - Add memory allocation maximum.  SMB 18-Oct-1982
! 1-042 - Add macros for comparing line numbers. STS 20-Oct-1982
! 1-043 - Work on 11-version of compare macro. STS 21-Oct-1982
! 1-044 - Bind high word of linenumbers in compare macro. STS 21-Oct-1982
! 1-045 - Fix bug in compare. STS 22-Oct-1982
! 1-046 - Work on 11 version of compare macro. STS 26-Oct-1982
! 1-047 - Change 11 compare to call EDT$$CMP_LNO. STS 27-Oct-1982
! 1-048	- Add SCR_EDIT_MINPOS, remove a bunch of unused and obsolete definitions.  JBS 27-Oct-1982
! 1-049	- Reduce the size of the screen edit area on the PDP-11.  This saves
!	   space at the expense of time.  JBS 15-Nov-1982
! 1-050	- Remove the edit buffer entirely.  JBS 27-Dec-1982
! 1-051	- Reduce the amount of code generated by the ASSERT macro, to try
!	   to save space on the PDP-11.  JBS 16-Jan-1983
! 1-052	- Correct the definition of SS3.  JBS 19-Jan-1983
! 1-053 - Change the format buffer size for VMS.  SMB 24-Feb-1983
!
! 3-001 - Start of modifications for Tops10/20.  CG 15-Nov-82
! 3-002 - Use XPORT $FIELD for field definitions.
! 3-003 - Redefine TBCB fields and various macros under BLISS36 conditionals.  GB 12-Dec-82
! 3-004 - Add STRING_9 macro for 9-bit strings. CJG 3-Jun-1983
! 3-005 - Change journal constants. CJG 17-Jun-1983
! 3-006 - Change the way that filespecs are handled. CJG 22-Jun-1983
! 3-007 - Add COM_PUSH for PUSH command. CJG 20-Sep-1983
! 3-008 - Fix TBCB layout to stop consistency checks on very large files. CJG 11-Oct-1983
! 3-009 - Make the internal read-ahead buffer the same length as the system
!	  buffer to prevent data corruption. CJG 21-Dec-1983
! 3-010 - Modify ASSERT macro to include an error code. CJG 30-Jan-1984
!--

!+
! DEFINITION DEFINITIONS
! ~~~~~~~~~~~~~~~~~~~~~~
!
! The following definitions are used to facilitate further definitions.
!-

!+
! Field definition macros.  This set of macros allows for definitions
! of the fields of data structures, letting the compiler compute the
! the offsets.
!-

LIBRARY 'BLI:XPORT';

COMPILETIME FIELD_OFFSET = 0;

! Macro to copy a lump of memory

    MACRO EDT$$CPY_MEM (LEN, SRCPTR, DSTPTR) = BEGIN EXTERNAL ROUTINE CPYMEM;
	 CPYMEM (LEN, SRCPTR, DSTPTR) END %;

! Macro to copy a string

    MACRO EDT$$CPY_STR (LEN, SRCPTR, DSTPTR) = BEGIN EXTERNAL ROUTINE CPYSTR;
	 CPYSTR (LEN, SRCPTR, DSTPTR) END %;


!+
! IMPLEMENTATION PARAMETERS.
!
! The following definitions are parameters used in the work-file system
! which may require re-definition for different implementations.
!-


LITERAL
    WF_BLN_LEN		= 18,
    LINE_NUM_LEN	= 18,	! Bit length of a line number. (actually 3*18=54)
    WC_K_NUM_BUKT	= 2;


!+
! TBCB DEFINITION
! ~~~~~~~~~~~~~~~
!
! 	The EDT work file can contain multiple, independent data sets
! referred to as Text Buffers.  A text buffer corresponds to the construct
! of the same name found in EDT user documentation, it is a seqential file
! of variable length records.  The records are grouped together into blocks
! of 512 characters.  The records in a block are sequentially ordered, 
! though the blocks themselves are not.  Each block contains a two-byte
! link to the previous and following blocks.  In addition to the lines in
! the work-file, an input file may be associated with a text buffer.  In this
! case the input file is logically placed at the end of the text buffer.
! The Text buffer is accessed via a control block called the Text Buffer
! Control Block, or TBCB.
!-

$FIELD
    TBCB_FIELDS =
	SET
	TBCB_LINE_ADDR	= [$POINTER],		! Pointer to current line.
	TBCB_CUR_BUKT	= [$SHORT_INTEGER],	! Current bucket number.
	TBCB_CUR_PAD	= [$SHORT_INTEGER], 	! Pad to make line number word aligned for arithmetic routines
	TBCB_CUR_LIN	= [$SHORT_INTEGER],	! Current line number.
	TBCB_CUR_LINM	= [$SHORT_INTEGER],
	TBCB_CUR_LINH	= [$SHORT_INTEGER], 
	TBCB_CHAR_POS	= [$SHORT_INTEGER],	 ! The character position within the line
	TBCB_FIRST_BUKT	= [$SHORT_INTEGER],	! First bucket number.
	TBCB_LAST_BUKT	= [$SHORT_INTEGER],	! Last bucket number.
	TBCB_INPUT_LINE	= [$SHORT_INTEGER],	! Number of last input line.
	TBCB_INPUT_LINM	= [$SHORT_INTEGER],
	TBCB_INPUT_LINH	= [$SHORT_INTEGER], 
	TBCB_LINE_COUNT	= [$INTEGER],		! Count of lines in buffer.
	TBCB_LC_M	= [$SHORT_INTEGER],
	TBCB_LC_H	= [$SHORT_INTEGER], 
	TBCB_CHAR_COUNT	= [$INTEGER],		! Count of chars in buffer.
	TBCB_INPUT_RAB	= [$ADDRESS],		! Pointer to input RAB.
						! Not a pointer on TOPS but used
						! to indicate if file is still open
	TBCB_PREV_BUF	= [$POINTER],		! Pointer to previous buffer
	TBCB_NEXT_BUF	= [$POINTER],		! Pointer to next text buffer.
	TBCB_IS_MAC	= [$POINTER],		! Buffer is a macro
	TBCB_NAME_LEN	= [$SHORT_INTEGER],	! Length of buffer name.
	TBCB_FILL_NAME	= [$SHORT_INTEGER],	! Name filler
	TBCB_NAME	= [$STRING(0)]		! Name of buffer
	TES ;
LITERAL
    TBCB_SIZE = $FIELD_SET_SIZE;

MACRO TBCB_BLOCK = BLOCK[TBCB_SIZE] FIELD(TBCB_FIELDS)% ;

!+
! The pos block is the portion of the TBCB which contains information needed
! to locate the current line.  This block must be identical to the first
! part of the TBCB or everything will fail.
!-

$FIELD
    POS_FIELDS =
	SET
	POS_LINE_ADDR	= [$POINTER],		! Pointer to current line.
	POS_CUR_BUKT	= [$SHORT_INTEGER],	! Current bucket number.
	POS_CUR_PAD	= [$SHORT_INTEGER],	! Pad to make line number word aligned for arithmetic.
	POS_CUR_LIN	= [$SHORT_INTEGER], 	! Current line number.
	POS_CUR_LINM	= [$SHORT_INTEGER],
	POS_CUR_LINH	= [$SHORT_INTEGER], 
	POS_CHAR_POS	= [$SHORT_INTEGER]
	TES ;

LITERAL
    POS_SIZE = $FIELD_SET_SIZE;		! Define size of position information

MACRO POS_BLOCK = BLOCK[POS_SIZE] FIELD(POS_FIELDS)%;

!+
! TEXT LINE DEFINITIONS
!
! A line number contains an integer part and a fractional part.
!-

$FIELD
    LIN_FIELDS =
	SET
	LIN_LENGTH	= [$SHORT_INTEGER],		! Length of line
	LIN_NEXT	= [$SHORT_INTEGER],		! Offset to next line in buffer
	LIN_NUM		= [$SHORT_INTEGER],		! The line number
	LIN_NUMM	= [$SHORT_INTEGER],
	LIN_NUMH	= [$SHORT_INTEGER], 
	LIN_PAD2	= [$SHORT_INTEGER],
	LIN_TEXT	= [$STRING(0)]			! The actual text
	TES ;

LITERAL
    LIN_FIXED_SIZE = $FIELD_SET_SIZE;

MACRO LIN_BLOCK = BLOCK[LIN_FIXED_SIZE] FIELD(LIN_FIELDS)%;

!+
! WORK-FILE BUCKET DEFINITIONS
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~
!
! The work file is orgainized into blocks of WF_BLOCK_SIZE characters.
! Each Text Buffer in the work file consists of a linked list of blocks.
!-

LITERAL WF_BUKT_SIZE = 512;		! Size of a work-file block (in words)
LITERAL BYTES_PER_WORD = 5;		! Number of bytes in a word
LITERAL BYTE_SIZE = 7;			! Size of a byte (in text buffer)

$FIELD
    WFB_FIELDS =
	SET
	WFB_PREV_BUKT	= [$SHORT_INTEGER],	! Number of previous bucket
	WFB_NEXT_BUKT	= [$SHORT_INTEGER],	! Number of next bucket
	WFB_END		= [$POINTER],		! Offset to last record in block
	WFB_RECORDS	= [$POINTER]		! Address of first record in block
	TES ;

LITERAL
    WFB_FIXED_SIZE = $FIELD_SET_SIZE;

!+
! LINE NUMBER BLOCK DEFINITIONS
!
! The line number is defined as a block, so it can be handled as
! one word and one half word.
!-

$FIELD
    LN_FIELDS =
	SET
	LN_LO = [$SHORT_INTEGER],
	LN_MD = [$SHORT_INTEGER],
	LN_HI = [$SHORT_INTEGER]
	TES;

LITERAL
    LN_SIZE = $FIELD_SET_SIZE;

MACRO LN_BLOCK = BLOCK [LN_SIZE] FIELD(LN_FIELDS) %;

STRUCTURE
    LNOVECTOR[I;N] = [N*LN_SIZE] (LNOVECTOR+I*LN_SIZE);

!+
! Semantic node definitions.
!
! The following defines the structures created by the EDT
! command parser semantic routines.  These structures form
! a tree-like representation of the command.
!
! The fields which are grouped together are re-definitions of the
! same slot for use in different types of nodes.
!-

FIELD NODE_FIELDS =
    SET

    NODE_TYPE	= [0,0,18,0],			! Identifies the type of node

    COM_NUM	= [0,18,18,0],			! Identifies the command
    RAN_TYPE    = [0,18,18,0],			! Identifier type of range
    OP_TYPE	= [0,18,18,0],			! Identifies type of operand
    SEQ_VAL	= [0,18,18,0],			! Did the seq switch have value.

    RANGE1	= [%UPVAL,0,%BPVAL,0],		! First range specifier
    RAN_VAL	= [%UPVAL,0,%BPVAL,0],		! Value for range specifier
    SW_BITS	= [%UPVAL,0,%BPVAL,0],          ! Bits for each possible switch
    SRCHADDR	= [%UPVAL,0,%BPVAL,0],		! Address of search string
    SET_TYPE	= [%UPVAL,0,%BPVAL,0],		! Which type of set command
    LEFT_OP     = [%UPVAL,0,%BPVAL,0],		! Left operand for binary ops
    OP_LEN	= [%UPVAL,0,%BPVAL,0],		! operand length for op nodes.
    OP_VAL	= [%UPVAL,0,%BPVAL,0],		! Operand value for numerics.
    COM_EXPR	= [%UPVAL,0,%BPVAL,0],		! Expression pointer for LET
    OP_LEFTOP	= [%UPVAL,0,%BPVAL,0],		! Left operand for operators.
    SUB_BASE	= [%UPVAL,0,%BPVAL,0],		! Substring base string.

    RANGE2	= [%UPVAL*2,0,%BPVAL,0],	! Second range specifier
    SUB_RANGE	= [%UPVAL*2,0,%BPVAL,0],	! Pointer to range for ranges
    STR_PNT	= [%UPVAL*2,0,%BPVAL,0],	! Pointer to a search string
    SRCHLEN	= [%UPVAL*2,0,%BPVAL,0],	! Search string length
    FILSPEC	= [%UPVAL*2,0,%BPVAL,0],	! File specification address
    SW_VAL1	= [%UPVAL*2,0,%BPVAL,0],	! First value for switches
    AS_STR	= [%UPVAL*2,0,%BPVAL,0],	! Addr of string for AS
    RIGHT_OP	= [%UPVAL*2,0,%BPVAL,0],	! Right operand for binary ops.
    BUF_NAME    = [%UPVAL*2,0,%BPVAL,0],        ! Address of buffer name
    OP_ADDR	= [%UPVAL*2,0,%BPVAL,0],	! Operand address for op nodes.
    COM_VARBL	= [%UPVAL*2,0,%BPVAL,0],	! Variable pointer for LET
    OP_RIGHTOP	= [%UPVAL*2,0,%BPVAL,0],	! Right operand for operators.
    SUB_START	= [%UPVAL*2,0,%BPVAL,0],	! Substring start pos.
    TAB_COUNT	= [%UPVAL*2,0,%BPVAL,0],	! Count for tabs adjust.

    SET_VAL1	= [%UPVAL*3,0,%BPVAL,0],	! Value for set command
    REPADDR	= [%UPVAL*3,0,%BPVAL,0],	! Replace string address
    FSPCLEN	= [%UPVAL*3,0,%BPVAL,0],	! File spec length
    AS_LEN	= [%UPVAL*3,0,%BPVAL,0],	! Length of string for AS
    BUF_LEN     = [%UPVAL*3,0,%BPVAL,0],        ! length of buffer name
    SUB_LENGTH	= [%UPVAL*3,0,%BPVAL,0],	! Substring length.

    NEXT_COM	= [%UPVAL*4,0,%BPVAL,0],	! Pointer to next command
    NEXT_RANGE  = [%UPVAL*4,0,%BPVAL,0],        ! Pointer to next range
    REPLEN	= [%UPVAL*4,0,%BPVAL,0],	! Replace string length
    SET_VAL	= [%UPVAL*4,0,%BPVAL,0],
    KEY_VAL     = [%UPVAL*4,0,%BPVAL,0],	! Number of key for def key
    
    PREV_RANGE	= [%UPVAL*5,0,%BPVAL,0],	! Reverse of NEXT_RANGE
    SWITS	= [%UPVAL*5,0,%BPVAL,0],	! Switch block pointer
    SW_VAL2	= [%UPVAL*5,0,%BPVAL,0],	! Second switch value

    SW_OVR1	= [%UPVAL*6,0,%BPVAL,0],	! Part of second switch value

    SW_OVR2	= [%UPVAL*7,0,%BPVAL,0]		! Part of second switch value

    TES;

LITERAL
    NUM_NODES	= 20,				! Number of semantic nodes
    NODE_SIZE	= 8*%UPVAL;			! Size of semantic node

LITERAL					! Node type equates

    COM_NODE	= 1,				! Command node
    RANGE_NODE	= 2,				! Range node
    STR_NODE	= 3,				! SUBSTITUTE strings
    SW_NODE	= 4,				! Option switch value
    OP_NODE	= 5;				! Expression operand

MACRO NODE_BLOCK = BLOCK[NODE_SIZE] FIELD(NODE_FIELDS) %;

!+
! ASCII CHARACTER DEFINITIONS
!
! Commonly used non-printing ASCII characters.
!-

LITERAL
    ASC_K_BS	= %O'10',
    ASC_K_TAB	= %O'11',
    ASC_K_LF	= %O'12',
    ASC_K_CTRL_K= %O'13',
    ASC_K_FF	= %O'14',
    ASC_K_CR	= %O'15',
    ASC_K_SO	= %O'16',
    ASC_K_SI	= %O'17',
    ASC_K_CTRL_U= %O'25',
    ASC_K_CTRL_Z= %O'32',
    ASC_K_ESC	= %O'33',
    ASC_K_SP	= %O'40',
    ASC_K_DEL	= %O'177',
    ASC_K_CSI	= ASC_K_ESC + %X'80',
    ASC_K_SS3	= ASC_K_SI + %X'80';
!+
! COMMAND NUMBER DEFINITIONS
!
! The following values are used in a command type node to specify which
! command it is.
!-

LITERAL
    COM_NULL	= 0,
    COM_CHANGE	= 1,
    COM_COPY	= 2,
    COM_DEFINE  = 3,
    COM_DELETE  = 4,
    COM_EXIT	= 5,
    COM_FIND	= 6,
    COM_INCLUDE = 7,
    COM_INSERT  = 8,
    COM_MOVE	= 9,
    COM_PRINT   = 10,
    COM_QUIT    = 11,
    COM_REPLACE = 12,
    COM_RESEQ   = 13,
    COM_SET     = 14,
    COM_SHOW    = 15,
    COM_SUBS    = 16,
    COM_TYPE    = 17,
    COM_WRITE   = 18,
    COM_SUBS_NEXT=19,
    COM_HELP	= 20,
    COM_CLEAR	= 21,
    COM_TADJ	= 22,
    COM_FILL	= 23,
    COM_DEF_MAC	= 24,
    COM_MAC_CALL= 25,
    COM_PUSH	= 26,
    COM_TRACE   = 27,
    COM_XDDT    = 28,
!   COM_VERIFY	= ?,
    LAST_COM	= 28;

!+
! RANGE TYPE DEFINITIONS
!
! The following constants are used in range nodes to specify the type of
! range.
!-

LITERAL
    RAN_NULL	= 0,
    RAN_NUMBER	= 1,
    RAN_DOT	= 2,
    RAN_STR	= 3,
    RAN_BEGIN	= 4,
    RAN_END	= 5,
    RAN_ORIG	= 6,
    RAN_PATTERN = 7,
    RAN_LAST	= 8,
    RAN_BEFORE	= 9,
    RAN_REST	= 10,
    RAN_WHOLE	= 11,
    RAN_SELECT	= 12,
    RAN_BUFFER	= 13,
    RAN_PLUS	= 14,
    RAN_MINUS	= 15,
    RAN_FOR	= 16,
    RAN_THRU	= 17,
    RAN_MINSTR	= 18,
    RAN_ALL     = 19,
    RAN_AND	= 20,
    NUM_RAN	= 20,   ! Total number of ranges
    NUM_SLR     = 7;    ! number of single line ranges

!
! Operand types for operand nodes.
!

LITERAL
    OP_STRING	= 0,	! Operand is a quoted string
    OP_NUM	= 1,	! Operand is a number
    OP_VAR	= 2,	! Operand is a variable
    OP_DOT	= 3,	! Operand is the dot pseudo variable
    OP_ADD	= 4,	! Operand is an addition operator
    OP_SUB	= 5,	! Operand is a subtractions operator
    OP_MULT	= 6,	! Operand is a multiplication operator
    OP_DIV	= 7,	! Operand is a division operator
    OP_AND	= 8,	! logical and
    OP_OR	= 9,	! logical or
    OP_LSS	= 10,	! compare for less
    OP_LEQ	= 11,	! compare for less or equal
    OP_EQL	= 12,	! Compare for equality
    OP_GEQ	= 13,	! compare for greater or equal
    OP_GTR	= 14,	! compare for greater
    OP_NEQ	= 15,	! compare for not equal
    OP_AMP	= 16,	! concatenation
    OP_SUBSTR	= 17,	! substringing
    OP_NEG	= 18,	! negation
    OP_NOT	= 19,	! logical not
    OP_LENGTH	= 20,	! length of
    OP_COL	= 21,	! current column
    OP_FIND	= 22,
    OP_POS	= 23,	! current position
    OP_LAST_OP	= 23;	! last operand type
!+
! LINE NUMBER HANDLING MACROS
!
! These macros are used for arithmetic involving line numbers, so it can
! be transportable across systems with various word lengths.  At least 48
! bits of precision are required for line numbers.  Line numbers are stored
! as an integer with a scale of -5, i.e. the true value * 10**5, so we can
! have 5 decimal positions and 10 integer positions in the line number.
!-

MACRO
    ADDLINE(S1,S2,D1) = 
	BEGIN EXTERNAL ROUTINE A54_ADD; A54_ADD(S1,S2,D1) END %,
    SUBLINE(S3,S4,D2) = 
	BEGIN EXTERNAL ROUTINE A54_SUB; A54_SUB(S3,S4,D2) END %,
    MULTLINE(S5,S6,D3) = 
	BEGIN EXTERNAL ROUTINE A54_MUL; A54_MUL(S5,S6,D3) END %,
    MOVELINE(S11,D6) =
	BEGIN EXTERNAL ROUTINE MOVELI; MOVELI(S11,D6) END %,
    BUILDLINE(S12,D7) = (D7 = S12; (D7+1) = 0; )%;

!+
! Option switch bit definitions
!-

LITERAL
    OPT_QUERY	=   2,
    OPT_BRIEF	=   4,
    OPT_NOTYP	=   8,
    OPT_SEQ	=  16,
    OPT_DUPL	=  32,
    OPT_SAVE	=  64,
    OPT_STAY	= 128,
    OPT_GO      = 256;

MACRO
    OPB_QUERY	= 1,1 %,
    OPB_BRIEF	= 2,1 %,
    OPB_NOTYP	= 3,1 %,
    OPB_SEQ	= 4,1 %,
    OPB_DUPL	= 5,1 %,
    OPB_SAVE	= 6,1 %,
    OPB_STAY	= 7,1 %,
    OPB_GO      = 8,1 %;

!
! Input source definitions.
!
! These constants define the source command line input.
!

LITERAL
    INP_TERM 	= 0,		! Terminal
    INP_MACRO	= 1,		! A macro
    INP_COMMAND = 2,		! The startup file
    INP_JOURNAL = 3;		! The journal file (only during /RECOVER)

!+
! Terminal type definitions.
!
! These literals define the type of terminal we are running on.
!

LITERAL
    TERM_UNKNOWN= 0,
    TERM_VT52	= 1,
    TERM_VT100  = 2,
    TERM_HCPY	= 3,
    TERM_VT10052= 4;

!+
! Length of type-ahead buffer
!-

LITERAL
    K_RDAHED_LEN = 256;

!
! Editor mode definitions.
!

LITERAL
    CHANGE_MODE 	= 0,
    LINE_MODE		= 1;

!
! definitions for types of words and paras
!

LITERAL
    DELIMITED		= 0,
    NOT_DELIMITED	= 1,
    WPSPARA		= 0,
    EDTPARA		= 1;


!+
! Define the error codes.
!-

REQUIRE 'EDTSRC:ERRMSG.REQ';


!+
! Definition of the screen update data structure.
!
! This structure has an entry for each line which is represented on the screen.
! In NOTRUNCATE mode, each record may occupy one or more screen lines.
!-

$FIELD
    SCR_FIELDS =
	SET
	SCR_PRV_LINE = [$POINTER],	! Pointer to the previous line
	SCR_NXT_LINE = [$POINTER],	! Pointer to the next line
	SCR_LINE_IDX = [$BYTE],		! The i'th screen line of this record
	SCR_CHR_FROM = [$BYTE],		! Workfile char position from
	SCR_CHR_TO   = [$BYTE],		! Workfile char position to
	SCR_EDIT_MINPOS = [$BYTE],	! Minimum position that has had an edit
	SCR_EDIT_MAXPOS = [$BYTE],	! Maximum position that has had an edit
	SCR_EDIT_FLAGS = [$BYTE]	! Modify, delete and insert flags
	TES;

LITERAL
    SCR_SIZE = $FIELD_SET_SIZE;


MACRO
    SCREEN_LINE = BLOCK [SCR_SIZE] FIELD(SCR_FIELDS) %;
!+
! These flags go in SCR_EDIT_FLAGS and are also used when calling EDT$$MRK_LNCHG.
!-
LITERAL
    SCR_EDIT_MODIFY = 1,		! This line has been modified
    SCR_EDIT_INSLN = 2,			! This line has been inserted
    SCR_EDIT_DELLN = 4;			! This line has been deleted



!+
! Define function for comparing string ptrs.
!-
    MACRO
	CH$PTR_GTR(P1,P2) = CH$DIFF(P1,P2) GTR 0 %,
	CH$PTR_GEQ(P1,P2) = CH$DIFF(P1,P2) GEQ 0 %,
	CH$PTR_EQL(P1,P2) = CH$DIFF(P1,P2) EQL 0 %,
	CH$PTR_LEQ(P1,P2) = CH$DIFF(P1,P2) LEQ 0 %,
	CH$PTR_LSS(P1,P2) = CH$DIFF(P1,P2) LSS 0 %,
	CH$PTR_NEQ(P1,P2) = CH$DIFF(P1,P2) NEQ 0 %;


!+
! Define the entity types.
!-

LITERAL

    ENT_K_CHAR	= 1,
    ENT_K_WORD	= 3,
    ENT_K_BW	= 5,
    ENT_K_EW	= 7,
    ENT_K_LINE	= 9,
    ENT_K_BL	= 11,
    ENT_K_NL	= 13,
    ENT_K_VERT	= 15,
    ENT_K_EL	= 17,
    ENT_K_SEN	= 19,
    ENT_K_BSEN	= 21,
    ENT_K_ESEN	= 23,
    ENT_K_PAR	= 25,
    ENT_K_BPAR	= 27,
    ENT_K_EPAR	= 29,
    ENT_K_PAGE	= 31,
    ENT_K_BPAGE	= 33,
    ENT_K_EPAGE	= 35,
    ENT_K_BR	= 37,
    ENT_K_ER	= 39,
    ENT_K_QUOTE	= 41,
    ENT_K_SR	= 43,
    LAST_K_ENT	= 43;

!+
! Define the verb numbers.
!
! These are the codes used to represent the change mode subcommands.
!
! The verbs from VERB_MOVE through VERB_APPEND require entities and
! their verb numbers must remain contiguous.
!-

LITERAL

    VERB_K_MOVE	= 	0,
    VERB_K_DELETE= 	1,
    VERB_K_REPLACE= 	2,
    VERB_K_CHGC	= 	3,
    VERB_K_CHGU =	4,
    VERB_K_CHGL =	5,
    VERB_K_SSEL = 	6,
    VERB_K_FILL	=	7,
    VERB_K_TADJ	=	8,
    VERB_K_CUT	= 	9,
    VERB_K_APPEND=	10,

    VERB_K_SEL	=	11,
    VERB_K_SUBS	=	12,
    VERB_K_PASTE=	13,
    VERB_K_INSERT=	14,
    VERB_K_XLATE=	15,
    VERB_K_CC	=	16,
    VERB_K_EXIT	=	17,
    VERB_K_SN	=	18,
    VERB_K_UNDC	=	19,
    VERB_K_UNDW	=	20,
    VERB_K_UNDL	=	21,
    VERB_K_ADV	=	22,
    VERB_K_BACK	=	23,
    VERB_K_REF	=	24,
    VERB_K_TOP	=	25,
    VERB_K_HELP	=	26,
    VERB_K_ASC	=	27,
    VERB_K_QUIT	=	28,
    VERB_K_SHL	=	29,
    VERB_K_SHR	=	30,
    VERB_K_TAB	=	31,
    VERB_K_TC	=	32,
    VERB_K_TD	=	33,
    VERB_K_TI	=	34,
    VERB_K_EXT	=	35,
    VERB_K_KS	=	36,
    VERB_K_DEFK	=	37,
    VERB_K_BELL =	38,
    VERB_K_DATE =	39,
    VERB_K_DUPC =	40,
    VERB_K_DLWC =	41,
    VERB_K_DMOV =	42,
    VERB_K_DESEL = 	43,
    VERB_K_TGSEL = 	44,
    VERB_K_CLSS	=	45,
    LAST_K_VERB	=	45;

!
! Changecase types.
!

LITERAL
	CASE_K_CHGC =	1,	! Invert case, corresponds to VERB_K_CHGC
	CASE_K_CHGU =	2,	! Upper case,  corresponds to VERB_K_CHGU
	CASE_K_CHGL =	3;	! Lower case,  corresponds to VERB_K_CHGL

!+
! PARSER OP-CODE DEFINITIONS
!
! The following are the op-codes accepted by the parser driver.
!-

LITERAL	
	OPC_ABORT	=	0,	! Abort the parse
	OPC_ACTION	=	1,	! Perform action routine
	OPC_CALL	=	2,	! Call sub-table
	OPC_RETURN	=	3,	! End of table or sub-table (return)
	OPC_GOTO	=	4,	! Unconditional goto
	OPC_OPTION	=	5,	! Optional phrase check
	OPC_REQUIRE	=	6,	! Require a specific token
	OPC_SELECT	=	7,	! select one of several options

	OP_ABORT	=	0,	! now the bit values
	OP_ACTION	=	32,
	OP_CALL		= 	64,
	OP_RETURN	=	96,
	OP_GOTO		=	128,
	OP_OPTION	=	160,
	OP_REQUIRE	=	192,
	OP_SELECT	=	224;

!+
! Token class definitions
!-

LITERAL
	CL_NAME		=	0,	! name class
	CL_NUMBER	=	1,	! the number class
	CL_SPECIAL	=	2,	! the special character class
	CL_STRING	=	3;	! The qouted string class


!+
! Parser token handling and matching macros
!-

MACRO
	PAR_MIN_LENGTH = 0,0,3,0 %,
	PAR_MAX_LENGTH = 0,4,4,0 %,
	PAR_OPT_PERCENT = 0,3,1,0 %,
	PAR_SYMBOL = 1,0,0,0 %;

!+
! Filespec parsing literal - used by JFNS calls.
!-

LITERAL	K_JFNS = %O'221120000001';


!+
! Miscellaneous definitions
!-


!+
! Descriptors on Tops10/20 are one word with the length in the
! left half and the address in the right half.
! File descriptor blocks are in the form a 6-word block containing the JFN,
! the length and address of the full filepec, and the pointers to the four
! main components - device, directory, name, and extension.
!-


MACRO
    DSC$L_DESC    = 0, 0,36,0 %,	! File descriptor
    DSC$A_POINTER = 0, 0,18,0 %,	! Pointer to filespec
    DSC$W_LENGTH  = 0,18,18,0 %,	! Length of filespec
    DSC$W_JFN     = 1, 0,18,0 %,	! JFN of file
    DSC$W_STATUS  = 1,18,18,0 %,	! File status
    DSC$A_DEVICE  = 2, 0,36,0 %,	! Pointer to device string
    DSC$A_DIRECT  = 3, 0,36,0 %,	! Pointer to directory string
    DSC$A_FNAME   = 4, 0,36,0 %,	! Pointer to filename string
    DSC$A_FEXTN   = 5, 0,36,0 %;	! Pointer to extension string

LITERAL
    DSC$K_SIZE = 6;			! Size of descriptor


MACRO STRING_DESC (DESC, LEN, ADDR) =
    BEGIN
    MAP
	DESC : BLOCK[1];
    DESC[DSC$A_POINTER] = ADDR;
    DESC[DSC$W_LENGTH] = .LEN;
    END %;

!+
! The following literals refer to file status.
!-

LITERAL
    EDT$K_FILE_OPEN   = 1,
    EDT$K_FILE_CLOSED = 0;

!+
! FLD macro is used to set up arbitrary fields given a mask. This is used in
! the parser and other places. 
!-

MACRO
    FLD (VAL, MSK) =
	((VAL) ^ (%NBITSU (MSK AND -MSK) -1 )) %;

LITERAL
    FLD_9B1 = %O'777000000000',			! First 9-bit byte
    FLD_9B2 = %O'000777000000',			! Second 9-bit byte
    FLD_9B3 = %O'000000777000',			! Third 9-bit byte
    FLD_9B4 = %O'000000000777',			! Fourth 9-bit byte
    FLD_LHS = %O'777777000000',			! Left half word
    FLD_RHS = %O'000000777777';			! Right half word

!+
! STRING_9 - generate a string of 9-bit bytes.
!
! This macro must be supplied with a string of values which will be placed
! in 9-bit bytes, 4 per word. If a byte is to be 0, it may be left blank.
! The string must contain an integral number of 4-bytes.
!-

MACRO
	STRING_9 (A,B,C,D)[] =
		FLD (%IF %NULL (A) %THEN 0 %ELSE A %FI, FLD_9B1) +
		FLD (%IF %NULL (B) %THEN 0 %ELSE B %FI, FLD_9B2) +
		FLD (%IF %NULL (C) %THEN 0 %ELSE C %FI, FLD_9B3) +
		FLD (%IF %NULL (D) %THEN 0 %ELSE D %FI, FLD_9B4)
	    %IF (%LENGTH GEQ 5) %THEN
		, STRING_9 (%REMAINING)
	    %FI %;

!+
! Screen handling definitions
!-

LITERAL
    NO_UPDATE	=	256,	! Indicating no update of current line needed
    NO_REFRESH	=	100,	! Indicating no refresh of screen needed
    MESSAG_LINE =	22,	! Line on which messages are displayed
    COMMAND_LINE=	23,	! Line on which command prompts are displayed
    DIR_FORWARD	=	1,	! Forward direction.
    DIR_BACKWARD=	0;	! Backward direction.

!+
! Definition of the ASSERT macro.  This macro calls EDT$$INTER_ERR if the
! condition is not true.
!-

MACRO ASSERT (CODE,CONDITION) =
    BEGIN
    IF (NOT (CONDITION))
    THEN
	BEGIN
	EXTERNAL ROUTINE EDT$$INTER_ERR : NOVALUE;
	EDT$$INTER_ERR (CODE);
	END;
    END %;

!+
! Symbols used in control C journaling.
!-

LITERAL
	CC_REC_SIZE = 14,		! Size of a control C record
	JOU_REC_ESC = %X'1F',		! First (escape) byte of a non-text record in the journal file
	CC_REC_FLAG = 1,		! Second byte: control C record
	CC_CTR_MAX = 4000000000;	! Maximum counter value in control C handling

!+
! Symbol used in the formatter
!-

LITERAL
	FMT_BUFLEN = 512;	! Length of the format buffer

!	End of file EDT.REQ
