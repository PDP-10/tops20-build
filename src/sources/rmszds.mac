TITLE	RMSZDS -- ENTRY VECTOR AND DISPATCH TABLE FOR RMS STUB 		;a506
SEARCH RMSINT,RMSMAC,MONSYM						;m501

REPEAT 0,<


;
;	COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION 1977, 1986.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED  AND
;	COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH
;	THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE  OR
;	ANY  OTHER  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE
;	AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE
;	SOFTWARE IS HEREBY TRANSFERRED.
;
;	THE INFORMATION IN THIS SOFTWARE IS  SUBJECT  TO  CHANGE  WITHOUT
;	NOTICE  AND  SHOULD  NOT  BE CONSTRUED AS A COMMITMENT BY DIGITAL
;	EQUIPMENT CORPORATION.
;
;	DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF
;	ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;

NAME:		RMSZDS
AUTHOR:		Andrew Nourse
(Adapted from RMSDSP, which was authored by S. BLOUNT)

EDIT DATE:	8-Aug-84
FUNCTION:	RMS-20 STUB JSYS DISPATCHER



REVISION HISTORY:

506		Development	(AN, 1-Aug-84) Write this module out of RMSDSP
>;;END OF REPEAT 0

LOC 137						;FOR VERSION # ON 10
$VERS

$PURE

SUBTTL	ENTRY POINTS TO RMS

	RELOC	400000

	ENTRY	RMS.EV

; ***	 PUSHJ ENTRY LOGIC ;
RMS$10::			;[3] CREATE OFFSET TO IDENTIFY CALLED ROUTINE
	REPEAT XX$MAX,<JSR CALDSP>					;;m521


;[71] Copyright notice, RL, 1-Jun-83

SMNCPY::ASCIZ\

	COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION 1977, 1986.
	ALL RIGHTS RESERVED.

\ ;[71]

CALDSP: Z
	MOVEM	T2,USERAC##+T2  ;[507] Preserve AC2
	MOVE	T2,CALDSP	;[507] Get calling addr
	SUBI	T2,RMS$10+1	;[3] GET OFFSET INTO TABLE OF ADDRESSES
	HRRZM	T2,UJSYS	;[3] STORE IT AWAY ;M506
	POP	P,RETPC		;STORE RETURN ADDRESS AWAY
	JRST	SETUP		;AND CONTINUE AS IF THIS WERE A JSYS

				; WITH THE /R OPTION, WHATEVER THAT MEANS

; ***	JSYS ENTRY LOGIC

RMS.EV==:VECLNG,,RMS$EV		;FOR SETTING RMS20 ENTRY VECTOR WITH LINK... /ST:RMS.EV

RMS$EV::JRST	RMS$20		;ADDRESS OF NORMAL DISPATCHER
	JRST	RMS20I		;ADDRESS OF RMS INITIALIZATION ROUTINE
	$VERS			;RMS VERSION #
	UJSYS##			;PLACE TO STORE JSYS CODE FROM MONITOR
	RETPC##			;PLACE TO STORE RETURN PC
VECLNG==.-RMS$EV		;LENGTH OF ENTRY VECTOR





RMS20I:	SETZM	INTFLG##	;FIRST TIME FOR EVERYTHING AGAIN.

RMS$20::
	MOVEM	T2,USERAC##+T2	;Don't clobber AC2 ;a521
	HRRZ	T2,UJSYS##	;GET JSYS CODE
	SUBI	T2,JS$MIN	;SUBTRACT BASE JSYS	
	CAILE	T2,C$MAX	;JSYS TOO HIGH?
	 SETO	T2,		;YES. THIS WILL POINT TO ERROR ROUTINE
	MOVEM	T2,UJSYS##	;[3] STORE OFFSET INTO TABLE
;	JRST	SETUP		;MERGE WITH PUSHJ ENTRY

SUBTTL	RMS COMMON ENTRY/EXIT CODE

;THIS ROUTINE IS THE FIRST ONE TO GET CONTROL AFTER A RMS MACRO
; HAS BEEN EXECUTED.  IT PERFORMS THE FOLLOWING FUNCTIONS:
;
;	1.  SAVE USER AC'S
;	2.  DISPATCH TO PROPER RMS ROUTINE
;
;COME HERE ON EITHER A DIRECT CALL (PUSHJ) OR AN RMS-20 JSYS.
;
SETUP:
	MOVE	T2,USERAC##+T2	;Don't clobber AC2 ;a521
	MOVEM	17,USERAC##+17	;SAVE LAST AC
	MOVEI	17,USERAC##	;SET UP TO SAVE USER AC'S
	BLT	17,USERAC##+16	;SAVE THEM

	MOVE	P, [IOWD PDLNG##,RMSTACK##] ;SET UP STACK ;A506

	;
	; Turn off trapping for page creation
	; This code (in section 0)
	; will only be executed the first time the code is executed.
	; After that, RMS, in its own section will do it, unless
	; the RMS JSYS to disable checking is used.
	; The code needs to be here for the initial setup because
	; bringing in RMS creates LOTS of pages.
	;

	SKIPE	INTFLG##	;[506] Is it the first time?
	  JRST	NOCHK1		;[450] Don't bother - go on
	SETOM	INTFLG##	;[506] Not any more.
	PUSH	17,T1		;[450] Save T1
	MOVEI	T1,.FHSLF	;[450] Get our interrupt mask
	RCM%			;[450] ...
	  ERCAL	MONERR		;[450] ... M506
	AND	T1,[EXP 1B22]	;[450] Save .ICNXP bit
	MOVEM	T1,INTMSK##	;[450] ...
	SKIPN	INTMSK##	;[450] Is trapping enabled?
	  JRST	NONXP1		;[450] No - don't worry
	MOVEI	T1,.FHSLF	;[450] Deactivate the channel
	MOVE	T2,[EXP 1B22]	;[450] ...
	DIC%			;[450] ...
	  ERCAL MONERR		;[450] ... M506
NONXP1:	POP	17,T1		;[450] Restore T1
NOCHK1:	MOVEI	T2,SU$SUC	;[450] ASSUME A SUCCESSFUL CONCLUSION
	MOVEM	T2,USRSTS##	;STORE IT IN USER STATUS FIELD
	SETZM	USRSTV##	;CLEAR STATUS-VALUE
	MOVE	T2,USERAC##+T2	; EXPECT 2 ARGUMENTS in ACs ;m521
	MOVE	T3,UJSYS##	;GET OFFSET INTO TABLE
	MOVE	T3,DSPTAB(T3)	;Get address of routine	;m521
	PUSHJ	17,(T3)		;Dispatch to routine	;m521
	JRST	USRRET		;Return to user

SUBTTL	EXIT CODE

UA%BLK==1			;?AB ADDRESS ORIG PASSED IN AC1




;
; HERE ON INVALID JSYS
;

BADJSY:	MOVEI	T2,ER$BUG	;ERROR CODE
	MOVEM	T2,USRSTS	;
	JRST	NONXP3		;GO INTO EXIT CODE

;
; HERE ON JSYS ERROR
;

MONERR:				;A506
	MOVEI	T1,.FHSLF	;A506
	GETER			;A506
	 ERJMP   .+1		;A506
	HRL	T2,UJSYS	;A506
	MOVEM	T2,USRSTV	;A506
	MOVE	T2,ER$BUG	;A506
	MOVEM	T2,USRSTS	;A506
	
USRERR::			;COME HERE ON BAD RETURN FROM RMS
	JFCL			;NO-OP, HERE ONLY TO PROVIDE PLACE TO SET BRK-PT
USRRET::			;COME HERE ON GOOD RETURN FROM ALL RMS MACRO'S
USRFOK::

	;[450] 
	;[450]  Restore user's page-creation trapping state
	;[450] 
	SKIPN	INTMSK##	;[450] Was user trapping?
	  JRST	NONXP2		;[450] No - don't reset anything
	MOVEI	T1,.FHSLF	;[450] Turn trapping on again
	MOVE	T2,[EXP 1B22]	;[450] ...
	AIC%			;[450] ...
 	  ERCAL MONERR		;M506
NONXP2:	MOVE	UA%BLK,USERAC##+UA%BLK ;[450][301] User's AC
	$FETCH	T2,STV,(UA%BLK)	; Get 2nd Status value from block 	;m506
	MOVEM	T2,USRSTV##	; Store it 				;m506
	$FETCH	T2,STS,(UA%BLK)	; Get Status value from block 		;m506	
	MOVEM	T2,USRSTS##	; Store it too				;m506
	CAIGE	T2,.ERBAS	;IS IT AN ERROR CODE(.GEQ. 300000?)
	 JRST	RETILN		;[301] No, just return in-line
NONXP3:	MOVE	T3,@RETPC	; GET ADDRESS TO RETURN TO
	AND	T3,[777740,,0]	;[301] Check only opcode and AC field
	CAMN	T3,[JUMP 16,]	;[3] IS IT AN ERJMP?
	JRST	DOJMP		;YES, "GOTO" ERROR ADDRESS
	CAME	T3,[JUMP 17,]	;[3] IS IT ERCAL?
	 JRST	RETILN		;[3] No, illegal call (Didn't use RMS macro).
				;[3] So just return in-line.
	MOVE	T1,USERAC+17	;[301] Fetch user's pushdown ptr.
	MOVE	T4,RETPC	;[3] Get return PC

	ADDI	T4,1		;SIMULATE PUSHJ AT LOCATION OF ERCAL
	PUSH	T1,T4		;...BY PUSHING @RETPC+1 ON STACK
	MOVEM	T1,USERAC+17	;[301] Save updated pushdown ptr.
;	JRST	DOJMP		;[301] and return.

;Do EACALC and return to where user told us.
; If not extended addressing, then we don't need to do an
;Effective address calcalation, because the section number will
;always be zero. Instead, just take the ERJMP instruction and
;make the opcode a JRST and the ac field be zero. Then XCT it after
;restoring the user's AC's.

DOJMP:
	MOVE	T3,RETPC	;[301] Get place where ERJMP/CAL is.
	MOVE	T3,(T3)		;[301] Get instruction
	TLZ	T3,777740	;[301] Turn off opcode, AC field
	IOR	T3,[JRST]	;[301] Make unconditional jump
	MOVEM	T3,RETPC	;[506] Store here a sec..
	MOVSI	17,USERAC##	;restore user AC's
	BLT	17,17
	HRRZ	2,USRSTS	;[301] Setup user status. Note - the original
				;[301] AC2 has been smashed.. it can't be used
				;[301] for indexing in the ERJMP/ERCAL.
	XCT	RETPC		;[506] Jump to desired location.

;
;Here to return in-line (through return PC)
;

RETILN:	MOVSI	17,USERAC##	;RESTORE USER AC'S
	BLT	17,17		;...
	HRRZ	2,USRSTS	;Return RMS status in AC 2
	JRST	@RETPC		;[3] Return.

SUBTTL	RMS DISPATCH TABLE

DEFINE	RMSVRB(NAME)<%$'NAME##> ;;INDIRECT TO ACTUAL PROCESSING IN RMS    ;m524



				; New verbs added			;a501vv
; THIS MUST COME IMMEDIATELY BEFORE DSPTAB.
	BADJSY			;UNIMPLEMENTED JSYS

DSPTAB::
	RMSVRB (OPEN)
	RMSVRB (CLOSE)
	RMSVRB (GET)
	RMSVRB (PUT)
	RMSVRB (UPDATE)
	RMSVRB (DELETE)
	RMSVRB (FIND)
	RMSVRB (TRUNCATE)
	RMSVRB (CONNECT)
	RMSVRB (DISCONNECT)
	RMSVRB (CREATE)
	RMSVRB (DEBUG)
	RMSVRB (RELEASE)
	RMSVRB (FLUSH)
	RMSVRB (MESSAGE)
	RMSVRB (NOMESSAGE)
	RMSVRB (DISPLAY)
	RMSVRB (ERASE)
	RMSVRB (FREE)
	RMSVRB	(UTLINT)
 	RMSVRB (NXTVOL)
 	RMSVRB (REWIND)
 	RMSVRB (WAIT)
 	RMSVRB (READ)
 	RMSVRB (SPACE)
 	RMSVRB (WRITE)
 	RMSVRB (PARSE)
 	RMSVRB (SEARCH)
 	RMSVRB (ENTER)
 	RMSVRB (EXTEND)
 	RMSVRB (REMOVE)
 	RMSVRB (RENAME)
	BADJSY	; FFFINT may not be called as a JSYS			;a524

PRGEND
TITLE RMSZGL - Global data for section 0 stub
SUBTTL	GLOBAL DATA DCLS

; DCL$GL - DEFINE GLOBAL AS SYMBOL AND UPDATE CURR OFFSET INTO GLOBS AREA
;
DEFINE DCL$GL(NAME$,SIZE$)<
	NAME$=:RMS$$G + G$OFFS		;;DEFINE LOCATION OF SYMBOL
	G$OFFS==G$OFFS+SIZE$		;;HOP OVER THE BLOCK SO DEFINED
>

EXTERN	RMS$$G				;STARTING ADDR OF GLOBALS SET IN LINK CMD LIST
G$OFFS==0				;INIT OFFSET

PDLNG=:^D500				;SIZE OF RMS'S STACK
					;SET IT SUCH THAT GLOBS AREA LT 2 PAGES

DCL$GL	(    RMSTACK, PDLNG)		;ONLY RMS STACK ON 1ST PAGE OF GLOB AREA
					; RMS INIT CODE (IN RMSOSM) NEEDS THIS

DCL$GL	(    USERAC,	20)		; STORE USER AC'S HERE
DCL$GL	(    UJSYS,	2)		;[300] STORE USER JSYS HERE
DCL$GL	(    RETPC,	2)		;[300] STORE USER RETURN PC HERE
DCL$GL	(    INTMSK,	1)		;[450] User's NXP interrupt mask
DCL$GL	(    USRSTS,	1)		; CONTAINS USER ERROR CODE
DCL$GL	(    USRSTV,	1)		; ADDITIONAL STATUS INDORMATION
DCL$GL	(    INTFLG,	1)		; FIRST-TIME-THROUGH FLAG

END
