TITLE	LODSRT - RMSLOD INTERFACE TO NON-ZERO SEGMENT SORT
SUBTTL	D.M.NIXON/DMN/PMV/PMV


;
;	COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION 1984, 1986.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED  AND
;	COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH
;	THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE  OR
;	ANY  OTHER  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE
;	AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE
;	SOFTWARE IS HEREBY TRANSFERRED.
;
;	THE INFORMATION IN THIS SOFTWARE IS  SUBJECT  TO  CHANGE  WITHOUT
;	NOTICE  AND  SHOULD  NOT  BE CONSTRUED AS A COMMITMENT BY DIGITAL
;	EQUIPMENT CORPORATION.
;
;	DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF
;	ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;

SEARCH	MACSYM,MONSYM
TWOSEG	400000				;PUT CODE IN HIGH SEGMENT
SALL
.DIRECTIVE	FLBLST, SFCOND

SUBTTL	TABLE OF CONTENTS FOR LODSRT


;                    Table of Contents for LODSRT
;
;
;                             Section                             Page
;
;   1  TABLE OF CONTENTS FOR LODSRT .............................   2
;   2  DEFINITIONS
;        2.1  Assembly Parameters, Entry Points, ACs ............   3
;        2.2  Typeout Macros ....................................   4
;        2.3  General description ...............................   5
;   3  TOPS-20 VERSION
;        3.1  SORT Main Entry Points ............................   6
;        3.2  Impure data .......................................  10
;        3.3  Error Messages ....................................  11
SUBTTL	DEFINITIONS -- Assembly Parameters, Entry Points, ACs

;PARAMETERS

LODEVC==3	;RMSLOD-SORT ENTRY VECTOR OFFSET

;ENTRY POINTS

ENTRY	SORT

;ACCUMULATOR DEFINITIONS

RV=0		;RETURN VALUE
T1=1
T2=2
T3=3
T4=4
P1=12
P2=13
P3=14		;SECTION # OF SORT
P4=15
AP=16
P=17

SUBTTL	DEFINITIONS -- Typeout Macros


DEFINE TYPE(MESSAGE)<
IFNB <MESSAGE>,<
	HRROI T1,[ASCIZ \MESSAGE\]
>
	PSOUT%
>

DEFINE TYPEC(ACC)<
 IFN <ACC>-T1,<
	HRRZ T1,ACC
 >
	PBOUT%
>

DEFINE $ERROR(Q,CODE,TEXT,MORE)<
E$$'CODE:
 IFB <MORE>,<
	TYPE <Q'SRT'CODE TEXT
>
 >
 IFNB <MORE>,<
	TYPE <Q'SRT'CODE TEXT>
 >
 IFIDN <Q'MORE><?>,<
	JRST	DIE
 >
>
SUBTTL	General description

COMMENT	\

This routine is built into RMSLOD.

When this routine is called for the first time it first looks for
SORT.EXE on SYS: and gives an error if not found.

It MAPs section 0 and section 1 together.

Then it loops through the section table looking for the next free
section above 1.  It jumps to itself in section 1 and does a GET
of SORT into the SORT section for all pages that exist, then uses
the SORT entry vector to get the addresses of the various SORT entry
points so that the user calls will go directly to SORT.

Use of %SRTAD

%SRTAD is a two word global PC word.
On the very first call to SORT %SRTAD+1 must be zero.
On subsequent calls %SRTAD+1 contains the PC of SORT.
%SRTAD is zero if SORT is in a non-zero section and -1 if it is in
section 0.
\
SUBTTL	TOPS-20 VERSION -- SORT Main Entry Points

SORT:	SKIPE	%SRTAD+1		; CALLED BEFORE?
	JRST	SORT5			; YES
	PUSHJ	P,.SAVE			; SAVE ACS
	SETZM	ERRFLG			; FLAG NO ERROR OCCURRED YET
	MOVX	T1,.FHSLF		; SAVE OUR ENTRY VECTOR
					;   SINCE GET% JSYS DESTROYS IT
	XGVEC%				; INCASE IN NON-ZERO SECTION
	  ERJMP	E$$SNA			; NOT RELEASE 5
	DMOVEM	T2,SAVEVC		; SAVE BOTH WORDS
	MOVEI	T1,.RFSFL+1		; LENGTH OF RFSTS% ARG BLOCK
	MOVEM	T1,RFSBLK+.RFCNT	; STORE
	MOVX	T1,RF%LNG+.FHSLF	; LONG FORM FOR THIS PROCESS
	MOVEI	T2,RFSBLK		; ARG BLOCK
	SETZM	RFSBLK+.RFSFL		; MAKE SURE ITS CLEAR
	RFSTS%				; GET STATUS
	  ERJMP	SORT1			; ASSUME NOT EXECUTE-ONLY
IFGE RF%EXO,<PRINTX ?ERROR - RF%EXO is not the sign bit>	; INCASE IT CHANGES
	SKIPGE	RFSBLK+.RFSFL		; RF%EXO IS SIGN BIT
	SKIPA	T1,[GJ%OLD!GJ%SHT!GJ%PHY]	; PHYSICAL ONLY IF EXECUTE-ONLY
SORT1:	MOVX	T1,GJ%OLD!GJ%SHT	; GET A JFN FOR SORT.EXE
	MOVE	P4,T1			; PUT IN SAFE PLACE FOR NOW
	MOVE	T1,[.FHSLF,,1]		; SEE IF SECTION 0 AND 1
	RSMAP%				;  ALREADY MAPPED TOGETHER
	  ERJMP	E$$SNA			; NOT RELEASE 5

; WE ARE RUNNING UNDER RELEASE 5 OR LATER

	AOJN	T1,SORT1A		; ALREADY DONE (T1 NOT = -1)
	MOVSI	T1,.FHSLF		; THIS FORK IN SECT 0
	MOVE	T2,[.FHSLF,,1]		; ...	    IN SECT 1
	MOVX	T3,SM%RWX+1
	SMAP%				; MAP SECTIONS 0 & 1 TOGETHER
	  ERJMP	E$$CM1			; CAN'T DO IT

SORT1A:	MOVE	T1,P4			; GET BACK GTJFN BITS
	HRROI	T2,[ASCIZ /SYS:SORT.EXE/]
	GTJFN%				;   ..
	  ERJMP	E$$CFS			; COMPLAIN IF WE CAN'T FIND SORT
	HRRZ	P4,T1			; PUT JFN IN A SAFE PLACE
SUBTTL	TOPS-20 Release 5

;LOOP THROUGH THE SECTIONS STARTING AT SECTION 2 LOOKING FOR A FREE ONE FOR SORT

SORT5A:	MOVEI	P3,1			; NOW FIND A FREE SECTION FOR SORT
SORT5B:	AOS	T1,P3			; TRY NEXT ONE
	CAILE	T1,37			; MAKE SURE SOME STILL LEFT
	JRST	E$$NFS			; NO FREE SECTIONS
	HRLI	T1,.FHSLF
	RSMAP%
	  ERJMP	E$$SNA			; ERROR
	AOJN	T1,SORT5B		; THIS ONE NOT FREE
	MOVEM	P3,GETARG+.GBASE	; SAVE SECTION # FOR GET

	SETZ	T1,			; DEFINE A MEMORY SECTION
	HRLI	T2,.FHSLF		;   ..
	HRR	T2,P3			;   ..
	MOVX	T3,<PM%RWX!1>		;   ..
	SMAP%				;   ..
	  ERJMP	E$$SNA			; FAILED, OTHER SECTIONS NOT AVAILABLE
;NOW GET SORT INTO THE NON-ZERO SECTION

SORT5C:	XMOVEI	T1,.			; SEE WHAT SECTION WE ARE IN
	TLNN	T1,-1			; IF ALREADY IN NON-ZERO SECTION STAY THERE

	XJRSTF	[0
		 1,,.+1]		; ELSE JUMP TO SECTION 1

SORT5D:	MOVX	T1,GT%LOW!GT%BAS	; LOAD UP GET% ARGS
	MOVEM	T1,GETARG+.GFLAG
	SETZM	GETARG+.GLOW
	SETZM	GETARG+.GHIGH
	HRLI	T1,.FHSLF		; DO A GET% ON SORT.EXE
	HRR	T1,P4			; GET JFN
	TXO	T1,GT%ARG!GT%NOV	; DON'T PRE-LOAD AS MOST IS NOT USED
	XMOVEI	T2,GETARG		; POINT TO ARG BLOCK
	GET%
	  ERJMP	E$$CGS			; FAILED

; GET SORT'S RMSLOD ENTRY VECTOR

SORT5E:	MOVEI	T1,.FHSLF		; GET SORT'S ENTRY VECTOR
	XGVEC%				;   ..
	CAIGE	T2,LODEVC+1		; IS ENTRY VECTOR LONG ENOUGH?
	JRST	E$$NDE			; NO--NO RMSLOD ENTRY VECTOR
	MOVE	P3,T3			; POINT TO SORT ENTRY VECTOR
	HLRZ	T1,LODEVC(P3)		; GET SIZE OF RMSLOD ENTRY VECTOR
	CAIE	T1,EVCLEN		; DOES ENTRY VECTOR CORRESPOND?
	  JRST	E$$UNE			;   NO, SOMETHING'S AMISS
	HRRZ	T2,LODEVC(P3)		; LOCAL ADDRESS OF RMSLOD VECTOR
	HLL	T2,P3			; MAKE IT GLOBAL
	XMOVEI	T3,%SRTAD+1		; CURRENT SECTION ADDRESS
	EXTEND	T1,[XBLT]		; MOVE THE ENTRY VECTOR TO CURRENT SECTION
SORT5F:	MOVEI	T1,.FHSLF
	DMOVE	T2,SAVEVC		; RESTORE USER'S ENTRY VECTOR
	XSVEC%

;HERE WHEN SORT IS READ IN

SORT5G:	HLLM	P3,%SRTAD+1		; FIX UP THE TRANSFER ADDRESSES

SORT3:	MOVEI	T1,1			; ADVANCE BYTE POINTER 1 CHAR
	IBP	T1,@0(16)		; GET BYTE POINTER
	LDB	T2,[POINT 6,T1,5]	; GET POSITION OF CHARACTER
	CAIE	T2,44-7			; AT BEGINNING OF WORD?
	 CAIN	T2,62			; OR ALIGNED OWGBP?
	  CAIA
	   JRST	E$$AQS			; ARGUMENT MUST BE QUOTED STRING
	CAILE	T2,44			; LOCAL BYTE POINTER?
	 TXZA	T1,77B5			; NO, CLEAR THE P&S FIELD
	  TXZ	T1,<37B5>!<77B11>!<@>	; YES, CLEAR P, S AND I FIELDS
	XMOVEI	T1,@T1			; GET ADDRESS OF THE POINTER
	MOVEM	T1,NEWARG+0		; STORE AS ADDRESS OF ARG
	MOVE	T1,-1(AP)		; GET WHOLE COUNT WORD
	MOVEM	T1,NEWARG-1		; SAVE IT AWAY IN NEW BLOCK
	XMOVEI	AP,NEWARG		; POINT TO THE NEW ARG BLOCK
	SETZ	T1,			; NO FUNCT.
	XMOVEI	T4,SORT4		; SORT'S RETURN ADDRESS
	SKIPE	%SRTAD
	JRST	@%SRTAD+1		; SECTION 0
	XJRSTF	%SRTAD			; NON-ZERO SECTION SORT

;Return from SORT to section 0

SORT4:	TDZA	RV,RV			; ERROR RETURN
	MOVEI	RV,1			; SUCCESS RETURN
	POPJ	P,			; RETURN TO CALLER

.SAVE:	PUSH	P,T2
	PUSH	P,T3
	PUSH	P,T4
	PUSH	P,P1
	PUSH	P,P2
	PUSH	P,P3
	PUSH	P,P4
	PUSHJ	P,@-7(P)		; CALL THE CALLER
	POP	P,P4
	POP	P,P3
	POP	P,P2
	POP	P,P1
	POP	P,T4
	POP	P,T3
	POP	P,T2
	POP	P,T1			;DELETE OLD RETURN ADDRESS
	POPJ	P,			; RETURN TO CALLER

;Here on subsequent calls, we must get to section 1

SORT5:	XMOVEI	T1,.			; SEE WHAT SECTION WE ARE IN
	SKIPN	%SRTAD			; DON'T BOTHER IF A NON-EXTENDED MACHINE
	TLNE	T1,-1			; IF ALREADY IN NON-ZERO SECTION
	JRST	SORT3			;  STAY THERE, ELSE JUMP TO SECTION 1
	XJRSTF	[0			;   ..
		 1,,SORT3]		;   ..

SUBTTL	TOPS-20 VERSION -- Impure data

	RELOC				; SWITCH TO LOW SEGMENT

;SET UP AFTER LODSRT MERGED IN

%SRTAD:	BLOCK	1			; SORT'S SRTINI XJRSTF PC
	Z				; MUST BE ZERO FIRST TIME

EVCLEN==1				; ENTRY VECTOR LENGTH (=1)

SAVEVC:	BLOCK	2			; SAVE USER'S ENTRY VECTOR

RFSBLK:	BLOCK	.RFSFL+1		; ARG BLOCK FOR LONG FORM RFSTS% JSYS

GETARG:	BLOCK	1			; EXP	GT%LOW!GT%BAS
	BLOCK	1			; EXP	0
	BLOCK	1			; EXP	0
	BLOCK	1			; SECTION # OF SORT

; SYMBOLS NOT IN MONSYM

SM%RWX==:SM%RD!SM%WR!SM%EX		; CONVENIENCE

	BLOCK	1			; HOLDS ARGUMENT COUNT
NEWARG:	BLOCK	1			; HOLDS ARGUMENT FOR SORT CALL

ERRFLG:	BLOCK	1			; FLAG ERROR OCCURRED HERE

	RELOC				; SWITCH BACK TO HIGH SEGMENT
SUBTTL	TOPS-20 VERSION -- Error Messages

E$$AQS:	$ERROR	(?,AQS,<Argument to SORT must be a quoted string.>)

E$$SNA:	$ERROR	(?,SNA,<Non-zero sections not available.>)

E$$CM1:	$ERROR	(?,CM1,<Can't MAP sections 0 and 1 together.>)

E$$NFS:	$ERROR	(?,NFS,<No free sections left.>)

E$$CGS:	$ERROR	(?,CGS,<Can't get SORT into non-zero section.>)

E$$NDE:	$ERROR	(?,NDE,<This SORT has no RMSLOD entry vector.>)

E$$UNE:	$ERROR	(?,UNE,<Unexpected number of SORT-RMSLOD entry points.>)

E$$CFS:	HRROI	T1,[ASCIZ /SYS:SORT.EXE/]	; MESSAGE WE WANT
	PUSH	P,T1
	SKIPL	RFSBLK+.RFSFL		; EXECUTE-ONLY?
	JRST	E$CFS1			; NO, USE OLD MESSAGE
	$ERROR	(?,XGF,<Execute-only GTJFN% failed for >,+)
	JRST	E$CFS2			; REST OF MESSAGE

E$CFS1:	$ERROR	(?,GFS,<GTJFN% failed for >,+)
E$CFS2:	POP	P,T1			; TYPE WHAT WE COULDN'T FIND
	TYPE				;   ..
	TYPE	<, >			;   FOLLOWED BY WHY (LAST PROCESS ERROR)
	MOVX	T1,.PRIOU
	MOVX	T2,<.FHSLF,,-1>		;  ..
	SETZ	T3,
	HRLZ	T3,T3			;  ..
	ERSTR%				;  ..
	  ERJMP	.+2			; IGNORE ERRORS AT THIS POINT
	  ERJMP	.+1			;  ..
	TYPE	<.
>

DIE:	SETOM	ERRFLG			; FLAG THAT ERROR OCCURRED
	SETZ	RV,			; RETURN ERROR CODE TO DTR20
	POPJ	P,

END
