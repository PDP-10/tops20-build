UNIVER	CPASYM  --  Parameter File For CMDPAR
SUBTTL	/PJT/MLB/DC/PJT 3-Oct-79


;
;
;
;	COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION 1975, 1986.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED  AND
;	COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH
;	THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE  OR
;	ANY  OTHER  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE
;	AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE
;	SOFTWARE IS HEREBY TRANSFERRED.
;
;	THE INFORMATION IN THIS SOFTWARE IS  SUBJECT  TO  CHANGE  WITHOUT
;	NOTICE  AND  SHOULD  NOT  BE CONSTRUED AS A COMMITMENT BY DIGITAL
;	EQUIPMENT CORPORATION.
;
;	DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF
;	ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;

	SALL				;SUPRESS MACRO EXPANSIONS

DEFINE TOPS10 <IFN TOP$10,>		;SETUP CONDITIONAL MACROS

DEFINE TOPS20 <IFN TOP$20,>


TOPS10 <
    IF1,<PRINTX Building a CPASYM-10 library>
	SEARCH	UUOSYM>			;SEARCH PROPER
TOPS20 <
    IF1,<PRINTX Building a CPASYM-20 library>
	SEARCH	MONSYM>			;UNIVERSAL FOR SYSTEM SYMBOLS

DEFINE VRSN.(PFX),<BYTE (3)PFX'WHO (9)PFX'VER (6)PFX'MIN (18)PFX'EDT>

SUBTTL Table of contents

SUBTTL	Accumulator Definitions

;THE FOLLOWING ACCUMULATOR DEFINITIONS ARE STANDARD THROUGHOUT THE
;	SUB-SYSTEMS GROUP AND MAY NOT BE CHANGED.  THE ACCUMULATORS DEFINED ARE:

	TF==0			;TRUE/FALSE REGISTER, NEVER REFERENCED DIRECTLY
				; USED BY $RETx AND JUMPT,JUMPF, SKIPT,SKIPF
	.SAC==0			;SCRATCH AC USED BY SOME NONE SKIPPABLE MACROS

	S1==1			;S1 & S2 ARE ARGUMENTS TO ROUTINES
	S2==2			;AND ARE OTHERWISE SCRATCH

	T1==3			;T1 - T4 ARE TEMPORARY REGS
	T2==4
	T3==5
	T4==6

	P1==7			;P1 - P4 ARE PRESERVED REGS
	P2==10
	P3==11
	P4==12
	.A13==13		;.A13 THRU .A16 NOT USED BY LIBRARY
	.A14==14
	.A15==15
	.A16==16

	.FP==16			;FRAME POINTER USED BY TRVAR AND ASUBR
				;MAY NOT BE CHANGED WITHIN THE SCOPE OF
				;A ROUTINE USING TRVAR OR ASUBR
				;HOWEVER -- IT IS PRESERVED OUTSIDE THE
				;SCOPE OF THESE ROUTINES

	P==17			;PUSHDOWN POINTER

;THERE ARE CO-ROUTINES DEFINED IN CPACOM TO SAVE AND AUTOMATICALLY
;	RESTORE THE "T" AND "P" THAT ARE INVOKED BY THE SAVE MACRO
;	CALLED AS FOLLOWS:

;	$SAVE <P1,P2,P3,P4>	;TO SAVE P1-P4
;	$SAVE <T1,T2,T3,T4>	;TO SAVE T1-T4
;	$SAVE <P1>		;TO SAVE P1
;	$SAVE <P1,P2,P3>		;TO SAVE P1-P3
;	$SAVE <T1,T2>		;TO SAVE T1-T2
;	$SAVE <TF,S1>		;TO SAVE TF AND S1 FOR RETURN TO CALLER
;				;AC'S ARE AUTOMATICALLY RESTORED ON RETURN

;AC'S 13,14,15 & 16 ARE AVAILABLE TO THE COMPONENT AND MAY BE USED
;	TO ANY END WITH THE NOTEABLE EXCEPTION:

;			* * * *  N O T E  * * * *

;	AC16 IS USED AS A FRAME POINTER FOR TRVAR AND ASUBR DYNAMIC
;	VARIABLE ALLOCATION.  IT MAY NOT BE REFERENCED WITHIN THE
;	RANGE OF THE TRVAR OR ASUBR, HOWEVER IT IS PRESERVED ON RETURN
;	TO THE CALLER.

;REFER TO CMDPAR.MEM FOR A FULL DESCRIPTION OF MACROS AND AC USAGE
SUBTTL	JUMPx, SKIPx Instruction OPDEFS

;All subroutines which follow CMDPAR conventions return a "success/failure"
; value in the register TF.  This is done by returning via one of 
; the return instructions, $RETE, $RETT  or $RETF (See next page).
;The value of TRUE or FALSE which a routine returns can be tested with one
;of the following instructions, which alter program flow according to
; the value currently in TF.

; Jump to location specified if TF contains TRUE

	OPDEF	JUMPT [JUMPN]

; Jump to location specified if TF contains FALSE

	OPDEF	JUMPF [JUMPE]

; Skip the next instruction if TF contains TRUE

	OPDEF	SKIPT [SKIPN]

; Skip the next instruction if TF contains FALSE

	OPDEF 	SKIPF [SKIPE]

; PJRST instruction OPDEF

	OPDEF	PJRST [JRST]
SUBTTL	ND, XP, EXT, and GLOB Macros

;Macro to Define a Symbol if not already defined
;	ND  SYMBOL,VALUE

DEFINE	ND(SYM,VAL),<IF2,<IFDEF SYM,<SYM==SYM>> IFNDEF SYM,<SYM==VAL>>


;Macro to Define a Symbol and force it INTERN
;	XP  SYMBOL,VAL,PRINT

;		Where PRINT is any Non-blank to allow printing from DDT

DEFINE	XP(SYM,VAL,PRINT),<IFB <PRINT>,<SYM==:VAL> IFNB <PRINT>,<SYM=:VAL>>

;Macro to EXTERN a Symbol if not defined in this routine
;	EXT SYMBOL

DEFINE	EXT(SYMBOL),<IRP SYMBOL,<
	IF2,<IFNDEF SYMBOL,<EXTERN SYMBOL>>>>


;Macro to EXTERN or INTERN a Symbol
;	GLOB SYMBOL

DEFINE	GLOB(SYMBOL),<IRP SYMBOL,<
	IF2,<IFDEF SYMBOL,<.IFN SYMBOL,EXTERN,<INTERN SYMBOL>>
	     IFNDEF SYMBOL,<EXTERN SYMBOL>
	     SUPPRES SYMBOL>>>
SUBTTL	CONT. LSTOF. LSTON. VRSN. Macro Definitions

;Macro to force page overflow with appropriate comments

DEFINE	CONT.(NAME)<LALL
PAGE; (NAME Continued on next page)
SALL; (NAME Continued from previous page)>


;Macros to turn on and off listings with nesting and level control
;	LSTOF.			;TURNS OFF LISTINGS ONLY
;	LSTOF. XCREF		;TURNS OFF LISTINGS AND CREF
;	LSTON.			;RESTORES LISTINGS AND CREF AT TOP LEVEL
;IF LSTIN. IS DEFINED AS .MINFI THEN ALL LISTINGS ARE ON

DEFINE	LSTOF.(FOO),<
	IFNDEF LSTIN.,LSTIN.==0		;;INITIALIZE LEVEL COUNTER
IFE LSTIN.,<
	IFIDN <XCREF><FOO>,<.XCREF>	;;CONDITIONALLY SUPPRESS CREF
		   XLIST>		;;TURN OFF LISTINGS
	LSTIN.==LSTIN.+1>		;;BUMP LIST LEVEL

DEFINE	LSTON.,<
	IFG LSTIN.,LSTIN.==LSTIN.-1	;;DECR LIST LEVEL
	IFLE LSTIN.,<.CREF		;;RESUME CREFS
		      LIST>>		;;RESUME LISTS

;Macro to Generate Standard Version Word
;Assumes PFXWHO, PFXVER, PFXMIN, PFXEDT are defined.
;	VRSN. (PFX)

DEFINE VRSN.(PFX),<BYTE (3)PFX'WHO (9)PFX'VER (6)PFX'MIN (18)PFX'EDT>
SUBTTL PROLOG - Uniform assembly set up

;The PROLOG macro is used to uniformly search all the right UNV files
;	and setup the listing format and STOP CODE controls.

; The call is :		PROLOG(xxxxxx)
;	where the 'xxxxxx' represents the module name.

	%%.MOD==SIXBIT/NONAME/		;DEFAULT MODULE NAME BEFORE
					; PROGRAM DOES PROLOG

	DEFINE 	PROLOG(MODULE)<
	  SALL
	  LSTOF. XCREF
	  TOPS20 <SEARCH MONSYM>	;;LOAD O.S. SYMBOLS
	  TOPS10 <SEARCH UUOSYM,MACTEN	;;FOR PROPER OPERATING SYSTEM
		IFIW==:1B0>
					;;FOR NON-LIBRARY COMPONENTS
	  DEFINE $DATA(NAM,SIZ<1>)<
	    NAM:	BLOCK	SIZ
	  >
	  DEFINE ..ASGN(A,ADDR) <GLOB(A)>
	  IFNB <MODULE>,<%%.MOD==SIXBIT/MODULE/> ;;MAKE NAME AVAILABLE
	  OPDEF $RETT [PJRST .RETT]	;;Pick up proper .RETT/.RETF
	  OPDEF $RETF [PJRST .RETF]
	  LSTON.				;;TURN LISTINGS BACK ON
	> ;END OF PROLOG DEFINITION

U$PURE==400000

; $IMPURE - CONTINUE GENERATION OF IMPURE PSECT
; 
DEFINE $IMPURE<			;;DO THIS WAY BECAUSE OF MACRO-53 RESTRICTIONS
  P$IMPURE==1				;;TELL $PURE
  TWOSEG U$PURE				;;MAKE PLENTY OF ROOM
  RELOC 0				;;START THE IMPURE "SEGMENT"
>

; $PURE - CONTINUE GENERATION OF PURE PSECT
;
DEFINE $PURE<				;;DO THIS WAY FOR NOW
  IFNDEF P$IMPUR,<TWOSEG U$PURE>	;;INDIC A PURE SEGMENT
  RELOC U$PURE				;;AND START IT UP
>

SUBTTL	SYSPRM - Set system dependent parameters

;THE SYSPRM MACRO IS USED TO DEFINE A SYMBOL WHOSE VALUE IS DIFFERENT
;	DEPENDING ON THE OPERATING SYSTEM WHICH THE PROGRAM IS
;	BEING ASSEMBLED FOR.
;
;	THE CALL IS:
;
;	  SYSPRM   'SUBSYSTEM-NAME' , 'TOPS10 VALUE' , 'TOPS20 VALUE'


DEFINE	SYSPRM(SYMBOL,UUOS,JSYS),<
	IFNB <UUOS>,<TOPS10<SYMBOL==UUOS>>
	IFNB <JSYS>,<TOPS20<SYMBOL==JSYS>>
>  ;END DEFINE SYSPRM

SUBTTL	PG2ADR,ADR2PG Macros

DEFINE	PG2ADR(AC),<LSH AC,^D9>

DEFINE	ADR2PG(AC),<LSH AC,-^D9>
SUBTTL	Standard Constants

.INFIN==377777,,777777		;PLUS INFINITY
.MINFI==1B0			;MINUS INFINITY
LHMASK==777777B17		;LEFT HALF
RHMASK==777777			;RIGHT HALF
FWMASK==-1			;FULL WORD


; BYTE POINTER PARTS

	BP.POS==77B5			;POSITION (BITS TO THE RIGHT)
	BP.SIZ==77B11			;SIZE OF BYTE
	BP.ADR==Z -1			;ADDRESS PORTION


; DEFINE UNIVERSAL TRUE AND FALSE CONSTANTS

	FALSE==0
	TRUE=-1

; MEMORY CONSTANTS

	PAGSIZ==^D512			;SIZE OF ONE PAGE
	MEMSIZ==^D512			;PAGES IN THE ADDRESS SPACE

; DEBUGGING CONSTANTS

	SYSPRM	DDTADR,.JBDDT,770000	;LOCATION CONTAINING START OF DDT
	SYSPRM	DEBUGW,.JBOPS,135	;SPECIAL "DEBUGGING" WORD
SUBTTL	Control Character Symbols

.CHNUL==000			;NULL
.CHCNA==001
.CHCNB==002
.CHCNC==003
.CHCND==004
.CHCNE==005
.CHCNF==006
.CHBEL==007			;BELL
.CHBSP==010			;BACKSPACE
.CHTAB==011			;TAB
.CHLFD==012			;LINE-FEED
.CHVTB==013			;VERTICAL TAB
.CHFFD==014			;FORM FEED
.CHCRT==015			;CARRIAGE RETURN
.CHCNN==016
.CHCNO==017
.CHCNP==020
.CHCNQ==021
.CHCNR==022
.CHCNS==023
.CHCNT==024
.CHCNU==025
.CHCNV==026
.CHCNW==027
.CHCNX==030
.CHCNY==031
.CHCNZ==032
.CHESC==033			;ESCAPE
.CHCBS==034			;CONTROL BACK SLASH
.CHCRB==035			;CONTROL RIGHT BRACKET
.CHCCF==036			;CONTROL CIRCONFLEX
.CHCUN==037			;CONTROL UNDERLINE

.CHALT==175			;OLD ALTMODE
.CHAL2==176			;ALTERNATE OLD ALTMODE
.CHDEL==177			;DELETE
SUBTTL	Field and Mask Macros

;STANDARD MACROS

;MACROS TO HANDLE FIELD MASKS

;COMPUTE LENGTH OF MASK, I.E. LENGTH OF LEFTMOST STRING OF ONES
;REMEMBER THAT ^L DOES 'JFFO', I.E. HAS VALUE OF FIRST ONE BIT IN WORD

;COMPUTE WIDTH OF MASK, I.E. LENGTH OF LEFTMOST STRING OF ONES

DEFINE WID(MASK)<<^L<-<<MASK>_<^L<MASK>>>-1>>>

;COMPUTE POSITION OF MASK, I.E. BIT POSITION OF RIGHTMOST ONE IN MASK

DEFINE POS(MASK)<<^L<<MASK>&<-<MASK>>>>>

;CONSTRUCT BYTE POINTER TO MASK

DEFINE POINTR(LOC,MASK)<<POINT WID(MASK),LOC,POS(MASK)>>

;PUT RIGHT-JUSTIFIED VALUE INTO FIELD SPECIFIED BY MASK

DEFINE	FLD(VALUE,MASK),<<<<VALUE>B<POS(<MASK>)>>&<MASK>>>

;MAKE VALUE BE RIGHT JUSTIFIED IN WORD.

DEFINE .RTJST(VAL,MSK)<<VAL>B<^D70-POS(MSK)>>

;CONSTRUCT MASK FROM BIT AA TO BIT BB. I.E. MASKB 0,8 = 777B8

DEFINE MASKB (AA,BB)<1B<<AA>-1>-1B<BB>>

;MODULE - GIVES REMAINDER OF DEND DIVIDED BY DSOR

DEFINE MOD. (DEND,DSOR)<<DEND-<DEND/DSOR>*DSOR>>

;OLD STYLE MACTEN TYPE CALLS

;MACRO TO BUILD A MASK "WID" BITS WIDE, WITH ITS RIGHTMOST BIT
;	IN THE BIT POSITION "POS".
DEFINE MASK.(WID,POS),<<<<1_<WID>>-1>B<POS>>>


;INVSL. POSITIONS VALUE IN MASK TO BE REPLACED BY FLD(VALUE,MASK)
DEFINE	INSVL.(VALUE,MASK),<<<<VALUE>B<POS(<MASK>)>>&<MASK>>>

SUBTTL MOVX

;MOVX - LOAD AC WITH CONSTANT

DEFINE MOVX (AC,MSK)<
   ..MX1==MSK			;;EVAL EXPRESSION IF ANY
IFDEF .PSECT,<
   .IFN ..MX1,ABSOLUTE,<
	MOVE AC,[MSK]>
   .IF ..MX1,ABSOLUTE,<
	..MX2==0		;;FLAG SAYS HAVEN'T DONE IT YET
	IFE <..MX1>B53,<
	  ..MX2==1
	  MOVEI AC,..MX1>	;;LH 0, DO AS RH
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <..MX1>B17,<
	  ..MX2==1
	  MOVSI AC,(..MX1)>>	;;RH 0, DO AS LH
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <<..MX1>B53-^O777777>,<
	  ..MX2==1
	  HRROI AC,<..MX1>>>	;;LH -1
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <<..MX1>B17-^O777777B17>,<
	  ..MX2==1
	  HRLOI AC,(..MX1-^O777777)>> ;;RH -1
	IFE ..MX2,<		;;IF STILL HAVEN'T DONE IT,
	  MOVE AC,[..MX1]>	;;GIVE UP AND USE LITERAL
	>>

IFNDEF .PSECT,<
	..MX2==0		;;FLAG SAYS HAVEN'T DONE IT YET
	IFE <..MX1>B53,<
	  ..MX2==1
	  MOVEI AC,..MX1>	;;LH 0, DO AS RH
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <..MX1>B17,<
	  ..MX2==1
	  MOVSI AC,(..MX1)>>	;;RH 0, DO AS LH
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <<..MX1>B53-^O777777>,<
	  ..MX2==1
	  HRROI AC,<..MX1>>>	;;LH -1
	IFE ..MX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <<..MX1>B17-^O777777B17>,<
	  ..MX2==1
	  HRLOI AC,(..MX1-^O777777)>> ;;RH -1
	IFE ..MX2,<		;;IF STILL HAVEN'T DONE IT,
	  MOVE AC,[..MX1]>	;;GIVE UP AND USE LITERAL
>
	PURGE ..MX1,..MX2>
SUBTTL CAX - COMPARE MACROS

;CREATE THE CAX MACRO DEFINITIONS

DEFINE	..DOCX (T)<
	IRP T,<
	  DEFINE CAX'T (AC,MSK)<
	    ..CX(T,AC,MSK)>>>

	..DOCX (<,L,LE,E,G,GE,N,A>)  ;DO 8 DEFINITIONS
	PURGE ..DOCX

DEFINE	..CX(T,AC,MSK)<
	  ..CX1==MSK
	IFDEF .PSECT,<
 	.IFN ..CX1,ABSOLUTE,<
	      CAM'T AC,[MSK]>
	.IF ..CX1,ABSOLUTE,<	;;MASK IS TESTABLE
		..CX2==0	;;MARK NOT DONE
	  IFE <..CX1&^O777777B17>,<
		..CX2==1	;;LH 0 CAN DO CAI
	    CAI'T AC,MSK>
	  IFE ..CX2,<		;;MUST USE CAM
	    CAM'T AC,[MSK]>
	PURGE ..CX1,..CX2>>
	IFNDEF .PSECT,<
		..CX2==0	;;MARK NOT DONE
	  IFE <..CX1&^O777777B17>,<
		..CX2==1	;;LH 0 CAN USE CAI
	    CAI'T AC,MSK>
	  IFE ..CX2,<		;;MUST USE CAM
	    CAM'T AC,[MSK]>
	PURGE ..CX1,..CX2>>
SUBTTL TX -- TEST MASK

;CREATE THE TX MACRO DEFINITIONS

;THIS DOUBLE IRP CAUSES ALL COMBINATIONS OF MODIFICATION AND TESTING
;TO BE DEFINED

DEFINE ..DOTX (M,T)<
	IRP M,<
	IRP T,<
	  DEFINE TX'M'T (AC,MSK)<
		..TX(M'T,AC,<MSK>)>>>>

	..DOTX (<N,O,Z,C>,<,E,N,A>) ;DO ALL DEFINITIONS
	PURGE ..DOTX

;..TX
;ALL TX MACROS JUST CALL ..TX WHICH DOES ALL THE WORK

DEFINE ..TX(MT,AC,MSK)<
   ..TX1==MSK			;;EVAL EXPRESSION IF ANY
IFDEF .PSECT,<
   .IFN ..TX1,ABSOLUTE,<
	TD'MT AC,[MSK]>
   .IF ..TX1,ABSOLUTE,<		;;MASK MUST BE TESTABLE
	..TX2==0		;;FLAG SAYS HAVEN'T DONE IT YET
	IFE <..TX1&^O777777B17>,<
	  ..TX2==1		;;LH 0, DO AS RH
	  TR'MT AC,..TX1>
	IFE ..TX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <..TX1&^O777777>,<
	  ..TX2==1		;;RH 0, DO AS LH
	  TL'MT AC,(..TX1)>>
	IFE ..TX2,<		;;IF HAVEN'T DONE IT YET,
	  IFE <<..TX1>B53-^O777777>,< ;;IF LH ALL ONES, 
	    ..TX3 (MT,AC)>>	;;TRY Z,O,C SPECIAL CASES
	IFE ..TX2,<		;;IF STILL HAVEN'T DONE IT,
	  TD'MT AC,[..TX1]>	;;MUST GIVE UP AND USE LITERAL
	PURGE ..TX1,..TX2>>
IFNDEF .PSECT,<
	..TX2==0		;;FLAG SAYS HAVEN'T DONE IT YET
	IFE <..TX1&^O777777B17>,<
	  ..TX2==1		;;LH 0, DO AS RH
	  TR'MT AC,..TX1>
	IFE ..TX2,<		;;IF HAVEN'T DONE IT YET,
	IFE <..TX1&^O777777>,<
	  ..TX2==1		;;RH 0, DO AS LH
	  TL'MT AC,(..TX1)>>
	IFE ..TX2,<		;;IF HAVEN'T DONE IT YET,
	  IFE <<..TX1>B53-^O777777>,< ;;IF LH ALL ONES, 
	    ..TX3 (MT,AC)>>	;;TRY Z,O,C SPECIAL CASES
	IFE ..TX2,<		;;IF STILL HAVEN'T DONE IT,
	  TD'MT AC,[..TX1]>	;;MUST GIVE UP AND USE LITERAL
	PURGE ..TX1,..TX2>>
;SPECIAL CASE FOR LH ALL ONES

DEFINE ..TX3 (MT,AC)<
	IFIDN <MT><Z>,<		;;IF ZEROING WANTED
	  ..TX2==1
	  ANDI AC,^-..TX1>	;;CAN DO IT WITH ANDI
	IFIDN <MT><O>,<		;;IF SET TO ONES WANTED
	  ..TX2==1
	  ORCMI AC,^-..TX1>	;;CAN DO IT WITH IORCM
	IFIDN <MT><C>,<		;;IF COMPLEMENT WANTED
	  ..TX2==1
	  EQVI AC,^-..TX1>>	;;CAN DO IT WITH EQV
;VARIENT MNEMONICS FOR TX DEFINITIONS

DEFINE IORX (AC,MSK)<
	TXO AC,<MSK>>

DEFINE ANDX (AC,MSK)<
	TXZ AC,<^-<MSK>>>

DEFINE XORX (AC,MSK)<
	TXC AC,<MSK>>
SUBTTL SUBFUNCTION MACROS

;.IF0 CONDITION, ACTION IF CONDITION 0, ACTION OTHERWISE

DEFINE .IF0 (COND,THEN,ELSE)<
	..IFT==COND		;;GET LOCAL VALUE FOR CONDITION
	IFE ..IFT,<
	THEN
	..IFT==0>		;;RESTORE IN CASE CHANGED BY NESTED .IF0
	IFN ..IFT,<
	ELSE>>

;CASE (NUMBER,<FIRST,SECOND,...,NTH>)

DEFINE .CASE (NUM,LIST)<
	..CSN==NUM
	..CSC==0
	IRP LIST,<
	IFE ..CSN-..CSC,<
	  STOPI
	  ..CAS1 (LIST)>
	..CSC==..CSC+1>>

DEFINE ..CAS1 (LIST)<
	LIST>

;TEST FOR FULL WORD, RH, LH, OR ARBITRARY BYTE

DEFINE ..TSIZ (SYM,MSK)<
	SYM==3			;;ASSUME BYTE UNLESS...
	IFE <MSK>+1,<SYM=0>	;;FULL WORD IF MASK IS -1
	IFE <MSK>-^O777777,<SYM==1> ;;RH IF MASK IS 777777
	IFE <MSK>-^O777777B17,<SYM==2>> ;;LH IF MAST IS 777777,,0

;TEST FOR LOC BEING AN AC -- SET SYM TO 1 IF AC, 0 IF NOT AC

DEFINE ..TSAC (SYM,LOC)<
	IFNDEF .PSECT,<
	SYM==0			;;ASSUME NOT AC UNLESS...
	..TSA1==<Z LOC>		;;LOOK AT LOC
	  IFE ..TSA1&^O777777777760,<SYM==1> ;;AC IF VALUE IS 0-17
	>
	IFDEF .PSECT,<
	SYM==0			;;ASSUME NOT AC UNLESS...
	..TSA1==<Z LOC>		;;LOOK AT LOC
	.IF ..TSA1,ABSOLUTE,<	;;SEE IF WE CAN TEST VALUE
	  IFE ..TSA1&^O777777777760,<SYM==1>> ;;AC IF VALUE IS 0-17
	PURGE ..TSA1>>

;FUNCTION TO TEST FOR MASK CONTAINING EXACTLY ONE BIT. RETURNS
;1 IFF LEFTMOST BIT AND RIGHTMOST BIT ARE SAME

DEFINE ..ONEB (SYM,MSK)<
	SYM==<<<-<MSK>>&<MSK>>&<1B<^L<MSK>>>>>

SUBTTL STKVAR - STACK VARIABLE FACILITY

;MACRO FOR ALLOCATING VARIABLES ON THE STACK. ITS ARGUMENT IS
;A LIST OF ITEMS.  EACH ITEM MAY BE:
; 1. A SINGLE VARIABLE WHICH WILL BE ALLOCATED ONE WORD
; 2. A VARIABLE AND SIZE PARAMETER WRITTEN AS <VAR,SIZ>.  THE
;	VARIABLE WILL BE ALLOCATED THE SPECIFIED NUMBER OF WORDS.
;RETURN FROM A SUBROUTINE USING THIS FACILITY MUST BE VIA
;RET OR RETSKP.  A DUMMY RETURN WHICH FIXES UP THE STACK IS PUT ON
;THE STACK AT THE POINT THE STKVAR IS ENCOUNTERED.
;WITHIN THE RANGE OF A STKVAR, PUSH/POP CANNOT BE USED AS THEY WILL
;CAUSE THE VARIABLES (WHICH ARE DEFINED AS RELATIVE STACK LOCATIONS)
;TO REFERENCE THE WRONG PLACE.
;TYPICAL USE:   STKVAR <AA,BB,<QQ,5>,ZZ>

EXTERN .STKST

DEFINE STKVAR (ARGS)<
	..STKR==10		;;REMEMBER RADIX
	RADIX 8
	..STKN==0
	IRP ARGS,<
	  .STKV1 (ARGS)>
	JSP .SAC,.STKST
	 ..STKN,,..STKN
	RADIX ..STKR
	PURGE ..STKN,..STKR,..STKQ
   >

;INTERMEDIATE MACRO TO PEAL OFF ANGLEBRACKETS IF ANY

DEFINE .STKV1 (ARG)<
	.STKV2 (ARG)>

;INTERMEDIATE MACRO TO CALCULATE OFFSET AND COUNT VARIABLES

DEFINE .STKV2 (VAR,SIZ)<
	IFB <SIZ>,<..STKN==..STKN+1>
	IFNB <SIZ>,<..STKN==..STKN+SIZ>
	..STKQ==..STKN+1
	.STKV3 (VAR,\..STKQ)>

;INNERMOST MACRO TO DEFINE VARIABLE

DEFINE .STKV3 (VAR,LOC)<
   IFDEF VAR,<.IF VAR,SYMBOL,<PRINTX STKVAR VAR ALREADY DEFINED>>
	DEFINE VAR<-^O'LOC(P)>
	$'VAR==<Z VAR>>		;SYMBOL FOR DDT
SUBTTL	SAVE MACRO DEFINITION

;VARIABLE SAVE FACILITY -- ACCEPTS A LIST OF ARGUMENTS
;	$SAVE <LIST-OF-VARIABLES>
;AUTOMATICALLY RESTORES ALL NAMED VARIABLES ON RETURN FROM ROUTINE
;  SUPPORTS +1 OR +2 RETURNS

;IF AN APPROPRIATE CO-ROUTINE IS DEFINED IN CPACOM FOR THE DESIRED
;AC'S IT IS USED, OTHERWISE OPEN PUSHES AND A DUMMY RESTORE ROUTINE
;ARE GENERATED.

;IF THE SAME SET OF VARIABLES IS SAVED MORE THAN ONCE IN A PROGRAM,
;THE RESTORE ROUTINE GENERATED IN THE LITERALS IS SHARED BETWEEN THE
;TWO SAVES.

EXTERN .SAVE1,.SAVE2,.SAVE3,.SAVE4,.SAVET,.SV13,.SV14,.SV15,.SV16, .ZCHNK


DEFINE SAVE (ARG) <PRINTX % Replacing SAVE with $SAVE
		   $SAVE <ARG>>

DEFINE $SAVE(ARG,%L1)<
	.NVR==0			;;INITILIZE VARIABLE COUNT
	.ACM==0			;;INITIALIZE AC MASK

	IRP ARG,<		;;BUILD AC MASK AND PUSH OTHER VARIABLES
		..TSAC(.ACB,ARG)		;;IS IT AN AC?
		IFN .ACB,<.ACM==.ACM!1B<ARG>>	;;YES -- BUILD MASK
		IFE .ACB,<			;;NO -- PUSH IT
		IFE .NVR,<			;;FIRST VARIABLE?
		    CAIA			;;YES -- DO SKIP CODE
		    LSTOF.
		    JRST %L1>
		  ..PUSH(ARG,\<.NVR+1>)>>	;;PUSH IT AND BUMP COUNT

	IFN .ACM,<	;;CHECK FOR PROPER AC CO-ROUTINE
	    IFE <.ACM-17B<T4>>,<.ACM==0
				$CALL .SAVET>
	    IFE <.ACM-377B<.A16>>,<.ACM==0
				$CALL .SAVE8>
	    IFE <.ACM-17B<P4>>,<.ACM==0
				$CALL .SAVE4>
	    IFE <.ACM-7B<P3>>,<.ACM==0
				$CALL .SAVE3>
	    IFE .NVR,<	;;DON'T DO CO-ROUTINE IF OTHER VARIABLES
	    IFE <.ACM-3B<P2>>,<.ACM==0
				$CALL .SAVE2>
	    IFE <.ACM-1B<P1>>,<.ACM==0
				$CALL .SAVE1>
	    IFE <.ACM-1B<.A13>>,<.ACM==0
				$CALL .SV13>
	    IFE <.ACM-1B<.A14>>,<.ACM==0
				$CALL .SV14>
	    IFE <.ACM-1B<.A15>>,<.ACM==0
				$CALL .SV15>
	    IFE <.ACM-1B<.A16>>,<.ACM==0
				$CALL .SV16>
	    >>

;;SAVE IS CONITINUED ON NEXT PAGE
;;SAVE MACRO CONTINUED FROM PREVIOUS PAGE

	IFN .ACM,<	;;PUSH THE AC'S IF NOT DONE BY CO-ROUTINE
	    IFE .NVR,<			;;FIRST ONE?
		CAIA			;;YES -- DO SKIP CODE
		LSTOF.
		JRST %L1>

	    .ACB==0			;;START AT AC0
	REPEAT ^D16,<			;;LOOP THRU ALL 16
	    IFN <.ACM&1B<.ACB>>,<	;;WAS IT GIVEN?
		..PUSH(\.ACB,\<.NVR+1>)>;;YES -- PUSH IT
		.ACB==.ACB+1>>		;;STEP TO NEXT

	IFN .NVR,<	;;BUILD DUMMY ROUTINE TO RESTORE ALL PUSHES
	    PUSH P,[[CAIA		;;HERE FOR NON SKIP RETURN
		     AOS -.NVR(P)	;;HANDLE SKIP RETURN
	    REPEAT .NVR,<..POP(\.NVR)>	;;POP ALL THINGS STACKED
		     POPJ P,0]]>	;;RETURN TO CALLER
	LSTON.
%L1:	SUPPRESS %L1>

	DEFINE ..PUSH(ARG,.NVX)<
		PUSH P,ARG
		.NV'.NVX==ARG
		.NVR==.NVR+1>

	DEFINE ..POP(.NVX)<
		POP P,.NV'.NVX
		PURGE .NV'.NVX
		.NVR==.NVR-1>
SUBTTL	LOAD,STORE,INCR,DECR,ZERO

DEFINE LOAD (AC,Y,STR)<
	IFNB <STR>,<..STR0 (..LDB,AC,STR,Y)>
	IFB  <STR>,<MOVE AC,Y>>		;;DEFAULT TO FULL WORD MOVE

    DEFINE ..STR0 (OP,AC,STR,Y)<
	IFNDEF STR,<PRINTX STR IS NOT DEFINED
	  OP (<AC>,Y,FWMASK)>	;;RESERVE A WORD, ASSUME WORD MASK
	IFDEF STR,<
	IFNDEF %'STR,<
	  OP (<AC>,Y,STR)>	;;ASSUME NO OTHER LOCN
	IFDEF %'STR,<
	  %'STR (OP,<AC>,Y,STR)>>> ;;DO IT

   DEFINE ..LDB (AC,LOC,MSK)<
	..TSIZ (..PST,MSK)
	.CASE ..PST,<<
		MOVE AC,LOC>,<
		HRRZ AC,LOC>,<
		HLRZ AC,LOC>,<
		LDB AC,[POINTR (LOC,MSK)]>>>

DEFINE STORE (AC,Y,STR)<
	IFNB <STR>,<..STR0 (..DPB,AC,STR,Y)>
	IFB  <STR>,<MOVEM AC,Y>>	;;DEFAULT FULL WORD MOVE

   DEFINE ..DPB (AC,LOC,MSK)<
	..TSIZ (..PST,MSK)
	.CASE ..PST,<<
		MOVEM AC,LOC>,<
		HRRM AC,LOC>,<
		HRLM AC,LOC>,<
		DPB AC,[POINTR (LOC,MSK)]>>>

DEFINE INCR (Y,STR)<
	IFNB <STR>,<..STR0 (.INCR0,,<STR>,Y)>
	IFB  <STR>,<AOS Y>>		;;DEFAULT FULL WORD INCR

   DEFINE .INCR0 (AC,LOC,MSK)<
	..PST==MSK-FWMASK
	.IF0 ..PST,<
		AOS LOC>,<	;;FULL WORD, CAN USE AOS
		$CALL .AOS	;;MUST USE SUPPORT CODE
		LSTOF.
		JUMP [POINTR(LOC,MSK)]
		LSTON.>>

DEFINE DECR (Y,STR)<
	IFNB <STR>,<..STR0 (.DECR0,,<STR>,Y)>
	IFB  <STR>,<SOS Y>>		;;DEFAULT FULL WORD DECR

   DEFINE .DECR0 (AC,LOC,MSK)<
	..PST==MSK-FWMASK
	.IF0 ..PST,<
		SOS LOC>,<	;;FULL WORD, CAN USE SOS
		$CALL .SOS	;;MUST USE SUPPORT CODE
		LSTOF.
		JUMP [POINTR(LOC,MSK)]
		LSTON.>>
SUBTTL $BUILD,$SET,$EOB - Build pre-formed data blocks

;Many components have a need to build simple and complex blocks which
;	contain pre-formatted data, such as FOBs,IBs and other blocks
;	which are made up of several words, each containing from 1 to several
;	fields.  Since data structures change, these blocks should not be
;	just created using EXP or whatever.  These macros will take values
;	and install them in the right field and word of a structure.

; Start off a structure, argument is the size of the structure.

	DEFINE $BUILD(SIZE)<
	  IFDEF ..BSIZ,<PRINTX ?Missing $EOB after a $BUILD>
	  ..BSIZ==0			;;START COUNTER
	  ..BLOC==.			;;REMEMBER OUR STARTING ADDRESS
	  REPEAT SIZE,<			;;FOR EACH WORD IN THE BLOCK
		BLD0.(\..BSIZ,0)	;;ZERO OUT IT'S ACCUMULATOR
		..BSIZ==..BSIZ+1>	;;AND STEP TO NEXT
	>;END OF $BUILD DEFINITION

; For each value installed somewhere in the structure, set it into the block
; 	Arguments are word offset,field in word (optional) and value to set.

	DEFINE $SET(OFFSET,STR,VALUE),<
	  IFNDEF ..BSIZ,<PRINTX ?$SET without previous $BUILD>
	  IFNB <STR>,<..STR0 (..SET,<VALUE>,STR,OFFSET)>
	  IFB  <STR>,<..STR0 (..SET,<VALUE>,FWMASK,OFFSET)>
	> ; END OF $SET DEFINITION

	DEFINE ..SET (VALUE,LOC,MSK) <
	  IFGE <<<LOC>&777777>-..BSIZ>,<
		PRINTX ?WORD offset greater than $BUILD size parameter>
	  SET0. (\<LOC>,MSK,<VALUE>)
	> ;END ..SET DEFINITION

; After all values are declared, the block must be closed to do its actual
;	creation.

	DEFINE $EOB,<
	  IFNDEF ..BSIZ,<PRINTX ?$EOB without previous $BUILD>
	  IFN <.-..BLOC>,<PRINTX ?Address change between $BUILD and $EOB>
	  LSTOF.			;;DON'T SHOW THE BLOCK
	  ..T==0
	  REPEAT ..BSIZ,<
	    BLD0.(\..T,1)		;;STORE EACH WORD
	    ..T==..T+1 >
	  PURGE ..BSIZ,..T,..BLOC	;;REMOVE SYMBOLS
	  LSTON.
	>; END OF $EOB DEFINITION

	DEFINE BLD0.(N,WHAT),<
	  IFE WHAT,<..T'N==0>
	  IFN WHAT,<EXP ..T'N
		    PURGE ..T'N>
	> ;END OF BLD0. DEFINITION

	DEFINE SET0.(LOC,MSK,VALUE),<
	IFN <<..T'LOC>&MSK>,<PRINTX ?Initial field not zero in $SET>
	  ..TVAL==<VALUE>
	  ..TMSK==<MSK>
	  ..T'LOC==..T'LOC!<FLD(..TVAL,..TMSK)>
	  PURGE ..TVAL,..TMSK
	>;END OF SET0. DEFINITION
SUBTTL	$CALL,$RETT,$RETF,$RETE,$RET Uniform Call/Return Mechanisms

;	All routines which follow CMDPAR Conventions should call
;  library routines and internal routines which return TRUE/FALSE
;  values with the $CALL Macro.  This provides a uniform calling
;  mechanism.

; 	All routines which follow CMDPAR conventions should return
;  via one of the return instructions. These instructions set the contents
;  of the true/false register, TF and then return via POPJ P,.

;	If a routine wishes to merely pass on the value of the TF register
;  it should return using a $RET

	EXTERN .RETT,.RETF,.RETE,.RET,.POPJ

	DEFINE $CALL(NAME$)<
		IF2,<IFNDEF NAME$,<EXTERN NAME$>>
		PUSHJ P,NAME$
	>

; $RETE is the instruction used to return FALSE from a routine and also
; set a specific error code in the first status register, S1.  The argument
; provided to the instruction is a 3 letter CMDPAR canonical error code.
; The effect of the $RETE instruction is to place the value of the
; CMDPAR error code into S1, place FALSE into TF and return via POPJ.

	DEFINE $RETE (COD) <
	  JSP	TF,.RETE		;;GO TO SUPPORT COD
		LSTOF.
	  JUMP	ER'COD'$
		LSTON.>			;;END OF $RETE DEFINITION


;$RETT is the instruction used to place a value of TRUE into the TF register
;  and return from the routine.  This instruction is used when a routine 
;  wishes to indicate to its caller that it is returning successfully.

;	$RETT is defined during the PROLOG macro


;		OPDEF	$RETT PJRST .RETT]


;$RETF is the instruction used to place a value of FALSE into the TF register
;  and return from the routine.  This instruction is used when a routine
;  wishes to indicate to its caller that is returning unsuccessfully.

;	$RETF is defined during the PROLOG macro

;		OPDEF	$RETF [PJRST .RETF]


;$RET is the instruction used to return the last value of TF to the caller

	OPDEF	$RET	[POPJ P,]	;;RETURN CURRENT VALUE OF TF
SUBTTL $DATA and $GDATA Macros - Runtime System Data Area control

;This macro is used to define impure storage areas.  The actual
;areas are created at run-time by the memory manager.  The first argument
; is the name of the word(s) to be allocated. This name may be referenced
; as any other labelled location.  The second argument is the number of
; words to allocate.  If omitted, this defaults to 1.

;In order to facilitate debugging of new library routines, the $DATA and
;	$GDATA macros produce BLOCK pseudo-op type locations when used
;	in a module whose PROLOG indicates it is not part of the library.
; 	This means that a new library module may be loaded with a test program
;	as a non-library piece of code while it is being debugged.

	DEFINE $DATA(NAM,SIZ<1>)<
		.PSECT	DATA
	NAM:	BLOCK	SIZ
		.ENDPS
	> ;END OF $DATA DEFINITION


; $GDATA is exactly like $DATA, except that the location defined
;	is GLOBAL, that is, available to other programs.

	DEFINE $GDATA(NAM,SIZ<1>)<
	  INTERN NAM
	  $DATA(NAM,<SIZ>)
	> ;END OF $GDATA DEFINITION
SUBTTL	TYPE OUT MACROS

;$TEXT PUTS OUT AN ARBITRARY ASCIZ STRING
;
	EXTERN K%SOUT

	DEFINE $TEXT(STRING)<
	  PUSHJ P,[			;;CALL PRINT OUT ROUTINE
		MOVEI S1,[ASCIZ\STRING\]	;;WITH THIS ARG
		PJRST K%SOUT]		;;DO IT
	>

;$FATAL is provided as a short form STOP code.  It should
;be used when it is impossible to proceed because
;the program doesn't have proper priviledges or can't find a required
;file -- or any other occassion where the full stopcode information
;is irrelevant or misleading


;CALL	$FATAL <any valid $TEXT string argument>
;

DEFINE $FATAL (STRING) <
	$TEXT <?'STRING>
> ;END OF $FATAL DEFINITION

;$WARN May be used when it is desired to issue a warning on the
;users terminal.

;CALL	$WARN <any valid $TEXT string argument>
;
DEFINE	$WARN (STRING) <
	$TEXT <%'STRING>	;;TEXT TO PUT OUT
>
SUBTTL	STOPPING A PROGRAM

;$STOP(CODE,STRING)

;WHERE	CODE = A UNIQUE 3 CHARACTER INDICATION OF THE STOP CODE
;  AND
;STRING IS AN EXPANDED STRING ASSOCIATED WITH THE ERROR CONDITION
; I.E.:	$STOP(NFP,No free pages)

DEFINE	$STOP(CODE,STRING),<
	JRST	[$TEXT(?'CODE' 'STRING)	;;PUT OUT MSG
		$CALL .STOP]		;;EXIT TO MONITOR
>

SYSPRM	$HALT,<EXIT 1,>,<HALTF>	;EXIT WITHOUT RESET


SUBTTL  System error codes

DEFINE ERRORS,<
	ERR	EOF,<End Of File>
	ERR	IFP,<Illegal file position>
	ERR	FDE,<File Data Error>
	ERR	FND,<File is not on disk>
	ERR	NSD,<No such device>
	ERR	SLE,<A System Limit Was Exceeded>
	ERR	IFS,<Illegal File Specification>
	ERR	FNF,<File Not Found>
	ERR	PRT,<Protection Violation>
	ERR	DNA,<Device Was Not Available>
	ERR	FDS,<Files are on different structures>
	ERR	FAE,<File already exists>
	ERR	USE,<Unexpected System Error>
	ERR	TBF,<The Command Table is full>
	ERR	EIT,<Entry already exists in the table>
	ERR	ITE,<Invalid Table Entry>
	ERR	QEF,<Quota Exceeded or Disk Full>
	ERR	ARG,<Invalid Argument>
>  ;END DEFINE ERRORS

;GENERATE THE ERROR SYMBOLS

	ER%%%==1			;DON'T USE ERROR CODE 0
DEFINE ERR(A,B),<
	ER'A'$==ER%%%
	ER%%%==ER%%%+1
>  ;END DEFINE ERR

	ERRORS
SUBTTL Canonical File Information

;In order to bring the number of feature test switches needed to the
;absolute minimum, the GLXFIL (file handler) module makes information
;about open files available through the F%INFO routine call.  The
;particular piece of information desired is designated by providing
;a canonical descriptor for that piece of information.

;These FI.xxx symbols, defined here, are the F%INFO descriptors

DEFINE CFI<
	
	  LSTOF.

	X CRE	;;UDT FORMAT CREATION DATE/TIME OF FILE
	X GEN	;;VERSION/GENERATION NUMBER OF FILE
	X PRT	;;PROTECTION OF THE FILE
	X CLS	;;CLASS OF FILE (TOPS-20) ONLY
	X AUT	;;AUTHOR OF THE FILE
	X USW	;;USER SETTABLE WORD
	X SPL	;;SPOOL WORD (TOPS-10) 
	X SIZ   ;;SIZE OF FILE, IN BYTES
	X MOD	;;DATA MODE
	X CHN	;;FILE CHANNEL # (CHN OR JFN)

	  LSTON.

> ;END OF CFI DEFINITION

;CREATE THE SYMBOLS

	FI.%%%==0

	DEFINE X(A)<
	FI.'A==FI.%%%
	FI.%%%==FI.%%%+1
	>

	CFI
	SUBTTL	FD - File Descriptor and Miscellaneous File Parameters

; PARAMETERS USED BY:	GLXFIL

	SYSPRM	SZ.IFN,^D30,^D30	;NUMBER OF FILES OPEN SIMULTANEOUSLY
	SYSPRM	SZ.BUF,406,400		;SIZE OF BUFFER AREA
	SYSPRM	SZ.OBF,200,400		;MAXIMUM WORDS XFERRED ON F%?BUF CALL
	SYSPRM	.PRIIN,377776,.PRIIN	;PRIMARY INPUT JFN
	SYSPRM	.PRIOU,377777,.PRIOU	;PRIMARY OUTPUT JFN
	SYSPRM	.NULIO,377775,.NULIO	;NULL I/O JFN

; The FD (File Descriptor) is the data structure used to pass a system
;	dependent file description to subroutines or as part of a larger
;	message or data structure.


	PHASE	0

.FDLEN:! BLOCK	1			;LENGTH WORD
	FD.LEN==-1,,0			;MASK TO LENGTH FIELD
.FDFIL:!				;FIRST WORD OF FILESPECIFICATION

	DEPHASE

TOPS10 <	;FILE DESCRIPTOR FOR TOPS10

;	!=======================================================!
;	!		   LENGTH OF THE FD			!
;	!-------------------------------------------------------!
;	!             STRUCTURE CONTAINING THE FILE             !
;	!-------------------------------------------------------!
;	!                       FILE NAME                       !
;	!-------------------------------------------------------!
;	!                       EXTENSION                       !
;	!-------------------------------------------------------!
;	!                        [P,PN]                         !
;	!=======================================================!
;	!                                                       !
;	!                 SFD PATH FOR THE FILE                 !
;	!               THESE WORDS ARE OPTIONAL                !
;	!             AND CAN BE OF LENGTH  0 TO 5              !
;	!                                                       !
;	!=======================================================!

	PHASE	.FDFIL

.FDSTR:! BLOCK	1		;STRUCTURE CONTAINING THE FILE
.FDNAM:! BLOCK	1		;THE FILE NAME
.FDEXT:! BLOCK	1		;THE EXTENSION
.FDPPN:! BLOCK	1		;THE OWNER OF THE FILE
FDMSIZ:!			;MINUMUM SIZE OF A FILE DESCRIPTOR

.FDPAT:! BLOCK	5		;PATH (OPTIONAL AND FROM 0 TO 5 WORDS)
FDXSIZ:!			;MAXIMUM FD AREA SIZE

	DEPHASE

>  ;END OF TOPS10

					;CONTINUED ON FOLLOWING PAGE
TOPS20 <		;FILE DESCRIPTOR FOR TOPS20

;	!=======================================================!
;	/                                                       /
;	/                                                       /
;	/   THE FILE DESCRIPTOR ON TOPS20 IS AN ASCIZ STRING    /
;	/      OF VARIABLE LENGTH AND READY TO BE GTJFN'ED      /
;	/                                                       /
;	/                                                       /
;	!=======================================================!

	PHASE	.FDFIL

.FDSTG:! BLOCK	1		;ASCIZ STRING FOR GTJFN/OPENF SEQUENCE
FDMSIZ:!			;MINIMUM SIZE OF A FILE DESCRIPTOR
FDXSIZ==^D300/^D5		;RESERVE ROOM FOR 300 CHARACTERS

	DEPHASE

>  ;END OF TOPS20
SUBTTL FOB - Parameter block passed to F%IOPN and F%OOPN

; THE FOLLOWING IS A DESCRIPTION OF THE BLOCK USED AS A PARAMETER
; PASSING AREA TO THE TWO FILE OPEN ROUTINES IN GLXFIL.

;	!=======================================================!
;	!      ADDRESS OF FD TO USE FOR FILE SPECIFICATION      !
;	!-------------------------------------------------------!
;	!				      !LSN!NFO!BYTE SIZE!
;	!-------------------------------------------------------!
;	!       FIRST HALF OF USER ID FOR "IN BEHALF OF"        !
;	!-------------------------------------------------------!
;	!          CONNECTED  DIRECTORY (TOPS-20 ONLY)          !
;	!=======================================================!

		PHASE	0

FOB.FD:! BLOCK	1			;POINTER TO FD AREA
FOB.CW:! BLOCK	1			;CONTROL WORD
	   FB.LSN==1B28			;LINE SEQUENCE NUMBERS APPEAR (IGNORE)
	   FB.NFO==1B29			;NEW FILE ONLY (NON-SUPERSEDING)
	   FB.BSZ==77B35		;BYTE SIZE OF THE FILE

FOB.MZ:!				;MINIMUM SIZE OF A FOB

FOB.US:! BLOCK	1			;(OPTIONAL) USER ID FOR "IN BEHALF" OPERATIONS
FOB.CD:! BLOCK	1			;(OPTIONAL) CONNECTED DIRECTORY (TOPS20)

FOB.SZ:!				;SIZE OF AN FOB

		DEPHASE
SUBTTL Scanning and Command Module Symbols

;Define the major macro to expand X(y,z,...) for each terminal type
;Note well:  the items in the TRMTYP macro MUST be in Alphabetical order
;	so that TRMTYP can be used to build parse tables.

DEFINE	TRMTYP,<
LSTOF.
X(33,TTY33,33,)				;;MODEL 33
X(35,TTY35,35,)				;;MODEL 35
TOPS20<
X(37,TTY37,37,)				;;MODEL 37
X(EXECUPORT,EXEC,EXE,)			;;TI EXECUPORT
>
X(LA36,LA36,L36,)			;;LA36
X(VT05,VT05,V05,<37,177,177,177>)	;;VT05
X(VT100,VT100,100,<.CHESC,"[","K">)	;;VT100
X(VT50,VT50,V50,<.CHESC,"J">)		;;VT50
X(VT52,VT52,V52,<.CHESC,"J">)		;;VT52
LSTON.
>;END DEFINE TRMTYP

;The general form of the X macro (which must be redefined just before invoking
;TRMTYP) is:
;X(PARNAM,SIXNAM,SUF,EOLSEQ)
;Where,
;	PARNAM	is the parseable name
;	SIXNAM	is the (TOPS-10) SIXBIT name for TRMOP. .TOTRM
;	SUF	is a 3-char suffix for .TTsuf and .TIsuf
;	EOLSEQ	is a sequence of bytes which will clear to end of line

;Note:
;	.TTsuf is the code to be passed to K%STYP
;		This value need not be the same on the -10 and the -20,
;		but today, they are.
;	.TIsuf is a number between 0 and .TIMAX (inclusive) which may
;		be used to $BUILD and $SETup dispatch tables

;Now, define the .TIsuf symbols which are indicies into tables
;which contain 1 entry for each type of terminal
DEFINE X(PARNAM,SIXNAM,SUF,EOLSEQ),<
.TI'SUF==..Z
..Z==..Z+1>
	..Z==0
	LALL
	TRMTYP			;Do 'em all!
	.TIMAX==..Z-1		;Set the max (must $BUILD (.TIMAX+1) still!)
	PURGE	..Z

TOPS10<
;Define the .TTsuf symbols, since they're not in UUOSYM
DEFINE X(PARNAM,SIXNAM,SUF,EOLSEQ),<
.TT'SUF==..Z
..Z==..Z+1
>;END DEFINE X
	..Z==0			;Start at 0
	TRMTYP			;Do 'em all!
	PURGE	..Z
>;END TOPS10

; The following TOPS-20 symbols are defined when building a TOPS-10 library
;	so that the emulation routines provided for scanning and command
;	parsing can use the same symbols on both systems.

TOPS10 <				;ALREADY DEFINED ON THE -20

; RDTTY flags and argument offsets

	.RDCWB==0			;COUNT OF WORDS FOLLOWING
	.RDFLG==1			;FLAG BITS
	  RD%BRK==1B0			;  BREAK ON ^Z OR ESC
	  RD%TOP==1B1			;  BREAK ON TOPS-10 BREAK SET
	  RD%PUN==1B2			;  BREAK ON PUNCTUATION
	  RD%BEL==1B3			;  BREAK ON EOL
	  RD%CRF==1B4			;  EAT CARRIAGE RETURNS
	  RD%RND==1B5			;  RETURN IF EDITED TO BEGINNING
	  RD%JFN==1B6			;  IFN RATHER THAN STRING PTR
	  RD%RIE==1B7			;  NON-BLOCKING, I.E. RETURN IF EMPTY
	  RD%BBG==1B8			;  PTR TO DEST BUFFER IS IN .RDBFP
	  RD%RAI==1B10			;  CONVERT LOWER TO UPPER CASE
	  RD%SUI==1B11			;  SUPRESS ^U (RUBOUT LINE) HANDLING

	  RD%BTM==1B12			;  INPUT ENDED ON A BREAK
	  RD%BFE==1B13			;  USER DELETED TO BEGINNING
	  RD%BLR==1B14			;  BACKUP LIMIT REACHED

	  RD%NEC==1B35			;  NO ECHO ON ANYTHING (TOPS-10)

	.RDIOJ==2			;INPUT AND OUTPUT IFNS OR STRING POINTER
	.RDDBP==3			;DESTINATION BYTE POINTER
	.RDDBC==4			;NUMBER OF BYTES LEFT AFTER POINTER
	.RDBFP==5			;BEGINNING BYTE POINTER
	.RDRTY==6			;RE-TYPE PROMPT POINTER
	.RDBRK==7			;LOCATION OF 4 WORD BREAK SET TABLE
	.RDBKL==10			;REAL (ARBITRARY) BACKUP LIMIT

;; STILL UNDER TOPS10 CONDITIONAL
; COMMAND SCANNING (S%CMND) INTERFACE

;FORMAT OF COMND STATE BLOCK:

	.CMFLG=0			;USER FLAGS,,REPARSE DISPATCH ADDRESS
	.CMIOJ=1			;INJFN,,OUTJFN
	.CMRTY=2			;^R BUFFER POINTER
	.CMBFP=3			;PTR TO TOP OF BUFFER
	.CMPTR=4			;PTR TO NEXT INPUT TO BE PARSED
	.CMCNT=5			;COUNT OF SPACE LEFT IN BUFFER AFTER PTR
	.CMINC=6			;COUNT OF CHARACTERS FOLLOWING PTR
	.CMABP=7			;ATOM BUFFER POINTER
	.CMABC=10			;ATOM BUFFER SIZE
	.CMGJB=11			;ADR OF GTJFN ARG BLOCK
	 CM%GJB=777777		;ADR OF GTJFN ARG BLOCK

>  ;END TOPS10

	SUBTTL PDB - PARSER DESCRIPTOR BLOCK DEFINITION

; THE PARSER DESCRIPTOR BLOCK (PDB) IS THE BASIC DATA STRUCTURE USED TO 
;CONTROL THE ACTION OF THE PARSER ROUTINE. THE FULL-BLOWN PDB CONSISTS OF THE STANDARD 
;FUNCTION DESCRIPTOR BLOCK (FDB) AS USED BY THE COMND JSYS, PLUS FOUR 
;ADDITIONAL WORDS USED BY THE PARSER ROUTINE TO CONTROL THE PARSE.
;HOWEVER, UNNECESSARY WORDS AT THE END OF THE FDB AND PRIVATE PART OF PDB
;ARE NOT ALLOCATED WHEN POSSIBLE.

;FUNCTION DESCRIPTOR BLOCK

	.CMFNP=0			;FUNCTION AND POINTER
	   CM%FNC=777B8		;FUNCTION CODE
	   CM%FFL=377B17		;FUNCTION-SPECIFIC FLAGS
	   CM%LST=777777		;LIST POINTER
	.CMDAT=1			;DATA FOR FUNCTION
	.CMHLP=2			;HELP TEXT POINTER
	.CMDEF=3			;DEFAULT STRING POINTER
	.CMBRK==4			;BREAK SET FOR CM%BRK

;THIS BLOCK DEFINES THE OFFSETS AFTER THE FDB FOR THE PDB
;RELATED ROUTINES.
	
	PB%HDR==0		;HEADER FOR THE BLOCK
	 PB.PDB==-1,,0		;OFFSET FOR PDB LENGTH
	 PB.FDB==0,,-1		;OFFSET FOR FDB LENGTH

	PHASE	0

PB%NXT:! BLOCK	1			;NEXT PDB TO USE
PB%RTN:! BLOCK	1			;ACTION ROUTINE FOR THE PARSER
PB%ERR:! BLOCK	1			;ERROR ROUTINE
PB%DEF:! BLOCK	1			;DEFAILT FILLING ROUTINE
PB%SIZ:! 				;SIZE OF MAXIMUM PDB DATA


	DEPHASE

PDB.SZ==.CMBRK+PB%SIZ

SUBTTL	CONSTANT DEFINITIONS FOR PARSER 

NCHPW==5			;NUMBER OF ASCII CHARACTERS PER WORD
BUFSIZ==200			;SIZE OF INPUT TEXT BUFFER
ATMSIZ==BUFSIZ			;SIZE OF ATOM BUFFER FOR COMND JSYS
FDBSIZ==.CMDEF+2		;SIZE OF FUNCTION DESCRIPTOR BLOCK

; GTJFN BLOCK FOR COMMAND

TOPS20	<GJFSIZ==.GJRTY+2>		;SIZE OF GTJFN BLOCK USED BY COMND JSYS

TOPS10	<GJFSIZ==FDXSIZ>

	.RDSIZ==.RDBKL+1		;SIZE OF ARGUMENT BLOCK

END
