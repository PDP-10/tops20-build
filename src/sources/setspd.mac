; UPD ID= 57, RIP:<7.UTILITIES>SETSPD.MAC.192,   1-Mar-88 16:09:50 by GSCOTT
;TCO 7.1249 - Edit 235, if DMP: is offline or badly defined, use the filename
; that we have patiently set up rather than BS:<SYSTEM>DUMP.CPY.  A warning
; message (not an error) should be output if the dump structure is not found.
; Also fix some places that called JSYER1 to do the right thing.  XLIST the 
; stupid historical cache refill code.
; UPD ID= 55, RIP:<7.UTILITIES>SETSPD.MAC.191,  23-Feb-88 09:41:20 by GSCOTT
;TCO 7.1239 - Edit 234, insure that we don't get into TI when run at entry
; vector offset zero by an older monitor on a front end reload.
; UPD ID= 47, RIP:<7.UTILITIES>SETSPD.MAC.189,  19-Feb-88 17:45:51 by GSCOTT
;TCO 7.1236 - Edit 233, update copyright.
; UPD ID= 46, RIP:<7.UTILITIES>SETSPD.MAC.188,  19-Feb-88 15:52:55 by GSCOTT
;TCO 7.1235 -  Edit 232, add 3 new keywords to ENABLE/DISABLE DUMP-ON-BUGCHK
; command: ALL-BUGCHKS, ALL-BUGINFS, and BUG name [IGNORE-DUMP-TIMEOUT].
; Add command prompt if in user mode, EXIT command, output version number.
; UPD ID= 44, RIP:<7.UTILITIES>SETSPD.MAC.187,  18-Feb-88 21:10:53 by GSCOTT
;More of TCO 7.1231 - increment version number to 231 for previous edit.
; UPD ID= 43, RIP:<7.UTILITIES>SETSPD.MAC.186,  18-Feb-88 15:34:33 by RASPUZZI
;TCO 7.1231 - Add ENABLE/DISABLE minimum password commands.
; UPD ID= 39, RIP:<7.UTILITIES>SETSPD.MAC.185,  26-Jan-88 11:05:03 by GSCOTT
;TCO 7.1198 - Edit 230, fix problem with ERROR macro.
; UPD ID= 32, RIP:<7.UTILITIES>SETSPD.MAC.183,  14-Dec-87 09:17:37 by BROOKS
;Increment version number for 7.0 ft1
; UPD ID= 22, RIP:<7.UTILITIES>SETSPD.MAC.182,   4-Nov-87 15:45:20 by MCCOLLUM
;TCO 7.1112 - Add ENABLE/DISABLE LOGIN STRUCTURE. Look for dumps on BS:
; UPD ID= 20, RIP:<7.UTILITIES>SETSPD.MAC.180,  29-Oct-87 14:46:23 by RASPUZZI
;TCO 7.1097 - Make ENABLE/DISABLE table alphabetical once again.
; UPD ID= 19, RIP:<7.UTILITIES>SETSPD.MAC.179,  28-Oct-87 22:52:41 by RASPUZZI
;More of TCO 7.1076 - Get routine labels in the right place this time
; UPD ID= 18, RIP:<7.UTILITIES>SETSPD.MAC.178,  25-Oct-87 14:16:11 by GSCOTT
;More of TCO 7.1081 - Create proper filename if no BUGNAM, just a BUGVER
; UPD ID= 17, RIP:<7.UTILITIES>SETSPD.MAC.177,  23-Oct-87 17:05:42 by GSCOTT
;TCO 7.1081 - Add code and comments for DOB support, add table of contents, 
;             change error macros and use of them and clean up all error 
;             messages, fixup gark code here and there, handle removal of
;             SPRCNT code with FTSC conditional, reset edit to 203, the sum
;             of 4.1, 5.1, 6.0, 6.1 SETSPDs
; UPD ID= 11, RIP:<7.UTILITIES>SETSPD.MAC.4,  21-Oct-87 15:13:25 by RASPUZZI
;TCO 7.1076 - Add ENABLE/DISABLE CLUSTER-INFO and CLUSTER-SEND support
; UPD ID= 6, RIP:<7.UTILITIES>SETSPD.MAC.3,  23-Sep-87 15:52:18 by MCCOLLUM
;TCO 7.1063 - And ENABLE/DISABLE OFFLINE-STRUCTURES commands
; UPD ID= 1, RIP:<7.UTILITIES>SETSPD.MAC.2,  28-May-87 15:23:26 by RASPUZZI
;No TCO - Move SETSPD to 7.0 utility area.
; *** Edit 64 to SETSPD.MAC by RASPUZZI on 6-Oct-86, for SPR #21393
; Add 2 new keywords to TERMINAL for IGNORING SYSTEM MESSAGES and USER MESSAGES
; *** Edit 63 to SETSPD.MAC by RASPUZZI on 11-Jun-86, for SPR #20381
; Rework edit 62 so that the monitor's entry vector is different at system
; startup.
; UPD ID= 119, SNARK:<6.1.UTILITIES>SETSPD.MAC.10,  30-Apr-85 16:24:11 by DUSSEAULT
;TCO 6.1.1352 - Add range checking for unit number in PRINTER command.  Add
;	an error message when invalid unit numbers are encountered.
; UPD ID= 79, SNARK:<6.1.UTILITIES>SETSPD.MAC.9,  13-Feb-85 16:26:29 by GLINDELL
; Maximum-buffer in DCNTA0 should be maximum-bufferS
; UPD ID= 55, SNARK:<6.1.UTILITIES>SETSPD.MAC.8,   6-Dec-84 16:29:17 by GLINDELL
;Check for and suppress NODX16 errors from NODE% jsys in DECNET/NODE command
; UPD ID= 47, SNARK:<6.1.UTILITIES>SETSPD.MAC.7,  17-Nov-84 16:18:03 by MELOHN
;TCO 6.1.1055 - Add LAT-STATE ON or OFF command. Sets LASDEF via SMON%
; UPD ID= 37, SNARK:<6.1.UTILITIES>SETSPD.MAC.6,   6-Nov-84 19:50:42 by TBOYLE
;Fix the TCO number on the previous edit.
; UPD ID= 36, SNARK:<6.1.UTILITIES>SETSPD.MAC.5,   2-Nov-84 19:27:12 by TBOYLE
;TCO 6.1.1034 - Changes to DMPRED, DMPMAP, add MAPSEC for multisection support.
; UPD ID= 34, SNARK:<6.1.UTILITIES>SETSPD.MAC.4,   2-Nov-84 12:23:40 by GLINDELL
;Change VMINOR to 1 since this is now a 6.1 specific SETSPD
; UPD ID= 612, SNARK:<6.UTILITIES>SETSPD.MAC.63,  18-Oct-84 14:44:54 by TBOYLE
;TCO 6.2253 (QAR 706284) wait for CI disks during dump processing.
; UPD ID= 611, SNARK:<6.UTILITIES>SETSPD.MAC.62,  17-Oct-84 16:22:59 by GRANT
;In DCARE, pick up unit from correct offset before doing the SMON%
; UPD ID= 608, SNARK:<6.UTILITIES>SETSPD.MAC.61,  14-Oct-84 14:34:39 by GLINDELL
;TCO 6.1.1006 - Add DECNET DEFAULT-FLOW-CONTROL command
; UPD ID= 587, SNARK:<6.UTILITIES>SETSPD.MAC.60,  21-Aug-84 13:34:14 by TBOYLE
;TCO 6.2187 (QAR 706128) At NXTUNT, initialize structure name and alias.
; UPD ID= 586, SNARK:<6.UTILITIES>SETSPD.MAC.58,  20-Aug-84 16:28:18 by TBOYLE
;TCO 6.2183 (QAR 706085) At STRMOU, if no DMP: return. Check structure
; returned by JFNS with STDEV to see if mounting needed. Fix T3 for JFNS.
; UPD ID= 583, SNARK:<6.UTILITIES>SETSPD.MAC.56,  14-Aug-84 14:50:35 by TBOYLE
;New SYSERR - prepare QUELOP for extended addresses in SEBQOU, SEBCDR.
; UPD ID= 582, SNARK:<6.UTILITIES>SETSPD.MAC.55,  14-Aug-84 14:31:48 by TBOYLE
;New SYSERR - Be able to read the new SYSERR blocks. SEBHED, SEBSIZ different.
; UPD ID= 581, SNARK:<6.UTILITIES>SETSPD.MAC.53,  10-Aug-84 18:07:09 by GROSSMAN
;Set minor version number to 0.
; UPD ID= 580, SNARK:<6.UTILITIES>SETSPD.MAC.52,  10-Aug-84 17:59:05 by GROSSMAN
;TCO 6.2170 - Fix ETHERNET <chan> DECNET command to let the monitor figure
;out the correct Ethernet address for a DECnet channel.
; UPD ID= 554, SNARK:<6.UTILITIES>SETSPD.MAC.51,  19-Jun-84 17:18:29 by MCLEAN
;ADD DON'T CARE LOGIC
; UPD ID= 547, SNARK:<6.UTILITIES>SETSPD.MAC.50,   8-Jun-84 11:21:43 by GLINDELL
;TCO 6.1.1006 - Add DECNET commands to provide initial parameters for DECnet
; UPD ID= 535, SNARK:<6.UTILITIES>SETSPD.MAC.49,  24-May-84 20:01:15 by GLINDELL
;TCO 6.1.1005 - Accept area number in DECnet node number
; UPD ID= 531, SNARK:<6.UTILITIES>SETSPD.MAC.48,  15-May-84 13:08:56 by TBOYLE
;REMOVE  TCO 6.1637, SPEAR COUNTER STUFF. IT'S DONE IN SYSERR NOW.
; UPD ID= 519, SNARK:<6.UTILITIES>SETSPD.MAC.47,  17-Apr-84 10:37:43 by GROSSMAN
;TCO 6.2036 - Add ETHERNET command to set Ethernet address.
; UPD ID= 498, SNARK:<6.UTILITIES>SETSPD.MAC.45,   5-Mar-84 16:19:02 by MOSER
;MORE 6.1562  - READ SERIAL NUMBERS IN DECIMAL. FIX ERROR MESSAGE
; UPD ID= 492, SNARK:<6.UTILITIES>SETSPD.MAC.44,  29-Feb-84 17:59:09 by PRATT
;TCO 6.1956 - Add ENABLE/DISABLE FAST-LOGIN-OPTION
; UPD ID= 476, SNARK:<6.UTILITIES>SETSPD.MAC.43,   8-Feb-84 14:02:57 by TBOYLE
;More TCO 6.1934 Change 22 to ^D22 at SETCN1.
; UPD ID= 470, SNARK:<6.UTILITIES>SETSPD.MAC.42,   8-Feb-84 10:05:16 by EVANS
;Add flag to edit number so I VER will display it in decimal.
; UPD ID= 465, SNARK:<6.UTILITIES>SETSPD.MAC.41,   8-Feb-84 08:37:15 by MCINTEE
;Change NODNAM routine to set the node number first.
; UPD ID= 458, SNARK:<6.UTILITIES>SETSPD.MAC.40,  25-Jan-84 18:58:50 by MOSER
;STILL MORE 6.1562 - FIX A BUG
; UPD ID= 456, SNARK:<6.UTILITIES>SETSPD.MAC.39,  25-Jan-84 09:57:16 by MOSER
;FIX AN ERROR IN 6.1934 - SETSPD WON'T BUILD
; UPD ID= 449, SNARK:<6.UTILITIES>SETSPD.MAC.38,  23-Jan-84 17:27:13 by TBOYLE
;More TCO 6.1934 Cleanup GTJFN error messages.
; UPD ID= 446, SNARK:<6.UTILITIES>SETSPD.MAC.37   23-Jan-84 16:24:13 by TBOYLE
;TCO 6.1948 - Fix JSYER0 to output the actual error message
; UPD ID= 445, SNARK:<6.UTILITIES>SETSPD.MAC.36,  23-Jan-84 16:16:40 by MOSER
;TCO 6.1562 - CHANGE FORMAT OF ALLOW / RESTRICT
; UPD ID= 437, SNARK:<6.UTILITIES>SETSPD.MAC.34,  18-Jan-84 13:45:32 by PAETZOLD
;TCO 6.1941 - ENA/DIS HANGUP-IF-LOGGED-IN/OUT commands need alphabetical order.
;TCO 6.1938 - add support for ena/dir system-message-level-0/1 commands.
; UPD ID= 435, SNARK:<6.UTILITIES>SETSPD.MAC.33,  17-Jan-84 19:47:02 by TBOYLE
;TCO 6.1937 - ENA/DIS HANGUP-IF-LOGGED-IN/OUT code.
; UPD ID= 431, SNARK:<6.UTILITIES>SETSPD.MAC.32,  13-Jan-84 17:28:47 by TBOYLE
;TCO 6.1934 - At SETCNT determine a new SPRCNT from ERROR.SYS properly.
; UPD ID= 397, SNARK:<6.UTILITIES>SETSPD.MAC.31,   9-Dec-83 21:49:16 by MCLEAN
;WORK ON THE NEW INTERNAL ERROR FORMATS
;MISSING COUNTS SPEAR RUNNING COUNT
; UPD ID= 357, SNARK:<6.UTILITIES>SETSPD.MAC.30,   5-Oct-83 22:27:46 by MCLEAN
;TCO 6.1819 MAKE SEBHED 2 (NOTE THIS REALLY IS NOT A GOOD SYMBOL NAME)
; UPD ID= 352, SNARK:<6.UTILITIES>SETSPD.MAC.29,  21-Sep-83 14:28:11 by TGRADY
; TCO 6.1804.  Don't mount the DMP: structure exclusively...
; UPD ID= 351, SNARK:<6.UTILITIES>SETSPD.MAC.28,  16-Sep-83 15:49:51 by MCLEAN
;PUT SEBHED BACK TO 4 WORDS SINCE JSYS HASN'T CHANGED
; UPD ID= 297, SNARK:<6.UTILITIES>SETSPD.MAC.27,  20-Jun-83 13:14:40 by MOSER
;TCO 6.1562 SERVICE, ALLOW, RESTRICT COMMANDS FOR MSCP SERVER
; UPD ID= 284, SNARK:<6.UTILITIES>SETSPD.MAC.26,  17-May-83 14:18:11 by LOMARTIRE
;TCO 6.1634 - Allow SETSPD to timeout if a command takes more than 30 sec.
; UPD ID= 282, SNARK:<6.UTILITIES>SETSPD.MAC.25,  11-May-83 15:17:06 by COBB
;TCO 6.1637 - Teach SETSPD to read the SPEAR counter from the dump and SMON% it
; UPD ID= 261, SNARK:<6.UTILITIES>SETSPD.MAC.24,  16-Apr-83 17:10:42 by PAETZOLD
;TCO 6.1616 - TCP Changes.  Break the ARPANET HOST command.
; UPD ID= 206, SNARK:<6.UTILITIES>SETSPD.MAC.23,   9-Feb-83 14:02:18 by WEETON
; UPD ID= 135, SNARK:<6.UTILITIES>SETSPD.MAC.22,  23-Sep-82 16:01:00 by MOSER
;TCO 6.1278 - BLT CORRECT NUMBER OF WORDS AT SPEED:
; UPD ID= 123, SNARK:<6.UTILITIES>SETSPD.MAC.21,   1-Sep-82 14:34:02 by HAUDEL
;TCO 6.1241 - Close DUMP.CPY when error occurs so lost pages are not created.
; UPD ID= 110, SNARK:<6.UTILITIES>SETSPD.MAC.20,   4-Aug-82 13:43:19 by CDUNN
;TCO 6.1189 (Again) - Fix bug in STRMOU code. Now ERJMP to MSTR error routine
;so RET takes you back to CPYDMP instead of back into the MSTR routine.
;Makes not finding dump structure work.
; UPD ID= 102, SNARK:<6.UTILITIES>SETSPD.MAC.19,  26-Jul-82 00:27:32 by CDUNN
;Add a <CRLF> before the dismount of the dump structure. Makes CTY more
;readable...
; UPD ID= 101, SNARK:<6.UTILITIES>SETSPD.MAC.18,  19-Jul-82 22:29:56 by CDUNN
;TCO 6.1189 Teach CPYDMP to mount the structure implied by DMP:. Also
;dismount when done.
; UPD ID= 45, SNARK:<6.UTILITIES>SETSPD.MAC.17,  19-May-82 10:51:21 by MILLER
; UPD ID= 44, SNARK:<6.UTILITIES>SETSPD.MAC.16,  19-May-82 10:43:09 by MILLER
;TCO 6.1142. ADD ENABLE/DISABLE COMMANDS FOR SYSTEM ERROR MESSAGES
; UPD ID= 30, SNARK:<6.UTILITIES>SETSPD.MAC.15,  22-Feb-82 10:23:58 by MURPHY
;yet again
; UPD ID= 29, SNARK:<6.UTILITIES>SETSPD.MAC.14,  19-Feb-82 15:34:56 by MURPHY
;More of same.
; UPD ID= 28, SNARK:<6.UTILITIES>SETSPD.MAC.13,  18-Feb-82 17:24:52 by MURPHY
;TCO 6.1060 - Copy dumps to DMP: instead of PS:<SYSTEM>
; UPD ID= 21, SNARK:<6.UTILITIES>SETSPD.MAC.12,  17-Jan-82 19:13:45 by PAETZOLD
;TCO 5.1681 - fix the change command
; UPD ID= 9, SNARK:<6.UTILITIES>SETSPD.MAC.11,   2-Nov-81 09:58:21 by PAETZOLD
;TCO 6.1035 - Update version information for release 6
; UPD ID= 26, SNARK:<5.UTILITIES>SETSPD.MAC.10,  31-Aug-81 09:33:07 by PAETZOLD
;TCO 5.1461 - read and interpret MMAP when getting queued SYSERR blocks
; UPD ID= 18, SNARK:<5.UTILITIES>SETSPD.MAC.9,   3-Aug-81 12:51:24 by ZIMA
;TCO 5.1438 - Include Friday in "ALL" entry in day-of-week table.
; UPD ID= 8, SNARK:<5.UTILITIES>SETSPD.MAC.8,  20-Jul-81 15:54:57 by MOSER
;TCO 5.1424 CHANGE BACKGROUND COMMAND TO BATCH-BACKGROUND.
; UPD ID= 2311, SNARK:<5.UTILITIES>SETSPD.MAC.7,   8-Jul-81 15:23:12 by DONAHUE
;TCO 5.1401 - Add TU77 entry to SLAVT table
; UPD ID= 2100, SNARK:<5.UTILITIES>SETSPD.MAC.6,  28-May-81 11:55:31 by PAETZOLD
;TCO 5.1352 - Change error handler to not complain about invalid
;keywords when started at start4.  This will prevent J0NRUN BUGHLT's
; UPD ID= 2070, SNARK:<5.UTILITIES>SETSPD.MAC.5,  24-May-81 15:35:52 by ZIMA
;TCO 5.1346 - EDIT 21 - pass proper MO%LCP setting on all subsequent LPINI
; calls for a unit.
; UPD ID= 1769, SNARK:<5.UTILITIES>SETSPD.MAC.4,  25-Mar-81 17:49:49 by GRANT
;Update Copyright
; UPD ID= 1367, SNARK:<5.UTILITIES>SETSPD.MAC.3,  18-Dec-80 10:25:34 by WACHS
;TCO 5.16 - ADD TM78 DEFINITION
; UPD ID= 524, SNARK:<5.UTILITIES>SETSPD.MAC.2,  15-May-80 13:33:16 by LYONS
;tco 5.1040 - Make release 5 look for 5-CONFIG.CMD
; UPD ID= 325, SNARK:<4.1.UTILITIES>SETSPD.MAC.5,  12-Mar-80 14:16:04 by OSMAN
;tco 4.1.1107 - Make release 4.1 look for 4-1-CONFIG.CMD
; UPD ID= 299, SNARK:<4.1.UTILITIES>SETSPD.MAC.3,  29-Feb-80 13:22:36 by OSMAN
;tco 4.1.1096 - Use COMND instead of TEXTI so as to allow "POLICY-PROGRAM"
; UPD ID= 102, SNARK:<4.1.UTILITIES>SETSPD.MAC.2,   6-Dec-79 11:05:53 by BLOUNT
;<4.1.UTILITIES>SETSPD.MAC.2,  6-Dec-79 10:55:56, EDIT BY BLOUNT
;TCO #4.2590 -CHANGE AT QUEDN1+7 TO FIX KS HALT STATUS BLOCK BUG
;<4.UTILITIES>SETSPD.MAC.44,  9-Oct-79 15:26:55, EDIT BY GRANT
;<4.UTILITIES>SETSPD.MAC.43, 25-May-79 13:02:47, EDIT BY MILLER
;FIX QUEBLK. IT WAS COMPUTING # OF PAGES TO DUMP OFF-BY-ONE
;<4.UTILITIES>SETSPD.MAC.42, 11-Apr-79 15:57:49, Edit by LCAMPBELL
; Fix up addressing of SYERR block at QUEDN1
;<4.UTILITIES>SETSPD.MAC.41, 13-Mar-79 08:50:11, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.UTILITIES>SETSPD.MAC.40, 13-Mar-79 06:50:04, EDIT BY R.ACE
;TAKE OUT TAPE-MOUNT-DEFAULT COMMAND
;ADD TAPE-RECOGNITION-ERRORS COMMAND
;<4.UTILITIES>SETSPD.MAC.39, 21-Feb-79 11:36:40, EDIT BY MURPHY
;ENABLE/DISABLE WORKING SET PRELOADING - DLM
;<4.UTILITIES>SETSPD.MAC.38, 20-Feb-79 17:43:04, EDIT BY BLOUNT
;CHANGE CLASS-SCHEDULER TO CLASS-SCHEDULING
;<4.UTILITIES>SETSPD.MAC.37, 19-Feb-79 14:22:43, Edit by MCLEAN
;FIX IT SO ECSKED WITH ARGUMENTS GIVES ERROR
;<4.UTILITIES>SETSPD.MAC.36, 19-Feb-79 13:24:27, Edit by MCLEAN
;CORRECT SPELLING OF WITHHELD
;<4.UTILITIES>SETSPD.MAC.35, 24-Jan-79 10:51:08, EDIT BY R.ACE
;MOVE TAPE-RECYCLE-PERIOD TO RIGHT PLACE, UPDATE EDIT#
;<4.UTILITIES>SETSPD.MAC.34, 11-Dec-78 06:52:19, EDIT BY R.ACE
;PUT ERJMP'S AFTER SYERR CALLS
;<4.UTILITIES>SETSPD.MAC.33, 28-Nov-78 08:04:16, EDIT BY R.ACE
;TCO 4.2098 - ADD TAPE-MOUNT-DEFAULT COMMAND
;ADD COMND JSYS ROUTINES FOR PARSING NEW SETSPD COMMANDS
;<ARC-DEC>SETSPD.MAC.3,  3-Oct-78 09:50:04, EDIT BY CALVIN
; Cause GTKEY to eat all of hypenated command name
;<ARC-DEC>SETSPD.MAC.1, 29-Sep-78 15:58:56, EDIT BY CALVIN
; Add ARCHIVE-TAPE-RECYCLE-PERIOD and TAPE-RECYCLE-PERIOD
;<4.UTILITIES>SETSPD.MAC.31, 20-Oct-78 19:16:54, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.30, 20-Oct-78 19:13:31, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.29, 20-Oct-78 19:12:53, EDIT BY MILLER
;TCO 4.2011. ADD BATCH-CLASS COMMAND
;<4.UTILITIES>SETSPD.MAC.28, 19-Oct-78 17:49:03, Edit by MCLEAN
;MAKE SKED JSYS BE SKED%
;<2MCLEAN>SETSPD.MAC.27, 24-Sep-78 21:56:05, Edit by MCLEAN
;<2MCLEAN>SETSPD.MAC.26, 21-Sep-78 21:22:18, Edit by MCLEAN
;<4.UTILITIES>SETSPD.MAC.25, 20-Sep-78 11:35:08, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.24, 19-Sep-78 12:57:51, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.23, 19-Sep-78 12:56:37, EDIT BY MILLER
;MORE OF TCO 4.2011
;<4.UTILITIES>SETSPD.MAC.22, 19-Sep-78 12:12:05, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.21, 19-Sep-78 12:10:50, EDIT BY MILLER
;TCO 4.2011. ADD ENABLE OPTIONS FOR CLASS SCHEDULER
;<4.UTILITIES>SETSPD.MAC.20, 19-Sep-78 11:27:50, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.19, 19-Sep-78 11:25:05, EDIT BY MILLER
;TCO 4.2011 AGAIN. ADD CREATE COMMAND
;<4.UTILITIES>SETSPD.MAC.18, 17-Sep-78 14:05:21, EDIT BY MILLER
;TCO 4.2011. IMPLEMENT "BATCH-BACKGROUND" COMMAND
;<4.UTILITIES>SETSPD.MAC.17, 24-Aug-78 12:07:17, EDIT BY R.ACE
;TCO 4.1993 - ADD COMMAND: ENABLE TAPE-DRIVE-ALLOCATION
;ADDED COMMENTING TO BEGINNING OF MODULE
;<R.ACE.LT>SETSPD.MAC.4, 23-Aug-78 16:44:38, EDIT BY R.ACE
;<R.ACE.LT>SETSPD.MAC.3, 23-Aug-78 13:19:33, EDIT BY R.ACE
;<R.ACE.LT>SETSPD.MAC.2, 23-Aug-78 12:12:30, EDIT BY R.ACE
;<2MCLEAN>SETSPD.MAC.17, 28-Jul-78 15:36:32, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.16, 26-Jul-78 15:00:29, Edit by MCLEAN
;<4.UTILITIES>SETSPD.MAC.13, 18-Jul-78 14:10:12, EDIT BY MILLER
;CHANGE VERSION NUMBER TO 4
;<4.UTILITIES>SETSPD.MAC.12, 16-May-78 09:23:45, EDIT BY MILLER
;ADD MINOR VERSION TO CONFIG FILE NAME
;<4.UTILITIES>SETSPD.MAC.11,  6-May-78 22:17:11, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.21,  4-Aug-78 13:13:02, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.20,  4-Aug-78 13:11:23, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.19,  3-Aug-78 17:12:20, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.18, 28-Jul-78 15:33:15, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.17, 27-Jul-78 14:41:21, EDIT BY MILLER
;INCREMENT EDIT NUMBER
;<3A.UTILITIES>SETSPD.MAC.16, 26-Jul-78 15:00:29, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.15, 16-May-78 09:21:33, EDIT BY MILLER
;<3A.UTILITIES>SETSPD.MAC.14, 16-May-78 09:19:58, EDIT BY MILLER
;<3A.UTILITIES>SETSPD.MAC.13, 16-May-78 09:17:32, EDIT BY MILLER
;AND CHANGE VERSION TO 3A
;<3A.UTILITIES>SETSPD.MAC.12, 16-May-78 09:16:35, EDIT BY MILLER
;ADD MINOR VERSION TO CONFIG NAME
;<1MCLEAN>SETSPD.MAC.17,  4-May-78 18:31:02, Edit by MCLEAN
;<1MCLEAN>SETSPD.MAC.16,  4-May-78 18:24:33, Edit by MCLEAN
;<1MCLEAN>SETSPD.MAC.15,  4-May-78 17:37:31, Edit by MCLEAN
;<1MCLEAN>SETSPD.MAC.14,  4-May-78 17:22:55, Edit by MCLEAN
;<1MCLEAN>SETSPD.MAC.13,  4-May-78 17:22:03, Edit by MCLEAN
;<1MCLEAN>SETSPD.MAC.12,  4-May-78 16:22:12, Edit by MCLEAN
;<1MCLEAN>SETSPD.MAC.11,  4-May-78 16:16:56, Edit by MCLEAN
;TCO 1880 ADD SLAVE TYPES TO MTALN JSYS
;<4.UTILITIES>SETSPD.MAC.9,  9-Apr-78 13:24:57, EDIT BY MILLER
;MERGE IN CHANGES TO NODE COMMAND FROM 3A SOURCE
;<4.UTILITIES>SETSPD.MAC.8,  7-Apr-78 00:40:43, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.9,  7-Apr-78 00:15:05, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.8,  7-Apr-78 00:13:21, Edit by MCLEAN
;<3A.UTILITIES>SETSPD.MAC.7,  7-Apr-78 00:07:24, Edit by MCLEAN
;ADD HSB (HALT STATUS BLOCK) FOR KS10
;<4.UTILITIES>SETSPD.MAC.5,  2-Mar-78 15:04:19, Edit by PORCHER
;<4.UTILITIES>SETSPD.MAC.4, 28-Feb-78 14:35:36, Edit by PORCHER
;<4.UTILITIES>SETSPD.MAC.3, 28-Feb-78 14:25:25, Edit by PORCHER
;ADD "CHANGE" COMMAND FOR ACCOUNTING SHIFT CHANGES
;<4.UTILITIES>SETSPD.MAC.2, 31-Jan-78 00:41:13, Edit by MCLEAN
;MAGTAPE ONLINE ENTRY VECTOR UPDATES
;<4.UTILITIES>SETSPD.MAC.2, 16-Dec-77 14:01:29, EDIT BY MILLER
;<4.UTILITIES>SETSPD.MAC.1, 16-Dec-77 13:56:02, EDIT BY MILLER
;TCO 1879. ADD NODE COMMAND

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

	TITLE SETSPD - Execute x-CONFIG.CMD and Copy System Dumps  

	SEARCH MONSYM,MACSYM,SERCOD,CMD

	.CPYRT <<1976, 1988>>
	.REQUIRE SYS:MACREL	;Use MACREL routines
	.REQUIRE SYS:CMD	;Use CMD package

	SALL			;Suppress ugly MACRO expansions
	.DIRECTIVE FLBLST	;Only first line binary in the listing

; This program is run by job 0 to perform various user-mode functions
; that affect the operation of the system.  Depending upon the desired
; action, the program is started at one of several positions in its
; entry vector.  SETSPD.EXE should be copied to BS:<SYSTEM>x-y-SETSPD.EXE,
; where "x" is the major version number and "y" is the minor version number
; of the monitor (if any).
	Subttl	Table of Contents

;		     Table of Contents for SETSPD
;
;				  Section		      Page
;
;
;    1. Version Number . . . . . . . . . . . . . . . . . . . .   5
;    2. Entry Vector . . . . . . . . . . . . . . . . . . . . .   6
;    3. SETSPD Data  . . . . . . . . . . . . . . . . . . . . .   7
;    4. Command Tables . . . . . . . . . . . . . . . . . . . .  11
;    5. Interrupt System Tables  . . . . . . . . . . . . . . .  16
;    6. Error Macros . . . . . . . . . . . . . . . . . . . . .  17
;    7. Build Config File Name and Prompt  . . . . . . . . . .  18
;    8. Initialization
;        8.1    Entry Points For Reading x-CONFIG.CMD File . .  19
;        8.2    Determine If Interactive Session . . . . . . .  20
;        8.3    Find SYSTEM:x-CONFIG.CMD . . . . . . . . . . .  21
;        8.4    Top Level Command Parser . . . . . . . . . . .  22
;        8.5    Capabilities and Interrupt System  . . . . . .  23
;    9. Commands
;        9.1    Hung Command Timeout . . . . . . . . . . . . .  24
;        9.2    TERMINAL . . . . . . . . . . . . . . . . . . .  25
;        9.3    RESTRICT and ALLOW . . . . . . . . . . . . . .  32
;        9.4    DONTCARE . . . . . . . . . . . . . . . . . . .  34
;        9.5    MAGTAPE  . . . . . . . . . . . . . . . . . . .  36
;        9.6    TAPE-RECOGNITION-ERRORS  . . . . . . . . . . .  37
;        9.7    ENABLE and DISABLE . . . . . . . . . . . . . .  38
;        9.8    DAYLIGHT . . . . . . . . . . . . . . . . . . .  50
;        9.9    LAT-STATE  . . . . . . . . . . . . . . . . . .  51
;        9.10   DEFINE . . . . . . . . . . . . . . . . . . . .  52
;        9.11   EXIT . . . . . . . . . . . . . . . . . . . . .  53
;        9.12   TIMEZONE . . . . . . . . . . . . . . . . . . .  54
;        9.13   HOST . . . . . . . . . . . . . . . . . . . . .  55
;        9.14   ARCHIVE-TAPE-RECYCLE-PERIOD  . . . . . . . . .  56
;        9.15   TAPE-RECYCLE-PERIOD  . . . . . . . . . . . . .  57
;        9.16   NODE . . . . . . . . . . . . . . . . . . . . .  58
;        9.17   DECNET . . . . . . . . . . . . . . . . . . . .  60
;        9.18   ETHERNET . . . . . . . . . . . . . . . . . . .  62
;        9.19   CHANGE . . . . . . . . . . . . . . . . . . . .  65
;        9.20   PRINTER  . . . . . . . . . . . . . . . . . . .  66
;        9.21   BIAS . . . . . . . . . . . . . . . . . . . . .  71
;        9.22   BATCH-BACKGROUND . . . . . . . . . . . . . . .  72
;        9.23   CREATE . . . . . . . . . . . . . . . . . . . .  73
;        9.24   ENABLE CLASS-SCHEDULING  . . . . . . . . . . .  74
;        9.25   BATCH-CLASS  . . . . . . . . . . . . . . . . .  75
	Subttl	Table of Contents (page 2)

;		     Table of Contents for SETSPD
;
;				  Section		      Page
;
;
;   10. System Dumps
;       10.1    At System Startup  . . . . . . . . . . . . . .  76
;       10.2    Continuable Dumps  . . . . . . . . . . . . . .  77
;       10.3    Process a Dump . . . . . . . . . . . . . . . .  79
;           10.3.1    Queue SYSERR Blocks  . . . . . . . . . .  82
;           10.3.2    Finish Up  . . . . . . . . . . . . . . .  84
;           10.3.3    Flush Incore Pages . . . . . . . . . . .  85
;           10.3.4    Set SPEAR Entry Count  . . . . . . . . .  86
;           10.3.5    Map Dump File to Read SYSERR Blocks  . .  88
;           10.3.6    Copy A Single Dump . . . . . . . . . . .  91
;           10.3.7    Mount Dump Structures  . . . . . . . . .  96
;           10.3.8    Dismount Dump Structures . . . . . . . . 101
;           10.3.9    Create Dump Filename . . . . . . . . . . 102
;   11. Free Space Subroutines . . . . . . . . . . . . . . . . 104
;   12. Error Routines . . . . . . . . . . . . . . . . . . . . 109
;   13. Cache Refill Code (Historical) . . . . . . . . . . . . 111
;   14. End of SETSPD  . . . . . . . . . . . . . . . . . . . . 112
	SUBTTL Version Number 

;[7.1081] Clean up general comments

; VERSION NUMBER DEFINITIONS

VMAJOR==7			;Major version of SETSPD
VMINOR==0			;Minor version number
VEDIT==VI%DEC+^D235		;Edit number
VWHO==0				;Group who last edited (0=DEC development)

VSTSPD==<VWHO>B2+<VMAJOR>B11+<VMINOR>B17+VEDIT

;Define registers used

	A==1			;[7.1081] Old code used A/B/C/D
	B==2			;[7.1081] 
	C==3			;[7.1081] 
	D==4			;[7.1081] 
	STDAC.			;[7.1081] New code uses standard ACs
	SUBTTL Entry Vector

;[7.1235][7.1081] Update comments about entry vector
;
; Pos	Description
; ---	--------
;
;  0	This is the normal starting entry for programs.  If SETSPD is started
;	here then it will read from the terminal instead of n-CONFIG.CMD.
;	Running SETSPD this way is reccomended for debugging new n-CONFIG
;	commands or for an occasional interactive command using SETSPD.  This
;	entry point is not used by the monitor.
;
;  1	Called once during system startup by RUNDD routine in MEXEC.
;	Reads file "SYSTEM:x-CONFIG.CMD" for commands such as ENABLE,
;	DISABLE, CHANGE, DEFINE, HOST, NODE, MAGTAPE, PRINTER, TERMINAL,
;	and so on.
;
;  2 	Contains TOPS-20 standard program version number.
;
;  3	Called by RUNDD routine in MEXEC during system
;	initialization after a crash to:
;	1. Copy PS:<SYSTEM>DUMP.EXE to DMP:DUMP-nnn-xxx.CPY
;	   where "nnn" is the monitor's edit number and "xxx" 
;	   is the BUG name that caused the dump.
;	2. Extract unrecorded SPEAR entries from DUMP.EXE and
;	   log them using the SYERR JSYS.
;
;  4	Called by CHKR routine in MEXEC while system is running
;	whenever PHYSIO detects that a tape drive has come online
;	and PHYSIO didn't know about the drive at system startup.
;	The x-CONFIG file is read as if entered at entry vector
;	position 1, except only the "MAGTAPE" commands in the
;	file are processed; all other commands are ignored.
;
;  5    Called by the CHKR routine in MEXEC when a Dump On BUGCHK
;	dump has been created, looks on all dumpable structures for
;	a dump to copy from str:<SYSTEM>DUMP.EXE to DMP:DUMP-nnn-xxx.CPY.

;[7.1081] Program entry vector

ENTVEC:	JRST START0		;[7.1235][7.1081] Starting location
MONVEC:	JRST START1		;[7.1081][63] The monitor starts SETSPD here
	VSTSPD			;[7.1081] Version number
	JRST START3		;[7.1081][63] Entry point for making DUMP.CPY
	JRST START4		;[7.1081][63] MTA/DISK online entry vector
	JRST START5		;[7.1081] Copy continuable dump
	ENVLEN==.-ENTVEC	;[7.1081] Entry vector length
	SUBTTL SETSPD Data

;[7.1081] Rearrange storage

DICT:	BLOCK 1			;FREE SPACE HEADER
CSBUFP:	BLOCK 1			;SCRATCH STRING POINTER
SYSTUP:	BLOCK 1			;[63] System startup flag (-1 if so)
JFN:	BLOCK 1			;JFN OF INPUT COMMAND FILE
DATBLK:	BLOCK 3			;FOR IDTNC STUFF FROM COMND (.CMTAD FUNCTION)
SMONBK:	BLOCK .SVDSN+1		;BLOCK FOR SMON FOR ALLOW / RESTRICT
LODLCP:	BLOCK <LPTN==2>		;FLAG NONZERO FOR LOWERCASE PRINTER
CLSBLK:	3			;COUNT
	BLOCK 2			;Data
MTBLK:	3			;SIZE OF BLOCK
	BLOCK 2			;FOR OTHER ARGS
EOLF:	BLOCK 1
PDL:	BLOCK <PDLEN=500>	;[7.1081] Push-down stack
PAGMAX:	BLOCK 1			;WORD TO HOLD HIGHEST DUMP PAGE NUMBER
FILNAM:	BLOCK ^D28		;NAME OF RAM OR VFU FILE PUT HERE
LINES:	BLOCK 1			;WORD TO HOLD LINES
STRBLK:	BLOCK .MSSLN		;BLOCK FOR STRUCTURE COMMAND
HSBBUF:	BLOCK HS%LEN		;LENGTH OF HSB AND HEADER
ASCTBL:	BLOCK <ASCTBZ==^D100>+1	;ACCOUNTING SHIFT CHANGE TABLE
MSCADR:	BLOCK 1			;ADDRESS OF MSECTB 
SPTADR:	BLOCK 1			;ADDRESS OF SPT
SECTN:	BLOCK 1			;SECTION NUMBER FOR MMPPG
SYSERR:	BLOCK ^D512		;SYSERR buffer
HNGCON:	BLOCK 1			;CONTINUATION ADDRESS IF HUNG
HNGSTK:	BLOCK 1			;STACK POINTER WHEN SETSPD HANGS
NCMDS:	BLOCK 1			;NUMBER OF COMMANDS PROCESSED

CMDSTG				;STORAGE FOR COMND JSYS

STRSIZ==100			;NUMBER OF SCRATCH STRING WORDS TO ALLOCATE

SPDTBL==560000			;SPEED TABLE
REMTBL==570000			;REMOTE TABLE
FREE==600000			;WHERE FREE SPACE STARTS
FRESIZ==50000			;SIZE OF FREE SPACE

;Following definitions are used for copying DUMP.EXE to DUMP-nnn-bugnam.CPY

DMPSTR:	BLOCK 2			;Hold the dump structure name here
DMPDIR:	BLOCK ^D28		;[7.1081] Hold the dump directory name here
ALISTR:	BLOCK 2			;Hold the structure alias of current str here
EXEINC:	BLOCK 1			;Flag if we must decrement DUMP.EXE mount count
CPYINC:	BLOCK 1 		;[7.1081] Nonzero when DMP: mount count incr
STRFLG:	BLOCK 1			;[7.1081] Nonzero when source mount count incr
NUMUNT:	BLOCK 1			;Number of units in the dump structure
UNTLFT:	BLOCK 1			;Number of units let unmounted in structure
CURSTR:	BLOCK 2			;Name of the structure currently being examined
TIMVAL:	BLOCK 1			;Timer value to retry for structure.
SYSFLG: BLOCK 1			;[7.1081] Flag whether called at system 
				;[7.1081] startup or to copy a continuable dump
STRNAM:	BLOCK 2			;[7.1081] Name of current structure
SIXNAM:	BLOCK 1			;[7.1081] SIXBIT name of current structure
BUGVER:	BLOCK 1			;[7.1081] Monitor version number from DUMP.EXE
BUGNAM:	BLOCK 1			;[7.1081] Name of BUGxxx that wrote DUMP.EXE
GTJBLK:	BLOCK .GJJFN		;[7.1081] GTJFN block for long form
GTJATR:	BLOCK 2			;[7.1081] GTJFN attribute block

FTSC==0				;[7.1081] Remove SPRCNT code, no longer needed
SPRCNT==113			;[7.1081] Address of running SPEAR entry count
  IFN FTSC,<			;[7.1081] If setting SPRCNT
TMPJFN:	BLOCK 1			;[7.1081] JFN of ERROR.SYS
SCDONE:	BLOCK 1			;[7.1081] -1 if SPEAR count set
  >				;[7.1081] 

EVFLG==3			;[7.1081] Offset for flag in entry vector
				;[7.1081]  0 = dump written by BOOT
				;[7.1081]  1 = dump written by DOB
				;[7.1081] -1 = dump copied by SETSPD
.JBVER==137			;[7.1081] Monitor version information
.JBBNM==114			;[7.1081] Monitor's last BUG name in SIXBIT
RTYTIM==^D30			;[7.1081] Number of seconds to wait for DMP:
JFNSFL==FLD(.JSAOF,JS%DEV)!FLD(.JSAOF,JS%DIR)!FLD(.JSAOF,JS%NAM)!FLD(.JSAOF,JS%TYP)!FLD(.JSAOF,JS%GEN)!JS%PAF ;[7.1081] Flag for JFNS% output

PGSFT==11		;PAGE SHIFT VALUE
CPYPGS==^D10		;# OF PAGES TO COPY WITH EACH PMAP
CPYWDS==CPYPGS_PGSFT	;NUMBER OF WORDS TO COPY

DEFSTR SEBSIZ,2,35,12		;POINTER TO SIZE FIELD IN SYSERR BLOCK
DEFSTR SEBERC,HSBBUF,8,9

STGADR==:<MASKB 12,35>		;MASK FOR STORAGE ADDRESSES (IMMEDIATE POINTERS
				; OR SPT ENTRIES)
PTRCOD==:<MASKB 0,2>		;CODE FIELD IN PAGE POINTER
SPTX==:<MASKB 18,35>		;MASK FOR SPT INDICES

SEBQOU==24			;Address of pointer to SYSERR queue
MMAPWD==25			;Address of pointer to MMAP page
SPTWD==237			;Address of pointer to SPT
MSECWD==240			;Address of pointer to MSECTB
SEBHED==3			;Number of header words in SYSERR block
ESYCNT==4			;Offset in SYSERR header for entry counter

;[7.1081] PG0PG must be first mapped page, ENDPG must be last page

PG0PG==30			;PAGE 0 OF DUMP.EXE
	PG0ADR=PG0PG_PGSFT
PG1PG==31			;[7.1081] Page 1 of DUMP.EXE
	PG1ADR=PG1PG_PGSFT	;[7.1081]
TMPPG==32			;[7.1081] 2 pages for temporary mapping
	TMPADR=TMPPG_PGSFT
MMPPG==34			;[7.1081] Page for mapping mmap page
	MMPADR=MMPPG_PGSFT
DMPPG==40			;PAGE FOR MAPPING DUMP FILE
	DMPADR==DMPPG_PGSFT
CPYPG==DMPPG+CPYPGS		;PAGE FOR MAPPING COPY FILE
	CPYADR==CPYPG_PGSFT
MAPPG==CPYPG+CPYPGS		;PAGE FOR BUILDING DUMP FILE MAP
	MAPADR=MAPPG_PGSFT
ESYPG==MAPPG+CPYPGS		;PAGE FOR MAPPING ERROR.SYS
	ESYSAD==ESYPG_PGSFT

ENDPG==ESYPG+CPYPGS		;[7.1081] Last page mapped is here

MSTRPG==700			;Page 700 is for building MSTR args
MSTRAD==700000			;Base address of MSTR page
MNTBLK==710000			;Where to build mount blocks within page
	SUBTTL Command Tables

;COMMAND TABLES:

;****************************************************************
;
;	WARNING!!!
;
;	THESE TABLES MUST BE KEPT IN ALPHABETICAL ORDER FOR TBLUK
;
;****************************************************************

;Main command table

LEV1TB:	LEV1TS-1,,LEV1TS-1
	T ALLOW,ALLOW
	T ARCHIVE-TAPE-RECYCLE-PERIOD,ARCHIV
	T BATCH-BACKGROUND,BATBGD
	T BATCH-CLASS,BCHCLS
	T BIAS,BIAS
	T CHANGE,CHANGE
	T CREATE,CREATE
	T DAYLIGHT,DAYLIG
	T DECNET,DECNET
	T DEFINE,DEFINE
	T DISABLE,DISABL
	T DONTCARE,DCARE
	T ENABLE,ENABLE
	T ETHERNET,ETHERN
	T EXIT,EXIT		;[7.1235]
	T HOST,HOST
	T LAT-STATE,LAT
	T MAGTAPE,MAGTAP
	T NODE,NODNAM
	T PRINTER,LPTLOD
	T RESTRICT,RESTRI
	T TAPE-RECOGNITION-ERRORS,TRECER
	T TAPE-RECYCLE-PERIOD,TAPRCY
	T TERMINAL,TERM
	T TIMEZONE,TIMZON
	LEV1TS==.-LEV1TB

;Commands allowed when a device comes online

ALTLVT:	ALTSIZ-1,,ALTSIZ-1
	T ALLOW,ALLOW
	T DONTCARE,DCARE
	T MAGTAPE,MAGTAP
	T RESTRICT,RESTRI
	ALTSIZ==.-ALTLVT

;Table of options for ENABLE commands

	MOREBT==1B0		;There is more of this commands (don't confirm)

ENAOPT:	ENASIZ-1,,ENASIZ-1
	T ACCOUNT-VALIDATION,[ENACCT]
	T CLASS-SCHEDULING,[MOREBT!ECSKED]
	T CLUSTER-INFORMATION,[ENACLU]	;[7.1076][7.1097]
	T CLUSTER-SENDALLS,[ENATMG]	;[7.1076][7.1097]
	T DIRECTORY-PARAMETER-SETTING,[ENADIR]
	T DUMP-ON-BUGCHK,[MOREBT!ENADOB] ;[7.1235]
	T FAST-LOGIN-OPTION,[ENAFST]
	T FULL-LATENCY-OPTIMIZATION,[ENAFLO]
	T HANGUP-IF-LOGGED-IN,[ENAHLI]
	T HANGUP-IF-LOGGED-OUT,[ENAHLO]
	T JOB0-CTY-OUTPUT,[J0OUTE]
	T LOGIN-STRUCTURE,[ENALGS] ;[7.1112]
	T MINIMUM-PASSWORD-LENGTH,[MOREBT!ENAMPL] ;[7.1231]
	T OFFLINE-STRUCTURES,[MOREBT!ENAOFS] ;[7.1063]
	T SYSTEM-MESSAGE-LEVEL-0,[ENALV0]
	T SYSTEM-MESSAGE-LEVEL-1,[ENALV1]
	T TAPE-DRIVE-ALLOCATION,[ENATDA]
	T WORKING-SET-PRELOADING,[ENAWSP]
	ENASIZ==.-ENAOPT

;Table of options for DISBLE commands

DISOPT:	DISSIZ-1,,DISSIZ-1
	T ACCOUNT-VALIDATION,[DISACT]
	T CLUSTER-INFORMATION,[DISCLU]	;[7.1076]
	T CLUSTER-SENDALLS,[DISTMG]	;[7.1076]
	T DIRECTORY-PARAMETER-SETTING,[DISDIR]
	T DUMP-ON-BUGCHK,[MOREBT!DISDOB] ;[7.1235]
	T FAST-LOGIN-OPTION,[DISFST]
	T FULL-LATENCY-OPTIMIZATION,[DISFLO]
	T HANGUP-IF-LOGGED-IN,[DISHLI]
	T HANGUP-IF-LOGGED-OUT,[DISHLO]
	T JOB0-CTY-OUTPUT,[J0OUTD]
	T LOGIN-STRUCTURE,[DISLGS] ;[7.1112]
	T MINIMUM-PASSWORD-LENGTH,[DISMPL] ;[7.1231]
	T OFFLINE-STRUCTURES,[DISOFS] ;[7.1063]
	T SYSTEM-MESSAGE-LEVEL-0,[DISLV0]
	T SYSTEM-MESSAGE-LEVEL-1,[DISLV1]
	T WORKING-SET-PRELOADING,[DISWSP]
	DISSIZ==.-DISOPT

;Table of disk drive types for ALLOW and RESTRICT commands

DSKTAB:	DSKTS-1,,DSKTS-1	;[7.1081] 
	T RP04,.MSRP4		;RP04
	T RP05,.MSRP5		;RP05
	T RP06,.MSRP6		;RP06
	T RP07,.MSRP7		;RP07
	T RP20,.MSR20		;RP20
	DSKTS==.-DSKTAB

;TABLE FOR TERMINAL CHARACTERISTICS

LEV2TB:	LEV2TS-1,,LEV2TS-1	;[7.1081] 
	T AUTO-BAUD,AUTO
	T IGNORE-SYSTEM-MESSAGES,IGNORE	;[64]
	T IGNORE-USER-MESSAGES,IGUMSG	;[64]
	T NOBELL,NOBELL
	T REMOTE,REMOTE
	T SPEED,SPEED
	LEV2TS==.-LEV2TB	;[7.1081] 

;Table of options for loading printers

LPTTAB:	LPTBSZ-1,,LPTBSZ-1
	T LOWERCASE, .MOSTS
	T RAM, .MOLTR
	T VFU, .MOLVF
	LPTBSZ==.-LPTTAB

;MAGTAPE command slave keywords

SLAVT:	SLVBSZ-1,,SLVBSZ-1
	T TU45,.MTT45		;TU45
	T TU70,.MTT70		;TU70
	T TU71,.MTT71
	T TU72,.MTT72		;TU72
	T TU73,.MTT73
	T TU77,.MTT77		;TU77
	T TU78,.MTT78		;TU78
	SLVBSZ==.-SLAVT

;TABLE OF DAYS OF WEEK FOR "CHANGE" COMMAND

DOWTAB:	XWD DOWTBZ-1,DOWTBZ-1
	T ALL,<<1B0!1B1!1B2!1B3!1B4!1B5!1B6>_-^D18>
	T FRIDAY,<<1B4>_-^D18>
	T MONDAY,<<1B0>_-^D18>
	T SATURDAY,<<1B5>_-^D18>
	T SUNDAY,<<1B6>_-^D18>
	T THURSDAY,<<1B3>_-^D18>
	T TUESDAY,<<1B1>_-^D18>
	T WEDNESDAY,<<1B2>_-^D18>
	T WEEKDAYS,<<1B0!1B1!1B2!1B3!1B4>_-^D18>
	T WEEKENDS,<<1B5!1B6>_-^D18>
	DOWTBZ=.-DOWTAB

;TABLE FOR TYPE OF CLASS SCHEDULING DESIRED

SKDOPT:	SKDSIZ-1,,SKDSIZ-1
	T ACCOUNTS,0
	T POLICY-PROGRAM,1
	SKDSIZ==.-SKDOPT

;TABLE FOR LAT-STATE ON AND OFF

LATSTA:	LATSIZ-1,,LATSIZ-1
	T OFF,LS.OFF
	T ON,LS.ON
	LATSIZ==.-LATSTA

;TABLE FOR DAYLIGHT SAVING TIME HANDLING

DSTOPT:	DSTSIZ-1,,DSTSIZ-1
	T AUTOMATIC,.DSTAU
	T OFF,.DSTNV
	T ON,.DSTAL
	DSTSIZ==.-DSTOPT

;TABLE FOR WINDFALL HANDLING

SKDOP0:	SKDSZ0-1,,SKDSZ0-1
	T ALLOCATED,0
	T WITHHELD,1
	SKDSZ0==.-SKDOP0

;Table for DECNET parameters

DCNTA0:	DCNSZ0-1,,DCNSZ0-1
	T BUFFER-SIZE,[.NDBSZ,,DCNNUM]
	T DEFAULT-BUFFERS-PER-LINK,[.NDDBL,,DCNNUM]
	T DEFAULT-FLOW-CONTROL,[.NDFLO,,NSPFLO]
	T MAXIMUM-ADDRESS,[.NDMXA,,DCNNUM]
	T MAXIMUM-BUFFERS,[.NDMXB,,DCNNUM]
	T ROUTER-ENDNODE,[.NDRTR,,ROUEND]
	T ROUTER-LEVEL-1,[.NDRTR,,ROULV1]
	DCNSZ0==.-DCNTA0

;Table for DECNET DEFAULT-FLOW-CONTROL

FLOTAB:	FLOSZ0-1,,FLOSZ0-1
	T NONE,[FCM.NO]
	T SEGMENT,[FCM.SG]
	FLOSZ0==.-FLOTAB

;[7.1235] Tables for ENABLE/DISABLE DUMP-ON-BUGCHK command

DOBTAB:	DOBTSZ-1,,DOBTSZ-1	;[7.1235] 
	T ALL-BUGCHKS,DOBABC	;[7.1235] 
	T ALL-BUGINFS,DOBABI	;[7.1235] 
	T BUG,DOBBUG		;[7.1235] 
	T FACILITY,DOBFAC	;[7.1235] 
	DOBTSZ==.-DOBTAB	;[7.1235] 

IGNTAB:	1,,1			;[7.1235] 
	T IGNORE-DUMP-TIMEOUT,0	;[7.1235] 
	SUBTTL Interrupt System Tables

;DEFINE INTERRUPT SYSTEM TABLES

PCLEV1:	BLOCK 1
PCLEV2:	BLOCK 1
.ICLPO==0			;CHANNEL FOR LINE PRINTER OFFLINE
.ICHNG==1			;CHANNEL FOR TIMER INTERRUPT
HNGTIM==<^D30*^D1000>		;SETSPD IS HUNG IF COMMAND TAKES >30 SECONDS
TIMENA:	BLOCK 1			;FLAG WORD TO SPECIFY IF TIMER PSI ENABLED
UMODF==1B5			;USER MODE FLAG
LEVTAB:	PCLEV1
	PCLEV2
	0

CHNTAB:	XWD 1,LPTINT		;.ICLPO CHANNEL
	XWD 2,HUNG		;.ICHNG CHANNEL
	BLOCK ^D34
	SUBTTL Error Macros

;[7.1081] ERROR macro prints error message.  First argument is text of error.
;The optional second argument is instructions to execute (should include a JRST
;or RET or something).  If the second argument is blank, returns +1.

DEFINE ERROR ($TEXT,$INST)<
IFB <$INST>,<
	CALL [	JSP T1,ERROR1
		ASCIZ/$TEXT/]		;;[7.1198]
> ;End of IFB <$INST>
IFNB <$INST>,<
	JRST [	HRROI T1,[ASCIZ/$TEXT/]	;;[7.1198]
		CALL ERROR1
		$INST]
>;end of IFNB <$INST>
>;end of DEFINE ERROR

;[7.1081] Macro to use after a JSYS to give an error message.  First argument
;is text of error, optional second argument is instruction(s) to execute after
;the error is printed (should include a JRST or RET or something).  If the
;second argument is blank, returns +1.

DEFINE JSYERR ($TEXT,$INST) <
IFB <$INST>,<
	ERCAL [	JSP T1,JSYER1
		ASCIZ \$TEXT\]
>;end of IFB <$INST>
IFNB <$INST>,<
	ERJMP [	HRROI T1,[ASCIZ\$TEXT\]
		CALL JSYER1
		$INST ]
>;end of IFNB <$INST>
>;end of DEFINE JSYERR
	SUBTTL Build Config File Name and Prompt

;[7.1235] Define the filename we use

	DEFINE BCONFIG (MAJ,MIN)  <
	IFE VMINOR,<ASCIZ /SYSTEM:'MAJ'-CONFIG.CMD/>
	IFG VMINOR,<ASCIZ /SYSTEM:'MAJ'-'MIN'-CONFIG.CMD/>
>;End of BCONFIG

RCONFG:	BCONFIG (\VMAJOR,\VMINOR)

;[7.1235] Define the prompt we will use whn processing commands interactively

	DEFINE BCONFIG (MAJ,MIN)  <
	IFE VMINOR,<ASCIZ /'MAJ'-SETSPD$/>
	IFG VMINOR,<ASCIZ /'MAJ'-'MIN'-SETSPD$/>
>;End of BCONFIG

CPROMP:	BCONFIG (\VMAJOR,\VMINOR)

;[7.1235] Define the prompt for yes/no question when running interactively

	DEFINE BCONFIG (MAJ,MIN)  <
	IFE VMINOR,<ASCIZ /Process 'MAJ'-SETSPD.CMD (Y or N)? />
	IFG VMINOR,<ASCIZ /Process 'MAJ'-'MIN'-SETSPD.CMD (Y or N)? />
>;End of BCONFIG

SPROMP:	BCONFIG (\VMAJOR,\VMINOR)
	SUBTTL Initialization -- Entry Points For Reading x-CONFIG.CMD File

;ENTRY POINTS FOR READING CONFIG.CMD FILE

START0: TDZA T1,T1		;[7.1235] 
START1:	SETO T1,		;[7.1235][7.1081] We are system starting up
	JRST START		;[7.1235] Continue with normal entry

START4:	SETO T1,		;[7.1235] We are system starting up
	TDZA P5,P5		;[7.1235] Indicate MTA online entry
START:	SETOM P5		;[7.1235] Indicate normal entry

;[7.1235] Startup flags are now all set:
;	P5/ -1 for normal commands, 0 for magtape
;	T1/ -1 running from monitor entry point, 0 for user running SETSPD

	MOVEM T1,SYSTUP		;[7.1235] Set startup flag
	MOVE P,[IOWD PDLEN,PDL]	;SET UP PUSH DOWN LIST
	CALL INIT		;SET UP PSI, CAPABILITIES, ETC.
	CALL FREINI		;INITIALIZE FREE SPACE
	CALL CMDINI		;INITIALIZE FOR COMND JSYS
				;[7.1235] Fall through

	SUBTTL Initialization -- Determine If Interactive Session

;[7.1235] If running interactively, ask if we should process command file.

	SKIPE SYSTUP		;[7.1235] Interactive mode?
	JRST CFILE		;[7.1235] Nope, process the config file
	GJINF%			;[7.1239] Get job information please
	JUMPE T3,CFILE		;[7.1239] Jump if running on job zero
STARTQ:	HRROI T1,SPROMP		;[7.1235] Point to prompt
	PSOUT			;[7.1235] Output that for the user
	HRROI T1,T4		;[7.1235] Command string to this scratch place
	MOVX T2,RD%BEL!RD%RAI!5 ;[7.1235] Break on CR, space for YES<CRLF>
	HRROI T3,SPROMP		;[7.1235] Control R buffer
	RDTTY			;[7.1235] Read from terminal
	 ERJMP CMND0		;[7.1235] If error, enter interactive mode
	LDB T1,[POINT 7,T4,6]	;[7.1235] Load first character
	CAIE T1,.CHCRT		;[7.1235] Is it a return or
	CAIN T1,"N"		;[7.1235]  is it a N?
	JRST CMND0		;[7.1235] Yes, run from terminal
	CAIN T1,"Y"		;[7.1235] Process the command file?
	JRST CFILE		;[7.1235] Start processing commmand file
	TMSG <
? Please answer Y or N
>				;[7.1235] Tell him the error
	MOVEI T1,.PRIIN		;[7.1235] Load primary terminal designator
	CFIBF			;[7.1235] Clear the input buffer
	JRST STARTQ		;[7.1235] The fat fingered get reprompted
	SUBTTL Initialization -- Find SYSTEM:x-CONFIG.CMD

;[7.1235] Here if not running interactive, find the SYSTEM:x-CONFIG.CMD
;command file, open it up for reading, and store the JFN in the CSB.

CFILE:	SETOM SYSTUP		;[7.1235] Insure we are set as system startup
	MOVX A,GJ%SHT!GJ%OLD!GJ%PHY ;[7.1235] Load old, physical, short form 
	HRROI B,RCONFG		;SYSTEM:X-CONFIG.CMD
	GTJFN			;FIND THE FILE
	 JRST FINISH		;NOT THERE. GO DEFAULT EVERYTHING
	MOVEM A,JFN		;REMEMBER THE JFN
	MOVX B,FLD(7,OF%BSZ)!OF%RD ;[7.1081] 7 bit bytes, read only
	OPENF%			;[7.1081] Get it
	 JSYERR (<Can't open configuration file>,<JRST FINISH>)	;[7.1081] Ouch
	HRL A,JFN		;GET JFN
	HRRI A,.NULIO		;[7.1081] Don't let COMND try to prompt
	MOVEM A,.CMIOJ+SBK	;TELL COMND TO READ FROM FILE
	SUBTTL Initialization -- Top Level Command Parser

;This is the top of the main command reading loop.

CMND0:	MOVEI A,CMND0		;IF HUNG, CONTINUE AT CMND0
	MOVEM A,HNGCON		;SAVE IT
	MOVEM P,HNGSTK		;SAVE THE STACK
	CALL SETTIM		;SET THE TIME AT WHICH WE WILL BE HUNG
	SKIPN SYSTUP		;[7.1235] Are we running from a file?
	SKIPA A,[POINT 7,CPROMP] ;[7.1235] Yes, point to the prompt
	HRROI A,[0]		;NO PROMPT WHEN READING FROM FILE
	CALL DPROMP		;INITIALIZE COMMAND LINE
	SKIPN P5		;CHECK FOR MAGTAPE ENTRY
	SKIPA A,[[FLDDB. .CMKEY,,ALTLVT]]	;ALTERNATE TABLE
	MOVEI A,[FLDDB. .CMKEY,,LEV1TB]	;THE TABLE
	CALL RFLDE		;[7.1081] (A/A,B) Read keyword
	IFSKP.			;[7.1081] If it worked
	  MOVE B,(B)		;[7.1081] Get table word
	  AOS NCMDS		;[7.1081] Increment number of commands seen
	  CALL (B)		;[7.1081] Execute the command
	  JRST CMND0		;[7.1081] Do rest of commands
	ENDIF.			;[7.1081] Otherwise, there was a problem
	CALL GETERR		;[7.1081] (/T2) Failed, see why
	CAIN T2,IOX4		;[7.1081] End of file?
	JRST FINISH		;[7.1081] Yes, finish up
	CAIN T2,NPXNOM		;[7.1081] Invalid switch or keyword?
	JUMPE P5,CMND0		;[7.1081] Yes, if doing magtapes ignore error
	JRST CMDERR		;[7.1081] No so complain and continue
	SUBTTL Initialization -- Capabilities and Interrupt System

; INIT - RESET PROCESS, SET UP SOFTWARE INTERRUPT SYSTEM,
;	 ENABLE CAPABILITIES
; RETURNS +1: ALWAYS

INIT:	RESET			;GET TO A KNOWN STATE
	MOVEI A,.FHSLF		;GET OWN ID
	RPCAP			;READ CAPABILITES
	MOVE C,B
	EPCAP			;ENABLE ALL CAPABILITIES
	MOVE B,[LEVTAB,,CHNTAB]
	SIR			;SET INTERRUPT TABLE ADDRESSES
	EIR			;TURN ON INTERRUPT SYSTEM
	SKIPN SYSTUP		;[7.1235] System startup?
	SKIPA B,[1B<.ICLPO>]	;[7.1235] No, just get line printer channel
	MOVX B,1B<.ICLPO>!1B<.ICHNG>  ;ACTIVATE LINE PRINTER OFFLINE
	AIC			;AND TIMER EXPIRED CHANNELS
	SETOM TIMENA		;SAY TIMER PSI ENABLED
	SETZM NCMDS		;INITIALIZE COMMAND COUNTER
	RET
	SUBTTL Commands -- Hung Command Timeout

; SETTIM - ROUTINE TO SET TIME AT WHICH THE COMMAND IS DETERMINED HUNG
; Returns +1:  ALWAYS

SETTIM:	SKIPN TIMENA		;IS TIMER PSI ENABLED?
	 RET			;NO, JUST RETURN
	MOVE T1,[.FHSLF,,.TIMAL];REMOVE ALL TIME LIMITS
	TIMER
	 ERJMP TIMERR		;ERROR, GIVE MESSAGE AND RETURN
	MOVEI T2,HNGTIM		;GET TIME LIMIT OF COMMAND
	MOVEI T3,.ICHNG		;SPECIFY HUNG PSI CHANNEL
	MOVE T1,[.FHSLF,,.TIMEL];ELAPSED TIME FUNCTION
	TIMER
	 ERJMP TIMERR		;ERROR, GIVE MESSAGE AND RETURN
	RET

TIMERR:	HRROI T1,[ASCIZ/TIMER JSYS failed - PSI System for Hung SETSPD disabled/]
	CALL JSYER1		;[7.1081] (T1/) Output that and last error
	MOVEI T1,.FHSLF		;GET PROCESS HANDLE
	MOVE T2,[1B<.ICHNG>]	;CHANNEL FOR TIMER JSYS
	DIC			;DEACTIVATE THIS CHANNEL
	SETZM TIMENA		;SAY PSI DISABLED FOR TIMER JSYS
	RET			;AND RETURN
	SUBTTL Commands -- TERMINAL

;COMMAND LEVEL ACTION ROUTINES.

;FIRST TERMINAL

TERM:	TRVAR <<DEFBLK,1+.CMDEF>,<DEFOUT,3>>
	MOVEI A,[FLDDB. .CMNUX,CM%SDH,8,<terminal line number>]
	CALL RFIELD		;GET LINE NUMBER, CMNUMX ALLOWS HYPHEN AFTER NUMBER
	HRLZM B,LINES		;SAVE LINE NUMBER
	MOVEI A,[FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ /-/]>,<hyphen (-) if specifying range>]
	CALL RFLDE		;SEE IF HYPHEN
	 CAIA			;NO HYPHEN
	JRST GTRNGE		;YES. GET RANGE
	HLRS LINES		;EXTEND LINE NUMBER
	JRST LINKEY		;GO GET THE KEY

GTRNGE:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,8,<terminal line number>]
	CALL RFIELD		;READ END OF RANGE
	HRRM B,LINES		;STASH LAST LINE NUMBER
	; ..

;NOW READ OUT THE KEY WORD

LINKEY:	SETZB P1,P2		;CLEAR FLAGS
	MOVEI A,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMKEY,,LEV2TB]]
	CALL RFIELD		;GET CONFIRMATION OR KEYWORD
	LOAD D,CM%FNC,.CMFNP(C)
	CAIN D,.CMCFM		;END OF LINE YET?
	RET			;YES, DONE
	MOVE B,(B)		;NO, GET TABLE ENTRY
	JRST (B)		;DO FUNCTION, RETURNS TO LINKEY

;IF HERE, LINES ARE REMOTE

AUTO:	TXOA P2,MO%AUT		;SET THE AUTO BUAD BIT
REMOTE:	TXO P2,MO%RMT		;SET THE REMOTE BIT
	HRRZ A,LINES		;GET FIRST LINE
	HLRZ B,LINES		;GET LAST LINE
	SUBI B,1(A)		;GET # TO DO
	HRLI A,0(B)		;AN AOBJN WORD
	HLR A,LINES		;FIRST LINE AGAIN
DOLINE:	SKIPN P1		;SETTING SPEED?
	IORM P2,REMTBL(A)	;SAY IT IS REMOTE
	SKIPE P1		;SETTING REMOTE?
	MOVEM P1,SPDTBL(A)	;NO. SET SPEED
	SKIPN SPDTBL(A)		;HAVE A SPEED YET?
	JRST REMOT1		;NO
	PUSH P,A		;SAVE LINES
	CALL SPDSET		;GO SET THE SPEED
	POP P,A			;RESTORE AOBJN WORD
REMOT1:	AOBJN A,DOLINE		;GO DO ALL OF THEM
	JRST LINKEY		;GO BACK FOR MORE ATTRIBUTES OF THIS SET OF TERMINALS
; HERE TO SET THE "IGNORE INPUT" (NO BELLS) BIT

NOBELL:	HRRZ D,LINES		;GET LAST LINE NUMBER
	HLRZ B,LINES		;GET FIRST LINE NUMBER
	SUBI B,1(D)		;FORM - NUMBER IN RANGE
	HRLI D,(B)		;FORM AN AOBJN POINTER TO LOOP
	HLR D,LINES		; OVER ALL THE LINES IN THE RANGE

NOBEL1:	MOVEI A,.TTDES(D)	;[63] Get line designator
	MOVX B,.MOSIG		;SET "IGNORE INPUT" BIT
	MOVX C,1		;TURN THE BIT ON
	MTOPR			;SET THE LINE TO IGNORE CHARACTERS UNTIL OPENED
	 ERJMP .+1		;IGNORE FAILURE HERE
	AOBJN D,NOBEL1		;LOOP OVER ALL THE LINES IN THE INDICATED RANGE
	JRST LINKEY		;GO GET THE NEXT KEYWORD IN THE COMMAND

;Ignore system messages for terminal lines

IGNORE:	HRRZ D,LINES		;[64] Get last line number
	HLRZ B,LINES		;[64] Get first line number
	SUBI B,1(D)		;[64] Form - number in range
	HRLI D,(B)		;[64] Make AOBJN pointer for loop
	HLR D,LINES		;[64] Do all lines in range
IGNOR1:	MOVEI A,.TTDES(D)	;[64] Get line designator
	MOVX B,.MOSNT		;[64] Ignore system messages function
	MOVX C,.MOSMN		;[64] Tell line to refuse system messages
	MTOPR%			;[64] Do it
	 ERJMP .+1		;[64] Don't care about failure
	AOBJN D,IGNOR1		;[64] Do all lines when there is a range
	JRST LINKEY		;[64] Go get next keyword in command

;Ignore user messages for terminal lines

IGUMSG:	HRRZ D,LINES		;[64] Get last line number
	HLRZ B,LINES		;[64] Get first line number
	SUBI B,1(D)		;[64] Form - number in range
	HRLI D,(B)		;[64] Make AOBJN pointer for loop
	HLR D,LINES		;[64] Do all lines in range
IGUMS1:	MOVEI A,.TTDES(D)	;[64] Get line designator
	MOVX B,.MOSTF		;[64] Ignore user messages function
	MOVX C,<MO%NUM!MO%NTM>	;[64] Make line ignore all SENDs
	MTOPR%			;[64] Do it
	 ERJMP .+1		;[64] Don't care about failure
	AOBJN D,IGUMS1		;[64] Do all lines when there is a range
	JRST LINKEY		;[64] Go get next keyword in command

;SET LINE SPEEDS

SPEED:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<input speed>]
	CALL RFIELD		;READ THE INPUT SPEED
	HRLI P1,.TTDES(B)	;[63] In case no more
	HRROI A,DEFOUT		;POINT TO BUFFER FOR DEFAULT OUTPUT SPEED
	MOVEM A,.CMDEF+DEFBLK	;STORE POINTER TO DEFAULT OUTPUT SPEED
	MOVEI C,5+5		;CREATE DEFAULT IN DECIMAL
	NOUT			;CREATE IT
	 JSHLT			;SHOULDN'T EVER FAIL
	HRLI A,[FLDDB. .CMNUM,CM%DPP!CM%SDH,5+5,<output speed>]
	HRRI A,DEFBLK		;MAKE BLT POINTER
	BLT A,.CMDEF-1+DEFBLK	;PUT WRITABLE COMND FUNCTION BLOCK
	MOVEI A,DEFBLK		;POINT AT THE CREATED BLOCK
	CALL RFIELD		;READ OUTPUT SPEED, DEFAULT TO INPUT
	HRRI P1,0(B)		;SAVE OUTPUT SPEED
	JRST REMOTE		;GO SET SPEEDS

;ROUTINE TO SET SPEED OF A LINE.
;INPUT IS :	A/ LINE NUMBER

SPDSET:	MOVEI A,0(A)		;CLEAN UP ARG
	SKIPN SYSTUP		;[7.1235] System startup 
	SKIPE REMTBL(A)		;[7.1235]  or remote line?
	JRST SPDST1		;YES. ALWAYS USE FILE SETTING
	MOVEI A,.TTDES(A)	;[63] Get TTY designator
	MOVEI B,.MORSP		;GET SPEED FROM MONITOR
	MTOPR			;GET IT
	ERJMP REMOT2		;?
	TRZ A,.TTDES		;[63]
	SKIPG C			;GET IT?
SPDST1:	MOVE C,SPDTBL(A)	;NO. USE FILE'S VALUE
	TLZ C,(1B0)		;GET RID OF SIGN BIT
	MOVEI B,.MOSPD		;SPEED SETTING
	IOR B,REMTBL(A)		;ADD IN THE REMOTE AND AUTO BITS (IF ANY)
	TRO A,.TTDES		;[63] TTY designator
	MTOPR			;DO IT
	 ERJMP REMOT2		;IGNORE ERROR
	MOVEI B,.MORNT		;REQ MSG SUPPRESS STATUS FROM
	MTOPR			;MONITOR FOR TTY (A/ TTY#)
	 ERJMP REMOT2		;IGNORE ERROR
	MOVEI B,.MOSNT		;SET MSG SUPPRESS BIT FOR TTY
	MTOPR			;SAME AS BEFORE
	 ERJMP REMOT2		;IGNORE ERROR
REMOT2:	RET			;ALL DONE

;ROUTINE TO APPLY DEFAULT SPEEDS AT EOF

FINISH:	JUMPE P5,QUIT		;QUIT IF MTA ONLINE
	MOVE A,[SIXBIT /TTYJOB/] ;FIRST FIND # OF TTY'S
	SYSGT			;GET IT
	HLLZ P3,B		;MAKE AOBJN POINTER
FIN1:	SKIPE SPDTBL(P3)	;THIS ONE SET YET?
	JRST FIN2		;YES. GO ON
	MOVEI A,0(P3)		;NO. GET LINE #
	MOVE B,[^D300,,^D300]	;DEFAULT SPEED
	MOVEM B,SPDTBL(A)	;STORE IT
	CALL SPDSET		;GO SET THE SPEED
FIN2:	AOBJN P3,FIN1		;DO ALL LINES
;;	CALL REFILL		;GO LOAD THE CACHE REFILL ALGORITHM

QUIT:	HALTF%			;[7.1081] All done
	JRST .-1		;[7.1081] Disallow continue
	SUBTTL Commands -- RESTRICT and ALLOW

;THIS CODE ALLOWS AND RESTRICTS MSCP SERVER ACCESS TO DISK DRIVES
;FORMAT OF A COMMAND LINE IS:
;	ALLOW/RESTRICT "DRIVE TYPE" "LOW SERIAL #" or
;	ALLOW/RESTRICT "DRIVE TYPE" "HIGH SERIAL #" "LOW SERIAL #"
;
RESTRI: SKIPA T1,[SV%DDU]
ALLOW:	SETZ T1,
	MOVEM T1,SMONBK+.SVTYP	;SAVE FLAGS FOR NOW
	MOVEI T1,.SVDSN+1	;LENGTH
	MOVEM T1,SMONBK+.SVCNT	;SAVE IT
	MOVEI T1,[FLDDB. .CMKEY,,DSKTAB] ;PARSE THE DRIVE TYPE
	CALL RFIELD
	HRRZ T2,(T2)		;GET TABLE ENTRY
	IORM T2,SMONBK+.SVTYP	;SAVE IT WITH FLAGS
	IORI T2,400		;ASSUME NO HIGH ORDER WORD WILL BE GIVEN
	LSH T2,20		; SO CONSTRUCT IT
	MOVEM T2,SMONBK+.SVDSH	;AND SAVE IT
	MOVEI T1,[FLDDB. .CMNUM,,^D10] ;GET THE SERIAL NUMBER
	CALL RFIELD
	MOVEM T2,SMONBK+.SVDSN	;SAVE IT AS LOW ORDER
	MOVEI T1,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMNUM,,^D10]]
	CALL RFIELD		;GET CONFIRMATION OR KEYWORD
	LOAD T4,CM%FNC,.CMFNP(T3)
	CAIE T4,.CMCFM		;END OF LINE YET?
	JRST [EXCH T2,SMONBK+.SVDSN ;NO, THIS IS LOW ORDER NUMBER
	      MOVEM T2,SMONBK+.SVDSH ;AND THE OTHER WAS THE HIGH ORDER
	      CONFRM		;NOW PARSE AN EOL
	      JRST .+1]		;AND CONTINUE
	MOVEI T1,.SFMSD		;GET FUNCTION
	MOVEI T2,SMONBK		;ADDRESS OF BLOCK
	SMON			;DO IT
	 ERJMP ALLOWE		;[7.1081] Owie
	RET			;[7.1081] Return

ALLOWE:	HRROI T1,[ASCIZ/Unable to allow MSCP access to disk drive, serial number /]
	MOVE T2,SMONBK+.SVTYP	;[7.1081] Get flags word
	TXNE T2,SV%DDU		;[7.1081] Was it restrict?
	HRROI T1,[ASCIZ/Unable to restrict MSCP access to disk drive, serial number /]
	CALL ERRBEG		;[7.1081] (T1/) Print error
	MOVE T2,SMONBK+.SVDSH	;[7.1081] High order serial number
	MOVEI T1,.PRIOU		;[7.1081] To CTY
	MOVEI T3,^D10		;[7.1081] In decimal
	NOUT%			;[7.1081] Print high order number
	 ERJMP .+1		;[7.1081] Ignore errors
	MOVEI T2," "		;[7.1081] Space
	BOUT%			;[7.1081] Output that
	 ERJMP .+1		;[7.1081] Ignore errors
	MOVE T2,SMONBK+.SVDSN	;[7.1081] Low order serial number
	NOUT%			;[7.1081] Output the number
	 ERJMP .+1		;[7.1081] Ignore errors
	TMSG < - >		;[7.1081] Now why
	CALL LSTERR		;[7.1081] Output last error code
	JRST STARS		;[7.1081] Output stars and return
	SUBTTL Commands -- DONTCARE

;DONTCARE SMON JSYS CODE

DCARE:	MOVEI T1,[FLDDB. .CMNUM,,^D10] ;GET THE CHANNEL NUMBER
	CALL RFIELD
	MOVEM T2,SMONBK
	MOVEI T1,[FLDDB. .CMNUM,,^D10] ;GET CONTROLLER NUMBER
	CALL RFIELD
	MOVEM T2,SMONBK+1
	MOVEI T1,[FLDDB. .CMNUM,,^D10] ;GET UNIT NUMBER
	CALL RFIELD
	MOVEM T2,SMONBK+2
	MOVEI T1,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMNUM,,^D10]]
	CALL RFIELD		;GET CONFIRMATION OR KEYWORD
	LOAD T4,CM%FNC,.CMFNP(T3)
	CAIE T4,.CMCFM		;END OF LINE YET?
	CONFRM			;[7.1081] Now parse an EOL
	MOVEI T1,.SFDCD		;GET FUNCTION
	MOVEI T2,SMONBK		;ADDRESS OF BLOCK
	MOVE T4,SMONBK		;PICK UP CHANNEL
	STOR T4,.SDF%C,T3	;STOR CHANNEL
	MOVE T4,SMONBK+1	;PICK UP CONTROLLER
	STOR T4,.SDF%K,T3
	MOVE T4,SMONBK+2	;PICK UP UNIT
	STOR T4,.SDF%U,T3
	SMON			;DO IT
	 ERJMP DCAREE		;[7.1081] Owie
	RET

DCAREE:	HRROI T1,[ASCIZ\Unable to allow don't care access to disk drive, channel/controller/unit \] ;[7.1081] 
	CALL ERRBEG		;[7.1081] (T1/) Output the meat
	MOVE T2,SMONBK		;[7.1081] Channel number
	MOVEI T1,.PRIOU		;[7.1081] To CTY
	MOVEI T3,^D10		;[7.1081] In decimal
	NOUT%			;[7.1081] Print channel
	 ERJMP .+1		;[7.1081] Ignore errors
	MOVEI T2," "		;[7.1081] Load a space 
	BOUT%			;[7.1081] Output that
	 ERJMP .+1		;[7.1081] Ignore errors
	MOVE T2,SMONBK+1	;[7.1081] Controller
	NOUT%			;[7.1081]  number
	 ERJMP .+1		;[7.1081] Ignore errors
	MOVEI T2," "		;[7.1081] Load another space
	BOUT%			;[7.1081] Output a space
	 ERJMP .+1		;[7.1081] Ignore errors
	MOVE T2,SMONBK+2	;[7.1081] Unit 
	NOUT%			;[7.1081]  number
	 ERJMP .+1		;[7.1081] Ignore errors
	TMSG < - >		;[7.1081] Output why next
	CALL LSTERR		;[7.1081] () Output last error
	JRST STARS		;[7.1081] Output stars and return
	SUBTTL Commands -- MAGTAPE

;THIS CODE PROCESSES THE MAGTAPE CONFIGURATION COMMANDS. FORMAT
;OF A COMMAND LINE IS:
;	MAGTAPE "LUN" "SERIAL#" "SLAVE TYPE"

MAGTAP:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<unit number>]
	CALL RFIELD
	MOVE P1,B		;SAVE LUN
	MOVE D,P1		;RESOTRE LUN
	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<serial number>]
	CALL RFIELD
	HRRZ P2,B		;SAVE SERIAL NUMBER
	MOVEI A,[FLDDB. .CMKEY,,SLAVT,<slave type,>]
	CALL CFIELD		;GET SLAVE TYPE AND CONFIRMATION
	HRL P1,(B)		;SAVE SLAVE TYPE IN LEFT HALF OF P1
	MOVE A,P1		;SET LUN
	MOVE B,P2		;SET SERIAL #
	MTALN			;DO IT
	 ERJMP MAGTAE		;[7.1081] Jump if owie
	RET

MAGTAE:	JUMPE P5,CMDER1		;[7.1081] No message if MTA online
	HRROI T1,[ASCIZ/Could not set MTA /] ;[7.1081] 
	CALL ERRBEG		;[7.1081] (T1/) Output with a question mark
	MOVEI A,.PRIOU		;[7.1081] To the CTY
	EXCH B,D		;Get MTA, save serial #
	MOVEI C,10		;[7.1081] In octal
	NOUT%			;[7.1081] Do it
	 ERJMP .+1		;[7.1081] If this fails we are in deep sneakers
	HRROI A,[ASCIZ / serial # /] ;[7.1081] Load the next tag
	PSOUT			;[7.1081] Output that
	MOVEI A,.PRIOU		;[7.1081] Output back to the CTY
	MOVE B,D		;[7.1081] Load the serial number
	MOVEI C,12		;[7.1081] Decimal radix
	NOUT%			;[7.1081]  serial # as well
	 ERJMP .+1		;[7.1081] If this fails we are in deep sneakers
	JRST STARS		;[7.1081] Output stars and return
	SUBTTL Commands -- TAPE-RECOGNITION-ERRORS

; TAPE-RECOGNITION-ERRORS COMMAND

TRECER:	MOVEI T1,[FLDDB. .CMKEY,,TRETB] ;GET FDB ADDRESS
	CALL CFIELD		;GET KEYWORD AND CONFIRMATION
	HRRZ T4,(T2)		;GET BIT SETTING
	MOVEI T1,.SFTDF		;GET TMON FUNCTION CODE
	TMON			;GET CURRENT MOUNTR CONTROLS
	STOR T4,MT%UUT,T2	;SET OR CLEAR UNLOAD-UNREADABLE-TAPES
	SMON			;RESTORE CONTROL WORD
	RET

; KEYWORD TABLE FOR TAPE-RECOGNITION-ERRORS

TRETB:	TRETBL,,TRETBL
	T REGARD-AS-UNLABELED,0
	T UNLOAD,1
TRETBL==.-TRETB-1
	SUBTTL Commands -- ENABLE and DISABLE 

; ENABLE COMMAND

DISABL:	MOVEI A,[FLDDB. .CMKEY,,DISOPT]
	JRST ENA1

ENABLE:	MOVEI A,[FLDDB. .CMKEY,,ENAOPT]
ENA1:	CALL RFIELD		;GET OPTION
	MOVE A,(B)		;TABLE WORD
	MOVE A,(A)		;GET CONTROL BITS AND DISPATCH ADDRESS
	TXZN A,MOREBT		;IS THERE MORE OF THIS COMMAND?
	CONFRM			;NO, SO CONFIRM NOW
	CALLRET (A)		;GO PERFORM INDICATED FUNCTION

;[7.1231] Here to enable or disable min password length

ENAMPL:	STKVAR <MINLEN>		;Safe place for now
	MOVEI T1,[FLDDB. .CMNUX,CM%SDH,^D10,<minimum password length>,]
	CALL RFIELD		;Parse the length
	MOVEM T2,MINLEN		;Save this
	CONFRM			;Now confirm the command
	SKIPA T2,MINLEN		;Get length back
DISMPL:	SETZ T2,		;Disable this function
	MOVEI T1,.SFMPL		;Set minimum password length
	SMON%			;Do it
	 JSYERR (<Failed to set minimum password length>) ;[7.1249]
	RET			;Done
	ENDSV.			;[7.1249] Done with that STKVAR

;[7.1076] Here to enable or disable cluster information

DISCLU:	TDZA T2,T2		;Disable cluster info stuff
ENACLU:	MOVEI T2,1		;Enable cluster info stuff
	MOVEI T1,.SFCLU		;Get function code for SMON%
	SMON%			;Do it
	 ERJMP CLUERR		;Report error
	RET			;Return

CLUERR:	HRROI T1,[ASCIZ/Failed to enable cluster information/] ;[7.1081] 
	SKIPE T2		;[7.1081] Enabling?
	HRROI T1,[ASCIZ/Failed to enable cluster information/] ;[7.1081] No
	CALLRET JSYER1		;[7.1081] Output text and return

;[7.1076] Here to enable or disable cluster sendalls

DISTMG:	TDZA T2,T2		;Disable cluster sendalls
ENATMG:	MOVEI T2,1		;Enable cluster sendalls
	MOVEI T1,.SFTMG		;Get function code for SMON%
	SMON%			;Do it
	 ERJMP TMGERR		;Report error
	RET			;Return

TMGERR:	HRROI T1,[ASCIZ/Failed to enable cluster sendalls/] ;[7.1081] 
	SKIPE T2		;[7.1081] Enabling?
	HRROI T1,[ASCIZ/Failed to disable cluster sendalls/] ;[7.1081] No
	CALLRET JSYER1		;[7.1081] Output text and return

; HERE TO PERMIT CHANGING DIRECTORY PARAMETERS

DISDIR:	TDZA B,B		;TURN OFF THE PARAMETER
ENADIR:	MOVEI B,1		;TURN ON THE OPTION
	MOVEI A,.SFCRD		;GET FUNCTION CODE
	SMON			;TELL THE MONITOR
	RET			;RETURN

; HERE TO ENABLE ACCOUNT VALIDATION

DISACT:	TDZA B,B		;TURN OFF ACCOUNT VALIDATION
ENACCT:	MOVEI B,1		;TURN ON ACCOUNT VALIDATION
	MOVEI A,.SFAVR		;GET THE FUNCTION CODE
	SMON			;TELL THE MONITOR
	RET			;RETURN

; HERE TO ENABLE/DISABLE FULL LATENCY OPTIMIZATION

DISFLO:	TDZA B,B		;TURN OFF FULL LATENCY OPTIMIZATION
ENAFLO:	MOVEI B,1		;TURN ON FULL LATENCY OPTIMIZATION
	MOVEI A,.SFFLO		;GET THE SMON FUNCTION CODE
	SMON			;SET THE DESIRED STATE
	RET			;AND RETURN

;Here to disable CTY output of system error messages

J0OUTD:	TDZA B,B		;FOR THE DISABLE
J0OUTE:	MOVEI B,1		;FOR THE ENABLE
	MOVEI A,.SFBGS		;THE BIT TO DO
	SMON			;DO IT
	RET			;AND DONE

; HERE TO ENABLE TAPE-DRIVE-ALLOCATION

ENATDA:	MOVEI B,1		;TURN ON TAPE DRIVE ALLOCATION
	MOVEI A,.SFMTA		;GET SMON SUNCTION CODE
	SMON
	RET

; HERE TO ENABLE/DISABLE WORKING SET PRELOADING

DISWSP:	TDZA B,B
ENAWSP:	MOVEI B,1
	MOVEI A,.SFWSP
	SMON
	RET

; HERE TO DISABLE FAST LOGIN OPTION FOR THE EXEC

DISFST:	MOVEI A,.SFXEC		;GET EXEC FLAGS WORD
	TMON
	TXO B,XC%FST		;DON'T ALLOW FAST LOGINS
	SMON
	RET

; HERE TO ENABLE FAST LOGIN OPTION FOR THE EXEC

ENAFST:	MOVEI A,.SFXEC		;GET EXEC FLAGS WORD
	TMON
	TXZ B,XC%FST		;ALLOW FAST LOGINS
	SMON
	RET

; HERE TO ENABLE/DISABLE HANGUP IF NOT LOGGED IN

DISHLO: TDZA B,B
ENAHLO:	MOVEI B,1
	MOVEI A,.SFHU0
	SMON
	RET

; HERE TO ENABLE/DISABLE HANGUP IF LOGGED IN

DISHLI: TDZA B,B
ENAHLI:	MOVEI B,1
	MOVEI A,.SFHU1
	SMON
	RET

; [7.1112]
; ENALGS/DISLGS
;
; Here to ENABLE/DISABLE the Login Structure feature
; CALL:
;	CALL ENALGS
;	  or
;	CALL DISLGS
; Returns:
;	+1: Always
DISLGS:	TDZA B,B		;0 to disable
ENALGS:	SETO B,			;-1 to enable
	MOVEI A,.SFLGS		;Get the function code
	SMON%			;Do the SMON%
	 JSYERR (<Unable to set Login Structure>)
	RET			;Done

;[7.1063]
; HERE TO ENABLE/DISABLE OFFLINE STRUCTURES

; ENAOFS - Enable offline structures
;
ENAOFS:	STKVAR <MINUTE,SECOND>	;Reserve some storage
	MOVEI A,[FLDDB. .CMNUX,CM%SDH,^D10,<timeout interval>,]
	CALL RFIELD		;Parse the minutes
	MOVEM B,MINUTE		;Save the minutes
	MOVEI A,[FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ/:/]>,<timeout interval>,<:>]
	CALL RFIELD		;Parse the colon
	MOVEI A,[FLDDB. .CMNUX,CM%SDH,^D10,<timeout interval>,]
	CALL RFIELD		;Parse the seconds
	MOVEM B,SECOND		;Save the seconds
	CONFRM			;Confirm the command
	SKIPL A,MINUTE		;Get the minutes given
	CAIL A,^D60		;And range check it
	JRST BADTIM		;Must be >= 0 and < 60
	IMULI A,^D60		;And convert this to seconds
	SKIPL B,SECOND		;Get the seconds given
	CAIL B,^D60		;And range check it
	JRST BADTIM		;Must be >= 0 and < 60
	ADD B,A			;Get the total number of seconds
	JUMPE B,BADTIM		;Must be non-zero to enable
	MOVEI A,.SFOFS		;Get the SMON% function code
	SMON%			;And try to set the interval
	 JSYERR (<Unable to enable offline structures>)	;[7.1081] 
	RET			;Done

;[7.1063] Here if the minutes or seconds specified is bogus.

BADTIM:	ERROR (<Unable to enable offline structures - Invalid time specified>) ;[7.1081] 
	RET			;Print error and return

;[7.1063]
;
; DISOFS - Disable offline structures
;
DISOFS:	MOVEI A,.SFOFS		;Get SMON% function code
	SETZM B			;Zero to disable
	SMON%			;Do it
	 JSYERR (<Unable to disable offline structures>) ;[7.1081] 
	RET			;Done

; HERE TO ENABLE/DISABLE SYSTEM MESSAGE LEVEL 0

DISLV0:	TDZA B,B		;TURN IT OFF
ENALV0:	MOVEI B,1		;TURN IT ON
	MOVEI A,.SFMS0		;GET THE FUNCTION CODE
	SMON%			;CHANGE IT
	RET			;AND RETURN

; HERE TO ENABLE/DISABLE SYSTEM MESSAGE LEVEL 1

DISLV1:	TDZA B,B		;TURN IT OFF
ENALV1:	MOVEI B,1		;TURN IT ON
	MOVEI A,.SFMS1		;GET THE FUNCTION CODE
	SMON%			;CHANGE IT
	RET			;AND RETURN

;[7.1235] Here to enable/disable DUMP-ON-BUGCHK features.

DISDOB:	TDZA T1,T1		;Clear T1
ENADOB:	SETO T1,		;Unclear T1
	STKVAR <DOBENF,DOBNAM>	;Enable flag, bug name
	MOVEM T1,DOBENF		;Save enable flags
	MOVEI T1,[FLDDB. .CMKEY,,DOBTAB,,FACILITY] ;Keyword list
	CALL RFIELD		;(T1/T1,T2,T3) Read the field
	HRRZ T2,(T2)		;Dispatch to routine
	JRST (T2)		; specified by command

;[7.1235] Here for ENABLE/DISABLE DUMP-ON-BUGCHK FACILITY

DOBFAC:	CONFRM			;Confirm the command
	SKIPE DOBENF		;Enable?
	SKIPA T3,[.DBENA]	;Enable DOB
	MOVEI T3,.DBDIS		;Disable DOB
	MOVEI T1,T2		;Argument block is in AC2/AC3
	MOVEI T2,.DBFNC+1	;Two words in argument block
	DOB%			;Enable or disable it
	 ERJMP .+1		;We don't care about errors here
	RET			;Return to get more commands

;[7.1235] Here for ENABLE/DISABLE DUMP-ON-BUGCHK ALL-BUGCHKS and ALL-BUGINFS

DOBABC:	SKIPA T4,[DB%ENA!DB%CHK] ;ALL-BUGCHKS
DOBABI:	MOVX T4,DB%ENA!DB%INF	;ALL-BUGINFS
	CONFRM			;Get a confirmation on that
	SKIPN DOBENF		;Is it disable?
	TXZ T4,DB%ENA		;Yes
	MOVEI T1,T2		;Point to argument block
	MOVEI T2,.DBFLG+1	;Length of block
	MOVEI T3,.DBPAR		;Say do this function
	DOB%			;Do it
	 ERJMP DOBABE		;Catch error
	RET

DOBABE:	HRROI T1,[ASCIZ/Failed to /] ;Start message
	CALL ERRBEG		;(T1/) Start the error right
	HRROI T1,[ASCIZ/enable/] ;Assume enable
	TXNN T4,DB%ENA		;Was it enable?
	HRROI T1,[ASCIZ/disable/] ;No disable
	PSOUT			;Output that part
	HRROI T1,[ASCIZ/ ALL-BUGCHKS/] ;Assume it was chks
	TXNN T4,DB%CHK		;Yes it was
	HRROI T1,[ASCIZ/ ALL-BUGINFS/] ;It was infs
	PSOUT			;Output that finally
	JRST DOBER1		;Output the rest of the error string and return

;[7.1235] Here for ENABLE/DISABLE DUMP-ON-BUGCHK BUG (NAME) name

DOBBUG:	NOISE (NAME)		;Grumble at the user if he is there
	MOVEI T1,[FLDDB. .CMFLD,,,<Name of BUG, 6 characters or less>]
	CALL RFIELD		;Get the bug name
	MOVEI T3,6		;We only want 6 characters
	MOVE T2,[POINT 7,ATMBUF] ;Point to atom buffer
	MOVE T1,[POINT 6,DOBNAM] ;Point to BUG name
	SETZM DOBNAM		;Spin all bits back to zeroes
	DO. 
	  ILDB T4,T2		;Get a byte from the Atom
	  JUMPE T4,ENDLP.	;Atom buffer is guaranteed to end with null
	  CAIL T4,"a"		;Is it lower case??
	  CAILE T4,"z"		;...
	  SKIPA			;No
	  ADDI T4,"A"-"a"	;Upper it 
	  SUBI T4,"A"-'A'	;Sixbit it
	  IDPB T4,T1		;Put it into DOBNAM
	  SOJG T3,TOP.		;More to do?
	OD.			;End of loop

	SKIPN DOBENF		;Enable?
	JRST DOBBU2		;No, disable
	MOVEI T1,[FLDDB. .CMKEY,,IGNTAB,,,[ ;Try for IGNORE keyword
	   FLDDB. .CMCFM]]	;Or a confirm
	CALL RFIELD		;(T1/T1,T2,T3) Get confirmation or keyword
	LOAD T3,CM%FNC,.CMFNP(T3) ;See what was parsed
	CAIE T3,.CMCFM		;Need to get confirmation?
DOBBU2:	CONFRM			;Get confirmation

	MOVEI T1,T2		;Point to argument block
	MOVEI T2,.DBCFG+1	;Load words in argument block
	MOVE T4,DOBNAM		;Reload bug name
	MOVX T4+1,DB%REQ	;Assume disable
	SKIPN DOBENF		;Enable?
	IFSKP.			;Yes
	  MOVX T4+1,DB%ENA!DB%REQ ;Request dump on this bug
	  CAIE T3,.CMCFM	;Ignore timeout?
	  TXO T4+1,DB%IGN	;Yes
	ENDIF.			;Ready to go
	MOVEI T3,.DBSBG		;Set bug configuration is the function
	DOB%			;Perform the function
	 ERJMP DUMPB1		;Catch errors
	RET			;Done if no errors

;[7.1235] Here on error setting a bug dumpable.

DUMPB1:	HRROI T1,[ASCIZ/Unable to enable dump on BUG named /] ;Start error
	TXNN T4,DB%ENA		;Disable?
	HRROI T1,[ASCIZ/Unable to disable dump on BUG named /] ;Yes
	CALL ERRBEG		;(T1/) Print error
	MOVEI T3,6		;Output maximum of 6 characters
	MOVE T2,[POINT 6,DOBNAM] ;Load pointer to bug name
	DO.			;Output the bug name
	  ILDB T1,T2		;Get a character
	  JUMPE T1,ENDLP.	;Jump if done
	  ADDI T1,"A"-'A'	;Convert back to ASCII
	  PBOUT%		;Output just that character
	  SOJG T3,TOP.		;Loop for all of them
	OD.

;[7.1235] Finish up error with space dash space last-error and stars.

DOBER1:	TMSG < - >		;Now why
	CALL LSTERR		;Output last error code
	JRST STARS		;Output stars and return

	ENDSV.			;End of DUMP's STKVAR
	SUBTTL Commands -- DAYLIGHT

;TURN DAYLIGHT SAVING TIME ON/OFF/AUTO

DAYLIG:	NOISE <MODE IS>		;[7.1081] 
	MOVEI A,[FLDDB. .CMKEY,,DSTOPT] ;[7.1081] setup function block
	CALL RFIELD		;[7.1081] get option
	HRRZ B,(B)		;[7.1081] RH of table word
	CONFRM			;[7.1081] get confirmation
	MOVEI A,.SFDST		;[7.1081] set DST function
	SMON			;do it
	 JSYERR (<Unable to set DAYLIGHT savings time switch>) ;[7.1081] 
	RET			;ok, return
	SUBTTL Commands -- LAT-STATE

; SET LAT-STATE ON OR OFF

LAT:	NOISE <STATE IS>	;[7.1081] 
	MOVEI A,[FLDDB. .CMKEY,,LATSTA] ;[7.1081] setup function block
	CALL RFIELD		;[7.1081] get option
	HRRZ B,(B)		;[7.1081] RH of table word
	CONFRM			;[7.1081] get confirmation
	MOVEI A,.SFLTS		;[7.1081] Set LAT-STATE
	SMON			;[7.1081] 
	 JSYERR (<Unable to set LAT-STATE>)
	RET			;[7.1081] Ok 
	SUBTTL Commands -- DEFINE 

;DEFINE A LOGICAL NAME

DEFINE:	STKVAR <LNPTR>
	NOISE <SYSTEM LOGICAL NAME>
	MOVEI A,[FLDDB. .CMDEV,CM%PO!CM%SDH,,<global logical name being defined>]
	CALL RFIELD		;READ THE NAME
	CALL BUFFF		;GET POINTER TO NAME
	MOVEM A,LNPTR		;REMEMBER POINTER TO NAME
	NOISE <AS>
	MOVEI A,[FLDDB. .CMTXT,CM%SDH,,<logical name definition>]
	CALL CFIELD
	CALL BUFFF		;GET POINTER TO DEFINITION STRING
	MOVE C,A		;NEW NAME IN C
	MOVEI A,.CLNSY		;SAY GLOBAL
	MOVE B,LNPTR		;GET LOGICAL NAME
	CRLNM
	 ERJMP DEFINN		;[7.1081] Ouch
	RET

DEFINN:	HRROI T1,[ASCIZ/Failed to define logical name /]
	CALL ERRBEG		;[7.1081] (T1/) Output the start of error
	MOVE T1,LNPTR		;[7.1081] Get pointer to name
	PSOUT%			;[7.1081] Output it
	CALL LSTERR		;[7.1081] () Output last error code
	JRST STARS		;[7.1081] Output stars and return
	SUBTTL Commands -- EXIT

;[7.1235] Here to exit if running interactively

EXIT:	NOISE (TO EXEC)		;Give a noise word
	CONFRM			;Confirm the commmand
	SKIPN SYSTUP		;Intractive mode?
	HALTF			;Yes, edit
	RET			;Return for more commands

	SUBTTL Commands -- TIMEZONE

;SET LOCAL TIME ZONE; IT MUST BE A NUMBER FROM -12 TO 12

TIMZON:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<timezone number>]
	CALL CFIELD		;GET NUMBER AND CONFIRMATION
	MOVM D,B		;CHECK IT FOR RANGE
	CAILE D,^D12		;MUST BE FROM -12 TO 12 DECIMAL
	ERROR (<Timezone must be -12 to 12 inclusive>,<JRST CMDER1>)
	MOVEI A,.SFTMZ		;SET TIME ZONE
	SMON			;ARGUMENT IN B
	 JSYERR (<Unable to set TIMEZONE>)
	RET			;DONE
	SUBTTL Commands -- HOST

;SET LOCAL HOST NUMBER OF AN ARPANET SITE

HOST:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,8,<local ARPAnet host number>]
	CALL CFIELD		;READ NUMBER AND CONFRIMATION
	MOVEI A,.SFLHN		;SET LOCAL HOST NUMBER
	SMON
	 JSYERR (<Unable to set Arpanet HOST>) ;[7.1081] 
	RET			;DONE
	SUBTTL Commands -- ARCHIVE-TAPE-RECYCLE-PERIOD

ARCHIV:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<number of days for archive tape recycle period>]
	CALL CFIELD
	MOVEI A,.SFACY		; SET ARCHIVE TAPE RECYCLE PERIOD
	SMON
	 JSYERR (<Unable to set ARCHIVE-TAPE-RECYCLE-PERIOD>) ;[7.1081] 
	RET
	SUBTTL Commands -- TAPE-RECYCLE-PERIOD

TAPRCY:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<number of days for tape recycle period>]
	CALL CFIELD
	MOVEI A,.SFMCY		; SET TAPE RECYCLE PERIOD
	SMON
	 JSYERR (<Unable to set TAPE-RECYCLE-PERIOD>)
	RET
	SUBTTL Commands -- NODE 

;COMMAND TO DECLARE DECNET NODE NAME

NODNAM:	STKVAR <LNNAME,ARENUM>
	MOVEI A,[FLDDB. .CMFLD,CM%SDH,,<local node name>]
	CALL RFIELD		;READ NODE NAME
	CALL BUFFF		;GET POINTER TO ASCIZ STRING
	MOVEM A,LNNAME		;REMEMBER POINTER TO NAME
	MOVEI A,[	FLDDB. .CMCFM,,,,,[
			FLDDB. .CMNUM,CM%SDH,5+5,<area.node>]]
	CALL RFIELD		;GET CONFIRMATION OR NODE NUMBER
	MOVEI D,0		;FIRST ASSUME NO NUMBER
	LOAD C,CM%FNC,.CMFNP(C)	;SEE WHAT WAS TYPED
	CAIN C,.CMCFM		;CONFIRMATION ONLY?
	JRST NODNA2		;YES, NO NUMBER
	MOVEM B,ARENUM		;Save what we believe is the area number
	MOVEI A,[	FLDDB. .CMCFM,,,,,[
			FLDDB. .CMTOK,,<-1,,[ASCIZ /./]>]]
	CALL RFIELD		;Get confirmation or area dot
	LOAD C,CM%FNC,.CMFNP(C)	;See what we got
	CAIE C,.CMCFM		;Confirm?
	IFSKP.			; -yes,
	  MOVE D,ARENUM		;  Retrieve node number (no area specified)
	  JRST NODNA2		;   and go process
	ENDIF.			;Come here if a dot was given
	MOVEI A,[	FLDDB. .CMNUM,CM%SDH,5+5,<node number>]
	CALL RFIELD		;Get node number
	MOVE D,ARENUM		;Get area number
	LSH D,^D10		;Shift it into position
	IOR D,B			; and put in node number
	CONFRM			;Confirm

NODNA2:	IFN. D    		;IF NO NUMBER, GO ON
	  MOVEI A,.NDSNM	;SET NODE NUMBER
	  MOVEI B,D		;WHERE THE NUMBER IS
	  NODE			;SET IT
	   ERJMP NODNA3		;[7.1081] Error, check it out
	ENDIF.
 	MOVEI A,.NDSLN		;WANT TO SET NODE NAME
 	MOVEI B,C		;ARG BLOCK
 	MOVE C,LNNAME		;GET POINTER TO NODE NAME
	NODE			;DO IT
	 JSYERR (<Couldn't set node name>) ;[7.1081] 
	RET

NODNA3: CALL GETERR		;[7.1081] (/T2) Get last error code
	CAIN T2,NODX16		;[7.1081] DECnet already initialized?
	RET			;[7.1081] Yes, just return now
	HRROI T1,[ASCIZ/Couldn't set NODE number/] ;[7.1249] 
	JRST JSYER1		;[7.1081] (T1/) Output error and return
	SUBTTL Commands -- DECNET

;DECNET command - set initial DECnet parameters
;
; Command format:
;	DECNET BUFFER-SIZE <value>
;	DECNET DEFAULT-BUFFERS-PER-LINK <value>
;	DECNET DEFAULT-FLOW-CONTROL NONE | SEGMENT
;	DECNET MAXIMUM-ADDRESS <value>
;	DECNET MAXIMUM-BUFFER <value>
;	DECNET ROUTER-ENDNODE <value>
;	DECNET ROUTER-LEVEL-1 <value>

DECNET:	SAVEAC <P1,P2>
	MOVEI T1,[FLDDB. .CMKEY,,DCNTA0]
	CALL RFIELD		;Get DECNET option
	MOVE A,(B)		;Table word
	HLRZ P1,(A)		;Get parameter number
	HRRZ T1,(A)		;Get processing address
	CALL (A)		;Process, return value to set in T2
	CONFRM			;Confirm
	MOVE P2,T2		;Get value to set
	MOVEI T1,.NDSDP		;Set DECnet parameter
	MOVEI T2,P1		;Point to argument block (P1-P2)
	NODE%			;Do it
	 ERJMP DECNE1		;[7.1081] Check error
	RET

DECNE1:	CALL GETERR		;[7.1081] (/T2) Get last TOPS-20 error code
	CAIN T2,NODX16		;[7.1081] DECnet already initialized?
	RET			;[7.1081] Yes, probably CFE reload - ignore
	HRROI T1,[ASCIZ/Failed to set DECnet parameter/] ;[7.1249] 
	JRST JSYER1		;[7.1081] Output error text and return

;Read a decimal number, return value in T2

DCNNUM:	MOVEI T1,[FLDDB. .CMNUM,,5+5]
	CALL RFIELD
	RET

;ROULV1 - routing level 1
;ROUEND - routing endnode

ROULV1:	SKIPA T2,[RNT.L1]
ROUEND:	MOVEI T2,RNT.NR
	RET

;NSPFLO - read flow control option

NSPFLO:	MOVEI T1,[FLDDB. .CMKEY,,FLOTAB]
	CALL RFIELD
	MOVE A,(B)
	MOVE T2,(A)		;Get flow value (FCM.NO or FCM.SG)
	RET
	SUBTTL Commands -- ETHERNET

; "ETHERNET" COMMAND -- SET ETHERNET ADDRESS FOR A GIVEN CHANNEL
;
; COMMAND FORMAT:
;	ETHERNET (CHANNEL NUMBER) <channel #> (ADDRESS) <Hex address string>
;   OR:	ETHERNET (CHANNEL NUMBER) <channel #> (ADDRESS) DECNET
;
; Where "Hex address string" is a string of six hexadecimal numbers seperated
; by dashes ('-').  If the keyword 'DECNET' is used (must be spelled out in
; full) the address generated will be the appropriate address for a DECnet
; node on the Ethernet.

ETHERN:	SAVEAC <P1,P2>
	MOVEI A,[FLDDB. .CMNUM,CM%SDH,^D10,<Channel number>]
	CALL RFIELD		; Read the channel number
	MOVE P1,B		; Put it in a safe place (I hope)
	MOVEI A,[FLDDB. .CMKEY,,DNTABL]
	CALL RFLDE		; Look for the keyword "DECNET"
	 JRST GETADR		;  No such luck, search for a normal address
	CONFRM			; Finish up the line
	MOVEI A,.NDGNM		; Get the current node number
	MOVEI B,C		; Put it in C
	SETZ C,			; Clear C in case of error
	NODE%
	 JSYERR (<Could not read DECnet address to set ETHERNET address>) ;[7.1081]
	SKIPN C			;[7.1081] Did we get a node number?
	ERROR (<Could not set DECnet address for ETHERNET channel - DECnet address is not set>,<RET>)
	MOVEI A,.SFSEA		; Function is "Set Ethernet Address"
	MOVE B,P1		; Get channel number into B
	SETO C,			; Indicate we want the DECnet address
	SMON%			; Set the DECnet Ethernet address
	 JSYERR (<Could not set ETHERNET address>) ;[7.1081]
	RET

GETADR:	CALL RNIADR		; Read the NI address
	
SETADR:	MOVE C,P1		; Get channel number
	DMOVE P1,A		; Put address in a safe place
	MOVEI A,.SFSEA		; Function is "Set Ethernet Address"
	MOVE B,C		; Channel number must be in B
	MOVE C,[POINT 8,P1]	; Get pointer to address
	SMON%			; Set the Ethernet address
	 JSYERR (<Could not set ETHERNET address>) ;[7.1081]
	RET

	DEFINE BADSTR (string)<[EXP CM%FW+CM%NOR+CM%INV,ASCIZ |string|],,0>

DNTABL:	DNTLEN,,DNTLEN
	BADSTR D		; Don't allow substrings which could
	BADSTR DE		;  be valid Ethernet addresses
	T DECNET,0
	DNTLEN==.-DNTABL-1

; Here to read an Ethernet address of the form xx-xx-xx-xx-xx-xx.  Where
; xx is a hex number in the range of 0 to FF inclusive.

RNIADR:	SAVEAC P1		; Allocate an AC for source byte pointer
	TRVAR <<ADDR,2>>	; Allocate space for address
	MOVEI A,[FLDDB. .CMFLD,CM%SDH,,<Hexadecimal Ethernet Address>]
	CALL CFIELD		; Read the text and confirmation
	MOVE P1,[POINT 7,ATMBUF]; Get pointer to parsed text

	MOVE C,[POINT 8,ADDR]	; Get pointer to destination
	MOVEI D,6		; We should go through here a max of 6 times

	JRST RNIAD2		; Enter loop at the right point
RNIAD1:	CAIE B,"-"		; Followed by a dash?
	 JRST BADADR		;  Nope, tell the user
RNIAD2:	CALL HEXIN		; Read a hex number
	JUMPL A,BADHEX		; If negative, probably overflowed
	CAILE A,^D255		; Is it more than 8 bits?
BADHEX:	ERROR (<Illegal hexadecimal byte in ETHERNET address>,<JRST CMDER1>)
	IDPB A,C		; Accumulate the Ethernet address
	SOJG D,RNIAD1		; Loop for all six numbers
	DMOVE A,ADDR		; Get address into A and B
	RET

BADADR:	HRROI T1,[ASCIZ/Illegal character "/] ;[7.1081] 
	CALL ERRBEG		;[7.1081] (T1/) Output string to CTY
	MOVE A,B		; Get naughty character
	PBOUT			; Throw it out
	TMSG <" in Ethernet address> ;[7.1081] Finish the mexxage
	CALL STARS		;[7.1081] () Output stars
	JRST CMDER1


HEXIN:	SETZ A,			; Clear the number holder
HEXIN2:	ILDB B,P1		; Get a byte from the source string
	CAIL B,"a"		; Less than "a"?
	 CAILE B,"z"		;  Or greater than "z"?
	  SKIPA			;   Yes to either, not lowercase
	SUBI B,"a"-"A"		; Nope, upper caseify it
	CAIL B,"0"		; Less than "0"?
	 CAILE B,"9"		;  Or greater than "9"?
	  SKIPA			;   Yes to either, check further
	JRST HEXIN1		; Nope, we have a valid digit
	CAIL B,"A"		; Less than "A"?
	 CAILE B,"F"		;  Or greater than "F"?
	  RET			;   Yes to either, it's not hex

	SUBI B,"A"-"9"-1	; Hexamize the character
HEXIN1:	SUBI B,"0"		; Turn it into an integer
	LSH A,4			; Make room for the new digit
	IOR A,B			; Bring in the new digit
	JRST HEXIN2		; And look for more
	SUBTTL Commands -- CHANGE

; "CHANGE" COMMAND -- SET ACCOUNTING SHIFT TIMES
;
; COMMAND FORMAT:
;	CHANGE (ACCOUNT SHIFT AT) <TIME> (ON) <DAYS-OF-WEEK>

CHANGE:	MOVEI A,[FLDDB. .CMTAD,CM%SDH,CM%ITM!CM%NCI!DATBLK,<time of day at which accounting shift is to occur>]
	CALL RFIELD		;READ TIME
	HRRZ P1,DATBLK+2	;STORE TIME, INIT LEFT HALF TO NO DAYS
	MOVEI A,[FLDDB. .CMCFM,,,<confirm now to assume all days, or enter specific days of week>]
	CALL RFLDE		;END OF LINE NOW?
	 CAIA			;NO
	JRST CHANG7		;YES, ASSUME ALL DAYS
CHANG2:	MOVEI A,[FLDDB. .CMKEY,,DOWTAB,<day of the week on which accounting shift is to occur>]
	CALL RFIELD		;READ DAY OF THE WEEK
	HRLZ A,(B)		;GET DAY-OF-WEEK BITS FROM TABLE TO LH
	TDO P1,A		;SET SELECTED DAYS
	MOVEI A,[FLDDB. .CMCFM,,,,,[
		 FLDDB. .CMCMA]]
	CALL RFIELD		;GET CONFIRMATION OR COMMA
	LOAD D,CM%FNC,.CMFNP(C)	;SEE WHICH
	CAIN D,.CMCMA		;MORE DAYS FOLLOWING?
	JRST CHANG2		;YES, GO READ THEM
	JRST CHANG8		;NO, CONFIRMATION, SO WE'RE DONE

CHANG7:
	TXO P1,1B0!1B1!1B2!1B3!1B4!1B5!1B6 ;ASSUME ALL DAYS OF WEEK
CHANG8:
	MOVEI T1,ASCTBZ		;GET SIZE OF TABLE
	HRRZM T1,ASCTBL		;STORE AS MAX TABLE SIZE
	MOVX T1,.USRAS		;READ ACCOUNTING SHIFTS
	MOVEI T2,ASCTBL		; INTO ASCTBL
	USAGE			; . . .
	 JSYERR (<Unable to read accounting shift CHANGE>,<RET>) ;[7.1081] 
	HLRZ T1,ASCTBL		;GET CURRENT SIZE OF TABLE
	ADDI T1,1		;BUMP BY ONE
	HRLM T1,ASCTBL		;STORE NEW SIZE
	MOVEM P1,ASCTBL(T1)	;STORE NEW ENTRY
	MOVX T1,.USSAS		;SET ACCOUNTING SHIFTS
	USAGE
	 JSYERR (<Unable to set accounting shift CHANGE>) ;[7.1081] 
	RET
	SUBTTL Commands -- PRINTER

; ROUTINE TO LOAD A RAM OR VFU

LPTLOD:	STKVAR <LODUNI,LODFNC,LODJFN,LPTJFN>
	SETZM LODJFN		;INIT THIS TO ZERO
	MOVEI A,[FLDDB. .CMNUM,CM%SDH,8,<lineprinter unit number>]
	CALL RFIELD		;READ UNIT NUMBER
	MOVEM B,LODUNI		;SAVE LPT UNIT NUMBER

; SEE IF RAM OR VFU IS TO BE LOADED

LPLD20:	MOVEI A,[FLDDB. .CMKEY,,LPTTAB]
	CALL RFIELD		;SEE WHICH IS BEING LOADED
	HRRZ A,(B)		;GET FUNCTION TO PERFORM
	CAIN A,.MOSTS		;SET STATUS FUNCTION (DECLARE LOWER CASE LPT) ?
	JRST [	MOVE T2,LODUNI	;YES, GET THE UNIT NUMBER
		CAIGE T2,LPTN	;Bad unit number, don't write to table
		SETOM LODLCP(T2) ;FLAG THAT PRINTER SHOULD BE LOWER CASE
		JRST LPLD20 ]	;GO GET NEXT ARGUMENT
	MOVEM A,LODFNC		;SAVE DESIRED FUNCTION (MTOPR CODE)
	CAIGE T2,LPTN		;Bad unit number?
	JRST LODERR		;Yes, don't continue

; READ FILENAME TO BE LOADED AND GET A JFN FOR IT

	MOVEI A,[FLDDB. .CMIFI,CM%SDH,,<name of ram or vfu file>]
	CALL CFIELD		;GET FILENAME AND CONFIRMATION
	MOVEM B,LODJFN		;SAVE JFN

; OPEN THE PRINTER AND VERIFY THAT NO RAM OR VFU IS NOW LOADED

	HRROI A,FILNAM		;GET POINTER TO WHERE DEVICE STRING GOES
	MOVSI B,600007		;GET LPT DEVICE DESIGNATOR
	HRR B,LODUNI		;GET UNIT NUMBER
	DEVST			;GET DEVICE NAME STRING
	 JRST LODERR		;FAILED
	MOVEI B,":"		;GET TERMINATOR FOR GTJFN
	IDPB B,A		;TERMINATE DEVICE NAME
	SETZ B,
	IDPB B,A		;TIE IT OFF
	MOVX A,GJ%SHT!GJ%FOU	;SHORT CALL, FOR OUTPUT USE
	HRROI B,FILNAM		;GET POINTER TO DEVICE NAME
	GTJFN			;GET A JFN FOR THE PRINTER
	 JRST ENDLPT		;ALREADY ASSIGNED
	MOVEM A,LPTJFN		;SAVE LPT JFN
	MOVX B,<FLD(7,OF%BSZ)+OF%WR> ;OPEN FOR WRITE
	OPENF			;OPEN THE PRINTER
	 JRST [	EXCH A,LPTJFN	;MUST BE OPEN ALREADY, GET BACK JFN
		RLJFN		;RELEASE THE JFN
		 JFCL		;IGNORE ERRORS HERE
		MOVE A,LPTJFN	;GET BACK ERROR CODE
		CAIE A,OPNX9	;ALREADY OPENED BY SOMEONE?
		JRST LODANY	;NO. LOAD ANYWAY
		JRST ENDLPT ]	;GO ON TO NEXT COMMAND
	MOVEI B,.MOPSI		;GET OFF-LINE INTS
	MOVEI C,P1		;SET UP ARGS IN REGISTERS
	MOVEI P1,3		;3 WORDS
	MOVEI P2,.ICLPO		;LINE PRINTER OFFLINE CHANNEL
	SETZ P3,		;NO FLAGS
	MTOPR			;DO IT
	ERJMP .+1		;IN CASE SOMETHING TERRIBLE HAPPENED
	GDSTS			;GET CURRENT STATUS
	TXZ B,MO%LVU!MO%LCP!MO%EOF ;TURN OFF CONDITION BITS
	JUMPN B,INERR		;IF AN ERROR, PUNT IT
	MOVEI B,14		;IF NO ERROR, ALIGN FORMS
	BOUT			;DO IT
	 ERJMP .+1		;IGNORE FAILURE

INERR:	DMOVE B,[-1,,FILNAM
		5*^D28]		;ARGS
	DMOVEM B,MTBLK+1	;TO ARG BLOCK
	MOVE C,LODFNC		;GET FUNCTION TO PERFORM
	MOVX B,.MORTR		;GET READ-RAM FUNCTION CODE
	CAIE C,.MOLTR		;ARE WE LOADING THE RAM ?
	MOVX B,.MORVF		;NO, GET READ-VFU FUNTION
	MOVEI C,MTBLK		;GET ADDRESS OF BLOCK
	SETZM FILNAM		;MAKE IT LOOK AS IF IT IS NOT LOADED
	MTOPR			;READ FILENAME ALREADY LOADED
	 ERJMP .+1		;UNEXPECTED ERROR. LOAD RAM ANYWAY
	MOVE A,LPTJFN		;GET JFN FOR PRINTER
	CLOSF			;CLOSE THE FILE
FCLOSE:	 JRST [	MOVE A,LPTJFN	;FAILED. GET JFN AGAIN
		TXO A,CZ%ABT	;DO IT NOW WITH ABORT
		CLOSF		;DO IT
		 JFCL		;HAS TO WORK
		JRST .+1]	;ALL DONE
	LDB A,[POINT 7,FILNAM,6] ;GET FIRST BYTE RETURNED
	JUMPN A,ENDLPT		;IF NOT-NULL, GO ON TO NEXT COMMAND

; GET JFN, FUNCTION, AND UNIT # AND LOAD THE RAM OR VFU

LODANY:	MOVE B,LODFNC		;GET FUNCTION TO BE PERFORMED
	MOVE A,LODJFN
	MOVE C,LODUNI		;GET UNIT NUMBER OF PRINTER
	SKIPE LODLCP(C)		;IS THIS PRINTER LOWER CASE ?
	TXO B,MO%LCP		;YES, MARK THAT PRINTER IS LOWER CASE
	LPINI			;LOAD RAM OR VFU
	 ERJMP LODERR		;ERROR - TELL SOMEONE

; HERE TO FINISH UP AND GO DO NEXT COMMAND

ENDLPT:	RET

; HERE ON AN ERROR LOADING THE RAM OR VFU

LODERR:	HRROI T1,[ASCIZ/Could not load the /] ;[7.1081] 
	CALL ERRBEG		;[7.1081] (T1/) Output that with a ?
	HRROI A,[ASCIZ/VFU/]	;GET TEXT
	MOVE B,LODFNC		;GET FUNCTION BEING PERFORMED
	CAIE B,.MOLVF		;ARE WE LOADING THE VFU ?
	HRROI A,[ASCIZ/RAM/]	;NO, GET RAM TEXT
	PSOUT			;TELL USER WHAT WE ARE LOADING
	TMSG < for PLPT>	;GET UNIT NAME
	MOVEI A,.PRIOU		;GET PRIMARY OUTPUT JFN
	MOVE B,LODUNI		;GET UNIT NUMBER
	MOVEI C,^D8		;GET OCTAL RADIX
	NOUT			;OUTPUT THE UNIT NUMBER
	 JFCL			;IGNORE ERRORS HERE
	CAIL B,LPTN		;Unit number out of range?
	JRST LODER1		;Yes, message isn't complete
	TMSG < - >		;[7.1081] Output seperator
	CALL LSTERR		;[7.1081] Output last error code
	JRST LODER2		;[7.1081] Continue below

LODER1:	TMSG <Unit number out of range>	;[7.1081] Output range error

LODER2:	CALL STARS		;[7.1081] () Finish up error message
	SKIPE A,LODJFN		;GET JFN FOR FILE TO HAVE BEEN LOADED
	CLOSF			;MAKE SURE IT IS REALLY CLOSED AND RELEASED
	 JFCL			;PROBABLY CLOSED BY MONITOR ALREADY ANYHOW
	JRST ENDLPT		;GO FINISH UP

;LPT OFF-LINE INTERRUPT ROUTINE

LPTINT:	MOVEI A,@FCLOSE		;REDIRECT CODE TO CLOSE AND ABORT DEVICE
	MOVEM A,PCLEV1		;ZAP THE OLD PC WORD
	DEBRK			;AND GO FINISH UP

;CHANNEL ONE INTERRUPT ROUTINE.  INVOKED WHEN TIMER HAS EXPIRED.

HUNG:	HRROI T1,[ASCIZ/
%SETSPD Hung on command line /]	;[7.1081]
	PSOUT%			;[7.1081]
	MOVEI T1,.PRIOU		;OUTPUT TO PRIMARY DESIGNATOR
	MOVE T2,NCMDS		;GET THE COMMAND LINE NUMBER THAT IS HUNG
	MOVEI T3,^D10		;OUTPUT IN DECIMAL
	NOUT%
	 JSERR
	HRROI T1,[ASCIZ/ - Continuing with next command...
/]				;[7.1081] 
	PSOUT%			;[7.1081] Output more of message
	MOVE T2,HNGCON		;GET CONTINUATION ADDRESS
	TXO T2,UMODF		;SET USER FLAG OF PC
	MOVEM T2,PCLEV2		;AND CHANGE PROCESS PC TO CONTINUE
	MOVE P,HNGSTK		;GET BACK LAST PRESERVED STACK
	DEBRK
	SUBTTL Commands -- BIAS

;ROUTINES FOR SCHEDULER CONTROLS

;SET BIAS-CONTROL VALUE

BIAS:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<value for bias control knob>]
	CALL CFIELD		;READ VALUE AND CONFIRMATION
	MOVE T4,T2		;COPY NUMBER
	MOVEI T1,.SKSBC		;SET BIAS CONTROL
	MOVEI T2,T3		;ARG BLOCK
	MOVEI T3,2		;LENGTH OF BLOCK
	SKED%			;SET IT
	 JSYERR (<Couldn't set scheduler BIAS>)	;[7.1081]
	RET
	SUBTTL Commands -- BATCH-BACKGROUND

;SET BATCH BACKGROUND

BATBGD:	CONFRM			;MAKE SURE HE MEANS IT
	MOVEI T1,.SKBBG		;GET PROPER FUNCTION
	SETZM T2		;NO ARGS
	SKED%			;SET IT
	 JSYERR (<Could not set BATCH-BACKGROUND>) ;[7.1081]
	RET
	SUBTTL Commands -- CREATE

;SCHEDULER CONTROLS COMMANDS CONTINUED

;CREATE A CLASS. WILL DO NOTHING IF CLASS SCHEDULER NOW ON.

CREATE:	MOVX T1,.SKRCV		;READ CLASS PARAMETERS
	MOVEI T2,T3
	MOVEI T3,2
	SKED%			;READ OUT CLASS PARAMETERS
	 JSYERR (<Couldn't read class parameters>,<JRST CMDER1>) ;[7.1081]
	TXNN T4,SK%STP		;NOW ON?
	JRST CMDER1		;YES. GO AWAY QUIETLY THEN

;CLASS SCHEDULING NOW OFF. SET THE CLASS SHARE

	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<class number>]
	CALL RFIELD
	MOVEM T2,CLSBLK+1	;SAVE CLASS
	MOVEI A,[FLDDB. .CMFLT,CM%SDH,,<percentage of machine to allot to class>]
	CALL CFIELD
	MOVEM T2,CLSBLK+2	;SAVE %
	MOVEI T2,CLSBLK
	MOVEI T1,.SKSCS		;PROPER FUNCTION
	SKED%			;DO IT
	 JSYERR (<Could not CREATE class>) ;[7.1081]
	RET
	SUBTTL Commands -- ENABLE CLASS-SCHEDULING

;MORE SCHEDULER COMMANDS

;ENABLE CLASS-SCHEDULING. GOT TO HERE FROM ENABLE COMMAND

ECSKED:	MOVEI T1,.SKRCV		;READ CLASS VALUES
	MOVEI T2,T3
	MOVEI T3,2
	SKED%			;READ VALUES
	 JSYERR (<Could not read scheduler class values>,<JRST CMDERR>)
	TXNN T4,SK%STP		;NOW ON?
	JRST CMDER1		;YES. SKIP IT THEN

;CLASS SCHEDULER NOW OFF.

	MOVEI A,[FLDDB. .CMKEY,,SKDOPT]
	CALL RFIELD		;GET OPTION
	HRRZ A,0(B)		;GET VALUE
	MOVX T4,SK%ACT		;ASSUME BY ACCOUNT
	SKIPE A			;IS IT?
	TXZ T4,SK%ACT		;NO
	MOVEI A,[FLDDB. .CMKEY,,SKDOP0,,<ALLOCATED>]
	CALL CFIELD		;DEFAULT TO ALLOCATED
	HRRZ A,0(B)		;GET VALUE
	SKIPE A			;WANT TO WITHHOLD?
	TXO T4,SK%WDF		;YES
	MOVEI T1,.SKICS
	MOVEI T2,T3
	MOVEI T3,2		;COUNT
	SKED%			;START UP CLASS SCHEDULER
	 JSYERR (<Could not ENABLE CLASS-SCHEDULING>) ;[7.1081]
	RET
	SUBTTL Commands -- BATCH-CLASS

;SET BATCH CLASS

BCHCLS:	MOVEI A,[FLDDB. .CMNUM,CM%SDH,5+5,<class number for running all batch jobs in>]
	CALL CFIELD
	MOVE T4,T2		;COPY VALUE
	MOVEI T3,2		;ARG BLOCK
	MOVEI T1,.SKBCS		;SET BATCH CLASS
	MOVEI T2,T3		;POINT TO ARG BLOCK
	SKED%			;DO IT
	 JSYERR (<Could not set BATCH-CLASS>) ;[7.1081]
	RET
	SUBTTL System Dumps -- At System Startup

;Entry point for processing crash dumps at system startup

START3:	SETZM SYSFLG		;[7.1081] Indicate system startup copy of dumps
	MOVE P,[IOWD PDLEN,PDL]	;SET UP PUSH DOWN LIST
	CALL INIT		;SET UP PSI, CAPABILITIES, ETC.
	MOVX T1,<ASCIZ/BS/>	;[7.1112] Load structure name to copy from
	MOVEM T1,STRNAM		;[7.1081]  at system startup time
	CALL QUEBLK		;[7.1081] Copy queued SYSERR and DUMP.EXE file
	JRST QUIT		;[7.1081] Exit
	SUBTTL System Dumps -- Continuable Dumps

;[7.1081] Entry point for processing continuable dumps - called after a
;[7.1081] continuable dump and at system startup after the crash dump
;[7.1081] has been copied.

START5:	SETOM SYSFLG		;[7.1081] Say we are doing continuable dumps
	MOVE P,[IOWD PDLEN,PDL]	;[7.1081] Setup the stack
	CALL INIT		;[7.1081] Set up PSI, capabilities, etc.
	CALL DEVLUP		;[7.1081] Copy all of the dumps
	JRST QUIT		;[7.1081] And quit

;[7.1081] Worker routine DEVLUP loops thru the DEVNAM table in the monitor.
;[7.1081] It calls routine STRWRK for each disk that is currently mounted
;[7.1081] by the system.  It quits as soon as it hits a device that is not
;[7.1081] a disk.

DEVLUP:	MOVEI T1,.DEVNA		;[7.1081] Name of table to read
	HRLI T1,-1		;[7.1081] We want count entries in this table
	GETAB%			;[7.1081] Go get it
	 ERJMP R		;[7.1081] Hell must be freezing over
	HRLZ Q1,T1		;[7.1081] Get XWD aobjn count, table index
DEVL1:	HRL T1,Q1		;[7.1081] Get table index into LH
	HRRI T1,.DEVNA		;[7.1081] Get table number into RH
	GETAB%			;[7.1081] Get SIXBIT name of device
	 ERJMP DEVL2		;[7.1081] Skip this one
	MOVEM T1,SIXNAM		;[7.1081] Move name to SIXNAM
	MOVX T2,<POINT 6,SIXNAM> ;[7.1081] Setup 6 bit byte pointer to name
	MOVX T1,<POINT 7,STRNAM> ;[7.1081] Setup byte pointer for ASCII name
	MOVEI T3,6		;[7.1081] Say max of 6 characters
	CALL SIXASC		;[7.1081] Convert it to something useful
	CALL STRWRK		;[7.1081] Copy <SYSTEM>DUMP.EXE on structure
	 RET			;[7.1081] No more disks
DEVL2:	AOBJN Q1,DEVL1		;[7.1081] Go check for another structure
	RET			;[7.1081] End of device table (!)

;[7.1081] Worker routine for DEVLUP to check a structure.  Ignores device DSK:.
;Call with STRNAM set up with ASCIZ structure, SIXNAM with SIXBIT structure
;name.
;Returns +1 if no more devices to check
;        +2 when finished with this device

STRWRK:	MOVX T1,<POINT 7,STRNAM> ;[7.1081] Point to ASCII name
	STDEV%			;[7.1081] Get device designator from string
	 ERJMP RSKP		;[7.1081] If in trouble - just skip it
	MOVE T1,T2		;[7.1081] Move device designator to T1
	DVCHR%			;[7.1081] Get the device characteristics
	 ERJMP RSKP		;[7.1081] Skip this one if unknown device
	LDB T3,[POINT 9,T2,17]	;[7.1081] Get device type
	CAIE T3,.DVDSK		;[7.1081] Make sure it's a disk
	RET			;[7.1081] First non-disk means no more disk dev
	MOVE T1,SIXNAM		;[7.1081] Get back SIXBIT name
	SKIPE T1		;[7.1081] Skip null entries
	CAMN T1,[SIXBIT /DSK/]	;[7.1081] Is it structure "DSK"?
	RETSKP			;[7.1081] Yes, forget it
	MOVX T1,<POINT 7,STRNAM> ;[7.1081] Pointer to ASCIZ structure name
	MOVEM T1,MSTRAD+.MSGSN	;[7.1081] Store it in MSTR block
	MOVX T1,<.MSGST+1,,.MSGSS> ;[7.1081] Arg block size,,func (get status)	
	MOVEI T2,MSTRAD		;[7.1081] Address of arg block
	MSTR%			;[7.1081] Get the structure status
	 ERJMP RSKP		;[7.1081] Skip this one
	MOVE T1,MSTRAD+.MSGST	;[7.1081] Get the status word
	TXNN T1,MS%OFS		;[7.1081] Is the structure offline?
	TXNN T1,MS%DMP		;[7.1081] Is the structure dumpable?
	RETSKP			;[7.1081] Offline or not dumpable
	MOVX T1,<POINT 7,STRNAM> ;[7.1081] Point to structure name again
	MOVEM T1,MSTRAD+.MSDEV	;[7.1081] Store it in MSTR block again
	MOVX T1,<.MSDEV+1,,.MSIMC> ;[7.1081] Arg block size,,incr mount count
	MOVEI T2,MSTRAD		;[7.1081] Point to the arg block
	MSTR%			;[7.1081] Increment the job's mount count
	 ERJMP STRWR1		;[7.1081] Check out this error
	SETOM EXEINC		;[7.1081] Remember to decrement the mount count

STRCPY:	CALL QUEBLK		;[7.1081] Go copy a dump file (if it exists)
	SKIPE EXEINC		;[7.1081] Did we increment mount count?
	CALL EXEDEC		;[7.1081] Yes - go decrement it
	SKIPE CPYINC		;[7.1081] Was the destination mount count incr?
	CALL CPYDEC		;[7.1081] Yes - go decrement it
	RETSKP			;[7.1081] Done

STRWR1:	CALL GETERR		;[7.1081] (/T2) Get last error code
	CAIE T2,MSTX31		;[7.1081] Is it 'Structure already mounted'?
	RETSKP			;[7.1081] No - skip this structure
	JRST STRCPY		;[7.1081] Yes - go copy dump
	SUBTTL System Dumps -- Process a Dump

;QUEBLK - Copy DUMP.EXE to DMP:DUMP-edit-bugname.CPY
;	  and log any unlogged SYSERR blocks that were found in the dump
;Returns +1 always

QUEBLK:	TRVAR <QUEJFN,QUEPGS,QUEFAD,QUESIZ> ;[7.1081] 
	SETZM QUEFAD		;[7.1081] No flag address yet
	SETZM QUEJFN		;[7.1081] There is no DUMP.CPY JFN yet
  IFN FTSC,<			;[7.1081] 
	SETZM SCDONE		;[7.1081] Clear spear count done flag
  >				;[7.1081] 
	MOVE T1,[SIXBIT /DBUGSW/] ;CHECK ON STATE OF SYSTEM
	SYSGT			;READ DBUGSW
	SKIPE T2		;FOUND IT?
	CAIGE T1,2		;YES. IS IT STAND-ALONE?
	SKIPA			;NO. DO THE DUMP
	JRST QUEDON		;[7.1081] Try to set SPEAR count if needed
	CALL CLRGTJ		;[7.1081] Clear GTJFN block
	MOVX T1,<POINT 7,STRNAM> ;[7.1081] Get a pointer to structure name
	MOVEM T1,GTJBLK+.GJDEV	;[7.1081] Store it in the GTJFN block
	MOVX T1,GJ%OLD		;[7.1081] Setup GTJFN flags
	MOVEM T1,GTJBLK+.GJGEN	;[7.1081] Store them
	MOVX T1,<.NULIO,,.NULIO> ;[7.1081] Setup input/output JFNs 
	MOVEM T1,GTJBLK+.GJSRC	;[7.1081]   in the arg block
	MOVEI T1,GTJBLK		;[7.1081] Point to the GTJFN block
	HRROI T2,[ASCIZ/<SYSTEM>DUMP.EXE/] ;[7.1081] Use this filename
	GTJFN			;[7.1081] Try to get a JFN on DUMP.EXE
	 JRST QUEDON		;[7.1081] Some problem, give up
	HRRZM T1,QUEJFN		;[7.1081] Save JFN

;[7.1081] Open the DUMP.EXE file, set protection to 770000

	MOVE T2,[FLD(^D36,OF%BSZ)!OF%RD!OF%WR!OF%THW!OF%RTD] ;[7.1081] 
				;[7.1081] Restricted access in case 2 systems
				;[7.1081] are running SETSPD at the same time
	OPENF%			;[7.1081] Open the file for read/write thawed
	IFNSK.			;[7.1081] If it failed
	  MOVE T1,QUEJFN	;[7.1081] Clean up JFN
	  RLJFN%		;[7.1081] Release it since it wasn't open
	   ERJMP .+1		;[7.1081] Ignore error
	  SETZM QUEJFN		;[7.1081] JFN is now gone
	  JRST QUEDON		;[7.1081] Clean up and exit
	ENDIF.			;[7.1081]

;[7.1081] Set protection to DUMP.EXE to 770000

	HRLI T1,.FBPRT		;SET THE PROTECTION OF DUMP.EXE TO 770000
	MOVEI T2,-1		;RIGHT HALF PROTECTION BITS
	MOVEI T3,770000		;MUCHO PROTECTION
	CHFDB			;THIS FILE MUST BE PROTECTED FOR SECURITY
	 ERJMP .+1

;[7.1081] Since DOB code writes directly to disk, make sure that we get a copy
;[7.1081] from disk and not from any copy that is still in memory.

	CALL FLUSH		;[7.1081] () Flush incore copy to disk

;[7.1081] Map in and check first page and see if we need to copy it

	HRLZ T1,QUEJFN		;[7.1081] Now map in EXE directory page
	MOVE T2,[.FHSLF,,PG0PG]	;[7.1081] Page 0 of the DUMP.EXE file
	MOVX T3,PM%RD!PM%WT	;[7.1081] Read and write access
	PMAP			;[7.1081] Read page 0
	 ERJMP QUEDON		;[7.1081] Done if error
	HRRZ T1,PG0ADR		;GET LENGTH OF DIRECTORY BLOCK
	HRRZ T2,PG0ADR-2(T1)	;GET STARTING FILE PAGE # OF LAST GROUP
	HLRZ T3,PG0ADR-1(T1)	;GET HALFWORD CONTAINING REPEAT COUNT
	LSH T3,-9		;RIGHT JUSTIFY REPEAT COUNT
	ADDI T2,1(T3)		;COMPUTE # OF FILE PAGES TO MAP
	MOVEM T2,QUEPGS		;SAVE NUMBER FOR CPYDMP
	HRRZ T1,PG0ADR		;GET LENGTH OF HEADER BLOCK OF DIR
	HLRZ T2,PG0ADR(T1)	;GET CODE OF NEXT BLOCK
	CAIE T2,1775		;ENTRY VECTOR?
	JRST QUEDON		;[7.1081] No, give up
	HRRZ T2,PG0ADR(T1)	;GET LENGTH
	CAIGE T2,4		;CORRECT LENGTH?
	JRST QUEDON		;[7.1081] No, give up
	SKIPGE PG0ADR+EVFLG(T1)	;[7.1081] Already copied this dump?
	JRST QUEDON		;[7.1081] Yes, give up
	MOVEI T1,PG0ADR+EVFLG(T1) ;[7.1081] Load the address of the flag
	MOVEM T1,QUEFAD		;[7.1081] Save flag address for later

;[7.1081] Get bugname and monitor edit information from the dump

	HRRZ T1,PG0ADR+2	;[7.1081] Look for process page 0
	SKIPE T1		;[7.1081] Is this the entry for page 0?
	IFSKP.			;[7.1081] Yes, map it to get vers and name
	  HRLZ T1,QUEJFN	;[7.1081] Get the file JFN
	  HRR T1,PG0ADR+1	;[7.1081] Get the page number in the file
	  MOVX T2,<.FHSLF,,PG1PG> ;[7.1081] Map it to this page
	  PMAP			;[7.1081] so we can look at it
	   ERJMP .+1		;[7.1081] If error we'll probably get zeroes
	  MOVE T1,PG1ADR+.JBVER	;[7.1081] Get edit info of monitor from dump
	  MOVEM T1,BUGVER	;[7.1081] Save it for filename
	  MOVE T1,PG1ADR+.JBBNM	;[7.1081] Get the bug name (SIXBIT)
	  MOVEM T1,BUGNAM	;[7.1081] Store that too
	ELSE.			;[7.1081] 
	  SETZM BUGVER		;[7.1081] No version found
	  SETZM BUGNAM		;[7.1081] No bug name found
	ENDIF.			;[7.1081] 

;[7.1081] Finally, copy the dump

	HRRZ T1,QUEJFN		;[7.1081] Get JFN of original dump file
	MOVE T2,QUEPGS		;[7.1081] Get highest page number to copy
	CALL CPYDMP		;[7.1081] (T1,T2/) Copy the dump file
	SKIPE @QUEFAD		;[7.1081] Dump written by BOOTS?
	JRST QUEDON		;[7.1081] No - skip SYSERR stuff
				;[7.1081] Yes, fall through
	SUBTTL System Dumps -- Process a Dump -- Queue SYSERR Blocks

;[7.1081] Copy is done, proceed with queueing up the SYSERR blocks if it
;[7.1081] was a BUGHLT type dump.

	CALL DMPMAP		;MAP THE DUMP FILE
	 JRST QUEDON		;[7.1081] Handle errors
	SETZ T1,		;WE WANT PAGE ZERO OF THE DUMP
	CALL DMPRED		;READ FROM THE DUMP
	 JRST QUEDON		;[7.1081] Exit

   IFN FTSC,<			;[7.1081]
	SKIPE T3,TMPADR+SPRCNT	;GET RUNNING COUNT OF SPEAR ENTRIES
	IFSKP.			;IF ZERO, TRY GETTING COUNT FROM ERROR.SYS
	  CALL STARS		;[7.1081] Output stars
	  TMSG <%SETSPD: SPEAR entry count = 0 in SYSTEM:DUMP.EXE, resynching from ERROR.SYS> ;[7.1081] 
	  CALL STARS		;[7.1081] 
	  CALL SETCNT		;[7.1081] Set count from ERROR.SYS
	ELSE.
	  SETZ T3,		;[7.1081] Clear counter
	  CALL SETZER		;[7.1081] (T3/) Set the count
	ENDIF.
   >				;[7.1081] Removal of SPRCNT code

	SKIPG P1,TMPADR+SEBQOU	;IS THIS ANYTHING IN THE QUEUE
	 JRST QUEDN1		;NO

QUELOP:	MOVE P2,P1		;GET ADDRESS OF NEXT BLOCK
	ANDI P2,777		;GET LOW ORDER BITS ONLY
	MOVE T1,P1		;NOW MAP IN THE PAGE WITH THE BLOCK
	LSH T1,-PGSFT		;CONVERT TO A PAGE NUMBER
	CALL DMPRED		;READ A PAGE FROM THE DUMP
	 JRST QUEDON		;HANDLER ERRORS
	MOVEI T1,TMPADR(P2)	;GET ADDRESS OF START OF BLOCK
	LOAD T2,SEBSIZ,(T1)	;GET SIZE OF BLOCK
	ADDI T1,SEBHED		;DONT STORE HEADER
	SUBI T2,SEBHED
	SOS T2
	DMOVE T3,0(T1)		;GET FIRST TWO WORDS
	DMOVEM T3,SYSERR
	DMOVE T3,2(T1)		;AND THE NEXT TWO WORDS
	DMOVEM T3,SYSERR+2
	MOVE T3,T1
	ADDI T3,5		;POINT PAST THE HEADER
	MOVSS T3,T3		;LEFT HALF FOR BLT
	HRRI T3,SYSERR+4	;SET RIGHT HALF
	BLT T3,SYSERR-5(T2)
	MOVEI T1,SYSERR
	SYERR			;PUT THIS BLOCK INTO ERROR LOG
	 ERJMP .+1		;IGNORE ERRORS
	MOVE P1,TMPADR(P2)	;GET ADDRESS OF NEXT BLOCK
	JUMPN P1,QUELOP		;IF ONE THERE, GO PROCESS IT

QUEDN1:
	MOVE T1,[SIXBIT /APRID/] ;GET APRID OF PROCESSOR
	SYSGT			;TO DETERMINE KS10
	CAIG T1,^D4096		;IF GT 4096. THEN KS12
	JRST QUEDON		;NO -- DON'T NEED HSB
	SETZ T1,		;PAGE ZERO
	CALL DMPRED		;READ IN A DUMP FILE
	 JRST QUEDON		;HANDLE ERRORS
	MOVEI T1,SEC%HS		;SET UP LOGGING CODE
	STOR T1,SEBERC
	DMOVE T1,TMPADR		;GET FIRST TWO WORDS OF DUMP (PHYSICAL 0,1
	DMOVEM T1,HS%COD+4+HSBBUF	;STORE IN BUFFER
	MOVE T1,[-HS%HSZ,,HS%HDZ]	;POINTER TO BUFFER
	MOVEM T1,HS%PTR+4+HSBBUF	;BUFFER
	MOVE T1,[PG0ADR+HSBADR,,HSBBUF+4+HS%HDZ] ;MOVE TO BUFFER
	BLT T1,HSBBUF+4+HS%HSZ	;BLT LOW CORE DATA
	MOVEI T1,HSBBUF		;SYSERR OUTPUT BUFFER
	MOVEI T2,HS%LEN
	SYERR			;OUTPUT ERROR
	 ERJMP .+1		;[7.1081] Ignore errors
	SUBTTL System Dumps -- Process a Dump -- Finish Up

;[7.1081] Here to unmap pages, kill fork, close JFNs, and return
;Sets the DUMP.EXE file as "copied"

QUEDON:				;[7.1081] Start of cleanup/exit code
  IFN FTSC,<			;[7.1081]
	CALL SETCNT		;[7.1081] Set SPEAR count if needed
  >				;[7.1081]
	SKIPN QUEJFN		;[7.1081] Did we get a open JFN on DUMP.EXE?
	RET			;[7.1081] No, return now
	SKIPE QUEFAD		;[7.1081] If a flag address is used
	SETOM @QUEFAD		;[7.1081] Now mark that we have copied it
	SETO T1,		;[7.1081] Unmap that page 
	MOVE T2,[.FHSLF,,PG0PG]	;[7.1081] Do all of the pages we need
	MOVX T3,PM%CNT!<ENDPG-PG0PG> ;[7.1081] Unmap all of these pages
	PMAP			;[7.1081] Zap
	 ERJMP .+1		;[7.1081] We certainly don't care now
	CALL FLUSH		;[7.1081] () Flush incore copy to disk
	SKIPE T1,QUEJFN		;[7.1081] Skip if no JFN to close
	CLOSF%			;[7.1081] Yes, close it
	 JSYERR (<Can't close JFN for DUMP.EXE>) ;[7.1081] Entered garkland
	RET			;ALL DONE
	SUBTTL System Dumps -- Process a Dump -- Flush Incore Pages

;[7.1081] Small routine to flush incore pages to disk.  This is needed since
;[7.1081] DOB code writes directly to disk.  We have to make sure that we get a
;[7.1081] copy from disk and not from any copy that is still in memory.

FLUSH:	MOVE T1,QUEJFN		;[7.1081] Load the JFN of DUMP.EXE
	SIZEF%			;[7.1081] Get the size of that file
	 JSYERR (<Can't get size of DUMP.EXE file>)
	MOVEM T3,QUESIZ		;[7.1081] Save size of the DUMP.EXE file
	HRLZ T1,QUEJFN		;[7.1081] Load JFN of DUMP.EXE,,page 0
	MOVE T2,T3		;[7.1081] Get count of pages to update
	TXO T2,UF%FSH		;[7.1081] Don't keep incore copy
	UFPGS%			;[7.1081] Flush incore copy of these pages
	 JSYERR (<Can't flush pages of DUMP.EXE before mapping>) ;[7.1081] Owie
	RET			;[7.1081] Always return
	SUBTTL System Dumps -- Process a Dump -- Set SPEAR Entry Count

  IFN FTSC,<			;[7.1081]
;SETCNT - Called when the running count of SPEAR entries is not found
;	   in DUMP.EXE, we didn't take a DUMP, or any one of numerous
;	   JSYS errors which may of occurred.
;SETZER - Alternate entry point to set count to zero
;Returns +1 always

SETCNT:	SKIPE SCDONE		;[7.1081] Already done this?
	RET			;[7.1081] Yes, return now
	MOVX T1,<GJ%OLD!GJ%DEL!GJ%SHT>
	HRROI T2,[ASCIZ/SERR:ERROR.SYS/]
	GTJFN%			
	IFNSK.			;[7.1081] If an error
	  CAIN 1,GJFX24		;[7.1081] File not found?
	  IFSKP.		;[7.1081] No
	    HRROI T1,[ASCIZ/GTJFN% failed on SERR:ERROR.SYS/] ;[7.1249]
	    CALL JSYER1		;[7.1081] (T1/) Output error code
	    JRST SETZER		;[7.1081] Zero the count
	  ELSE.			;[7.1081] 
	    CALL STARS		;[7.1081] 
	    TMSG <%SETSPD: Could not set SPEAR entry count from SERR:ERROR.SYS because file was not present, resynching from zero.> ;[7.1081] 
SETZER:	    SETZ T3,		;[7.1081] Synch to zero
	    JRST SETCN2		;[7.1081]  set it and forget it
	  ENDIF.		;[7.1081] 
	ENDIF.			;[7.1081] 
	HRRZS T1
	MOVX T2,<OF%RD!OF%PLN>
	OPENF%
	 JSYERR (<OPENF% failed on SERR:ERROR.SYS>,<JRST SETZER>) ;[7.1081] 
	MOVEM T1,TMPJFN		;[7.1081] Save JFN
	FFFFP			;FIND FIRST FREE PAGE ON ERROR.SYS
	SUBI T1,1		;T1 IS NOW THE LAST USED PAGE
	MOVE T2,[.FHSLF,,ESYPG]
	MOVX T3,<PM%RD!PM%PLD>
	PMAP%			;MAP IT IN
	 JSYERR (<PMAP% failed from SERR:ERROR.SYS>,<JRST SETZER>)

	HRRZ T1,ESYSAD		;GET FIRST RESYNC ENTRY ON THIS PAGE
	SKIPE T3,ESYSAD+ESYCNT(T1) ;IS THE SPRCNT ZERO?
	IFSKP.			;YES, TELL WORLD AND RESYNC
	  CALL STARS		;[7.1081] Output stars
	  TMSG <%SETSPD: SPEAR entry count = 0 in ERROR.SYS, resynching to 0> ;[7.1081] 
	  CALL STARS		;[7.1081] 
	ELSE.			;NO, THEN SEE IF WE CAN GET A HIGHER VALUE
	  HRRZ T1,ESYSAD+200	;THIS IS THE SECOND ONE
	  JUMPE T1,SETCN1	;IF ZERO, USE WHAT WE HAVE
	  MOVE T3,ESYSAD+ESYCNT+200(T1) ;NOT ZERO, LOOK FOR HIGHER
	  HRRZ T1,ESYSAD+400	;THIS IS THE THIRD RESYNC ENTRY
	  JUMPE T1,SETCN1	; ..
	  MOVE T3,ESYSAD+ESYCNT+400(T1) ;KEEP LOOKING
	  HRRZ T1,ESYSAD+600
	  JUMPE T1,SETCN1
	  MOVE T3,ESYSAD+ESYCNT+600(T1) ;THIS IS THE LAST ONE
SETCN1:	  ADDI T3,^D22		;ADD IN ENOUGH ENTRIES THAT FIT IN 200 WORDS
	ENDIF.
				;IF ANYONE WANTS TO FIND THE LAST POSSIBLE
				;VALUE, THEN BE MY GUEST.
SETCN2:	SETO T1,		;[7.1081] Must close ERROR.SYS, count in T3
	MOVE T2,[.FHSLF,,ESYPG]
	PMAP%			;UNMAP FILE...
	 JSYERR (<PMAP% unmap of SERR:ERROR.SYS failed>,<JRST SPRSET>) ;[7.1081] 
	SKIPE T1,TMPJFN		;[7.1081] Skip if any JFN opened
	CLOSF%			;AND CLOSE IT!
	 JSYERR (<CLOSF% failed on SERR:ERROR.SYS>,<JRST SPRSET>) ;[7.1081] 

;[7.1081] Set the SPEAR error count from T3

SPRSET:	MOVEI T2,(T3)		;GET COUNT 
	MOVEI T1,.SFSPR		;GET FUNCTION CODE FOR SMON%
	SMON%			;ADD OLD COUNT INTO CURRENT COPY OF MONITOR
	 JSYERR (<SMON% failed to set SPEAR error counter>) ;[7.1081] 
	SETOM SCDONE		;[7.1081] Don't do it twice
	RET			;[7.1081] Return
   >				;[7.1081] Removal of SPRCNT code
	SUBTTL System Dumps -- Process a Dump -- Map Dump File to Read SYSERR Blocks

;DMPMAP	IS THE ROUTINE TO BUILD DUMP FILE MAP, DETERMINE MMAP PAGE
;	AND READ IN MMAP PAGE

DMPMAP:
	HRRZ T1,QUEJFN		;GET THE DUMP FILE JFN
	SETZ T2,		;POINT TO THE FIRST BYTE IN THE FILE
	SFPTR			;SET FILE POINTER
	 ERJMP DMPMER		;HANDLE ERRORS
	HRRZ T1,QUEJFN		;GET THE JFN
	BIN			;GET A BYTE FROM THE FILE
	 ERJMP DMPMER		;HANDLE ERRORS
	HLRZS T2		;GET THE ENTRY CODE
	CAIE T2,1776		;IS THIS AN EXE FILE?
	 JRST DMPMBD		;NO SO THIS IS BAD
DMPMLP:				;THIS IS THE MAPPING LOOP
	HRRZ T1,QUEJFN		;GET THE JFN
	BIN			;GET THE NEXT WORD
	 ERJMP DMPMER		;HANDLE ERROR
	MOVE P1,T2		;SAVE THE FIRST WORD
	HLRZS T2		;ZERO THE LEFT HALF
	CAIE T2,1775		;ENTRY VECTOR?
	 CAIN T1,1777		;END OF DIRECTORY?
	  JRST DMPMDN		;YES SO MAPPING PROCESS IS DONE
	BIN			;NOT END SO GET SECOND WORD OF GROUP
	 ERJMP DMPMER		;HANDLE ERRORS
	MOVE P2,T2		;SAVE THE SECOND WORD
	LDB T1,[POINT 27,P1,35]	;GET THE FILE PAGE NUMBER
	LDB T2,[POINT 27,P2,35]	;GET THE CORE PAGE NUMBER
	LDB T3,[POINT 9,P2,8]	;GET THE REPEAT COUNT
DMPML2:				;INNER PAGE MAP LOOP
	MOVEM T1,MAPADR(T2)	;SAVE THE PAGE NUMBER IN MAP
	MOVEM T2,PAGMAX		;SAVE THE MAX PAGE NUMBER
	AOJ T1,			;BUMP FILE PAGE
	AOJ T2,			;BUMP CORE PAGE
	SOJGE T3,DMPML2		;LOOP FOR THE REPEAT COUNT
	JRST DMPMLP		;DONE WITH THIS GROUP SO GET NEXT
DMPMDN:				;HERE WHEN MAPPING IS DONE
	HRRZ T1,QUEJFN		;GET THE JFN
	MOVEI T2,MSECWD		;POINTER TO MSECTB
	CALL READIN		;GET FROM DUMP
	MOVEM T2,MSCADR		;SAVE ADDRESS OF MSECTB
	MOVEI T2,SPTWD		;POINTER TO SPT
	CALL READIN		;GET FROM DUMP
	MOVEM T2,SPTADR		;SAVE ADDRESS OF SPT
	SETOM T2		;ALL ONES
	MOVEM T2,SECTN		;CURRENTLY MAPPED SECTION (I.E. NONE YET)
	AOS (P)			;BUMP THE RETURN ADDRESS
DMPMER:				;HERE ON ERROR DURING MAPPING
DMPMBD:				;HERE ON BAD EXE FILEE DIRECTORY
	RET			;RETURN TO CALLER

; MAPSEC IS THE ROUTINE TO MAP A SECTION MAP FROM THE DUMP FILE

MAPSEC:				;T2/ SECTION NUMBER TO MAP
	STKVAR <SEC>
	MOVEM T2,SEC
	SETO T1,		;UNMAP FUNCTION
	MOVX T2,<.FHSLF,,MMPPG>	;SECTION MAP PAGE
	MOVX T3,<PM%CNT!<1>B35>	;UNMAP ONE PAGE
	PMAP
	 ERJMP .+1		;IGNORE ERRROS
	MOVE T2,SEC
	ADD T2,MSCADR		;SECTION POINTER FOR DESIRED SECTION
	CALL READIN		;GET FROM DUMP
	LOAD T4,PTRCOD,T2	;GET POINTER TYPE
	CAIE T4,2		;IS IT A SHARE POINTER?
	 JRST DMPMBD		;NO, BAD DUMP
	LOAD T4,SPTX,T2		;YES, GET SPT OFFSET
	MOVE T2,SPTADR		;ADDRESS OF SPT
	ADD T2,T4		;LOCATION OF STORAGE ADDRESS
	CALL READIN		;GET FROM DUMP
	LOAD T2,STGADR,T2	;HERE IS PAGE OF MMAP
	SKIPN T1,MAPADR(T2)	;GET THE FILE PAGE OF MMAP PAGE
	 JRST DMPMBD		;BAD EXE FILE IF NO PAGE
	HRL T1,QUEJFN		;GET THE JFN
	MOVX T2,<.FHSLF,,MMPPG>	;PUT THE PAGE AT THE MMAP PAGE
	MOVX T3,<PM%RD>		;WE ONLY WANT TO READ THIS PAGE
	PMAP			;MAP IN THE PAGE
	 ERJMP DMPMER		;HANDLE ERROR
	MOVE T2,SEC		;GET SECTION
	MOVEM T2,SECTN		;SET CURRENTLY MAPPED SECTION
	RETSKP

; READIT IS THE ROUTINE TO READ THE CONTENTS OF A PARTICULAR WORD
;	OUT OF THE DUMP FILE. 

READIN:				;T2/ ADDRESS OF WORD
	HRRZ T1,QUEJFN		;DUMP FILE JFN
	MOVE T4,T2		;GET COPY
	ANDI T4,777		;GET OFFSET
	LSH T2,-9		;GET PAGE NUMBER
	MOVE T3,MAPADR(T2)	;FIND CORRESPONDING PAGE IN DUMP
	LSH T3,PGSFT		;FORM ADDRESS
	ADD T3,T4		;ADD IN OFFSET
	RIN			;READ WORD
	 ERJMP DMPMER		;ERROR
	SKIPG T2		;ANYTHING RETURNED?
	 JRST DMPMBD		;NO, THEN BAD DUMP
	RET			;RETURN WORD IN T2

;DMPRED	IS THE ROUTINE TO MAP PAGES FROM CRASHED MONITOR VIRTUAL
;	ADDRESS SPACE

DMPRED:				;ROUTINE TO MAP DUMP PAGES
				;T1/ PAGE NUMBER OF MONITOR
	STKVAR <MPAGE>
	MOVEM T1,MPAGE		;SAVE THE MONITOR PAGE NUMBER
	SETO T1,		;UNMAP FUNCTION
	MOVX T2,<.FHSLF,,TMPPG>	;TEMP PAGE ONE
	MOVX T3,<PM%CNT!<2>B35>	;UNMAP TWO PAGES
	PMAP			;UNMAP IO PAGES
	 ERJMP .+1		;IGNORE ERRROS
	LDB T2,[<POINT 9,MPAGE,26>] ;GET SECTION NUMBER
	CAMN T2,SECTN		;SECTION MAPPED?
	IFSKP.
	 CALL MAPSEC		;NO, MAP SECTION FIRST
	  JRST DMPRDB		;BAD EXE FILE RETURN
	 ENDIF.
	MOVE T1,MPAGE
	ANDI T1,777		;GET PAGHE IN SECTION
	MOVEI T2,TMPPG		;GET THE PAGE TO TARGET PAGE
	CALL DMPRD2		;CALL THE WORKER ROUTINE
	 JRST DMPRDB		;BAD EXE FILE RETURN
	MOVE T1,MPAGE		;GET THE MONITOR PAGE AGAIN
	ADDI T1,1		;WE WANT THE NEXT PAGE
	MOVEI T2,TMPPG+1	;MAP THE PAGE TO THE NEXT TARGET PAGE
	CALL DMPRD2		;CALL THE WORKER ROUTINE
	 JFCL			;ERROR IS OK
	AOS (P)			;BUMP THE RETURN PC
DMPRDB:				;BAD EXE FILE RETURN
	RET			;RETURN TO CALLER

DMPRD2:				;WORKER ROUTINE FOR DMPRED
	LDB T3,[POINT 3,MMPADR(T1),2] ;GET THE POINTER TYPE FOR PAGE
	CAIE T3,1		;IMMEDIATE?
	 RET			;NO SO LOSE
	HRRZ T1,MMPADR(T1)	;GET THE PHYSICAL PAGE NUMBER
	CAMLE T1,PAGMAX		;IS IT A LEGAL PAGE?
	 RET			;NO SO ERROR RETURN
	SKIPN T1,MAPADR(T1)	;GET THE FILE PAGE NUMBER
	 RET			;IF ZERO THEN ERROR RETURN
	HRL T1,QUEJFN		;GET THE DUMP FILE JFN
	HRLI T2,.FHSLF		;THIS FORK
	PMAP			;MAP THE PAGE
	 ERJMP R		;[7.1081] Return +1 for error
	RETSKP			;[7.1081] Skip return
	SUBTTL System Dumps -- Process a Dump -- Copy A Single Dump

;CPYDMP - ROUTINE TO COPY <SYSTEM>DUMP.EXE TO <SYSTEM>DUMP.CPY
;
;ACCEPTS IN T1/	JFN OF ORIGINAL DUMP FILE
;	    T2/	# OF FILE PAGES TO COPY
;		CALL CPYDMP
;RETURNS: +1 ALWAYS

CPYDMP:	STKVAR <DMPJFN,DMPCNT,CPYJFN,CPYSIZ>
	MOVEM T1,DMPJFN		;SAVE JFN OF ORIGINAL DUMP FILE
	MOVEM T2,DMPCNT		;SAVE # OF FILE PAGES TO COPY
	IMULI T2,1000		;COMPUTE # OF WORDS TO BE COPIED
	SUBI T2,1		;COMPUTE # OF LAST WORD IN COPY FILE
	MOVEM T2,CPYSIZ		;SAVE # OF WORDS IN FILE
	CALL STRMOU		;Mount the disk DMP: implies
	CALL CRENAM		;[7.1081] () Go create the output filename	
	CALL CLRGTJ		;[7.1081] () Clear GTJFN block
	MOVX T1,GJ%FOU		;[7.1081] Get a JFN on next higher generation
	MOVEM T1,GTJBLK+.GJGEN	;[7.1081] Store flags in the block
	HRROI T1,DMPSTR		;[7.1081] Point to device name implied by DMP:
	MOVEM T1,GTJBLK+.GJDEV	;[7.1081] Store it in the arg block
	HRROI T1,DMPDIR		;[7.1081] Point to dir name implied by DMP:
	MOVEM T1,GTJBLK+.GJDIR	;[7.1081] Store it
	HRROI T1,[ASCIZ/DUMP/]	;[7.1081] Get a pointer to the default filename
	MOVEM T1,GTJBLK+.GJNAM	;[7.1081] Store it in the block
	HRROI T1,[ASCIZ/CPY/]	;[7.1081] Get a pointer to the file type
	MOVEM T1,GTJBLK+.GJEXT	;[7.1081] Store it
	MOVX T1,<.NULIO,,.NULIO> ;[7.1081] Setup input/output JFNs 
	MOVEM T1,GTJBLK+.GJSRC	;[7.1081]   in the arg block
	MOVEI T1,GTJATR		;[7.1081] Point to attribute block
	MOVEM T1,GTJBLK+.GJATR	;[7.1081] Store it in GTJFN block
	MOVEI T1,2		;[7.1081] Size of attribute block
	HRROI T2,[ASCIZ/P770000/] ;[7.1081] Point to the file protection
	DMOVEM T1,GTJATR	;[7.1081] Store size and pointer in the block

;[7.1249] Long form block is all set up now, try to get a JFN on the CPY file.
;If this fails, then try BS:<SYSTEM> and the same filename.

	MOVEI T1,GTJBLK		;[7.1081] Point to the GTJFN block
	HRROI T2,FILNAM		;[7.1081] Use the name created by CRENAM
	GTJFN%			;[7.1081] Try that file
	ERJMP CPYD01		;[7.1249] Can't use that one
	JRST CPYD07		;[7.1249] OK, ready to go

CPYD01:	HRROI T1,[ASCIZ/BS/]	;[7.1249] Point to the usual str for dumps
	MOVEM T1,GTJBLK+.GJDEV	;[7.1249] Store it in the arg block
	HRROI T1,[ASCIZ/SYSTEM/] ;[7.1249] Point to usual area for dumps
	MOVEM T1,GTJBLK+.GJDIR	;[7.1249] Store it
	MOVEI T1,GTJBLK		;[7.1081] Point to block again
	HRROI T2,FILNAM		;[7.1249] Point to the filename again please
	GTJFN%			;[7.1081] Try alternate destination
	ERJMP DMPERR		;[7.1249] Jump if error
	JRST CPYD07		;[7.1249] We got the alternate filename

;[7.1249] Here if error copying the dump file, print message and abort copy

DMPERR:	HRROI T1,[ASCIZ/Failed to copy dump file/] ;[7.1249] Error string 
	CALL JSYER1		;[7.1081] () Output error message and why
	CALL UMPPGS		;UNMAP DUMP PAGES
	SKIPN CPYJFN		;[7.1081] Check for DUMP.CPY JFN (TCO 6.1241)
	IFSKP.			;[7.1081] There is a JFN
	  MOVX T1,CZ%ABT	;GET THE ABORT BIT FOR CLOSF
	  HRR T1,CPYJFN		;GET THE JFN FOR CLOSF
	  CLOSF			;CLOSE THE DUMP.CPY FILE
	  ERJMP .+1		;ERROR PROBABLY MEANS NOT OPEN
	ENDIF.
	CALL STRDIS		;Dismount a structure if need be
	RET			;RETURN

;We now have a JFN for both input an output files, print a little message 
;before starting the dump copy.

CPYD07:	MOVEM T1,CPYJFN		;[7.1249] Save JFN of DUMP.CPY
	MOVE T2,[FLD(^D36,OF%BSZ)!OF%RD+OF%WR] ;[7.1081] 
	OPENF			;OPEN THE COPY FILE
	 JRST DMPERR		;FAILED
	HRLI T1,.FBBYV		;CHANGE PROPER WORD
	MOVX T2,FB%RET		;SET THE RETENTION COUNT
	SETZ T3,		; TO INFINITY
	CHFDB			;DO IT
	ERJMP .+1		;IGNORE ANY ERRORS
	HRROI T1,[ASCIZ /
Copying system dump
	from: /]		;[7.1081] Assume system startup dump
	PSOUT%			;[7.1081] Print that on CTY
	MOVEI T1,.PRIOU		;[7.1081] Point output to terminal
	MOVE T2,QUEJFN		;[7.1081] Get JFN of source file
	MOVX T3,JFNSFL		;[7.1081] Load JFNS% flags
	JFNS%			;[7.1081] Output the the file name
	 ERJMP .+1		;[7.1081] Ignore errors
	SETZ T3,		;[7.1081] Terminate on null
	HRROI T2,[ASCIZ/
	to:   /]		;[7.1081] Label the other filename
	SOUT%			;[7.1081]  on the terminal
	 ERJMP .+1		;[7.1081] Ignore errors
	HRROI T1,FILNAM		;[7.1249] Point back to the filename area
	MOVE T2,CPYJFN		;[7.1081] Get JFN of DUMP.CPY file
	MOVX T3,JFNSFL		;[7.1081] Load JFNS% flags
	JFNS%			;[7.1081] Output that to terminal
	 ERJMP .+1		;[7.1081] Ignore errors
	HRROI T1,FILNAM		;[7.1249] Point to filename again
	PSOUT%			;[7.1249] Output that filename
	TMSG <
>				;[7.1081] Make the output look neat

; SET UP TO COPY THE FILE

	SETZM T4		;START WITH FILE PAGE 0
CPYD10:	MOVE T1,DMPCNT		;GET # OF PAGES TO COPY
	JUMPLE T1,CPYD20	;IF DONE, GO UNMAP THE PAGES
	SUBI T1,CPYPGS		;COMPUTE # OF PAGES LEFT TO COPY
	MOVEM T1,DMPCNT		;SAVE NEW # OF PAGES TO COPY
	HRL T1,DMPJFN		;GET JFN OF ORIGINAL DUMP FILE
	HRR T1,T4		;GET FILE PAGE NUMBER
	MOVE T2,[.FHSLF,,DMPPG]	;THIS FORK, FIRST PAGE TO MAP DUMP FILE
	MOVEI T3,CPYPGS		;GET # OF PAGES TO MAP
	SKIPGE DMPCNT		;NEED TO MAP LESS THAN THIS MANY ?
	ADD T3,DMPCNT		;YES, COMPUTE # REMAINING TO BE MAPPED
	TXO T3,PM%RD+PM%WR+PM%PLD+PM%CNT
	PMAP			;MAP THE PAGES FROM THE ORIGINAL FILE
	 ERJMP DMPERR		;JUST IN CASE
	HRL T1,CPYJFN		;GET JFN OF COPY FILE
	HRR T1,T4		;GET FILE PAGE NUMBER
	MOVE T2,[.FHSLF,,CPYPG]	;THIS FORK, FIRST PAGE OF COPY FILE DATA
	TXZ T3,PM%PLD		;NO PRE-LOADING
	PMAP			;MAP THE COPY FILE
	 ERJMP DMPERR		;JUST IN CASE
	MOVE T1,[DMPADR,,CPYADR] ;SET UP TO COPY DATA
	BLT T1,CPYADR+CPYWDS-1	;COPY DATA
	ERJMP DMPERR		;IN CASE DISK IS FULL.
	ADDI T4,CPYPGS		;COMPUTE ADDRESS OF NEXT FILE PAGE
	JRST CPYD10		;LOOP OVER ALL PAGES TO COPY

; HERE WHEN COPY IS COMPLETE

CPYD20:	CALL UMPPGS		;UNMAP DUMP PAGES
	HRRZ T1,CPYJFN		;GET JFN OF NEW FILE
	HRLI T1,.FBSIZ		;GET OFFSET TO EOF POINTER
	SETOM T2		;CHANGE ALL BITS IN THE WORD
	MOVE T3,CPYSIZ		;GET # OF LAST WORD IN FILE
	CHFDB			;SET THE EOF POINTER
	HRRZ T1,CPYJFN		;GET JFN OF COPY FILE
	CLOSF			;CLOSE NEW FILE
	 JRST DMPERR		;FAILED, REPORT ERROR

;[7.1244] We were successful in our expectation of the copy without error.

	TMSG <
[Copied dump to >		;[7.1249] Start the message
	HRROI T1,FILNAM		;[7.1249] Point to filename string again
	PSOUT			;[7.1249] Output it 
	TMSG <]
>				;[7.1249] Finish up that message
	CALL STRDIS		;Get rid of the structure if need be
	RET			;RETURN

;ROUTINE TO UNMAP DUMP PAGES ON NORMAL COMPLETION OR ERROR

UMPPGS:	SETOM T1		;UNMAP THE PAGES
	MOVE T2,[.FHSLF,,DMPPG]	;PAGES MAPPED TO ORIGINAL FILE
	MOVE T3,[PM%CNT+CPYPGS]	;NUMBER OF PAGES TO UNMAP
	PMAP			;UNMAP THE PAGES
	MOVE T2,[.FHSLF,,CPYPG]	;PAGES MAPPED TO COPY FILE
	PMAP			;UNMAP THE PAGES
	RET			;AND DONE
	SUBTTL System Dumps -- Process a Dump -- Mount Dump Structures

;Routine to mount the structure (all of it) that is implied by the expansion
;of DMP:.

STRMOU:	MOVEI T1,RTYTIM		;[7.1081] Get number of retry times
	MOVEM T1,TIMVAL		;this is for CI disks
STRRTY:				;here is our retry entry point
	MOVX T1,.LNSSY		;Lookup a system-wide logical name 
	HRROI T2,[ASCIZ |DMP|]	;Logical name without colon
	SETZ T3,		;We don't want the translation
	LNMST			;See if a logical name DMP:
	 RET			;Return now if no DMP:
	MOVX T1,<GJ%SHT!GJ%OFG>	;This is the short form and parse only
	HRROI T2,[ASCIZ |DMP:|]	;Logical name for dump structure
	GTJFN			;Get a parse only JFN on DMP:
	 RET			;If it fails, leave now
	HRRZM T1,T2		;Set up the JDN in the right place
	HRROI T1,DMPSTR		;Loc for the name of the structure
	MOVX T3,FLD(.JSAOF,JS%DEV) ;Only output device field
	SETZ T4,		;No file attribute
	JFNS%			;Get the device implied by DMP:
	 ERJMP R		;[7.1081] Fail and try default
	HRROI T1,DMPDIR		;[7.1081] Get the directory implied by DMP:
	MOVX T3,FLD(.JSAOF,JS%DIR) ;[7.1081] Do directory field 
	JFNS%			;[7.1081] Get the directory name
	 ERJMP R		;[7.1081] Forget it
	HRROI T1,DMPSTR		;Point to that structure name
	STDEV			;String to device designator
	IFSKP.			;[7.1081] If it worked
	  HRROI T1,DMPSTR	;[7.1081] Point to structure name
	  MOVEM T1,MSTRAD+.MSDEV ;[7.1081] Store it in MSTR block
	  MOVE T1,[XWD .MSJOB,.MSIMC] ;[7.1081] Length,,Function
	  MOVEI T2,MSTRAD	;[7.1081] Point to MSTR block
	  MSTR%			;[7.1081] Increment the mount count 
	   ERJMP .+2		;[7.1081] Not necessary, don't set flag
	  SETOM CPYINC		;[7.1081] Say we incremented the mount count
	  RET			;[7.1081]  and return
	ENDIF.	

;Here when we have real work to do. Loop over all disks looking for all units
;in the dump structure.

	SETOM MSTRAD+.MSRCH	;Start with the first unit
	SETOM MSTRAD+.MSRCT	;  and the first controller
	SETOM MSTRAD+.MSRUN	;  and the first unit
DSKLOP:	MOVE T1,[XWD .MSRLN,.MSRNU] ;Length of args,,function code
	MOVEI T2,MSTRAD		;Address of the MSTR block
	HRROI T3,CURSTR		;Byte pointer to the name of current structure
	MOVEM T3,MSTRAD+.MSRSN	;Store in the arg block
	HRROI T3,ALISTR		;Byte pointer to current structure alias
	MOVEM T3,MSTRAD+.MSRSA	;Store it in the arg block
	MSTR			;Get disk info
	 ERJMP MSTRER		;Handle an MSTR failure
	HRROI T1,CURSTR		;Get the name of the current structure
	HRROI T2,DMPSTR		;Is this the one we seek (Sorry)
	STCMP			;Compare the strings
	SKIPN T1		;Are the strings the same???
	 JRST FNDSTR		;We have found the structure, go mount it
	JRST DSKLOP		;Loop for more disks

; Here when we have found the disk name we are looking for and are ready to
;mount the critter. But first we must loop to find the other units and build
;the mount block.

FNDSTR:	HRRZ T1,MSTRAD+.MSRNS	;Get the number of units in this structure
	MOVEM T1,NUMUNT		;Store
	MOVEM T1,UNTLFT		;Also store as the number of units left to find
UNTLOP:	SOS UNTLFT		;Show that we have touched this unit
	HLRZ T1,MSTRAD+.MSRNS	;Get the unit number within the structure
	IMULI T1,.MSTNO		;Multiply by the block size to get the offset
	ADDI T1,<MNTBLK+.MSTUI>	;Now make it the base addr of the unit block
	MOVE T2,MSTRAD+.MSRCH	;Get the channel number
	MOVEM T2,.MSTCH(T1)	;Store the channel number in the unit block
	MOVE T2,MSTRAD+.MSRCT	;Get the controller number
	MOVEM T2,.MSTCT(T1)	;Store in unit block
	MOVE T2,MSTRAD+.MSRUN	;Get the unit number
	MOVEM T2,.MSTUN(T1)	;Store in the unit block
	SKIPG UNTLFT		;Are there any more units left to be done???
	 JRST MNTDSK		;No, mount the disk
NXTUNT:	MOVE T1,[XWD .MSRLN,.MSRNU] ;Arg block len,,function code
	MOVEI T2,MSTRAD		;Point to the arg block
        HRROI T3,CURSTR         ; Re-initialize the string 
        MOVEM T3,MSTRAD+.MSRSN  ;   pointers for the structure name
        HRROI T3,ALISTR         ;     and alias
        MOVEM T3,MSTRAD+.MSRSA  ;       before comparing each unit
	MSTR			;Get the status of the next unit
	 ERJMP MSTRER		;handle an MSTR failure
	HRROI T1,DMPSTR		;Get the name of the dump structure
	HRROI T2,CURSTR		;Do they match???
	STCMP			;Compare the strings
	SKIPE T1		;Do they match???
	 JRST NXTUNT		;No, dont count this one in unit list
	JRST UNTLOP		;Loop to get all the units

; Here to mount the disk (at last)...

MNTDSK:	MOVEI T1,.MSTNO		;Get the length of the unit blocks
	IMUL T1,NUMUNT		;Multiply by the number of units
	ADDI T1,.MSTFL+1	;Add the overhead words
	HRLZS T1		;Move the length to the left half
	HRRI T1,.MSMNT		;Add the function code
	MOVEI T2,MNTBLK		;Point to the nase of the mount block
	HRROI T3,DMPSTR		;Byte pointer to structure name
	MOVEM T3,MNTBLK+.MSTNM	;Store in the arg block
	MOVEM T3,MNTBLK+.MSTAL	;Store as the alias as well
;	MOVX T3,<MS%XCL>	;Flag for making disk my very own, for me alone
	MOVE T3,NUMUNT		;Get the number of units in the structure
	MOVEM T3,MNTBLK+.MSTFL	;Store in the mount block
	MSTR			;Mount the structure
	 ERJMP MSTRER		;Handle MSTR errors
	SETOM STRFLG		;Set flag that we have a structure to dismount
	HRROI T1,DMPSTR		;Point to the structure name
	MOVEM T1,MSTRAD		;Store pointer in arg block
	MOVE T1,[XWD .MSDEV+1,.MSIMC] ;Setup MSTR AC, Arg len,arg block addr
	MSTR			;Increment structure mount count
	 ERJMP MSTRER		;Handle MSTR errors
	RET			;And return

; Here on MSTR errors. We expect to see no more units but
;others are fatal to copying the dump if this is the structure we are trying
;to copy to.

MSTRER:	CALL GETERR		;[7.1081] (/T2) Get last error
	CAIN T2,MSTX18		;[7.1081] No more units in system
	SOSGE T1,TIMVAL		;[7.1081] Yes, retries exhausted?
	JRST MSTRE1		;[7.1249] Yes
	CAIE T1,RTYTIM-1	;[7.1081] Is this our first retry?
	IFSKP.			;[7.1081] If so, warn of retry delays..
	  TMSG <
%SETSPD: Waiting to see if dump structure comes online...
>				;[7.1249] Output a message for operator
	ENDIF.			;[7.1081] 
	MOVEI T1,^D1000		;[7.1081] Yes, sleep for 1 second
	DISMS%			;[7.1081] Zzz...
	JRST STRRTY		;[7.1081] Go back and retry

MSTRE1:	TMSG (<
%SETSPD: Could not find dump structure, trying BS:<SYSTEM>
>)				;[7.1249] Give another warning message
	RET			;[7.1249] And return
	SUBTTL System Dumps -- Process a Dump -- Dismount Dump Structures

;[7.1081] EXEDEC/CPYDEC
;Decrement mount count of a structure:
; 	EXEDEC - structure that DUMP.EXE came from
; 	CPYDEC - structure that DUMP.CPY was written to

CPYDEC:	SETZM CPYINC		;[7.1081] Say we decremented the count
	MOVX T1,<POINT 7,DMPSTR> ;[7.1081] Point to structure name
	JRST DECCNT		;[7.1081] Join common code

EXEDEC:	SETZM EXEINC		;[7.1081] Say we decremented it
	MOVX T1,<POINT 7,STRNAM> ;[7.1081] Point to structure name

DECCNT:	MOVEM T1,MSTRAD+.MSDEV	;[7.1081] Store pointer in MSTR block
	SETOM T1		;[7.1081] We want to release any unopened JFNs 
	RLJFN%			;[7.1081]  may (like the GTJFN in STRMOU)
	 ERJMP .+1		;[7.1081] Don't care
	MOVX T1,<.MSDEV+1,,.MSDMC> ;[7.1081] Size,,Function
	MOVEI T2,MSTRAD		;[7.1081] Point to MSTR block
	MSTR%			;[7.1081] Decrement the mount count
	ERJMP .+1		;[7.1081] Forget this error
	RET			;[7.1081] Return

;STRDIS - Dismount a structure we copied a dump to (DMPSTR).

STRDIS:	SKIPN STRFLG		;Is there a structure to dismount???
	 RET			;No, return no, nothing to do here
	MOVE T1,[XWD <.MSDNM+1>,.MSDIS]	;Length,,function code for MSTR
	MOVEI T2,MSTRAD		;Pointer to arg block
	HRROI T3,DMPSTR		;Point to structure to be dismounted
	MOVEM T3,MSTRAD		;Store in the arg block
	MSTR			;Dismount the structure
	 ERJMP MSTRER		;Handle MSTR errors
	SETZM STRFLG		;Say we dismounted the structure
	RET			;And return
	SUBTTL System Dumps -- Process a Dump -- Create Dump Filename

;[7.1081] Routine to create the output filename when copying a dump
;[7.1081] The filename looks like:  "DUMP-nnnn-xxxxxx"
;[7.1081] where: nnnn = monitor edit number from DUMP.EXE location .JBVER
;[7.1081] 	 xxxxxx = name of bug from location 144

CRENAM:	HRROI T1,FILNAM		;[7.1081] Destination pointer
	HRROI T2,[ASCIZ/DUMP/]	;[7.1081] Source pointer
	SETZM T3		;[7.1081] Terminate on a null
	SOUT%			;[7.1081] Write it
	 ERJMP .+1		;[7.1081] Something seriously broken
	SKIPN BUGVER		;[7.1081] Any monitor version found?
	IFSKP.			;[7.1081] If yes
	  MOVEI T3,"-"		;[7.1081] Get a separator
	  IDPB T3,T1		;[7.1081] Store it next
	  HRRZ T2,BUGVER	;[7.1081] Load the edit of the monitor
	  MOVX T3,^D8		;[7.1081] We want octal today
	  NOUT			;[7.1081] Output edit number it
	   ERJMP .+1		;[7.1081] Ignore error
	ENDIF.			;[7.1081]
	MOVX T2,<POINT 6,BUGNAM> ;[7.1081] Point to bugname
	CALL NAMCHK		;[7.1081] () Check that it looks good
	IFSKP.			;[7.1081] If there was one and it was ok
	  MOVEI T2,"-"		;[7.1081] Get the separator character again
	  IDPB T2,T1		;[7.1081] Store it
	  MOVX T2,<POINT 6,BUGNAM> ;[7.1081] Pointer to name
	  CALL SIXASC		;[7.1081] Convert to ASCII and copy to filnam
	ENDIF.			;[7.1081]
	SETZM T2		;[7.1081] Zero out a byte
	IDPB T2,T1		;[7.1081] Insure that the string ends with null
	RET			;[7.1081] Done

;[7.1081] Routine to scan a sixbit string and insure each byte is alpha-numeric
;[7.1081] also counts the number of bytes in the string and returns the count
;[7.1081] in T3
;[7.1081] Called with T2/ pointer to SIXBIT string
;[7.1081] Returns +1 not all bytes are alpha-numeric
;[7.1081] 	  +2 ALL BYTES ARE ALPHA-NUMERIC
;[7.1081] 	  T3/ count of bytes

NAMCHK: MOVSI T3,-6		;[7.1081] Our counter
NAMLUP:	ILDB T4,T2		;[7.1081] Get a byte
	JUMPE T4,NAMEXI		;[7.1081] Done if null
	CAIL T4,'0'		;[7.1081] Is it numeric
	CAILE T4,'9'		;[7.1081]  in the decimal radix?
	IFNSK.			;[7.1081] Not numeric - might be alpha
	  CAIL T4,'A'		;[7.1081] Is it alpha-
	  CAILE T4,'Z'		;[7.1081]  betic?
	  RET			;[7.1081] No, error return
	ENDIF.			;[7.1081] Ok character
	AOBJN T3,NAMLUP		;[7.1081] Count another byte
NAMEXI:	HRLI T3,0		;[7.1081] Return count in T3
	JUMPE T3,R		;[7.1081] If we haven't done any, give bad
	RETSKP			;[7.1081] Success

;[7.1081] Routine to convert a SIXBIT string to ASCII
;[7.1081] Called with T1/ destination pointer
;[7.1081] 	      T2/ pointer to SIXBIT string
;[7.1081] 	      T3/ count of characters in source string
;[7.1081] This routine will terminate on a null byte or when count in t3 is
;[7.1081] exhausted, returns +1 always

SIXASC:	ILDB T4,T2		;[7.1081] Get a sixbit byte
	JUMPE T4,SIXEXI		;[7.1081] Done if null byte
	ADDI T4,"A"-'A'		;[7.1081] Do the conversion
	IDPB T4,T1		;[7.1081] Put it in the destination
	SOJG T3,SIXASC		;[7.1081] Decrement counter and continue
	SETZM T4		;[7.1081] Setup a null byte
SIXEXI:	IDPB T4,T1		;[7.1081] Deposit a null byte at the end 
	RET			;[7.1081]

;[7.1081] Routine to zero out the GTJFN block
;[7.1081] Returns +1 always

CLRGTJ:	MOVE T1,[GTJBLK,,GTJBLK+1] ;[7.1081] Setup BLT
	SETZM GTJBLK		;[7.1081] Zero first word
	BLT T1,GTJBLK+.GJJFN	;[7.1081] Clear the GTJFN block
	RET			;[7.1081] Return
	SUBTTL Free Space Subroutines

;ROUTINES TO BUFFER A STRING.  GIVE IT POINTER TO STRING IN A.
;ROUTINE RETURNS POINTER TO BUFFERED STRING IN A.
;THE STRING ALWAYS BEGINS ON A WORD BOUNDARY.  (SOME CALLERS ASSUME SO!)

BUFFS:	MOVEI B,DICT		;SAY WHERE POOL STARTS
	CALL READNM		;COPY STRING INTO FREE SPACE
	ERROR (<String space exhausted>,<JRST CMDER1>)
	RET

;BUFFF buffers the atom buffer
;
;Returns +1:	A/	pointer to buffered atom

BUFFF:	HRROI A,ATMBUF		;POINT TO THE ATOM
	CALLRET BUFFS		;BUFFER IT AND RETURN

;ROUTINE TAKING A STRING POINTER IN A.  IT COPIES THE STRING TO FREE SPACE
;AND TAKES A SKIP RETURN, YIELDING THE POINTER TO THE STRING IN
;A.  IF NO ROOM FOR THE STRING, A NON-SKIP RETURN IS TAKEN AND CONTENTS
;OF A IS INDETERMINATE
;GIVE IT FREE POOL HEADER ADDRESS IN B

READNM:	STKVAR <FPA,RPTR,NEWPTR>
	MOVEM A,RPTR		;REMEMBER POINTER
	MOVEM B,FPA		;REMEMBER FREE POOL ADDRESS
	CALL BCOUNT		;HOW MANY WORDS IN THIS STRING?
	MOVE B,FPA		;SAY WHICH FREE POOL TO USE
	CALL GETMEM		;GET THAT MANY
	 JRST NOREAD		;COULDN'T, SO TAKE NON-SKIP RETURN
	HRLI B,440700		;MAKE BYTE POINTER TO SPACE OBTAINED
	MOVEM B,NEWPTR		;REMEMBER NEW POINTER
	MOVE A,B
	MOVE B,RPTR		;GET POINTER TO STRING
	MOVEI C,0		;STORE NULL AT END OF STRING
	SOUT			;COPY THE STRING
	MOVE A,NEWPTR		;GET ADDRESS WHERE STRING GOT PUT
	RETSKP			;SUCCESFUL RETURN
NOREAD:	RET			;NO ROOM FOR STRING

;ROUTINE TO GET MEMORY BLOCK.  RETURNS +1 ALWAYS WITH ADDRESS OF BLOCK
;IN A.  GIVE IT NUMBER OF WORDS DESIRED IN A.

GETBUF:	MOVEI B,DICT	;USE CORRECT POOL
	CALL GETMEM	;GET THE MEMORY
	 ERROR <Free space exhausted> ;[7.1198]
	MOVE A,B		;RETURN ADDRESS IN A
	RET

; /GETMEM/ - ROUTINE TO ASSIGN MEMORY AS REQUESTED
; INPUTS:	A - CONTAINS NUMBER OF WORDS WANTED
;		B - FREE SPACE HEADER ADDRESS
; OUTPUTS:	A - NUMBER OF WORDS OBTAINED
;		B - CONTAINS ADDRESS OF WORDS GOTTEN
; RETURNS:	SKIPS IF SUCCESSFUL, NON-SKIP IF NO ROOM

GETMEM:	STKVAR <<SAVSTF,2>,DADR>
	MOVEM B,DADR		;REMEMBER HEADER ADDRESS
GETM2:	MOVE C,B		;REMEMBER WHO POINTS TO CURRENT
	HRRZ B,0(C)		;B IS NOW CURRENT BLOCK
	JUMPE B,R		;IF 0, WE HAVE REACHED END OF THE ROAD
	HLRZ D,0(B)		;GET SIZE OF CURRENT BLOCK
	CAMGE D,A		;IS IT SUFFICIENT FOR REQUEST?
	JRST GETM2		;NO, SO TRY NEXT BLOCK
GETM3:	HRL B,0(B)		;GET LINK OF CURRENT BLOCK
	HLRM B,0(C)		;MAKE PREV LINK BE WHAT WAS OUR LINK
	HRRZS B			;ISOLATE CURRENT BLOCKS ADDRESS
	CAMN D,A		;IS THIS AN EXACT MATCH ON SIZE?
	RETSKP			;SUCCESS, SKIP RETURN
	DMOVEM A,SAVSTF		;SAVE NUMBER OF WORDS AND ADDRESS
	ADD B,A			;GET FIRST WORD TO RETURN
	SUBM D,A		;NUMBER OF WORDS TO RETURN
	MOVE C,DADR		;GET ADDRESS OF CONTROL WORD
	CALL RETMEM		;RETURN THE EXTRA WORDS
	DMOVE A,SAVSTF		;RESTORE NUMBER OF WORDS AND ADDRESS
	RETSKP			;SUCCESS, SKIP RETURN

;STREM ROUTINE TAKES POINTER TO STRING IN A, AND "REMOVES" THE STRING
;FROM THE STRING STORAGE SPACE.  THE SPACE WHERE THE STRING WAS IS
;RETURNED TO FREE SPACE

STREM:	SAVEAC <A,B,C,D>	; NEED TO BE TRANSPARENT
	STKVAR <SPT000>
	MOVEM A,SPT000		;REMEMBER POINTER
	CALL BCOUNT		;COUNT NUMBER OF WORDS IN THE STRING
	HRRZ B,SPT000		;GET RID OF BYTE POINTER P AND S
	CALLRET RETBUF		;RETURN THE BUFFER

;RETBUF RETURNS A BUFFER TO FREE STORAGE
;	A/	SIZE BEING RETURNED
;	B/	ADDRESS OF BLOCK BEING RETURNED

RETBUF:	MOVEI C,DICT		;SAY WHERE FREE SPACE IS
	CALLRET RETMEM		;RETURN THE SPACE TO THE FREE POOL

; /RETMEM/ - ROUTINE TO DE-ALLOCATE MEMORY WHEN WE ARE THROUGH WITH IT
; INPUT:	A - CONTAINS SIZE OF BLOCK TO RETURN
;		B - CONTAINS ADDRESS OF BLOCK BEING RETURNED
;		C - FREE SPACE HEADER ADDRESS
; OUTPUT:	NONE
; RETURNS: ALWAYS CPOPJ
;

RETMEM:	HRRZ D,0(C)		;GET PREV'S LINK
	SKIPE	D			;IF CURRENT IS 0 OR
	CAIL D,0(B)		;  ITS ADDRESS IS PAST ADDR OF RETURN BLK
	JRST RETM4			; THEN RETURN BLOCK HERE
	MOVE C,D			;MAKE PREV=CURRENT
	JRST RETMEM			;CONTINUE

RETM4:	HRRM D,0(B)		;FORWARD PTR OF RETURNED BLOCK
	HRRM B,0(C)		;FORWARD PTR OF PREV BLOCK
	HRLM A,0(B)		;STORE SIZE OF THIS BLOCK
	ADD A,B			;ADD ADDR+SIZE
	CAIE A,0(D)		;ARE WE RIGHT UP AGAINST NEXT BLOCK?
	JRST RETM5			;NO, CANT COMBINE
	HRRZ A,0(D)		;GET NEXT GUYS FORWARD LINK
	HRRM A,0(B)		;MAKE IT OURS. IE POINT PAST HIM
	HLRZ A,0(B)		;GET OUR SIZE
	HLRZ D,0(D)		;GET HIS SIZE
	ADD A,D			;GET OUR NEW COMBINED SIZE
	HRLM A,0(B)		;STORE INTO RETURNED BLOCK
	HRRZ D,0(B)		;GET LINK OF CURRENT BLOCK
RETM5:	HLRZ A,0(C)		;GET PREV BLOCKS SIZE
	ADDI A,0(C)		;ADD HIS ADDRESS AND SIZE
	CAIE A,0(B)		;DOES HE BUTT RIGHT UP AGAINST US?
	RET			;NO, RETURN WITH NO COMBINATION
	HRRM D,0(C)		;MAKE PREV POINT TO OUR NEXT
	HLRZ A,0(C)		;GET HIS SIZE
	HLRZ B,0(B)		;AND OUR SIZE
	ADD A,B			;COMBINE THE SIZES
	HRLM A,0(C)		;STORE COMBINED SIZE
	RET			;RETURN

;ROUTINE TO INITIALIZE FREE SPACE STORAGE.

FREINI:	SETZM DICT		;INITIALIZE FREE SPACE SYSTEM
	MOVEI A,FRESIZ		;FREE UP THIS MUCH FREE SPACE (ALL OF IT!)
	MOVEI B,FREE		;STARTS AT ADDRESS IN B
	CALL RETBUF		;FREE IT UP IN STANDARD WAY
	MOVEI A,STRSIZ		;ALLOCATE SOME SPACE FOR STRINGS
	CALL GETBUF
	HRLI A,440700		;MAKE POINTER TO STRING STORAGE
	MOVEM A,CSBUFP		;REMEMBER POINTER TO STRING STORAGE
	RET

;FIXPT changes byte pointer with -1 in left half to have 440700 in left half.
;
;Accepts:	A/	pointer
;
;Returns+1:	A/	converted pointer

FIXPT:	TLC A,-1		;CHANGE -1 TO 0
	TLCN A,-1		;RESTORE BITS AND SKIP IF ANY ARE NOW ON
	HRLI A,440700		;THEY WERE ALL OFF SO MUST HAVE BEEN ALL ON
	RET

;BCOUNT MEASURES AN ASCIZ STRING.
;
;ACCEPTS:	A/	POINTER (-1,,FOO O.K.!)
;
;RETURNS+1:	A/	NUMBER OF WORDS NEEDED IN A
;		B/	NUMBER OF CHARACTERS

BCOUNT:	CALL FIXPT		;CHANGE -1 TO 440700
	MOVEI B,0		;B WILL ACCUMULATE COUNT OF BYTES
BC1:	ILDB C,A		;READ NEXT BYTE
	CAIE C,0		;DONE COUNTING IF NULL SEEN
	AOJA B,BC1		;NOT DONE, KEEP COUNTING
	MOVE D,B		;REMEMBER EXACT COUNT IN D
	AOJ B,			;LEAVE ROOM FOR NULL
	IDIVI B,5		;GET NUMBER OF WORDS
	CAIE C,0		;EXTRA CHARACTERS?
	AOJ B,			;YES, THEY TAKE A WHOLE WORD
	MOVE A,B
	MOVE B,D		;RETURN BYTE COUNT IN B
	RET
	SUBTTL Error Routines

;[7.1081] Here to output a standard SETSPD error message, used by the
;ERROR macro.
;Call with T1/ address of ASCIZ message
;Returns +1 always

ERROR1:	CALL ERRBEG		;(T1/) Output the beginning of the error
				;Fall through to output stars and return

;[7.1081] Here to output a line of stars on the terminal
;Returns +1 always, preserves all ACs

STARS:	HRROI T1,[ASCIZ/
*****************
/]				;Output the stars
	PSOUT%			;Output the mess
	RET			;Gee, that was easy

;[7.1081] Here to output the start of an error message to the CTY
;Outputs those stars and the standard SETSPD beginning message
;Call with T1/ address of start of error text
;Returns +1 always, preserves ACs

ERRBEG:	PUSH P,T1		;Save T1
	HRROI T1,[ASCIZ/
*****************
?SETSPD: /]			;Output the stars and the start of the mess
	PSOUT			;Output the mess
	POP P,T1		;Restore T1
	TLO T1,-1		;Make sure its a byte pointer
	PSOUT%			;Output the error text and
	RET			; well that was pretty easy too

;[7.1081] Here to output error message and the last JSYS error surrounded
;by stars, used by the JSYERR macro.
;Call with T1/ pointer to ASCIZ message
;Returns +1 always

JSYER1:	CALL ERRBEG		;(T1/) Output stars and the SETSPD label
	TMSG < - >		;Output seperator characters
	CALL LSTERR		;Output last TOPS-20 error
	CALL STARS		;Output more stars
	RET			;Return to caller

;[7.1081] Routine to output last TOPS-20 error code to terminal
;Returns +1 always, smashes the temp ACs

LSTERR:	MOVEI T1,.PRIOU		;Output to primary
	HRLOI T2,.FHSLF		;This fork's last error
	SETZ T3,		;No limit
	ERSTR%			;Error to string
	 JRST LSTER1		;Undefined error number
	 JFCL			; errors
	RET			;  and return

LSTER1:	TMSG <Undefined error number > ;Output a starting string
	CALL GETERR		;(/T2) Get last error number
	MOVEI T1,.PRIOU		;Point output to primary
	MOVEI T3,10		;Octal
	NOUT%			;Output undefined number
	 ERJMP .+1		;Disaster
	RET			;Return to caller

;[7.1081] Routine to return the last JSYS error
;Returns +1 always, T2/ 0,,error code

GETERR:	MOVEI T1,.FHSLF		;This fork
	GETER%			;Last error
	TLZ T2,-1		;Zap the fork handle
	RET			;Return
	SUBTTL Cache Refill Code (Historical)

; CACHE REFILL ALGORITHM RAM LOADING INSTRUCTIONS
; *** CURRENTLY PERFORMS NO FUNCTION ***

	XLIST			;[7.1249] Code is REPEAT 0ed and XLISTed
	REPEAT 0,<		;DISABLE THIS CODE
REFILL:
	USRIO			;TURN ON USER IOT
	 RET			;FAILED
	BLKO APR,0
	BLKO APR,100004
	BLKO APR,200010
	BLKO APR,300014
	BLKO APR,400020
	BLKO APR,500024
	BLKO APR,600030
	BLKO APR,700034
	BLKO APR,300040
	BLKO APR,100044
	BLKO APR,200050
	BLKO APR,300054
	BLKO APR,200060
	BLKO APR,100064
	BLKO APR,200070
	BLKO APR,300074
	BLKO APR,700100
	BLKO APR,100104
	BLKO APR,200110
	BLKO APR,700114
	BLKO APR,100120
	BLKO APR,100124
	BLKO APR,200130
	BLKO APR,700134
	BLKO APR,600140
	BLKO APR,500144
	BLKO APR,600150
	BLKO APR,700154
	BLKO APR,500160
	BLKO APR,500164
	BLKO APR,600170
	BLKO APR,700174
	BLKO APR,000200
	BLKO APR,300204
	BLKO APR,200210
	BLKO APR,300214
	BLKO APR,000220
	BLKO APR,200224
	BLKO APR,200230
	BLKO APR,300234
	BLKO APR,000240
	BLKO APR,100244
	BLKO APR,200250
	BLKO APR,300254
	BLKO APR,400260
	BLKO APR,500264
	BLKO APR,600270
	BLKO APR,700274
	BLKO APR,000300
	BLKO APR,700304
	BLKO APR,700310
	BLKO APR,700314
	BLKO APR,000320
	BLKO APR,000324
	BLKO APR,000330
	BLKO APR,700334
	BLKO APR,400340
	BLKO APR,600344
	BLKO APR,600350
	BLKO APR,600354
	BLKO APR,400360
	BLKO APR,400364
	BLKO APR,600370
	BLKO APR,400374
	BLKO APR,300400
	BLKO APR,100404
	BLKO APR,300410
	BLKO APR,300414
	BLKO APR,100420
	BLKO APR,100424
	BLKO APR,100430
	BLKO APR,300434
	BLKO APR,000440
	BLKO APR,700444
	BLKO APR,700450
	BLKO APR,700454
	BLKO APR,000460
	BLKO APR,000464
	BLKO APR,000470
	BLKO APR,700474
	BLKO APR,000500
	BLKO APR,100504
	BLKO APR,200510
	BLKO APR,300514
	BLKO APR,400520
	BLKO APR,500524
	BLKO APR,600530
	BLKO APR,700534
	BLKO APR,400540
	BLKO APR,500544
	BLKO APR,500550
	BLKO APR,700554
	BLKO APR,400560
	BLKO APR,500564
	BLKO APR,400570
	BLKO APR,700574
	BLKO APR,000600
	BLKO APR,100604
	BLKO APR,200610
	BLKO APR,200614
	BLKO APR,000620
	BLKO APR,100624
	BLKO APR,200630
	BLKO APR,100634
	BLKO APR,000640
	BLKO APR,500644
	BLKO APR,600650
	BLKO APR,600654
	BLKO APR,000660
	BLKO APR,500664
	BLKO APR,600670
	BLKO APR,000674
	BLKO APR,400700
	BLKO APR,500704
	BLKO APR,600710
	BLKO APR,500714
	BLKO APR,400720
	BLKO APR,500724
	BLKO APR,600730
	BLKO APR,400734
	BLKO APR,000740
	BLKO APR,100744
	BLKO APR,200750
	BLKO APR,300754
	BLKO APR,400760
	BLKO APR,500764
	BLKO APR,600770
	BLKO APR,700774
	RET			;AND DONE
>				;END OF REPEAT ZERO
	LIST			;[7.1249] End of XLISTed REPEAT 0ed code
	SUBTTL End of SETSPD

	END <ENVLEN,,ENTVEC>
