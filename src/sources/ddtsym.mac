;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1984,1987.
;ALL RIGHTS RESERVED.

; THESE ARE THE SYMBOLS USED IN THE REPRESENTATION OF "."

; THE LEFT HALF OF DOT IS USED FOR FLAGS.  THE SIGN BIT IS A "VALID" FLAG.
; THE 200K BIT INDICATED THAT THE ADDRESS IS AN "AC" ADDRESS AND SHOULD BE 
; INCRIMENTED BY 1

; DOT	(AC7)	IS THE CURRENT SIMULATED PC

; DOTOLD MEM	IS WHERE THE OLD DOT IS SAVES ON CASE OF A <ESC><LF>,
;		A <ESC><CR>, OR A <ESC>^.

; DOTFOO MEM

; DTFOLD MEM

; ROUTINE DOTSAV
;	MOVES DOT TO DOTOLD AND DOTFOO TO DTFOLD

; ROUTINE DOTINC
;	IF THE SIGN BIT OF THE DOT WORD IS SET, DOTINC WILL USE IT, ELSE IT
;	WILL START WITH DOT.  IF THE SIGN BIT OF DOT IS NOT SET, IT WILL ALSO
;	LOAD A -1 TO THE LEFT HALF OF THE ADDRESS. IT ALSO HAS THE OBNOXIOUS
;	HABIT OF SCREWING WITH THE BITS, BASED ON THE TYPE OF FE IT THINKS
;	IT IS PLAYING WITH

; ROUTINE NDTFOO
;	ROUTINE TO UPDATE (WITH DOTINC) DOTFOO.

; ROUTINE NDTFIN
;	UPDATES THE DOT POINTERS DTFINP (USED FOR INPUT)

; ROUTINE NXTDOT
;	UPDATES DOT TO POINT TO THE NEXT WORD



UNIVERSAL DDTSYM SYMBOLS FOR DDT11

	SEARCH	MONSYM

	SALL			;GET NICE LISTINGS FOR A CHANGE
	.HWFRMT			;AND SKIP THE FANCY BITS

IFNDEF DEBUG,<DEBUG==0>

EXMAX==	140			;MAXIMUM NUMBER OF BYTES TO EXAMINE AT ONCE

MASKSZ==10			;NUMBER OF WORDS IN MASK
CMDSIZ==500			;LARGEST COMMAND
NUMBUF==1			;NUMBER OF BUFFERS FOR READING DUMPS, ETC.
				; SETTING LARGER THAN 1 MAY CAUSE %GOTO TO FAIL



;REGISTER USAGE

AC0=	0			; only for very tempory things
AC1=	1
AC2=	AC1+1
AC3=	AC2+1
AC4=	AC3+1
SYM=	5			;POINTER TO SYMBOL BLOCK
STATE=	6
DOT=	7			;CURRENT LOCATION
DOT.AC==200000,,0		;THE CURRENT LOCATION IS AN AC
DOT.OK==400000,,0		;THE CURRENT DOT IS VALID
DOT.FG==777000,,0		;ALL THE DOT FLAGS

				; IF LH IS NONZERO IS A REGISTER ADR
FLG=	10
T1=	11
T2=	T1+1
T3=	T2+1			; ALSO REFERED TO AS MA
T4=	T3+1			; ALSO REFERED TO AS MA+1
T5=	T4+1
QX=	16			; AN AC TO SCRATCH
P=	17

; THE AC'S WE DONT WANT TO HEAR ABOUT

.XCREF	P,QX,T1,T2,T3,T4,T5,AC0,AC1,AC2,AC3,AC4,FLG

; THE MACROS WE DONT WANT TO HEAR ABOUT

.XCREF	TYPE,CALL,RET
.XCREF	TXN,TXNA,TXNN,TXNE,TXO,TXOA,TXOE,TXON
.XCREF	TXC,TXCA,TXCN,TXCE,TXZ,TXZA,TXZE,TXZN





; SIMULATOR REGISTER USAGE

;WHEN SIMULATING REGS 0-7 ARE USED FOR CORRESPONDING PDP11 REG'S
; REGISTERS ALWAYS CLEAR EXCEPT FOR BITS 20-35
SP=	6			;SIMULATED STACK POINTER
PC=	7			;SIMULATED PC
				; PC MUST ALWAYS BE EVEN
MA=	T3			;CONTAINS LAST ADR SETUP UP BY CALLS THROUGH RFETCH
				; SO RSTORE USES SAME LOC.   WORD ADDRESSES ARE LOADED THEN
				; ROTATED RIGHT 2 POSITIONS.   BYTE ADDRESS ARE DIVIDED BY 4.
				; REMAINDER OF DIVISION IS KEPT IN MA+1

MA..UN==040000			;ADDRESS IS A UNIBUS DEVICE
MA..RG==020000			;LOCATION IS REGISTER
MA..IO==010000			;LOCATION IS IN PERIPHERAL AREA (I.E. 170000-177777)
IR=	T5			;CONTAINS INSTRUCTION WHEN SIMULATING
PS=	16			;SIMULATED PS
PS...T==000020			;TRAP BIT
PS...N==000010			;RESULT WAS NEGATIVE
PS...Z==000004			;RESULT WAS ZERO
PS...V==000002			;RESULT WAS ARITH OVERFLOW
PS...C==000001			;RESULT WAS A CARRY



F.FLIP==1B35			;LOCAL FLAG
				; USED BY $V TO FLAG 1ST PASS
				; USED BY $N TO DISTINGUISH FROM $W
				; USED BY OPNFIL TO DEMAND PROMPT
				; USED BY $D TO REMEMBER DOING COMMAND LOGGING
				; USED WHEN READING BINARY FILE
F.FLOP==1B34			;LOCAL FLAG
				; SET IF USER SAYES /BINARY IN INITIAL COMMAND
				; SET IF READING A PACKED FILE
F..FOO==1B33			;LOCAL FLAG WHEN SET MEANS
				; DUMP IS DISASSEMBLY
				; READING A DTELDR DUMP
F.LOPN==1B32			;CURRENT LOCATION IS OPEN
F.MOPN==1B31			;MASK OPEN
F.MASK==1B30			;ESCAPE M TYPED
F.TEXT==1B29			;ASSEMBLING TEXT
F.IOCT==1B28			;ASSEMBLING AN OCTAL NUMBER
F.IDEC==1B27			;ASSEMBLING A DECIMAL NUMBER
F.IHEX==1B26			;ASSEMBLING A HEX NUMBER
F.SYMB==1B25			;ASSEMBLING A SYMBOL
F.CACH==1B24			;USE CACHE IF POSSIBLE
F.WRIT==1B23			;WE ARE OPENING FILE FOR OUTPUT
F.APND==1B22			;APPEND TO TO FILE IF ALREADY EXISTS
F.LOCK==1B21			;PROGRAM IS LOCKED
F.WENB==1B20			;PATCHING WAS ENABLED WITH /PATCH
F..ESC==1B19			;TYPED ESCAPE TWICE
F.PACK==1B18			;BINARY FILE IS PACKED
F.LBKT==1B17			;LOCATION OPENED WITH A LEFT BRACKET
F.HASH==1B16			;OPCODE PRECEEDED BY A # SIGN
F.PERC==1B15			;OPCODE PRECEEDED BY A % SIGN
F.LPAR==1B14			;OPCODE PRECEEDED BY A ( SIGN
F.SYML==1B13			;SYM HAS BEEN LOADED . SET BY GETEXP
F.GEXP==1B12			;GOT AN EXPRESSION . SET BY GETEXP
F.TOPN==1B11			;DID OPEN ON TTY(TO CONTROL ECHO)
F.SVIO==1B10			;HIT A STACK VIOLATION
F.SREG==1B9			;SYMBOLIC TYPEIN WAS A REGISTER NAME
F..SIM==1B8			;AM RUNNING SIMULATION
F.EXEC==1B7			;RUNNING IN EXEC MODE
F.RUNF==1B6			;RUN FLOP FOR SIMULATION
F.CERR==1B5			;HIT AN ERROR IN COMMAND FILE
F.FELE==1B4			;HAVE DONE FIRST ELEMENT OF EXPRESSION
F.NOUT==1B0			;SUPRESS OUTPUT



; RAMDOM FLAGS AND OTHER GARBAGE

IO.RLB==1000
IO.WLB==400


;TTYBIT FLAGS

TF.RUB==1B1			;DO RUBOUTS WITH BACKSPACE-SPACE-BACKSPACE


; DEBUG FLAGS FOR USE WITH THE /DEBUG SWITCH

DB.INI==1B35			; INIT CODE DEBUG MESSAGES
DB.SYM==1B34			; SYMBOL TABLE INFORMATION
DB.MEM==1B33			; MEMORY INFORMATION
DB.EXD==1B32			; EXAMINE/ DEP CODE...
DB.CAL==1B31			; REPORT ALL CALLS


;FLAGS FOR TYPE OF OPERATING SYSTEM

T.OTHER==1B0			;THIS IS OTHER

T.TOP10==1B1			;THIS IS TOPS-10
T.ITS==1B2			;THIS IS ITS
T.TENEX==1B3			;THIS IS TENEX
T.TOP20==1B4			;THIS IS TOPS-20
T.EXEC==1B5			;THIS IS EXEC MODE


; CPU TYPES THAT WE RUN ON...

P.KS10==1B0			; KS10 - deliberately the sign bit
P.KL10==1B1			; KL10
P.KI10==1B2			; KI10
P.KA10==1B3			; KA10
P.PDP6==1B4			; PDP-6


; GENERAL ERROR CODES WE CAN SEE - USED BY THE PARSER, AND IN CALERR

ER.NXM==1			; NONEXISTENT MEMORY REFERENCE
ER.ODD==2			; ODD ADDRESS TRAP
ER.DTE==3			; DTE TIME OUT ERROR



; VALUES FOR OUTPUT MODES

MODINS==0			; INSTRUCTION MODE OUTPUT
MODADR==1			; ADDRESS MODE OUTPUT
MODNUM==2			; NUMERIC MODE OUTPUT
MODBYT==3			; BYTE MODE OUTPUT
MODASC==4			; ASCII MODE OUTPUT
MODEBC==5			; EBCIDIC MODE OUTPUT
MODR50==6			; RADIX 50 TYPEOUT

; DEFINE THE TYPES OF DATA THAT CAN BE STORED IN "DATA"

DAT.XX==0			; NO DATA THERE, OR DONT KNOW
DAT.NU==1			; A NUMBER
DAT.AS==2			; AN ASCII STRING
DAT.IN==3			; AN INSTRUCTION


;DEFINE THE TYPES OF EXAMINES WE CAN DO

EX.MEM==	0		;MEMORY
EX.PORT==	1		;CALL11 UUO
EX.NODE==	2		;NODE UUO
EX.FE0==	3		;RSX20F EXAMINE
EX.D61==	4		;DN60 ON TOPS-10
EX.D62==	5		;DN60 ON TOPS-20
EX.MCB==	6		;DN20 DECNET 20 EXAMINE
EX.FE1==	7		;RSX20F/TOPS-10
	FE.MAX==40		;Max data bytes 20F allows for ME msg
EX.MC1==	10		;MCB running on TOPS-10



; SYMBOL TABLE FORMAT...

;SYMBOLS ARE KEPT IN FOUR WORD BLOCKS
;	SYMBEG POINTS TO FIRST BLOCK
;	SYMEND POINTS TO LAST BLOCK

; 1ST WORD IN BLOCK IS SIXBIT SYMBOL

; 2ND WORD IS VALUE

; 3RD WORD IS HALF WORD FLAGS,,MASK FOR MATCH

SMF.SU==000001			;SYMBOL IS SUPPRESSED(DEFINED WITH =)
SMF.RG==000002			;SYMBOL IS A REGISTER VALUE
SMF.IN==000004			;SYMBOL IS AN INSTRUCTION
SMF.EI==000010			;EIS INSTRUCTION FORMAT
SMF.DD==000020			;LOW ORDER SIX BITS ARE DESTINATION
SMF.SS==000040			;LOW ORDER 12 BITS ARE SSDD
SMF.BR==000100			;LOW ORDER 8 BITS ARE XXX(I.E. BR)
SMF.SB==000200			;SOB TYPE ADDRESS
SMF.RT==000400			;RTS TYPE REGISTER USAGE
SMF.JS==001000			;JSR TYPE REGISTER USAGE
SMF.EM==002000			;EMT TYPE ARGUMENT

SMF.MK==010000			;MARK
SMF.PL==020000			;SET PROCESSOR LEVEL
SMF.P8==040000			;PDP8 SYMBOL
SMF.11==100000			;PDP11 SYMBOL
SMF.BY==200000			;BYTE INSTRUCTION

; 4TH WORD IS SYMBOL SOURCE



OPDEF	APRID	[700000,,0]	;READ MICROCODE VERSION AND CPU SERIAL NU
OPDEF	WRAPR	[700200,,0]	;WRITE APR
				;1B19	;IO RESET
				;1B20	;ENABLE SELECTED CONDITIONS
				;1B21	;DISABLE SELECTED CONDITIONS
				;1B22	;CLEAR SELECTED CONDITIONS
				;1B23	;SET SELECTED CONDITIONS
				;1B25	;INTERRUPT 8080
				;1B26	;POWER FAIL
				;1B27	;NXM
				;1B28	;BAD MOS DATA
				;1B29	;CORRECTED MOS DATA
				;1B30	;TIMER
				;1B31	;8080 INTERRUPT
				;1B32	;GENERATE APR INTERRUPT
				;7B35	;APR LEVEL
OPDEF	RDAPR	[700240,,0]	;READ APR
OPDEF	WRPI	[700600,,0]	;WRITE PI
OPDEF	PIOFF	[700600,,400]
OPDEF	PION	[700600,,200]
OPDEF	RDPI	[700640,,0]	;READ PI
OPDEF	WRUBR	[701140,,0]	;WRITE USER BASE REGISTER
OPDEF	CLRPT	[701100,,0]	;CLEAR PAGE TABLE
OPDEF	RDUBR	[701040,,0]	;READ USER BASE REGISTER
OPDEF	WREBR	[701200,,0]	;WRITE
OPDEF	RDEBR	[701240,,0]	;READ
OPDEF	TIOE	[710000,,0]	;TEST UNIBUS, SKIP EQUAL
OPDEF	TIOEB	[720000,,0]	;TEST UNIBUS, SKIP EQUAL
OPDEF	TION	[711000,,0]	;TEST UNIBUS, SKIP NOT EQUAL
OPDEF	TIONB	[721000,,0]	;TEST UNIBUS, SKIP NOT EQUAL
OPDEF	RDIO	[712000,,0]	;READ UNIBUS
OPDEF	RDIOB	[722000,,0]	;READ UNIBUS BYTE
OPDEF	WRIO	[713000,,0]	;WRITE UNIBUS
OPDEF	WRIOB	[723000,,0]	;WRITE UNIBUS BYTE
OPDEF	BSIO	[714000,,0]	;BIT SET TO UNIBUS
OPDEF	BSIOB	[724000,,0]	;BIT SET TO UNIBUS BYTE
OPDEF	BCIO	[715000,,0]	;BIT CLEAR TO UNIBUS
OPDEF	BCIOB	[725000,,0]	;BIT CLEAR TO UNIBUS BYTE
OPDEF	WRSPB	[702400,,0]	;WRITE SPT BASE REGISTER
OPDEF	RDSPB	[702000,,0]	;READ SPT BASE REGISTER
OPDEF	WRCSB	[702440,,0]	;WRITE CORE STATUS TABLE BASE REGISTER
OPDEF	RDCSB	[702040,,0]	;READ CORE STATUS TABLE BASE REGISTER
OPDEF	WRPUR	[702500,,0]	;WRITE PROCESS USE REGISTER
OPDEF	RDPUR	[702100,,0]	;READ PROCESS USE REGISTER
OPDEF	WRCSTM	[702540,,0]	;WRITE CST MASK REGISTER
OPDEF	RDCSTM	[702140,,0]	;READ CST MASK REGISTER
OPDEF	WRTIME	[702600,,0]	;WRITE TIME BASE
OPDEF	RDTIME	[702200,,0]	;READ TIME BASE
OPDEF	WRINT	[702640,,0]	;WRITE INTERVAL TIMER
OPDEF	RDINT	[702240,,0]	;READ THE INTERVAL REGISTER
OPDEF	UMOVE [704000,,0]	;MOVE FROM PREVIOUS CONTEXT
OPDEF	UMOVEM [705000,,0]	;MOVE TO PREVIOUS CONTEXT



;EPT - EXECUTIVE PROCESS TABLE

				;0-37 CHANNEL LOGOUT AREA
				;40-41
EPTINT==42			;42-57 INTERRUPT LOCATIONS
				;60-77 (KL10 - DTE AREA)
EPTVEC==100			;100 128 WORD TABLE OF VECTORS
				;101-177 RESERVERED FOR FUTURE USE
				;200-377 EXEC PAGE 400-777
				;400-420
EPTAOV==421			;421 EXEC ARITH OVERFLOW TRAP INS
EPTPDO==422			;422 EXEC PUSHDOWN OVFL INS
EPTTP3==423			;423 EXEC TRAP-3 INS
				;424-427 HALT STATUS AREA
				;430-437
				;460-507
				;510 TIME BASE HIGH-ORDER WORD
				;511 TIME BASE LOW-ORDER WORD
				;512 PERF ANA COUNTER HIGH-ORDER WORD
				;513 " LOW-ORDER WORD
				;514 INTERVAL TIMER VEC INT LOC
				;515-577 RES FOR USE BY HDW
EPTSTP==540			;540-557 SECTION TABLE POINTER FOR SECTION 0-17
EPM000==600			;600-757 EXEC PAGE 0-337
				;760-777 RESERVED


				;UPT - USER PAGE TABLE
				;0-377 USER PAGE 0-777
				;400-417 EXEC PAGE 340-377
				;420 FREE
				;421 USER ARTIH OVFLW TRAP INST
				;422 USER PUSHDOWN OVFLW TRAP INS
				;423 USER TRAP-3 INS
.UPMUO==1424			;424 USERS FLAGS,,MUUO OPCODE
.UPMUP==1425			;425 PC WORD OF MUUO STORED HERE
				;426 MUUO EFFECTIVE ADDR
				;427 PROCESSOR CONTEXT
				;430 KERNEL NO TRAP MUUO NEW PC WORD
				;431 KERNEL TRAP MUUO NEW PC WORD
				;432 SUPERVISOR TRAP MUUO NEW PC WORD
				;433 SUPERVISOR NO TRAP MUUO NEW PC WORD
				;434 CONCEALED TRAP MUUO NEW PC WORD
				;435 CONCEALED NO TRAP MUUO NEW PC WORD
				;436 PUBLIC TRAP MUUO NEW PC WORD
				;437 PUBLIC NO TRAP MUUO NEW PC WORD
				;440-477 FREE
UPTPFW==1500			;500 EXEC OR USER PAGE FAILWORD STORED HERE
				;B0 USER MODE
				;B1 IO = ADAPTER
UPTPFL==1501			;501 PAGE FAIL OLD FLAGS WORD
UPTPFO==1502			;502 PAGE FAIL OLD PC WORD
UPTPFN==1503			;503 PAGE FAIL NEW PC WORD
				;504 EBOX CLOCK TICKMETER HIGH ORDER WORD
				;505 EBOX CLOCK TICKMETER LOW-ORDER WORD
				;506 MBOX CYCLEMETER HIGH ORDER WORD
				;507 MBOX CYCLEMETER LOW-ORDER WORD
				;510-577 RESERVED FOR HDW
				;600-777 FREE

; PAGE TABLE WORDS
				;400000 ACCESS ALLOWED
				;200000 PUBLIC
				;100000 WRITABLE
				;040000 SOFTWARE
				;020000 CACHE ENABLED
				;017777 PHYSICAL PAGE ADR BITS 14-26
				;UNIBUS ADAPTER




BR5LVL==4
BR5OFF==1B26!1B32
BR5ON==	1B25!1B32
BR5INT==1B24			;INTERRUPT IN PROGRESS FOR BR5

BR7LVL==3
BR7OFF==1B26!1B31
BR7ON==	1B25!1B31
BR7INT==1B23			;INTERRUPT IN PROGRESS FOR BR7

UBAMAP=	763000			;MAPPING REGISTERS
UB.RPW==400000			;MAINTENANCE PAUSE FOR EVEN AND ODD MEMORY WRITE
UB.16B==200000			;DISABLE UPPER TWO BITS ON TRANSFER
UB.FST==100000			;FAST XFER
UB.VLD==040000			;VALID
				;003777	;PAGE NUMBER
UBA.SR=	763100			;STATUS REGISTER
				;400000	;TIMEOUT
				;200000	;BAD MEMORY ON NPR TRANSFER
				;100000	;SM10 BACKPANEL BUS ERROR
				;040000	;CPU ADDRESSED NONEXISTENT DEVICE
				;004000	;BR6 OR BR7
				;002000	;BR5 OR BR4
				;001000	;AC OR DC LOW
				;000200	;DISABLE TRANSFER ON UNCORRECTABLE DATA
				;000100	;UBA INITIALIZE
UBA.B7==1B28+BR7LVL*10
UBA.B5==1B28+BR5LVL
UBALVL==1B28+BR7LVL*10+BR5LVL	;PI LVL ASSIGNMENTS
UBA.IR=	763200			;VECTOR REGISTER
UBA.MR=	763101			;MAINTENANCE REGISTER
				;000001	;CHANGE NPR REQUEST
				;000002	;ENABLE NPR WRAP AROUND



;DZ11

DZ.CSR==0			;CONTROL AND STATUS REGISTER
DZ.RBF==2			;READER BUFFER
DZ.LPR==2			;LINE PARAMETER REGISTER
DZ.TCR==4			;TRANSMIT CONTROL REGISTER
DZ.MSR==6			;MODEM STATUS REGISTER
DZ.TDR==6			;TRANSMIT DATA REGISTER

;RJP04
RPCS1==	776700
RPWC==	776702
RPBA==	776704
RPDA==	776706
RPCS2==	776710
RPDS==	776712
RPER1==	776714
RPAS==	776716
RPLA==	776720
RPDB==	776722
RPMR==	776724
RPDT==	776726
RPSN==	776730
RPOF==	776732
RPDC==	776734
RPCC==	776736
RPER2==	776740
RPER3==	776742
RPEC1==	776744
RPEC2==	776746



;INTERPROCESSOR COMMUNICATIONS AREA

;WORD 31 - KEEP ALIVE AND STATUS WORD
FEWSTS=	31

;WORD 32 - KS-10 INPUT WORD
FEWINP=	32
				;BITS 20-27 = 0 NO ACTION
				;BITS 20-27 = 1 CTY CHAR
				;BITS 28-35 = CHAR

;WORD 33 - KS-10 OUTPUT WORD
FEWOUT=	33
				;BITS 20-27 = 0 NO ACTION
				;BITS 20-27 = 1 CTY CHAR
				;BITS 28-35 = CHAR

;WORD 34 - KS-10 KLINIK LINE INPUT WORD

;WORD 35 - KS-10 KLINIK LINE OUTPUT WORD



;TOPS-20 version DN60 protocol definitions

.BTD60==16			;DN60 PROTOCL OPERATION
.VND60==2			;DN60 protocol type

;BTD60 ARG BLOCK

;	DEFSTR	(BT6DTE,0,35,36) ;DTE number
;	DEFSTR	(BT6ERR,1,35,36) ;returned error flags
;	DEFSTR	(BT6HBC,2,17,18) ;DN60 header byte count
;	DEFSTR	(BT6HDR,2,35,18) ;DN60 header address(begins on word)
;	DEFSTR	(BT6DBC,3,35,36) ;data byte count
				;	positive => write data mode
				;	zero     => no data transfer
				;	negative => read data mode
;	DEFSTR	(BT6PTR,4,35,36) ;data byte ptr
				;the following are returned for timing analysis
;	DEFSTR	(BT6TMR,5,35,36) ;time of request
;	DEFSTR	(BT6TAS,6,35,36) ;TIME DTE ASSIGNED
;	DEFSTR	(BT6THQ,7,35,36) ;time header queued to 11
;	DEFSTR	(BT6TRD,10,35,36) ;time of -10 done for response header
;	DEFSTR	(BT6TDD,11,35,36) ;time of -10 done for data
;	DEFSTR	(BT6TFR,12,35,36) ;time finished request
BT6DTE==0
BT6ERR==1
BT6HDR==2
BT6DBC==3
BT6PTR==4
BT6TMR==5
BT6TAS==6
BT6THQ==7
BT6TRD==10
BT6TDD==11
BT6TFR==12
BT6SIZ==13			;size of BOOT arg block

;DN60 header definitions
;	DEFSTR	(D6FCN,0,15,16)	;xmitted function code
;	 DEFSTR	(D6RSP,0,7,8)	;returned response code
;	 DEFSTR	(D6FCD,0,15,8)	;returned function code
;	DEFSTR	(D6ADR,0,31,16)	;address for examine/deposit
;	DEFSTR	(D6DAT,1,15,16)	;data from examine/for deposit
;	DEFSTR	(D6DEV,0,23,8)	;device code
;	DEFSTR	(D6LIN,0,31,8)	;line number
;	DEFSTR	(D6CNT,1,15,16)	;requested byte count to transfer
				;end of original header definitons
				;begin extended header
;	DEFSTR	(D6AR3,1,31,16)	;reserved
;	DEFSTR	(D6DST,2,31,32)	;returned device status
;	DEFSTR	(D6LST,3,32,32)	;returned line status

D6HWSZ==4			;number of 36 bit words in header
D6HBSZ==4*D6HWSZ		;number of 8 bit bytes in header

;DN60/DTE database/work space definitions
;D6STS below is returned in BT6ERR when an error occurs

;	DEFSTR	(D6STS,0,35,36)	;port status
				;protocol flags
	 D6.BSY==1B0		;port is busy - sign bitness is used in testing
	 D6.QHD==1B1		;header has been queued
	 D6.HDD==1B2		;to -11 done for header seen
	 D6.NDT==1B3		;this is a no-data-transfer operation
	 D6.RED==1B4		;this is a read data type operation
	 D6.QDT==1B5		;data has been queued(for write fcn)
	 D6.DTD==1B6		;to -11 done for write data seen
	 D6.RBL==1B7		;to -10 doorbell for response header seen
	 D6.RDN==1B8		;to -10 done for response header seen
	 D6.DBL==1B9		;to -10 doorbell for read data seen
	 D6.DDN==1B10		;to -10 done for read data seen
	 D6.FDN==1B11		;to -10 done for read data was faked
				;error flags
	 D6.BDP==1B30		;bad data byte ptr
	 D6.ARD==1B31		;11 attempted to send read data when
				; when none was expected
	 D6.TRS==1B32		;timed out waiting for response header
	 D6.TDT==1B33		;timed out waiting for read data

	 D6.TPO==1B34		;timed out waiting for port to be free
	 D6.NT6==1B35		;not a DN60 front end

	 D6.SER==D6.BDP!D6.ARD!D6.TRS!D6.TDT!D6.TPO!D6.NT6 ;all errors

;DN60 function codes

D6.EXM==11			; DN60 examine memory function code
D6.DEP==12			; DN60 deposit memory function code



;FORMATS OF PDP-11 STB FILES (FROM VARIOUS SOURCES...

comment \

STB files are written in records of variable counted length. The format
in the file is :

	two clear bits, high byte, low byte   per halfword

The count, which is first, is two bytes long, and will be on a word
boundry.  The records should be an even number of bytes long. The
following is a list of the record types available.

\
STB.XX==0			; ILLEGAL RECORD TYPE
STB.GS==1			; GLOBAL SYMBOL RECORD
STB.EG==2			; END OF GLOBAL SYMBOLS
STB.TX==3			; TEXT INFORMATION
STB.RL==4			; RELOCATION INFORMATION
STB.IS==5			; INTERNAL (LOCAL) SYMBOLS
STB.EM==6			; END OF MODULE
STB.MX==6			; MAXIMUM RECORD TYPE


; The following are the types defined for GSD (type 1) records

GSD.MN==0			; MODULE NAME
GSD.CS==1			; CSECT NAME
GSD.IS==2			; INTERNAL SYMBOL
GSD.TA==3			; TRANSFER ADDRESS (START ADDRESS)
GSD.GS==4			; GLOBAL SYMBOL
GSD.PN==5			; PROGRAM NAME
GSD.PV==6			; PROGRAM VERSION
GSD.MA==7			; MAPPED ARRAY 
GSD.CR==10			; COMPLEATION ROUTINE NAME
GSD.MX==10			; MAX ALLOWED TYPE

; Within the global symbol, the following flags have significants

GS.WEA==1			; WEAK REFERENCE (INTERNAL ONLY IF NEEDED)
GS.TYP==4			; TYPE, DEFINITION/REFERENCE OR LIBRARY
GS.REF==10			; REFERENCE OD DEFINITION
GS.REL==40			; RELOCATABLE OR ABSOLUTE

; Within a Psect, the following flags hold

PS.MES==1			; MEMORY SPEED 1==> FAST NEEDED
PS.LIB==2			; REFERENCES LIBRARY OR COMMON BLOCK
PS.ALL==4			; ALLOCATION: 0==> CONCATINATE 1==> OVERLAY
PS.RES==10			; RESERVED FOR TKB INTERNAL USE
PS.ACC==20			; ACCESS: 0==> READ/WRITE 1==> READ ONLY
PS.REL==40			; RELOCATION: 0==> ABSOLUTE 1==> RELOCATABLE
PS.SCO==100			; SCOPE: 0==> LOCAL 1==> GLOBAL
PS.TYP==200			; TYPE: 0==> INSTRUCTIONS 1==> DATA



;FORMAT OF PDP-11 BINARY TAPES

;	FRAME	-1	001
;		-2	000
;		-3	BYTE COUNT - LOWER ORDER
;		-4	BYTE COUNT - HIGHER ORDER
;		-5	LOAD ADDRESS - LOWER ORDER
;		-6	LOAD ADDRESS - HIGHER ORDER
;				DATA
;			CHKSUM

;	THE BYTE COUNT COUNTS FRAME-1 THROUGH ALL DATA
;	IF THE BYTE COUNT IS EQUAL TO 6 THE LOAD ADDRESS IS THE START ADDRESS
;	UNLESS ODD.
;	IF THE BYTE COUNT IS > 6, DATA WILL BE LOADED INTO MEMORY
;	WHEN CHKSUM IS ADDED TO SUM OF PREVIOUS FRAMES RESULT IS 0


;PDP11 ADDRESSING MODES

;	0	Rn	REGISTER
;	1	@Rn	REGISTER DEFERRED
;	2	(Rn)+	AUTO-INCREMENT
;	3	@(Rn)+	AUTO-INCREMENT DEFERRED
;	4	-(Rn)	AUTO-DECREMENT
;	5	@-(Rn)	AUTO-DECREMENT DEFERRED
;	6	X(Rn)	INDEX
;	7	@X(Rn)	INDEX DEFERRED

;	27	#X	IMMEDIATE
;	37	@#X	ABSOLUTE
;	67	X	RELATIVE
;	77	@X	RELATIVE DEFERRED



;MACRO TO DEFINE SYMBOLS FOR INSTRUCTIONS

; 1ST ARGUMENT IS VALUE OF INSTRUCTION
; 2ND ARG IS MASK FOR VALUE
; 3RD ARG IS MNEMONIC
; 4TH ARG IS FLAG BITS
; 5TH ARG IS SIMULATION

DEFINE INSTRU <
XLIST
X 000000,007000,AND,<SMF.IN!SMF.P8>
X 000000,177777,HALT,<SMF.IN!SMF.11>
X 000000,177777,R0,<SMF.RG!SMF.11>
X 000001,177777,R1,<SMF.RG!SMF.11>
X 000001,177777,WAIT,<SMF.IN!SMF.11>
X 000002,177777,R2,<SMF.RG!SMF.11>
X 000002,177777,RTI,<SMF.IN!SMF.11>
X 000003,177777,BPT,<SMF.IN!SMF.11>
X 000003,177777,R3,<SMF.RG!SMF.11>
X 000004,177777,IOT,<SMF.IN!SMF.11>
X 000004,177777,R4,<SMF.RG!SMF.11>
X 000005,177777,R5,<SMF.RG!SMF.11>
X 000005,177777,RESET,<SMF.IN!SMF.11>
X 000006,177777,RTT,<SMF.IN!SMF.11>
X 000006,177777,SP,<SMF.RG!SMF.11>
X 000007,177777,PC,<SMF.RG!SMF.11>
X 000100,177700,JMP,<SMF.IN!SMF.DD!SMF.11>
X 000200,177770,RTS,<SMF.IN!SMF.RT!SMF.11>
X 000230,177770,SPL,<SMF.IN!SMF.PL!SMF.11>
X 000240,177777,NOP,<SMF.IN!SMF.11>
X 000241,177777,CLC,<SMF.IN!SMF.11>
X 000242,177777,CLV,<SMF.IN!SMF.11>
X 000244,177777,CLZ,<SMF.IN!SMF.11>
X 000250,177777,CLN,<SMF.IN!SMF.11>
X 000257,177777,CCC,<SMF.IN!SMF.11>
X 000261,177777,SEC,<SMF.IN!SMF.11>
X 000262,177777,SEV,<SMF.IN!SMF.11>
X 000264,177777,SEZ,<SMF.IN!SMF.11>
X 000270,177777,SEN,<SMF.IN!SMF.11>
X 000277,177777,SCC,<SMF.IN!SMF.11>
X 000300,177700,SWAB,<SMF.IN!SMF.DD!SMF.11>
X 000400,177400,BR,<SMF.IN!SMF.BR!SMF.11>
X 001000,177400,BNE,<SMF.IN!SMF.BR!SMF.11>
X 001000,007000,TAD,<SMF.IN!SMF.P8>
X 001400,177400,BEQ,<SMF.IN!SMF.BR!SMF.11>
X 002000,177400,BGE,<SMF.IN!SMF.BR!SMF.11>
X 002000,007000,ISZ,<SMF.IN!SMF.P8>
X 002400,177400,BLT,<SMF.IN!SMF.BR!SMF.11>
X 003000,177400,BGT,<SMF.IN!SMF.BR!SMF.11>
X 003000,007000,DCA,<SMF.IN!SMF.P8>
X 003400,177400,BLE,<SMF.IN!SMF.BR!SMF.11>
X 004000,177000,JSR,<SMF.IN!SMF.DD!SMF.JS!SMF.11>
X 004000,007000,JMS,<SMF.IN!SMF.P8>
X 005000,177700,CLR,<SMF.IN!SMF.DD!SMF.11>
X 005000,007000,JMP,<SMF.IN!SMF.P8>
X 005100,177700,COM,<SMF.IN!SMF.DD!SMF.11>
X 005200,177700,INC,<SMF.IN!SMF.DD!SMF.11>
X 005300,177700,DEC,<SMF.IN!SMF.DD!SMF.11>
X 005400,177700,NEG,<SMF.IN!SMF.DD!SMF.11>
X 005500,177700,ADC,<SMF.IN!SMF.DD!SMF.11>
X 005600,177700,SBC,<SMF.IN!SMF.DD!SMF.11>
X 005700,177700,TST,<SMF.IN!SMF.DD!SMF.11>
X 006000,177700,ROR,<SMF.IN!SMF.DD!SMF.11>
X 006000,007000,IOT,<SMF.IN!SMF.P8>
X 006100,177700,ROL,<SMF.IN!SMF.DD!SMF.11>
X 006200,177700,ASR,<SMF.IN!SMF.DD!SMF.11>
X 006300,177700,ASL,<SMF.IN!SMF.DD!SMF.11>
X 006400,177700,MARK,<SMF.IN!SMF.MK!SMF.11>
X 006700,177700,SXT,<SMF.IN!SMF.DD!SMF.11>
X 007000,007777,NOP,<SMF.IN!SMF.P8>
X 007001,007401,IAC,<SMF.IN!SMF.P8>
X 007002,007416,BSW,<SMF.IN!SMF.P8>
X 007004,007406,RAL,<SMF.IN!SMF.P8>
X 007006,007406,RTL,<SMF.IN!SMF.P8>
X 007010,007412,RAR,<SMF.IN!SMF.P8>
X 007012,007412,RTR,<SMF.IN!SMF.P8>
X 007020,007420,CML,<SMF.IN!SMF.P8>
X 007040,007440,CMA,<SMF.IN!SMF.P8>
X 007100,007500,CLL,<SMF.IN!SMF.P8>
X 007200,007600,CLA,<SMF.IN!SMF.P8>
X 007400,007777,NOP,<SMF.IN!SMF.P8>
X 007401,007777,NOP,<SMF.IN!SMF.P8>
X 007402,007403,HLT,<SMF.IN!SMF.P8>
X 007404,007405,OSR,<SMF.IN!SMF.P8>
X 007410,007571,SKP,<SMF.IN!SMF.P8>
X 007420,007431,SNL,<SMF.IN!SMF.P8>
X 007421,007521,MQL,<SMF.IN!SMF.P8>
X 007430,007431,SZL,<SMF.IN!SMF.P8>
X 007440,007451,SZA,<SMF.IN!SMF.P8>
X 007450,007451,SNA,<SMF.IN!SMF.P8>
X 007500,007511,SMA,<SMF.IN!SMF.P8>
X 007501,007521,MQA,<SMF.IN!SMF.P8>
X 007510,007511,SPA,<SMF.IN!SMF.P8>
X 007521,007521,SWP,<SMF.IN!SMF.P8>
X 007600,007601,CLA,<SMF.IN!SMF.P8>
X 007601,007601,CLA,<SMF.IN!SMF.P8>
X 010000,170000,MOV,<SMF.IN!SMF.SS!SMF.11>
X 020000,170000,CMP,<SMF.IN!SMF.SS!SMF.11>
X 030000,170000,BIT,<SMF.IN!SMF.SS!SMF.11>
X 040000,170000,BIC,<SMF.IN!SMF.SS!SMF.11>
X 050000,170000,BIS,<SMF.IN!SMF.SS!SMF.11>
X 060000,170000,ADD,<SMF.IN!SMF.SS!SMF.11>
X 070000,177000,MUL,<SMF.IN!SMF.EI!SMF.11>
X 071000,177000,DIV,<SMF.IN!SMF.EI!SMF.11>
X 072000,177000,ASH,<SMF.IN!SMF.EI!SMF.11>
X 073000,177000,ASHC,<SMF.IN!SMF.EI!SMF.11>
X 074000,177000,XOR,<SMF.IN!SMF.JS!SMF.DD!SMF.11>
X 075000,177770,FADD,<SMF.IN!SMF.RT!SMF.11>
X 075010,177770,FSUB,<SMF.IN!SMF.RT!SMF.11>
X 075020,177770,FMUL,<SMF.IN!SMF.RT!SMF.11>
X 075030,177770,FDIV,<SMF.IN!SMF.RT!SMF.11>
X 077000,177000,SOB,<SMF.IN!SMF.SB!SMF.11>
X 100000,177400,BPL,<SMF.IN!SMF.BR!SMF.11>
X 100400,177400,BMI,<SMF.IN!SMF.BR!SMF.11>
X 101000,177400,BHI,<SMF.IN!SMF.BR!SMF.11>
X 101400,177400,BLOS,<SMF.IN!SMF.BR!SMF.11>
X 102000,177400,BVC,<SMF.IN!SMF.BR!SMF.11>
X 102400,177400,BVS,<SMF.IN!SMF.BR!SMF.11>
X 103000,177400,BCC,<SMF.IN!SMF.BR!SMF.11>
X 103000,177400,BHIS,<SMF.IN!SMF.BR!SMF.11>
X 103400,177400,BCS,<SMF.IN!SMF.BR!SMF.11>
X 103400,177400,BLO,<SMF.IN!SMF.BR!SMF.11>
X 104000,177400,EMT,<SMF.IN!SMF.EM!SMF.11>
X 104400,177400,TRAP,<SMF.IN!SMF.EM!SMF.11>
X 105000,177700,CLRB,<SMF.IN!SMF.DD!SMF.BY!SMF.11>
X 105100,177700,COMB,<SMF.IN!SMF.DD!SMF.BY!SMF.11>
X 105200,177700,INCB,<SMF.IN!SMF.DD!SMF.BY!SMF.11>
X 105300,177700,DECB,<SMF.IN!SMF.DD!SMF.BY!SMF.11>
X 105400,177700,NEGB,<SMF.IN!SMF.DD!SMF.BY!SMF.11>
X 105500,177700,ADCB,<SMF.IN!SMF.DD!SMF.BY!SMF.11>
X 105600,177700,SBCB,<SMF.IN!SMF.DD!SMF.BY!SMF.11>
X 105700,177700,TSTB,<SMF.IN!SMF.DD!SMF.BY!SMF.11>
X 106000,177700,RORB,<SMF.IN!SMF.DD!SMF.BY!SMF.11>
X 106100,177700,ROLB,<SMF.IN!SMF.DD!SMF.BY!SMF.11>
X 106200,177700,ASRB,<SMF.IN!SMF.DD!SMF.BY!SMF.11>
X 106300,177700,ASLB,<SMF.IN!SMF.DD!SMF.BY!SMF.11>
X 106400,177700,MTPS,<SMF.IN!SMF.DD!SMF.11>
X 106700,177700,MFPS,<SMF.IN!SMF.DD!SMF.11>
X 110000,170000,MOVB,<SMF.IN!SMF.SS!SMF.BY!SMF.11>
X 120000,170000,CMPB,<SMF.IN!SMF.SS!SMF.BY!SMF.11>
X 130000,170000,BITB,<SMF.IN!SMF.SS!SMF.BY!SMF.11>
X 140000,170000,BICB,<SMF.IN!SMF.SS!SMF.BY!SMF.11>
X 150000,170000,BISB,<SMF.IN!SMF.SS!SMF.BY!SMF.11>
X 160000,170000,SUB,<SMF.IN!SMF.SS!SMF.11>
X 163000,177777,UBAMAP,<SMF.11>
X 163100,177777,UBA.SR,<SMF.11>
;X 163200,177777,UBA.VC,<SMF.11>
X 163300,177777,UBA.MR,<SMF.11>
X 177570,177777,SW,<SMF.11>
X 177776,177777,PS,<SMF.11>
LIST
>

DEFINE CALL (ADDR) <XLIST
.XCREF
IFE <DEBUG-2>,<CALLXX ADDR>
IFL <DEBUG-2>,<PUSHJ P,ADDR>
.CREF
LIST>

DEFINE CALLXX (ADDR,%FAKE,%FAKE1) <
	SKIPA QX,F.DEBU
	JRST %FAKE
	TXNN QX,DB.CAL
	JRST %FAKE1
	PUSH P,T1
	PUSH P,T2
	MOVE T1,[SIXBIT \ADDR\]
	MOVEI T2,ADDR
	PUSHJ P,CALLTY
	POP P,T2
	POP P,T1
%FAKE1:!PUSHJ P,ADDR
%FAKE:!>

DEFINE RET (OPT,LABEL) <XLIST
.XCREF
IFE <DEBUG-2>,<RETXX (OPT,LABEL)>
IFL <DEBUG-2>,<IFNB <OPT>,< IFIDN <OPT><SKIP>,<
	AOS (P)
	POPJ P, >
IFIDN <OPT><SAFE>,<JRST RSKP>>
IFB <OPT>,<POPJ P,>>
.CREF
LIST>

DEFINE RETXX (OPT,LABEL,%FAKE,%FAKE1) <
IFNB <LABEL>,<
	SKIPA QX,F.DEBU
	JRST %FAKE
	TXNN QX,DB.CAL
	JRST %FAKE1
	PUSH P,T1
	MOVE T1,[SIXBIT /LABEL/]
IFB <OPT>,<PUSHJ P,RETTY1>
IFNB <OPT>,<PUSHJ P,RETTY2>
	POP P,T1
>
IFNB <OPT>,<
 IFIDN <OPT><SKIP>,<
%FAKE1:!AOS (P)
%FAKE:!	POPJ P,
 >
 IFIDN <OPT><SAFE>,<
%FAKE1:!JRST RSKP
%FAKE:!>>
IFB <OPT>,<
%FAKE1:!POPJ P,
%FAKE:!>>


DEFINE TYPE (X) <XLIST
.XCREF
	MOVEI T1,[ASCIZ \X\]
	PUSHJ P,TYPSTR
.CREF
LIST>


DEFINE DEBTYP (X) <XLIST
.XCREF
IFN <DEBUG>,<
	MOVEI T1,[ASCIZ \X\]
	SKIPE F.DEBU
	PUSHJ P,TYPSTR
>
.CREF
LIST>


DEFINE DBGTYP (TX,X) <XLIST
.XCREF
IFN <DEBUG>,<
	MOVE QX,F.DEBU		; GET THE DEBUG FLAG
	MOVEI T1,[ASCIZ \X\]
	TRNE QX,TX		; IS THIS OPTION EMABLED ??
	PUSHJ P,TYPSTR		; YES, TYPE THE STRING
>
.CREF
LIST>



DEFINE DBG1TYP (TX,X) <XLIST
.XCREF
IFN <DEBUG>,<
	PUSH P,T1
	MOVE QX,F.DEBU ; GET THE DEBUG FLAG
	MOVEI T1,[ASCIZ \X\]
	TRNE QX,TX		; IS THIS OPTION ENABLED ??
	PUSHJ P,TYPSTR		; YES, TYPE THE STRING
	POP P,T1
>
.CREF
LIST>


DEFINE SWTCON (LABS,VALS) <IRP LABS,<Y'LABS::>
ZZ==0
IRP VALS,<ZZ=ZZ!Z'VALS>
	EXP ZZ
>

DEFINE SWTCHK (SWT) <IF2 <
IFNDEF Z'SWT,<EXTERNAL Z'SWT>
IFNDEF Y'SWT,<EXTERNAL Y'SWT>>
XLIST
	MOVE T1,[Z'SWT]		;; GET THIS SWITCH
	MOVE T2,Y'SWT		;; GET THE DISALLOWED SWITCHES
	CALL SWTTST		;; SEE IF THIS IS AN OK MATCH
	POPJ P,			;; CONFLICT
LIST
>



DEFINE ENTEXT (TYPE,LLIST)<
IRP LLIST,<TYPE LLIST>
>

DEFINE ENT11 (MAGIC)<
XLIST
ENTEXT (MAGIC,<MEMORY,MEMLIM,MEMUSE,MOVMEM,MOVSMT,SYMBEG,SAVE4,SAVE35,POSYMT>)
ENTEXT (MAGIC,<DELSYM,OSTYPE,DDT11,LASTSW,LEVL.0,PDP8F,DAT,DATA,CALER0,R,RSKP>)
ENTEXT (MAGIC,<SWTMSK,SWTTST,SYMBOL,SYMBEG,SYMEND,SAVE2,SAVE34,LEVEL0,LEVEL2>)
ENTEXT (MAGIC,<VALFND,CMDLIM,O.MODE,DOTFOO,GOTO,INVLFN,RGFNDN,MOVMUS,TYPDAT>)
ENTEXT (MAGIC,<SYMFND,CNINWD,SBEGIN,DOTINC,CMDTKR,LSTADR,RSTART,ADDSYM,ORADIX>)
ENTEXT (MAGIC,<S..END,EXPRES,NDTFOO,ESC.Q.,BYTCNT,SAVE24,COMLF1,CORERR,CALERR>)
ENTEXT (MAGIC,<GENERR,F.DEBU,F.MSYS,F.DMCB,F.MCBD,TYPE11,F.MCB,F.HALT>)
IFN DEBUG,<
ENTEXT (MAGIC,<CALLTY,RETTY1,RETTY2>)
>
LIST
>

DEFINE ENTGP (MAGIC)<
XLIST
ENTEXT (MAGIC,<PUTFOO,DTEERR,QUED60,GETWRD,PUTBYT,SETUPN,CLRMEM,NODSET>)
ENTEXT (MAGIC,<GETMEM,ETYPE,CACHEL,CACHE,NODE.N,LINE,PORT,SET.FE,SETBIN>)
ENTEXT (MAGIC,<SETDFE,SETDMP,SETFOO,SETLIN,SETMCB,SETMCS,SETNOD,SETPRT,SETUBA>)
LIST
>

DEFINE ENTSIM (MAGIC)<
XLIST
ENTEXT (MAGIC,<UBACTL,SIMXCT,MAPCOR,UPTIME,INSRUN,WAITIM,SIMREG,SETUPC,SIMREL>)
ENTEXT (MAGIC,<IOBSTO,IOLOAD,IOSTOR,IOLDM1>)
LIST
>

DEFINE ENTFIL (MAGIC)<
XLIST
ENTEXT (MAGIC,<ADRTYP,B3.TYP,BLANKT,CMDCNT,CMDFIL,COLTYP,COMTYP,CRLTYP,CSECHO>)
ENTEXT (MAGIC,<DATYPE,DECINP,DECTYP,ESC..D,ESC..P,ESC..Y,FILPOS,IDTYPE,MRGFLG>)
ENTEXT (MAGIC,<MYPPN,OCTYPE,OHD,OPNFL0,PCNTYP,PDECTY,PERTYP,QESTYP,RADTYP>)
ENTEXT (MAGIC,<RDDUMP,RSTATE,SETFES,SETMRG,SETREL,SETRST,SETSYM,SIXIN,SIXTYP>)
ENTEXT (MAGIC,<TABTYP,TIMTY1,TYPCHR,TYPSTR,GETCHR,SIXOCT,FILDEV,DEFEXT,RATYPE>)
ENTEXT (MAGIC,<LATYPE>)
LIST
>



; DEFINE THE VARIOUS TYPES OF -11S WE CAN WORK WITH...

DEFINE CPUINF <
XLIST
; X A,B,C WHERE A IS THE CPU TYPE, B IS THE NUMBER TO TYPE FOR THIS CPU,
;		AND C IS THE WIDTH OF THE LARGEST MEMORY ADDRESS

;	CPU	ID	WIDTH

X	8,	8,	12	; PDP8
X	02,	2,	16	; 11/02
X	03,	3,	16	; 11/03
X	04,	4,	16	; 11/04
X	05,	5,	16	; 11/05
X	10,	10,	16	; 11/10
X	15,	15,	16	; 11/15
X	20,	20,	16	; 11/20
X	23,	23,	18	; 11/23
X	3P,	231,	22	; 11/23 PLUS
X	24,	24,	22	; 11/24
X	34,	34,	16	; 11/34
X	35,	35,	18	; 11/35
X	40,	40,	18	; 11/40
X	44,	44,	22	; 11/44
X	45,	45,	18	; 11/45
X	55,	55,	18	; 11/55
X	60,	60,	22	; 11/60
X	70,	70,	22	; 11/70
X	74,	74,	22	; 11/74
LIST
>



;MACRO TO REMEMBER REFERENCES TO SIMULATED CORE

DEFINE MEMREL (QQ) <XLIST
IF2 <Q=.
	RELOC RLMTAB+RLMSIZ
	QQ,,Q
	RELOC Q>
	RLMSIZ=	RLMSIZ+1
LIST>

;MACRO TO GET A WORD FROM MEMORY

; FIRST ARG IS REGISTER TO USE AS AN INDEX ; 2ND ARG IS DESTINATION

DEFINE LOAD (Q,QQ) <
IFN <Q-PC> <	TRNE Q,1
		JRST NXM...>
IFN <MA-Q>,<	HRRZ MA,Q>
MEMREL	MEMLIM
		CAIL MA,0
IFE <QQ-T1> <	CALL IOLOAD
LODRET==4>
IFN <QQ-T1> <	JRST [	MOVEM T1,IOLT1S# ;SAVE T1
			CALL IOLOAD+2
			HRRZ QQ,T1
			MOVE T1,IOLT1S#	;RESTORE T1
			JRST .+LODRET+1]>
		ROT MA,-2
		SKIPGE MA
MEMREL	MEMORY
		SKIPA QQ,0(MA)
MEMREL	MEMORY
		HLRZ QQ,0(MA)
		ANDI QQ,177777 ;STRIP EXTRA BITS
IFE <QQ-PC> <	TRNE PC,1
		JRST NXM...>>

;MACRO TO GET A BYTE FROM MEMORY
; FIRST ARG IS REGISTER TO USE AS AN INDEX
; 2ND ARG IS DESTINATION

DEFINE BLOAD (Q,QQ) <
IFN <MA-Q>,<	HRRZ MA,Q>
MEMREL	MEMLIM
		CAIL MA,0
		CALL IOBLOD
BLDRET==7			;NUMBER OF INSTRUCTIONS TO SKIP
		LSHC MA,-2	;IDIVI	MA,4
		LSH MA+1,-^D34
		TRNE MA+1,2
MEMREL	MEMORY
		SKIPA QQ,0(MA) ;GET RH OF WORD
MEMREL	MEMORY
		HLRZ QQ,0(MA) ;GET LH OF WORD
		TRNE MA+1,1	;WANT ODD BYTE ?
		LSH QQ,-^D8	;YES
		ANDI QQ,377>	;STRIP EXTRA BITS



				;MACRO TO STORE WORD OR BYTE IN MEMORY AFTER DOING LOAD FROM SAME LOCATION
; ADDRESS IS IN MA, DATA IS FOUND IN T1 (LH MAY BE NONZERO E.G. SBC)

DEFINE RSTORE (FLAG,TYPE) <
IFE <<FLAG>&SMF.BY> <TLNE MA,MA..RG ;WAS LOCATION A REGISTER ?
		JRST [	HRRM T1,(MA)	;DEPOSIT APPROPRIATE REG
			TRNN PC,1 ;IN CASE SET PC
			JRST SIM11 ;PC WAS GARBAGED
			JRST NXM...	] ;TAKE A TRAP
		TLNE MA,MA..IO	;WAS LOCATION AN IO REGISTER ?
		JRST [	PUSH P,[EXP SIM11] ;PUSH RETURN ON STACK
			JRST IOR.'TYPE ] ;RESTORE WORD TO MEMORY
		SKIPGE MA
		JRST .+3
MEMREL	MEMORY
		HRLM T1,0(MA)
		JRST SIM11
MEMREL	MEMORY
		HRRM T1,0(MA)>
IFN <<FLAG>&SMF.BY> <TLNN MA,MA..RG ;WAS LOCATION A REGISTER ?
		JRST .+5	;NOT A REGISTER
		DPB T1,[POINT 8,(MA),35] ;THIS IS SLOW BUT PROB BEST WAY
		TRNN PC,1	;CHECK PC NOT POLLUTED
		JRST SIM11
		JRST NXM...	;TAKE A BUS TRAP
		TLNE MA,MA..IO	;WAS LOCATION AN IO REGISTER ?
		JRST [PUSH P,[EXP SIM11] ;PUSH RETURN ON STACK
			JRST IOBR.'TYPE ] ;RESTORE BYTE TO MEMORY
		DPB T1,SIMPTR(MA+1)>> ;PUT BYTE BACK INTO MEMORY


;MACRO TO STORE A WORD IN MEMORY
; FIRST ARG IS REGISTER TO USE AS AN INDEX
; 2ND ARG IS DESTINATION

DEFINE STORE (Q,QQ) <
IFN <Q-PC> <	TRNE Q,1
		JRST NXM...>
IFN <MA-Q>,<	HRRZ MA,Q>
MEMREL	MEMLIM
		CAIL MA,0
		JRST [
IFN <T1-QQ>,<		HRRZ T1,QQ>
Z=	7
IFE <Q-6> <Z=Z+2>
			PUSH P,[EXP .+Z]
			JRST IOSTOR ]
IFE <Q-6>,<	CAIGE MA,400
		JSR STCKVP>
		ROT MA,-2
		SKIPGE MA
		JRST .+3
MEMREL	MEMORY
		HRLM QQ,0(MA)
		JRST .+2
MEMREL	MEMORY
		HRRM QQ,0(MA)
>


;MACRO TO STORE A BYTE IN MEMORY
; FIRST ARG IS REGISTER TO USE AS AN INDEX
; 2ND ARG IS DESTINATION

DEFINE BSTORE (Q,QQ) <
IFN <MA-Q>,<	HRRZ MA,Q>
MEMREL	MEMLIM
		CAIL MA,0
		JRST [
IFN <T1-QQ>,<		HRRZ T1,QQ>
Z=	4
IFE <Q-6>,<Z=Z+2>
			PUSH P,[EXP .+Z]
			JRST IOBSTO ]
IFE <Q-6>,<	CAIGE MA,400
		JSR STCKVP>
		LSHC MA,-2
		LSH MA+1,-^D34
		DPB QQ,SIMPTR(MA+1)
>


;MACRO TO PUT PC AND PS ON STACK

DEFINE INTSAV (VEC) <
	CAIG SP,177774
	CAIG SP,400-40
	JRST RSTACK		;RED STACK VIOLATION
	MOVEI SP,-4(SP)
	HRRZI MA,2(SP)
	STORE MA,PS		;SAVE PS ON STACK
	STORE SP,PC		;SAVE PC ON STACK
	MOVEI MA,VEC
	LOAD MA,T2		;GET NEW PC IN TEMP REG
	MOVEI MA,2+VEC
	LOAD MA,T1		;GET NEW PS
	ANDI T1,377		;ONLY HAVE A RH
	EXCH PS,T1		;SET NEW PS (AND PRESERVE OLD ONE)
	MOVE PC,T2		;LOAD NEW PC
	CALL PS.CHK		;ADJUST FOR NEW PS LEVEL
	TRNE PC,1		;BE SURE OK
	JRST NXM...		;TAKE A BUS TRAP
>
DEFINE ADC. (FLAG) <
	JSR @RFETCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	TRZE PS,PS...C
	JRST .+6
	TRNE T1,100000
	TRO PS,PS...N
	JUMPN T1,SIM11
	TRO PS,PS...Z
	JRST SIM11
	AOS T1
	TRNE T1,100000
	TRO PS,PS...N
	TRZE T1,200000	;OVERFLOW IFF WENT TO ZERO
	TRO PS,PS...Z!PS...C
	CAIN T1,100000
	TRO PS,PS...V
	RSTORE FLAG
>

DEFINE ADCB. (FLAG) <
	JSR @BRFTCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	TRZE PS,PS...C
	JRST .+6
	TRNE T1,000200
	TRO PS,PS...N
	JUMPN T1,SIM11
	TRO PS,PS...Z
	JRST SIM11
	AOS T1
	TRNE T1,000200
	TRO PS,PS...N
	TRZE T1,000400	;OVERFLOW IFF WENT TO ZERO
	TRO PS,PS...Z!PS...C
	CAIN T1,000200
	TRO PS,PS...V
	RSTORE FLAG
>

DEFINE ADD. (FLAG) <
	MOVE T2,T1		;SAVE SRC
	JSR @RFETCH(IR)		;GET DST
	MOVE IR,T1		;SAVE COPY OF DST FOR PS...V CALC
	ADD T1,T2		;MAKES RESULT
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	TRNE T1,100000	;CHECK FOR NEGATIVE
	TRO PS,PS...N
	TRZE T1,600000	;CHECK FOR OVERFLOW
	TRO PS,PS...C
	SKIPN	T1
	TRO PS,PS...Z
	EQV IR,T2		;SRC EQV DST
	XOR T2,T1		;RESULT XOR SRC
	AND T2,IR
	TRNE T2,100000
	TRO PS,PS...V
	RSTORE FLAG
>

DEFINE ASH. (FLAG) <
	ANDI T2,7		;LEAVE ONLY REG FIELD
	JSR @FETCH(IR)		;GET NN
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	MOVE MA,(T2)		;GET REGISTER TO SHIFT
	TRNE MA,100000	;WAS REGISTER NEGATIVE ?
	IOR MA,[-1,,700000]	;EXTEND SIGN
	TRNE T1,40		;RIGHT OR LEFT SHIFT ?
	JRST [IORI T1,777740 ;SHIFT RIGHT
		ASHC MA,(T1)	;SHIFT IT
		TLNE MA+1,200000 ;WAS LAST BIT OUT A 1 ?
		TRO PS,PS...C ;REMEMBER LAST BIT OUT
		JRST .+13 ]
	ANDI T1,37		;SHIFT LEFT
				;JUMPE	T1, ????		*****
				;	*****				*****
				;	*****	WHAT IF SHIFT 0 ???	*****
				;	*****				*****
	JOV .+1		;CLEAR FLAG
	ASH MA,(T1)		;SHIFT IT
	TRNE MA,200000	;WAS LAST BIT OUT SET ?
	TRO PS,PS...C	;LAST BIT OUT WAS SET
	JOV .+4		;LOSE ANY BITS ?
	SKIPGE T1,MA		;NEGATIVE ?
	XOR T1,[-1,,700000]
	TDNE T1,[-1,,700000]
	TRO PS,PS...V
	ANDI MA,177777	;STRIP EXTRA BITS
	TRNE MA,100000	;IS RESULT NEGATIVE ?
	TRO PS,PS...N	;WAS NEGATIVE RESULT
	SKIPN MA		;WAS RESULT ZERO ?
	TRO PS,PS...Z	;YES
	MOVEM MA,(T2)		;UPDATE ORIGINAL REGISTER
	TRNE PC,1		;DID THAT POLLUTE THE PC ?
	JRST NXM...		;GIVE A BUS TRAP
>

DEFINE ASHC. (FLAG) <
				; *****				*****
				; *****	WHAT IF REG IS ODD ??	*****
				; *****				*****
	ANDI T2,7		;LEAVE ONLY REG FIELD
	JSR @FETCH(IR)		;GET NN
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	MOVE MA,(T2)		;GET HIGH ORDER BITS
	LSH MA,^D16		;POSITION
	MOVE IR,T2		;COPY REGISTER ADR
	IORI IR,1		;MAKE LOW ORDER BITS ADR
	IOR MA,(IR)		;GET LOW ORDER BITS
	TLNE MA,020000		;WAS REG NEGATIVE ?
	TLO MA,740000	;EXTEND SIGN
	TRNE T1,40		;RIGHT OR LEFT SHIFT ?
	JRST [IORI T1,777740 ;SHIFT RIGHT
		ASHC MA,(T1)	;SHIFT IT
		TLNE MA+1,200000 ;WAS LAST BIT OUT A 1 ?
		TRO PS,PS...C
		JRST .+13 ]
	ANDI T1,37		;SHIFT LEFT
				;JUMPE	T1, ????		*****
				;	*****				*****
				;	*****	WHAT IF SHIFT 0 ???	*****
				;	*****				*****
	JOV .+1		;CLEAR FLAG
	ASH MA,(T1)		;SHIFT IT
	TLNE MA,040000		;WIN A CARRY BIT ?
	TRO PS,PS...C	;WON A CARRY
	JOV .+4
	SKIPGE T1,MA		;WAS THAT NEGATIVE ?
	TLC T1,760000	;CL7AR EXTENDED SIGN
	TLNE T1,760000		;DID WE LOSE BITS ?
	TRO PS,PS...V	;LOST BITS
	TLNE MA,020000		;IS RESULT NEGATIVE ?
	TRO PS,PS...N	;WAS NEGATIVE RESULT
	TLZ MA,740000	;STRIP EXTRA BITS
	SKIPN MA		;WAS RESULT ZERO ?
	TRO PS,PS...Z	;YES
	MOVE T1,MA		;COPY RESULT
	ANDI T1,177777	;STRIP EXTRA BITS
	MOVEM T1,(IR)		;RESTORE LOW ORDER BITS
	LSH MA,-^D16	;POSITION HIGH ORDER BITS
	MOVEM MA,(T2)		;RESTORE NEW HIGH ORDER BITS
	TRNE PC,1		;DID THAT POLLUTE THE PC ?
	JRST NXM...		;GIVE A BUS TRAP
>

DEFINE ASL. (FLAG) <
	JSR @RFETCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	TRNN T1,040000	;CHECK NEW N BIT
	JRST .+5		;NO NEW N BIT
	TRZE T1,100000	;CHECK NEW C BIT
	TROA	PS,PS...N!PS...C
	TRO PS,PS...N!PS...V
	JRST .+3
	TRZE T1,100000	;CHECK NEW C BIT
	TRO PS,PS...C!PS...V
	LSH T1,1
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG
>

DEFINE ASLB. (FLAG) <
	JSR @BRFTCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	TRNN T1,000100	;CHECK NEW N BIT
	JRST .+5		;NO NEW N BIT
	TRZE T1,000200	;CHECK NEW C BIT
	TROA	PS,PS...N!PS...C
	TRO PS,PS...N!PS...V
	JRST .+3
	TRZE T1,000200	;CHECK NEW C BIT
	TRO PS,PS...C!PS...V
	LSH T1,1
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG
>

DEFINE ASR. (FLAG) <
	JSR @RFETCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	TRNN T1,100000	;CHECK NEW N BIT
	JRST .+6		;NO NEW N BIT
	TRO T1,200000	;SET NEW SIGN BIT
	TRZE T1,1		;CHECK NEW C BIT
	TROA	PS,PS...N!PS...C
	TRO PS,PS...N!PS...V
	JRST .+3
	TRZE T1,1		;CHECK NEW C BIT
	TRO PS,PS...C!PS...V
	LSH T1,-1
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG
>
DEFINE ASRB. (FLAG) <
	JSR @BRFTCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	TRNN T1,000200	;CHECK NEW N BIT
	JRST .+6		;NO NEW N BIT
	TRO T1,000400	;SET NEW SIGN BIT
	TRZE T1,1		;CHECK NEW C BIT
	TROA	PS,PS...N!PS...C
	TRO PS,PS...N!PS...V
	JRST .+3
	TRZE T1,1		;CHECK NEW C BIT
	TRO PS,PS...C!PS...V
	LSH T1,-1
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG
>

DEFINE BIC. (FLAG) <
	MOVE T2,T1		;COPY SRC
	JSR @RFETCH(IR)		;GET DST
	ANDCM	T1,T2		;CLEAR SOME BITS
	TRZ PS,PS...N!PS...Z!PS...V
	TRNE T1,100000
	TRO PS,PS...N
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG,C
>

DEFINE BICB. (FLAG) <
	MOVE T2,T1		;COPY SRC
	JSR @BRFTCH(IR)		;GET DST
	ANDCM	T1,T2		;CLEAR SOME BITS
	TRZ PS,PS...N!PS...Z!PS...V
	TRNE T1,000200
	TRO PS,PS...N
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG,C
>

DEFINE BIS. (FLAG) <
	MOVE T2,T1		;COPY SRC
	JSR @RFETCH(IR)		;GET DST
	IOR T1,T2		;SET NEW BITS
	TRZ PS,PS...N!PS...Z!PS...V
	TRNE T1,100000
	TRO PS,PS...N
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG,S
>

DEFINE BISB. (FLAG) <
	MOVE T2,T1		;COPY SRC
	JSR @BRFTCH(IR)		;GET DST
	IOR T1,T2		;SET NEW BITS
	TRZ PS,PS...N!PS...Z!PS...V
	TRNE T1,000200
	TRO PS,PS...N
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG,S
>

DEFINE BIT. (FLAG) <
	MOVE T2,T1		;COPY FIRST OPERAND
	JSR @FETCH(IR)		;GET 2ND OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	AND T1,T2		;MASK THE BITS
	SKIPN T1
	TRO PS,PS...Z
	TRNE T1,100000
	TRO PS,PS...N
>

DEFINE BITB. (FLAG) <
	MOVE T2,T1		;COPY FIRST OPERAND
	JSR @BFETCH(IR)		;GET 2ND OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	AND T1,T2		;MASK THE BITS
	SKIPN T1
	TRO PS,PS...Z
	TRNE T1,000200
	TRO PS,PS...N
>

;DEFINE CCC. (FLAG) <>	;HANDLED BY .CCCLR

;DEFINE CLC. (FLAG) <>	;HANDLED BY .CCCLR

;DEFINE CLN. (FLAG) <>	;HANDLED BY .CCCLR

DEFINE CLR. (FLAG) <
	HRRM PS,PS.REG+1	;IN CASE OF BUS TRAP
	SETZ T1,
	TRZ PS,PS...N!PS...V!PS...C
	TRO PS,PS...Z
	JRST @STUFF(IR)
ZZRET==	-1
>

DEFINE CLRB. (FLAG) <
	HRRM PS,PS.REG+1	;IN CASE OF BUS TRAP
	SETZ T1,
	TRZ PS,PS...N!PS...V!PS...C
	TRO PS,PS...Z
	JRST @BSTUFF(IR)
ZZRET==	-1
>

;DEFINE CLV. (FLAG) <>	;HANDLED BY .CCCLR

;DEFINE CLZ. (FLAG) <>	;HANDLED BY .CCCLR

DEFINE CMP. (FLAG) <
	MOVE T2,T1		;COPY FIRST OPERAND
	JSR @FETCH(IR)		;GET 2ND OPERAND
	MOVE IR,T2		;ANOTHER COPY OF SRC FOR PS...V CALC
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	SUB T2,T1
	TRNE T2,100000
	TRO PS,PS...N
	TRNN T2,177777
	TRO PS,PS...Z
	TRNE T2,200000
	TRO PS,PS...C
	XOR IR,T1		;SRC XOR DST
	EQV T1,T2		;CHECK RESULT AND DST
	AND T1,IR
	TRNE T1,100000
	TRO PS,PS...V	;SAME SIGN SO OVERFLOW
>

DEFINE CMPB. (FLAG) <
	MOVE T2,T1		;COPY FIRST OPERAND
	JSR @BFETCH(IR)		;GET 2ND OPERAND
	MOVE IR,T2		;ANOTHER COPY OF SRC FOR PS...V CALC
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	SUB T2,T1
	TRNE T2,000200
	TRO PS,PS...N
	TRNN T2,000377
	TRO PS,PS...Z
	TRNE T2,000400
	TRO PS,PS...C
	XOR IR,T1		;SRC XOR DST
	EQV T1,T2		;CHECK RESULT AND DST
	AND T1,IR
	TRNE T1,000200
	TRO PS,PS...V	;SAME SIGN SO OVERFLOW
>

DEFINE COM. (FLAG) <
	JSR @RFETCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	TRO PS,PS...C
	TRCE	T1,177777	;PERFORM COMPLEMENT AND CHECK FOR -1 RESULT
	TRNE T1,100000
	TRO PS,PS...N
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG
>

DEFINE COMB. (FLAG) <
	JSR @BRFTCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	TRO PS,PS...C
	TRCE	T1,000377	;PERFORM COMPLEMENT AND CHECK FOR -1 RESULT
	TRNE T1,000200
	TRO PS,PS...N
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG
>

DEFINE DEC. (FLAG) <
	JSR @RFETCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	SOSN	T1
	TRO PS,PS...Z
	ANDI T1,177777
	TRNE T1,100000
	TRO PS,PS...N
	CAIN T1,077777
	TRO PS,PS...V
	RSTORE FLAG
>

DEFINE DECB. (FLAG) <
	JSR @BRFTCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	SOSN	T1
	TRO PS,PS...Z
	ANDI T1,000377
	TRNE T1,000200
	TRO PS,PS...N
	CAIN T1,000177
	TRO PS,PS...V
	RSTORE FLAG
>

DEFINE DIV. (FLAG) <
	ANDI T2,7		;LEAVE REGISTER FIELD
	JSR @FETCH(IR)		;GET DIVISOR
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	JUMPE	T1,[TRO PS,PS...C!PS...V ;SET FLAGS
		JRST SIM11 ]
	TRNE T1,100000	;NEGATIVE DIVSOR ?
	IOR T1,[-1,,700000]	;EXTEND SIGN
	MOVE MA,(T2)		;GET HIGH ORDER BITS OF DIVIDEND
	LSH MA,^D16		;POSITION
	TLNE MA,020000		;NEGATIVE ?
	TLO MA,760000	;EXTEND SIGN
	MOVE IR,T2		;COPY REG ADR
	IORI IR,1
	IOR MA,(IR)		;GET LOW ORDER BITS
	IDIV	MA,T1		;DO THE DIVISION
	ANDI MA,177777	;STRIP EXTRA BITS
	MOVEM MA,(T2)
	TRO T1,1		;OTHER REGISTER
	ANDI MA+1,177777	;STRIP OTHER BITS
	MOVEM MA+1,(T2)		;AND SAVE THESE AS WELL
	TRNE MA,100000	;NEGATIVE RESULT ?
	TRO PS,PS...N	;REMEMBER NEGATIVE
	ANDI MA,177777	;STRIP EXTRA BITS
	SKIPN MA
	TRO PS,PS...Z	;REMEMBER ZERO RESULT
	TRNE PC,1		;DID THAT POLLUTE THE PC ?
	JRST NXM...		;GIVE A BUS TRAP
>

DEFINE FADD. (FLAG) <
	JRST ILLINS
ZZRET==	-1
>

DEFINE FDIV. (FLAG) <
	JRST ILLINS
ZZRET==	-1
>

DEFINE FMUL. (FLAG) <
	JRST ILLINS
ZZRET==	-1
>

DEFINE FSUB. (FLAG) <
	JRST ILLINS
ZZRET==	-1
>

DEFINE HALT. (FLAG) <
	TXZ FLG,F.RUNF
	SETOM F.HALT		;FLAG THE HALT INSTRUCTION
	HRROS	INTDLY		;SO WE NOTICE RUN FLOP
>

DEFINE INC. (FLAG) <
	JSR @RFETCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	AOS T1
	TRNE T1,100000
	TRO PS,PS...N
	TRZE T1,200000	;HAPPENS IIF
	TRO PS,PS...Z	; OPERAND NOW ZERO
	CAIN T1,100000
	TRO PS,PS...V
	RSTORE FLAG
>

DEFINE INCB. (FLAG) <
	JSR @BRFTCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	AOS T1
	TRNE T1,000200
	TRO PS,PS...N
	TRZE T1,000400	;HAPPENS IFF
	TRO PS,PS...Z	; OPERAND NOW ZERO
	CAIN T1,000200
	TRO PS,PS...V
	RSTORE FLAG
>

DEFINE JMP. (FLAG) <
	JSR @JMPCLC(IR)		;CALCULATE ADDR
	MOVE PC,T1		;SET NEW PC
	TRNE PC,1		;BE SURE KOSHER PC
	JRST NXM...
>

DEFINE MOV. (FLAG) <
	HRRM PS,PS.REG+1	;SAVE PS IN CASE OF STACK VIOLATION
	TRZ PS,PS...N!PS...Z!PS...V
	TRNE T1,100000	;DO WE WANT N BIT
	TRO PS,PS...N	;SET N BIT
	SKIPN T1
	TRO PS,PS...Z	;SET Z BIT
	JRST @STUFF(IR)
ZZRET==	-1
>

DEFINE MOVB. (FLAG) <
	HRRM PS,PS.REG+1	;SAVE PS IN CASE OF STACK VIOLATION
	TRZ PS,PS...N!PS...Z!PS...V
	TRNE T1,000200	;DO WE WANT N BIT
	TRO PS,PS...N	;SET N BIT
	SKIPN T1
	TRO PS,PS...Z	;SET Z BIT
	TRNE IR,70		;CHECK FOR REGISTER DST
	JRST @BSTUFF(IR)
	TRNE T1,200		;WANT TO EXTEND SIGN ?
	TRO T1,177600	;EXTEND SIGN
	HRRM T1,(IR)
>

DEFINE MUL. (FLAG) <
	ANDI T2,7		;LEAVE ONLY REGISTER FIELD
	JSR @FETCH(IR)		;GET THE SOURCE OPERAND
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	TRNE T1,100000	;NEGATIVE VALUE ?
	IOR T1,[-1,,700000]	;EXTEND SIGN
	MOVE MA,(T2)		;GET REGISTER ARGUMENT
	TRNE MA,100000	;NEGATIVE ARGUMENT ?
	IOR MA,[-1,,700000]	;EXTEND SIGN
	IMULB	T1,MA		;DO THE MULTIPLICATION
	SKIPN T1		;WAS RESULT ZERO
	TRO PS,PS...Z	;REMEMBER IT WAS ZERO
	TLNE T1,020000		;IS RESULT NEGATIVE ?
	TRO PS,PS...N	;REMEMBER IT WAS NEGATIVE
	CAML	T1,[-1,,700000]
	CAILE	T1,077777
	TRO PS,PS...C	;NEED MORE THAN 16 BITS
	ANDI MA,177777	;LEAVES LOW ORDER PORTION
	LSH T1,-^D16	;LEAVES HIGH ORDER PORTION
	ANDI T1,177777	;STRIP EXTRA IF ANY
	MOVEM T1,(T2)		;STORE HIGH ORDER PORTION
	IORI T2,1		;OTHER REG ADDRESS
	MOVEM MA,(T2)
	TRNE PC,1		;DID THAT CORRUPT THE PC ?
	JRST NXM...		;YES SO TAKE A BUS TRAP
>

DEFINE NEG. (FLAG) <
	JSR @RFETCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	MOVNS	T1
	ANDI T1,177777
	TRNE T1,100000
	TRO PS,PS...N
	SKIPN T1
	TROA	PS,PS...Z
	TRO PS,PS...C
	CAIN T1,100000
	TRO PS,PS...V
	RSTORE FLAG
>

DEFINE NEGB. (FLAG) <
	JSR @BRFTCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	MOVNS	T1
	ANDI T1,000377
	TRNE T1,000200
	TRO PS,PS...N
	SKIPN T1
	TROA	PS,PS...Z
	TRO PS,PS...C
	CAIN T1,000200
	TRO PS,PS...V
	RSTORE FLAG
>

;DEFINE NOP. (FLAG) <>	;HANDLED BY .CCCLR
DEFINE RESET. (FLAG) <
	CALL R.SET		;DO COMMON STUFF
>

DEFINE ROL. (FLAG) <
	JSR @RFETCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	TRZE PS,PS...C
	TLO T1,400000	;CARRY BIT GOES TO SIGN BIT
	TRZE T1,100000	;CHECK NEW CARRY
	TRO PS,PS...C!PS...V ;NEW CARRY AND OVERFLOW (MAYBE)
	ROT T1,1
	TRNE T1,100000	;GET A NEGATIVE RESULT ?
	TRC	PS,PS...N!PS...V ;WIN NEGATIVE AND COMPLEMENT OVERFLOW
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG
>

DEFINE ROLB. (FLAG) <
	JSR @BRFTCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	TRZE PS,PS...C
	TLO T1,400000	;CARRY BIT GOES TO SIGN BIT
	TRZE T1,000200	;CHECK NEW CARRY
	TRO PS,PS...C!PS...V ;NEW CARRY AND OVERFLOW (MAYBE)
	ROT T1,1
	TRNE T1,000200	;GET A NEGATIVE RESULT ?
	TRC	PS,PS...N!PS...V ;WIN NEGATIVE AND COMPLEMENT OVERFLOW
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG
>

DEFINE ROR. (FLAG) <
	JSR @RFETCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	TRZE PS,PS...C
	JRST .+4
	TRZE T1,1		;DO WE GET A NEW CARRY ?
	TRO PS,PS...C!PS...V
	JRST .+5
	TRO T1,200000	;CARRY BIT GOES TO SIGN BIT
	TRZE T1,1		;CHECK NEW CARRY
	TROA	PS,PS...C!PS...N ;NEW CARRY AND NEGATIVE
	TRO PS,PS...V!PS...N ;OVERFLOW AND NEGATIVE
	LSH T1,-1
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG
>

DEFINE RORB. (FLAG) <
	JSR @BRFTCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	TRZE PS,PS...C
	JRST .+4
	TRZE T1,1		;DO WE GET A NEW CARRY ?
	TRO PS,PS...C!PS...V
	JRST .+5
	TRO T1,000400	;CARRY BIT GOES TO SIGN BIT
	TRZE T1,1		;CHECK NEW CARRY
	TROA	PS,PS...C!PS...N ;NEW CARRY AND NEGATIVE
	TRO PS,PS...V!PS...N ;OVERFLOW AND NEGATIVE
	LSH T1,-1
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG
>

DEFINE RTI. (FLAG) <
	LOAD SP,T1		;PUT RESTORED PC IN TEMP REG
	MOVEI SP,2(SP)
	ANDI SP,177776
	LOAD SP,T2		;GET NEW PS
	ANDI T2,377		;WE DON'T HAVE A LH
	HRRM PS,PS.REG+1	;SAVE OLD PS
	MOVE PS,T2		;LOAD NEW PS
	MOVEI SP,2(SP)
	ANDI SP,177776
	MOVE PC,T1		;LOAD NEW PC
	TRNE PC,1		;CHECK PC OK
	JRST NXM...		;TAKE A BUS TRAP
	CALL PS.CHK		;SEE IF THERE ARE INTERRUPTS TO TAKE
>

DEFINE RTS. (FLAG) <
	ANDI IR,7
	MOVE PC,(IR)
	LOAD SP,T1		;GET OLD REG FROM STACK
	MOVEM T1,(IR)		;LOAD REG FROM STACK
	MOVEI SP,2(SP)		;FINISH POP
	ANDI SP,177777	;IN CASE OVERFLOWED
	TRNE PC,1		;BE SURE NEW PC OK
	JRST NXM...		;TAKE A BUS TRAP
>

DEFINE RTT. (FLAG) <
	LOAD SP,T1
	MOVEI SP,2(SP)
	ANDI SP,177776
	LOAD SP,T2		;GET NEW PS
	ANDI T2,377		;WE DON'T HAVE A LH
	HRRM PS,PS.REG+1	;SAVE OLD PS
	MOVE PS,T2		;LOAD NEW PS
	MOVEI SP,2(SP)
	ANDI SP,177776
	HRRZ PC,T1		;LOAD NEW PC
	TRNE PC,1		;CHECK NEW PC OK
	JRST NXM...		;TAKE A BUS TRAP
	CALL PS.CHK		;SEE IF THERE ARE INTERRUPTS TO TAKE
	JRST SIM11A		;INHIBIT TRACE TRAP
ZZRET==	-1
>

DEFINE SBC. (FLAG) <
	JSR @RFETCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	TRZE PS,PS...C
	JRST .+8
	TRNE T1,100000
	TRO PS,PS...N
	CAIN T1,100000
	TRO PS,PS...V
	JUMPN T1,SIM11
	TRO PS,PS...Z
	JRST SIM11
	SOSN	T1
	TRO PS,PS...Z
	TRNE T1,100000
	TRO PS,PS...N
	CAIN T1,100000-1
	TRO PS,PS...V
	TRZE T1,600000
	TRO PS,PS...C
	RSTORE FLAG
>

DEFINE SBCB. (FLAG) <
	JSR @BRFTCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	TRZE PS,PS...C
	JRST .+8
	TRNE T1,000200
	TRO PS,PS...N
	CAIN T1,000200
	TRO PS,PS...V
	JUMPN T1,SIM11
	TRO PS,PS...Z
	JRST SIM11
	SOSN	T1
	TRO PS,PS...Z
	TRNE T1,000200
	TRO PS,PS...N
	CAIN T1,000200-1
	TRO PS,PS...V
	TRZE T1,777400
	TRO PS,PS...C
	RSTORE FLAG
>

;DEFINE SCC. (FLAG) <>	;HANDLED BY .CCSET
;DEFINE SEC. (FLAG) <>	;HANDLED BY .CCSET
;DEFINE SEN. (FLAG) <>	;HANDLED BY .CCSET
;DEFINE SEV. (FLAG) <>	;HANDLED BY .CCSET
;DEFINE SEZ. (FLAG) <>	;HANDLED BY .CCSET

DEFINE SOB. (FLAG) <
	ANDI T2,7		;GET REGISTER DESIGNATION
	SOSN	T1,(T2)
	JRST SIM11		;DON'T TAKE BRANCH
	ANDI T1,177777	;IN CASE OF OVERFLOW
	MOVEM T1,(T2)
	ANDI IR,77
	LSH IR,1
	SUBI	PC,(IR)
	ANDI PC,177777	;ONLY NEEDED IF PC .LT. 200 !
>

DEFINE SPL. (FLAG) <
	ANDI IR,7		;LEAVE ONLY NEW PRIORITY
	DPB IR,P.PLVL
	CALL PS.CHK
>

DEFINE SUB. (FLAG) <
	MOVE T2,T1		;SAVE SRC
	JSR @RFETCH(IR)		;GET DST
	MOVE IR,T1		;SAVE COPY OF DST FOR PS...V CALC
	SUB T1,T2		;MAKES RESULT
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	TRNE T1,100000	;CHECK FOR NEGATIVE
	TRO PS,PS...N
	TRZE T1,600000	;CHECK FOR OVERFLOW
	TRO PS,PS...C
	SKIPN T1
	TRO PS,PS...Z
	XOR IR,T2		;DST XOR SRC
	EQV T2,T1		;SRC EQV RESULT
	AND T2,IR
	TRNE T2,100000
	TRO PS,PS...V
	RSTORE FLAG
>

DEFINE SWAB. (FLAG) <
	JSR @RFETCH(IR)		;GET ARGUMENT
	DPB T1,[POINT 8,T1,19]
	LSH T1,-10
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	TRNE T1,000200
	TRO PS,PS...N
	TRNN T1,377
	TRO PS,PS...Z
	RSTORE FLAG
>

DEFINE SXT. (FLAG) <
	HRRM PS,PS.REG+1	;IN CASE OF BUS TRAP
	TRZ PS,PS...V	;ALWAYS CLEARED
	TRNN PS,PS...N
	TROA	PS,PS...Z	;WIN A Z BIT
	TRZA	PS,PS...Z	;LOST THE Z BIT
	TDZA	T1,T1
	MOVEI T1,177777
	JRST @STUFF(IR)
ZZRET==	-1
>

DEFINE TST. (FLAG) <
	JSR @FETCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	TRNE T1,100000
	TRO PS,PS...N
	SKIPN T1
	TRO PS,PS...Z
>

DEFINE TSTB. (FLAG) <
	JSR @BFETCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V!PS...C
	TRNE T1,000200
	TRO PS,PS...N
	SKIPN T1
	TRO PS,PS...Z
>

DEFINE WAIT. (FLAG) <
	TADJUS
WAIT0:
	TXNN	FLG,F.EXEC	;RUNNING IN EXEC MODE ?
	JRST WAIT1		;NO
	SKIPN BR7PND		;CHECK FOR INTERUPTS HAPPENED
	SKIPE BR5PND		;CHECK OTHER FLAVOUR
	JRST SIM11		;GO TAKE INTERRUPT
	SOSLE	T1,INTDLY
	JRST WAIT0		;NOT YET
	TADJUS
	HRRZ T1,CTISPD
	MOVEM T1,INTDLY
	MOVEM T1,INTDLY+1
	CALL TIMCHK
	JRST WAIT0
	JRST SIM11

WAIT1:	HRRE	T1,INTDLY+1
	ADDM	T1,INSRUN	;ACCUMULATE NUMBER OF INSTRUCTIONS EXECUTED
	ADDM	T1,WAITIM	;ACCUMULATE WAIT TIME
	MOVE T1,CTISPD
	HRRM T1,INTDLY
	HRRM T1,INTDLY+1
	CALL TIMCHK
	JRST WAIT0
>

DEFINE XOR. (FLAG) <
	MOVE T2,-740(T2)	;GET REGISTER
	JSR @RFETCH(IR)		;GET OPERAND
	TRZ PS,PS...N!PS...Z!PS...V
	XOR T1,T2
	TRNE T1,100000
	TRO PS,PS...N
	SKIPN T1
	TRO PS,PS...Z
	RSTORE FLAG
>

				; STACK MODIFICATION INSTRUCTIONS
DEFINE JSR. (FLAG) <
	JSR @JMPCLC(IR)		;GET ADR OF JSR
	TRZ T2,777770	;REG IN JSR REG,FOO
	HRLM T1,T2		;SAVE SUBROUTINE ADR
	MOVE T1,(T2)		;GET CURRENT REG CONTENTS
	MOVEI SP,-2(SP)		;START PUSHING OLD REG ON STACK
	ANDI SP,177777	;BE SURE DIDN'T PUSH TO FAR
	HRRZM	PC,(T2)		;PUT PC IN REG
	HLRZ PC,T2		;GET SUBROUTINE ADR BACK
	HRRM PS,PS.REG+1	;SAVE PS IN CASE OF STACK VIOLATION
	STORE SP,T1		;FINISH PUSHING REG ON STACK
	TRNE PC,1		;BE SURE NEW PC KOSHER
	JRST NXM...		;DIE
>

DEFINE MARK. (FLAG) <
	ANDI IR,77		;LEAVES N
	LSH IR,1		;MAKES N*2
	HRRZ SP,IR
	ADDI	SP,(PC)		;SP FROM PC + 2*NN
	HRRZ PC,5		;PC FROM R5
	LOAD SP,5
	MOVEI SP,2(SP)
	ANDI SP,177777
	TRNE PC,1		;IS NEW PC OK
	JRST NXM...		;TAKE A BUS TRAP
>

DEFINE MFPS. (FLAG) <
	HRRM PS,PS.REG+1	;IN CASE OF BUS TRAP
	HRRZ T1,PS		;GET DATA TO STORE
	TRZ PS,PS...N!PS...Z!PS...V
	TRNE T1,200
	TRO PS,PS...N
	TRNN T1,377
	TRO PS,PS...Z
	JRST @BSTUFF(IR)	;NOW STORE THE DATA
ZZRET==	-1
>

DEFINE MTPS. (FLAG) <
	JSR @BFETCH(IR)		;GET WHAT TO SET PS TO
	HRRM PS,PS.REG+1	;SAVE ORIGINAL PS
	HRRZ PS,T1		;SET NEW PS
	CALL PS.CHK		;TAKE AN INTERRUPT MAYBE
>
				; THE INTERUPT INSTRUCTIONS

DEFINE BPT. (FLAG) <
	INTSAV	14
>

DEFINE IOT. (FLAG) <
	INTSAV	20
>

DEFINE EMT. (FLAG) <
	INTSAV	30
>

DEFINE TRAP. (FLAG) <
	INTSAV	34
>
				; THE BRANCH INSTRUCTIONS

DEFINE BCC. (FLAG) <
	TRNE PS,PS...C
	JRST SIM11		;NO BRANCH
>

DEFINE BCS. (FLAG) <
	TRNN PS,PS...C
	JRST SIM11		;NO BRANCH
>

DEFINE BEQ. (FLAG) <
	TRNN PS,PS...Z
	JRST SIM11
>

DEFINE BGE. (FLAG) <
	TRNN PS,PS...N
	JRST [TRNE PS,PS...V
		JRST SIM11	;NO BRANCH
		JRST .+3 ]
	TRNN PS,PS...V
	JRST SIM11		;NO BRANCH
>

DEFINE BGT. (FLAG) <
	TRNE PS,PS...Z
	JRST SIM11		;NO BRANCH
	TRNN PS,PS...N
	JRST [TRNE PS,PS...V
		JRST SIM11	;NO BRANCH
		JRST .+3 ]
	TRNN PS,PS...V
	JRST SIM11		;NO BRANCH
>

DEFINE BHI. (FLAG) <
	TRNE PS,PS...Z!PS...C
	JRST SIM11		;NO BRANCH
>

DEFINE BHIS. (FLAG) <
	TRNE PS,PS...C
	JRST SIM11		;NO BRANCH
>

DEFINE BLE. (FLAG) <
	TRNE PS,PS...Z
	JRST .+5		;BRANCH
	TRNE PS,PS...N
	JRST [TRNE PS,PS...V
		JRST SIM11	;NO BRANCH
		JRST .+3 ]
	TRNN PS,PS...V
	JRST SIM11		;NO BRANCH
>

DEFINE BLO. (FLAG) <
	TRNN PS,PS...C
	JRST SIM11		;NO BRANCH
>

DEFINE BLOS. (FLAG) <
	TRNN PS,PS...Z!PS...C
	JRST SIM11		;NO BRANCH
>

DEFINE BLT. (FLAG) <
	TRNE PS,PS...N
	JRST [TRNE PS,PS...V
		JRST SIM11	;NO BRANCH
		JRST .+3 ]
	TRNN PS,PS...V
	JRST SIM11		;NO BRANCH
>

DEFINE BMI. (FLAG) <
	TRNN PS,PS...N
	JRST SIM11		;NO BRANCH
>

DEFINE BNE. (FLAG) <
	TRNE PS,PS...Z
	JRST SIM11
>

DEFINE BPL. (FLAG) <
	TRNE PS,PS...N
	JRST SIM11		;NO BRANCH
>

DEFINE BR. (FLAG) <
>

DEFINE BVC. (FLAG) <
	TRNE PS,PS...V
	JRST SIM11		;NO BRANCH
>

DEFINE BVS. (FLAG) <
	TRNN PS,PS...V
	JRST SIM11		;NO BRANCH
>

				;MACROS TO BUILD DISPATCH TABLES
DEFINE TAGDSP (TAG) <Q=0
REPEAT	10,<QQ=0
REPEAT	10,< TAGDS2	TAG,\Q,\QQ
QQ=QQ+1>
Q=Q+1>>
DEFINE TAGDS2 (TAG,Q,QQ) <EXP	TAG'Q'QQ>

				;MACRO TO DEFINE GET, RGET, AND PUT
;	GET AND RGET RETURN DATA IN T1
;	RGET ALSO SETS UP MA
;	PUT STORES DATA IN T1

DEFINE MODES (Q) <
XLIST
;MODE 0 - REGISTER MODE

SGET0'Q:Z
	HRRZ T1,(T2)		;GET REGISTER
	HRRZ MA+1,IR		;COPY DEST MODE
	ANDI MA+1,7		;LEAVE ONLY DEST REGISTER
	CAME	MA+1,T2		;SAME AS SRC REGISTER ?
	JRST @SGET0'Q		;NO SO DONE
	CAIL IR,20		;MAYBE DEST IS REG OR @REG ?
	CAILE	IR,57		;OR IS INDEXED OR @INDEXED ?
	JRST @SGET0'Q		;ONE OF THOSE SO DONE
	CAIGE	IR,30
	ADDI	T1,4		;WAS AUTO INCREMENT MODE
	SUBI	T1,2
	ANDI T1,177777	;STRIP EXTRA BITS
	JRST @SGET0'Q

GET0'Q:	Z
	HRRZ T1,Q
	JRST @GET0'Q

RGET0'Q:Z
	HRROI MA,Q
	HRRZ T1,Q
	JRST @RGET0'Q

SBGT0'Q:Z
	HRRZ T1,(T2)		;GET REGISTER
	ANDI T1,377		;STRIP EXTRA BITS
	HRRZ MA+1,IR		;COPY DEST MODE
	ANDI MA+1,7		;LEAVE ONLY DEST REGISTER
	CAME	MA+1,T2		;SAME AS SRC REGISTER ?
	JRST @SBGT0'Q		;NO SO DONE
	CAIL IR,20		;MAYBE DEST IS REG OR @REG ?
	CAILE	IR,57		;OR IS INDEXED OR @INDEXED ?
	JRST @SBGT0'Q		;ONE OF THOSE SO DONE
	CAIGE	IR,30
IFL <Q-6>,<ADDI	T1,2
	SOS	T1>
IFGE <Q-6>,<	ADDI	T1,4	;WAS AUTO INCREMENT MODE
	SUBI	T1,2>
	ANDI T1,377		;STRIP EXTRA BITS
	JRST @SBGT0'Q

BGET0'Q:Z
	HRRZ T1,Q
	ANDI T1,377
	JRST @BGET0'Q

BRGT0'Q:Z
	HRROI MA,Q
	HRRZ T1,Q
	ANDI T1,000377
	JRST @BRGT0'Q

JMP0'Q==JMPREG			;REGISTER MODE ILLEGAL FOR JMP & JSR

PUT0'Q:	HRRZ Q,T1		;LOAD REGISTER
IFE <Q-PC> <TRNE PC,1		;BE SURE PC NOT CORRUPTED
	JRST NXM...>
	JRST SIM11

BPUT0'Q:TRZ Q,377		;STRIP OLD BITS
	TRO Q,(T1)		;SET NEW BITS
IFE <Q-PC> <TRNE PC,1		;BE SURE PC NOT CORRUPTED
	JRST NXM...>
	JRST SIM11


;MODE 1 - REGISTER DEFERRED

RGET1'Q:IFE <Q-6>,<Z
	HRRZ MA,Q		;COPY CONTENTS OF REGISTER
	CAIGE	MA,400
	JSR STACKV		;WE'RE GONNA VIOLATE STACK
	LOAD MA,T1
	JRST @RGET1'Q>

SGET1'Q:GET1'Q:	Z
	LOAD Q,T1
	JRST @GET1'Q

BRGT1'Q:IFE <Q-6>,<Z
	HRRZ MA,Q		;COPY STACK POINTER
	CAIGE	MA,400
	JSR STACKV		;WE'RE GONNA VIOLATE STACK
	BLOAD MA,T1
	JRST @BRGT1'Q>

SBGT1'Q:BGET1'Q:Z
	BLOAD Q,T1
	JRST @BGET1'Q

JMP1'Q:	Z
	HRRZ T1,Q
	JRST @JMP1'Q

PUT1'Q:	STORE Q,T1
	JRST SIM11

BPUT1'Q:BSTORE Q,T1
	JRST SIM11


;MODE 2 - AUTO-INCREMENT

RGET2'Q:IFE <Q-6>,<Z
	HRRZ MA,Q		;COPY STACK POINTER
	ADDI	Q,2
IFL <Q-6>,<ANDI Q,177777>
	CAIGE	MA,400
	JSR STACKV		;WE'RE GONNA VIOLATE STACK
	LOAD MA,T1
	JRST @RGET2'Q>

SGET2'Q:
GET2'Q:	Z
	HRRZ MA,Q		;COPY REGISTER
	ADDI	Q,2
IFL <Q-6>,<ANDI Q,177777>
	LOAD MA,T1
	JRST @GET2'Q

BRGT2'Q:IFE <Q-6>,<Z
	HRRZ MA,Q		;COPY STACK POINTER
IFGE <Q-6>,<ADDI Q,2>
IFL <Q-6>,< AOS Q>
IFL <Q-6>,<ANDI Q,177777>
	CAIGE	MA,400
	JSR STACKV		;WE'RE GONNA VIOLATE STACK
	BLOAD MA,T1
	JRST @BRGT2'Q>

SBGT2'Q:BGET2'Q:
	Z
	HRRZ MA,Q		;COPY REGISTER
IFGE <Q-6>,<ADDI Q,2>
IFL <Q-6>,< AOS Q>
IFL <Q-6>,<ANDI Q,177777>
	BLOAD MA,T1
	JRST @BGET2'Q

JMP2'Q:	Z
	HRRZ T1,Q
	ADDI	Q,2
IFL <Q-6>,<ANDI Q,177777>
	JRST @JMP2'Q

PUT2'Q:	HRRZ MA,Q		;COPY REGISTER
	ADDI	Q,2
IFL <Q-6>,<ANDI Q,177777>
	STORE MA,T1
	JRST SIM11

BPUT2'Q:HRRZ MA,Q		;COPY REGISTER
IFGE <Q-6>,<ADDI Q,2>
IFL <Q-6>,<AOS Q
	ANDI Q,177777>
	BSTORE MA,T1
	JRST SIM11


;MODE 3 - AUTO-INCREMENT DEFERRED

SGET3'Q:GET3'Q:RGET3'Q:Z
	HRRZ MA,Q		;COPY REGISTER
	ADDI	Q,2
IFL <Q-6>,<ANDI Q,177777>
	LOAD MA,MA
	LOAD MA,T1
	JRST @GET3'Q

SBGT3'Q:BGET3'Q:BRGT3'Q:Z
	HRRZ MA,Q		;COPY REGISTER
			ADDI	Q,2		;;2 (NOT 1) BECAUSE DEFERRED
IFL <Q-6>,<ANDI Q,177777>
	LOAD MA,MA
	BLOAD MA,T1
	JRST @BGET3'Q

JMP3'Q:	Z
	HRRZ MA,Q		;COPY REGISTER
	ADDI	Q,2
IFL <Q-6>,<ANDI Q,177777>
	LOAD MA,T1
	JRST @JMP3'Q

PUT3'Q:	HRRZ MA,Q		;COPY REGISTER
	ADDI	Q,2
IFL <Q-6>,<ANDI Q,177777>
	LOAD MA,MA
	STORE MA,T1
	JRST SIM11

BPUT3'Q:HRRZ MA,Q		;COPY REGISTER
	ADDI	Q,2		;2 (NOT 1) BECAUSE DEFERRED
IFL <Q-6>,<ANDI Q,177777>
	LOAD MA,MA
	BSTORE MA,T1
	JRST SIM11


;MODE 4 - AUTO-DECREMENT

RGET4'Q:
IFE <Q-6>,<Z
	SUBI	Q,2
IFL <Q-7>,<ANDI Q,177777>
	HRRZ MA,Q		;COPY SP IN CASE OF STACK VIOLATION
	CAIGE	MA,400
	JSR STACKV		;WE'RE GONNA VIOLATE STACK
	LOAD MA,T1
	JRST @RGET4'Q>

SGET4'Q:GET4'Q:	Z
	SUBI	Q,2
IFL <Q-7>,<ANDI Q,177777>
	LOAD Q,T1
	JRST @GET4'Q
BRGT4'Q:
IFE <Q-6>,<Z
IFGE <Q-6>,<SUBI Q,2>
IFL <Q-6>,<SOSGE Q>
IFL <Q-7>,<ANDI Q,177777>
	HRRZ MA,Q
	CAIGE	MA,400
	JSR STACKV		;WE'RE GONNA VIOLATE STACK
	BLOAD MA,T1
	JRST @BRGT4'Q>

SBGT4'Q:BGET4'Q:Z
IFGE <Q-6>,<SUBI Q,2>
IFL <Q-6>,<SOSGE Q>
IFL <Q-7>,<ANDI Q,177777>
	BLOAD Q,T1
	JRST @BGET4'Q

JMP4'Q:	Z
IFL <Q-7>,<ANDI Q,177777>
	HRRZ T1,Q
	JRST @JMP4'Q

PUT4'Q:	SUBI	Q,2
IFL <Q-7>,<ANDI Q,177777>
	STORE Q,T1
	JRST SIM11

BPUT4'Q:
IFGE <Q-6>,<SUBI Q,2>
IFL <Q-6>,<SOSGE Q>
IFL <Q-7>,<ANDI Q,177777>
	BSTORE Q,T1
	JRST SIM11


;MODE 5 - AUTO-DECREMENT DEFERRED

SGET5'Q:GET5'Q:RGET5'Q:Z
	SUBI	Q,2
IFL <Q-7>,<ANDI Q,177777>
	LOAD Q,MA
	LOAD MA,T1
	JRST @GET5'Q

SBGT5'Q:BGET5'Q:BRGT5'Q:Z
	SUBI	Q,2		;2 (NOT 1) BECAUSE DEFERRED
IFL <Q-7>,<ANDI Q,177777>
	LOAD Q,MA
	BLOAD MA,T1
	JRST @BGET5'Q

JMP5'Q:	Z
	SUBI	Q,2
IFL <Q-7>,<ANDI Q,177777>
	LOAD Q,T1
	JRST @JMP5'Q

PUT5'Q:	SUBI	Q,2
IFL <Q-7>,<ANDI Q,177777>
	LOAD Q,MA
	STORE MA,T1
	JRST SIM11

BPUT5'Q:SUBI	Q,2		;2 (NOT 1) BECAUSE DEFERRED
IFL <Q-7>,<ANDI Q,177777>
	LOAD Q,MA
	BSTORE MA,T1
	JRST SIM11


;MODE 6 - INDEXED
RGET6'Q:
IFE <Q-6>,<Z
	LOAD PC,MA
	ADDI	PC,2
	ADD MA,Q
	ANDI MA,177777
	CAIGE	MA,400
	JSR STACKV		;WE'RE GONNA VIOLATE STACK
	LOAD MA,T1
	JRST @RGET6'Q>

SGET6'Q:GET6'Q:	Z
	LOAD PC,MA
	ADDI	PC,2
	ADD MA,Q
	ANDI MA,177777
	LOAD MA,T1
	JRST @GET6'Q
BRGT6'Q:
IFE <Q-6>,<Z
	LOAD PC,MA
	ADDI	PC,2
	ADD MA,Q
	ANDI MA,177777
	CAIGE	MA,400
	JSR STACKV		;WE'RE GONNA VIOLATE STACK
	BLOAD MA,T1
	JRST @BRGT6'Q>

SBGT6'Q:BGET6'Q:Z
	LOAD PC,MA
	ADDI	PC,2
	ADD MA,Q
	ANDI MA,177777
	BLOAD MA,T1
	JRST @BGET6'Q

JMP6'Q:	Z
	LOAD PC,T1
	ADDI	PC,2
	ADD T1,Q
	ANDI T1,177777
	JRST @JMP6'Q

PUT6'Q:	LOAD PC,MA
	ADDI	PC,2
	ADD MA,Q
	ANDI MA,177777
IFE <Q-6>,<CAIGE	MA,400
	JSR STCKVP>
	STORE MA,T1
	JRST SIM11

BPUT6'Q:LOAD PC,MA
	ADDI	PC,2
	ADD MA,Q
	ANDI MA,177777
IFE <Q-6>,<CAIGE	MA,400
	JSR STCKVP>
	BSTORE MA,T1
	JRST SIM11


;MODE 7 - INDEXED DEFERRED

SGET7'Q:GET7'Q:RGET7'Q:Z
	LOAD PC,MA
	ADDI	PC,2
	ADD MA,Q
	ANDI MA,177777
	LOAD MA,MA
	LOAD MA,T1
	JRST @GET7'Q

SBGT7'Q:BGET7'Q:BRGT7'Q:Z
	LOAD PC,MA
	ADDI	PC,2
	ADD MA,Q
	ANDI MA,177777
	LOAD MA,MA
	BLOAD MA,T1
	JRST @BGET7'Q

JMP7'Q:	Z
	LOAD PC,MA
	ADDI	PC,2
	ADD MA,Q
	ANDI MA,177777
	LOAD MA,T1
	JRST @JMP7'Q

PUT7'Q:	LOAD PC,MA
	ADDI	PC,2
	ADD MA,Q
	ANDI MA,177777
	LOAD MA,MA
	STORE MA,T1
	JRST SIM11

BPUT7'Q:LOAD PC,MA
	ADDI	PC,2
	ADD MA,Q
	ANDI MA,177777
	LOAD MA,MA
	BSTORE MA,T1
	JRST SIM11
LIST
>
;TRANSLATION OF IO ADDRESS SPACE

DEFINE DDBGEN (DEV,WRDS) <
IF2,<IFGE <DEV'ADR-DDBADR>
<PRINTX ERROR BUILDING IOMAP>
IFNDEF	DEV'TIM,<DEV'TIM==R>	;DEFAULT TIMER ROUTINE
IFNDEF	DEV'RST,<DEV'RST==R>	;DEFAULT RESET ROUTINE
IFNDEF	DEV'LVL,<DEV'LVL==0	;DEFAULT INTERRUPT LEVEL
		 DEV'INT==0>>	;DEFAULT INTERRUPT ROUTINE
DEV'DDB: PHASE	0
	0,,DEV'ADR		;FIRST ADR IN DEVICE
	0,,DEV'ADR+WRDS+WRDS-1	;HIGHEST ADR IN DEVICE
DDBADR==DEV'ADR
DV.LNK:! DDBLNK,,DDBLNK		;LINK TO NEXT DEVICE BLOCK
DDBLNK==DEV'DDB
DV.LOD:! EXP	DEV'LOD		;DISPATCH FOR LOAD
DV.BLD:! EXP	DEV'BLD		;DISPATCH FOR BYTE LOAD
DV.WRT:! EXP	DEV'WRT		;DISPATCH FOR WRITING WORDS
DV.BWR:! EXP	DEV'BWR		;DISPATCH FOR WRITING BYTES
DV.TIM:! EXP	DEV'TIM		;DISPATCH WHEN TIMER GOES OFF
				; RETURNS WITH SKIP IF INTERRUPTED
	Z			;TIME TO TAKE TIMER DISPATCH
DV.RST:! EXP	DEV'RST		;DISPATCH FOR RESET
DV.LVL:! EXP	DEV'LVL		;CONTAINS DEVICE LEVEL
DV.INT:! EXP	DEV'INT		;DISPATCH IF WANT TO CHECK FOR INTERRUPTS
DV.SIZ:!
DEPHASE
>

;FOLLOWING DDBGEN ARE SIMULATED DEVICES TO USE STANDARD READ, WRITE ROUTINES
;	0,,0	;LH IS WRITEABLE BY PROGRAM BITS,,RH IS REGISTER
;	0,,0	;LH IS WRITEABLE BY OPERATORE BITS,,RH IS OLD REGISTER

UBXADR==163000

MMVEC==250			; VECTOR FOR AN INTERUPT FROM MEMORY MANAGEMENT

KG.ADR==170700

SIPDR==172200			; SUPERVISOR INST PDR
SDPDR==172220			; SUPERVISOR DATA PDR
SIPAR==172240			; SUPERVISOR INST PAR
SDPAR==172260			; SUPERVISPR DATA PAR
KIPDR==172300			; KERNAL INST PDR
KDPDR==172320			; KERNAL DATA PDR
KIPAR==172340			; KERNAL INST PAR
KDPAR==172360			; KERNAL DATA PAR

MMR3==172516			; MEMORY MANAGEMENT REGISTER 3

CLKADR==177546			; KW11-L
CLKLVL==6

CTYADR==177560			; DL11 NUMBER 0
CTYLVL==4

SW.ADR==177570			; SWITCH REGISTER AND LIGHTS

MMR0==177572			; MEMORY MANAGEMENT REGISTER 0
MMR1==177574			; MEMORY MANAGEMENT REGISTER 1
MMR2==177576			; MEMORY MANAGEMENT REGISTER 2
UIPDR==177600			; USER INST PDR
UDPRD==177620			; USER DATA PDR
UIPAR==177640			; USER INST PAR
UDPAR==177660			; USER DATA PAR

CMHADH==177752			; CACHE HIT/MISS COUNTS
SIZADR==177760			; SYSTEM SIZE, TWO WORDS
SIDADR==177764			; SYSTEM I/D WORD
CPUADR==177766			; CPU ERROR ADDRESS
MPBADR==177770			; MICROPROGRAM BREAK
PIRADR==177772			; PROGRAM INTERUPT REQUESTS
SL.ADR==177774			; STACK LIMIT
PS.ADR==177776			; PROCESOR STATUS WORD

; EPTBLK POINTS TO THE START OF:
EPT...==0			;PAGE FOR EXEC PROCESS TABLE
UPT...==1000			;PAGE FOR USER PROCESS TABLE
STB...==2000			;PAGE FOR SECTION TABLE FOR SECTION 0
CST...==3000			;PAGE FOR CORE STATUS TABLE
VECTAB==4000			;3000 WORDS FOR VECTORED INTERRUPTS
DSKPAG==7000			;PAGE FOR DISK IO
EBLKSZ==10000			;SIZE OF BLOCK FOR EXEC USAGE
APRLVL==2



DEFINE MOVX (AC,MSK)<
.XCREF
..MX1==MSK
.IFN ..MX1,ABSOLUTE,<MOVE AC,[MSK]>
.IF ..MX1,ABSOLUTE,<..MX2==0
IFE <..MX1>B53,<..MX2==1
MOVEI AC,..MX1>
IFE ..MX2,<IFE <..MX1>B17,<..MX2==1
MOVSI AC,(..MX1)>>
IFE ..MX2,<IFE <<..MX1>B53-^O777777>,<..MX2==1
HRROI AC,<..MX1>>>
IFE ..MX2,<IFE <<..MX1>B17-^O777777B17>,<..MX2==1
HRLOI AC,(..MX1-^O777777)>>
IFE ..MX2,<MOVE AC,[..MX1]>>
.CREF
>

DEFINE ..DOTX (M,T) <
IRP M,<
IRP T,<
DEFINE TX'M'T (AC,MSK)<.XCREF
..TX(M'T,AC,<MSK>)
.CREF>
>>>

..DOTX (<N,O,Z,C>,<,E,N,A>)	;DO ALL DEFINITIONS
PURGE ..DOTX

DEFINE ..TX(MT,AC,MSK)<
..TX1==MSK
.IFN ..TX1,ABSOLUTE,<TD'MT AC,[MSK]>
.IF ..TX1,ABSOLUTE,<..TX2==0
IFE <..TX1&^O777777B17>,<..TX2==1
TR'MT AC,..TX1>
IFE ..TX2,<IFE <..TX1&^O777777>,<..TX2==1		
TL'MT AC,(..TX1)>>
IFE ..TX2,<IFE <<..TX1>B53-^O777777>,<..TX3 (MT,AC)>>	
IFE ..TX2,<IFE <..TX1+1>,<..TX4 (MT,AC)>>
IFE ..TX2,<TD'MT AC,[..TX1]>>
>

DEFINE ..TX3 (MT,AC)<
IFIDN <MT><Z>,<	..TX2==1
ANDI AC,^-..TX1>
IFIDN <MT><O>,<	..TX2==1
ORCMI AC,^-..TX1>	
IFIDN <MT><C>,<	..TX2==1
EQVI AC,^-..TX1>
>


DEFINE ..TX4 (MT,AC)<IFIDN <MT><NN>,<..TX2==1
CAIN AC,0>		
IFIDN <MT><NE>,<..TX2==1
CAIE AC,0>>

END
