;
;
;
; COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1984,1987. ALL RIGHTS RESERVED.
;
;
; THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
; ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH LICENSE AND WITH THE
; INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER
; COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
; OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE  SOFTWARE  IS  HEREBY
; TRANSFERRED.
;
;
; THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT  NOTICE
; AND  SHOULD  NOT  BE  CONSTRUED  AS A COMMITMENT BY DIGITAL EQUIPMENT
; CORPORATION.
;
; DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY  OF  ITS
; SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
;

TITLE	DDT11 %7F(121) PDP-10 RESIDENT PDP-11 [FIL]DDT

VWHO==	0
VDDT11==7
VMINOR==6
VEDIT==	121

comment \ 

This program has been brought to you through the hard work of the
following people:

Tony Crugnola, Dan Deufel, Kathy Haramundanis, [RDH], Tim Litt,
DRLyons, Mary Marotta, Todd (WEM) Matson, Dave McClure, Pete
Mierswa, Reed Powell, Bob South, Ric Werme, Jack Yelig

EDIT	120	Dec-20-83	VLG
*	Put in privilage check for MCB's	*


\



	SEARCH	DDTSYM,JOBDAT,MACTEN,UUOSYM,MONSYM

	SALL			;GET NICE LISTINGS FOR A CHANGE
	.HWFRMT			;AND SKIP THE FANCY BITS
	.DIRECT FLBLST

; ENTRY POINTS FOR THIS ROUTINE

ENT11 (ENTRY)			; OUR ENTRY POINTS
ENTGP (EXTERN)			; GLOBALS IN DDTGP
ENTSIM (EXTERN)			; GLOBALS IN DDTSIM
ENTFIL (EXTERN)			; GLOBALS IN DDTFIL

EXTERN	DEFOUT

;DDT11 VERSION NUMBER

%%DDT11==:<BYTE	(3)VWHO(9)VDDT11(6)VMINOR(18)VEDIT>
	LOC .JBVER
	%%DDT11
	RELOC 0


ASCII \

COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1984,1987. ALL RIGHTS RESERVED.
\;END COPYRIGHT MACRO



\



DDT11:	NOP
	JSR INIALL		;GET PROCESSOR FLAGS, AND RESET WORLD
	CALL IDTYPE		;IDENTIFY OURSELF
	CALL CRLTYP		;END WITH A FLOURISH

	MOVE T1,[0,,0]		;DEFAULT OUTPUT MODE IS SYMBOLIC
	MOVEM T1,O.MODE
	SETZM CACHEL		;HIGHEST ADDR IN CACHE
	SETZM NODE.N		;HAVEN'T SPECIFIED NODE YET
	SETZM CMDCON		;NO COMAND CONFLICTS YET
	SETZM LINE		;OR LINE ON NODE
	JRST INI.03
INI.00:	TYPE <
Respond with file spec and/or switches (/HELP for help)>
	CLRBFI			;FLUSH TYPEAHEAD
INI.03:	TYPE <
Input:	>
	SETZ T1,		;NO DEFAULT FILE NAME
	MOVE T2,[SIXBIT /LSDBIN/] ;DEFAULT EXTENSION
	MOVE T3,[SW.DSP,,SW.LST]
	MOVE T4,[400000,,RDDUMP] ;DEFAULT LAST SWITCH
	SETZM SWTMSK		; NO SWITCHES, NO CONFLICTS
	CALL OPNFL0
	JRST INI.00		;TELL HIM THATS NOT NICE
	JRST INI.03



INIALL:	Z
	SETZ 0			;ZERO 1ST AC
	MOVEI 17,1		;MAKE BLT POINTER
	BLT 17,17		;CLEAR ALL AC'S
	MOVE P,[IOWD PDLEN,PDL]
	PUSH P,INIALL
	SETZM OHD
	SETZM CMDFIL
	MOVE FLG,FLGSAV		;SETUP FLAGS
	TXZ FLG,F.EXEC!F.TOPN!F.LOCK!F..SIM!F.WENB!F.WRIT!F.APND
	MOVSI T1,(CPU.34)	; GET THE FLAG FOR AN 11/34
	MOVEM T1,FLAG11		; AND SAVE AWAY FOR THE SPOOKS
	MOVEI T1,CPN.34		; AND GET THE CPU CODE NUMBER
	MOVEM T1,TYPE11		; SAVE THE NEW MASK
	MOVE T1,[MA.34]		; GET THE MEMORY MASK
	MOVEM T1,MEMMSK		; AND SAVE THAT, TOO
	SETZM F.DEBU		; NO DEBUG SWITCHES
	SETZM F.MSYS		; NOR IS THE A MCB SYSTEM
	SETZM F.MCB		; NOR A RUNNING MCB
	SETZM DEFOUT		; SET ZERO DEFAULT OUTPUT MODE
	SETZM MRGFLG
	MOVE DOT,[DOT.FG]	; DOT IS VALID, AND 0
	SETZM RSTATE		;CLEAR STB READER STAE
	MOVE T1,INIALL
	TLNN T1,010000		;CHECK USER MODE FLAG
	TXO FLG,F.EXEC		;WE ARE IN EXEC MODE
	CALL MAPCOR		;SETUP EPT AND UNIBUS MAPPING
	SETZM UPTIME		;HAVEN'T STARTED THE CLOCK YET
	SETZ T2,
	TXNE FLG,F.EXEC		;IF NOT IN EXEC MODE
	JRST INIAL1
	MOVE T1,[XWD 112,11]	;GET THE MONITOR TYPE
	CALLI T1,41		;A GETTAB IN HIDING
	SETZ T1,		;ALWAYS A 0 IF IT FAILS
	LSH T1,-^D12		;MOVE THE TYPE OVER
	ANDI T1,7		;MASK ANY UNWANTED BITS
	MOVE T2,[T.OTHER	;FREE INDEX
		T.TOP10		;TOPS-10
		T.ITS		;ITS
		T.TENEX		;TENEX
		T.TOP20		;TOPS-20
		T.OTHER
		T.OTHER
		T.OTHER](T1)	;GET THE TYPE
INIAL1:	TXNE FLG,F.EXEC
	TXO T2,T.EXEC
	MOVEM T2,OSTYPE		;AND SAVE FOR LATER USE
	RESET
	SETZM INSRUN		;HAVEN'T DONE ANY INSTRCUTIONS YET
	SETZM WAITIM		;AND HAVEN'T WAITED YET
	MOVE T2,[1,,2]
	TXNN FLG,F.EXEC		; DONT TRY IF WE ARE IN EXEC MODE
	GETPPN T2,		; SEE WHO WE ARE
	JFCL			; BLOODY JACCT BIT
	MOVEM T2,MYPPN		; SAVE FOR PPN DEFAULTING
	RET ,INIALL



				;HERE ON A REENTER
RSTART:	NOP
	JSR INIALL		;DO RESET, ETC.

;HERE AFTER INITIAL DIALOGUE

LEVL.0:	SKIPE FILDEV
	JRST [TYPE <?
?File specification given was not used by any switch
>
		RELEAS 1,
		SETZM FILDEV
		RET ,LEVL.0]
	MOVE P,[IOWD PDLEN,PDL]
	CALL STCOR1		;HANDLE /CORE:#
	CALL MAPCOR		;UPDATE MEMORY MAP
	SETZM OHD
	SETZM CMDFIL		;NO MORE COMMAND FILE
	CALL CRLTYP
	SETZM CMDTKR

LEVEL0:	TXZ FLG,F.LOPN!F.MASK!F.MOPN!F.CACH!F.WRIT!F.LBKT
	MOVEM FLG,FLGSAV	;SAVE IN CASE OF REENTER
	HLRS ORADIX		;RESET OUTPUT RADIX
	HLRS O.MODE		;RESET CURRENT OUTPUT MODE FROM PERMANENT
	HLRS BYTCNT		;RESET REPETITION COUNT

; HERE TO RESET MOST OF THE DANGEROUS THINGS (LIKE THE STACK POINTER),
;  AND ASK FOR THE NEXT COMMAND THAT WE WILL PARSE AND EXECUTE

LEVEL2:	MOVE P,[IOWD PDLEN,PDL]
	SETZM TYPDAT
	TXZ FLG,F.SYMB!F.TEXT!F.IOCT!F.IDEC!F.IHEX
	MOVE T1,[POINT 7,CMDLIN]
	MOVEM T1,CMDPTR		;SAVE NEW COMMAND PUTTER
	MOVE STATE,[T2,,STATE0]	;DISPATCH TABLE WHEN IDLE
	MOVE T1,[POINT 8,DATA]
	SKIPE PDP8F
	MOVE T1,[POINT 12,DATA]
	MOVEM T1,DAT		;POINTER TO DATA AREA
	SETZM DTFINP
	MOVE T1,[BYTCNT,,ESCSAV] ;SPECIAL CARE OF THINGS SET
	BLT T1,ESCSAV+2		; WITH ESCAPE COMMANDS
	SETZM LFTSAV		;NO PARTIAL X<Y>



; MOST OF THE WORK IS IN READING AN INSTRUCTION, IF ONE WAS TYPED

LEVEL3:	CALL GETEXP		;GET AN EXPRESSION
	JRST COMAND		;CHECK FOR COMMAND FILE
	LDB T1,CMDPTR		;GET LAST CHARACTER
	CAIE T1,40		;WAS IT A SPACE ?
	JRST LEVEL8
	SKIPE PDP8F		;DOING PDP8 INSTRUCTIONS ?
	JRST LEVEL9
	TXNE FLG,F.SYML		;DID WE HAVE A SYMBOL ?
	TLNN SYM,SMF.IN		;WAS IT AN INSTRUCTION ?
	JRST LEVEL8
	MOVEI T1,DAT.IN
	MOVEM T1,TYPDAT		; REMEMBER THAT WE SAW AN INSTRUCTION
	MOVE T1,EXPRESS		;GET EXPRESSION
	IDPB T1,DAT		;SAVE IT
	PUSH P,DAT		;SAVE POINTER TO OPCODE
	ROT T1,-^D8
	IDPB T1,DAT
	CALL NDTFIN		;SET NEXT DTFINP
	PUSH P,SYM		;SAVE SYMBOL POINTER
	TLNE SYM,SMF.EI		;WAS THIS AN EIS INSTRUCTION ?
	JRST [SETZ T1,		;ARG FOR LEVEL5
		CALL LEVEL5
		LDB T1,CMDPTR	;GET BREAK CHARACTER
		CAIE T1,","
		JRST LEVEL7
		MOVE SYM,(P)	;RESTORE SYMBOL POINTER
		JRST .+1 ]
	TLNE SYM,SMF.JS!SMF.SB!SMF.EI ;WAS THIS A JSR OR SOB OR EIS ?
	JRST [	CALL GETREG	;GET REGISTER NAME ARGUMENT
		MOVE T3,-1(P)	;GET POINTER TO OPCODE
		LDB T2,T3	;GET LOW ORDER BITS
		ILDB T3,T3	;GET HIGH ORDER BITS
		DPB T3,[POINT 8,T2,27]
		DPB T1,[POINT 3,T2,29]
		MOVE T3,-1(P)	;GET POINTER TO OPCODE AGAIN
		DPB T2,T3	;RESTORE LOW ORDER BITS
		LSH T2,-^D8
		IDPB T2,T3
		MOVE SYM,(P)	;RESTORE SYM POINTER
		TLNE SYM,SMF.EI	;IF EIS DON'T CHECK ","
		JRST .+1
		LDB T1,CMDPTR
		CAIE T1,","	;PROPER BREAK ?
		JRST LEVEL7
		JRST .+1]
	MOVEI T1,^D6		;ARG FOR LEVEL5
	TLNE SYM,SMF.SS
	JRST [CALL LEVEL5
		LDB T1,CMDPTR	;GET BREAK CHARACTER
		CAIE T1,","
		JRST LEVEL7
		MOVE SYM,(P)	;RELOAD POINTER TO SYMBOL
		JRST .+1]
	SETZ T1,		;ARG FOR LEVEL5
	TLNE SYM,SMF.DD!SMF.SS
	CALL LEVEL5
	MOVE SYM,(P)		;GET FLAGS AGAIN
	TLNE SYM,SMF.BR		;WAS THIS A BRANCH TYPE INSTRUCTION ?
	JRST [CALL GETEXP	;GET BRANCH ADR
		JRST ILLCHR
		MOVE T1,EXPRESS	;GET DESTINATION ADR
		HRROM T1,LSTIAD	;SAVE LAST ADR TYPED IN
		SUB T1,DTFINP
		ASH T1,-1
		SOS T1
		SKIPN F.MCB
		ANDI T1,177777
		CAIL T1,200
		CAIL T1,177600
		TRZA T1,777400
		JRST ILLCHR
		DPB T1,-1(P)
		JRST LEVEL7 ]
	TLNE SYM,SMF.MK		;WAS THIS A MARK ?
	JRST [CALL GETEXP	;GET ARGUMENT
		JRST ILLCHR
		MOVE T1,EXPRESS
		LDB T2,-1(P)	;GET LOW ORDER BITS OF OPCODE
		DPB T1,[POINT 6,T2,35]
		DPB T2,-1(P)	;PUT OPCODE BACK IN DATA
		JRST LEVEL7 ]
	TLNE SYM,SMF.EM		;EMT TYPE INSTRUCTION ?
	JRST [CALL GETEXP	;GET OPERAND
		JRST ILLCHR
		MOVE T1,EXPRESS	;GET OPERAND
		DPB T1,-1(P)	;PUT OPERAND IN INSTRUCTION
		JRST LEVEL7 ]
	TLNE SYM,SMF.RT		;RTS TYPE INSTRUCTION ?
	JRST [CALL GETREG	;GET REGISTER NAME
		LDB T2,-1(P)	;GET LOW ORDER BITS OF OPCODE
		DPB T1,[POINT 3,T2,35]
		DPB T2,-1(P)
		JRST LEVEL7 ]
	TLNE SYM,SMF.PL		;WAS THIS A SPL TYPE ?
	JRST [CALL GETEXP	;GET ARGUMENT
		JRST ILLCHR
		MOVE T1,EXPRESS
		LDB T2,-1(P)	;GET LOWORDER BITS OF OPCODE
		DPB T1,[POINT 3,T2,35]
		DPB T2,-1(P)
		JRST LEVEL7 ]
	TLNE SYM,SMF.SB		;WAS THIS A SOB ?
	JRST [CALL GETEXP	;GET ADDRESS
		JRST ILLCHR
		MOVE T1,EXPRESS
		HRROM T1,LSTIAD	;IN CASE ENDS WITH A TAB
		HRRZ T2,DTFINP
		SUBI T2,-2(T1)
		SKIPN F.MCB
		ANDI T2,177777
		LSH T2,-1
		CAIL T2,100
		JRST ILLCHR	;OUT OF RANGE
		LDB T1,-1(P)	;GET LOW ORDER BITS OF OPCODE
		DPB T2,[POINT 6,T1,35]
		DPB T1,-1(P)	;RESTORE
		JRST LEVEL7 ]
LEVEL7:	POP P,SYM
	POP P,T1
	JRST LEVEL9


LEVEL8:	TXNN FLG,F.GEXP		;DID WE GET ANYTHING ?
	JRST LEVEL9		;NO
	MOVE T1,EXPRESS
	HRLI T1,400000		;ASSUME REGISTER
	TXNE FLG,F.SYML		;WAS THERE A SYMBOL IN EXPRESSION ?
	TLNN SYM,SMF.RG		;WAS THAT A REGISTER NAME ?
	HRROS	T1		;MEMORY ADR
	MOVEM T1,LSTIAD		;SAVE LAST ADR TYPED IN
	IDPB T1,DAT
	LSH T1,-^D8
	IDPB T1,DAT
	SKIPN F.MCB
	JRST LEV8.5
	LSH T1,-^D8
	ANDI T1,3
	IDPB T1,DAT
LEV8.5:	MOVEI T1,DAT.NU		; REMEMBER THAT THIS WAS A NUMBER
	MOVEM T1,TYPDAT		; SO WE CAN USE IT LATER
	CALL NDTFIN		;ADVANCE DTFINP
LEVEL9:	MOVE T4,[POINT 8,DATA]	;POINTER TO DATA
	SKIPE PDP8F
	HRLI T4,(POINT 12)
	LDB T1,CMDPTR		;GET BREAK CHARACTER
	ROT T1,-1
	TLNE T1,400000
	SKIPA T2,STATEB(T1)
	HLRZ T2,STATEB(T1)
	JRST (T2)		;DISPATCH ON BREAK CHARACTER

COMAND:	LDB T1,[POINT 6,SYMBOL,5] ;GET FIRST CHAR OF SYMBOL
	CAIE T1,'  %'
	JRST LEVEL2		;PUNT
	MOVE T1,SYMBOL		;GET SYMBOL
	CAMN T1,[SIXBIT \%GOTO\]
	JRST %GOTO
	CAMN T1,[SIXBIT \%IF\]
	JRST %IF
	CAMN T1,[SIXBIT \%IFB\]
	JRST %IFB
	JRST ILLCHR



;HERE IF DOING "%GOTO"

%GOTO:	CALL SIXIN		;FIND WHERE TO GO
	JRST ILLCHR
%GOTO3:	MOVEM T1,SYMBOL		;REMEMBER WHERE TO GO
	CALL SYMFND		;SEE IF WE KNOW IT
	JRST [CALL FNDTAG
		JRST ILLCHR
		JRST .+1 ]
	SKIPE CSECHO		;ECHOING COMMAND FILE ?
	JRST %GOTO5		;NO
	CALL CRLTYP		;BEGIN WITH A FLOURISH
	MOVE T1,(SYM)		;GET TAG NAME
	CALL SIXTYP
	CALL COLTYP		;END WITH A ":"
%GOTO5:	MOVE T1,1(SYM)		;GET VALUE
	MOVEM T1,CMDCNT		;WHERE WE WILL BE
	CALL FILPOS		;POSITION FILE
	JRST ILLCHR
	JRST LEVEL2


;HERE TO SEARCH THROUGH REST OF FILE TO FIND TAG

FNDTAG:	HRROS CSECHO		;SUPPRESS ECHO WHILE SEARCHING
	CALL SIXIN		;GET NEXT SIXBIT WORD
	JRST FNDTG8
	CAIE T5,":"		;WAS THAT A TAG DEFINITION ?
	JRST FNDTG8		;NO
	LDB T2,[POINT 6,T1,5]	;DID IT START WITH A % ?
	CAIE T2,'  %'
	JRST FNDTG8
	MOVE T2,CMDCNT		;VALUE OF TAG
	MOVSI T3,SMF.SU		;SUPPRESSED
	SETZM T4		;MISC
	CALL ADDSYM		;ADD IT TO OUR TABLE
	MOVE T1,(SYM)		;GET SYMBOL
	CAME T1,SYMBOL		;WAS THIS WHAT WE WANTED ?
	JRST FNDTG8		;NO SO KEEP LOOKING
	HRRZS CSECHO		;TURN ECHOING BACK ON
	RET SKIP,FNDTAG

FNDTG8:	SKIPE CMDFIL		;DID WE HIT END OF FILE ?
	JRST FNDTAG		;NO SO KEEP LOOKING
	HRRZS CSECHO		;TURN ECHO BACK ON
	RET ,FNDTAG



;HERE IF DOING A %IF COMMAND

%IFB:	SETOM IFBYTE		; FLAG BYTE MODE
	CAIA			; SKIP NEXT WORD
%IF:	SETZM IFBYTE		;WE ARE DOING WORD WORK
	CALL SIXIN		;GET CONDITION
	JRST ILLCHR		;LOSE
	SETZ T3,
%IF..3:	SKIPN %IFLST(T3)
	JRST ILLCHR		;LOSE CAUSE CAN'T FIND THAT TYPE
	CAME T1,%IFLST(T3)	;FIND IT ?
	AOJA T3,%IF..3
	JRST @%IFDSP(T3)	;DISPATCH ON TYPE OF CONDITION

;HERE FOR "%IF DEF" OR "IF DF"

%IFDEF:	CALL SIXIN		;GET WHAT MIGHT BE DEFINED
	JRST ILLCHR		;LOSE CAUSE END OF FILE
	CALL SYMFND		;GO SEE IF WE CAN FIND IT
	JRST %IFNOT		;NOT DEFINE SO DON'T DO IT
	JRST %IFTRUE		;FOUND IT

;HERE FOR "%IF ERR"

%IFERR:	TXZN FLG,F.CERR
	JRST %IFNOT		;DON'T DO IT
	JRST %IFTRU		;DO IT

;HERE FOR "%IF NDF"

%IFNDF:	CALL SIXIN		;GET SYMBOL TO CHECK
	JRST ILLCHR		;LOSE
	CALL SYMFND		;SEE IF WE CAN FIND IT
	JRST %IFTRUE		;WHAT HE WAS LOOKING FOR
	JRST %IFNOT



;HERE FOR "IF EQ"

%IF.EQ:	MOVE T1,[SKIPE T1]
	JRST %IFEXP

;HERE FOR "%IF G" OR "%IF GT"

%IF.GT:	MOVE T1,[SKIPG T1]
	JRST %IFEXP

;HERE FOR "%IF GE"

%IF.GE:	MOVE T1,[SKIPGE T1]
	JRST %IFEXP

;HERE FOR "%IF NE" OR "%IF N"

%IF.NE:	MOVE T1,[SKIPN T1]
	JRST %IFEXP

;HERE FOR "%IF L" OR "%IF LT"

%IF.LT:	MOVE T1,[SKIPL T1]
	JRST %IFEXP

;HERE FOR "%IF LE"

%IF.LE:	MOVE T1,[SKIPLE T1]
	JRST %IFEXP

%IFEXP:	PUSH P,T1		;SAVE TEST
	CALL GETEXP		;GET EXPRESSION TO EVALUATE
	JRST ILLCHR		;LOSE CAUSE EPRESSION NOT HERE
	SKIPE IFBYTE		; IS THIS A BYTE MODE?
	JRST [	TRNE T1,200	; IS THIS BYTE NEGITIVE
		ORCMI T1,177	; SIGN EXTEND THE BYTE
		JRST %IFEX2 ]
	TRNE T1,100000		;IS THIS NEGATIVE ?
	ORCMI T1,077777		;EXTEND SIGN
%IFEX2:	POP P,T2		;GET TEST
	XCT T2
	JRST %IFNOT		;NOT TRUE



%IFTRU:	CALL SIXIN
	JRST ILLCHR		;MUST BE END OF FILE
	SETZ T2,
	ROTC T1,6
	CAIE T2,'  %'
	ROTC T1,-6
	MOVEI T2,'  %'
	ROTC T1,-6
	JRST %GOTO3		;BRANCH TO THAT TAG

;HERE BECAUSE CONDITION NOT TRUE

%IFNOT:	CALL SIXIN
	JRST ILLCHR
	JRST LEVEL2		;ON TO OTHER THINGS


;HERE TO DO SS OR DD FIELD

LEVEL5:	PUSH P,T1
	CALL GETOPR		;GET OPERAND
	JRST [POP P,T1		;CLEAN OFF STACK
		POP P,T1	;POP OFF RETURN
		JRST LEVEL2 ]
	LDB T3,[POINT 6,T1,17]	;GET MODE
	CAIE T3,27		;IMMEDIATE ?
	CAIN T3,37		;OR ABSOLUTE ?
	JRST LEVEL4
	CAIL T3,60
LEVEL4:	JRST [IDPB T1,DAT
		LSH T1,-^D8
		IDPB T1,DAT
		MOVEI T1,2
		ADDM T1,DTFINP
		JRST .+1 ]
	POP P,T1		;GET POSITION
	LSH T3,(T1)
	MOVE T2,-2(P)		;GET POINTER TO OPCODE
	LDB T1,T2		;GET LOW ORDER BITS
	ILDB T2,T2		;GET HIGH ORDER BITS
	DPB T2,[POINT 8,T1,27]
	TRO T1,(T3)		;SET SS OR DD MODE
	MOVE T2,-2(P)		;GET POINTER TO OPCODE
	DPB T1,T2		;SAVE LOW ORDER BITS
	LSH T1,-^D8
	IDPB T1,T2		;SAVE HIGH ORDER BITS
	RET ,LEVEL4



;HERE TO GET AN OPERAND
; CALL GETOPR
;	LOSE RETURN
;	WIN	WITH T1/ MODE,,ADR

GETOPR:	TXZ FLG,F.HASH!F.PERC!F.LPAR
	MOVSI AC1,400000	;BUILD MODE HERE
GETOP0:	CALL GETEXP
	RET ,GETOPR
	LDB T1,CMDPTR		;GET BREAK CHAR
	CAIN T1,"@"
	JRST [	TLON AC1,10	;BIT FOR INDIRECT
		TXNE FLG,F.GEXP
		JRST ILLCHR
		JRST GETOP0]
	CAIN T1,"#"
	JRST [	TXON FLG,F.HASH
		TXNE FLG,F.GEXP
		JRST ILLCHR
		JRST GETOP0]
	CAIN T1,"-"		;IS THIS AUTO DECREMENT ?
	JRST [TLON AC1,40	;FLAG AUTO DECREMENT
		TXNE FLG,F.GEXP	;WAS THERE ANY DATA ?
		JRST ILLCHR
		CALL GETCHR	;GET THE (
		IDPB T1,CMDPTR
		CAIE T1,"("
		JRST ILLCHR
		JRST GETOP5 ]
	CAIN T1,"("
	JRST [TXOE FLG,F.LPAR
		JRST ILLCHR
		HRR AC1,EXPRESS	;IN CASE INDEXED
		TLNN AC1,10	;HAVE A @ ALSO ?
		TXNE FLG,F.GEXP	;WAS IT INDEXED ?
		TLO AC1,60	;REMEMBER WAS INDEXED
		JRST GETOP5 ]
	TXNN FLG,F.GEXP		;DID WE GET SOMETHING ?
	JRST ILLCHR
	HRR AC1,EXPRESS		;GET EXPRESSION
	TXNE FLG,F.SREG
	JRST [DPB AC1,[POINT 3,AC1,17]
		JRST GETOP8 ]
	TXNE FLG,F.HASH		;WAS THAT IMMEDIATE ?
	JRST [TLO AC1,27	;SET IMMEDIATE OR ABSOLUTE
		JRST GETOP8 ]
	TLO AC1,67
	HRRZI T1,-4(AC1)
	SUB T1,DTFINP
	SKIPN F.MCB
	ANDI T1,177777
	HRROM AC1,LSTIAD	;IN CASE ENDS WITH AN HT
	HRR AC1,T1
	JRST GETOP9



;HERE TO GET THE REGISTER NAME IN OPERAND SPECIFICATION

GETOP5:	CALL GETREG		;GET REGISTER NAME
	DPB T1,[POINT 3,AC1,17]	;PUT REGISTER NAME IN MODE
	LDB T1,CMDPTR		;GET BREAK CHARACTER
	CAIE T1,")"
	JRST ILLCHR
GETOP6:	CALL GETCHR		;GET NEXT CHARACTER
	IDPB T1,CMDPTR
	CAIN T1,"+"		;WAS THAT AUTO INCREMENT ?
	JRST [TLON AC1,20	;ALREADY SEEN "+"
		TLNE AC1,40
		JRST ILLCHR
		JRST GETOP6 ]
	TLNN AC1,70
	TLO AC1,10
GETOP8:	MOVEM T1,LSTIAD		;LAST ADDRESS INPUT
GETOP9:	MOVE T1,AC1		;PUT RESULT IN RIGHT REG
	RET SKIP,GETOPR


;HERE TO GET A REGISTER ARGUMENT

GETREG:	CALL GETEXP		;GET REGISTER NAME
	JRST ILLCHR
	TXNN FLG,F.SREG
	JRST ILLCHR
	MOVE T1,EXPRESS
	HRLI T1,400000
	MOVEM T1,LSTIAD		;LAST ADDRESS INPUT
	RET ,GETREG

;HERE TO GET AN EXPRESSION
; CALL GETEXP
;	LOSE RETURN
;	WIN RETURN	EXPRESSION IN T1, AND FLAGS SET

GETEXP:	SETZM EXPRES		;ACCUMULATED EXPRESSION
GTEXP1:	TXZ FLG,F..ESC!F..SIM!F.GEXP!F.SYML!F.SYMB!F.TEXT!F.IOCT!F.IDEC!F.IHEX!F.SREG!F.FELE
GTEXP3:	SETZM INPOPR		;CLEAR INPUT OPERATOR
	SETZM REMAIN		;REMAINDER OF LAST DIVISION
	SETZM OCTIN#
	SETZM DECIN#
	SETZM HEXIN#
	SETZM SYMBOL
	MOVE T1,[POINT 6,SYMBOL]
	MOVEM T1,SYMPTR
GTEXP2:	CALL GETCHR		;GET FIRST CHARACTER
	CAIN T1," "		;WAS IT A BLANK ?
	JRST GTEXP2		;YES SO FLUSH IT
	CAIA



LOOP:	CALL GETCHR		;GET A COMMAND CHAR
	IDPB T1,CMDPTR		;REMEMBER CHAR IN CASE NEED TO RESCAN
LOOP1:	HRRZ T2,T1
	LSH T2,-1
	TRNE T1,1		;note the t2 must have the char/2
	SKIPA T2,@STATE		; because state has that set up as an 
	HLRZ T2,@STATE		; index.  
	JRST (T2)		;DISPATCH ON CHARACTER

;HERE WHEN ASSEMBLING NUMBER AND FIND A PERIOD

ASSPER:	TXNN FLG,F.IDEC!F.IOCT
	JRST ASSYMB
	TXO FLG,F.IDEC
	TXZ FLG,F.IOCT!F.IHEX
	JRST ASYMB2

;HERE WHEN NUMBER MUST BE DECIMAL

ASSDEC:	TXO FLG,F.IDEC
	TXZ FLG,F.IOCT

;HERE WHEN ASSEMBLING A OCTAL, DECIMAL OR HEX NUMBER

ASSNUM:	TXNE FLG,F.SYMB			; ARE WE READING A SYMBOL WITH A DIGIT?
	JRST ASSYMB			; YES, FORGET THIS NUMBER STUFF...
	TXNN FLG,F.IDEC!F.IHEX
	TXO FLG,F.IOCT
	MOVE T2,OCTIN
	LSH T2,3
	ADDI T2,-60(T1)
	MOVEM T2,OCTIN
	MOVE T2,DECIN
	IMULI T2,^D10
	ADDI T2,-60(T1)
	MOVEM T2,DECIN
	MOVE T2,HEXIN
	LSH T2,4
	ADDI T2,-60(T1)
	MOVEM T2,HEXIN
	JRST ASYMB2

;HERE WHEN ENCOUNTER A PERCENT SIGN - POSSIBLE TAG OR REG NAME

ASSPRC:	TXNN FLG,F.FELE		;HAVE WE DONE FIRST ELEMENT OF EXPRESSION ?
	MOVE T2,SYMPTR		;GET POINTER TO SYMBOL
	CAME T2,[POINT 6,SYMBOL] ;STARTED SYMBOL YET ?
	JRST ACCUM		;CAN'T HAVE THIS IN MIDDLE !



;HERE WHEN ASSEMBLING A SYMBOL

ASSYMB:	TXO FLG,F.SYMB
	TXZ FLG,F.IDEC!F.IOCT!F.IHEX
ASYMB2:	TXO FLG,F.GEXP		;GOT SOMETHING
	CAIL T1,40+"A"		;CHECK FOR LOWER CASE
	CAILE T1,40+"Z"
	SUBI T1,40		;CONVERT CHAR TO SIXBIT
	MOVE T2,SYMPTR		;GET POINTER TO SYMBOL
	CAME T2,[POINT 6,SYMBOL,35]
	IDPB T1,SYMPTR		;ADD CHAR TO SYMBOL
	JRST LOOP

;HERE IF END EXPRESSION WITH A SPACE

EXPSPC:	TXNN FLG,F.FELE		;IS THIS FIRST ELEMENT OF EXPRESSION ?
	TXNN FLG,F.SYMB		;EVALUATING A SYMBOL ?
	JRST EXPLUS		;AFTER FIRST SUBEXPRESSION SAME AS PLUS
	CALL EVLSYM		;FIND WHAT SYMBOL IS
	RET ,EXPSPC
	TLNN SYM,SMF.IN		;WAS THAT AN INSTRUCTION
	JRST EXPLUS		;NO SO SAME AS PLUS
	MOVE T1,1(SYM)		;GET VALUE
	HRRZM T1,EXPRESS
	RET SKIP,EXPSPC

EXPLUS:	TDZA T1,T1		;CODE FOR NEXT TIME IS 0
EXPMIN:	MOVEI T1,1
	JRST EXP.DO

EXPMUL:	SKIPA T1,[2]
EXPDIV:	MOVEI T1,3
	JRST EXP.DO

EXPIOR:	SKIPA T1,[4]
EXPAND:	MOVEI T1,5
	JRST EXP.DO

EXPXOR:	MOVEI T1,6
EXP.DO:	TXO FLG,F.FELE		;HAVE SEEN FIRST ELEMENT
	MOVE T2,PRECED(T1)	;GET PRECEDENCE OF NEW OPERATOR
	MOVE T3,INPOPR		;PREVIOUS OPERATOR
	MOVE T3,PRECED(T3)	;GET PRECEDENCE OF OLD OPERATOR
	CAMG T2,T3
	JRST EXPDO5
	PUSH P,EXPRESS		;SAVE PARTIAL EXPRESSION SO FAR
	PUSH P,INPOPR		;AND PREVIOUS OPERATOR
	SETZM EXPRESS		;INITIALIZE EXPRESSION
	SETZM INPOPR
	CALL EXPDO5		;DO NEXT PART OF EXPRESSION
	SOS -2(P)		;UNSKIP RETURN FROM ACCUM3
	POP P,INPOPR		;PREVIOUS OPERATION
	MOVE T2,EXPRESS		;LATEST ACCUMULATION
	POP P,EXPRESS		;PREVIOUS ACCUMULATION
	JRST ACCUM3
EXPDO5:	PUSH P,T1		;SAVE CODE FOR NEXT TIME
	CALL ACCUM		;ACCUMULATE EXPRESSION
	JRST [POP P,T1
		RET ,EXP.DO]
	POP P,INPOPR		;NEXT INPUT OPERATION
	JRST LOOP		;THEN DONE



;HERE WHEN USER TYPES A <CONTROL F> - FILL FIELD

CNTRLF:	SKIPN T1,SYMBOL		;ARE WE BUILDING A SYMBOL ?
	JRST ILLCHR		;DING HIM
	MOVEI T1,[BYTE (7)10,40,10,10,40,10,0] ;BACKUP OVER ^F
	MOVE T2,TTYBIT		;GET TTY BITS
	TXNE T2,TF.RUB		;VIDEO TERMINAL ?
	CALL TYPSTR		;YES SO CLEAN SCREEN
	PUSH P,T4
	PUSH P,T5
	SETOM T5		;ESTABLISH COUNTER
	SETZM T4		;ESTABLISH MATCH
	CALL MATCH		;TRY TO FIND PARTIAL MATCH
	JUMPE SYM,CNTLF5
	AOSN T5
	MOVE T4,(SYM)		;GET MATCH
	MOVE T1,(SYM)		;GET NEW MATCH
	SKIPA T2,[EXP -1]	;BUILD MASK
CNTLF3:	LSH T2,6		;SHRINK MASK
	AND T1,T2		;MASK NEW MATCH
	AND T4,T2		;MASK PREVIOUS MATCH
	CAME T1,T4		;MATCH LAST MATCH ?
	JRST CNTLF3
	RET ,CNTRLF
CNTLF5:	JUMPE T4,CNTLF8		;CHECK FOR NO MATCHES
	XOR T4,SYMBOL		;LEAVE ONLY NEW CHARS
	JUMPE T4,CNTLF7
CNTLF2:	LSH T4,6
	TLNN T4,770000		;SHIFTED FAR ENOUGH ?
	JRST CNTLF2
CNTLF6:	SETZ T3,
	LSHC T3,6
	MOVEI T1,40(T3)
	IDPB T1,CMDPTR
	CALL TYPCHR
	JUMPN T4,CNTLF6
CNTLF7:	JUMPE T5,CNTLF9		;NO BELL IF ONLY ONE MATCH
CNTLF8:	MOVEI T1,7
	CALL TYPCHR
CNTLF9:	POP P,T5
	POP P,T4
	MOVE T1,[POINT 7,CMDLIN]
	MOVEM T1,CMDTKR		;RESCAN THE LINE
	MOVE T1,CMDPTR
	MOVEM T1,CMDLIM
	JRST LEVEL2



;ROUTINE TO COMBINE ELEMENTS OF EXPRESSION, MAY BE SUBR OR EXIT FROM GETEXP

ACCUM:	LDB T1,CMDPTR		;THE BREAK CHAR WHICH GOT US HERE
	CAIE T1,"("		;WE ARE LOOKING FOR -(
	JRST ACCUM2		;DEFINATELY NOT
	CALL RSCAN		;GET POINTER TO PREVIOUS CHAR
	LDB T1,T2		;GET PREVIOUS CHAR
	CAIE T1,"-"		;WAS THIS AUTO DECREMENT ?
	JRST ACCUM2		;NO
	MOVE T1,CMDPTR		;LIMIT
	SKIPN CMDTKR		;ALREADY DOING A RESCAN ?
	MOVEM T1,CMDLIM		;DOING ONE NOW
	MOVEM T2,CMDTKR
	MOVEM T2,CMDPTR
	JRST ACCUM8
ACCUM2:	SETZ T2,		;IN CASE FOLLOWING DOESN'T SET UP T2
	TXZE FLG,F.SYMB
	JRST [CALL EVLSYM
		RET ,ACCUM
		MOVEM T1,T2	;PUT IN RIGHT REG
		JRST ACCUM3 ]
	TXZE FLG,F.IOCT
	MOVE T2,OCTIN
	TXZE FLG,F.IDEC
	MOVE T2,DECIN
	TXZE FLG,F.IHEX
	MOVE T2,HEXIN
ACCUM3:	MOVE T1,EXPRES		;GET EXPRESSION SO FAR
	MOVE T3,INPOPR		;GET INPUT OPERATOR
	XCT [	ADD T1,T2
		SUB T1,T2
		IMUL T1,T2
		IDIV T1,T2
		IOR T1,T2
		AND T1,T2
		XOR T1,T2 ](T3)
	CAIE T3,3		;DID WE JUST DO A DIVISION ?
	SETZ T2,		;NO SO NO REMAINDER
	MOVEM T1,EXPRESS	;SAVE ACCUMULATED EXPRESSION
	MOVEM T2,REMAIN		;SAVE NEW REMAINDER
ACCUM8:	MOVEI T1,177777		;MASK FOR 16 BITS
	SKIPE F.MCB
	MOVEI T1,777777		;YES, MASK FOR 18 BITS
	ANDB T1,EXPRESS		;MASK OFF HIGH BITS
	SETZM OCTIN
	SETZM DECIN
	SETZM HEXIN
	SETZM SYMBOL
	MOVE T2,[POINT 6,SYMBOL]
	MOVEM T2,SYMPTR
	RET SKIP,ACCUM



;HERE IF USER TYPES A CONTROL R

CNTRLR:	CALL RSCAN
	MOVEM T2,CMDPTR		;SAVE PUTTER WITHOUT CONTROL R
	CALL CNTLR3
	JRST LOOP

;HERE TO RETYPE COMMAND

CNTLR3:	CALL CRLTYP		;TYPE A <CR><LF> TO BEGIN
	MOVE T2,[POINT 7,CMDLIN] ;GET POINTER TO COMMAND LINE
	CAMN T2,CMDPTR		;IS LINE EMPTY ?
	JRST CRLTYP		;EXTRA FLOURISH TO END
CNTLR4:	ILDB T1,T2		;GET NEXT CHAR TO ECHO
	CAIN T1,33		;IS CHAR AN ALTOMODE ?
	MOVEI T1,"$"		;YES SO SPECIAL ECHO
	CALL TYPCHR		;ECHO THE CHAR
	CAME T2,CMDPTR		;TYPED ENOUGH YET ?
	JRST CNTLR4		;LOOP BACK FOR REST OF CHARS
	RET ,CNTRLR

;HERE TO BACKUP COMMAND POINTER
; CALL RSCAN
;	RETURN	WITH T2 CONTAINING POINTER TO PREVIOUS CHAR
;		T1 CONTAINS POINTER TO PREVIOUS-2 CHAR

RSCAN:	SETZB T1,T2
	MOVE T3,[POINT 7,CMDLIN]
RSCAN2:	CAMN T3,CMDPTR		;HIT END YET ?
	RET ,RSCAN
	MOVE T1,T2
	MOVE T2,T3
	IBP T3
	JRST RSCAN2



;HERE WHEN USER TYPES A RUBOUT

COMRUB:	CALL RSCAN		;BACK UP POINTER
	JUMPE T1,CNTRLU		;IF NOTHING IS SAME AS ^U
	MOVEM T1,CMDLIM
	MOVEM T1,CMDPTR		;IN CASE CALL CNTLR3
	MOVE T1,[POINT 7,CMDLIN]
	MOVEM T1,CMDTKR		;RESCAN THE COMMAND
	MOVE T1,TTYBIT		;GET TTY DESCRIPTION WORD
	TXNN T1,TF.RUB		;IS THIS A VIDEO TERMINAL ?
	JRST CMRUB3		;GO DO "\X" TYPE ECHO
	LDB T1,T2		;GET CHAR JUST RUBBED OUT
	CAIN T1,33		;IS IT AN ALTMODE ?
	MOVEI T1,"$"
	CAIGE T1," "		;BE SURE USUAL PRINTING CHAR
	JRST [	CALL CNTLR3	;ECHO COMMAND
		JRST CMRUB8 ]
	MOVEI T1,[BYTE (7)10,40,10,0]
	CALL TYPSTR
	JRST CMRUB8

CMRUB3:	MOVEI T1,"\"
	CALL TYPCHR
	LDB T1,T2
	CAIN T1,33		;WAS THIS AN ALTMODE ?
	MOVEI T1,"$"
	CALL TYPCHR		;ECHO CHAR JUST RUBBED OUT
CMRUB8:
CMRUB9:	MOVE T1,[ESCSAV,,BYTCNT] ;RESTORE THINGS SET WITH
	BLT T1,BYTCNT+2		; ESCAPE COMMANDS
	JRST LEVEL2

;HERE WHEN USER TYPES A CONTROL U

CNTRLU:	MOVEI T1,[BYTE (7)7,"x","x","x",11,0]
	CALL TYPSTR
	JRST CMRUB9



;HERE WHEN USER TYPES A CONTROL W - DELETE FIELD FROM TYPEIN

CNTRLW:	CALL RSCAN		;BACKUP POINTER
	JUMPE T1,CNTRLU		;IF NOTHING SAME AS ^U
	SKIPA T2,T1
CNTLW1:	CALL RSCAN
	MOVEM T2,CMDLIM
	MOVEM T2,CMDPTR
	MOVE T1,[POINT 7,CMDLIN]
	MOVEM T1,CMDTKR
	JUMPE T1,CNTRLU		;IF NOTHING IS SAME AS ^U
	LDB T2,CMDPTR		;GET LAST CHAR
	CAIN T2,"."
	JRST CNTLW1		;KEEP BACKING UP
	CAIL T2,"0"
	CAILE T2,"Z"+40
	JRST CNTLW9
	CAILE T2,"9"
	CAIL T2,"A"+40
	JRST CNTLW1		;KEEP BACKING
	CAIL T2,"A"
	CAILE T2,"Z"
	JRST CNTLW9
	JRST CNTLW1
CNTLW9:	CALL CNTLR3		;RETYPE THE LINE
	JRST LEVEL2		;THEN REDO IT



;HERE WHEN COMMAND STARTS WITH A QUOTE

QUOTE:	TXNE FLG,F.GEXP		;DID ANYTHING PRECEDE THE " ?
	JRST ILLCHR		;BOUNCE REQUEST
	MOVE STATE,[STATEQ(T2)]	; PASS ADDRESS OF NEW STATE TABLE
				; but include t2 as the index register
	MOVEI T2,QUOTEB		;NEXT CHAR IS THE BREAK CHAR
	CALL QUOTET		;SET UP TABLE
	MOVEI T1,DAT.AS		;REMEMBER WE ARE WORKING ON AN ASCII STRING
	MOVEM T1,TYPDAT		;SO WE CAN DO GOOD THINGS LATER
	JRST LOOP

;HERE WHEN GET BREAK CHARACTER AFTER QUOTE
QUOTEB:	TXO FLG,F.TEXT		;NOW DOING TEXT
	MOVEI T2,QUOTEC		;MOST CHARACTERS NOW ARE TEXT
	CALL QUOTET		;SETUP DISPATCH TABLE
	ROT T1,-1		;DIVIDE BREAK CHAR BY 2
	ADDI T1,(STATE)		;POINT TO STATE TABLE
	MOVEI T2,QUOTEE		;WHEN GET ANOTHER BREAK ARE DONE
	HRRM T2,(T1)
	SKIPL T1		;WAS CHAR EVEN ?
	MOVSS @T1		;YES SO DISPATCH FROM LEFT OF WORD
	JRST LOOP

;HERE WHEN GET ANOTHER TEXT CHAR
QUOTEC:	ANDI T1,177		;STRIP PARITY
	IDPB T1,DAT		;PUT INTO DATA AREA
	SKIPL T1,DTFINP		;ALREADY SETUP DTFINP ?
	SKIPA T1,DOT		;NO SO USE DOT
	AOS T1			;ADVANCE IT
	MOVEM T1,DTFINP
	JRST LOOP		;GO GET NEXT CHAR

;HERE WHEN GET TERMINAL BREAK
QUOTEE:	TXZ FLG,F.TEXT		;NO LONGER DOING TEXT
	HRRI STATE,STATE0
	JRST LEVEL3

;HERE TO SETUP DISPATCH TABLE
QUOTET:	HRLI T2,(T2)
	MOVEM T2,(STATE)
	HRLI T2,(STATE)		;BUILD BLT POINTER
	HRRI T2,1(STATE)	;FINISH POINTER
	BLT T2,77(STATE)
	MOVEI T2,CNTRLR		;DISPATCH FOR CONTROL R
	HRLM T2,11(STATE)
	MOVEI T2,CNTRLU		;DISPATCH FOR CONTROL U
	HRRM T2,12(STATE)
	MOVEI T2,CNTRLW		;DISPATCH FOR CONTROL W
	HRRM T2,13(STATE)
	MOVEI T2,CNTRLZ		;DISPATCH FOR CONTROL Z
	HRLM T2,15(STATE)
	MOVEI T2,COMRUB		;DISPATCH FOR RUBOUT
	HRRM T2,77(STATE)
	RET ,QUOTET



;HERE WHEN USER TYPES A CR COMMAND

COM.CR:	CALL STEFIN		;DO DEPOSIT MAYBE
	TXZN FLG,F..ESC		;WAS THIS AN <ESCAPE><CR> ?
	JRST LEVEL0		;NO SO CLEAN UP THEN GET MORE CHARS
	CALL DOTSWP		;LOAD ALTERNATE DOT
	CALL COMLF1		;DISPLAY NEW DOT
	JRST LEVEL0

;HERE WHEN USER TYPES A BACK SLASH

BKSLSH:	CALL B3.TYP
	PUSH P,DOT
	PUSH P,DOTFOO
	MOVE DOT,LSTIAD
	CALL DATYPE
	POP P,DOTFOO
	POP P,DOT
	JRST LEVEL2

;HERE WHEN USER TYPES IN AN ILLEGAL CHARACTER

ILLCHR:	MOVEI T1,[BYTE (7)"?",7,11,0]
IFN DEBUG,<
	SKIPE F.DEBU		; FUNNY MESSAGE IF ASKED FOR.
	MOVEI T1,[ASCIZ /
%DDT11-W-QDT, Question mark - Dink - Tab.
/]
>
ILLCH0:	CALL TYPSTR
	TXO FLG,F.CERR		;IN CASE THIS IS A COMMAND FILE
	MOVE T1,[ESCSAV,,BYTCNT] ;RESTORE THINGS SET BY ESCAPE
	BLT T1,BYTCNT+2		; COMMANDS
	JRST LEVEL2

;HERE WHEN THE USER TYPES A TAB COMMAND

COM.HT:	CALL STEFIN		;DO DEPOSIT MAYBE
	CALL CRLTYP		;TYPE A CR/LF
	CALL DOTSAV		;SAVE CURRENT DOT, DOTFOO, FOR LATER
	MOVE DOT,LSTADR		;LAST ADDRESS TYPED IN OR OUT
	CALL COMLF1
	JRST LEVEL2



;HERE TO SAVE CURRENT DOT, DOTFOO FOR LATER $/ ETC.

DOTSAV:	MOVEM DOT,DOTOLD	;SAVE DOT
	MOVE T1,DOTFOO		;GET DOTFOO
	MOVEM T1,DTFOLD		;SAVE IT ALSO
	RET ,DOTSAV

;HERE TO SET DOTFOO TO NEXT VALUE

NDTFOO: PUSH P,T2
	HRRM T2,O.MODE
	CAIN T2,3
	JRST NXT.0
	POP P,T2
	MOVE T1,DOTFOO		;CURRENT DOTFOO
	CALL DOTINC
	MOVEM T1,DOTFOO
	RET ,NDTFOO

NXT.0: 	POP P,T2
	RET ,NDTFOO

;HERE TO SET DTFINP TO NEXT VALUE

NDTFIN:	MOVE T1,DTFINP		;GET CURRENT DTFINP
	CALL DOTINC		;INCREMENT IT
	MOVEM T1,DTFINP		;RESTORE NEW DTFINP
	RET ,NDTFIN

;HERE TO GET THE NEXT VALUE FOR DOT

NXTDOT:	MOVE T1,DOT
	CALL DOTINC
	MOVEM T1,DOT
	RET ,NXTDOT


;GET NEXT VALUE FOR LOCATION POINTER
; CALL: MOVE T1,<CURRENT VALUE>
;	CALL DOTINC

DOTINC:	SKIPL T1		;DID IT GET LOADED ?
	JRST [SKIPL T1,DOT	;START WITH DOT
		TXO T1,DOT.FG
		RET ,DOTINC	]
	SKIPE PDP8F		;OR A PDP8 ?
	AOJA T1,[TRZ T1,700000	;15 BIT ADR
		RET ,DOTINC	]
	TXNN T1,DOT.AC		;WAS THIS A REGISTER ADDRESS ?
	JRST [AOS T1		;INCREMENT BY 1 FOR REGISTERS
		TRZ	T1,777770 ;STRIP EXTRA BITS
		RET ,DOTINC	]
	PUSH P,T2
	HRRZ T2,O.MODE			; BYTE MODE?
	CAIN T2,3			; 
	JRST DOT.0			; YES 
	POP P,T2
	ADDI T1,2
	TRZ T1,1
	SKIPN F.MCB
	TRZ T1,600001
	RET ,DOTINC

DOT.0:	HRRZ T2,BYTCNT			; ADD BYTE COUNT
	ADD T1,T2
	SKIPN F.MCB			; MCB?
	TRZ T1,600000			; MASK TO 16-BITS
	POP P,T2			; RESTORE T2
	RET ,DOTINC



;HERE IF END EXPRESSION WITH AN LEFT ANGLE BRACKET

LFTANG:	CALL ACCUM		;FINISH EXPRESSION
	RET ,LFTANG
	HRROM T1,LFTSAV		;SAVE IT
	JRST GETEXP

;HERE WHEN THE USER TYPES A LINE FEED COMMAND

COM.LF:	CALL STEFIN		;DO DEPOSIT MAYBE
	TXZE FLG,F..ESC		;WAS <LF> PRECEDED BY AN <ESCAPE> ?
	CALL DOTSWP		;YES SO SPECIAL HANDLING
	MOVEI T1,15		;CARRIAGE RETURN
	CALL TYPCHR
	MOVE T1,DOTFOO
	SETZM DOTFOO		;DONE WITH IT NOW
	CALL DOTINC
	MOVEM T1,DOT
	CALL COMLF1
	JRST LEVEL2

COMLF1:	TXO FLG,F.LOPN		;FLAG LOCATION IS OPEN
COMLF2:	MOVE T1,DOT
	CALL ADRTYP		;TYPE ADDRESS
	MOVEI T1,"/"
	TXNE FLG,F.LBKT		;FOLLOWING A LEFT BRACKET ?
	MOVEI T1,"["		;YES SO DECLARE IT
	CALL TYPCHR
COMLF3:	HRRZ T1,DOT
	CAMGE T1,CACHEL		;IS THIS ALREADY IN CACHE ?
	SETZM CACHEL		;YES SO FLUSH CACHE
COMLF4:	CALL B3.TYP		;TYPE 3 SPACES
	TXO FLG,F.CACH		;USE CACHE AFTER 1ST WORD
	TXNN FLG,F.LBKT		;DOING LFT BRACKET STUFF ?
	PJRST DATYPE
	MOVEI T1,2		;NUMERIC STYLE
	MOVEI T5,1		;ONE WORD
	PJRST RETYPE



;HERE WHEN USER TYPES A BACK ARROW

BARROW:	CAMN T4,DAT		;FOLLOWING TYPEIN ?
	JRST BARRW5		;NO
BARRW3:	ILDB T1,T4		;GET LOW ORDER BYTE
	SETZ T2,		;IN CASE ODD NUMBER OF BYTES
	CAME T4,DAT
	ILDB T2,T4		;GET HIGH ORDER BYTE
	DPB T2,[POINT 8,T1,27]
	SKIPN F.MCB
	JRST BARRW4
	SETZ T2,
	CAME T4,DAT
	ILDB T2,T4
	DPB T2,[POINT 8,T1,19]
BARRW4:	CALL ADRTYP		;DISPLAY AS AN ADDRESS
	CAME T4,DAT		;DONE ALL YET ?
	JRST [CALL COMTYP
		JRST BARRW3 ]	;LOOP BACK FOR REST
	CALL B3.TYP
	JRST LEVEL2
BARRW5:	TXNN FLG,F.LOPN		;IS LOCATION OPEN ?
	JRST ILLCHR		;NO SO BOUNCE COMMAND
	MOVEI T1,0		;OUTPUT AS INSTRUCTION
	MOVEI T5,2		;WANT ONLY 1 WORD
	CALL RETYPE		;NO RETYPE STUFF
	JRST LEVEL2

;HERE WHEN USER TYPES A SEMICOLON

SEMICL:	CAMN T4,DAT		;FOLLOWING TYPEIN ?
	JRST SMICL5		;NO
	JRST LEVEL2
SMICL5:	TXNN FLG,F.LOPN		;IS LOCATION OPEN ?
	JRST ILLCHR		;IF NOT CAN'T HANDLE
	HRRZ T1,O.MODE		;SET RIGHT MODE
	HRRZ T5,BYTCNT
	CALL RETYPE
	JRST LEVEL2

RETYPE:	PUSH P,O.MODE		;SAVE OUTPUT MODE
	HRRM T1,O.MODE
	PUSH P,BYTCNT
	HRRM T5,BYTCNT
	SETZM DOTFOO
	TXO FLG,F.CACH		;USE CACHE IF POSSIBLE
	CALL DATYPE		;TYPE DATA
	POP P,BYTCNT
	POP P,O.MODE		;RESTORE OUTPUT MODE
	RET ,RETYPE



;HERE WHEN USER TYPES =

EQUALS:	CAMN T4,DAT		;FOLLOWING TYPEIN ?
	JRST EQUAL5		;NO
	TXNE FLG,F.SYML		;DID TYPEIN INCLUDE A SYMBOL ?
	TLNN SYM,SMF.RG		;WAS THAT A REGISTER NAME ?
	CAIA
	CALL PCNTYP		;TYPE A %
EQUAL2:	ILDB T1,T4
	SETZ T2,
	CAME T4,DAT
	ILDB T2,T4
	DPB T2,[POINT 8,T1,27]
	SKIPN F.MCB
	JRST EQUAL3
	SETZ T2,
	CAME T4,DAT
	ILDB T2,T4
	DPB T2,[POINT 8,T1,19]
EQUAL3:	MOVEM T1,LSTADR		;LAST OUTPUT ADDRESS
	MOVEM T1,ESC.Q.		;IN CASE OF <ESCAPE>Q
	CALL RADTYP
	CAMN T4,DAT
	JRST [CALL B3.TYP	;TYPE 3 SPACES
		JRST LEVEL2 ]
	CALL COMTYP
	JRST EQUAL2

;HERE TO RETYPE PREVIOUSLY OUTPUT DATA IN CURRENT RADIX

EQUAL5:	TXNN FLG,F.LOPN		;IS LOCATION OPEN ?
	JRST ILLCHR		;NO SO ILLEGAL
	MOVEI T1,2		;OUTPUT AS NUMERIC
	SKIPN T5,DOTFOO
	HRRZ T5,DOT
	SUBI T5,-2(DOT)
	ANDI T5,777777		;HALF WORD ONLY
	LSH T5,-1
	CALL RETYPE
	JRST LEVEL2



;NHERE WHEN USER TYPES [ AT END OF A NUMBER

OPLBKT:	TXOA FLG,F.LBKT		;REMEMBER HOW WE OPENED

;HERE WHEN USER TYPES / AT END OF A NUMBER

OPNLOC:	TXZ FLG,F.LBKT
	TXZE FLG,F..ESC		;ESCAPE /?
	TXO FLG,F.NOUT		;YES, SUPPRESS ALL OUTPUT UNTIL NEXT INPUT
	TXZN FLG,F.MASK		;ASKING ABOUT THE MASK ?
	JRST OPNLC4		;LOOKING AT 11
	TXO FLG,F.MOPN		;MASK NOW OPEN
	CALL B3.TYP		;TYPE 3 SPACES
	MOVEI T3,S.MASK-1	;MAKE A POINTER TO THE MASK
	SKIPN T2,ESCOCT		;DID WE GET A NUMBER WITH THE COMMAND ?
	MOVEI T2,1		;DEFAULTS TO 1
	CAIL T2,MASKSZ		;ASKING FOR TOO MUCH ?
	MOVEI T2,MASKSZ		;YES SO GIVE LIMIT
	CAIA
OPNLC2:	CALL BLANKT
	AOS T3
	MOVE T1,(T3)
	MOVEM T1,LSTADR		;IN CASE OF HT COMMAND
	MOVEM T1,ESC.Q.		;IN CASE USES <ESCAPE>Q
	CALL RADTYP		;DISPLAY IT
	SOJG T2,OPNLC2
	CALL TABTYP
	JRST LEVEL2

;HERE BECAUSE REALLY OPENING A LOCATION

OPNLC4:	CALL DOTSAV		;SAVE DOT FOR AN ESCAPE LF COMMAND
	HRRO DOT,EXPRESS
	TXNE FLG,F.SYML		;WAS SYM LOADED ?
	TLNN SYM,SMF.RG
	CAIA
	TLZ DOT,377777
	SETZM DOTFOO
	TXO FLG,F.LOPN		;FLAG LOCATION IS OPEN
	CALL COMLF3
	JRST LEVEL2



;HERE WHEN USER TYPES AN UP ARROW

UARROW:	CALL STEFIN
	TXZE FLG,F..ESC		;WAS <LF> PRECEDED BY AN <ESCAPE> ?
	CALL DOTSWP		;YES SO SPECIAL HANDLING
	CALL CRLTYP
	SETZM DOTFOO
	TXNN DOT,DOT.OK		;WAS ADR SET ?
	TXO DOT,DOT.FG
	MOVEI T1,-1		;IN CASE REGISTER MODE
	TXNN DOT,DOT.AC		;REG OR MEM ?
	JRST COMAR0		;REG - GO DO IT
	MOVNI	T1,2		;IN CASE "[" MODE
	TXNE FLG,F.LBKT		;IS IT
	JRST COMAR0		;YES
	MOVN	T1,BYTCNT	;NUMBER OF BYTES
	SKIPE PDP8F
	JRST COMAR0
	HRRZ T2,O.MODE		;GET OUTPUT MODE
	JUMPE T2,COMAR2		;SYMBOLIC ?
	CAIN T2,1		; OR ADDRESS ?
	ASH T1,1		;CONVERT WORD COUNT TO BYTES
	CAIN T2,2		;OR NUMERIC
	ASH T1,1		;CONVERT WORD COUNT TO BYTES
COMAR0:	ADD T1,DOT
	TXNN DOT,DOT.AC		;WAS THIS A REGISTER ?
	ANDI T1,7		;IN CASE WRAPPED AROUND
	SKIPE PDP8F		;IS THIS A PDP8 ADDRESS ?
	TRZA T1,700000
	ANDI T1,-1
	SKIPN F.MCB
	ANDI T1,177777
	HRRM T1,DOT
	CALL COMLF1		;REST LIKE A LINE FEED COMMAND
	JRST LEVEL2

COMAR2:	TRZ DOT,1
	SKIPN F.MCB
	TRZ DOT,600001		;INSTRUCTIONS BEGIN ON WORD BOUNDRY
	TXZ FLG,F.CACH		;DON'T USE CACHE
	MOVEI T4,1		;TRY ONE WORD INSTRUCTION FIRST
COMAR3:	MOVE T2,T4		;NUMBER OF WORDS TO LOOK FOR
	ASH T2,1		;TIMES 2 FOR BYTES
	MOVEI T1,(DOT)		;CURRENT ADR
	SUBI T1,(T2)		;BACK UP CURRENT ADR
	CALL CNINWD		;COUNT WORDS IN INSTRUCTION AT ADR
	JRST COMAR8		;NOT AN INSTRUCTION
	CAIE T4,(T1)		;IS THAT WHAT WE WANTED ?
	JRST COMAR8		;NO
	SUBI DOT,(T4)
	SUBI DOT,(T4)
	CALL COMLF1		;PRINT INSTRUCTION
	JRST LEVEL2



COMAR8:	AOS T4			;TRY FOR LARGER INSTRUCTION
	CAIE T4,4		;IS THAT TOO LARGE ?
	JRST COMAR3		;NO
	SUBI DOT,2		;JUST BACK UP ONE WORD
	CALL COMLF1
	JRST LEVEL2

;HERE TO COUNT WORDS IN AN INSTRUCTION
; CALL MOVE T1,<ADR>
;	CALL CNINWD
;	ERROR RETURN
;	WIN RETURN	NUMBER OF WDS IN T1

CNINWD:	MOVEI T2,2		;TRY FOR 2 BYTES
	SKIPE PDP8F		;UNLESS PDP8
	MOVEI T2,1		;IS PDP8 SO ONLY ONE WORD
	MOVEI T2,2		;NUMBER OF BYTES TO TRY FOR
	CALL GETWRD		;TRY TO GET THE DATA
	RET ,CNINWD
	CALL INVLFN		;SEE IT THERE IS ANY SUCH INSTRUCTION
	RET ,CNINWD
	MOVEI T2,1		;ONE FOR INSTRUCTION
	LDB T3,[POINT 6,T1,29]	;GET SS FIELD
	TLNE SYM,SMF.SS		;IS THIS SSDD FORMAT ?
	CALL CNIWD3		;YES SOADJUST NUMBER OF WDS IN INSTRUCTION
	LDB T3,[POINT 6,T1,35]	;GET DD FIELD
	TLNE SYM,SMF.DD!SMF.SS	;IS DD PRESENT ?
	CALL CNIWD3		;YES SO ADJ WORD COUNT
	HRRZ T1,T2		;NUMBER OF WORDS
	RET SKIP,CNINWD

CNIWD3:	CAIE T3,27		;IS THIS IMMEDIATE (#FOO)
	CAIN T3,37		;OR ABSOLUTE
	AOS T2			;YES SO ANOTHER WORD IN INSTRUCTION
	LDB T3,[POINT 3,T3,32]
	CAIE T3,6		;IS THIS RELATIVE
	CAIN T3,7		;OR RELATIVE DEFERRED ?
	AOS T2			;YES SO ANOTHER WORD
	RET ,CNIWD3



;HERE WHEN THE USER TYPE A ^Z

CNTRLZ:	TXNE FLG,F.EXEC		; IF WE ARE IN EXEC MODE,
	JRST DDT11		; THEN JUST REPEAT THIS PROGRAM
	MONRT.			;BACK TO THE MONITOR WE GO
	JRST LEVEL0		;USER TYPED .CONTINUE

;HERE IF USER ENDS AN EXPRESSION WITH A ">"

SUPLIM:	SKIPE T1,LFTSAV
	MOVEM T1,SBEGIN		;SET LOWER LIMIT FOR SEARCH
	MOVE T1,EXPRESS		;GET EXPRESSION
	HRRZM T1,S..END		;SET UPPER LIMIT FOR SEARCH
	JRST LEVEL2

;HERE IF USER ENDS SYMBOL WITH A "?"

QUEST.:	SKIPN T1,SYMBOL		;WERE WE BUILDING A SYMBOL ?
	JRST QUEST1		; NO, HE MUST WANT THE ENTIRE SYMBOL TABLE
	PUSH P,T5
	SETO	T5,		;COUNT MATCHES
	CALL MATCH		;TRY TO FIND A PARTIAL MATCH
	JUMPE SYM,QUEST5	;IN CASE CAN'T FIND ANY MATCHES
	CALL CRLTYP		;BEGIN WITH <CR><LF>
	MOVEI T1,[ASCIZ \following are partial matches
\]
	AOSN T5
	CALL TYPSTR
	CALL SYMDMP
QUEST4:	RET ,QUEST.
QUEST5:	MOVEI T1,[ASCIZ \ no partial matches for symbol\]
	AOSN T5			;FIND ANY MATCHES ?
	CALL TYPSTR
	POP P,T5
	CALL CNTLR3		;RETYPE THE COMMAND
	JRST LOOP

QUEST1:	MOVE SYM,SYMBEG		;GET A POINTER TO THE CURRENT SYMBOL TABLE
	TYPE <following are defined symbols
>
QUEST2:	CALL SYMDMP		; DUMP OUT THE USEFULL INFORMATION ABOUT IT
	CALL CRLTYP
	MOVEI SYM,4(SYM)	; GO TO THE NEXT SYMBOL, PLEASE
	CAME SYM,SYMEND		; DONE ?
	JRST QUEST2		; NO, DO MORE WORK
	JRST LOOP		; YES, DO MORE REAL WORK

SYMDMP:	CALL TABTYP		;AND ADD A <HT>
	MOVE T1,(SYM)		;GET SYMBOL NAME
	CALL SIXTYP
	MOVEI T1,[ASCIZ \ = \]
	CALL TYPSTR
	TLNE SYM,SMF.RG		;IS THIS A REGISTER DEFINITION ?
	CALL PCNTYP		;TYPE A "%"
	HRRZ T1,1(SYM)		;GET VALUE OF SYMBOL
	CALL RADTYP		;TYPE VALUE IN CURRENT RADIX
	MOVEI T1,[ASCIZ \ spd\]
	TLNE SYM,SMF.SU		;IS SYMBOL SUPPRESSED ?
	CALL TYPSTR		;YES
	MOVEI T1,[ASCIZ \ opcode\]
	TLNE SYM,SMF.IN		;IS THIS AN OPCODE ?
	CALL TYPSTR		;YES
	SKIPN 3(SYM)		;WAS THERE A SOURCE ?
	JRST QUEST4		;NO
	TYPE < defined in >
	MOVE T1,3(SYM)		;GET SOURCE
	JRST SIXTYP

;HERE TO TRY TO FIND A PARTIAL MATCH FOR A SYMBOL
; CALL: SKIPN T1,SYMBOL	;WERE WE BUILDING A SYMBOL ?
;	JRST ILLCHR	;DON'T CALL MATCH
;	CALL MATCH
;	RETURN WITH SYM SETUP WITH PARTIAL MATCH
;		WITH (SYM) = 0 WHEN FOUND ALL MATCHES

MATCH:	CALL RSCAN
	MOVEM T2,CMDPTR		;DELETE THE "?" OR <CONTROL F>
	SKIPA T3,[770000,,0]	;BUILD MASK TO TEST UNDER
MATCH0:	ASH T3,-6		;ENLARGE THE MASK
	MOVE T1,T3		;COPY SUGGESTED MASK
	AND T1,SYMBOL
	CAME T1,SYMBOL		;IS MASK LARGE ENOUGH ?
	JRST MATCH0		;NO SO INCREASE SIZE
	MOVE SYM,SYMBEG		;POINT TO THE FIRST SYMBOL
MATCH2:	MOVE T1,(SYM)		;GET SYMBOL NAME
	AND T1,T3		;MASK OFF
	CAME T1,SYMBOL		;DOES THIS MATCH ?
	JRST MATCH4		;NO
	HLL	SYM,2(SYM)	;GET FLAGS FOR THE SYMBOL
	SKIPE PDP8F		;DOING PDP8 SYMBOLS ?
	TLC	SYM,SMF.P8
	TLNE SYM,SMF.P8
	JRST MATCH4
	HLL	SYM,2(SYM)	;SO SMF.P8 RIGHT
	CALL @(P)
MATCH4:	MOVEI SYM,4(SYM)
	CAME SYM,SYMEND		;HIT END ?
	JRST MATCH2
	SETZ SYM,		;FLAG ALL DONE
	RET ,MATCH



;HERE TO DO DEPOSIT MAYBE AFTER CR OR LF OR UP ARROW

STEFIN:	MOVE T1,[POINT 8,DATA]	;VIRGIN DATA POINTER
	SKIPE PDP8F		;WAS THIS A PDP8 LOOK ?
	HRLI T1,(POINT 12)
	CAMN T1,DAT		;DID USER TYPE ANYTHING ?
	RET ,STEFIN
	TXZE FLG,F.MOPN		;IS MASK OPEN ?
	JRST SETMSK		;SET MASK
	TXZN FLG,F.LOPN		;IS LOCATION OPEN ?
	RET ,STEFIN
	TXNN FLG,F.WENB		;WAS PATCHING ENABLED ?
	JRST WRTLCK		;IS WRITE LOCKED
	SKIPL T1,LSTIAD		;LAST ADDRESS GIVE BY USER
	MOVE T1,LSTADR
	MOVEM T1,LSTADR		;SAVE IT
	MOVEM T1,ESC.Q.		;ALSO USE FOR <ESCAPE>Q
	SETZM LSTIAD
	MOVE T1,DTFINP		;GET NEW DOTFOO
	MOVEM T1,DOTFOO		;AND SAVE IT
	SETZM DTFINP
	MOVEI T1,(DOT)		;WHERE TO PUT DATA
	TXNE DOT,DOT.AC		;IS THIS MEMORY OR REGISTER
	JRST STEFN5		;MUST BE MEMORY
	SETZM DOTFOO		;SO FIRST CALL WORKS
	MOVE T3,[POINT 8,DATA]	;POINTER TO DATA
STEFN3:	CALL NDTFOO		;GET NEXT DOTFOO
	SETZ T2,		;IN CASE ODD NUMBER OF BYTES
	ILDB T1,T3		;GET LOW ORDER BYTE
	CAME T3,DAT		;DONE ALL BYTES ?
	ILDB T2,T3		;GET HIGH ORDER BITS
	DPB T2,[POINT 8,T1,27]	;PUT HIGH ORDER WITH LOW ORDER
	HRRZ T2,DOTFOO		;GET ADDRESS
	CAIN T2,7		;IS THIS THE PC ?
	ANDI T1,177776		;BE SURE IS EVEN
	MOVEM T1,SIMREG(T2)	;STORE DATA
	CAME T3,DAT		;WAS THAT END OF DATA ?
	JRST STEFN3		;LOOP BACK FOR REST
	RET ,STEFIN

STEFN5:	CALL PUTBYT		;PUT DATA INTO 11
	NOP
	RET ,STEFIN

;HERE IF THERE IS AN ATTEMPT TO WRITE WITHOUT /PATCH

WRTLCK:	TYPE <?
?patching was not enabled by /PATCH
>
	JRST LEVEL0



;HERE TO SET MASK

SETMSK:	SETZ T4,		;INDEX FOR MASK
STMSK1:	ILDB T2,T1		;GET NEXT BYTE
	SETZ T3,		;IN CASE DONE
	CAME T1,DAT		;DONE EVERYTHING YET ?
	ILDB T3,T1
	DPB T3,[POINT 8,T2,27]
	HRROM T2,LSTADR		;SAVE IN CASE OF HT
	MOVEM T2,ESC.Q.		;SAVE IN CASE <ESCAPE>Q
	HRRM T2,S.MASK(T4)	;SET MASK
	CAME T1,DAT		;ALL DONE YET ?
	AOJA T4,STMSK1		;NOT YET - GO SET REST
	RET ,SETMSK



;HERE IF USER TYPES ESCAPE

ESCAPE:	CALL ACCUM		;IN CASE ANYTHING ALREADY IN PROGRESS
	RET ,ESCAPE
	HRRI STATE,STATSC	;SET ESCAPE FLAG
	SETZM ESCOCT		;INITIAL OCTAL ARGUMENT
	SETZM ESCDEC		;INITIAL DECIMAL ARGUMENT
	JRST LOOP

ESCESC:	TXO FLG,F..ESC
	JRST LOOP

;HERE TO ACCUMULATE NUMBER AFTER ESCAPE

ESC...:	TXO FLG,F.IDEC		;NUMBER IS DECIMAL
	MOVE T1,ESCDEC		;GET DECIMAL VERSION
	MOVEM T1,ESCOCT		;AND FORCE IT DECIMAL
	JRST LOOP
ESC..8:	TXO FLG,F.IDEC		;NUMBER IS DECIMAL
ESC..0:	MOVE T2,ESCOCT
	IMULI T2,^D8
	ADDI T2,-60(T1)		;ACCUMULATE NUMBER
	MOVEM T2,ESCOCT		;SAVE UPDATED NUMBER
	MOVE T2,ESCDEC
	IMULI T2,^D10
	ADDI T2,-60(T1)		;ACCUMULATE NUMBER
	MOVEM T2,ESCDEC		;SAVE UPDATED NUMBER
	TXNE FLG,F.IDEC		;WANT DECIMAL ARGUMENT ?
	MOVEM T2,ESCOCT		;YES SO FORCE IT
	JRST LOOP

;HERE WHEN USER TYPES "(" AFTER AN ESCAPE

ESCPAR:	SKIPE ESCOCT		;DID USER ALSO TYPE A # ?
	JRST ILLCHR		;YES CONFUSED
	PUSH P,EXPRES		;SAVE EXPRESSION SO FAR
	PUSH P,FLG		;SAVE THE FLAG BITS
	HRRI STATE,STATE0	;PLAIN EXPRESSION EVALUATION
	CALL GETEXP		;GET EXPRESSION
	JRST [	POP P,T1
		POP P,T1
		RET ,ESCPAR]
	HRRM T1,ESCOCT		;THAT WAS NUMERIC ARGUMENT
	POP P,T1		;GET THE OLD FLAGS
	TXNE T1,F..ESC		;DOUBLE ESCAPE?
	TXO FLG,F..ESC		;YES, RESET IT
	POP P,EXPRESS		;GET OLD EXPRESSION BACK
	LDB T1,CMDPTR		;GET BREAK CHARACTER
	CAIE T1,")"
	JRST ILLCHR
	HRRI STATE,STATSC
	TXZ FLG,F..SIM!F.GEXP!F.SYML!F.SYMB!F.TEXT!F.IOCT!F.IDEC!F.IHEX!F.SREG!F.FELE
	JRST GTEXP3		;FINISH PARTIAL EXPRESSION



;HERE WHEN A USER TYPES ESCAPE / OR [ OR <LF> OR <CR> OR ^

ESC.SL:
ESC.LF:
ESC.CR:
ESC.UP:	HRRI STATE,STATE0	;FIX DISPATCH TABLE POINTER
	TXO FLG,F..ESC		;REMEMBER WE SAW <ESCAPE>
	JRST LOOP1		;THEN EXIT GETEXP

;HERE TO EXCHANGE OLD DOT, DOTFOO, & DOTFLG

DOTSWP:	EXCH	DOT,DOTOLD	;EXCHANGE NEW AND OLD DOT
	MOVE T1,DOTFOO		;GET DOTFOO
	EXCH	T1,DTFOLD	;EXCHANGE WITH OLD ONE
	MOVEM T1,DOTFOO		;AND SET NEW DOTFOO
	RET ,DOTSWP

ESCP..:	JRST ESC..P		; PUNCH NEW BIN FILE

ESCD..:	JRST ESC..D		; DUMP TO DISK

ESCY..:	JRST ESC..Y		; READ IN A COMMAND FILE

;HERE FOR <ESCAPE>M - REFERS TO THE MASK

ESC..M:	TXO FLG,F.MASK		;MASK REFERENCED
	JRST ESCMD8		;FINISH COMMAND

;HERE FOR ESCAPE K - KILL THE SYMBOL

ESC..K:	JUMPE SYM,ILLCHR	;DID A SYMBOL PRECEDE $K ?
	CALL B3.TYP		;TYPE 3 SPACES
	MOVSI T1,SMF.SU		;FLAG TO SUPRESS OUTPUT
	IORM	T1,2(SYM)	;SUPRESS SYMBOL
	MOVE T1,(SYM)		;GET SYMBOL
	TXZE FLG,F..ESC		;DID HE WANT TO FLUSH SYMBOL ?
	CALL DELSYM		;YES SO FORGET IT
	JRST LEVEL2

ESC..R:	TXNN FLG,F.IDEC		;WAS ARGUEMNT DECIMAL
	SKIPA T1,ESCOCT		;NO SO USE OCTAL
	MOVE T1,ESCDEC
	CAIG	T1,^D16
	CAIG	T1,1		;IS RADIX REASONABLE ?
	JRST ILLCHR		;NO SO FLUSH REQUEST
	HRRM T1,ORADIX		;YES SET NEW RADIX
	TXZN FLG,F..ESC		;SETTING PERMANENT MODE ?
	JRST ESCMD8		;NOT PERMANENT MODE
	HRLM T1,ORADIX		;YES
	JRST ESCMD7		;EXIT



ESC..B:	SKIPA T1,[MODBYT]	;SET BYTE MODE
ESC..A:	MOVEI T1,MODADR		;SETTING ADDRESS MODE
	JRST ESCMOD

ESC..S:	SKIPA T1,[MODINS]	;SET INSTRUCTION MODE
ESC..C:	MOVEI T1,MODNUM		;SETTING NUMERIC MODE
	JRST ESCMOD

ESC..F:	MOVEI T1,MODR50		;SETTING RADIX50 MODE
	JRST ESCMOD

ESC..I:	SKIPA T1,[MODEBC]	;SETTING EBCDIC OUTPUT
ESC..T:	MOVEI T1,MODASC		;SETTING ASCII OUTPUT

ESCMD0:	MOVE T2,ESCOCT		;GET ARGUMENT
	SKIPN T2
	MOVEI T2,2		;DEFAULT IS 2 BYTES
	JRST ESCMD2

ESCMOD:	MOVE T2,ESCOCT		;GET ARGUMENT
	SKIPN T2
	MOVEI T2,1		;DEFAULT IS 1
ESCMD2:	HRRM T2,BYTCNT
	HRRM T1,O.MODE		;SET CURRENT MODE
	TXZ FLG,F.LBKT
	TXZN FLG,F..ESC
	JRST ESCMD8		;NOT PERMANENT
	HRLS	BYTCNT		;LOCAL COUNT IS PERMANT COUNT
	HRLM T1,O.MODE		;SET PERMANT MODE
ESCMD7:	CALL B3.TYP		;TYPE 3 SPACES
	JRST LEVEL2
ESCMD8:	HRRI STATE,STATE0	;RESTORE STATE POINTER
	JRST LOOP		;FINISH COMMAND

;HERE IF USER TYPES <ESCAPE>Q

ESC..Q:	MOVE T2,SYMPTR		;GET SYMBOL POINTER
	CAME T2,[POINT 6,SYMBOL] ;DID THIS HAPPEN AT A REASONABLE TIME ?
	JRST ILLCHR		;NO SO DING HIM
	TXO FLG,F.SYMB!F.GEXP	;GOT SOMETHING
	TXZ FLG,F.IDEC!F.IOCT!F.IHEX
	IBP SYMPTR		;SKIP FIRST CHAR
	MOVEI T1,'  Q'
	IDPB T1,SYMPTR		;PUT Q IN SYMBOL
	HRRI STATE,STATE0	;RESTORE STATE
	JRST LOOP		;AND PROCEDE



ESC..G:	SKIPN T1,EXPRESS	;GET ADDRESS HE TYPED
	MOVE T1,GOTO		;OLD VALUE FOR STARTING ADDRESS
	ANDI T1,177776		;ONLY 16 BITS PLEASE
	MOVEM T1,GOTO		;REMEMBER IT FOR LATER
	SKIPE MEMORY		;ARE DIDDLING DUMP OR BIN FILE ?
	JRST ESC.G1		;START THE SIMULATION
	SKIPN NODE.N		;ARE WE DOING STUFF WITH A NODE ?
	JRST ILLCHR		;NO SO THIS IS IMPOSSIBLE
	TXNN FLG,F.WENB		;WAS PATCHING ENABLED ?
	JRST WRTLCK		;CAN'T DO IT
	MOVE T1,EXPRESS		;GET ADDRESS HE TYPED
	CALL SETUPN		;SETUP NODE UUO
	EXP	3		;CODE FOR GOTO IS 3
	CALL NODSET		;GO DO NODE UUO
	JRST CALER0		;FAILED ?!
TABDNE:	CALL TABTYP
	JRST LEVEL2		;WE DID IT

ESC.G1:	TXNE FLG,F..ESC		;WAS THIS AN $$G ?
	JRST TABDNE		;THAT JUST SETS STARTING ADDRESS
	CALL SETUPC		;SETUP THE PC FOR EXECUTION
	TXO FLG,F.RUNF		;SET RUN FLOP
	MOVEI T1,[ASCIZ \
   beginning execution @pc = \]
	CALL TYPSTR
	MOVE T1,SIMREG+PC	;GET PC WE'LL START AT
	CALL ADRTYP
	CALL CRLTYP
	MOVE AC4,INSRUN
	SUB AC4,WAITIM
	CALL SIMXCT		;RUN THE SIMULATED MACHINE FOR A WHILE
	MOVEI T1,[ASCIZ \
   PDP-11 halted @pc = \]
	CALL TYPSTR
	MOVE T1,SIMREG+PC
	CALL ADRTYP
	TYPE < ps = >
	HRRZ T1,PS
	CALL OCTYPE
	TYPE <
	after >
	MOVE T1,INSRUN
	SUB T1,WAITIM
	SUB T1,AC4
	MOVE AC4,T1		;REMEMBER NUMBER OF INSTRUCTIONS EXECUTED
	CALL PDECTY		;TYPE AS DECIMAL WITH COMMAS
	TYPE < instructions.>
	CALL CRLTYP
	JRST LEVEL2



;ESCAPE V - WATCH A LOCATION FOR VARIANCE

ESC..V:	SKIPE MEMORY
	JRST ILLCHR
	TXNN FLG,F.LOPN		;IS LOCATION OPEN ?
	JRST ILLCHR		;GIVE USER "?"
	SETZM CACHE		;SWEEP THE CACHE
	TXO FLG,F.FLIP
ESC.V0:	MOVEI T1,0		;MINIMUM SLEEP
	SLEEP	T1,
	HRRZ T1,DOT		;GET ADDRESS TO WATCH
	HRRZ T2,BYTCNT		;NUMBER OF BYTES TO DISPLAY
	HRRZ T3,O.MODE		;OUTPUT MODE
	CAIG	T3,2
	ASH T2,1		;WORD MODE SO TIMES 2 BYTES
	TXZ FLG,F.CACH
	CALL GETWRD		;GET DATA
	JRST [CALL CALER0
		JRST LEVEL2 ]
	MOVE T2,T1		;COPY DATA
	XOR T2,DATA		;COMPARE TO LAST TIME
	AND T2,S.MASK		;MASK OFF IRREVELANT BITS
	TXZN FLG,F.FLIP
	JUMPE T2,ESC.V9		;BRANCH IF SAME AS BEFORE
	PUSH P,T1		;SAVE NEW DATA
	MOVEM T1,DATA		;SAVE NEW DATA
	CALL CRLTYP
	HRRZ T1,DOT		;GET ADDRESS
	CALL ADRTYP
	MOVEI T1,"/"
	TXNE FLG,F.LBKT
	MOVEI T1,"["
	CALL TYPCHR
	CALL COMLF4
	POP P,DATA		;IN CASE DATYPE CHANGED IT
ESC.V9:	SKPINC			;HAS USER TYPED A CHARACTER ?
	JRST ESC.V0		;NO SO KEEP WATCHING
	TYPE <
<done watching>
>
	JRST LEVEL2		;GO PROCESS NEXT COMMAND



;HERE BECAUSE TYPED $X - EXECUTE AN INSTRUCTION
; REGISTER USAGE
;	AC1 ON RETURN FROM SIMXCT WILL CONTAIN PC WE JUST EXECUTED
;	AC3 CONTAINS # FROM $#X
;	AC4 FOR $$X WILL BE SET UP WITH PC TO STOP ON

ESC..X:	SKIPN MEMORY		;DO WE HAVE A PROGRAM TO EXECUTE ?
	JRST ILLCHR		;NO SO DING HIM
	HRLZ	AC3,ESCOCT	;COPY REPETITION COUNT
	MOVNS	AC3		;MAKE AN AOBJN POINTER
	CALL SETUPC		;SETUP THE PC
	MOVE AC4,SIMREG+PC	;GET STARTING PC
	MOVE T1,AC4		;GET STARTING ADDRESS
	CALL CNINWD		;COUNT WORDS IN INSTRUCTION
	MOVEI T1,1		;CALL IT A ONE WORD INSTRUCTION
	ADD AC4,T1		;PLUS NUMBER OF WORDS
	ADD AC4,T1		;TWICE TO MAKE BYTE ADR
	TXZ FLG,F.RUNF!F.FLIP	;NOT REALLY RUNNING
	CALL CRLTYP		;ACKNOWLEDGE WE ARE DOING IT
	MOVE T1,[SIMREG,,BEGREG]
	BLT T1,BEGREG+7		;COPY INITIAL REGISTERS
	MOVEM PS,BEG.PS		;SAVE INITIAL PS
	SETZM CACHEL		;FLUSH CACHE
ESC.X1:	CALL SIMXCT		;EXECUTE THE NEXT INSTRUCTION
	SKIPE F.HALT		;DID THE -11 HALT?
	JRST ESCX73		;YES
	TXNN FLG,F..ESC		;DOING $$X ?
	JRST ESC.X7		;NO
	MOVE T1,SIMREG+PC	;GET CURRENT PC
	CAIL T1,(AC4)		;RETURN FROM SUBROUTINE ?
	CAILE T1,30(AC4)	;IN CASE OF ARGUMENT LIST
	CAIA
	JRST ESC.X9
	SKPINC			;OPERATOR IMPATIENT ?
	JRST ESC.X1		;DO ANOTHER INSTRUCTION
	JRST ESC.X9



;HERE AFTER DOING INSTRUCTION FOR $X

ESC.X7:	AOBJN	AC3,ESC.X1	;IF WANT MORE DO'EM
	CAMN PS,BEG.PS		;DID THE PS CHANGE ?
	JRST ESCX73
	TXO FLG,F.FLIP		;HAVE TYPED A REGISTER
	MOVEI T1,[ASCIZ \PS/   \]
	CALL TYPSTR
	HRRZ T1,PS
	CALL RADTYP
	CALL B3.TYP		;TYPE A FEW SPACES

;HERE TO DISPLAY REGISTERS WHICH CHANGED

ESCX73:	MOVSI AC4,-7
ESCX74:	MOVE T1,SIMREG(AC4)
	CAME T1,BEGREG(AC4)
	PUSHJ P,[TXO FLG,F.FLIP	;HAVE TYPED A REGISTER
		HRRZ DOT,AC4	;COPY REG ADR
		TXZ DOT,<DOT.FG-DOT.OK>	; CLEAR ALL THE FLAGS BUT OK
		JRST COMLF1 ]
	AOBJN	AC4,ESCX74
	CAME AC3,[1,,1]		;DID WE EXECUTE ONE INSTRUCTION
	JRST ESC.X8		;MORE THAN ONE SO DON'T TRY TO TYPE OPERANDS
	MOVE T1,AC1		;GET PC WE EXECUTED
	HRRO DOT,AC1		;CURRENT LOCATION
	SETZM DOTFOO
	MOVEI T2,2		;WANT TWO BYTES
	CALL GETWRD		;TRY TO GET THE INSTRUCTION
	JRST ESC.X8		;CAN'T GET = DONE
	AOS BEGREG+PC
	AOS BEGREG+PC
	MOVEM T1,DATA		;SAVE FOR FUTUTR REFERENCE
	CALL INVLFN		;TRY TO FIND SYMBOL
	JRST ESC.X8		;CAN'T FIND = DONE
	LDB T1,[POINT 6,DATA,29]
	HLL	SYM,2(SYM)	;GET FLAGS FOR INSTRUCTION
	TLNE SYM,SMF.SS
	PUSHJ P,[CAIE T1,27	;IMMEDIATE ?
		JRST ESC.X3	;PRINT DATA FOR FIRST OPERAND
		MOVEI T1,2
		ADDM T1,BEGREG+PC ;ADJUST OLD PC FOR THIS
		RET ,ESCX74+20	]
	LDB T1,[POINT 6,DATA,35]
	TLNE SYM,SMF.DD!SMF.SS
	CALL ESC.X3
ESC.X8:	TXZE FLG,F.FLIP		;DID WE TYPE ANY REGISTERS ?
	CALL CRLTYP		;YES SO FINISH OLD STUFF WITH A FLOURISH



;HERE WHEN $X OR $$X IS FINISHED TO TYPE NEXT INSTRUCTION

ESC.X9:	CALL B3.TYP
	HRRO DOT,SIMREG+PC	;SET UP DOT TO CALL DATYPE
	PUSH P,O.MODE		;SAVE OLD OUTPUT MODE
	PUSH P,BYTCNT		;SAVE OLD BYTE COUNT
	SETZM O.MODE		;SET INSTRUCTION MODE
	MOVEI T1,1
	HRRM T1,BYTCNT
	CALL COMLF1		;TYPE OUT INSTRUCTION
	POP P,BYTCNT
	POP P,O.MODE
	JRST LEVEL2



ESC.X3:	TRNN	T1,70		;IS THIS REGISTER MODE ?
	RET, ESC.X3
	LSHC T1,-3		;LEAVE ONLY MODE IN T1
	LSH T2,-^D33		;RIGHT JUSTIFY REG NUMBER
	HRR DOT,BEGREG(T2)
	CAIN T1,1		;WAS THIS REGISTER DEFERRED
	JRST ESCX35		;YES SO WE HAVE ADR NOW
	CAIG	T1,3		;IS THIS AUTO INCREMENT ?
	JRST [AOS BEGREG(T2)
		TLNE SYM,SMF.BY
		CAIL T2,6
		AOS BEGREG(T2)
		JRST ESCX33 ]
	CAIG	T1,5		;IS THIS AUTO DECREMENT ?
	JRST [SOS BEGREG(T2)
		TLNE SYM,SMF.BY
		CAIL T2,6
		SOS BEGREG(T2)
		HRR DOT,BEGREG(T2)
		JRST ESCX33]
	PUSH P,T1
	PUSH P,T2
	MOVE T1,BEGREG+PC
	MOVEI T2,2		;WANT TWO BYTES
	CALL GETWRD
	SETZ T1,
	HRRZ DOT,T1
	POP P,T2
	POP P,T1
	AOS BEGREG+PC
	AOS BEGREG+PC
	ADD DOT,BEGREG(T2)
ESCX33:	ANDI DOT,177777		;STRIP EXTRA BITS
	TRNN	T1,1		;IS THIS DEFERRED MODE ?
	JRST ESCX35
	MOVE T1,DOT		;COPY ADDRESS
	MOVEI T2,2
	CALL GETWRD
	RET ,ESC.X3
	HRRZ DOT,T1
ESCX35:	TXO FLG,F.FLIP		;REMEMBER WE TYPED DATA
	ANDI DOT,177777		;STRIP EXTRA BITS
	HRROS DOT		;FLAG IS MEMORY LOCATION
	PUSH P,DATA
	PUSH P,SYM		;SAVE POINTER TO SYMBOL FOR INSTRUCTION
	PUSH P,O.MODE		;SAVE OUTPUT MODE
	PUSH P,BYTCNT		;AND SAVE OUTPUT COUNT
	HRRZ T1,O.MODE		;GET OUTPUT MODE
	SKIPN T1
	MOVEI T1,1		;USE ADDRESS INSTEAD OF INSTRUCTION
	MOVEI T2,2		;ASSUME TWO BYTES OF OUTPUT
	CAIG	T1,2		;WORD MODE OUTPUT ?
	MOVEI T2,1		;ONLY ONE WORD
	TLNE SYM,SMF.BY		;BYTE MODE INSTRUCTION ?
	JRST [CAIG	T1,2	;ALREADY BYTE MODE OUTPUT ?
		MOVEI T1,3	;SET BYTE MODE OUTPUT
		MOVEI T2,1	;ONLY ONE BYTE OF OUTPUT
		JRST .+1 ]
	MOVEM T1,O.MODE		;SET NEW OUTPUT MODE
	HRRM T2,BYTCNT		;AND BYTE COUNT
	CALL COMLF2		;TYPE ADR AND DATA
	POP P,BYTCNT
	POP P,O.MODE
	POP P,SYM		;GET SYMBOL POINTER BACK
	POP P,DATA
	RET ,ESC.X3



;HERE FOR <$>N (OR <$>W) WHICH IS NOT (OR IS) WORD SEARCH

ESC..N:	TROA	FLG,F.FLIP	;FLAG WE ARE DOING NOT SEARCH
ESC..W:	TXZ FLG,F.FLIP		;FLAG WE WANT MATCHES
	MOVE T1,EXPRESS		;GET WHAT TO SEARCH FOR
	AND T1,S.MASK
	MOVEM T1,S.WORD
	MOVE DOT,SBEGIN
	SETZM CACHEL		;NOTHING IN CACHE SO FAR
	TXO FLG,F.CACH		;USE CACHE IF WE CAN
ESC.W2:	HRROS T1,DOT		;COPY ADR (FLAG MEMORY ADR)
	HRRZ T2,S..END
	ADDI T2,2
	SUB T2,T1		;NUMBER OF WORDS TO GET TO FINSIH SEARCH
	CAILE T2,EXMAX
	MOVEI T2,EXMAX		;MAXIMUM NUMBER OF WORDS FOR THIS REQUEST
	CALL GETWRD
	JRST ESCW.9
	MOVEM T1,DATA		;SAVE DATA
	AND T1,S.MASK		;MASK SOME OF THE BITS
	TXNE FLG,F.FLIP		;ARE WE LOOKING FOR MATCH ?
	JRST [	CAMN T1,S.WORD	;DON'T WANT MATCH
			JRST ESCW.8
			JRST ESCW.6 ]
	CAME T1,S.WORD
	JRST ESCW.8
ESCW.6:	CALL CRLTYP
	MOVE T1,DOT		;GET ADDRESS
	CALL ADRTYP
	TYPE </	>
	CALL DATYPE
	SKPINC			;ANY TYPEAHEAD ?
	JRST ESCW.8
	JRST ESCW.9		;YES SO STOP
ESCW.8:	CALL NXTDOT		;GET NEXT DOT
	HRRZ T1,DOT
	CAMLE	T1,S..END
	JRST ESCW.9
	TRNN	DOT,377		;DON'T DO TOO MANY UUO'S
	SKPINC			;TYPING AHEAD ?
	JRST ESC.W2		;NO
ESCW.9:	TYPE <
<search done>
>
	JRST LEVEL2



; Here to control that little $$[n]U command

ESC..U:	JRST LEVEL2		; SIMPLE, FOR NOW

;HERE TO MOVE MEMORY UP IN CORE
; CALL MOVEI T1,<AMOUNT TO MOVE IT UP>
;	CALL MOVEM

MOVMEM:	PUSH P,T1		;SAVE ARGUMENT
	CALL MOVSMT		;FIRST MOVE UP THE SYMBOL TABLE
	POP P,T1		;NUMBER OF WORDS TO MOVE
	SKIPN T2,MEMORY		;ADR OF 1ST WORD IN MEMORY
	RET ,MOVMEM
	ADDM T1,MEMORY		;UPDATE MEMORY POINTER
	MOVE T3,SYMBEG		;GET NEW SYMBOL TABLE POINTER
	SOS T3			;IS NEW LAST WORD IN MEMORY
	CALL MOVTAB		;MOVE IT
	JRST SIMREL		;ADJUST SIMULATION TO NOTICE NEW LOCATIONS

;HERE TO MOVE MEMORY USE TABLE UP IN CORE
; CALL MOVEI T1,<AMOUNT TO MOVE IT UP>
;	CALL MOVMUS

MOVMUS:	PUSH P,T1		;SAVE ARGUMENT
	CALL MOVSMT		;FIRST MOVE UP THE SYMBOL TABLE
	POP P,T1		;NUMBER OF WORDS TO MOVE
	HRRZ T2,MEMUSE		;ADR OF FIRST WORD IN MEMORY USE TABLE
	JUMPE T2,R		;IF NO MEMORY WE'RE DONE
	ADDM T1,MEMUSE		;UPDATE MEMORY USE TABLE ADR
	ADDM T1,MEMORY		;AND MEMORY POINTER
	MOVE T3,SYMBEG		;NEW SYMBOL TABLE ADR
	SOS T3			;MAKES NEW LAST WORD IN MEMORY
	CALL MOVTAB		;MOVE IT
	JRST SIMREL		;ADJUST SIMULATION TO NOTICE NEW ADDRESSES

;HERE TO MOVE A TABLE UP IN CORE (BACKWARDS BLT)
; CALL MOVE T1,<# OR WORDS TO MOVE)
;	MOVE T2,ADR OF 1ST WORD IN CORE TO BE MOVED
;	MOVE T3,<ADR OF NEW LAST WORD IN BLOCK>
;	CALL MOVTAB

MOVTAB:	MOVE T4,T3		;COPY ADR OF LAST WORD IN BLOCK
	SUB T3,T1		;MAKES LAST ADR IN OLD TABLE
MOVTB2:	MOVE T1,(T3)		;GET NEXT WORD TO COPY
	MOVEM T1,(T4)		;COPY IT
	SOS T4
	CAME T3,T2		;COPIED LAST WORD YET ?
	SOJA	T3,MOVTB2	;LOOP FOR MORE WORDS
	SETZM (T2)		;CLEAR FIRST WORD IN TABLE
	HRLI T2,(T2)		;BUILD BLT POINTER
	AOS T2			;FINISH BUILDING POINTER
	BLT T2,(T4)		;CLEAR OLD TABLE
	RET ,MOVTAB

SAVE4:	PUSH P,T1
	PUSH P,T2
	PUSH P,T3
	PUSH P,T4
	PUSHJ P,@-4(P)
	CAIA
	AOS -5(P)
	POP P,T4
	POP P,T3
	POP P,T2
	POP P,T1
	POP P,(P)
	POPJ P,

SAVE2:	EXCH	T2,(P)
	PUSHJ P,(T2)
	CAIA
	AOS -1(P)
	POP P,T2
	POPJ P,

SAVE24:	EXCH	T2,(P)
	PUSH P,T3
	PUSH P,T4
	PUSHJ P,(T2)
	CAIA
	AOS -3(P)
	POP P,T4
	POP P,T3
	POP P,T2
	POPJ P,

SAVE34:	EXCH	T3,(P)
	PUSH P,T4
	PUSHJ P,(T3)
	CAIA
	AOS -2(P)
	POP P,T4
	POP P,T3
	POPJ P,

SAVE35:	EXCH	T3,(P)
	PUSH P,T4
	PUSH P,T5
	PUSHJ P,(T3)
	CAIA
	AOS -3(P)
	POP P,T5
	POP P,T4
	POP P,T3
	POPJ P,



;CALL MOVE T1,<ERROR CODE>
;	MOVE T2,ERROR LIST
;	CALL CALERR

CALER0:	SETZ T2,
CALERR:	JUMPL T1,R		;EXIT IF WE ALREADY GAVE THE ERROR
	PUSH P,T1		;SAVE CODE
	JUMPN T2,CALER1		;ERROR LIST GIVEN ?
	SKIPE NODE.N		;WERE WE DOING /NODE STUFF ?
	MOVEI T2,NERLST		;NODE. ERROR
	SKIPE PORT		;WAS A /PORT GIVEN ?
	MOVEI T2,C11LST		;YES SO IS CALL11 ERROR CODE
CALER1:	PUSH P,T2		;SAVE LIST
	CALL QESTYP		;TYPE A QUESTION MARK
	HRRZ T1,(P)		;GET TYPE OF ERROR
	SKIPE T1
	PUSHJ P,[HRRZ T1,(T1)	;GET ERROR DESCRIPTION
		JRST TYPSTR]	;DISPLAY IT
	TYPE < error code = >
	MOVE T1,-1(P)		;GET OCTAL CODE
	CALL OCTYPE
	CALL BLANKT		;TYPE A SPACE
	POP P,T2		;GET ERROR LIST
	POP P,T1		;GET ERROR CODE
	JUMPLE	T1,CALER9
	JUMPE T2,CALER9
	HLRZ T3,(T2)		;GET MAX ERROR WE KNOW
	CAILE T1,(T3)		;IS IT IN RANGE ?
	JRST CALER9		;NOT IN RANGE SO CAN'T HELP FURTHER
	ADDI T1,(T2)
	MOVE T1,(T1)
	CALL TYPSTR
CALER9:	CALL QESTYP
	CALL TABTYP
	SETO T1,		;SAY WE PRINTED THE ERROR
	RET ,CALERR

;HERE FOR A LOCK ERROR
LOCKER:	MOVEI T2,LERLST		;DESCRIPTIONS FOR LOCK ERRORS
	CALL CALERR
	EXIT
	JRST LOCKER



GENERR:	XWD <C11LST-GENERR+1>,[ASCIZ \GENERAL\]

	Z [ASCIZ \NXM memory reference\]
	Z [ASCIZ \odd address memory reference\]
	Z [ASCIZ \DN60 not available\]


C11LST:	XWD <LERLST-C11LST+1>,[ASCIZ \CAL11\]

	Z [ASCIZ \not privileged\]
	Z [ASCIZ \unknown function\]
	Z [ASCIZ \not a DC76\]
	Z [ASCIZ \function already in use\]
	Z [ASCIZ \no answer to query\]
	Z [ASCIZ \queue entry too short\]
	Z [ASCIZ \not enough arguments\]


LERLST:	XWD <NERLST-LERLST+1>,[ASCIZ \LOCK\]

	Z [ASCIZ \not privileged\]
	Z [ASCIZ \other job too large\]
	Z [ASCIZ \maximum too large\]
	Z [ASCIZ \EVM exhausted\]
	Z [ASCIZ \illegal subfunction\]
	Z [ASCIZ \page unavailable\]


NERLST:	XWD <LSTLST-NERLST+1>,[ASCIZ \NODE.\]

	Z [ASCIZ \ill arg list\]
	Z [ASCIZ \ill node name or number\]
	Z [ASCIZ \not privileged job\]
	Z [ASCIZ \remote node control not available\]
	Z [ASCIZ \job not locked\]
	Z [ASCIZ \timeout\]


LSTLST:



;HERE BECAUSE USER FINISHED SYMBOL WITH ":"

DEFSYM:	TXNE FLG,F.SYMB
	SKIPN T1,SYMBOL		;SYMBOL HE DEFINED
	JRST ILLCHR
	SKIPE T2,LFTSAV		;WAS THIS X<TAG: ?
	JRST [		;ANDI T2,177777	;STRIP EXTRA BITS
		JRST DFSYM3 ]	;YES
	TXNN DOT,DOT.OK
	TXO DOT,DOT.FG
	HRRZ T2,DOT		;CURRENT ADR
	SETZB T3,T4		;NO FLAGS OR MISC
	TXNN DOT,DOT.AC
	TLO T3,SMF.RG
	LDB T1,[POINT 6,SYMBOL,5] ;GET FIRST CHAR IN SYMBOL
	CAIN T1,'  %'
	JRST [SKIPN CMDFIL	;DOING COMMAND FILE ?
		JRST ILLCHR	;NO SO THIS IS TRASH
		MOVE T2,CMDCNT	;VALUE IS CHAR IN FILE
		MOVSI T3,SMF.SU	;SUPPRESS VALUE
		JRST .+1 ]
DFSYM3:	MOVE T1,SYMBOL		;GET SYMBOL AGAIN
	MOVE T4,[SIXBIT /TYPEIN/] ;SAY THAT THE USER DEFINED IT
	CALL ADDSYM
	CALL TABTYP
	JRST LEVEL2

;HERE TO EVALUATE A SYMBOL
; CALL WITH SYMBOL SETUP
;	LOSE RETURN
;	WIN RETURN WITH SYM SETUP, VALUE IN T1, FLAGS IN T2
EVLSYM:	LDB T1,[POINT 6,SYMBOL,5] ;GET FIRST CHAR OF SYMBOL
	CAIN T1,'  %'
	RET ,EVLSYM
	MOVE T1,SYMBOL		;GET CURRENT SYMBOL
	CAMN T1,[SIXBIT \ Q\]	;CHECK FOR <ALT>Q
	JRST [HRRZ T1,ESC.Q.
		RET SKIP,EVLSYM]
	CAMN T1,[SIXBIT \.\]	;CHECK FOR SPECIAL CASE
	JRST [HRRZ T1,DOT
		MOVSI SYM,SMF.RG
		TXNN DOT,DOT.OK
		TXO DOT,DOT.FG
		TXNN DOT,DOT.AC
		TXO FLG,F.SYML
		RET SKIP,EVLSYM]
	TXO FLG,F.SYML		;ASSUME WE'LL LOAD SYM
	CALL SYMFND		;TRY TO FIND SYMBOL
	JRST SYMERR
	HRRZ T1,1(SYM)		;GET VALUE OF SYMBOL
	TLNE SYM,SMF.RG		;IS THIS A REGISTER NAME ?
	TXO FLG,F.SREG		;YES
	RET SKIP,EVLSYM

SYMERR:	MOVEI T1,[ASCIZ \U   \]
	JRST ILLCH0		;REST LIKE ILLEGAL CHARACTER



;HERE TO FIND A MATCH FOR A SYMBOL
; CALL MOVE T1,[SIXBIT \SYMBOL\]
;	CALL SYMFND
;	ERROR RETURN
;	SUCCESS RETURN	SYM POINTS TO SYMBOL

SYMFND:	SKIPN SYM,SYMBEG	;GET ADR OF BEGINNING OF SYMBOL TABLE
	RET ,SYMFND
SYMFN1:	CAMN SYM,SYMEND		;HIT END OF TABLE YET ?
	RET ,SYMFND
	CAMN T1,(SYM)		;IS THIS SYMBOL ?
	CALL SYMFN7		;CHECK PDP8/PDP11 RIGHT
	MOVEI SYM,4(SYM)	;POINT TO NEXT SYMBOL TABLE BLOCK
	JRST SYMFN1

;HERE TO SEE IF PDP8/PDP11 FLAG RIGHT FOR THIS SYMBOL
SYMFN7:	HLL	SYM,2(SYM)	;GET FLAGS FOR SYMBOL
	TLNN SYM,SMF.IN		;IS THIS AN INSTRUCTION ?
	JRST SYMFN9		;NO SO OK TO USE SYMBOL
	TLNE SYM,SMF.P8		;IS THIS A PDP8 SYMBOL ?
	JRST SYMFN8
	SKIPE PDP8F
	RET ,SYMFND
	JRST SYMFN9
SYMFN8:	SKIPN PDP8F
	RET ,SYMFND
SYMFN9:	MOVEM T1,(P)
	POP P,T1
	RET SKIP,SYMFND

RSKP:	RET SKIP,UNKNOW
R:	RET ,UNKNOW	

;HERE TO SEE IF WE CAN FIND A MATCH FOR AN INSTRUCTION
; CALL MOVEI T1,<VALUE>
;	CALL INVLFN
;	LOSE RETURN
;	WIN RETURN WITH SYM SET UP

INVLFN:	SKIPN SYM,SYMBEG	;ADDRESS OF FIRST SYMBOL BLOCK
	RET ,INVLFN
INVLF1:	MOVE T2,2(SYM)		;GET FLAGS & MASK
	TLNN T2,SMF.SU		;IS THIS SUPPRESSED >?
	TLNN T2,SMF.IN		;IS THIS AN INSTRUCTION ?
	JRST INVLF8
	ANDI T2,(T1)		;MASK ARGUMENT
	CAMN T2,1(SYM)		;IS THIS A MATCH ?
	CALL SYMFN7		;OK IF PDP8/PDP11 FLAG RIGHT
INVLF8:	MOVEI SYM,4(SYM)	;GET ADR OF NEXT SYMBOL BLOCK
	CAME SYM,SYMEND		;HIT END OF SYMBOLS ?
	JRST INVLF1		;NO SO SEE IF THIS ONE OK
	RET ,INVLFN



;HERE TO FIND A NAME FOR A REGISTER
; CALL:	MOVEI T1,#	;REGISTER NUMBER
;	CALL RGFNDN
;	LOSE
;	BINGO	(WITH SYM SETUP - OTHER REGS PRESERVED)

RGFNDN:	CALL SAVE24		;SAVE REGISTERS
	CALL VLFND0		;FIND A SYMBOL FOR VALUE
	CAIA
RGFND8:	MOVEI SYM,-4(SYM)	;MAKE ADDRESS OF PREVIOUS SYMBOL
	CAMN T1,1(SYM)		;RIGHT VALUE ?
	CAMGE SYM,SYMBEG	;BACKED UP TOO FAR ?
	RET ,RGFNDN
	HLL	SYM,2(SYM)	;GET FLAGS
	TLNN SYM,SMF.SU		;IS THIS A SUPPRESSED SYMBOL ?
	TLNN SYM,SMF.RG		;IS THIS A REGISTER ?
	JRST RGFND8		;NO GOOD
	RET SKIP,RGFNDN



;HERE TO ADD A SYMBOL TO TABLE
; CALL PUT SYMBOL IN T1, PUT VALUE IN T2, FLAGS IN T3, MISC IN T4
;	RETURNS WITH SYM POINTING TO NEW SYMBOL

ADDSYM:	PUSH P,T4		;SAVE MISC ON STACK
	SKIPE PDP8F		;IS THIS A PDP8 SYMBOL ?
	TLO T3,SMF.P8		;YES IS A PDP8
	PUSH P,T3		;SAVE FLAGS ON STACK
	PUSH P,T1		;SAVE SYMBOL ON STACK
	PUSH P,T2		;SAVE VALUE ON STACK
IFN DEBUG,<
	MOVE QX,F.DEBU		; GET THE DEBUG FLAG
	TRNN QX,DB.SYM		; IS THIS OPTION ENABLED ??
	JRST ADDSYX
	TYPE <%Adding symbol >
	MOVE T1,-1(P)		;GET THE NAME
	CALL SIXTYP		;TYPE SYMBOL NAME
	TYPE <.  Value is >
	MOVE T1,(P)
	CALL OCTYPE
	TLNN T3,SMF.SU		; SUPPRESSED?
	JRST ADDSYZ
	TYPE <, suppresed>
ADDSYZ:	TLNN T3,SMF.RG
	JRST ADDSYY
	TYPE <, register>
ADDSYY:	TYPE <, in module >
	MOVE T1,T4		;COPY OF MODULE NAME
	CALL SIXTYP
	CALL PERTYP
	CALL CRLTYP
	MOVE T2,(P)
	MOVE T1,-1(P)
	MOVE T3,-2(P)
	MOVE T4,-3(P)
ADDSYX:>
	CALL DELSYM		;FIRST DELETE ANY OLD VALUE
	CALL POSYMT		;POSITION SYMBOL TABLE AT END OF CORE
	MOVEI T1,4		;GET 4 WORDS FOR A SYMBOL BLOCK
	CALL GETCOR		;GET NEW CORE
	POP P,T1		;GET VALUE FOR SYMBOL
	CALL VLFND0		;FIND WHERE TO BULGE SYMBOL TABLE
	MOVEI T2,4
	ADDM T2,SYMEND		;AND POINTER TO END OF  SYMBOL TABLE
	CAML	T1,1(SYM)
	ADDI SYM,4
	MOVE T2,T1		;COPY SYMBOL VALUE
	POP P,T1		;GET SYMBOL
	POP P,T3		;GET FLAGS
	POP P,T4		;GET MISC
	PUSH P,SYM		;SAVE SYMBOL POINTER
ADSYM7:	EXCH	T1,(SYM)
	EXCH	T2,1(SYM)
	EXCH	T3,2(SYM)
	EXCH	T4,3(SYM)
	MOVEI SYM,4(SYM)	;POINT TO NEXT SYMBOL TABLE BLOCK
	CAME SYM,SYMEND		;HIT END OF TABLE YET ?
	JRST ADSYM7		;NO SO KEEP GOING
	POP P,SYM		;GET POINTER TO NEW SYMBOL
	RET ,ADDSYM



;HERE TO DELETE A SYMBOL FROM A SYMBOL TABEL
; CALL MOVE T1,[SIXBIT \SYMBOL\]
;	CALL DELSYM
;	RETURN

DELSYM:	CALL SYMFND		;TRY TO FIND SYMBOL IN CURRENT SYMBOL TABLE
	RET ,DELSYM
	HRLI T1,4(SYM)		;BUILD BLT POINTER
	HRR T1,SYM
	HRRZ T2,SYMEND		;END OF SYMBOL TABLE
	BLT T1,-4(T2)
	MOVNI	T1,4
	CAMN T2,.JBFF##		;SYMBOL TABLE AT END OF CORE ?
	ADDM T1,.JBFF##		;YES SO ADJUST END POINTER
	ADDM T1,SYMEND		;AND ADJUST POINTER TO END OF SYMBOL TABLE
	RET ,DELSYM


;HERE TO BE SURE SYMBOL TABLE IS LAST THING IN CORE AND MOVE IT IF NOT
; CALL:	CALL POSYMT

POSYMT:	MOVE T1,SYMEND
	CAMN T1,.JBFF##		;IS SYMBOL TABLE AT END OF CORE ?
	RET ,POSYMT
	PUSH P,.JBFF##		;SAVE OLD FREE CORE POINTER
	MOVE T1,SYMEND
	SUB T1,SYMBEG
	CALL GETCOR
	POP P,T1		;GET OLD FREE CORE POINTER
	HRL	T1,SYMBEG
	HRRZM T1,SYMBEG		;NEW BEGINNING OF SYMBOL TABLE
	HRRZ T2,.JBFF
	BLT T1,-1(T2)
	MOVEM T2,SYMEND		;NEW END OFF SYMBOL TABLE
	RET ,POSYMT

;HERE TO MOVE THE SYMBOL TABLE UP IN CORE
; CALL:	MOVEI T1,<AMOUNT TO MOVE IT UP>
;	CALL MOVSMT

MOVSMT:	CALL SAVE24		;SAVE REGISTERS
	PUSH P,T1		;SAVE ARGUMENT
	CALL GETCOR		;GET ADDITIONAL CORE
	POP P,T1		;GET NUMBER OF WORDS TO MOVE
	MOVE T2,SYMBEG		;FIRST WORD IN CURRENT SYMBOL TABLE
	ADDM T1,SYMBEG		;NEW SYMBOL TABLE ADR
	HRRZ T3,.JBFF##		;ADR OF NEW LAST WORD IN SYMBOL TABLE
	HRRM T3,SYMEND		;NEW END OF SYMBOL TABLE
	SOJA	T3,MOVTAB	;MAKE NEW LAST WORD IN SYMBOL TABLE
				; AND MOVE THE TABLE



;HERE TO FIND A NEAR MATCH FOR A VALUE
; CALL MOVEI T1,VALUE TO MATCH
;	CALL VALFND
;	ERROR RETURN	;WITH SYM CLEARED
;	RETURN WITH SYM SET UP

VALFND:	CALL VLFND0
	JRST VLFND4
VLFND3:	MOVEI SYM,-4(SYM)	;BACK UP SYMBOL POINTER
	CAMGE SYM,SYMBEG	;BACKED UP TOO FAR ?
	JRST VLFND7		;YES
VLFND4:	HLL	SYM,2(SYM)	;GET FLAGS FOR SYMBOL
	TLNE SYM,SMF.SU!SMF.IN!SMF.RG ;IS SYMBOL SUPPRESSED OR REG OR INSTRUCTION ?
	JRST VLFND3		;YES SO REJECT IT
	MOVE T2,1(SYM)		;GET SYMBOL VALUE
	CAIGE T1,400(T2)
	AOSA	(P)
VLFND7:	SETZM SYM
	RET ,VALFND

VLFND0:	MOVE SYM,SYMBEG		;POINT TO FIRST SYMBOL BLOCK
	MOVE T3,SYMEND
VLFND2:	MOVE T2,T3		;COPY HIGH LIMIT POINTER
	SUB T2,SYM		;MAKE DIFFERENCE BETWEEN HIGH AND LOW
	LSH T2,-1
	ANDI T2,777774
	JUMPE T2,R		;HAVE CARRIED THIS AS FAR AS WE CAN
	ADD T2,SYM
	CAMGE T1,1(T2)
	SKIPA T3,T2
	MOVE SYM,T2
	JRST VLFND2



;HERE TO GET MORE CORE
; CALL MOVEI T1,<#WORDS OF CORE WANTED>
;	CALL GETCOR

GETCOR:	HRRZS T1		;CLEAR LEFT HALF
	ADDB	T1,.JBFF##	;MAKE NEW END OF CORE
	HRRZS T1		;CLEAR LEFT HALF
	HRLM T1,.JBSA##		;IN CASE WE GET SAVED LATER
	TXNN FLG,F.EXEC		;RUNNING IN EXEC MODE
	CAMG T1,.JBREL##
	JRST GTCOR9
	TXNE FLG,F.LOCK
	JRST [	MOVEI T1,1	;CODE FOR LOW SEG
			UNLOK.	T1, ;CAN'T BE LOCKED WHEN WE DO THIS
			JRST LOCKER ;OLD MONITOR PERHAPS ?
			HRRZ T1,.JBFF##	;GET CORE ARG BACK
			CORE	T1,
			JRST CORERR ;CAN'T HAVE MORE ?
			MOVEI T1,1 ;CODE TO LOCK LOW SEG
			LOCK	T1,
			JRST LOCKER
			JRST GTCOR6 ]
	CORE	T1,
	JRST CORERR
GTCOR6:	DBGTYPE DB.MEM,<%Expanding memory to make room, new memory size is
>
	MOVEI T1,"["
	CALL TYPCHR
	HRRZ T1,.JBREL##
	AOS T1
	LSH T1,-^D9
	CALL DECTYP
	TYPE <p core]
>
GTCOR9:	RET ,GETCOR

;HERE IF CAN'T GET CORE WE WANT
CORERR:	TYPE <?
?CORE UUO failed, can't continue from here.
>
	EXIT
	JRST DDT11		; IF THEY TRY TO CONTINUE, ANYWAY



;HERE TO CHECK SWITCHES AND ASSURE NO CONFLICT
; T1= OUT SWITCHES
; T2= CONFLICTING SWITCHES
; WILL UPDATE SWTMSK, AND REMEMBER ALL THE ONES WE HAVE SEEN

SWTTST:	IORB T1,SWTMSK		; REMEMBER THIS SWITCH AS SEEN
	TDNE T2,SWTMSK		; IS THIS OK WITH WHAT WE HAVE SEEN?
	JRST [TYPE <?
? Switch conflict in command line.
>
		RET ,SWTTST]
	RET SKIP,SWTTST

;HERE FOR CORE ARGUMENT

SETCOR:	SWTCHK CORE
	DBGTYPE <DB.MEM!DB.INI>,<%Processing CORE switch
>
	CAIE T5,":"
	JRST [TYPE <?
?Core switch requires an argument
>
		RET ,SETCOR]
	CALL DECINP		;GET THE CORE SIZE
	JRST [TYPE <?
?Core switch requires an argument
>
		RET ,SETCOR]
	CAIE T5,"K"		;UPPERCASE K
	CAIN T5,"K"+40		;LOWERCASE K ?
	JRST [IMULI T1,2000	;CONVERT TO NUMBER OF WORDS
		MOVEI T5,40	;FAKE BREAK CHAR
		JRST .+1 ]
	HRRZM T1,CORARG
	MOVEI T1,EX.MEM
	MOVEM T1,ETYPE
	RET SKIP,SETCOR


;HERE TO EFFECT THE /CORE:#

STCOR1:	SKIPN PDP8F
	SKIPN T2,CORARG		;WAS THERE A CORE ARGUMENT ?
	 RET SAFE,STCOR1
	LSH T2,1		;CONVERT BYTES TO WORDS
	ADDI T2,017777		;ROUND TO NEXT 4K WORD BOUNDRY
	ANDI T2,160000		;MASK TO RIGHT SIZE
	SOS T2			;NEW MEMLIM IS ONE LESS
	MOVEM T2,CORARG
	SKIPN MEMORY		;ANY CORE ASSIGNED YET ?
	JRST STCOR2		;NONE YET SO GET IT
	CAMG T2,MEMLIM		;DO WE HAVE ENOUGH YET ?
	JRST STCOR3		;WE HAVE ENOUGH
STCOR2:	SETZ T1,
	CALL PUTFOO		;MAKE SURE WE HAVE THAT LOCATION
STCOR3:	MOVE T1,CORARG		;GET CORE ARGUMENT
	EXCH T1,MEMLIM		;WHICH IS NEW MEMLIM
	SUB T1,MEMLIM		;HOW MANY BYTES TO DELETE
	JUMPE T1,STCOR9		;IF NONE WER'E DONE
	LSH T1,-2		;NUMBER OF WORDS TO SHIFT SYMBOL TABLE
	HRL T2,SYMBEG		;GET BEGINING OF SYMBOL TABLE
	HRR T2,SYMBEG		;BUILD BLT POINTER
	SUB T2,T1
	HRRM T2,SYMBEG
	MOVE T3,SYMEND
	SUB T3,T1		;NEW END OF SYMBOL TABLE
	MOVEM T3,SYMEND
	BLT T2,(T3)
	HRRZM T3,.JBFF##
	HRLM T3,.JBSA##
STCOR9:	SETZM CORARG		;DONE WITH ARGUMENT
	RET SKIP,STCOR1



;HERE IF USER TYPES /GO

SETGO:	SWTCHK GO
	DBGTYPE DB.INI,<%Setting start address to LEVL.0 for /GO
>
	MOVE T1,[400000,,LEVL.0]
	MOVEM T1,LASTSW
	MOVEI T1,EX.MEM
	MOVEM T1,ETYPE
	RET SKIP,SETGO

IFN DEBUG,<			; HERE FOR /DEB	

CALLTY:	PUSH P,T1
	PUSH P,T2
	MOVEI T1,[ASCIZ \%Call to routine \]
	PUSHJ P,TYPSTR
	MOVE T1,-1(P)
	PUSHJ P,SIXTYP
	MOVEI T1,[ASCIZ \ (\]
	PUSHJ P,TYPSTR
	MOVE T1,(P)
	PUSHJ P,OCTYPE
	MOVEI T1,[ASCIZ \) from \]
	PUSHJ P,TYPSTR
	MOVEI T1,.+4
	PUSHJ P,OCTYPE
	PUSHJ P,CRLTYP
	ADJSP P,-2
	POPJ P,

RETTY1:	PUSH P,T2
	PUSH P,T1
	MOVEI T1,[ASCIZ \	%Returning for routine \]
	PUSHJ P,TYPSTR
	POP P,T1
	PUSHJ P,SIXTYP
	PUSHJ P,CRLTYP
	POP P,T2
	POPJ P,	
	
RETTY2:	PUSH P,T2
	PUSH P,T1
	MOVEI T1,[ASCIZ \	%Skip returning for routine \]
	PUSHJ P,TYPSTR
	POP P,T1
	PUSHJ P,SIXTYP
	PUSHJ P,CRLTYP
	POP P,T2
	POPJ P,	


SETDDT:	SWTCHK DEBUG
	MOVEI T1,DB.INI!DB.SYM!DB.MEM!DB.EXD
	MOVEM T1,F.DEBU
	CAIE T5,":"		; IS THERE AN ARGUMENT HERE?
	JRST SETDT1		; NO, THEN ALL IS OK...
	CALL SIXIN		; GET THE NUMBER TYPED
	JRST [	TYPE <%Illegal value for the /DEBUG switch, -1 assumed.
>
		JRST SETDT1	]
	CALL SIXOCT		; CONVERT THE NUMBER TO OCTAL, PLEASE
	JRST [	TYPE <%Illegal value for the /DEBUG switch, -1 assumed.
>
		JRST SETDT1	]
	MOVEM T1,F.DEBU		; SAVE THE FLAGS FOR LATER...
SETDT1:	MOVE QX,F.DEBU		; GET THE FLAGS
	TXNN QX,DB.INI
	RET SAFE,SETDDT
	TYPE <%Setting the DEBUG switch
>
	RET SKIP,SETDDT
>

;HERE FOR /PATCH

SETWEN:	SWTCHK PATCH
	DBGTYPE <DB.INI!DB.EXD>,<%Enabling writes to memory
>
	TXO FLG,F.WENB		;ENABLE PATCHING
	RET SKIP,SETWEN



;HERE BECAUSE USER TYPED /PDP11 OR /11

SETP11:	SWTCHK 11
	SWTCHK PDP11
	SETZM PDP8F		;CLEAR PDP8 FLAG
	MOVSI T1,(CPU.34)	; GET THE FLAG FOR AN 11/34
	MOVEM T1,FLAG11		; AND SAVE AWAY FOR THE SPOOKS
	MOVEI T1,CPN.34		; AND GET THE CPU CODE NUMBER
	MOVEM T1,TYPE11		; SAVE THE NEW MASK
	MOVE T1,[MA.34]		; GET THE MEMORY MASK
	MOVEM T1,MEMMSK		; AND SAVE THAT, TOO
	CAIE T5,":"		; IS THERE AN ARGUMENT?
	RET SAFE,SETP11
	CALL SIXIN		; GET THE VALUE TYPED...
	JRST [	TYPE <?
?Illegal argument for /PDP11 switch, PDP11/34 assumed
>
		RET SKIP,SETP11]
	CALL SIXOCT		; CONVERT IT TO OCTAL, PLEASE
	JRST [	TYPE <?
?Illegal argument for /PDP11 switch, PDP11/34 assumed
>
		RET SKIP,SETP11]
	MOVEI T2,TYP11T		; GET THE 11 TYPE TABLE
SETP13:	SKIPN T3,1(T2)		; IS THAT THE LAST ENTRY ?
	JRST [			; YES, COMPLAIN ABOUT THE LACK OF A MATCH
		TYPE <?
?Unknown cpu number for the /PDP11 switch, PDP11/34 assumed
>
		RET SKIP,SETP11]
	HRRZ T3,T3		; ONLY KEEP HALF THE WORD
	CAMN T1,T3		; THE SAME?
	JRST SETP14
	ADDI T2,2		; SKIP OVER THE MEMORY MASK
	AOJA T2,SETP13		; NO, LOOP AT THE NEXT WORD
SETP15:
IFN DEBUG,<
	MOVE QX,F.DEBU
	TXNN QX,DB.INI
	JRST SETP14
	TYPE <%Setting the PDP11 type to >
	HRRZ T1,1(T2)		; GET THE EXTERNAL TYPE
	CALL OCTYPE
	CALL CRLTYP
>
SETP14:	HLRZ T3,1(T2)		; GET THE INTERNAL CPU TYPE
	MOVEM T3,TYPE11		; AND SAVE THE NUMBER...
	MOVE T3,(T2)		; GET FLAG FOR CPU
	MOVEM T3,FLAG11		; AND SAVE AWAY
	MOVE T3,2(T2)		; GET MEMORY MASK
	MOVE T3,MEMMSK		; AND SAVE THAT, TOO
	RET SKIP,SETP11



; HERE IS THE TABLE OF CPU TYPES WE SUPPORT AT THIS TIME...

TYP11T:
ZZ==0
DEFINE X (A,B,C) <
	XLIST
CPU.'A==1B<ZZ>
CPN.'A==ZZ
MA.'A==<<1B<35-C>>-1>
	EXP	CPU.'A
	EXP	<CPN.'A,,B>
	EXP	MA.'A
ZZ==ZZ+1
	LIST
>

	CPUINF
	EXP 0,0,0		; END OF THE LIST FOR NOW, MUST BE 3 WORDS

;HERE BECAUSE USER TYPED /PDP8 OR /8

SETPD8:	SWTCHK 8
	SWTCHK PDP8
	DBGTYPE DB.INI,<%Setting cpu type to PDP8
>
	SETOM PDP8F
	MOVSI T1,(CPU.8)	; GET THE FLAG FOR AN EIGHT
	MOVEM T1,FLAG11		; AND SAVE AWAY FOR THE SPOOKS
	MOVEI T1,CPN.8		; AND GET THE CPU CODE NUMBER
	MOVEM T1,TYPE11		; SAVE THE NEW MASK
	MOVE T1,[MA.8]		; GET THE MEMORY MASK
	MOVEM T1,MEMMSK		; AND SAVE THAT, TOO
	RET SKIP,SETPD8


;HERE FOR A /LA36 IN COMMAND LINE

SETLA3:	SWTCHK LA36
	SETZM TTYBIT
	RET SKIP,SETLA3

;HERE FOR /LOCK

SETLOK:	SWTCHK LOCK
	DBGTYPE <DB.INI!DB.MEM>,<%Locking DDT11 in core.
>
	MOVE T1,OSTYPE
	TXNN T1,T.TOP10
	JRST [	TYPE <?
?Illegal /LOCK when not on TOPS-10
>
		RET ,SETLOK]
	MOVEI T1,LK.LLS!LK.LNE	;CODE TO LOCK
	LOCK T1,
	JRST LOCKER		;REPORT ERROR
	TXO FLG,F.LOCK		;REMEMBER WE DID
	RET SKIP,SETLOK


;HERE FOR A /VT52 IN COMMAND LINE

SETVTX:	SWTCHK VT52
	TXO T1,TF.RUB		;BIT TO GET RIGHT KIND OF RUBOUTS
	MOVEM T1,TTYBIT
	RET SKIP,SETVTX



;HERE FOR /HELP IN THE COMMAND LINE

SETHLP:	SWTCHK HELP
	SETZM LASTSW		;FLAG THAT THERE ARE NO ROUTINES TO EXECUTE
	MOVEI T1,HLPTXT
	CALL TYPSTR
	RET SKIP,SETHLP


HLPTXT:	ASCIZ	\
switches:

Switch		Use

/11
/PDP11[:n]	The dump or node is a PDP11 of type n
	n may be 2,3,4,5,10,15,20,23,231,24,34,35,40,44,45,55,60,70, or 74
/8
/PDP8		The dump or node is a PDP8
/BINARY		The dump is in the form produced by MACDLX.
/CORE:n		Expand "simulated" memory to size n (i.e. 28K)
/DTELDR		The dump is in the form produced by DTELDR or DNLOAD
/DUMP		The dump is in the form produced by NETLDR (default)
/FE:xy		Look at front end y on cpu x
/FESYMB		Load symbols from a RSX20F style map
/GO		Enter DDT mode
/HELP		This text
/LA36		Terminal is a LA36 (or other hard copy terminal)
/LINE:n		Use DDCMP maintaince mode over a line n
/LOCK		Lock ddt11 in core
/LSD		The dump is in the form produced by BOOT11
/MCB:node	Examine a running MCB node with node name "node"
/MCBDMP		Read a dump of an MCB
/MCBSYS		Read an unrun MCB system image
/MERGE		Merge more than one dump into DDT11's work space
/NODE:n		Examine node n, or /NODE:n/LINE:m
/PATCH		Enable patching of the dump or node being examined
/PORT:n		Used to indicate a DN6x front end or any front end
		connected to a DL10
/RELOCA:sym	Relocate symbols read in by the value sym
/STB		Read an STB format symbol table
/SYMBOL[:n]	Read a listing produced by MACDLX and extract symbols
		Where n is the (optional) 128 word disk block to start
		reading from.
/UBA:n		Use UBA n for the -11 I/O page
/VT52		The terminal does a backspace
\



;HERE TO READ A SAVED SYMBOL TABLE

SETLOD:	SWTCHK LOAD
	TYPE <?
?The /LOAD switch is not yet implemented
>
	RET ,SETLOD

;HERE TO WRITE A SYMBOL TABLE

SETSAV:	SWTCHK SAVE
	TYPE <?
?The /SAVE switch is not yet implemented
>
	RET ,SETSAV

;HERE TO SET THE MODULE NAME FOR ADDING SYMBOLD TO THE SYMBOL TABLE

SETMOD:	SWTCHK MODULE
	TYPE <?
?The /MODULE switch is not yet implemented
>
	RET ,SETMOD



;INITIAL STATE TABLE

STATE0:
BYTE (18)LOOP  ,ILLCHR,ILLCHR,DDT11 ,ILLCHR,ILLCHR,CNTRLF,ILLCHR ;7
BYTE (18)ACCUM ,ACCUM ,ACCUM ,ILLCHR,ILLCHR,ACCUM ,ILLCHR,ILLCHR ;17
BYTE (18)ILLCHR,ILLCHR,CNTRLR,ILLCHR,ILLCHR,CNTRLU,ILLCHR,CNTRLW ;27
BYTE (18)EXPXOR,ILLCHR,CNTRLZ,ESCAPE,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;37
BYTE (18)EXPSPC,EXPIOR,ACCUM ,ACCUM ,ASSYMB,ASSPRC,EXPAND,EXPDIV ;47
BYTE (18)ACCUM ,ACCUM ,EXPMUL,EXPLUS,ACCUM ,EXPMIN,ASSPER,ACCUM	;57
BYTE (18)ASSNUM,ASSNUM,ASSNUM,ASSNUM,ASSNUM,ASSNUM,ASSNUM,ASSNUM ;67
BYTE (18)ASSDEC,ASSDEC,DEFSYM,ACCUM ,LFTANG,ACCUM ,ACCUM ,QUEST. ;77
BYTE (18)ACCUM ,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB ;107
BYTE (18)ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB ;117
BYTE (18)ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB ;127
BYTE (18)ASSYMB,ASSYMB,ASSYMB,ACCUM ,ACCUM ,ILLCHR,ACCUM ,ACCUM	;137
BYTE (18)ILLCHR,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB ;147
BYTE (18)ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB ;157
BYTE (18)ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB,ASSYMB ;167
BYTE (18)ASSYMB,ASSYMB,ASSYMB,ILLCHR,ILLCHR,ILLCHR,ILLCHR,COMRUB ;177

;STATE TABLE WHEN USER TYPES ALTMODE

STATSC:
BYTE (18)LOOP  ,ILLCHR,ILLCHR,DDT11 ,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;7
BYTE (18)ESC.UP,ILLCHR,ESC.LF,ILLCHR,ILLCHR,ESC.CR,ILLCHR,ILLCHR ;17
BYTE (18)ILLCHR,ILLCHR,CNTRLR,ILLCHR,ILLCHR,CNTRLU,ILLCHR,CNTRLW ;27
BYTE (18)ILLCHR,ILLCHR,CNTRLZ,ESCESC,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;37
BYTE (18)ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;47
BYTE (18)ESCPAR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ESC...,ESC.SL ;57
BYTE (18)ESC..0,ESC..0,ESC..0,ESC..0,ESC..0,ESC..0,ESC..0,ESC..0 ;67
BYTE (18)ESC..8,ESC..8,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;77
BYTE (18)ILLCHR,ESC..A,ESC..B,ESC..C,ESCD..,ILLCHR,ESC..F,ESC..G ;107
BYTE (18)ILLCHR,ESC..I,ILLCHR,ESC..K,ILLCHR,ESC..M,ESC..N,ILLCHR ;117
BYTE (18)ESCP..,ESC..Q,ESC..R,ESC..S,ESC..T,ESC..U,ESC..V,ESC..W ;127
BYTE (18)ESC..X,ESCY..,ILLCHR,ESC.SL,ILLCHR,ILLCHR,ESC.UP,ILLCHR ;137
BYTE (18)ILLCHR,ESC..A,ESC..B,ESC..C,ESCD..,ILLCHR,ESC..F,ESC..G ;147
BYTE (18)ILLCHR,ESC..I,ILLCHR,ESC..K,ILLCHR,ESC..M,ESC..N,ILLCHR ;157
BYTE (18)ESCP..,ESC..Q,ESC..R,ESC..S,ESC..T,ESC..U,ESC..V,ESC..W ;167
BYTE (18)ESC..X,ESCY..,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,COMRUB ;177



;STATE TABLE TO END AN EXPRESSION

STATEB:
BYTE (18)ILLCHR,ILLCHR,ILLCHR,DDT11 ,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;7
BYTE (18)UARROW,COM.HT,COM.LF,ILLCHR,ILLCHR,COM.CR,ILLCHR,ILLCHR ;17
BYTE (18)ILLCHR,ILLCHR,CNTRLR,ILLCHR,ILLCHR,CNTRLU,ILLCHR,CNTRLW ;27
BYTE (18)ILLCHR,ILLCHR,CNTRLZ,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;37
BYTE (18)ILLCHR,ILLCHR,QUOTE ,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;47
BYTE (18)ILLCHR,ILLCHR,ILLCHR,ILLCHR,LEVEL3,ILLCHR,ILLCHR,OPNLOC ;57
BYTE (18)ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;67
BYTE (18)ILLCHR,ILLCHR,ILLCHR,SEMICL,ILLCHR,EQUALS,SUPLIM,ILLCHR ;77
BYTE (18)ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;107
BYTE (18)ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;117
BYTE (18)ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;127
BYTE (18)ILLCHR,ILLCHR,ILLCHR,OPLBKT,BKSLSH,ILLCHR,UARROW,BARROW ;137
BYTE (18)ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;147
BYTE (18)ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;157
BYTE (18)ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR ;167
BYTE (18)ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,ILLCHR,COMRUB ;177

; STATE TABLE BUILT TO BE USED FOR TYPING QUOTED TEXT

STATEQ:	BLOCK 100



DEFINE	NAMES <
	XLIST
	X	11,SETP11	;/11
	X	8,SETPD8	;/8
	X	BINARY,SETBIN	;/BINARY PRODUCED BY MACDLX
	X	CORE,SETCOR	;/CORE:28K
IFN DEBUG,< X	DEBUG,SETDDT	;/DEBUG HELP MESSAGE TURN ON>
	X	DTELDR,SETFOO	;/DTELDR PRODUCED BY DTELDR
	X	DUMP,SETDMP	;/DUMP PRODUCED BY NETLDR
	X 	FE,SET.FE	;/FE:XY
	X	FESYMB,SETFES	;/FESYMBOLS TYPE SYMBOL TABLE
	X	GO,SETGO	;/GO RIGHT NOW
	X	HELP,SETHLP	;/HELP ME, PLEASE
	X	LA36,SETLA3	;/LA36
	X	LINE,SETLIN	;/LINE:N
	X	LOAD,SETLOD	;/LOAD SYMBOL TABLE
	X	LOCK,SETLOK	;/LOCK IN CORE
	X	LSD,SETDMP	;/LSD PRODUCED BY BOOT11
	X	MCB,SETDFE	;/MCB:node
	X	MCBDMP,SETMCB	;/MCBDMP PRODUCED BY DECNET NETWORK MANAGEMENT
	X	MCBSYS,SETMCS	;/MCBSYS TO READ AN UNRUN MCB SYSTEM IMAGE
	X	MERGE,SETMRG	;/MERGE THIS ON TOP OF OLD DUMP
	X	MODULE,SETMOD	;/MODULE:NAME TO SET ENTRIES IN SYMBOL TABLE
	X	NODE,SETNOD	;/NODE:N
	X	PATCH,SETWEN	;/PATCH IS ALLOWED
	X	PDP11,SETP11	;/PDP11
	X	PDP8,SETPD8	;/PDP8
	X	PORT,SETPRT	;/PORT:X OF THE DL10
	X	RELOCA,SETREL	;/RELOCATION OF SYMBOLS (GLOBAL AND LOCAL)
	X	SAVE,SETSAV	;/SAVE SYMBOLS
	X	STB,SETRST	;/STB PRODUCED BY MACY11 OR VNP20
	X	SYMBOL,SETSYM	;/SYMBOL TO BE READ
	X	UBA,SETUBA	;/UBA - SET UNIBUS TO USE
	X	VT52,SETVTX	;/VT52
	LIST
>

DEFINE	X (A,B) <	SIXBIT	\A\
	Z'A==:XX
	XX==XX+XX
>



XX==1
SW.LST:	NAMES
	Z



DEFINE	X (A,B) <	0,,B >

SW.DSP:	NAMES



SWTCON (<PDP11,11>,<PDP8,8>)

SWTCON (<PDP8,8>,<PDP11,11,BINARY,DTELDR,FE,FESYMB,HELP,LSD,MCB,MCBDMP,MCBSYS,PORT,RELOC,STB,UBA>)

SWTCON (<BINARY>,<PDP8,8,DTELDR,DUMP,FE,FESYMB,GO,HELP,LINE,LOAD,LOCK,LSD,MCB,MCBDMP,MCBSYS,MODULE,NODE,PORT,RELOCA,SAVE,STB,SYMBOL,UBA>)

SWTCON (<CORE>,<FE,FESYMB,HELP,LINE,LOAD,LOCK,MCB,MODULE,NODE,PORT,RELOCA,SAVE,STB,SYMBOL,UBA>)

SWTCON (<DEBUG>,<>)

SWTCON (<DTELDR>,<PDP8,8,BINARY,DUMP,FE,FESYMB,GO,HELP,LINE,LOAD,LOCK,LSD,MCB,MCBSYS,MCBDMP,MODULE,NODE,PORT,RELOCA,SAVE,STB,SYMBOL,UBA>)

SWTCON (<DUMP>,<BINARY,DTELDR,FE,FESYMB,GO,HELP,LINE,LOAD,LOCK,MCB,MCBSYS,MCBDMP,MODULE,NODE,PORT,RELOCA,SAVE,STB,SYMBOL,UBA>)

SWTCON (<FE>,<PDP8,8,BINARY,DTELDR,DUMP,FESYMB,GO,HELP,LINE,LOAD,LOCK,LSD,MCB,MCBSYS,MCBDMP,MERGE,MODULE,NODE,PORT,RELOCA,SAVE,STB,SYMBOL,UBA>)

SWTCON (<FESYMB>,<PDP8,8,BINARY,CORE,DTELDR,DUMP,FE,GO,HELP,LINE,LOAD,LOCK,LSD,MCB,MCBDMP,MCBSYS,MERGE,NODE,PATCH,PORT,SAVE,STB,SYMBOL,UBA>)

SWTCON (<GO>,<BINARY,DTELDR,DUMP,FE,HELP,LINE,LOAD,LOCK,LSD,MCB,MCBSYS,MCBDMP,MERGE,MODULE,NODE,PORT,RELOCA,SAVE,STB,UBA>)

SWTCON (<HELP>,<11,PDP11,PDP8,8,BINARY,CORE,DTELDR,DUMP,FE,FESYMB,GO,LINE,LOAD,LOCK,LSD,MCB,MCBDMP,MCBSYS,MERGE,MODULE,NODE,PATCH,PDP11,PDP8,PORT,RELOCA,SAVE,STB,SYMBOL,UBA>)

SWTCON (<LA36>,<VT52>)

SWTCON (<LINE>,<BINARY,CORE,DTELDR,DUMP,FE,FESYMB,GO,HELP,LOAD,LSD,MCB,MCBDMP,MCBSYS,MERGE,MODULE,PORT,RELOCA,SAVE,STB,SYMBOL,UBA>)

SWTCON (<LOAD>,<>)

SWTCON (<LOCK>,<BINARY,DTELDR,DUMP,FESYMB,GO,HELP,LOAD,LSD,MCBDMP,MCBSYS,MERGE,MODULE,RELOCA,SAVE,STB,SYMBOL>)

SWTCON (<LSD>,<PDP8,8,BINARY,DTELDR,FE,FESYMB,GO,HELP,LINE,LOAD,LOCK,MCB,MCBSYS,MCBDMP,MODULE,NODE,PORT,RELOCA,SAVE,STB,SYMBOL,UBA>)

SWTCON (<MCB>,<PDP8,8,BINARY,DTELDR,DUMP,FE,FESYMB,GO,HELP,LINE,LOAD,LSD,MCBSYS,MCBDMP,MERGE,MODULE,NODE,PORT,RELOCA,SAVE,STB,SYMBOL,UBA>)

SWTCON (<MCBDMP>,<PDP8,8,BINARY,DTELDR,DUMP,FE,FESYMB,GO,HELP,LINE,LOAD,LOCK,LSD,MCB,MCBSYS,MODULE,NODE,PORT,RELOCA,SAVE,STB,SYMBOL,UBA>)

SWTCON (<MCBSYS>,<PDP8,8,BINARY,DTELDR,DUMP,FE,FESYMB,GO,HELP,LINE,LOAD,LOCK,LSD,MCB,MCBDMP,MODULE,NODE,PORT,RELOCA,SAVE,STB,SYMBOL,UBA>)

SWTCON (<MERGE>,<FE,FESYMB,GO,HELP,LINE,LOCK,MCB,MCBDMP,MCBSYS,MODULE,NODE,PORT,RELOCA,SAVE,STB,SYMBOL,UBA>)

SWTCON (<MODULE>,<11,8,BINARY,CORE,DTELDR,DUMP,FE,FESYMB,GO,HELP,LINE,LOAD,LOCK,LSD,MCB,MCBSYS,MCBDMP,MERGE,NODE,PATCH,PDP11,PDP8,PORT,SAVE,SYMBOL,UBA>)

SWTCON (<NODE>,<BINARY,DTELDR,DUMP,FE,FESYMB,GO,HELP,LOAD,LSD,MCB,MCBSYS,MCBDMP,MERGE,MODULE,PORT,RELOCA,SAVE,STB,SYMBOL,UBA>)

SWTCON (<PATCH>,<FESYMB,HELP,LOAD,SAVE,STB,SYMBOL>)

SWTCON (<PORT>,<PDP8,8,BINARY,CORE,DTELDR,DUMP,FE,FESYM,GO,HELP,LINE,MCB,MCBDMP,MCBSYS,MERGE,NODE,RELOCA,STB,SYMBOL,UBA,LOAD,SAVE>)

SWTCON (<RELOCA>,<>)

SWTCON (<SAVE>,<>)

SWTCON (<STB>,<>)

SWTCON (<SYMBOL>,<11,8,BINARY,CORE,DTELDR,DUMP,FE,FESYMB,GO,HELP,LINE,LOCK,LOAD,LSD,MCB,MCBDMP,MCBSYS,MERGE,NODE,PATCH,PDP11,PDP8,PORT,RELOCA,SAVE,STB,UBA>)

SWTCON (<UBA>,<8,PDP8,BINARY,DTELDR,DUMP,FE,FESYMB,HELP,LINE,LOCK,LOAD,LSD,MCB,MCBDMP,MCBSYS,MERGE,MODULE,NODE,PORT,RELOCA,SAVE,STB,SYMBOL>)

SWTCON (<VT52>,<LA36>)



DEFINE	NAMES <
	XLIST
	X	DEF,%IFDEF
	X	DF,%IFDEF
	X	E,%IF.EQ
	X	EQ,%IF.EQ
	X	ERR,%IFERR
	X	G,%IF.GT
	X	GE,%IF.GE
	X	GT,%IF.GT
	X	N,%IF.NE
	X	NDF,%IFNDF
	X	NE,%IF.NE
	X	L,%IF.LT
	X	LE,%IF.LE
	X	LT,%IF.LT
	LIST
>

DEFINE	X (A,B),< SIXBIT \A\ >
%IFLST:	NAMES
	Z

DEFINE	X (A,B),< EXP B >
%IFDSP:	NAMES



TYPE11:	Z			; THE TYPE OF THE -11 WE ARE WORKING ON
FLAG11:	Z			; A FLAG BIT FOR THE CPU TYPE
MASK11:
MEMMSK:	Z			; THE MASK TO USE WHEN ANDING AN ADDRESS
PDP8F:	Z			; NONZERO IF WE DOING PDP8 STYLE

LASTSW:	Z			; ROUTINE TO EXECUTE AFTER PARSING OTHER SWITCHES
F.DEBU:	Z			; SWITCH TO FLAG EXTRA OUTPUT FOR THE DEBUGGER
F.MSYS:	Z			; SWITCH TO FLAG THAT THIS IS AN MCB SYSTEM...
F.DMCB: Z			; SWITCH TO FLAG WRITING AN MCB SYSTEM IMAGE IN $P
F.MCBD:	Z			; SWITCH TO FLAG DUMPING A MCB OR DTE DUMP TO DISK
F.MCB:	Z			; THE PROGRAM IS LOOKING AT A MCB OF SOME SORT
F.HALT:	Z			; THE SIMULATOR DID A HALT...
IFBYTE:	Z			; BYTE TO FLAG IF THE IF IS BYTE MODE OR NOT
DAT:	Z			; POINTER TO DATA AREA
TYPDAT:	Z			; VALUE OF THE LAST TYPE OF DATA WE ARE
				; POINTING TO WITH "DAT"
DOTFOO:	Z			; IN CASE 32 OR 48 BIT INSTRUCTION
				; LH = -1 MEANS MEMORY ADR
				; LH = 400000 + BITS 12-17 ARE MODE
DTFINP:	Z			; DOTFOO WHILE TYPEING IN STUFF
DOTOLD:	Z			; OLD VALUE FOR DOT IN CASE OF ESCAPE CR ETC.
DTFOLD:	Z			; KEEP DOTFOO HERE
EXPRES:	Z			; BUILD EXPRESSIONS HERE
LSTADR:	-1,,Z			;LAST ADDRESS DISPLAYED
LSTIAD:	Z			;LAST ADDRESS INPUT

REMAIN:	Z			; REMAINDER FROM LAST DIVISION
LFTSAV:	Z			; IF LH NONZERO RH PRECEDED <
GOTO:	EXP	2		; STARTING ADDRESS FOR PROGRAM, EVEN, SO 11'S WORK
CORARG:	Z			; CORE SIZE USER REQUESTED
SYMPTR:	Z			; BYTE POINTER TO FILL SYMBOL
SYMBOL:	Z			; CURRENT SYMBOL WE ARE BUILDING
DATA:	BLOCK	^D20
SBEGIN:	XWD	-1,0		; FIRST ADDRESS FOR SEARCH
S..END:	EXP	0		; LAST ADDRESS FOR SEACRH
S.WORD:	EXP	0		; WORD TO SEARCH FOR
S.MASK:	EXP	177777		; MASK FOR WORD SEARCH
REPEAT	MASKSZ,<EXP 0>		; MASK FOR WORD SEARCH
INPOPR:	EXP	0		; INPUT OPERATION (0=+,1=-,2=*,3=',4=!,5=&,6=^X)
PRECED:	EXP	0		; PRECEDENCE OF INPOPR = 0
	EXP	0
	EXP	1
	EXP	1
	EXP	2
	EXP	2
	EXP	2



BYTCNT:	XWD	1,1		; REPETITION COUNTS FOR OUPUT BYTES ETC.
O.MODE:	EXP	0		;OUTPUT MODE LH = PERMANENT, RH = CURRENT
				; (0=SYMBOLIC, 1=ADDRESS, 2=NUMERIC, 3=BYTES,
				;  4=ASCII TEXT, 5=EBCDIC TEXT, 6=RADIX50)
ORADIX:	^D8,,^D8		;OUTPUT RADIX
				; LH IS PERMANENT SETTING, RH IS CURRENT
ESCSAV:	BLOCK	3		;SAVE BYTCNT ETC HERE IN CASE OF RUBOUT ETC.
ESC.Q.:	Z			;USED IF GET AN <ALT>Q
ESCOCT:	Z			;USED TO ACCUMULATE OCTAL NUMBER FOR ESCAPE ARG
ESCDEC:	Z			;USED TO ACCUMULATE DECIMAL NUMBER FOR ESCAPE ARG

;KEEP A COPY OF CURRENT COMMAND HERE TO RETYPE IT OR RUBOUT CHARS
CMDTKR:	Z			;USE TO REPROCESS LINE
CMDLIM:	Z			;LIMIT TO RESCAN
CMDPTR:	Z			;UES TO FILL COMMAND LINE

CMDLIN:	BLOCK	<CMDSIZ+4>/5
TTYBIT:	EXP	TF.RUB		;FLAGS TO DEFINE TYPE OF TERMINAL
FLGSAV:	EXP	0		;SAVE FLAG REGISTER HERE IN CASE OF REENTER
CMDCON:	EXP	0		;COMMAND CONFLICT LOCATION
OSTYPE:	Z			;THE FLAG FOR THE TYPE OF OS WE ARE RUNNING
XMSG:	BLOCK	^O274/4+1	; DDCMP Q flush buffer
RETRY:	BLOCK	1		; BOOT retry counter



;PDP11 WORDS ARE STORED IN PDP10 MEMORY AS FOLLOWS

;                      1             1 1 1 2             2 2             3
;  0 1 2             9 0             7 8 9 0             7 8             5
; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
; ! ! !    byte 1     !    byte 0     ! ! !    byte 3     !    byte 2     !
; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

;THE SPARE BITS ARE USED AS A FLAG TO SAY BYTE HAS BEEN USED
; I.E. BYTE WAS READ INTO FROM DUMP OR BINARY FILE OR WRITTEN BY USER
; E.G. IF BYTE 0 IS SET THEN BIT 1 IS SET AS A FLAG

MEMORY:	EXP	0		;ADDRESS OF DUMP MEMORY
MEMLIM:	EXP	-1		;HIGHEST LOCATION IN DUMP
				; BIT ON IFF BYTE READ OR DEPOSITED
MEMUSE:	EXP	0		;T1,,POINTER TO MEMORY USE TABLE
				; FOR EACH BYTE IN SIMULATED MEMORY, BIT WILL
				; BE SET IF BYTE SET BY LOAD OR USER
SWTMSK:	EXP	0		; A CONFLICT MASK FOR SWITCHES
BEGREG:	EXP	0		;R0
	EXP	0		;R1
	EXP	0		;R2
	EXP	0		;R3
	EXP	0		;R4
	EXP	0		;R5
	EXP	0		;R6
	EXP	0		;R7
BEG.PS:	EXP	0		;BEGINNING PS

	IFNDEF	PDLEN,<PDLEN==300>

PDL:	BLOCK	PDLEN
	IFNDEF	PATLEN,<PATLEN==100>

PAT..:
PATCH:	BLOCK	PATLEN
	XLIST
	LIT
	VAR
	LIST

DEFINE	X (VAL,MASK,NAME,FLAG) <
IFL	<VAL-Q>,<PRINTX	SYMBOL TABLE MESSED UP
QVAL=	Q
>
IFN	<<VAL&MASK>-VAL>,<PRINTX SYMBOL TABLE MASK>
Q=	VAL
Z=	<<FLAG>&SMF.P8>!<<FLAG>&SMF.11>
IFE	<<FLAG>&<SMF.P8!SMF.11>>,<Z=1>
IFN	Z,<
	SIXBIT	\NAME\
	EXP	VAL
	XWD	FLAG,MASK
	SIXBIT	\DDT11\
>>					;END OF DEFINE X

Q=	0
SYMBEG:	EXP	.+2
SYMEND:	EXP	SYMZZZ

;FOLLOWING IS DYNAMIC STORAGE
;	SPACE (IF EXEC MODE)
;	MEMORY FOR EXEC MODE USAGE (EPT, UPT, ETC.) POINTED TO BY EPTBLK
;	MEMORY USE TABLE (IF READ FILE INTO CORE)
;	MEMORY (IF READ FILE INTO CORE)
;	SYMBOL TABLE (AT END CAUSE MOST LIKELY TO CHANGE IN SIZE)

	INSTRU			; BUILD THE SYMBOL TABLE

SYMZZZ==.

	PURGE	Z,ZZ,ZZRET,Q,QQ,X,XX,DDBLNK,DDBADR

DDTEND:	END	DDT11
