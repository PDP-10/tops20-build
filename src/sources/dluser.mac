; UPD ID= 52, RIP:<7.UTILITIES>DLUSER.MAC.4,  19-Feb-88 18:09:27 by GSCOTT
;TCO 7.1236 - Edit 22, update copyright notice.
; UPD ID= 34, RIP:<7.UTILITIES>DLUSER.MAC.3,  14-Dec-87 09:18:41 by BROOKS
;Increment version number for 7.0 ft1
; UPD ID= 28, RIP:<7.UTILITIES>DLUSER.MAC.2,   1-Dec-87 17:50:58 by MCCOLLUM
;TCO 7.1154 - Implement the /FORCE switch for the LOAD command.
; *** Edit 9 to DLUSER.MAC by MCCOLLUM on 22-Jan-86, for SPR #21004
; Rewrite code in LODUS3 and STRPDT to remove all BKJFN calls 
; UPD ID= 151, SNARK:<6.1.UTILITIES>DLUSER.MAC.8,  28-Aug-85 07:39:58 by DMCDANIEL
;Fix for release.
; UPD ID= 149, SNARK:<6.1.UTILITIES>DLUSER.MAC.7,  12-Aug-85 15:02:47 by MCCOLLUM
;Add support for TOPS-10 PPN in directory.
; UPD ID= 111, SNARK:<6.1.UTILITIES>DLUSER.MAC.6,   5-Apr-85 13:37:45 by LEACHE
;TCO 6.1.1307 - Suppress leading blanks on ODTIM
; UPD ID= 266, SNARK:<6.UTILITIES>DLUSER.MAC.5,  20-Apr-83 10:30:10 by LEACHE
;More TCO 6.1623
; UPD ID= 142, SNARK:<6.UTILITIES>DLUSER.MAC.3,  27-Sep-82 14:27:37 by LEACHE
;Bump edit number on previous
; UPD ID= 141, SNARK:<6.UTILITIES>DLUSER.MAC.2,  27-Sep-82 14:21:00 by LEACHE
;TCO 6.1623 Save and restore password encryption version number
; UPD ID= 1033, SNARK:<5.UTILITIES>DLUSER.MAC.3,  23-Sep-80 12:18:26 by LYONS
;Fix an error in the error code
;<4.UTILITIES>DLUSER.MAC.4,  3-Aug-79 16:36:06, Edit by KONEN
;IF USER NUMBER ALREADY EXISTS IN LOADING, LET SYSTEM GIVE ONE
;<4.UTILITIES>DLUSER.MAC.3,  5-Jun-79 11:40:57, EDIT BY DBELL
;TCO 4.2273 - ALWAYS SET DIRECTORY PARAMETERS FOR THE SYSTEM DIRECTORIES
;<4.UTILITIES>DLUSER.MAC.2, 10-Mar-79 13:45:56, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.UTILITIES>DLUSER.MAC.1, 23-Jan-79 10:46:22, Edit by KONEN
;UPDATE VERSION NUMBER FOR RELEASE 4

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
	TITLE DLUSER - Dump/Load User Information

;DUMP/LOAD USER INFORMATION - D. MURPHY
;NOTE: REQUIRES OPERATOR OR WHEEL CAPABILITY

	SEARCH MONSYM, MACSYM
	.CPYRT <<1976, 1988>>
	.DIREC FLBLST

	IFNDEF .PSECT,<
	.DIRECT .XTABM>
	.REQUIRE SYS:MACREL
	SALL


;Warning:  when dumping, ALL strings returned by GTDIR that happen to
;be null must be written to the file as <space><CR><LF>, not <CR><LF>
;If GTDIR is changed to return additional string fields, see the code
;preceding DLUSER's invocation of GTDIR and add to it.

T1=1
T2=2
T3=3
T4=4
P=17
GB=16
P2=15
P1=14
IO=11

	INTERN START,LODUSR,DMPUSR

;ENTRY VECTOR

PRGCST==0			;CUSTOMER ID
PRGVER==7			;[7.1154]VERSION NUMBER
PRGMIN==0			;[7.1154]MINOR VERSION
PRGEDT==^D22			;[7.1154]EDIT NUMBER
ENTVEC:	JRST START		;MAIN START
	JRST PARSE		;REENTER ADDRESS
	PRGCST_^D33+PRGVER_^D24+PRGMIN_^D18+PRGEDT


DEFINE LS (NM,SZ)
<NM:	BLOCK SZ
>

NPDL==20			;SIZE OF THE STACK
SYSMAX==17			;HIGHEST SYSTEM DIRECTORY NUMBER
LS PDL,NPDL			;THE STACK

LS JFN,1			;JFN OF FILE FOR INPUT OR OUTPUT
	EBUFLN==.CDPPN+1	;LENGTH OF EBUF
LS EBUF,EBUFLN			;ARGUMENT BLOCK FOR GTDIR OR CRDIR
LS NAMBUF,21			;CONTAINS STR:<*> ON DUMP, STR:<DIRECTORY> ON LOAD
LS DATBUF,21			;STORES DATE FOR PASSWORD ENCRYPTION
LS NAMPTR,1			;POINTER INTO NAMBUF 
LS DIRNAM,21			;CONTAINS STR:<DIRECTORY> ON DUMP
LS DIRNUM,1			;DIRECTORY NUMBER
LS PASBUF,11			;CONTAINS PASSWORD
LS ACTBUF,11			;CONTAINS DIRECTORY DEFAULT ACCOUNT
LS STRDV,1			;DEVICE DESIGNATOR FOR STRUCTURE TO USE
LS USERNO,1			;USER NUMBER CURRENTLY WORKING ON (FOR CTRL/A)

;LOCATIONS FOR STORING PC WHEN PROCESSING INTERRUPTS
LS RET1,1
LS RET2,1
LS RET3,1		;INTERUPT PC TABLE

;GROUP BLOCKS.  EACH CONTAINS COUNT + 1000 WORDS + 1 WORD FOR ZERO AT END

GRPSIZ== 1000			;SIZE OF GROUP BLOCK
LS UGROUP,GRPSIZ+1+1		;USER GROUPS
LS DGROUP,GRPSIZ+1+1		;DIRECTORY GROUPS
LS CRTGRP,GRPSIZ+1+1		;GROUPS FOR SUBDIRECTORIES

;DEFINITIONS FOR COMMAND PARSING USING COMND JSYS

;TB - MACRO TO SET UP COMMAND TABLE 

	DEFINE TB (DAT,TXT)<
	XWD [ASCIZ /TXT/],DAT>

;ADDRESSES FOR HANDLING EACH COMMAND

CMDTAB:
	CMDSIZ,,CMDMAX		;NUMBER COMMANDS, MAXIMUM NUMBER
	TB (.DUMP,DUMP)		;DUMP DIRECTORIES TO FILE
	TB (.EXIT,EXIT)		;QUIT
	TB (.HELP,HELP)		;TYPE INFORMATION ABOUT DLUSER
	TB (.LOAD,LOAD)		;LOAD DIRECTORIES INTO SYSTEM FROM FILE
	TB (.STR,STRUCTURE)	;SPECIFY STRUCTURE TO OPERATE ON

CMDSIZ==.-CMDTAB-1		;[7.1154]
CMDMAX==CMDSIZ			;MAXIMUM NUMBER OF COMMANDS

LODTAB:	LODSIZ,,LODSIZ		;[7.1154]SIZE OF TABLE
	TB (0,FORCE)		;[7.1154]FORCE SWITCH
LODSIZ==.-LODTAB-1		;[7.1154]SIZE OF TABLE
FRCSWI:	BLOCK 1			;[7.1154]FORCE SWITCH VALUE

NCHPW==5			;NUMBER OF CHARACTERS PER WORD
PROMPT:	ASCIZ /DLUSER>/		;PROMPT
CMDBLK:	BLOCK .CMGJB+5		;COMMAND STATE BLOCK (LEAVE ROOM FOR GROWTH)
GJFSIZ==.GJRTY+2
GTJBLK:	BLOCK GJFSIZ		;GTJFN BLOCK (USED BY COMND)

BUFSIZ==150			
BUFFER:	BLOCK BUFSIZ		;BUFFER USER TYPES COMMAND INTO
ATMSIZ==BUFSIZ
ATMBUF:	BLOCK ATMSIZ		;BUFFER THAT COMND STORES LAST FIELD INTO

;ERROR - MACRO TO PRINT ERROR AND GO TO SPECIFIED LOCATION

	DEFINE ERROR (ADDR,MSG)<
	JRST  [	HRROI T1,[ASCIZ /
? MSG
/]
		PSOUT
		JRST ADDR]>

;TXTPTR- MACRO TO SET UP BYTE POINTER TO A STRING

	DEFINE TXTPTR (MSG) <POINT 7,[ASCIZ/MSG/]>


START:	MOVE P,[IOWD NPDL,PDL]
	RESET
	HRROI 1,NAMBUF		;INIT STR PNTR
	MOVEM 1,NAMPTR
	MOVEI T1,.FHSLF
	RPCAP			;GET PROCESS CAPABILITIES
	TXNN T3,SC%WHL!SC%OPR
	JRST [	TMSG <?WHEEL or OPERATOR capability required
>
		HALTF
		JRST START]
	MOVEI T1,.FHSLF
	CIS			;SET UP INTERUPT SYSTEM
	EIR
	MOVE T2,[LEVTAB,,CHNTAB]
	SIR
	MOVX T2,1B1		;PUT ^A ON 1
	AIC
	MOVE T1,[1,,1]
	ATI			;ASSIGN TERMINAL CODE

;HERE TO START A NEW COMMAND.SET UP THE COMMAND STATE  BLOCK

PARSE:	SETZM USERNO		;NONE YET
	MOVEI T2,CMDBLK		;POINT TO START OF COMMAND STATE BLOCK
	MOVEI T1,PARSE2		;TRANSFER IF USER DELETES PREVIOUSLY PARSED STUFF
	MOVEM T1,.CMFLG(T2)
	MOVE T1,[.PRIIN,,.PRIOU] ;JFN'S FOR USER INPUT AND OUTPUT
	MOVEM T1,.CMIOJ(T2)
	HRROI T1,PROMPT		;POINTER TOPROMPT STRING
	MOVEM T1,.CMRTY(T2)
	HRROI T1,BUFFER		;POINTER TO START OF USER INPUT
	MOVEM T1,.CMBFP(T2)
	MOVEM T1,.CMPTR(T2)	;POINTER TO NEXT FIELD
	MOVEI T1,BUFSIZ*NCHPW	;SPACE REMAINING IN BUFFER
	MOVEM T1,.CMCNT(T2)
	SETZM .CMINC(T2)	;NUMBER OF UNPARSED CHARACTERS
	HRROI T1,ATMBUF		;POINTER TO ATOM BUFFER
	MOVEM T1,.CMABP(T2)
	MOVEI T1,ATMSIZ*NCHPW	;NUMBER CHARACTERS IN ATOM BUFFER
	MOVEM T1,.CMABC(T2)
	MOVEI T1,GTJBLK		;ADDRESS OF GTJFN BLOCK
	MOVEM T1,.CMGJB(T2)


;HERE WHEN ERROR OCCURS AND NEED TO START OVER.  REINIT THE COMND JSYS

PARSE1:
	MOVEI T1,CMDBLK		;T1/ADDRESS OF COMMAND STATE BLOCK
	MOVEI T2,[FLDDB. (.CMINI)] ;T2/ADDRESS OF FUNCTION DESCRIPTOR BLOCK
	COMND			;INIT THE COMND JSYS

;HERE WHEN USER RUBOUTS INTO PREVIOUSLY GOTTEN TEXT

PARSE2:	MOVE T1,[CZ%NCL+.FHSLF];WE WANT TO RELEASE ALL JFN'S
	CLZFF			;DO IT
	MOVEI T1,CMDBLK		;T1/ADDRESS OF COMMAND STATE BLOCK
	MOVEI T2,[FLDDB.(.CMKEY,,CMDTAB)] ;T2/ADDRESS OF FDB
	COMND			;LOOK FOR A KEYWORD
	TXNE T1,CM%NOP		;DID WE FIND ONE?
	ERROR PARSE1,<NOT A DLUSER COMMAND> ;NO. START OVER
	HRRZ T1,(T2)		;YES. GO PROCESS IT
	JRST (T1)	
PARSE3:	JRST PARSE		;GET NEXT COMMAND
	SUBTTL DUMP (TO FILE) FILESPEC

;USER WANTS TO DUMP DIRECTORIES TO A FILE.  GET NAME OF FILE

.DUMP:
	MOVEI T1,CMDBLK		;T1/ADDRESS OF COMMAND STATE BLOCK
	MOVEI T2,[FLDDB. (.CMNOI,,TXTPTR <TO FILE>)];T2/ADDRESS OF FDB
	COMND			;TYPE NOISE WORD IF NEEDED
	MOVE T1,[GTJBLK,,GTJBLK+1] ;SET UP TO CLEAR GTJFN BLOCK
	SETZM GTJBLK		;CLEAR FIRST WORD OF BLOCK
	BLT T1,GTJBLK+GJFSIZ-1	;CLEAR GTJFN BLOCK
	HRROI T1,[ASCIZ/USERS/]	;GET DEFAULT FILENAME
	MOVEM T1,GTJBLK+.GJNAM	;SAVE DEFAULT FILE NAME
	HRROI T1,[ASCIZ/TXT/]	;GET POINTER TO DEFAULT FILE TYPE
	MOVEM T1,GTJBLK+.GJEXT	;SAVE DEFAULT FILE TYPE POINTER
	HRROI T1,[ASCIZ/770000/] ;GET DEFAULT PROTECTION
	MOVEM T1,GTJBLK+.GJPRO	;SAVE DEFAULT PROTECTION
	MOVX T1,GJ%FOU		;GET "FOR-OUTPUT-USE" FLAG
	MOVEM T1,GTJBLK+.GJGEN	;SAVE FLAGS
	MOVEI T1,CMDBLK		;T1/ADDRESS OF COMMAND STATE BLOCK
	MOVEI T2,[FLDDB. (.CMFIL)] ;GET FILESPEC FDB FOR COMND
	COMND			;GET OUTPUT FILE
	TXNE T1,CM%NOP		;DID WE GET A GOOD FILE NAME
	JRST [	JSERR		;FAILED. REPORT ERROR
		JRST PARSE1]
	HRRZM T2,JFN		;YES. SAVE THE JFN

	MOVEI T1,CMDBLK		;T1/ADDRESS OF COMMAND STATE BLOCK
	MOVEI T2,[FLDDB. (.CMCFM)] ;T2/ADDRESS OF FUNCTION DESCRIPTOR BLOCK
	COMND			;GET CONFIRMATION
	TXNE T1,CM%NOP		;DID WE GET IT?
	ERROR PARSE1,<INVALID COMMAND CONFIRMATION>  ;NO. START OVER

;OPEN THE FILE

	MOVE T1,JFN		;T1/JFN OF OUTPUT FILE
	MOVX T2,<OF%WR+FLD(7,OF%BSZ)> ;T2/OPEN FOR WRITE, 7-BIT BYTES
	OPENF			;OPEN FILE TO DUMP ONTO
	JRST [	JSERR		;FAILED.  REPORT ERROR
		JRST PARSE1]	;START THE LINE OVER
	JRST DMPUSR
;SUBROUTINE TO DUMP ALL DIRECTORIES ONTO SPECIFIED FILE
;IF A STRUCTURE WAS SPECIFIED, NAMBUF CONTAINS THE STRUCTURE NAME.
;IF NOT, IT IS ZEROED.  NAMPTR POINTS TO THE NEXT AVAILABLE LOCATION
;IN NAMBUF.

DMPUSR:	MOVE T1,NAMPTR		;T1/ POINTER TO END OF STRUCTURE
	HRROI T2,[ASCIZ /<*>/]	;T2/ POINTER TO DIRECTORY SPEC
	SETZ T3,		;T3/ STOP ON NULL
	SOUT			;APPEND <*> TO STRUCTURE NAME
	MOVX T1,RC%AWL		;T1/ ALLOW WILD CARD
	HRROI T2,NAMBUF		;T2/ POINT TO STR:<*>
	RCDIR			;GET THE FIRST DIRECTORY
	 ERJMP [ TMSG <
?Unable to get first directory>
			JSERR
		JRST PARSE]
	TXNE T1,RC%NOM!RC%AMB!RC%NMD ;ANY ERROR CONDITIONS?
	JRST [	TMSG <
?Unable to get first directory>
		HALTF
		JRST PARSE]
	MOVEM T3,DIRNUM		;NO. SAVE DIRECTORY NUMBER
	HRROI T1,DIRNAM		;T1/ POINT TO BUFFER FOR OUTPUT
	MOVE T2,T3		;T2/ DIRECTORY NUMBER
	DIRST			;STORE STRUCTURE:<DIRECTORY>
	 JSHLT			;FAILED. SHOULDN'T HAPPEN

;PRINT A ONE-TIME HEADER INDICATING STRUCTURE BEING DUMPED AND
;FORMAT OF OUTPUT

	MOVE T1,JFN		;OUTPUT FILE
	HRROI T2,[ASCIZ "Dump of all directories on: "]
	SETZ T3,
	SOUT			;OUTPUT COMMENT
	MOVE T1,JFN
	HRROI T2,DIRNAM		;T2/ SOURCE IS DIRECTORY NAME
	MOVEI T3,7		;T3/ DEVICE NAME CAN'T EXCEED 6 CHARACTERS
	MOVEI T4,":"		;T4/ STOP WITH DEVICE TERMINATOR
	SOUT			;PRINT THE STRUCTURE NAME
	HRROI T2,FORMAT
	SETZ T3,
	SOUT			;OUTPUT DESCR

;LOOP THROUGH DIRECTORIES, GETTING THEIR DIRECTORY INFO AND COPYING
;IT TO THE OUTPUT FILE

DMPUS3:	MOVE T1,DIRNUM		;T1/ DIRECTORY #
	MOVEM T1,USERNO		;SAVE FOR ^A WATCHERS
	MOVEI T2,EBUFLN		;GET LENGTH OF BUFFER "EBUF"
	MOVEM T2,EBUF+.CDLEN	;STORE COUNT IN BLOCK FOR GTDIR
	MOVEI T2,EBUF		;T2/ WHERE TO STORE DIRECTORY INFO
	HRROI T3,PASBUF		;T3/ WHERE TO STORE PASSWORD

;SET UP POINTERS FOR GROUP LISTS.  ARGUMENT BLOCK FOR GTDIR CONTAINS 
;ADDRESS OF BLOCK INTO WHICH GTDIR COPIES GROUP NUMBERS.  THE DESTINATION
;BLOCK CONTAINS ITS SIZE IN THE FIRST WORD.  THIS CODE ZEROES THE
;DESTINATION BLOCK, STORES ITS SIZE IN THE FIRST WORD, AND STORES A
;POINTER TO THE DESTINATION IN THE GTDIR ARGUMENT BLOCK

	MOVE P1,[UGROUP,,UGROUP+1] ;GET SOURCE,,DESTINATION
	SETZM UGROUP		;CLEAR FIRST WORD OF GROUP BLOCK
	BLT P1,UGROUP+GRPSIZ-1	;CLEAR ENTIRE USER GROUP BLOCK
	MOVE P1,[DGROUP,,DGROUP+1] ;GET SOURCE,,DESTINATION
	SETZM DGROUP		;CLEAR FIRST WORD OF GROUP BLOCK
	BLT P1,DGROUP+GRPSIZ-1	;CLEAR ENTIRE DIRECTORY GROUP BLOCK
	MOVE P1,[CRTGRP,,CRTGRP+1] ;GET SOURCE,,DESTINATION
	SETZM CRTGRP		;CLEAR FIRST WORD OF GROUP BLOCK
	BLT P1,CRTGRP+GRPSIZ-1	;CLEAR ENTIRE CREATABLE GROUP BLOCK
	MOVEI P1,UGROUP		;GET ADR OF USER GROUP BLOCK
	MOVEM P1,EBUF+.CDUGP	;STORE BLOCK ADR FOR GTDIR
	MOVEI P1,DGROUP		;GET ADR OF DIR GROUP BLOCK
	MOVEM P1,EBUF+.CDDGP	;STORE BLOCK ADR FOR GTDIR
	MOVEI P1,CRTGRP		;GET ADDRESS OF CREATABLE GROUP BLOCK
	MOVEM P1,EBUF+.CDCUG	;STORE BLOCK ADDRESS FOR GTDIR
	MOVEI P1,GRPSIZ		;GET SIZE OF GROUP BLOCK
	MOVEM P1,UGROUP		;STORE SIZE OF BLOCK IN FIRST WORD
	MOVEM P1,DGROUP		;DITTO FOR DIR GROUP BLOCK
	MOVEM P1,CRTGRP		;DITTO FOR CREATABLE GROUP BLOCK
	HRRI P1,ACTBUF		;ADDRESS OF DEFAULT ACCT BUFFER
	HRLI P1,(<POINT 7,>)
	MOVEM P1,EBUF+.CDDAC	;STORE POINTER FOR GTDIR
	GTDIR			;GET PASSWORD AND DIRECTORY PARAMS
	 ERJMP [CALL DIRERR	;FAILED. PRINT MESSAGE AND FIND REASON
		JRST PARSE	;NOT ENOUGH PRIVILEGE. ABORT COMMAND
		JRST DMPUS1]	;PROBLEM WITH INDIVIDUAL DIRECTORY.  CONTINUE

;OUTPUT HEADER FOR THIS DIRECTORY FOLLOWED BY PASSWORD

	MOVE T1,JFN		;T1/ DESTINATION IS OUTPUT FILE
	MOVEI T2,"&"
	BOUT			;MARK START OF NAME
	HRROI T2,DIRNAM		;T2/ SOURCE IS DIRECTORY NAME
	SETZ T3,
	SOUT			;OUTPUT NAME
	HRROI T2,[ASCIZ /
 /]
	SOUT
	HRROI T2,PASBUF		;PASSWORD
	SOUT

;OUTPUT REST OF INFORMATION STARTING WITH LOGGED IN QUOTA
;EACH ITEM IS PRECEDED BY <CR><LF><SPACE>.  

	MOVSI 7,-<.CDLLD-.CDLIQ+1> ;7/-COUNT,,POINTER TO GTDIR BLOCK
DMPUS2:	HRROI T2,[ASCIZ /
 /]
	SETZ T3,
	SOUT			;MARK BEGINNING OF ITEM
	MOVE T2,EBUF+2(7)	;GET NEXT ITEM
	MOVE T3,[1B0+10]	;OUTPUT MAGNITUDE, OCTAL
	NOUT			;OUTPUT THE DATA
	 JSHLT
	AOBJN 7,DMPUS2		;LOOP THROUGH DATA UP TO GROUPS

;DUMP THE USER GROUPS PRECEDED BY <CR><LF><SPACE>

	HRROI T2,[ASCIZ/
 /]
	SETZM 3			;TERMINATE ON NULL
	SOUT
	MOVEI GB,UGROUP		;GET ADR OF USER GROUP BLOCK
	CALL DMPGRP		;GO DUMP USER GROUPS

;DUMP THE DIRECTORY GROUPS PRECEDED BY <CR><LF><SPACE>

	HRROI T2,[ASCIZ/
 /]
	SETZM 3			;TERMINATE ON NULL
	SOUT
	MOVEI GB,DGROUP		;GET ADR OF DIR GROUP BLOCK
	CALL DMPGRP		;GO DUMP DIRECTORY GROUPS

;DUMP THE NUMBER OF ALLOWED SUBDIRECTORIES

	HRROI T2,[ASCIZ /
 /]
	SETZ T3,
	SOUT			;MARK BEGINNING OF FIELD
	MOVE T2,EBUF+.CDSDQ	;GET NUMBER OF ALLOWED SUBDIRECTORIES
	MOVX T3,NO%MAG+<FLD(10,NO%RDX)> ;PRINT MAGNITUDE, OCTAL NUMBER
	NOUT			;OUTPUT MAXIMUM SUBDIRECTORIES
	 JSHLT			;FAILED. SHOULDN'T HAPPEN

;DUMP CREATABLE USER GROUPS PRECEDED BY <CR><LF><SPACE>

	HRROI T2,[ASCIZ/
 /]
	SETZ T3,		;STOP ON NULL
	SOUT			;MARK BEGINNING OF ITEM
	MOVEI GB,CRTGRP		;GET ADDRESS OF GROUP LIST
	CALL DMPGRP		;GO OUTPUT THE LIST

;DUMP THE DEFAULT DIR ACCOUNT PRECEDED BY <CR><LF>

	MOVE T1,JFN		;DESTINATION IS OUTPUT FILE
	HRROI T2,[ASCIZ/
/]
	SETZ T3,		;STOP ON NULL
	SOUT
	HRROI T2,ACTBUF
	SETZ T3,
	SOUT			;OUTPUT THE DEFAULT ACCOUNT

;Dump password encryption version number

	HRROI T2,[ASCIZ/
 /]
	SETZ T3,
	SOUT%
	MOVE T2,EBUF+.CDPEV	;Get number
	MOVX T3,NO%MAG+FLD(^D10,NO%RDX)
	NOUT%
	 JSHLT
;Dump password encryption date
	HRROI T2,[ASCIZ/
 /]
	SETZ T3,
	SOUT%
	MOVE T2,EBUF+.CDPDT
	JUMPE T2,DMPEDZ		;If zero, just output the zero
	MOVX T3,OT%SCL		;Suppress leading blanks
	ODTIM
	JRST DMPPED
DMPEDZ:	MOVX T3,NO%MAG+FLD(^D10,NO%RDX)
	NOUT%
	 JSHLT

;Dump password expiration date
DMPPED:	HRROI T2,[ASCIZ/
 /]
	SETZ T3,
	SOUT%
	MOVE T2,EBUF+.CDPED
	JUMPE T2,DMPPDZ		;If zero, just output the zero
	MOVX T3,OT%SCL		;Suppress leading blanks
	ODTIM
	JRST DMPPUD
DMPPDZ:	MOVX T3,NO%MAG+FLD(^D10,NO%RDX)
	NOUT%
	 JSHLT

;Dump password use data
DMPPUD:	HRROI T2,[ASCIZ/
 /]
	SETZ T3,
	SOUT%
	HLRZ T2,EBUF+.CDPMU	;Get current use count
	MOVX T3,NO%MAG+FLD(^D10,NO%RDX)
	NOUT%
	 JSHLT
	HRROI T2,[ASCIZ/,,/]
	SETZ T3,
	SOUT%
	HRRZ T2,EBUF+.CDPMU	;Get maximum use count
	MOVX T3,NO%MAG+FLD(^D10,NO%RDX)
	NOUT%
	 JSHLT

;Dump the TOPS10 project-programmer number
DMPPPN:	HRROI T2,[ASCIZ/
 /]
	SETZ T3,
	SOUT%
	HLRZ T2,EBUF+.CDPPN	;Get project number
	MOVX T3,NO%MAG+FLD(^D8,NO%RDX)
	NOUT%
	 JSHLT
	HRROI T2,[ASCIZ/,,/]
	SETZ T3,
	SOUT%
	HRRZ T2,EBUF+.CDPPN	;Get programmer number
	MOVX T3,NO%MAG+FLD(^D8,NO%RDX)
	NOUT%
	 JSHLT

;END THE WHOLE THING WITH <CR><LF>

	HRROI T2,[ASCIZ/
 /]
	SETZ T3,		;STOP ON NULL
	SOUT

;DONE WITH THIS DIRECTORY. STEP TO THE NEXT ONE

DMPUS1:	MOVX T1,RC%AWL!RC%STP	;T1/ ALLOW WILD CARD, STEP
	HRROI T2,NAMBUF		;T2/ POINT TO STR:<*>
	MOVE T3,DIRNUM		;T3/ DIRECTORY NUMBER LAST RETURNED
	RCDIR			;GET THE NEXT DIRECTORY
	 ERJMP [ TMSG <
?Unable to get next directory>
		HALTF
		JRST PARSE]
	TXNE T1,RC%NOM!RC%AMB	;ANY PROBLEM OTHER THAN NO MORE DIRECTORIES?
	JRST [	TMSG <
?Unable to get next directory>
		HALTF
		JRST PARSE]
	TXNE T1,RC%NMD		;NO. ANY MORE DIRECTORIES?
	JRST DONE		;NO. ALL DONE
	MOVEM T3,DIRNUM		;YES. SAVE DIRECTORY NUMBER FOR STEPPING
	HRROI T1,DIRNAM		;T1/ POINT TO OUTPUT FOR DIRST
	MOVE T2,T3		;T2/ DIRECTORY NUMBER
	DIRST			;GET DIRECTORY NAME INCLUDING STRUCTURE
	 JSHLT			;FAILED. SHOULDN'T HAPPEN
	JRST DMPUS3		;GO DO THE DIRECTORY
;DIRERR - ROUTINE TO PRINT ERROR AFTER GTDIR FAILS.

;NOTE: GETER CLOBBERS 4-10

;	CALL DIRERR

;RETURNS +1:LACK OF PRIVILEGE
;        +2:PROBLEM WITH ONE DIRECTORY

DIRERR:	TMSG<
?JSYS ERROR:>
	MOVEI T1,.FHSLF		;T1/CURRENT FORK
	GETER			;GET LAST ERROR
	MOVEI T1,.PRIOU		;T1/PRIMARY OUTPUT
	SETZ T3,		;T3/NO LIMIT ON LENGTH OF MESSAGE
	ERSTR			;PRINT MESSAGE FOR ERROR IN T2
	 JFCL			;FAILED
	 JFCL			;FAILED
	MOVEI T2,(T2)		;GET ERROR CODE
	CAIN T2,GTDIX1		;IS IT LACK OF OPERATOR OR WHEEL PRIVILEGE?
	JRST 	[TMSG<
>				;YES.  QUIT.

		RET]
	TMSG < - >		;NO. PRINT AND CONTINUE
	HRROI T1,DIRNAM		;T1/POINTER TO DIRECTORY NAME
	PSOUT			;PRINT THE DIRECTORY NAME
	TMSG <
>
	RETSKP			;SKIP RETURN
	
; ROUTINE TO DUMP USER OR DIRECTORY GROUPS

; ACCEPTS GB/	ADDRESS OF GROUP BLOCK
;		CALL DMPGRP
; RETURNS	+1 ALWAYS

DMPGRP:	MOVEI P1,1(GB)		;COPY ADR OF FIRST  GROUP BLOCK
	MOVE 1,JFN		;GET OUTPUT JFN
	MOVEI 3,^D10		;DECIMAL RADIX
	MOVEI P2,GRPSIZ		;# OF WORDS IN GROUP BLOCK
	MOVE 2,(P1)		;GET FIRST WORD OF BLOCK
	JRST DMPGP2		;GO DO FIRST GROUP
DMPGP1:	MOVEI 2,","		;GET DELIMITER
	BOUT			;OUTPUT THE COMMA
	MOVE 2,(P1)		;GET GROUP # AGAIN
	MOVE 1,JFN		;GET JFN BACK
DMPGP2:	NOUT			;OUTPUT THE GROUP #
	 JSHLT			;UNEXPECTED ERROR
	JUMPE 2,R		;QUIT ON ZERO
	SOJLE P2,DMPGP3		;GROUP BLOCK IS TOO SMALL ?
	AOJA P1,DMPGP1		;GO OUTPUT NEXT PAIR OF GROUPS
DMPGP3:	TMSG <
? GROUP BLOCK IS TOO SMALL, ABORTING ...
>
	HALTF
	JRST .-1

FORMAT:	ASCIZ \
Data Format:

STR:<DIRECTORY-NAME>
 PASSWORD
 LOGGED IN QUOTA
 CAPABILITIES
 FILES ONLY, ALPHA ACCTS, REPEAT LMSG
 LOGGED OUT QUOTA
 DIRECTORY NUMBER
 DEFAULT FILE PROTECTION
 DIRECTORY PROTECTION
 DEFAULT RETENTION SPECIFICATION
 LAST LOGIN
 USER GROUPS
 DIRECTORY GROUPS
 MAXIMUM SUBDIRECTORIES
 CREATABLE USER GROUPS
 DEFAULT DIRECTORY ACCOUNT
 PASSWORD ENCRYPTION VERSION NUMBER
 PASSWORD ENCRYPTION DATE/TIME
 PASSWORD EXPIRATION DATE/TIME
 PASSWORD USE DATA (CURRENT USE COUNT,,MAXIMUM USE COUNT)
 TOPS10 PROJECT-PROGRAMMER NUMBER
\
	SUBTTL EXIT (TO MONITOR)

;USER WANTS TO QUIT.  GET CONFIRMATION AND EXIT

.EXIT:
	MOVEI T1,CMDBLK		;T1/ADDRESS OF COMMAND STATE BLOCK
	MOVEI T2,[FLDDB. (.CMNOI,,TXTPTR <TO MONITOR>)];T2/ADDRESS OF FDB
	COMND			;TYPE NOISE WORD IF NEEDED
	MOVEI T1,CMDBLK		;T1/ADDRESS OF COMMAND STATE BLOCK
	MOVEI T2,[FLDDB. (.CMCFM)] ;T2/ADDRESS OF FUNCTION DESCRIPTOR BLOCK
	COMND			;GET CONFIRMATION
	TXNE T1,CM%NOP		;DID WE GET IT?
	ERROR PARSE1,<INVALID COMMAND CONFIRMATION> ;NO
	SETOM T1		;T1/INDICATES ALL FILES
	CLOSF			;CLOSE ALL OPEN FILES
	 JSERR			;PRINT ERROR AND CONTINUE
	HALTF			;RETURN TO MONITOR
	JRST START		;IF CONTINUED, START OVER
	SUBTTL STRUCTURE (TO USE)

;USED TO SPECIFY STR OTHER THAN DEFAULT

.STR:	HRROI T1,NAMBUF		;INIT POINTER
	MOVEM T1,NAMPTR
	MOVEI T1,CMDBLK		;COMND INFO
	MOVEI T2,[FLDDB. (.CMNOI,,TXTPTR <TO USE>)]
	COMND
	MOVEI T2,[FLDDB. (.CMDEV,CM%SDH,,<STRUCTURE NAME>,<DSK>)]
	COMND
	TXNE T1,CM%NOP		;LOSAGE?
	ERROR PARSE1,<INVALID STRUCTURE NAME GIVEN>
	MOVEM T2,STRDV		;SAVE DESIGNATOR A WHILE
	MOVEI T2,[FLDDB. (.CMCFM)]
	COMND
	TXNE T1,CM%NOP
	ERROR PARSE1,<INVALID COMMAND CONFIRMATION>
	MOVE T1,STRDV		;GET DEVICE DESIGNATOR
	DVCHR
	LDB T1,[POINTR T2,DV%TYP]
	CAIE T1,.DVDSK		;GRNTEE DISK
	ERROR PARSE1,<INVALID STRUCTURE NAME GIVEN>
	MOVE T2,STRDV		;DEVICE DESIGNATOR
	MOVE T1,NAMPTR		;GET PNTR
	DEVST			;GET STRING
	 JRST [	JSERR
		JRST PARSE]	;START OVER
	MOVEI T2,":"		;TERMINATE WITH COLON
	IDPB T2,T1		;...
	MOVEM T1,NAMPTR		;UPDATE PNTR
	JRST PARSE3		;GET NEXT COMMAND
	SUBTTL HELP

;USER WANTS AN EXPLANATION

.HELP:	MOVEI T1,CMDBLK		;T1/ADDRESS OF COMMAND STATE BLOCK
	MOVEI T2,[FLDDB. (.CMCFM)] ;T2/ ADDRESS OF FDB
	COMND			;GET CONFIRMATION
	TXNE T1,CM%NOP		;DID WE GET IT?
	ERROR PARSE1,<INVALID COMMAND CONFIRMATION> ;NO. PRINT ERROR
	HRROI T1,HLPMSG
	PSOUT			;TYPE THE HELP MESSAGE TO USER'S TTY
	JRST PARSE3

;TEXT FOR HELP MESSAGE

HLPMSG:	ASCIZ\		TOPS-20 DLUSER
FUNCTIONS:
	1) DUMP ONTO A FILE IDENTIFYING INFORMATION ABOUT EACH DIRECTORY
IN THE SYSTEM
	2) CREATE DIRECTORIES ON A SYSTEM BY LOADING IDENTIFYING 
INFORMATION FROM A FILE

COMMANDS:
	DUMP (TO FILE) FILE-SPECIFICATION
	  DUMP DIRECTORIES TO FILE
	EXIT (TO MONITOR)
	  LEAVE THIS PROGRAM
	HELP
	  PRINT THIS MESSAGE
	LOAD (FROM FILE) FILE-SPECIFICATION
	  LOAD DIRECTORIES FROM FILE. DON'T CHANGE DIRECTORIES
	  THAT ALREADY EXIST UNLESS THEY ARE SYSTEM DIRECTORIES
	LOAD (FROM FILE) FILE-SPECIFICATION /FORCE
	  LOAD DIRECTORIES FROM FILE. MODIFY DIRECTORIES IF THEY
	  ALREADY EXIST ON THE STRUCTURE.
	STRUCTURE (TO USE) STR-NAME:
	   SPECIFY STRUCTURE TO DUMP FROM/LOAD ONTO
	   (DEFAULT IS CONNECTED STRUCTURE)

THIS PROGRAM IS USEFUL FOR MOVING ALL DIRECTORIES FROM ONE FILE SYSTEM
TO ANOTHER.  IT WILL NOT MOVE A SUBSET.  IT MUST BE RUN WITH WHEEL OR
OPERATOR CAPABILITIES ENABLED.
\				;[7.1154]
	SUBTTL LOAD (FROM FILE) FILE-SPECIFICATION

;USER WANTS TO LOAD DIRECTORIES ONTO SYSTEM FROM A FILE.  GET THE FILE NAME

.LOAD:	SETZM FRCSWI		;[7.1154]INIT FORCE SWITCH
	MOVEI T1,CMDBLK		;T1/ADDRESS OF COMMAND STATE BLOCK
	MOVEI T2,[FLDDB. (.CMNOI,,TXTPTR <FROM FILE>)];T2/ADDRESS OF FDB
	COMND			;TYPE NOISE WORD IF NEEDED
	MOVEI T1,CMDBLK		;T1/ADDRESS OF COMMAND STATE BLOCK
	MOVEI T2,[FLDDB. (.CMIFI)] ;T2/ADDRESS OF FUNCTION DESCRIPTOR BLOCK
	COMND			;GET OUTPUT FILE
	TXNE T1,CM%NOP		;DID WE GET A GOOD FILE NAME
	JRST [	JSERR		;FAILED. REPORT ERROR
		JRST PARSE1]
	HRRZM T2,JFN		;YES. SAVE THE JFN

	MOVEI T1,CMDBLK		;T1/ADDRESS OF COMMAND STATE BLOCK
	MOVEI T2,[FLDDB. .CMSWI,,LODTAB,,,[
		  FLDDB. .CMCFM]] ;[7.1154]T2/ADDRESS OF FDB
	COMND			;[7.1154]CONFIRM OR GET SWITCH
	TXNE T1,CM%NOP		;[7.1154]DID WE GET IT?
	IFNSK.			;[7.1154]
	  JSERR			;[7.1154]FAILED. REPORT ERROR
	  JRST PARSE1		;[7.1154]PARSE NEXT COMMAND
	ENDIF.			;[7.1154]
	LDB T3,[POINTR ((T3),CM%FNC)] ;[7.1154]GET FUNCTION CODE PARSED
	CAIN T3,.CMCFM		;[7.1154]CONFIRMED?
	JRST LODOPN		;[7.1154]YES.
	SETOM FRCSWI		;[7.1154]MUST BE /FORCE THEN
	MOVEI T1,CMDBLK		;[7.1154]T1/ADDRESS OF COMMAND STATE BLOCK
	MOVEI T2,[FLDDB. (.CMCFM)] ;[7.1154]T2/ ADDRESS OF FDB
	COMND			;[7.1154]GET CONFIRMATION
	TXNE T1,CM%NOP		;[7.1154]DID WE GET IT?
	ERROR PARSE1,<INVALID COMMAND CONFIRMATION> ;[7.1154]NO. PRINT ERROR

;OPEN THE FILE

LODOPN:	MOVE T1,JFN		;[7.1154]T1/JFN OF INPUT FILE
	MOVX T2,<OF%RD+FLD(7,OF%BSZ)> ;T2/OPEN FOR READ, 7-BIT BYTES
	OPENF			;OPEN FILE TO DUMP ONTO
	 JRST [	JSERR		;PRINT THE ERROR MESSAGE
		JRST PARSE1]	;START PARSING AGAIN
	JRST LODUSR
;SUBROUTINE TO LOAD ALL DIRECTORIES FROM SPECIFIED FILE

LODUSR:	CALL FNDUSR		;FIND A USER NAME
	 JRST LODEND		;EOF SEEN
	CALL SCNSPC		;SCAN TO SPACE MARKING PASSWORD
	 JRST INPERR
	MOVE 5,[POINT 7,PASBUF,-1]
	MOVEM 5,EBUF+.CDPSW
	CALL RDSTR		;READ PASSWORD
	 JRST INPERR

;LOOP THROUGH THE DATA FOR THIS DIRECTORY, COPYING EACH WORD INTO THE
;ARGUMENT BLOCK FOR CRDIR. EACH ITEM IS PRECEDED BY <CR><LF><SPACE>

	MOVSI 7,-<.CDLLD-.CDLIQ+1> ;ALL PARAMS - NAME, PASSWD, GROUPS
LODUS3:	CALL SCNSPC		;POSITION TO BEGINNING OF NUMBER
	 JRST INPERR
	MOVEI 3,10
	NIN			;READ NUMBER
	JRST [	CAIE 3,IFIXX3	;NORMAL OVERFLOW?
		JRST LODERR
		JRST .+1]	;YES, HAPPENS ON 36 BIT OCTAL NUMBER
	MOVEM 2,EBUF+2(7)
	AOBJN 7,LODUS3

;CALL ROUTINES TO SET UP BLOCKS OF USER AND DIRECTORY GROUP NUMBERS.
;STORE POINTERS TO THESE BLOCKS IN THE CRDIR ARGUMENT BLOCK

	MOVEI GB,UGROUP		;GET ADR OF GROUP BLOCK
	CALL LODGRP		;GO READ USER GROUPS
	MOVEM GB,EBUF+.CDUGP	;STORE ADR OF USER GROUPS
	MOVEI GB,DGROUP		;GET ADR OF DIR GROUP BLOCK
	CALL LODGRP		;GO READ DIRECTORY GROUPS
	MOVEM GB,EBUF+.CDDGP	;STORE ADR OF DIR GROUPS

;COPY THE MAXIMUM NUMBER OF SUBDIRECTORIES INTO THE CRDIR ARGUMENT BLOCK

	CALL SCNSPC		;LOOK FOR THE SPACE THE STARTS THE FIELD
	 JRST INPERR
	MOVEI 3,10		;T3/ OCTAL NUMBER
	NIN			;READ THE NUMBER
	JRST [	CAIE 3,IFIXX3	;NORMAL OVERFLOW?
		JRST LODERR
		JRST .+1]	;YES, HAPPENS ON 36 BIT OCTAL NUMBER
	MOVEM T2,EBUF+.CDSDQ	;STORE IT IN CRDIR ARGUMENT BLOCK

;CALL ROUTINE TO COPY THE LIST OF USER GROUPS THAT THIS DIRECTORY'S
;SUBDIRECTORIES CAN HAVE

	MOVEI GB,CRTGRP		;GET ADDRESS OF CREATABLE GROUP LIST
	CALL LODGRP		;SET UP THE BLOCK
	MOVEM GB,EBUF+.CDCUG	;STORE POINTER IN CRDIR ARGUMENT BLOCK

;COPY THE DEFAULT DIR ACCOUNT INTO THE CRDIR ARGUMENT BLOCK

	MOVE 5,[POINT 7,ACTBUF,-1]
	MOVEM 5,EBUF+.CDDAC
	CALL RDSTR		;READ THE ACCOUNT
	 JRST INPERR		;ERROR

;Copy password encryption version number

	CALL SCNSPC
	 JRST INPERR
	MOVEI T3,^D10
	NIN%
	 JRST [	CAIE T3,IFIXX3	;Overflow?
		JRST LODERR
		JRST .+1]	;Yes, tolerate it
	MOVEM T2,EBUF+.CDPEV

;Copy password encryption date

	CALL SCNSPC
	 JRST INPERR
	HRROI T2,DATBUF		;Buffer for this string
	MOVEI T3,^D80		;Read a max of 80. characters
	MOVEI T4,12		;Terminate on a line feed
	SIN			;Get this line into the buffer
	 ERJMP LODERR		;Bad file format
	MOVE T3,[POINT 7,DATBUF] ;Point at the buffer
	ILDB T2,T3		;Get a byte
	SUBI T2,"0"		;Just a zero?
	JUMPE T2,STRPDT		;Yes. No real date here
	HRROI T1,DATBUF		;Date/time are in DATBUF
	SETZM T2		;No format flags
	IDTIM			;Read the date and time
	JRST LODERR		;Failed. Report error
	MOVE T1,JFN		;Get back the file JFN and continue
STRPDT:	MOVEM T2,EBUF+.CDPDT

;Copy password expiration date

	CALL SCNSPC
	 JRST INPERR
	HRROI T2,DATBUF		;Buffer for this string
	MOVEI T3,^D80		;Read a max of 80. characters
	MOVEI T4,12		;Terminate on a line feed
	SIN			;Get this line into the buffer
	 ERJMP LODERR		;Bad file format
	MOVE T3,[POINT 7,DATBUF] ;Point at the buffer
	ILDB T2,T3		;Get a byte
	SUBI T2,"0"		;Just a zero?
	JUMPE T2,STRPED		;Yes. No real date here
	HRROI T1,DATBUF		;Date/time are in DATBUF
	SETZM T2		;No format flags
	IDTIM			;Read the date and time
	JRST LODERR		;Failed. Report error
	MOVE T1,JFN		;Get back the file JFN and continue
STRPED:	MOVEM T2,EBUF+.CDPED

;Copy password use data

	CALL SCNSPC
	 JRST INPERR
	MOVEI T3,^D10		;Get the Current use count
	NIN%
	 JRST [	CAIE T3,IFIXX3	;Overflow?
		     JRST LODERR
		     JRST .+1]	;Yes, tolerate it
	HRLM T2,EBUF+.CDPMU
	BIN			;NIN read first comma, now read second
	MOVEI T3,^D10
	NIN%			;Get the maximum use count
	 JRST [	CAIE T3,IFIXX3	;Overflow?
		JRST LODERR
		JRST .+1]	;Yes, tolerate it
	HRRM T2,EBUF+.CDPMU

;Copy TOPS10 project-programmer number

	CALL SCNSPC
	 JRST INPERR
	MOVEI T3,^D8		;Get the project number
	NIN%
	 JRST [	CAIE T3,IFIXX3	;Overflow?
		JRST LODERR
		JRST .+1]	;Yes, tolerate it
	HRLM T2,EBUF+.CDPPN
	BIN			;NIN read first comma, now read second
	MOVEI T3,^D8
	NIN%			;Get the maximum use count
	 JRST [	CAIE T3,IFIXX3	;Overflow?
		JRST LODERR
		JRST .+1]	;Yes, tolerate it
	HRRM T2,EBUF+.CDPPN

;WITH THE DATA TAKEN FROM THE INPUT FILE, DO A CRDIR TO CREATE THE
;DESIRED DIRECTORY

	;DO NOT UPDATE QUOTA, PASSWORDS ENCRYPTED
	MOVX T1,CD%NSQ+CD%PEN+CD%PED+CD%PMU+CD%PPN
	MOVE T2,EBUF+.CDNUM	;SYSTEM DIRECTORIES ALWAYS GET CHANGED
	CAILE T2,SYSMAX		;SO IS THIS ONE?
	SKIPE FRCSWI		;[7.1154]OR ARE WE FORCING CHANGES?
	SKIPA			;[7.1154]SYSTEM OR FORCING. DON'T LIGHT CD%NCE
	TXO T1,CD%NCE		;[7.1154]NOT SYSTEM AND NOT FORCING CHANGES
	HRRI T1,EBUFLN		;GET LENGTH OF ARG BLOCK
	MOVEM T1,.CDLEN+EBUF	;SET FLAGS IN BLOCK
	HRROI T1,NAMBUF
	MOVE T2,[XWD 777776,EBUF] ;INDICATE ALL DATA IS TO BE USED
	CRDIR
	 ERJMP LODERR
	MOVEM T1,USERNO		;SAVE FOR ^A WATCHER
	JRST LODUSR

LODERR:	MOVEI T1,.FHSLF		;GET ERROR NUMBER
	GETER
	HRRZ T1,T2		;GET ERROR ONLY
	CAIN T1,CRDIX8		;IS IT INVALID DIR #?
	JRST [ HRROI T1,NAMBUF	;YES, TRY FOR DEFAULT
		MOVE T2,[XWD 773776,EBUF]
		CRDIR
		 ERJMP .+1
		MOVEM T1,USERNO
		JRST LODUSR]
	MOVEI 1,.PRIOU
	HRLOI 2,.FHSLF
	SETZ 3,
	ERSTR
	 JRST [	HRROI 1,[ASCIZ /ERSTR: UNDEFINED ERROR NUMBER - /]
		JRST LODER1]
	 JRST [	HRROI 1,[ASCIZ /ERSTR: INTERNAL CONFUSION - /]
		JRST LODER1]
	HRROI 1,[ASCIZ / - /]
LODER1:	PSOUT
	HRROI 1,NAMBUF
	PSOUT
	HRROI 1,[ASCIZ /
/]
	PSOUT
	JRST LODUSR

;NULL FOUND. SEE IF END OF FILE

LODEND:	GTSTS
	TXNE T2,GS%EOF		;END OF FILE?
	JRST DONE		;YES - THROUGH
INPERR:	TMSG <?Error while reading - >
	MOVEI T1,.PRIOU
	MOVE T2,JFN
	MOVEI T3,0		;DEFAULTS
	JFNS
	TMSG <
>
	JRST PARSE		;RESTART

RDSTR:	BIN
	 ERJMP [RET]
	CAIN 2,.CHCRT		;CARRAIGE RETURN?
	JRST RDSTR		;YES, IGNORE IT
	CAIN 2,.CHLFD
	SETZ 2,			;APPEND NULL ON END OF STRING
	IDPB 2,5
	JUMPN 2,RDSTR
	RETSKP

SCNSPC:	BIN
	 ERJMP [RET]
	CAIE 2," "
	JRST SCNSPC
	RETSKP

;ROUTINE TO LOCATE USER NAME IN FILE

FNDUSR:	MOVE T1,JFN		;INPUT JFN
FNDUS1:	BIN
	 ERJMP [RET]		;MAYBE EOF
	CAIN T2,"!"		;CHECK FOR OLD STYLE NAME
	JRST FNDOLD		;IT IS - HANDLE IT
	CAIE T2,"&"		;NEW STYLE DELIMITER
	JRST FNDUS1		;NEITHER - KEEP LOOKING
	MOVE 5,NAMPTR		;GET POINTER
	TLC 5,-1		;CHECK IF STR NAME GIVEN
	TLCN 5,-1
	JRST [	HRLI 5,(<POINT 7,0>)
		CALLRET RDSTR]	;FETCH NAME
FNDUS2:	BIN			;STR NAME GIVEN - SKIP ONE IN FILE
	 ERJMP [RET]
	CAIE T2,":"
	JRST FNDUS2		;LOOP TILL COLON SEEN
	CALLRET RDSTR		;FETCH REMAINDER AND RETURN

FNDOLD:	MOVE 5,NAMPTR		;GET POINTER
	TLC 5,-1		;CHECK IF STR NAME GIVEN
	TLCN 5,-1
	HRLI 5,(<POINT 7,0>)
	MOVEI T2,"<"		;MUST ADD DIR DELIMS TO OLD NAMES
	IDPB T2,5
	CALL RDSTR		;FETCH REMAINDER OF NAME
	 RET			;ERROR
	MOVEI T2,">"		;APPEND CLOSING DELIM
	DPB T2,5		;OVER NULL
	MOVEI T2,0
	IDPB T2,5		;APPEND NULL
	RETSKP			;GOOD RETURN
; ROUTINE TO LOAD A GROUP

; ACCEPTS IN GB/	ADDRESS OF GROUP BLOCK
;			CALL LODGRP
; RETURNS		+1 ALWAYS


LODGRP:	CALL SCNSPC		;MOVE INPUT POINTER TO FIRST GROUP
	MOVE 1,JFN		;GET INPUT JFN
	MOVEI P1,1(GB)		;GET ADR OF GROUP BLOCK+1
	MOVEI 3,^D10		;USE DECIMAL RADIX

LODGP1:	NIN			;GET A GROUP #
	 JRST LODGP2		;MUST BE END-OF-LIST
	MOVEM 2,(P1)		;STORE GROUP #
	JUMPE 2,LODGP2		;GO STORE COUNT IF END-OF-LIST
	CAIL P1,GRPSIZ-1(GB)	;IS ENTIRE GROUP BLOCK FULL ?
	JRST LODGP3		;YES, ISSUE ERROR MESSAGE
	AOJA P1,LODGP1		;GO DO NEXT PAIR OF GROUPS

LODGP2:	SUB P1,GB		;COMPUTE # OF WORDS USED IN BLOCK
	MOVEM P1,(GB)		;STORE # OF WORDS USED
	RET			;RETURN TO WHENCE WE CAME ...

LODGP3:	TMSG <
? GROUP BLOCK TOO SMALL, ABORTING ...
>
	HALTF			;QUIT
	JRST .-1
;PROCESSING OF FILE COMPLETE (LOAD OR DUMP). CLOSE FILE

DONE:	SETZM USERNO		;SAY NOTHING
	MOVE 1,JFN
	CLOSF
	 JFCL
	TMSG <
DONE.
>
	JRST PARSE3
;INTERUPT PROCESSING

LEVTAB:	RET1
	RET2
	RET3

CHNTAB:	2,,BADINT
	3,,SUMINT
REPEAT ^D34,<
	2,,BADINT
>

;USER TYPED CTRL/A TO SEE WHAT DIRECTORY WAS BEING DONE.  IF ANY,
;PRINT ITS NAME

SUMINT:	SKIPN USERNO		;ANYTHING TO WATCH
	DEBRK			;NO
	PUSH P,T1		;SAVE REGS
	PUSH P,T2
	PUSH P,T3
	TMSG < Working on directory >
	MOVEI T1,.PRIOU
	MOVE T2,USERNO
	DIRST			;PRINT USER NAME
	 JFCL			;TOUGH
	MOVEI T1,.CHCRT		;CARRIAGE RETURN
	PBOUT
	MOVEI T1,.CHLFD
	PBOUT
	POP P,T3		;RESTOR
	POP P,T2
	POP P,T1
	DEBRK			;EXIT INT

BADINT:	PUSH P,T1
	TMSG < Unexpected interupt - ignored...
>
	POP P,T1
	DEBRK

	END <3,,ENTVEC>
