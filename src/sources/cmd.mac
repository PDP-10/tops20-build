; UPD ID= 2050, SNARK:<6.UTILITIES>CMD.MAC.2,  20-May-81 14:47:12 by HDAVIS
;TCO 6.1014 - MAKE IT WORK IN NON-ZERO SECTION
; UPD ID= 324, SNARK:<4.1.UTILITIES>CMD.MAC.4,  12-Mar-80 14:06:39 by OSMAN
;tco 4.1.1094 - display bad command if not from a terminal
; UPD ID= 245, SNARK:<4.1.UTILITIES>CMD.MAC.3,   5-Feb-80 10:39:19 by OSMAN
;IN DPROMP, DO CALLRET INSTEAD OF CALL AND RET
;<4.1.UTILITIES>CMD.MAC.2, 12-Nov-79 10:15:39, EDIT BY OSMAN
;TCO 4.1.1014 - Make REPARS external
;<4.UTILITIES>CMD.MAC.7,  3-Apr-79 13:53:15, EDIT BY OSMAN
;Make CMDERR global
;<4.UTILITIES>CMD.MAC.5,  2-Apr-79 14:59:11, EDIT BY OSMAN
;GIVE STACK OVERFLOW ERROR IF TOO MUCH USER STACK TO SAVE DURING PROMPT SETUP
;<4.UTILITIES>CMD.MAC.4, 10-Mar-79 13:43:33, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.UTILITIES>CMD.MAC.3, 14-Feb-79 10:44:19, EDIT BY OSMAN
;ADD CJFNLN
;<4.UTILITIES>CMD.MAC.2,  7-Jan-79 08:05:13, EDIT BY R.ACE
;Make CONFRM and NOISE preserve caller's T1-T4
;<4.UTILITIES>CMD.MAC.1, 27-Jul-78 10:08:39, EDIT BY OSMAN
;SET UP .CMIOJ IN CMDINI INSTEAD OF DPROMP

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1976,1977,1978,1979 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

IFNDEF REL,<REL==0>		;DEFAULT IS UNIVERSAL

IFE REL,<
	UNIVERSAL CMD
	EXTERNAL RFIELD,CMDINI,CFIELD,CMDERR,CMDER1,DPROMPT,RFLDE,NOIRTN,CFMRTN,REPARS
>
IFN REL,<
	TITLE CMD
>
	SEARCH MONSYM,MACSYM
	SALL


;AC DEFINITIONS

A=1		;A-D ARE TEMPORARY
B=2
C=3
D=4

P1=10		;P1-P4 ARE SUPPOSEDLY PRESERVED THROUGH SUBROUTINE CALLS
P2=11
P3=12
P4=13

CX=16		;USED BY SUPPORT CODE
P=17		;STACK POINTER
SUBTTL MACRO DEFINITIONS

;MACRO TO PROMPT FOR COMMAND

DEFINE PROMPT (MESSAGE) <
	HRROI A,[ASCIZ MESSAGE]
	CALL DPROMPT
>

;MACRO TO PRINT GUIDEWORDS

DEFINE NOISE (SHT) <
	HRROI CX,[ASCIZ\SHT\]
	CALL NOIRTN
>

;MACRO TO REQUIRE CONFIRMATION

DEFINE CONFRM <
	CALL CFMRTN
>

;MACRO TO MAKE TABLE ENTRY

DEFINE T (WORD,ADDRES) <
IFB <ADDRES>,<	[ASCIZ /WORD/],,.'WORD>
IFNB <ADDRES>,<	[ASCIZ /WORD/],,ADDRES>
>

;MACRO TO GENERATE COMND JSYS STORAGE

DEFINE CMDSTG <
CMDBLN==:<^D80*6>/5+1		;ROOM FOR SIX LINE COMMAND
CMDBUF::BLOCK CMDBLN
CMDACS::BLOCK 20		;SAVED AC'S FROM BEGINNING OF COMMAND LINE
ATMBLN==:CMDBLN
ATMBUF::BLOCK ATMBLN		;HOLDS LAST PARSED FIELD
SBK::	BLOCK 20		;COMND JSYS STATE BLOCK
CJFNLN==:20
CJFNBK::BLOCK CJFNLN		;GTJFN BLOCK FOR COMND JSYS
REPARA::0			;REPARSE ADDRESS FOR COMND
CMDFRM::0			;MARKS BOTTOM OF STACK
CMDPLN==:200			;AMOUNT OF STACK WE CAN SAVE
CMDPDL::BLOCK CMDPLN		;ROOM TO SAVE PDL
   >
SUBTTL SUPPORT ROUTINES FOR CMD

IFN REL,<

;SYMBOLS WHICH USER PROGRAM MUST DEFINE.  HE MAY CONVENIENTLY DO
;SO, HOWEVER, WITH CMDSTG MACRO DEFINED ABOVE.

EXTERNAL CMDBUF,CMDBLN		;USER'S COMMAND BUFFER AND LENGTH
EXTERNAL CMDACS			;BLOCK TO STORE AC'S WHEN COMMAND STARTS
EXTERNAL CMDPDL,CMDPLN		;PLACE TO SAVE STACK WHEN COMMAND STARTS
EXTERNAL SBK			;STATE BLOCK
EXTERNAL CJFNBK,CJFNLN		;JFN BLOCK
EXTERNAL ATMBUF,ATMBLN		;ATOM BUFFER AND LENGTH
EXTERNAL REPARA			;HOLDS REPARSE ADDRESS
EXTERNAL CMDFRM			;HOLDS BOTTOM OF STACK

;GET HERE ON COMND JSYS ERROR.  LET USER TRY AGAIN.

MESLN==30
CMDERR::	STKVAR <<ERMES,MESLN>>
	HRROI A,ERMES		;POINT TO MESSAGE AREA
	MOVE B,[.FHSLF,,-1]	;OURSELF, MOST RECENT ERROR
	MOVSI C,-MESLN*5	;MAXIMUM STRING WE'VE ROOM FOR
	ERSTR			;GET ERROR STRING
	 JFCL
	 JFCL			;UNEXPECTED ERRORS
	HRROI A,ERMES		;POINT AT STRING
	ESOUT			;PRINT IT IN STANDARD MANNER
	HLRZ A,.CMIOJ+SBK	;SEE WHERE COMMAND CAME FROM
	DVCHR			;GET DEVICE TYPE
	LOAD A,DV%TYP,B		;SEE IF INPUT FROM A TERMINAL
	CAIE A,.DVTTY		;IS IT?
	JRST [	LDB A,[350700,,.CMBFP+SBK]	;SEE IF ANY STRING TO TYPE
		JUMPE A,.+1	;IF NOT, NO DASH
		TMSG < - >
		MOVE A,.CMBFP+SBK	;NO, SO DISPLAY ROTTEN COMMAND
		PSOUT
		JRST .+1]
	;...

;COME HERE TO LET USER FIX HIS ERROR (BY TYPING ^H) OR ISSUE ANOTHER
;COMMAND
;PRINT ERROR MESSAGE BEFORE TRANSFERRING HERE

	;...
CMDER1::SOS REPARA		;MODIFY REPARSE ADDRESS SO REPROMPT HAPPENS
	JRST REPARS

;PLACE TO TRANSFER IF USER EDITS PREVIOUSLY PARSED FIELDS

REPARS::	MOVE P,CMDACS+P		;FIRST RESTORE P SO WE KNOW HOW MUCH STACK TO RESTORE
	HRLI A,CMDPDL		;RESTORE STACK FROM SAVED STACK
	HRR A,CMDFRM		;COPY TO BOTTOM OF STACK
	BLT A,(P)		;RESTORE THE STACK
	MOVSI 16,CMDACS		;MAKE BLT POINTER
	BLT 16,16		;RESTORE REST OF AC'S
	JRST @REPARA		;TRANSFER BACK TO JUST AFTER .CMINI CALL

;ROUTINE TO PROMPT FOR NEW COMMAND OR NEW PROMPT LINE OF COMMAND.
;CALL THIS ROUTINE WITH POINTER TO PROMPT IN A, OR 0 IF NO PROMPT.

DPROMP::CAIN A,0		;ANY PROMPT?
	HRROI A,[0]		;NO, POINT TO A NULL STRING
	MOVEM A,SBK+.CMRTY	;SAVE POINTER TO PROMPT
	POP P,REPARA		;REMEMBER REPARSE ADDRESS
	DMOVEM 0,CMDACS+0	;SAVE AC'S
	MOVE 1,[2,,CMDACS+2]
	BLT 1,CMDACS+17
	HRL A,CMDFRM		;SAVE FROM BOTTOM OF STACK
	HRRI A,CMDPDL		;MOVE DATA TO COMND PDL AREA
	HRRZ B,P		;SEE WHERE TOP OF STACK IS NOW
	SUB B,CMDFRM		;CALCULATE NUMBER OF WORDS
	MOVE C,[IOWD CMDPLN,CMDPDL]	;GET STACK POINTER TO BEGINNING OF SAVED STACK
	HRRZ B,B		;CLEAR LEFT HALF
	ADJSP C,(B)		;GENERATE ERROR IF TOO MUCH STACK TO SAVE
	BLT A,CMDPDL(B)		;SAVE THE STACK
	PUSH P,REPARA		;MAKE STACK LIKE IT WAS
	MOVEI A,[FLDDB. .CMINI]	;TYPE PROMPT
	CALLRET RFIELD		;TYPE PROMPT AND RETURN TO CALLER

;READ A FIELD ROUTINE.  GIVE IT ADDRESS OF FUNCTION BLOCK IN A.
;JRSTS TO CMDERR IF ERROR.  A, B, AND C WILL HAVE
;RESULT OF COMND JSYS IN THEM.

RFIELD::CALL RFLDE		;READ FIELD, SKIP IF SUCCESS
	 JRST CMDERR		;FAILED, GO PROCESS ERROR
	RET			;SUCCESS

;ROUTINE TO READ A FIELD AND SKIP IFF SUCCESSFUL.  A, B, AND C WILL HAVE
;RESULT OF COMND JSYS IN THEM UPON RETURN.

RFLDE::	MOVE B,A		;PUT FUNCTION BLOCK POINTER IN B
	MOVEI A,SBK		;POINTER TO STATE BLOCK IN A
	COMND			;READ FIELD OF COMND
	 ERJMP R		;ERROR IN COMND JSYS
	TXNE A,CM%NOP		;DID COMMAND PARSE CORRECTLY?
	RET			;NO, SINGLE RETURN
	RETSKP			;YES, SKIP RETURN

;READ A FIELD AND REQUIRE CARRIAGE RETURN AFTER IT FOR CONFIRMATION

CFIELD::CALL RFIELD		;READ THE FIELD
	CONFRM			;GET CONFIRMATION
	RET			;RETURN TO CALLER

;COMND JSYS INITIALIZATION ROUTINE.  CALL ONLY ONCE AT BEGINNING OF
;PROGRAM.
;ALWAYS CALL THIS ROUTINE AT A LESS-THAN-OR-EQUALLY NESTED LOCATION
;WITHIN THE PROGRAM IN COMPARISON WITH ANY SUBSEQUENT CALL TO THE COMND
;JSYS EXECUTION ROUTINES

CMDINI::MOVEI A,REPARS		;REPARSE ADDRESS
	MOVEM A,SBK+.CMFLG
	HRLI A,100		;SOURCE OF COMMAND
	HRRI A,101		;REGULAR PRIMARY OUTPUT
	MOVEM A,SBK+.CMIOJ
	HRROI A,CMDBUF		;POINTER TO COMMAND BUFFER
	MOVEM A,SBK+.CMBFP
	MOVEM A,SBK+.CMPTR	;POINTER TO NEXT FIELD
	MOVEI A,CMDBLN*5	;ROOM FOR TYPIN
	MOVEM A,SBK+.CMCNT
	SETZM SBK+.CMINC	;NO UNPARSED CHARACTERS YET
	HRROI A,ATMBUF		;POINTER TO ATOM BUFFER
	MOVEM A,SBK+.CMABP
	MOVEI A,ATMBLN*5
	MOVEM A,SBK+.CMABC	;ROOM IN ATOM BUFFER
	MOVEI A,CJFNBK		;POINTER TO JFN BLOCK
	MOVEM A,SBK+.CMGJB
	MOVEM P,CMDFRM		;REMEMBER BEGINNING OF STACK
	RET

;ROUTINE TO GET CONFIRMATION

CFMRTN::PUSH P,A		;PRESERVE CALLER'S AC'S
	PUSH P,B
	PUSH P,C
	MOVEI A,[FLDDB. .CMCFM]
	CALL RFIELD		;PARSE CONFIRMATION
XPARX:	POP P,C
	POP P,B
	POP P,A
	RET

;ROUTINE TO PARSE GUIDE WORD TEXT
;CX/ STRING POINTER TO TEXT

NOIRTN::PUSH P,A		;SAVE AC'S
	PUSH P,B
	PUSH P,C
	PUSH P,[FLD(.CMNOI,CM%FNC)] ;.CMFNP WORD OF FDB
	PUSH P,CX		;.CMDAT WORD OF FDB
	MOVEI A,-1(P)		;GET ADDR OF FDB IN STACK
	CALL RFIELD
	ADJSP P,-2		;DELETE FDB FROM STACK
	JRST XPARX		;RESTORE A,B,C AND RETURN

   >	;END OF IFN REL

END
