TITLE DYNTRP -- Trap handling for dynamic library RTL

;
;	COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION 1984, 1986.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED  AND
;	COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH
;	THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE  OR
;	ANY  OTHER  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE
;	AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE
;	SOFTWARE IS HEREBY TRANSFERRED.
;
;	THE INFORMATION IN THIS SOFTWARE IS  SUBJECT  TO  CHANGE  WITHOUT
;	NOTICE  AND  SHOULD  NOT  BE CONSTRUED AS A COMMITMENT BY DIGITAL
;	EQUIPMENT CORPORATION.
;
;	DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF
;	ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;

SEARCH DYNSYM, DDBSYM, MONSYM, MACSYM
SALL

EXTERNAL SG$SIG, RTLERS, SG$DLG

COMMENT \

***** Begin Revision History *****

V1.0

(stolen from MTHLIB 1.1(3243)

V1.1

;.EDIT 50	Formally go to version 1.1, update copyright, insert V1.1
;			development changes (previously V2)
;		DDB,15-Jan-85,SPR:NONE

***** End Revision History *****

\

	SEGMENT	CODE

COMMENT	\

DESCRIPTION OF "TRAPS" PROGRAM FOR MATHLIB-

I. THE PURPOSE OF THE TRAPS PROGRAM IS DO ERROR DETECTION,
   CORRECTION, AND REPORTING WHEN ARITHMETIC FAULTS OCCUR
   DURING THE EXECUTION OF FORTRAN PROGRAMS.

II. THE TRAPS PROGRAM CONSISTS OF THREE DISTINCT PARTS:

	A. %TRPINI
		1. CALLING SEQUENCE- PUSHJ P,%TRPINI
		2. PROCESSOR AND MONITOR TRAPPING ON OVERFLOW (PC WORD
		      BIT 0) IS ENABLED

	B. ERRSET Removed from DYNTRP

	C. OVTRP IS THE USER-MODE INTERRUPT ROUTINE WHICH IS STARTED
	   BY THE MONITOR WHEN AN ARITHMETIC FAULT OCCURS.
		1. The PC word (with the address+1 of the instruction
		      causing the trap) is stored in PC.
		2. FOR FLOATING POINT INSTRUCTIONS
			A. FOR OVERFLOWS AND DIVIDE CHECKS,
			   THE FAULTY ANSWER IS PATCHED
			   TO BE PLUS OR MINUS (THE SIGN WILL BE THAT
			   OF THE CORRECT ANSWER)THE LARGEST POSSIBLE
			   NUMBER.
			B. FOR UNDERFLOWS, THE FAULTY ANSWER IS NORMALLY
			   PATCHED TO BE 0. HOWEVER, IF THE INSTRUCTION
			   FOLLOWING THE TRAPPING INSTRUCTION IS A JFCL
			   WITH BIT 16 (XR2) SET, THE ANSWER WILL BE
			   UN-NORMALIZED ENOUGH TO BRING THE EXPONENT
			   BACK INTO RANGE.

		3. For integer instructions, no attempt is made to fix
		   up the faulty result. The problem is with the instructions
		   AOJX, AOSX, SOJX, and SOSX.  These can modify the PC
		   and overflow.  The new PC stored by the overflow trap
		   does not point to the instruction that overflowed, so
		   the recovery code will "fix" up a random instruction.  The
		   probability of this occurrence is small, but if it does
		   happen there is no way to limit the consequences.
		   The only available solution is to not touch any integer	
		   overflow.

		4. IF THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION
		      IS JFCL
		      A. DO NOT TYPE AN ERROR MESSAGE
		      B. DO NOT INCREMENT THE TRAP COUNTER ENTRY
		      C. IF ANY FLAG BITS ARE ON (9-12), IMMEDIATELY
			 RETURN TO THE PROGRAM WITHOUT CLEARING THE
			 FLAGS, AS IF THERE WERE NO TRAP HANDLER.
		      D. IF THE ADDRESS (BITS 18-35) OF THE JFCL
			 ARE NON-ZERO, THE INTERRUPTED PROGRAM WILL
			 BE RESTARTED AT THE ADDRESS OF THE JFCL
			 (THE @ AND INDEX FIELDS ARE IGNORED FOR
			 THE EFFECTIVE ADDRESS).
		      E. IF THE ADDRESS OF THE JFCL IS ZERO, THE
			 INTERRUPTED PROGRAM WILL BE RESTARTED AT
			 THE JFCL

		5. IF THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION
		      IS NOT JFCL

		     A. INCREMENT THE TRAP COUNTER ENTRY
		     B. TYPE AN ERROR MESSAGE WITH THE FOLLOWING INFORMATION:
				FLOATING OR INTEGER FAULT
				OVERFLOW, UNDERFLOW, OR DIVIDE CHECK
				ADDRESS OF FAULTING INSTRUCTION
		     C. IF A USER SUBROUTINE SUBR IS SPECIFIED BY A PREVIOUS
			CALL TO ERRSET (SEE ABOVE), THE TRAP HANDLER
			SIMULATES A CALL TO THE SUBROUTINE:

			CALL SUBR (TRPNUM,PC,NUM2,VARTYP,UNFXD,FIXED)

			WHERE TRPNUM IS THE TRAP NUMBER, PC IS THE
			LOCATION OF THE TRAP RETURNED BY THE
			MONITOR (WHICH MAY BE THE ADDRESS OF AN
			XCT OR UUO WHICH THEN EXECUTED THE ACTUAL
			INSTRUCTION TRAPPED), NUM2 IS A 2ND ERROR NUMBER
			RESERVED FOR FUTURE USE, VARTYP IS THE TYPE CODE
			OF THE VARIABLE MODIFIED BY THE TRAPPED 
			INSTRUCTION, UNFXD IS THE UNFIXED VALUE
			OF THE VARIABLE, AND FIXED IS THE FORTRAN
			FIXED VALUE. FORTRP USES THE VALUE RETURNED
			IN FIXED, SO THAT THE USER MAY SUBSTITUTE
			FOR THE FORTRAN FIXUP. NOTE THAT WHILE INTEGER
			OVERFLOWS ARE TRAPPED, FIXUPS ARE NOT DONE.
			(SEE NOTE ABOVE REGARDING INTEGER INSTRUCTIONS.)

		     D. THE INTERRUPTED PROGRAM WILL BE RESTARTED AT
			THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION

		     E. THE PROCESSOR FLAGS (PC WORD FLAGS) ARE CLEARED
			EXCEPT FOR CRY0, CRY1, AND USER IOT.

		     F. THE INTERRUPTED PROGRAM IS RESTARTED
III. LIMITATIONS


	A.  Fixups are not made for KA-format double precision
		numbers.  The instructions FADL, FSBL, FMPL, FDVL,
		UFA, and DFN are not recognized as requiring fixups.

	B. THE MEMORY FIX UPS FOR THE FLOATING POINT INSTRUCTIONS
	   WILL NOT WORK PROPERLY IF THE ANSWER IS STORED INDEXED
	   BY 17 (THE PUSH DOWN POINTER). EXAMPLES:

			FADRM AC,(17)
			FMPRB AC,-2(17)
			FDVM  AC,+1(17)

	C. MOVNX and MOVMX are integer instructions and will have
	   get integer fixups if they cause overflow.  These
	   instructions can't overflow when dealing with normalized
	   floating point numbers.

	D. THE TRAPPING INSTRUCTION MUST NOT BE IN AC 0.

	F. THE SIGN OF F.P. DIVIDE CHECK FIX UPS WILL BE CORRECT
	    ONLY WHEN DIVIDING BY ZERO. (THIS IMPLIES THAT THE
	    ARGUMENTS FOR DIVIDE CHECKS SHOULD BE NORMALIZED.)

	G. Instructions that store to BOTH AC AND MEMORY will fix up
	   only the AC destination.
\


SUBTTL %TRPINI -- Initialize trapping

;PC FLAGS

;THESE FLAGS SHOULD BE DEFINED IN FORPRM INSTEAD
UBITS==PC%USR+PC%UIO		;FOR NOW, THE FLAGS WE WANT NOT
				;TO TURN OFF. WE REALLY
				;WANT TO JUST TURN OFF
				;THE FLAGS WE ARE INTERESTED IN


;ENTRY POINT TO INITALIZE TRAP HANDLER

%TRPIN::
	MOVX T1, UBITS
	MOVEM T1, TRPBLK
	XMOVEI T1, SETRAP
	MOVEM T1, TRPBLK+1
	XJRSTF TRPBLK

SETRAP:	XMOVEI	T1,OVTRP	;SET TRAP ADDRESS IN CONTROL BLOCK
	MOVEM	T1,NPC

	MOVEI	T1,.FHSLF	;THIS FORK
	MOVEI	T2,.SWART	;SET ARITHMETIC TRAP ADDRESS
	XMOVEI	T3,TRPBLK	;POINT TO CONTROL BLOCK
	SWTRP%			;TELL MONITOR
	POPJ	P,		;DONE


SUBTTL OVTRP -- Actual trap service routine

;HERE ON OVERFLOW TRAP WITH TRPBLK FILLED IN

OVTRP:	DMOVEM	T0,ACS		;SAVE T0-T1

;HERE ON ANY APR TRAP
;ACS T0-T1 ARE SAVED

;CHECK HERE IF WE GOT A TRAP WITHIN A TRAP ROUTINE (FATAL).
	MOVE	T0,PC		;GET PC OF TRAP + 1
	SUBI	T0,1		;GET PC OF TRAP
	MOVEM	T0,%ERRPC	;SAVE FOR ERROR REPORTING
	CAIG	T0, 777777	;Skip if trap not in section zero
	  JRST MINRET		;Return without doing anything from S0 trap
	SKIPN	%TRFLG		;Skip if error -- trap within a trap
	  JRST TRAPOK		;No error, continue

; Error -- trap detected while we were within a trap
	PUSH P, %ERRPC		;PC of trapping instruction
	PUSH P, [1]
	PUSH P, [SG$TRP]
	CALL RTLERS		;Build SG block
	CALL SG$SIG		;Send it
NOCONT:	TMSG <
?? Can't continue from SEVERE error
?? Program terminated due to previous error
>
	HALTF%
	JRST NOCONT

;[JLC]CHECK THE INSTRUCTION TO BE EXECUTED AFTER THE TRAPPED ONE. IF
;IT IS JFCL WITH FLAGS, RETURN TO THE USER PROGRAM WITHOUT TURNING OFF
;THE FLAGS.

TRAPOK:	HLRZ	T0,@PC		;GET INSTRUCTION AFTER TRAP
	TRZ	T0,37		;SHUT OFF I AND X
	TRZN	T0,740		;ANY AC BITS?
	 JRST	NOTJF		;NO. CAN'T BE JFCL WITH FLAGS
	CAIE	T0,(JFCL)	;[3243] YES. IS IT A JFCL?
	 JRST	NOTJF		;[3243] NO, GO HANDLE THE TRAP
	DMOVE	T0,ACS		;[3243] YES, RESTORE ACS AND RETURN NOW
	JRST	@PC		;[3243] WITHOUT SETTING ANY FLAGS

NOTJF:	SETOM	%TRFLG		;SET FLAG FOR INSIDE TRAP ROUTINE
	DMOVEM	T2,ACS+T2	;SAVE T2-T3
				;MAGIC WARNING: T3 CAN ONLY BE USED IN
				;very special (restricted) ways.  Consider
				;how two-word AC operands in T3,T4 are
				;handled.  Briefly, even though T3 is
				;saved it shouldn't be used in new ways.

	LDB	T1,[POINT 9,INST,26] ;GET OPCODE OF TRAP INSTRUCTION
	CAIL	T1,100		;OUTSIDE TABLE RANGE?
	CAILE	T1,377
	  MOVEI	T1,100		;YES, SET TO INNOCUOUS TABLE ENTRY
	IDIVI	T1,4		;4 BYTES PER WORD
	LDB	T1,BPTAB(T2)	;GET FLAG BITS FOR THIS INSTRUCTION
	JUMPE	T1,XRET		;INSTRUCTION CAN'T OVERFLOW, DON'T TRY FIXUPS

	LDB	T2,[POINT 4,INST,30] ;GET AC FIELD OF INSTRUCTION
	CAIG	T2,T3		;DOES INST USE ACS T0-T3?
	 XMOVEI	T2,ACS(T2)	;YES, RELOCATE TO SAVED ACS
	MOVEM	T2,AC		;SAVE AC ADDRESS OF INSTRUCTION

	MOVE	T2,E		;GET EFFECTIVE ADDRESS
	CAIG	T2,T3		;IN SAVED ACS?
	 XMOVEI	T2,ACS(T2)	;YES, RELOCATE
	MOVEM	T2,E

	CAIE	T1,SP		;SPECIAL INSTRUCTION?
	  JRST	SPCONT		;NO. NORMAL INST

;SPECIAL CASES (EXTEND INSTRUCTIONS, XCT)
;[JLC] FOR FIX, FIXR, PUT THE UNFIXED RESULT (A REAL VALUE) IN THE AC

SPINST:	LDB	T1,[POINT 9,INST,26] ;GET OPCODE AGAIN
	CAIN	T1,(<XCT>B9)	;XCT INSTRUCTION?
	  JRST	SPXCT		;YES, GO HANDLE
	CAIN	T1,(<EXTEND>B9)	;EXTEND?
	 JRST	SPEXT		;YES

;MUST BE A FIX OR FIXR
SPFIX:	MOVE	T0,@E		;GET THE UNFIXED QUANTITY
	MOVEM	T0,@AC		;PRETEND THE AC GOT THE UNFIXED VALUE
	MOVEI	T1,SPRA		;TELL THE USER IT'S A REAL VALUE
	JRST	SPCONT		;AND CONTINUE

SPEXT:	MOVE	T1,ACS+T1	;RESTORE NONZERO ACS
	DMOVE	T2,ACS+T2
	MOVE	T0,@E		;GET EXTENDED INST
	XMOVEI	T1,@T0		;GET ITS EFFECTIVE ADDRESS
	CAIG	T1,T3		;IN SAVED ACS?
	 XMOVEI	T1,ACS(T1)	;YES, RELOCATE
	MOVEM	T1,E		;Store real E

	LDB	T1,[POINT 9,T0,8] ;GET EXTEND OPCODE
	CAIL	T1,020		;OUTSIDE TABLE RANGE?
	CAILE	T1,031
	  MOVEI	T1,020		;YES, SET TO INNOCUOUS TABLE ENTRY
	ADDI	T1,400-020	;OFFSET TO END OF MAIN TABLE
	IDIVI	T1,4		;9 BYTES PER WORD
	LDB	T1,BPTAB(T2)	;GET FLAG BITS FOR INSTRUCTION
	JUMPE	T1,XRET		;IF INST CAN'T OVERFLOW, DON'T TRY FIXUP

	TRZN	T1,WRONGBIT	;DOES INST LEAVE RESULT IN WRONG OPERAND?
	  JRST	SPCONT		;NO, FINE
	MOVE	T0,@E		;GET OPERAND
	MOVEM	T0,@AC		;STORE IN AC FOR SIGN FIXUP
	JRST	SPCONT		;GO CONTINUE AS IF NORMAL INST

SPXCT:	MOVE	T1,ACS+T1	;RESTORE NONZERO ACS
	DMOVE	T2,ACS+T2
	MOVE	T0,@E		;GET XCTED INST
	XMOVEI	T1,@T0		;GET ITS EFFECTIVE ADDRESS
	CAIG	T2,T3		;IN SAVED ACS?
	 XMOVEI	T2,ACS(T2)	;YES, RELOCATE
	HLRM	T0,INST		;STORE INST
	MOVEM	T1,E		;Store E
	JRST	TRAPOK		;START OVER

;[JLC] SAVE THE UNFIXED RESULT IN %UNFXD
; Needs T1/ Bits from opcode table
SPCONT:	MOVEI	T2,(T1)		;COPY FLAGS, ARG TYPE
	LSH	T2,-4		;GET JUST FLAGS
	ANDI	T2,7		;TURN OFF EXTRA BITS
	XCT	XLOAD(T2)	;GET UNFIXED RESULT
	DMOVEM	T2,%UNFXD	;SAVE FOR USER CALL
	HLLZ	T0,FLGS		;GET PC FLAGS
	TLNN	T0,(PC%FUF)	;FLOATING UNDERFLOW?
	  JRST	OV		;NO, GO HANDLE OVERFLOW

	SETZB	T2,T3		;SET FIXED-UP VALUE TO 0
	JRST	STRET		;DONE


;HERE ON FLOATING & INTEGER OVERFLOW AND DIVIDE CHECK
; Needs t0/ PC flags from trap
;	t1/ Bits from op-code table
OV:	TLNE	T0,(PC%NDV)	;NO DIVIDE?
	  JRST	DIVCHK		;YES. CHECK FOR 0/0
	TLNN	T0,(PC%FOV)	;NO. FLOATING OVERFLOW?
	  JRST	INTRET		;NO. INTEGER FIXUP IS DANGEROUS
	JRST	NDVCHK		;YES. GO ON WITH FIXUP

DIVCHK:	SKIPE	@AC		;DIVIDE BY ZERO. ZERO DIVIDEND?
	 JRST	NDVCHK		;NO.
	SETZB	T2,T3		;SET FIXED-UP VALUE TO 0
	JRST	STRET

NDVCHK:	TRNN	T1,ACBIT	;DID INST STORE ITS RESULT IN THE AC?
	TLNE	T0,(PC%NDV)	;YES, NO-DIVIDE, WHICH STORES NO RESULT?
	  SKIPA	T2,@AC		;NO, GET RESULT FROM AC
	MOVE	T2,@E		;ELSE GET RESULT FROM E

	TRZE	T1,WRONGBIT	;DID INST STORE WRONG SIGN?
	  TLC	T2,(1B0)	;YES, SET CORRECT SIGN

	JUMPL	T2,NEGOV	;IF CORRECT ANSWER NEGATIVE, GO SET -INF
	DMOVE	T2,[OCT 377777777777,377777777777] ;GET +INFINITY
	JRST	STRET

NEGOV:	TLNN	T0,(PC%FOV)	;FLOATING OVERFLOW?
	  JRST	INTOV		;NO, USE INTEGER -INFINITY

	MOVN	T2,[OCT 377777777777] ;FLOATING, GET FLOATING -INFINITY
	TRNE	T1,DPBIT	;WAS INSTRUCTION DOUBLE PRECISION?
	  DMOVN	T2,[OCT 377777777777,377777777777] ;YES, GET IT IN DP
	JRST	STRET		;GO STORE RESULT AND RETURN

INTOV:	DMOVE	T2,[OCT 400000000000,0] ;GET INTEGER -INFINITY

;[JLC]CALL TCALU, WHICH IF THE INSTRUCTION FOLLOWING THE TRAPPED
;INSTRUCTION IS NOT A JFCL, ISSUES THE ERROR MESSAGE (IF NOT OVER THE
;MESSAGE LIMIT) AND CALLS THE USER-SPECIFIED TRAP SUBROUTINE (IF ANY);
;THEN USE THE RETURNED VALUE OF %FIXED (WHICH WILL BE UNTOUCHED IF
;THE USER DOESN'T DO ANYTHING TO IT).
; Needs t1/ Flag bits from opcode table
;	t2-t3/ Fixed-up value
STRET:	DMOVEM	T2,%FIXED	;STORE FIXED RESULT
	PUSH P, T1
	PUSHJ	P,TCALU		;CALL USER TRAP ROUTINE
	POP P, T1
	DMOVE	T2,%FIXED	;GET FIXED RESULT
	LSH	T1,-4		;TOSS DATA TYPE, JUST GET FLAGS
	ANDI	T1,7		;TURN OFF EXTRA BITS
	XCT	XSTORE(T1)	;STORE ANSWER

;RESTORE SOME ACS, CLEAR THE PC FLAGS
XRET:
;	HRL	P, LHSP		;[3] DELETE Restore LH of SP
	DMOVE	T2,ACS+T2	;RESTORE T2-T3
	MOVSI	T1,(PC%OVF+PC%FOV+PC%FUF+PC%NDV) ;CLEAR OV, FOV, FUF, NDV
	ANDCAB	T1,FLGS
	SETZM	%TRFLG		;WE ARE NO LONGER IN A TRAP
MINRET:	DMOVE	T0,ACS		;RESTORE T0-T1
	XJRSTF	FLGS		;Return to user.

;INTEGER OVERFLOW RETURN - CALL TCALU TO ISSUE THE ERROR MSG AND
;CALL THE USER-SPECIFIED ROUTINE, BUT DO NOT USE THE FIXED-UP RESULT.
INTRET:	SETZM	%FIXED		;SET FIXED-UP VALUE TO 0
	SETZM	%FIXED+1
	PUSHJ	P,TCALU		;CALL USER ROUTINE
	JRST	XRET		;DON'T USE FIXED-UP VALUE

;[JLC] IF THE INST AFTER THE TRAP IS A JFCL WITH NO FLAGS, PROCEED TO DO
;THE STANDARD FORTRAN FIXUP. OTHERWISE, PRINT A MESSAGE AND
;CALL A USER TRAP ROUTINE VIA $TCALL.
TCALU:	MOVE	T0,@PC		;GET INSTRUCTION AFTER TRAP
	TLC	T0,(JFCL)	;SEE IF IT'S JFCL
	TLNN	T0,777000	;IS IT?
	 JRST	NOCALU		;YES. DON'T PRINT MSG OR CALL USER

; Save registers 4-5
	PUSH P, 4
	PUSH P, 5

	PUSH P, %ERRPC
	XMOVEI T0, %UNFXD
	PUSH P, T0
	XMOVEI T0, %FIXED
	PUSH P, T0
 	MOVEI	T2,(T1)		;GET FLAGS AGAIN
 	ANDI	T2,17		;GET VARIABLE TYPE
	PUSH P, T2
	PUSH P, [4]
 	SETZ	T2,		;CREATE AN INDEX
 	MOVE	T0,FLGS		;TESTING THE FLAGS
 	TLNE	T0,(PC%NDV)	;NO-DIVIDE?
 	 TRO	T2,1		;YES
 	TLNE	T0,(PC%FUF)	;FLOATING UNDERFLOW?
 	 TRO	T2,2		;YES
 	TLNE	T0,(PC%FOV)	;FLOATING OVERFLOW?
 	 TRO	T2,4		;YES
	PUSH P, TCALTB(T2)	;Select condition code
	CALL RTLERS		;Make a signal block, return in T1
	MOVX T0, SG%APR		;Set signal type
	MOVEM T0, .SGCLS(T1)	;into signal block
	CALL SG$SIG		;Signal it.  Continue if signal is continued
	CALL SG$DLG		;Throw away the signal block

; Restore registers 4-5
	POP P, 5
	POP P, 4

 	POPJ	P,

NOCALU:	TRNE	T0,-1		;ADDR IN JCFL?
	 HRRM	T0,PC		;YES. RETURN TO THAT ADDR
	POPJ	P,


SUBTTL Trap block and other impure storage

	SEGMENT	DATA

;SWTRP BLOCK, FILLED IN BY MONITOR OR MICROCODE ON OVERFLOW TRAP

TRPBLK:!
FLGS:!				;LH = PC FLAGS
INST:	BLOCK	1		;RH = LH(TRAP INSTRUCTION)
PC:	BLOCK	1		;PC+1 OF TRAP INSTRUCTION
E:	BLOCK	1		;E OF TRAP INSTRUCTION
NPC:	BLOCK	1		;NEW PC TO USE AT TRAP

AC:	BLOCK	1		;AC FIELD OF TRAP INSTRUCTION
ACS:	BLOCK	4		;TEMP SPACE FOR T0-T3

%TRFLG:	BLOCK 1			;Nonzero if we are within trap processing
%ERRPC:	BLOCK 1			;Save PC of trapping instruction for error reporting
%FIXED:	BLOCK 4
%UNFXD:	BLOCK 4
;LHSP:	BLOCK 1			;[3] DELETE Left half of SP on entry, sign-extended

SUBTTL Table of flag bits for every instruction that can overflow

	SEGMENT	CODE

;FLAG BITS FOR EVERY INSTRUCTION THAT CAN OVERFLOW
;[JLC] EXPANDED THE FLAG BYTE FOR EACH INSTRUCTION TO 9 BITS,
;TO ALLOW FOR THE VARIABLE TYPE CODE AND FOR A NEW BIT, NOT YET
;IMPLEMENTED, FOR THE AOS/SOS-CLASS INSTRUCTIONS, WHICH LEAVE
;THE RESULT IN MEMORY AND AN AC IF A NON-ZERO AC IS SPECIFIED.
;THIS IS NOT A PROBLEM FOR THE CURRENT PROCESSORS, SINCE INTEGER
;FIXUPS CANNOT BE DONE RELIABLY (SEE NOTES AT BEGINNING OF MODULE).

	DPBIT==1*20		;1 IF INST STORES 2-WORD RESULT
	ACBIT==2*20		;1 IF INST STORES RESULT IN AC
	MEMBIT==4*20		;1 IF INST STORES RESULT IN MEMORY
	WRONGBIT==10*20		;1 IF INST STORES RESULT WITH WRONG SIGN,
				;  FOR EXTEND MEANS RESULT NOT STORED IN AC
	BOTHBT==ACBIT+MEMBIT	;RESULT STORED IN BOTH AC AND MEMORY
	NZACBT==4*20		;1 IF INST STORES RESULT IN BOTH IF AC NONZERO
				;NOT HANDLED, AS INTEGER OVERFLOWS AREN'T FIXED

;ARG TYPE CODES

TP%UDF==0			;NOT SPECIFIED
TP%LOG==1			;LOGICAL
TP%INT==2			;INTEGER
TP%3==3				;UNDEFINED
TP%SPR==4			;SINGLE REAL
TP%5==5				;UNDEFINED
TP%SPO==6			;SINGLE OCTAL
TP%LBL==7			;STATEMENT LABEL
TP%DPR==10			;DOUBLE REAL
TP%DPI==11			;DOUBLE INTEGER
TP%DPO==12			;DOUBLE OCTAL
TP%DPX==13			;EXTENDED-EXPONENT DOUBLE REAL (G-FLOATING)
TP%CPX==14			;COMPLEX
TP%CHR==15			;CHARACTER
TP%16==16			;UNDEFINED
TP%LIT==17			;QUOTED LITERAL (ASCIZ)

	SPRA==TP%SPR+ACBIT	;SINGLE PRECISION REAL, RESULT IN AC
	SPRM==TP%SPR+MEMBIT	;SINGLE REAL, RESULT IN MEMORY
	SPRB==TP%SPR+BOTHBT	;SINGLE REAL, RESULT IN BOTH
	INTA==TP%INT+ACBIT	;INTEGER, RESULT IN AC
	INTM==TP%INT+MEMBIT	;INTEGER, RESULT IN MEMORY
	INTB==TP%INT+BOTHBT	;INTEGER, RESULT IN BOTH
	DPIA==TP%DPI+ACBIT+DPBIT  ;DOUBLE INTEGER, RESULT IN AC
	DPIM==TP%DPI+MEMBIT+DPBIT ;DOUBLE INTEGER, RESULT IN MEMORY
	DPIB==TP%DPI+BOTHBT+DPBIT ;DOUBLE INTEGER, RESULT IN BOTH
	DPRA==TP%DPR+ACBIT+DPBIT  ;DOUBLE REAL, RESULT IN AC
	DPRM==TP%DPR+MEMBIT+DPBIT ;DOUBLE REAL, RESULT IN MEMORY
	DPRB==TP%DPR+BOTHBT+DPBIT ;DOUBLE REAL, RESULT IN BOTH
	DPXA==TP%DPX+ACBIT+DPBIT  ;GDOUBLE REAL, RESULT IN AC
	DPXM==TP%DPX+MEMBIT+DPBIT ;GDOUBLE REAL, RESULT IN MEMORY
	DPXB==TP%DPX+BOTHBT+DPBIT ;GDOUBLE REAL, RESULT IN BOTH
	SPRAW==SPRA+WRONGBIT	;SPRA, RESULT HAS WRONG SIGN
	SPRMW==SPRM+WRONGBIT	;SPRM, RESULT HAS WRONG SIGN
	SPRBW==SPRB+WRONGBIT	;SPRB, RESULT HAS WRONG SIGN
	INTAW==INTA+WRONGBIT	;INTA, RESULT HAS WRONG SIGN
	INTMW==INTM+WRONGBIT	;INTM, RESULT HAS WRONG SIGN
	INTBW==INTB+WRONGBIT	;INTB, RESULT HAS WRONG SIGN
	INTNW==TP%INT+WRONGBIT+NZACBT	;INTEGER, WRONG SIGN, RESULT IN
					;BOTH IF NON-ZERO AC
	DPIAW==DPIA+WRONGBIT	;DPIA, RESULT HAS WRONG SIGN
	DPIMW==DPIM+WRONGBIT	;DPIM, RESULT HAS WRONG SIGN
	DPIBW==DPIB+WRONGBIT	;DPIB, RESULT HAS WRONG SIGN
	DPRAW==DPRA+WRONGBIT	;DPRA, RESULT HAS WRONG SIGN
	DPRMW==DPRM+WRONGBIT	;DPRM, RESULT HAS WRONG SIGN
	DPRBW==DPRB+WRONGBIT	;DPRB, RESULT HAS WRONG SIGN
	DPXAW==DPXA+WRONGBIT	;DPXA, RESULT HAS WRONG SIGN
	DPXMW==DPXM+WRONGBIT	;DPXM, RESULT HAS WRONG SIGN
	DPXBW==DPXB+WRONGBIT	;DPXB, RESULT HAS WRONG SIGN
	SP==1			;SPECIAL CASE, NOT COVERED ABOVE
	NOBIT==0		;NO BITS

BITS:	BYTE (9) NOBIT, NOBIT,  DPXA,  DPXA	;OPCODE	100 UJEN-GFSB
	BYTE (9) NOBIT, NOBIT,  DPXA,  DPXA	;	104 JSYS-GFDV
	BYTE (9)  DPRA,  DPRA,  DPRA,  DPRA	;	110 DFAD-DFDV
	BYTE (9) DPIAW, DPIAW, DPIAW,  DPIA	;	114 DADD-DDIV
	BYTE (9) NOBIT, DPIAW,    SP,    SP	;	120 DMOVE-EXTEND
	BYTE (9) NOBIT, DPIMW,    SP, NOBIT	;	124 DMOVEM-FLTR
	BYTE (9)  SPRA, NOBIT,  SPRA,  INTA	;	130 UFA-ADJBP
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	134 ILDB-DPB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	140 FAD-FADB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	144 FADR-FADRB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	150 FSB-FSBB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	154 FSBR-FSBRB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	160 FMP-FMPB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	164 FMPR-FMPRB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	170 FDV-FDVB
	BYTE (9)  SPRA,  SPRA,  SPRM,  SPRB	;	174 FDVR-FDVRB
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	200 MOVE-MOVES
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	204 MOVS-MOVSS
	BYTE (9) INTAW, NOBIT, INTMW, INTMW	;	210 MOVN-MOVNS
	BYTE (9) INTAW, NOBIT, INTMW, INTMW	;	214 MOVM-MOVMS
	BYTE (9)  INTA,  INTA,  INTM,  INTB	;	220 IMUL-IMULB
	BYTE (9)  DPIA,  DPIA,  DPIM,  DPIB	;	224 MUL-MULB
	BYTE (9)  INTA,  INTA,  INTM,  INTB	;	230 IDIV-IDIVB
	BYTE (9)  DPIA,  DPIA,  DPIM,  DPIB	;	234 DIV-DIVB
	BYTE (9)  INTA, NOBIT, NOBIT, NOBIT	;	240 ASH-JFFO
	BYTE (9)  INTA, NOBIT, NOBIT, NOBIT	;	244 ASHC-NONE
	BYTE (9) NOBIT, NOBIT,  INTA,  INTA	;	250 EXCH-AOBJN
	BYTE (9) NOBIT, NOBIT,    SP, NOBIT	;	254 JRST-MAP
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	260 PUSHJ-POPJ
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	264 JSR-JRA
	BYTE (9) INTAW, INTAW, INTMW, INTBW	;	270 ADD-ADDB
	BYTE (9) INTAW, INTAW, INTMW, INTBW	;	274 SUB-SUBB
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	300 CAI-CAILE
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	304 CAIA-CAIG
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	310 CAM-CAMG
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	314 CAMA-CAMGE
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	320 JUMP-JUMPLE
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	324 JUMPA-JUMPG
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	330 SKIP-SKIPLE
	BYTE (9) NOBIT, NOBIT, NOBIT, NOBIT	;	334 SKIPA-SKIPG
	BYTE (9) INTAW, INTAW, INTAW, INTAW	;	340 AOJ-AOJLE
	BYTE (9) INTAW, INTAW, INTAW, INTAW	;	344 AOJA-AOJG
	BYTE (9) INTNW, INTNW, INTNW, INTNW	;	350 AOS-AOSLE
	BYTE (9) INTNW, INTNW, INTNW, INTNW	;	354 AOSA-AOSG
	BYTE (9) INTAW, INTAW, INTAW, INTAW	;	360 SOJ-SOJLE
	BYTE (9) INTAW, INTAW, INTAW, INTAW	;	364 SOJA-SOJG
	BYTE (9) INTNW, INTNW, INTNW, INTNW	;	370 SOS-SOSLE
	BYTE (9) INTNW, INTNW, INTNW, INTNW	;	374 SOSA-SOSG
	BYTE (9) NOBIT, SPRAW, NOBIT, DPIAW	;EXTEND	020 XBLT-DGFIX
	BYTE (9) INTAW, DPIAW, INTAW, NOBIT	;EXTEND	024 GFIX-DGFLTR
	BYTE (9) NOBIT,  DPXA, NOBIT, NOBIT	;EXTEND	030 GFLTR,GFSC

BPTAB:	POINT	9,BITS-20(T1),8		;BYTE POINTERS, OFFSET BY 100 OCTAL
	POINT	9,BITS-20(T1),17
	POINT	9,BITS-20(T1),26
	POINT	9,BITS-20(T1),35

;TABLES INDEXED BY T1 (WITH FLAG BITS IN IT) TO ACCESS INSTRUCTION OPERANDS

XLOAD=.-2
	MOVE	T2,@AC		;SA
	DMOVE	T2,@AC		;DA
	MOVE	T2,@E		;SM
	DMOVE	T2,@E		;DM
	MOVE	T2,@AC		;SB
	DMOVE	T2,@AC		;DB

XSTORE=.-2
	MOVEM	T2,@AC		;SA
	DMOVEM	T2,@AC		;DA
	MOVEM	T2,@E		;SM
	DMOVEM	T2,@E		;DM
	PUSHJ	P,[MOVEM T2,@AC	;SB
		   MOVEM T2,@E
		   POPJ P,]
	PUSHJ	P,[DMOVEM T2,@AC ;DB
		   DMOVEM T2,@E
		   POPJ P,]

; Trap message condition code table
TCALTB:	SG$IOV			;000
	SG$IDC			;001	NDV
	0			;010	FXU		(impossible)
	0			;011	FXU, NDV	(impossible)
	SG$FOV			;100	FXO
	SG$FDC			;101	FXO, NDV
	SG$FUN			;110	FXO, FXU
	0			;111	FXO, FXU, NDV	(impossible)

	END
