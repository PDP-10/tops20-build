; *** Edit 256 to EDIT.MAC by EVANS on 14-Jul-86, for SPR #20840
; Add VT102 and any other documented terminal types not there, to the tables.
;Edit 254 to EDIT.MAC by LOMARTIRE on Wed 27-Mar-85, for SPR #20638
;		Fix a bug in edit 205 which did not check for EOF
;Edit 253 to EDIT.MAC by LOMARTIRE on Tue 20-Nov-84 - Add the PERUSE command.
;Edit 252 to EDIT.MAC by LOMARTIRE on Tue 24-Jul-84, for SPR #20248
;		Fix the L commmand broken by edit 246.  Edit 246 is now
;;		required for this fix to be correct.
;Edit 251 to EDIT.MAC by LOMARTIRE on Wed 9-Nov-83, for SPR #19694
;		Fix ^+n to return correct line number - not ^+n-1
;Edit 250 to EDIT.MAC by LOMARTIRE on Fri 10-Jun-83, for SPR #19186 - Allow /READONLY in SWITCH.INI
;Edit 249 to EDIT.MAC by LOMARTIRE on Thu 9-Jun-83, for SPR #18725
;		Allow substitution of vertical bar in C64 mode
;Edit 248 by LOMARTIRE on Wed 27-Apr-83, for SPR #18363
;		Fix "C^$ (FILE) filename,^,incr" so that ^ is converted right
; UPD ID= 64, FARK:<5-1-WORKING-SOURCES.UTILITIES>EDIT.MAC.247,   2-Dec-82 11:32:39 by LOMARTIRE
;Edit 247 - Allow G, E, B, /NAME: and /RUN: commands to be aborted via ^U
; UPD ID= 56, FARK:<5-1-WORKING-SOURCES.UTILITIES>EDIT.MAC.246,   4-Nov-82 11:31:12 by LOMARTIRE
;Edit 246 - Store entire filespec so that output directory is not ignored
; UPD ID= 55, FARK:<5-1-WORKING-SOURCES.UTILITIES>EDIT.MAC.245,   4-Nov-82 08:58:45 by LOMARTIRE
;Edit 245 - Allow character editing, recognition, and help for entry of
;filespec when EDIT is invoked without one and there is no saved filespec
;(improvement of edit 243)
; UPD ID= 44, FARK:<5-1-WORKING-SOURCES.UTILITIES>EDIT.MAC.244,  30-Sep-82 17:08:39 by LOMARTIRE
;Edit 244 - Fix T command to deal with entire pages correctly
; UPD ID= 42, FARK:<5-1-WORKING-SOURCES.UTILITIES>EDIT.MAC.6,  21-Sep-82 13:24:58 by LOMARTIRE
;Edit 243 - When EDIT is entered without a saved filespec, make the entry 
;of the filespec more friendly (allow character editing)
; UPD ID= 41, FARK:<5-1-WORKING-SOURCES.UTILITIES>EDIT.MAC.4,  17-Sep-82 17:40:43 by LOMARTIRE
;Edit 242 - Fix I* so it doesn't start at 49999 in empty pages
; UPD ID= 24, FARK:<5-WORKING-SOURCES.UTILITIES>EDIT.MAC.3,   1-Jun-82 17:14:42 by TSANG
;Edit 241 - set flag "DOENDF" off after line CKIND+2
; UPD ID= 20, FARK:<5-WORKING-SOURCES.UTILITIES>EDIT.MAC.2,   6-May-82 15:05:06 by KROSENBLUH
;edit 240 - fix so I* doesn't start with line 99999 on an empty page
; UPD ID= 81, SNARK:<5.UTILITIES>EDIT.MAC.239,  22-Feb-82 16:06:16 by KROSENBLUH
; UPD ID= 77, SNARK:<5.UTILITIES>EDIT.MAC.238,   1-Feb-82 14:32:50 by KROSENBLUH
;TCO 5.1712 - 5EDIT.MAC.36,  1-Feb-82 12:08:44, EDIT BY KROSENBLUH
;improve edit 223 for T command.
;TCO 5.1674 - 5EDIT.MAC.17, 14-Jan-82 16:09:06, EDIT BY KROSENBLUH
;Don't allow re-enter, but do allow continue after ^C from Ex or Gx command
;Also, fix up stuff broken by edit 202, around CNCREN.
;TCO 5.1664 - 5EDIT.MAC.11, 11-Jan-82 13:31:44, EDIT BY KROSENBLUH
;If EXCPFL is on, don't try to do the GTJFN in GTJFNX twice,
;because it can cause a wrong error message.
;TCO 5.1646 - EDIT.MAC.6, 31-Dec-81 13:29:40, EDIT BY KROSENBLUH
;At CKIND, save status of COMFLF, and reset it before leaving,
;so indirect files won't bomb.
;TCO 5.1645 - EDIT.MAC.10, 30-Dec-81 14:48:27, EDIT BY KROSENBLUH
;Discard spaces and tabs between "/" and switch-name. 
;TCO 5.1643 - EDIT.MAC.4, 23-Dec-81 11:57:58, EDIT BY KROSENBLUH
;Make sure EDIT-BUFFER.IN is deleted when quitting.
;TCO 5.1642 - EDIT.MAC.2, 22-Dec-81 16:55:35, EDIT BY KROSENBLUH
;Fix edit 214 so if RSCAN buffer is empty, user can ^C out. 
;<5.UTILITIES>EDIT.MAC.230, 28-Oct-81 15:00:01, EDIT BY GRANT
;Change major version to 5
;<ROSENBLUH>5-EDIT.MAC.10, 19-Oct-81 14:17:53, EDIT BY ROSENBLUH
;increase number of bytes we read from the rscan buffer to 999 (226)
;TCO 5.1585 - <ROSENBLUH>5-EDIT.MAC.6, 16-Oct-81 09:56:37, EDIT BY ROSENBLUH
;make message after a D command right.(225)
;TCO 5.1506 - <ROSENBLUH>EDIT.MAC.23, 14-Sep-81 13:28:14, EDIT BY ROSENBLUH
;dissallow copy from device tty: (224)
;TCO 5.1501 - <ROSENBLUH>EDIT.MAC.15, 10-Sep-81 11:58:27, EDIT BY ROSENBLUH
;make "C/<page>,<source>", and "I/<page>,<incr>" work (223)
;TCO 4.2623 - EDIT.MAC.7, 24-Aug-81 16:16:06, EDIT BY ROSENBLUH
;set jfn storage word to zero after a jfn is closed and released (222)
;TCO 4.2622 - EDIT.MAC.221 FIX REACTION TO "FULL DIRECTORY"
;TCO 4.2621 - EDIT.MAC.220 FIX ?INTERNAL CONFUSION WHEN ON LAST PAGE
;TCO 4.2620 - EDIT.MAC.217 FIX SO ALTER/INSERT MODE DOESN'T ECHO BACK ^E
;TCO 4.2619 - EDIT.MAC.216 ADD THREE NEW TERMINAL TYPES
;TCO 4.2618 - EDIT.MAC.215 FIX SO TYPEAHEAD ISN'T LOST AFTER INDIRECT FILE ENDS
;TCO 4.2617 EDIT.MAC.214 FIX SO "EDIT<CR>" TO EXEC DOESNT CAUSE EXIT (214)
;TCO 4.2616 EDIT.MAC.213 ADD COMMENT COMMAND (;) (213)
;TCO 4.2615 EDIT.MAC.212 FIX SO I* DOESNT GIVE 99999 ON EMPTY PAGE
; UPD ID= 360, FARK:<4-WORKING-SOURCES.UTILITIES>EDIT.MAC.6,   8-Jan-81 15:05:30 by SIMMONS
;TCO 5.1228 - EDIT.MAC.211 FIX FOR CONT WHEN NO ^C CAPBILITY WAS SET
; UPD ID= 359, FARK:<4-WORKING-SOURCES.UTILITIES>EDIT.MAC.4,   7-Jan-81 13:01:11 by SIMMONS
;TCO 5.1227 - EDIT.MAC.210 FIX FOR I.-1 WHEN AT FIRST LINE
; UPD ID= 139, FARK:<4-WORKING-SOURCES.UTILITIES>EDIT.MAC.3,  11-Aug-80 12:13:12 by SIMMONS
;TCO 5.1126 - EDIT.MAC.207 FIX FOR COPY TO CORRECT EDIT 206
; UPD ID= 41, FARK:<4-WORKING-SOURCES.UTILITIES>EDIT.MAC.2,   6-Jun-80 10:57:09 by SIMMONS
;TCO 4.1.1156 - EDIT.MAC.206 FIX TO ELIMINIATE TEMP FILE ON OUTPUT
;TCO 4.1.1144 - EDIT.MAC.205 FIX FOR F/F ON LINE TOO LONG
;TCO 4.1.1127 - EDIT.MAC.203 FIX F & S WHEN USED WITH ,E
;TCO 4.1.1102 - EDIT.MAC.202 FIX "E"/"R" COMMAND ON INTERRUPT WHEN IN SUBSTITUE MODE
;TCO 4.1.1058 - EDIT.MAC.201 FIX EOF SO LINE 100 CAN BE INSERTED/REFERENCED
;TCO 4.1.1054 - EDIT.MAC.200 FIX SO FORMFEEDS DON'T GET LOST
;TCO 4.1.1042 - EDIT.MAC.199 FIX SO "I" REMEBERS LAST INSERT
;TCO 4.1.1040 - EDIT.MAC.198  FIX BACKWARD DELETE IN ALTER MODE
;TCO 4.1.1038 - EDIT.MAC.197 Correct B command for DEV:<DIR>
;TCO 4.1.1004 - DO NOT ALLOW E<ESC> WHEN CREATING A FILE
;<4.UTILITIES>EDIT.MAC.196,  3-Jan-80 15:25:49, EDIT BY R.ACE
;UPDATE COPYRIGHT DATE
;<4.UTILITIES>EDIT.MAC.195,  29-oct-79 10:25:29, EDIT BY SIMMONS
;TCO 4.2558 - KEEP P COMMAND FROM REPRINTING THE LAST LINE PRINTED
;<4.UTILITIES>EDIT.MAC.194,  18-OCT-79 15:30:53, EDIT BY SIMMONS
;tco 4.2531 - ALLOW ECHO ON TERMINAL WHEN ^C IN ALTERMODE
;<4.UTILITIES>EDIT.MAC.193,  3-Jul-79 12:38:53, EDIT BY GRADY
;tco 4.2319 - allow wildcards in 'hlp:' device definition
;<4.UTILITIES>EDIT.MAC.192, 19-Apr-79 15:58:36, EDIT BY GRADY
;TCO 4.2236 - SEE TCO 3.1894 BELOW - PREVENT ILLEGAL INSTRUCTION TRAP
;<4.UTILITIES>EDIT.MAC.191, 10-Mar-79 13:54:40, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.UTILITIES>EDIT.MAC.190,  2-Jan-79 16:54:46, EDIT BY DBELL
;TCO 4.2145 - CLEAR UPTOPF ON ERRORS SO P^ DOESN'T GIVE "NO SUCH LINES"
;ERRORS AFTER AN INVALID INSERT COMMAND.
;<4.UTILITIES>EDIT.MAC.189, 20-Dec-78 16:09:24, EDIT BY DBELL
;TCO 4.2127 - CHECK FOR NONEXISTANT OUTPUT FILE AT DELOUT, SO A QUIT
;COMMAND AT THE WRONG TIME DOESN'T BLOW UP.
;<4.UTILITIES>EDIT.MAC.188, 20-Dec-78 13:02:32, EDIT BY DBELL
;REMOVE TEXTI BIT RD%RBF SINCE NOT USED ANYWAY
;<4.UTILITIES>EDIT.MAC.187, 12-Oct-78 14:01:58, EDIT BY DBELL
;TCO 4.2042 - FIX TAB OUTPUT PROBLEM IN "P" AND <LF> COMMANDS
;<4.UTILITIES>EDIT.MAC.186, 10-Oct-78 16:50:46, EDIT BY DBELL
;TCO 4.2040 - DON'T ALLOW WRITING OF TEMPORARY FILES
;<4.UTILITIES>EDIT.MAC.185,  4-Oct-78 11:57:07, EDIT BY DBELL
;TCO 4.2031 - MAKE DISK FULL INTERRUPT CODE CHECK RIGHT PC FOR "CAI"
;<4.UTILITIES>EDIT.MAC.184, 30-Sep-78 21:16:59, EDIT BY DBELL
;TCO 4.2028.  MAKE ALL LINE SEQUENCE FILES USE 36 BIT BYTES.  THIS
;FIXES MANY PROBLEMS CONCERNING THE APPENDING OF TWO LINE SEQUENCE
;NUMBERED FILES TOGETHER.
;<4.UTILITIES>EDIT.MAC.183, 20-Sep-78 15:15:55, EDIT BY DBELL
;TCO 4.2016.  GIVE INFORMATIVE OUT OF ORDER MESSAGE FOR COPY COMMAND.
;<4.UTILITIES>EDIT.MAC.182, 16-Jun-78 11:09:44, Edit by DBELL
;TCO 1923.  FIX /RUN SWITCH TO WORK CORRECTLY
;TCO 1922.  MAKE SURE PRARG BLOCK ALWAYS CONTAINS A NULL BYTE
;<4.UTILITIES>EDIT.MAC.181,  1-Jun-78 11:17:59, Edit by ENGEL
;FIX SFMOD TO USE TT%WAK INSTEAD OF 77B23 (FOR FULL WAKE-UP CHANGES)
;<4.UTILITIES>EDIT.MAC.180, 23-May-78 17:01:54, Edit by HESS
;TCO 1915 - Fix ESC echo on creation first input.
;<4.UTILITIES>EDIT.MAC.179,  3-May-78 11:31:13, Edit by DBELL
;TCO 1894. PREVENT ILLEGAL INSTRUCTION IN COPY COMMAND
;<4.UTILITIES>EDIT.MAC.178,  2-May-78 14:21:28, Edit by DBELL
;TCO 1893.  FIX OBSCURE PROBLEM WHEN A LOGICAL NAME IS DEFINED
;AS A SERIES OF FILE SPECS, AND ONE OF THE FILE SPECS IS PROTECTED.
;<4.UTILITIES>EDIT.MAC.177, 17-Nov-77 01:55:38, EDIT BY DBELL
;TCO 1878.  COPY PROTECTION OF ORIGINAL FILE TO NEW AND BACKUP FILES
;<4.UTILITIES>EDIT.MAC.176, 10-Nov-77 17:43:26, EDIT BY DBELL
;TCO 1877.  DON'T CLOSE INDIRECT FILE ON AN AUTO-SAVE
;<4.UTILITIES>EDIT.MAC.175,  9-Nov-77 14:35:57, EDIT BY DBELL
;TCO 1876.  SET GJ%NS WHEN CHECKING EXISTANCE OF OUTPUT FILE.
;<4.UTILITIES>EDIT.MAC.174, 31-Oct-77 17:42:33, EDIT BY DBELL
;FIX SKPNO1 TO NOT REREAD COMMENT CHARACTER
;<4.UTILITIES>EDIT.MAC.173, 31-Oct-77 15:57:05, EDIT BY DBELL
;IMPLEMENT EK COMMAND WHICH IS SAME AS EU BUT SUPPRESSES FORMFEEDS

;THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY ONLY BE USED
;  OR COPIED IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE.
;
;COPYRIGHT (C) 1976,1977,1978,1979,1980 BY DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.

TITLE	EDIT - TOPS20 EDITOR
SUBTTL DEFINITIONS

WHOEDI==0	;LAST EDITED BY DML (DEC)
VEREDI==5
PATEDI==0	;PATCH LEVEL
MODEDI==^D256	;EDIT LEVEL

; EDITOR FOR THE DISK -- WORKS BY RECOPYING FILES USED

	SALL		;SUPPRESS MACRO XPANSIONS
	.HWFRMT		;READABLE LISTING
	IFNDEF .PSECT,<
	.DIRECT .XTABM>

IFNDEF CRYPSW,<CRYPSW==0	;FOR ENCRYPTED FILES>
IFNDEF EXTEND,<EXTEND==1	;FOR EXTENDED FEATURES>
IFNDEF PPNTSW,<PPNTSW==0	;FOR PRETTY PRINT FEATURES>

	SEARCH	MONSYM
    IFN CRYPSW,<
	.REQUIRE ENDECR.REL
    >

OPDEF	OCRLF	[OUTSTR [BYTE (7)15,12]]
OPDEF	CALL	[PUSHJ P,]
OPDEF	RET	[POPJ P,]
OPDEF	RETSKP	[JRST CPOPJ1]
OPDEF	PJRST	[JRST]
;ACS USED

JF=0	;TEMP FLAGS FOR JUSTIFY & PRETTY PRINT
T1=1	;TEMP REGISTERS
T2=2
T3=3
T4=4
T5=5

FL=10		;FLAG REGISTER
FL2=11
ALTP=12		;POINTER FOR ALTER MODE
CS=13		;CHARACTER TABLE BITS
SINDEX=14	;LINE TO FIND, USED ALSO BY THE VARIOUS ROUTINES
PNTR=15		;POINTS AT CURRENT PLACE IN BUFFER
C=16		;CHARACTER RETURNED HERE BY GNCH
P=17		;PUSHDOWN LIST

;FLAGS  (RIGHT HALF)

BOF==1		;NOW ON FIRST RECORD OF FILE
EOF==2		;HAVE READ END OF FILE BUT NOT NECESSARILY BUT IN BUFFER
EOF2==4		;LAST WORD OF FILE IS IN CURRENT BUFFER
ADDL==10	;USED IN COMMAND SCANNING--LINE NUMBER + INC
SUBL==20	;LINE NUMBER - INC
IDF==40		;SCAN HAS SEEN AN IDENTIFIER
NUMF==100	;SCAN HAS SEEN A NUMBER
TERMF==200	;SCAN SAW A TERMINATOR (LF OR ALTMODE)
LINSN==400	;THE COMMAND INPUT ROUTINES SAW A LINE NUMBER
PGSN==1000	;THEY SAW A PAGE NUMBER
NEWFL==2000	;NEW FILE NAME SEEN BY END CODE
ORDF==4000	;LINES OUT OF ORDER (USED BY NUMBER)
BGSN==10000	;BIGGEST PAGE HAS BEEN SEEN
M37F==20000	;THIS IS A MODEL 37
CNTF==40000	;COMMAND USING !
		;100000--UNUSED
READOF==200000	;THIS FILE IS BEING USED IN READ ONLY MODE
EXTOG==400000	;ON FOR SHORT ERROR MESSAGES

;SPECIAL FLAGS FOR PARSE CODE

F.LAHD==1	;LOOK-AHEAD FLAG

CODMAX==^D20	;MAX CHARS IN CODE
SFDLVL==6	;MAX SFD LVL

D==PNTR
S1==PNTR		;SPECIAL ACS
S2==SINDEX
;FLAGS (LEFT HALF)

NEGF==1		;SEARCH HAS SEEN A 
DEMCHR==2	;SEARCH MUST SEE ANOTHER CHARACTER
ASSMF==4	;SEARCH HAS ASSUMED SEARCH CONTINUATION
ALTSRF==10	;HE WANTS TO DO A SEARCH AND EDIT
NUMSRF==20	;HE ONLY WANTS NUMBERS OF LINES FOUND
ARBITG==40	;WE ARE DOING ^N CURRENTLY, DO NOT ALLOW ANOTHER
EXCTSR==100	;WANTS TO SEARCH EXACTLY (NOT IGNORE CASE)
COPFIL==200	;WE ARE COPYING FROM ANOTHER FILE
ISCOP==400	;WE ARE DOING A COPY
NOPRN==1000	;DO NOT PRINT WHILE DOING SUBSTITUTE
DECID==2000	;ALLOW USER TO DECIDE IF LINE IS OK
EXCTS1==4000	;ANOTHER EXACT SEARCH FLAG FOR SUBS
QMODF==10000	;DO NOT TREAT ? AS A SPECIAL CASE ON INPUT
GCOM==20000	;DOING A G COMMAND INSTEAD OF E
SRCOP==40000	;DOING A SEARCH OF SECOND FILE
TRANFL==100000	;THIS IS A TRANSFER COMMAND WHICH HAS DELETED LINES
TECOF==200000	;THIS IS A TECO FILE
FSTOPF==400000	;THIS IS THE FIRST READ OP ON THIS FILE

;FLAGS IN FL2 (RIGHT)

STARF==1	;WE HAVE SEEN A * FOR THE LAST LINE
RUBF==2		;WE ARE DOING RUBOUT IN INTRA-LINE EDIT
ALTDUP==4	;DUPLEX CHARACTERS IN ALTER MODE
RUBF2==10	;DOING DELETE TYPE RUBOUT IN ALTER MODE
SVIT==20	;WE ARE DOING A "W" COMMAND (SAVE WORLD)
NONUMF==40	;SUPPRESS LINE NOS FOR P,R,I CMDS
ACONST==100	;ADD CONSTANT FOR R COMMAND
MONOF==200	;MONOTONIC RENUMBERING - NO REST AT P.M.
ALTECH==400		;ECHO ESC FLAG
SUPN==1000	;SUPPRESS LISTING OF LINE NUMBERS
		;2000 OPEN
UPTOPF==4000	;GET NEW LINE AT TOP OF PAGE
QSEPF==10000	;TREAT . % $ AS SEPARATORS
COMFLF==20000	;READ COMMANDS FROM FILE
ADECIF==40000	;SAW A AS RESPONSE TO DECIDE MODE
BADORD==100000	;FILE BECAME OUT OF ORDER DURING COPY COMMAND

;FLAGS IN FL2 (LEFT)

PDECID==1	;PERM DECIDE MODE FOR S
UARWF==2	;UP ARROW (^) SEEN FOR FIRST LINE
SRCWHO==4	;(203) WHO IS SEARCHING ON=FIND OFF=SEARCH
NORENT==10	;DON'T ALLOW REENTER
RENTF==20	;REENTER COMMAND TYPED
BELLF==40	;ALLOW <BELL><BELL>
BELLSN==100	;<BELL> SEEN
AUTOF==200	;AUTO SAVE IN PROGRESS
EXACT==400	;(203) USED FOR EXACT SEARCHES
EXCPFL==1000	;(207) USETO MARK A COPY
DOENDF==2000	;E CMD REQUESTED OR NEEDED
INOPTF==4000	;READING OPTION FILE
INPARS==10000	;DOING INITIAL PARSE
PCHGF==20000	;FILE HAS CHANGED THIS PASS
FCHGF==40000	;FILE HAS CHANGED THIS EDIT
CCHGF==100000	;THIS COMMAND HAS CHANGED THE FILE

ALLCHG==PCHGF!FCHGF!CCHGF	;ALL FLAGS AFFECTING FILE CHANGE

;FLAGS FOR JF (RIGHT)

EJECT==1	;EJECT AFTER PAGES
WAIT==2		;WAIT FOR CR AFTER PAGES
PGNOS==4	;PAGE NUMBERS AT BOTTOM
OPDEF	ERROR	[1B8]	;ERROR UUOS FATAL ERROR
OPDEF	NERROR	[2B8]	;NON-FATAL ERROR
OPDEF	RERROR	[3B8]	;PRINT MESSAGE AND RETURN
OPDEF	JERROR	[4B8]	;JSYS ERROR CALL
OPDEF	FJERR	[5B8]	;FATAL JSYS ERROR
OPDEF	OUTSTR	[6B8]	;OUTPUT STRING TO TERMINAL
OPDEF	OUTCHR	[7B8]	;OUTPUT CHAR TO TERMINAL
OPDEF	INCHRW	[10B8]	;INPUT CHAR TO LOC
	MAXUUO==10
SRBLG==^D200	;NUMBER OF CHRS ALLOWED IN SEARCH STRING
SRNUM==6	;NUMBER OF SEARCH STRINGS ALLOWED
PDLSIZ==200	;PUSHDOWN LIST SIZE
MXWPL==^D500	;MAX NUMBER OF WORDS PER LINE

IBUF0==100000		;INPUT PAGE BUFFER
OBUF0==IBUF0+1000	;OUTPUT PAGE BUFFER
CPYPG0==OBUF0+1000	;COPY INPUT PAGE BUFFER
CPYBUF==CPYPG0+1000	;COPY BROWSE BUFFER
NCPYP==10		;SIZE OF ABOVE
LIBUF==177000		;LINE BUFFER
LIBUF2==176000		;AUX LINE BUFFER
TTIBUF==175000		;TTY INPUT BUFFER
ARBBUF==173000		;2 PAGES FOR PATTERN MATCHING
BUF0==200000		;MAIN EDIT WINDOW
MINPAG==4		;MINIMUM WINDOW SIZE
MAXPAG==377-<BUF0>B44+1	;MAXIMUM WINDOW SIZE
DEFPAG==12		;DEFAULT WINDOW SIZE IF NONE GIVEN
BUFC==400000		;TEMP STORAGE FOR COPY
NCPAGS==677-<BUFC>B44+1	;SIZE OF ABOVE

IFN EXTEND,<LSNUM==3	;NUMBER OF NESTED LINE SEARCHES ALLOWED>
%LPP==^D53		;LINES/PAGE FOR "L" CMD
PGSZ==^D55		;LINES / PAGE
FULLPG==^D65		;LINES TO NEXT PAGE

FILSIZ==^D24		;WORDS/FILESPEC
SUBTTL REVISION HISTORY
COMMENT \


EDIT #				REASONS
------				-------

1	CHANGED SOS INTO EDIT, CHANGING SYMBOLS, NOT COMMENTS

2	CHANGED BACKUP ROUTINE BACK TO SHORT FILE VERSION

3	Added two new commands: /? prints all the settable
	switches, and =? prints all the printable switches.

4	Re-inserted the LOCATION switch which somehow got
	lost.

5	Added ? to the Alter command.  It prints a list
	of all the valid Alter mode commands.

6	Added the subcommand to E which prints a VTECO-like
	identifying line at the top of your file if you exit
	with the option 'I'.  This feature is in under the
	FT10X switch.

7	CHANGED THE COMMAND DISPATCHER TO BE GENUINELY
	TABLE-DRIVEN.

10	MADE THE W AND Q COMMANDS TELL THE USER TO GIVE THE
	B AND EQ COMMANDS.  THE _ COMMAND TELLS THE USER TO
	GIVE THE / COMMAND.

11	Fixed a bug in the join logic, and fixed ? message.

12	Changed the TOPS-20 parser.  EDIT must be started
	by the TOPS-20 Exec, with the command in the
	RESCAN buffer.  In all other cases, the user gets:
	?You must type an input file specification.

13	The parameter CORSIZ has been added.  For TOPS-10
	programs, this parameter should be set to 3000(8);
	however for now we are setting virtual jobs at
	300000(8).  This is the number of words which will
	be in the 'core memory buffer'.  Refer to the routine
	MOCO (for getting more core).

14	Removed the ED feature which allowed the user to lose
	everything if he typed 'END'.  Also removed the EQ
	command and changed the help message.

15	put most of the code under setppn under the IFE FT10X
	conditional.

16	CONVERT TO TOPS20 MONITOR CALLS

17	FIX ^U PROBLEM IN READNM (SAVE PREVIOUS FILESPEC)
	FIX "FILE STILL MAPPED" PROBLEM IN OCOMPL

20	MAKE COPY BROWSE BUFFER 10 PAGES. CLEANUP ^O STUFF.

21	FIX WRAPAROUND ON /RO FILES THAT ARE UNSEQUENCED.
	MINOR FIX TO ^C INT WHEN NORENT IS ON. CHECK CREATF
	BEFORE TRYING TO MAKE A BAK FILE.

22	SET CORRECT FILE DATE AND TIMES UPON EXIT

23	ADD /WINDOW:N TO SPECIFY EDIT WINDOW SIZE, EJ COMMAND
	TO DO D^/^ , EI, ADD K<LF> TO ALTER MODE

24	HANDLE CHL 20 PSI AND OPENF FAILURES FOR DISK FULL OR
	QUOTA EXCEEDED. ADD CLEAR OUTPUT BUFFER ON ^C

25	REDO ERROR MESSAGE MACRO AND CODE ASSIGNMENT

26	SEE TCO FILE FROM NOW ON (ALSO FIRST COMMENT LINES)

\
	SUBTTL ENTRY VECTOR AND EXEC INTERFACE

EV::	JRST	STPT		;START ADDRS
	JRST	CNCREN		;REENTER ADDRS
	BYTE	(3)WHOEDI (9)VEREDI (6)PATEDI (18)MODEDI


CREFIT:	OCRLF			;INFORM USER ALL IS OK
	MOVEI	T1,1		;COUNT OF ARGS
	MOVEM	T1,LIBUF2	;STASH IN BUFFER
	SKIPN	T2,RUNFIL	;SEE IF FILE GIVEN
	JRST	[SETZM LIBUF2+2	;ZERO MEANS USE LAST LOAD CLASS CMD
		 MOVEI T3,1	;SIZE OF ARG
		 JRST CRFIT1]	;JOIN REST
	HRROI	T1,LIBUF2+2	;COPY STRING
	MOVEI	T3,0
	SOUT
	IBP	T1		;POINT AFTER TERMINATING NULL
	MOVEI	T3,1(T1)	;CALC SIZE
	SUBI	T3,LIBUF2+2	;IN WORDS
CRFIT1:	MOVE	T1,[4B2+17B12+2] ;CODE AND BUFFER OFFSET
	MOVEM	T1,LIBUF2+1	;...
	MOVE	T1,[.PRAST,,.FHSLF]
	MOVEI	T2,LIBUF2	;BUFFER ADDRS
	ADDI	T3,2		;ACCOUNT FOR OVERHEAD
	PRARG			;SET PARAMS
	HALTF			;ALL DONE
	JRST	.-1		;FOREVER



;A CHARACTER TABLE FOR USE ON TYPE IN AND TYPE OUT

;FLAGS USED IN CHARACTER TABLE

OPF==10		;THIS IS A SPECIAL CHARACTER
SNUMF==4	;THIS IS PART OF A NUMBER
LETF==2		;THIS IS A LETTER
TERM==1		;THIS IS A TERMINATOR
M37==400000	;THIS CHR IS PRINTED AS ITSELF ON MODEL 37
NSEPF==200000	;THIS IS NOT A SEPERATOR (USED ON $,%,AND.)
DEFINE CHRS (FLAGS,PALT,INALT,RH)
<BYTE (4) FLAGS (7) PALT,INALT(18)RH>

CTBL:	0
	CHRS	OPF,"!","",""
	CHRS	OPF,42,"",""
	CHRS	OPF,"#",3,3
	CHRS	OPF,"$",4,4
	CHRS	OPF,"%",5,5
	CHRS	OPF,"&",6,6
	CHRS	OPF,"'",7,7
	CHRS	OPF,<"(">,10,10
	0
	CHRS	OPF!TERM,0,12,12
	CHRS	OPF,0,13,13
	CHRS	OPF,0,14,14
	0
	CHRS	OPF,<")">,16,16
	CHRS	OPF,"*",17,17
	CHRS	OPF,"+",20,20
	CHRS	OPF,54,21,21
	CHRS	OPF,"-",22,22
	CHRS	OPF,".",23,23
	CHRS	OPF,"/",24,24
	CHRS	OPF,"0",25,25
	CHRS	OPF,"1",26,26
	CHRS	OPF,"2",27,27
	CHRS	OPF,"9",30,30
	CHRS	OPF,"6",31,31
	CHRS	OPF,"4",32,32
	CHRS	OPF,"=",33,33
	CHRS	OPF,74,34,34
	CHRS	OPF,76,35,35
	CHRS	OPF,"7",36,36
	CHRS	OPF,"8",37,37
	0
	CHRS	OPF,0,1,"!"
	CHRS	OPF,0,2,42
	CHRS	OPF,0,3,"#"
	CHRS	OPF,0,4,"$"+NSEPF
	CHRS	OPF,0,5,"%"+NSEPF
	CHRS	OPF,0,6,"&"
	CHRS	OPF,"'","'","'"
	CHRS	OPF,0,10,<"(">
	CHRS	OPF,0,16,<")">
	CHRS	OPF,0,17,"*"
	CHRS	OPF,0,20,"+"
	CHRS	OPF,0,21,54
	CHRS	OPF,0,22,"-"
	CHRS	OPF,0,23,"."+NSEPF
	CHRS	OPF,0,24,"/"
	CHRS	SNUMF,0,25,20
	CHRS	SNUMF,0,26,21
	CHRS	SNUMF,0,27,22
	CHRS	SNUMF,0,176,23
	CHRS	SNUMF,0,32,24
	CHRS	SNUMF,0,"5",25
	CHRS	SNUMF,0,31,26
	CHRS	SNUMF,0,36,27
	CHRS	SNUMF,0,37,30
	CHRS	SNUMF,0,30,31
	CHRS	OPF,0,174,":"
	CHRS	OPF,0,73,73
	CHRS	OPF,0,34,74
	CHRS	OPF,0,33,"="
	CHRS	OPF,0,35,76
	CHRS	OPF,0,37,"?"
	CHRS	OPF,0,140,"@"
XXZ=101
REPEAT ^D26,<CHRS	LETF,0,XXZ+40,XXZ-40
XXZ=XXZ+1>
	CHRS	OPF,0,173,<"[">
	CHRS	OPF,7,7,"\"	; CTRL-G PRINTS AS BELL
	CHRS	OPF,0,175,<"]">
	CHRS	OPF,0,"^","^"
	CHRS	OPF,0,"_","_"
	CHRS	OPF,100,140,140
XXZ=141
REPEAT ^D26,<CHRS	LETF,XXZ-40,XXZ,XXZ-100
XXZ=XXZ+1>
	CHRS	OPF,<"[">,173,173+M37
	CHRS	OPF,":",174,174+M37
	CHRS	OPF,<"]">,175,175+M37
	CHRS	OPF,"3",176,176
	CHRS	OPF,"\",177,177
	CHRS	OPF,0,0,200

SUBTTL SCANNER
GNCH:	SKIPN	C,LIMBO		;USE SAVED CHAR IF ANY
	PUSHJ	P,@CHIN		;ELSE GET FRESH CHAR
	SETZM	LIMBO		;AND CLEAR LIMBO
	CAMN	C,ESC		;CHECK ESCAPE CHAR
	MOVEI	C,200		;CONFUSE WITH LEFT CURLY BRACKET
	TLNE	FL,QMODF	;SHOULD WE TREAT ' SPECIALLY
	JRST	GNCH1Y		;NO:
	CAIN	C,"'"		;YES: SHOULD WE USE ALT CHR SET?
	JRST	GNCHA		;YES:
GNCH1Y:	TDNN	FL2,[INOPTF,,COMFLF]
	TLNN	FL2,BELLF		;ALLOWED?
	JRST	GNCHB		;NO: JUST GET BITS
	CAIN	C,7		;YES: SEE IF BELL
	JRST	[TLO FL2,BELLSN	;SAY WE SAW ONE
		 JRST GNCHA]	;AND LOOK AT NEXT
GNCHB:	JUMPE	C,GNCH		;IGNORE NULLS
	MOVE	CS,CTBL(C)	;GET CHARACTER TABLE BITS
	TLNE	CS,LETF_16	;CHECK TO SEE IF A LETTER
	TDC	C,CASEBT	;USE UPPER/LOWER INFO
	POPJ	P,		;AND RETURN

GNCHA:	PUSHJ	P,@CHIN		;GET NEXT CHAR
	JUMPE	C,GNCHA		;SKIP NULLS
	TLZE	FL2,BELLSN	;WAS 1ST BELL SEEN
	JRST	[CAIN C,7	;YES: CHECK FOR 2ND
		 JRST [OCRLF	;2ND SEEN - PUNT
		       CALL CLRBFI
		       JRST COMND]
		 MOVEM C,LIMBO	;SAVE CHAR
		 MOVEI C,7	;RETURN A BELL
		 JRST GNCHB]
	SKIPE	CTBL(C)		;NO CHANGE FOR NULL,SPACE,TAB,CRET
	MOVS	C,CTBL(C)	;GET ALTERNATE CHR FROM CHR TABLE
	ANDI	C,177		;ONLY THE CHR BITS
	JRST	GNCHB		;GO CHECK THINGS
;HERE TO INPUT FROM TTY

TTYCH:	SOSG	TTICNT		;SEE IF MORE CHARS
	CALL	TTYINP		;NO - GET SOME MORE
	ILDB	C,TTIPNT	;GET CHAR
	JUMPE	C,TTYCH		;SKIP OVER NULLS
	TRNE	FL2,ALTECH	;ESC ECHO?
	CAME	C,ESC		;IS IT
	RET			;NO - JUST RETURN
	PUSH	P,T1		;SAVE T1
	MOVEI	T1,"$"
	PBOUT			;DUMP DOLLAR
	PJRST	T1POPJ		;RESTORE T1 & EXIT

TTYINP:	PUSH	P,T1		;SAVE T1
TTYIN0:	HRROI	T1,TTIBUF	;POINT TO BUFFER
	MOVEM	T1,TEXTIB+.RDDBP
	MOVSI	T1,(RD%TOP!RD%JFN!RD%RND)
	MOVEM	T1,TEXTIB+.RDFLG	;SET FLAGS
	MOVEI	C,5*MXWPL+2	;COUNT OF CHARS
	MOVEM	C,TEXTIB+.RDDBC
	MOVEI	T1,TEXTIB	;POINT TO ARG BLOCK
	TEXTI			;SNARF SOME
	  FJERR			;FATAL JSYS ERROR
	MOVE	T1,TEXTIB+.RDFLG ;GET FLAGS
	TLNE	T1,(RD%BFE)	;BUFFER EMPTY?
	JRST	TTYNUL		;YES - PROCESS NULL INPUT
	SUB	C,TEXTIB+.RDDBC	;GET CHAR COUNT
	MOVEM	C,TTICNT	;SETUP COUNT
	MOVE	T1,[POINT 7,TTIBUF]
	MOVEM	T1,TTIPNT	;RESET POINTER
	PJRST	T1POPJ		;RESTORE T1

;HERE ON EITHER ^U OR RUBOUT BEYOND BEGINNING OF BUFFER

TTYNUL:	PUSH	P,T2		;SAVE EXTRA REG
	MOVEI	T1,.PRIOU	;USE OUTPUT JFN
	RFPOS			;GET POSITION
	MOVE	T1,T2		;COPY TO T1
	POP	P,T2		;RESTORE T2
	TRNE	T1,-1		;LEFT MARGIN?
	JRST	[OUTCHR [7]	;NO - RING BELL AND TRY AGAIN
		 JRST TTYIN0]
	SKIPE	T1,FSFLG	;IN F/S OR COPY COMMAND
;**;[247]	Change 1 line at TTYNUL:+9		DML	23-NOV-82
	JRST	CTLUAB		;[247] PRINT ABORT MESSAGE
	OUTSTR	CRBUF		;OUTPUT PROMPT
	JRST	TTYIN0		;AND TRY AGAIN

;**;[247]	Add 3 lines at CLRBFI:-1		DML	23-NOV-82
CTLUAB:	OUTSTR	[ASCIZ "Aborted..."]  ;[247] PRINT MESSAGE
	OCRLF			;[247] OUTPUT CRLF
	JRST	COMND		;[247] RETURN TO COMMAND LOOP

CLRBFI:	PUSH	P,T1		;SAVE T1
	MOVEI	T1,.PRIIN	;ONLY CLEAR PRIMARY INPUT
	CFIBF
	PJRST	T1POPJ

NOECHO:	PUSH	P,T3		;SAVE STUFF
	MOVEI	T3,0		;ECHO STATUS FLAGS
	MOVEM	T3,ECFLG	;(194) SET ECHO FLAG
	JRST	ECHOST		;JOIN COMMON CODE

DOECHO:	PUSH	P,T3		;SAVE T3
	MOVEI	T3,2		;TURN ECHO ON
ECHOST:	PUSH	P,T1		;SAVE OTHER REGS
	PUSH	P,T2
	MOVEI T1,.PRIOU		;PRIMARY OUTPUT
	DPB T3,[POINT 2,MODW,25] ;SET FLAGS
	MOVE T2,MODW
	SFMOD			;...
	POP	P,T2		;RESTORE REGS
	POP	P,T1
	POP	P,T3
	RET			;RETURN
;SUBROUTINE TO SCAN NEXT ATOM
;CALL:
;	PUSHJ	P,SCAN
;	<RETURN HERE>
;C(ACCUM) := SIXBIT ATOM
;C(T1)    := ASCII SEQ NUMBER FORM
;C(T2)    := DECIMAL INTEGER
;C(C)     := BREAK CHAR OR SPACE IF IDENT.

SCAN:	TRZ	FL,TERMF!NUMF!IDF ;RESET FLAGS
	SKIPE	CS,SAVCHR	;CHECK TO SEE IF WE LEFT ONE LAST TIME
	JRST	SL1		;YES, IT MUST BE A DELIMITER
	SKIPN	C,SAVC		;BACK UP A CHARACTER?
	JRST	SL10		;NO
	PUSHJ	P,GNCHB		;YES, GET BITS
	TLNN	FL2,INPARS	;HANDLE SPECIAL IF IN PARSE
	JRST	SL11		;NOT IN INITIAL PARSE
	SETZM	SAVC
	SETZM	SAVCHR
	POPJ	P,		;RETURN IF SPACE DELIM
SL10:	PUSHJ	P,GNCH		;GET A CHR
SL11:	SETZM	SAVC
	JUMPE	CS,SL10		;CHECK FOR TAB, SPACE, AND IGNORE
	JUMPL	CS,SL1		;SPECIAL CHARACTER?
	MOVE	T3,[POINT 6,ACCUM] ;SET TO SAVE IDENT
	SETZM	ACCUM
	TLNE	CS,SNUMF_16	;CHECK FOR NUMBER
	JRST	SNUM1		;AND GO RACING OFF TO NUMBER ROUTINE
SL2P:	TRO	FL,IDF		;IT IS AN IDENT
SL2:	TLNE	T3,770000	;HAVE WE STORED ENOUGH?
	IDPB	CS,T3		;NO, STORE ANOTHER (RH OF CHR TABLE HAS SIXBIT)
	PUSHJ	P,GNCH		;CONTINUE
	JUMPG	CS,SL2		;CHECK FOR ANOTHER NUMBER OR LETTER
SOK1:	MOVEM	CS,SAVCHR	;SAVE THE CHARACTER (MUST BE A SPECIAL CHR)
	TLNE	FL2,INPARS
	JRST	[MOVEM C,SAVC	;SAVE HERE IF IN PARSE
		 SETZB C,SAVCHR
		 POPJ P,]
	MOVEI	C,0		;ZERO IN C FOR NUMBERS AND IDNETS
	POPJ	P,

SL1:	HRRZ	C,CS		;FOR SPECIAL CHARACTERS, RETURN RH OF CTABLE
	TLNE	CS,TERM_16	;CHECK FOR TERMINATOR
	TRO	FL,TERMF	;AND SET FLAG
	ANDI	C,377		;GET RID OF EXTRA BITS
	SETZM	SAVCHR		;ZERO SAVCHR FOR LATER
	CAIE	C,"."		;CHECK FOR .
	POPJ	P,		;NO RETURN
	MOVE	T1,CLN		;SET UP FOR CURRENT LINE AND PAGE
	MOVE	T2,CPGL
	TRO	FL,NUMF		;CALL IT A NUMBER
	POPJ	P,
SNUM1:	SETZB	T1,T2		;SET NUMBER ACCUMS TO 0
SN1A:	TLNE	T3,770000	;WILL STORE THE SIXBIT FOR FILE NAMES
	IDPB	CS,T3		;BUT ONLY IF LESS THAN 6
SN1B:	TLNE	T1,(<177B7>)	;CHECK FOR 5 CHARS
	JRST	SN1C		;5 ALREADY
	LSH	T1,7		;ACCUMULATE ASCII IN T1
	IOR	T1,C
SN1C:	IMULI	T2,^D10		;DECIMAL IN T2
	ADDI	T2,-"0"(C)
	PUSHJ	P,GNCH		;GET NEXT AND CONTINUE
	JUMPLE	CS,SOK2		;CHECK FOR END OF NUMBER
	TLNN	CS,SNUMF_16	;CHECK FOR NUMBER
	JRST	SL2P		;MUST BE AN IDENT
	JRST	SN1A		;CONTINUE SCANNING NUMBER

SOK2:	TRO	FL,NUMF		;IT WAS A NUMBER
	LSH	T1,1		;CONVERT TO LINE NUMBER
	IOR	T1,[<ASCII /00000/>!1]
	JRST	SOK1		;SAVE DELIM AND RETURN

SUBTTL PLACE FINDING ROUTINES

;FIND-- PAGE TO FIND IS IN DPG. NUMBER TO FIND IS IN SINDEX.
;LOADS T1 WITH THE LINE NUMBER FOUND
;IF NO EXACT MATCH WILL FIND NEXT HIGHER NUMBER OR A PAGE MARK.
;IF EOF FOUND, RETURNS 0

FIND:	MOVE	T1,DPG		;GET THE DESIRED PAGE
	CAMLE	T1,CPG		;IS IT GREATER THAN THE PAGE WE ARE ON
	JRST	FWDPG		;YES, SEARCH FORWARD FOR PAGE
	CAML	T1,CPG		;IS IT THE SAME AS THE CURRENT PAGE?
	JRST	FEQPG		;YES, JUST SEARCH FOR LINE NUMER
	SUBI	PNTR,1		;BACK UP A LITTLE (IN CASE POINTED AT PAGE MARK)
FIND1:	PUSHJ	P,CHKREN	;SEE IF REENTER
	JRST	FNDONE		;YES: FINISH UP
	SKIPN	T1,(PNTR)	;GET THE WORD, BUT WATCH FOR START OF BUFFER
	JRST	FINDHD		;WILL HAVE TO FINISH COPY AND START OVER
	CAME	T1,PGMK		;IS IT A PAGE MARK?
	SOJA	PNTR,FIND1	;CONTINUE SEARCHING
	SOS	T1,CPG		;DECREASE THE PAGE WE ARE NOW ON
	CAME	T1,DPG		;IS IT THE RIGHT ONE YET?
	SOJA	PNTR,FIND1	;NO, KEEP SEARCHING
	SUBI	PNTR,1		;BACK OVER PAGE MARK
FIND2:	PUSHJ	P,CHKREN	;REENTER?
	JRST	FNDONE		;YES:
	SKIPN	T1,(PNTR)	;PICK UP WORD AND CHECK FOR START OF BUFFER
	JRST	FINDHD		;HAVE TO DO IT THE HARD WAY
	TRNN	T1,1		;IS IT A SEQUENCE NUMBER?
	SOJA	PNTR,FIND2	;NO, CONTINUE SEARCH
	CAMN	T1,PGMK		;IS IT PERHAPS A PAGE MARK?
	AOJA	PNTR,FNDFW1	;YES, GO FORWARD A LINE AND RETURN IT
	CAMGE	SINDEX,T1	;IS THE LINE WE WANT GREATER OR EQUAL TO THIS ONE
	SOJA	PNTR,FIND2	;NO, KEEP UP THE GOOD WORK
	CAMN	SINDEX,T1	;EXACT MATCH?
	POPJ	P,		;YES, RETURN
	JRST	FNDFW1		;GO FORWARD A LINE TO GET NEXT LARGER
FEQPG:	SKIPN	T1,(PNTR)	;CHECK THE WORD WE ARE POINTING AT
	JRST	FNDFOO		;MUST BE POINTING AT END OF BUFFER OR BUFFER EMPTY
	CAMN	T1,PGMK		;IS IT A PAGE MARK?
	SOJA	PNTR,FIND2	;MUST BE ONE AT END OF PAGE, SEARCH BACKWARDS
FEQPG1:	CAMGE	SINDEX,T1	;COMPARE TO LINE WE WANT
	JRST	FIND2		;WANT A SMALLER ONE, SEARCH BACK
	JRST	FNDFW1		;SEARCH FORWARD

FWDPG:	PUSHJ	P,CHKREN	;REENTER?
	JRST	FNDONE		;YES:
	SKIPN	T1,(PNTR)	;SEARCH FORWARD FOR PAGE
	JRST	FNXRCP		;END OF BUFFER, GET A NEW ONE
	CAME	T1,PGMK		;FOUND A PAGE MARK?
	AOJA	PNTR,FWDPG	;NO, CONTINUE
	AOS	T1,CPG		;ADVANCE CURRENT PAGE COUNT
	CAME	T1,DPG		;AND SEE IF WE ARE THER YET
	AOJA	PNTR,FWDPG	;NUTS, LOOK SOME MORE
	ADDI	PNTR,1		;ADVANCE BEYOND PAGE MARK
FNDFW1:
FIND3:	PUSHJ	P,CHKREN	;REENTER?
	JRST	FNDONE		;YES:
	SKIPN	T1,(PNTR)	;LOOK FOR LINE
	JRST	FNXRC		;END OF RECORD, GET A NEW ONE
	TRNN	T1,1
	AOJA	PNTR,FIND3	;NOT LINE NUMBER
	CAMN	T1,PGMK		;PAGE MARK
	POPJ	P,		;RETURN IT, IT IS BEST MATCH WE CAN FIND
	CAMLE	SINDEX,T1	;ARE WE THERE YET?
	AOJA	PNTR,FIND3	;NO, CONTINUE SEARCH
	POPJ	P,		;YES, FINALLY

FNDFOO:	CAMN	PNTR,BUFP	;ARE WE POINTED TO START OF BUFFER
	JRST	FDFOO1		;YES, BUFFER MUST BE EMPTY
	SUBI	PNTR,1		;NO, MUST HAVE BEEN AT END OF BUFFER
FDFOO2:	SKIPN	T1,(PNTR)	;GET WORD
	ERROR	ICN		;MUST BE CONFUSED, THERE SHOULD BE A LINE NUMBER
	TRNN	T1,1		;SEARCH FOR LINE NUMBER
	SOJA	PNTR,FDFOO2	;KEEP LOOKING
	CAMN	T1,PGMK		;IS IT A PAGE MARK
	AOJA	PNTR,FNDFW1	;YES, SEARCH FORWARD
	JRST	FEQPG1		;GO DO SOMETHING WITH IT
FDFOO1:	TRNE	FL,EOF2		;ARE WE AT END OF FILE?
	JRST	FINDHD		;WILL HAVE TO TRY FROM START
	PUSHJ	P,GETN		;GET THE NEXT BUFFER
	JRST	FEQPG

;HERE TO SAY WE HAVE BEEN INTERUPTED

FNDONE:	JRST	COMND		;JUST GO TO CMD LOOP FOR NOW
FNXRCP:	TRNE	FL,EOF2		;ARE WE AT END OF FILE
	JRST	FNX1		;YES, JUST RESET BGPG AND LOOK AGAIN
	PUSHJ	P,GETN		;GET THE NEXT BUFFER
	JRST	FWDPG		;AND CONTINUE SEARCH
FNX1:	MOVE	T1,CPG		;SET BGPG TO CURRENT PAGE
	MOVEM	T1,BGPG
	TRO	FL,BGSN		;RECORD THAT LARGEST PAGE SEEN
	MOVEI	T1,0		;RETURN 0 FOR EOF
	POPJ	P,

FNXRC:	TRNE	FL,EOF2		;ARE WE AT END OF FILE
	JRST	FNX1		;YES, GIVE HIM BACK THE 0
	PUSHJ	P,GETN		;NO, GET THE NEXT BUFFER
	JRST	FIND3		;AND CONTINUE LOOKING FOR LINE

FINDHD:	TRNE	FL,BOF		;ARE WE AT THE START OF THE FILE
	JRST	FNDFST		;YES, CAN NOT GO BACK JUST GIVE FIRST LINE OF FILE
	TLNE	FL,COPFIL	;IS THIS A COPY?
	JRST	FINDH4		;YES: DON'T RELEAS IN & OUT
	TRNE	FL,READOF	;ALSO HANDLE SPECIAL IF RO
	JRST	FINDH
	PUSHJ	P,OCOMPL	;FINISH COPYING FILE
	TLNN	FL2,PCHGF	;ANY CHANGES THIS PASS?
	JRST	[CALL DELOUT	;DELETE OUTPUT FILE
		 JRST FINDHB]
FINDH:	SKIPE	AUXFLG
	JRST	[MOVE T1,ICRJFN	;CURRENT INPUT JFN
		 CALL DOCLSF	;CLOSE IT (RETAIN JFN)
		 CALL DDELFR	;FLUSH IT
		 SETZM ICRJFN	;ITS GONE
		 SETZM AUXFLG	;(222)CLEAR AUXFLG
		 JRST .+1]
	TRNE	FL,READOF	;READ-ONLY ?
	JRST	FINDH2		;YES - THIS IS FAST
	SKIPE	T1,ICRJFN	;CLOSE FILE
	CALL	DOCLSR		;...
	SETZM	ICRJFN		;(222)CLEAR JFN STORAGE
	PUSHJ	P,OUTFIN	;PURGE BUFFER
	HRROI	T1,[ASCIZ "EDIT-BUFFER.IN"]
	HRROI	T2,ICRASZ
	CALL	MAKTMP		;MAKE TEMP FILE SPEC
	HRROI	T2,ICRASZ	;MAKE PNTR TO NAME
	MOVEM	T2,ICRFIL	;...
	MOVSI	T1,(GJ%SHT!GJ%TMP!GJ%FOU)
	PUSHJ	P,GTJFNX	;GET JFN FOR NEW INPUT
	  FJERR
	SETOM	AUXFLG		;WE HAVE AN AUX FILE
	MOVEM	T1,ICRJFN	;...
	MOVE	T1,OCRJFN	;CURRENT OUTPUT JFN
	MOVE	T2,ICRJFN	;JFN OF DEST FILE
	RNAMF			;RENAME OUTPUT FILE
	  FJERR			;FATAL JSYS ERROR
	SETZM	OCRJFN		;(222)CLEAR JFN STORAGE
IFN CRYPSW,<
	MOVE T1,OCRCOD		;INPUT CODE IS NOW
	MOVEM T1,ICRCOD		; OLD OUTPUT CODE
>
FINDH1:	MOVEI	T1,IBUF0	;SET UP BUFFER PNTR
	MOVEM	T1,CIPBUF
	MOVE	T1,ICRJFN	;INPUT JFN
	MOVEM	T1,CIPJFN	;CORRECT BLOCK
	MOVE	T2,[7B5+OF%RD]
	OPENF			;OPEN IT
	  FJERR			;LOASGE
	PUSH	P,ALTP		;SAVE ALT PNTR
	MOVEI	ALTP,CIPB	;INPUT BLOCK
	CALL	GFSIZE		;NEW INPUT FILE SIZE
	POP	P,ALTP		;RESTORE PNTR
FINDHB:	MOVSI	T1,(GJ%FOU!GJ%TMP!GJ%SHT)
	MOVE	T2,OCRFIL	;PNTR TO FILESPEC
	PUSHJ	P,GTJFNX	;GET NEW JFN
	  FJERR
	MOVEM	T1,OCRJFN	;SAVE
	MOVEI	T2,OF%WR	;OPEN FOR WRITE, FULL WORDS
	MOVEM	T1,OPNJFN	;SAVE FOR OPNERR
	OPENF
	  CALL	OPNERR		;CHECK FAILURE
	SETZM	OPG		;OUTPUT PAGE CNTR
	MOVNI	T1,2
	MOVEM	T1,OPCNT	;OUTPUT FILE PAGE COUNT
	SETZM	OUPNT		;OUTPUT FILE PNTR
FINDH2:	SETOM	CIPCNT		;INIT PAGE CNTR
	SETZM	CIPPNT		;CLEAR BUFFER
	SETZM	CIPBYT		;...
FINDH3:	SETZM	WC		;WC STARTS OUT 0
	TDZ	FL,[TECOF,,EOF!EOF2]
	TDO	FL,[FSTOPF,,BOF]
	TLNN	FL,COPFIL	;DON'T HURT THIS FLAG IF IN COPY
	TLZ	FL2,PCHGF	;NO CHANGES YET
	MOVEI	T1,1		;SET UP INPUT PAGE IN CASE OF
	MOVEM	T1,INPG		;ORDER OR LTL ERRORS ON INPUT
	SETZM	SVWD
	SETZM	OLDLIN		;USED IN CHECKING INPUT ORDER OF LINES
	PUSHJ	P,FILLBF	;FILL UP THE BUFFER
	MOVEI	T1,1
	MOVEM	T1,CPG		;START ON PAGE 1
	MOVE	PNTR,BUFP	;SET PNTR TO START OF WORLD
	JRST	FIND		;AND GO LOOKING

FNDFST:	MOVE	T1,@BUFP	;GET FIRST WORD
FNDFS1:	MOVE	PNTR,BUFP	;SET TO START OF WORLD
	POPJ	P,		;AND DISMISS

FINDH4:	SETOM	AIPCNT		;RESET INPUT PAGE COUNT
	SETZM	AIPPNT		;AND EMPTY BUFFER
	SETZM	AIPBYT		;...
	JRST	FINDH3

;FIND THE NEXT LINE, PAGE MARK, ETC.

FINDN1:	SKIPN T1,(PNTR)
	JRST FINDN2
	TRNN T1,1
FINDN:	AOJA PNTR,FINDN1
	POPJ P,		;RETURN THE LINE

FINDN2:	TRNE FL,EOF2	;IS IT EOF?
	POPJ P,		;YES, RETURN PRESENT T1 (0 FOR EOF)
	PUSHJ P,GETN	;GET NEXT BUFFER
	JRST FINDN1	;GO LOOK SOME MORE



FINDZ1:	SKIPN T1,(PNTR)	;AS FINDN BUT STOPS AT END OF RECORD
	POPJ P,
	TRNN T1,1	;LINE NUMBER?
FINDZ:	AOJA PNTR,FINDZ1
	POPJ P,



;FIND THE PREVIOUS LINE

FINDB1:	SKIPN T1,(PNTR)	;WATCH OUT FOR START OF BUFFER
	JRST FINDB2
	TRNN T1,1	;LINE NUMBER?
FINDB:	SOJA PNTR,FINDB1	;TRY AGAIN
	CAMN T1,PGMK	;TEST FOR PAGE MARK
	SOS CPG		;NOW ON PREVIOUS PAGE
	POPJ P,		;RETURN LINE NUMBER

FINDB2:	TRNE FL,BOF	;AT START OF FILE?
	JRST FINDB3	;(210) YES, GO GET THE FIRST LINE OF FILE
	MOVE T1,1(PNTR)	;GET THE FIRST LINE ON THIS PAGE
	TRNN T1,1	;MAKE SURE THERE IS ONE THERE
	ERROR ICN	;NO, WE ARE CONFUSED
	PUSH P,SINDEX	;SAVE (CALLER MAY NEED IT)
	MOVE SINDEX,T1
	PUSHJ P,FINDHD	;THIS WILL WORK AND WE WILL HAVE A LITTLE SPACE BEFORE
	POP P,SINDEX	;GET THIS BACK
	SOJA PNTR,FINDB1	;GO LOOK BACK AGAIN

;**;[244]	Change 1 line at FINDB3:		DML	9/29/82
FINDB3:	TRNN	FL2,UPTOPF	;[244](210) IS THIS AN I COMMAND
	JRST	FNDFS1		;(210) NO JUST GET FIRST LINE
	CAMN	T1,[<ASCII /00000/>!1] ;(210) DOES LINE 00000 EXIST?
	NERROR	ILR		;(210) YES GIVE ERROR
;**;[242]	insert two lines after FINDB3+3		DML	9/17/82
	TRNE	FL2,UPTOPF	;[242] IS THIS AN INSERT
	TRNN	FL2,STARF	;[242] YES, IT IS AN I*, USE LINE = START
	CAMLE	T1,TECFST	;(210) NO, IS THIS <= START PARAMETER?
	JRST	[MOVE T1,TECFST
		 JRST FINDB4]	;(210) NO USE LINE = START
	MOVE	T2,[<ASCII /00000/>!1] ;(210) YES GET AVERAGE FOR NEW ONE
	MOVE	T1,SINDEX	;(210) SET TO START LINE
	MOVE	SINDEX,[<ASCII /00000/>!1] ;(210) SET TO LINE 00000
	PUSHJ	P,ASCAV		;(210) AVERAGE 0 AND FIRST LINE
	MOVE	T1,T2		;(210) SAVE AVERAGE IN T1
FINDB4:	MOVE	SINDEX,T1	;(210) SAVE RESULT IN SINDEX
	JRST	FNDFS1		;(210) ALL DONE GET POINTER

SUBTTL BUFFER HANDLING ROUTINES

SUBTTL BUFFER HANDLING ROUTINES
OCOMPL:	TLNN	FL2,PCHGF	;SEE IF NEEDED
	JRST	[MOVEI T2,<IBUF0>B44
		 PJRST UNMAP]	;UNMAP PAGE AND RETURN
OCOMP0:	MOVE	T1,WC		;GET CURRENT WORD COUNT
	ADD	T1,BUFP		;TURN IT INTO A POINTER
	PUSHJ	P,DUMP		;DUMP DUMPS BUFFER FROM BUFP TO (T1)
	SETZM	WC		;TELL IT NO CURRENT WORD COUNT
	TRNE	FL,EOF2		;ALL DONE?
	POPJ	P,
	PUSHJ	P,FILLBF	;FILL UP INPUT BUFFER
	PUSHJ	P,CHKREN	;DID WE REENTER?
	JRST	COMND		;YES: GO TO COMMAND LOOP
	JRST	OCOMP0		;AND GO DUMP THIS ONE TOO



GETWD:	TRNE	FL,EOF
	JRST	RTEOF		;RETURN 0 IF EOF
	PUSH	P,ALTP		;SAVE PNTR
	MOVEI	ALTP,CIPB	;ASSUME CURRENT INPUT BLOCK
	TLNE	FL,COPFIL	;IN A COPY, WE GET FROM SOMEWHERE ELSE
	MOVEI	ALTP,AIPB	;USE ALT INPUT BLOCK
GETWD0:	MOVE	T3,PNT(ALTP)	;GET PNTR
	AOBJP	T3,GETDO	;GET INPUT IF NECESSARY
	MOVEM	T3,PNT(ALTP)	;RESTORE NEW VALUE
GETWD1:	MOVE	T3,0(T3)	;GET NEXT WORD
	JUMPE	T3,GETWD0	;IGNORE 0 WORDS
	POP	P,ALTP		;RESTORE PNTR
	RET			;RETURN

GETDO:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2
	AOS	T1,CNT(ALTP)	;GET NEXT PAGE #
	HRL	T1,IJFN(ALTP)	;INPUT JFN
	RPACS			;SEE IF PAGE EXISTS
	TLNN	T2,(PA%PEX)	;???
	JRST	GTEOF		;NO - RETURN EOF
	HRRZ	T2,BUF(ALTP)	;BUFFER ADDRS
	LSH	T2,-^D9		;CONVERT TO PAGE #
	HRLI	T2,.FHSLF	;FORK HANDLE
	MOVSI	T3,(PM%RD!PM%CPY) ;READ ACCESS
	PMAP			;GET PAGE
	MOVNI	T3,0(T1)	;- PAGE #
	IMULI	T3,1000		;TIMES WORDS / PAGE
	ADD	T3,FSZ(ALTP)	;INPUT FILE EOF BYTE #
	MOVNS	T3		;- COUNT BEYOND HERE
	CAMGE	T3,[-1000]	;CHECK MAX
	MOVNI	T3,1000		;MAX ALLOWED
	HRLS	T3		;-WC,,0
	HRR	T3,BUF(ALTP)	;POINT TO BUFFER BEGINNING
	MOVEM	T3,PNT(ALTP)	;SAVE
IFN CRYPSW,<
	MOVE T1,PNT(ALTP)	;BUFFER PNTR
	HRRZ T2,CNT(ALTP)	;PAGE #
	MOVE T3,ICRCOD		;ASSUME CURRENT INPUT
	TLNE FL,COPFIL
	MOVE T3,ALTCOD		;NO - USE ALT INPUT
	PUSHJ P,CRYPT.##
	MOVE T3,PNT(ALTP)	;RESTORE PNTR
>
	POP	P,T2		;RESTORE REGS
	POP	P,T1
	JRST	GETWD1		;GET WORD

GTEOF:	HRRZ	T2,BUF(ALTP)	;GEN BUFFER PAGE #]
	LSH	T2,-^D9
	CALL	UNMAP		;REMOVE BUFFER
	POP	P,T2		;RESTORE REGS
	POP	P,T1		;...
	POP	P,ALTP		;PRUNE THIS ALSO
RTEOF1:	TRO	FL,EOF		;SET EOF FLAG
RTEOF:	MOVEI	T3,0		;RETURN ZERO
	RET			;...

;ROUTINE TO REMOVE PAGE SPECIFIED BY T2

UNMAPL:	PUSH	P,T1		;SAVE T1
	LSH	T2,-^D9		;CONVERT TO PAGE #
	CALL	UNMAP		;UNMAP IT
	POP	P,T1		;RESTORE T1
	RET			;RETURN

UNMAPO:
IFN CRYPSW,<
	MOVE T1,[-1000,,OBUF0]
	HRRZ T2,OPCNT		;LAST PAGE #
	AOS T2			;...
	MOVE T3,OCRCOD
	PUSHJ P,CRYPT.##	;ENCRYPT
>
	MOVEI	T2,<OBUF0>B44	;OUTPUT BUFFER PAGE
UNMAP:	HRLI	T2,.FHSLF	;FORK HANDLE
	MOVNI	T1,1		;SAY DELETE IT
	MOVEI	T3,0		;NO STATUS
	PMAP			;DO IT
	RET			;RETURN
;CHARACTER INPUT ROUINTE

GCHAR:	TRNE	FL,EOF		;CHECK EOF SEEN
	JRST	RTEOF
	PUSH	P,ALTP		;SAVE PNTR
	MOVEI	ALTP,CIPB	;ASSUME PRIMARY INPUT
	TLNE	FL,COPFIL	;USING ALTERNATE INPUT
	MOVEI	ALTP,AIPB	;YES - USE ALTERNATE
GCHAR0:	SOSLE	BYT(ALTP)	;CHECK CHARS LEFT
GCHAR1:	JRST	[ILDB T3,TXT(ALTP) ;GET ONE
		 JUMPE T3,GCHAR0 ;SKIP OVER NULLS
		 POP P,ALTP
		 RET]		;RETURN
	PUSH	P,T1		;NEED MORE - SAVE REGS
	PUSH	P,T2
	MOVE	T1,IJFN(ALTP)	;JFN TO USE
	HRRO	T2,BUF(ALTP)	;WHERE TO PUT INPUT
	MOVNI	T3,1000*5	;CHARS TO READ (PAGE)
	SIN			;SLURP!
	ADDI	T3,1000*5	;SEE HOW MANY READ
	JUMPE	T3,[POP P,T2	;RESTORE PDL
		    POP P,T1
		    POP P,ALTP
		    JRST RTEOF1]
	MOVEM	T3,BYT(ALTP)	;SAVE COUNT
	HRRZ	T3,BUF(ALTP)	;BUFFER ADDRS
	HRLI	T3,(POINT 7,,)	;FORM BP
	MOVEM	T3,TXT(ALTP)	;PNTR TO BUFFER
	POP	P,T2		;PRUNE PDL
	POP	P,T1
	JRST	GCHAR1		;AND EXIT
OUTWDZ:	MOVEI	T3,0		;OUTPUT A WORD OF ZEROES
OUTWD:	PUSH	P,T1		;SAVE T1
	MOVE	T1,OUPNT	;OUTPUT PNTR
	AOBJP	T1,OUTDO	;DUMP IF FULL
OUTWD1:	MOVEM	T3,0(T1)	;LOAD BUFFER
	MOVEM	T1,OUPNT	;RESTORE PNTR
	POP	P,T1		;PRUNE STACK
	RET			;EXIT

OUTDO:	PUSH	P,T2		;SAVE T2
	PUSH	P,T3		;AND WORD
	AOSGE	T1,OPCNT	;OUTPUT PAGE CNT
	JRST	[HRLZ T1,OCRJFN	;INIT PAGE 0
		 JRST OUTDO1]
IFN CRYPSW,<
	MOVE T2,T1		;PAGE #
	MOVE T1,[-1000,,OBUF0]
	MOVE T3,OCRCOD		;OUTPUT CODE
	PUSHJ P,CRYPT.##
	MOVE T1,OPCNT		;RESTORE PAGE #
>
	AOS	T1		;NEXT PAGE
	HRL	T1,OCRJFN	;OUTPUT JFN
OUTDO1:	MOVE	T2,[.FHSLF,,<OBUF0>B44]
	MOVSI	T3,(PM%WT)	;WRITE ACCESS
	PMAP			;GET NEXT PAGE FROM FILE
	MOVE	T1,[-1000,,OBUF0]
	POP	P,T3		;RESTORE REGS
	POP	P,T2		;...
	JRST	OUTWD1		;TRY TO DUMP WORD

;ROUTINE TO SET EOF PNTR FOR OUTPUT FILE

OUTFIN:	CALL	UNMAPO		;DELETE OUTPUT BUFFER
	AOS	T3,OPCNT	;# OF PAGES WRITTEN
	AOS	T3		;...
	LSH	T3,^D9		;CVT TO WORDS
	JUMPE	T3,OUTFN1	;HAVE SIZE IF 0
	HLRE	T1,OUPNT	;CHECK PARTIAL PAGE
	MOVNS	T1		;COUNT +1 OF WORDS UNWRITTEN
	SUBI	T3,-1(T1)	;ADJUST WORD COUNT
OUTFN1:	HRRZ	T1,OCRJFN	;GET JFN
	HRLI	T1,.FBSIZ	;SET EOF PNTR IN FILE
	MOVNI	T2,1		;SET MASK
	CHFDB			;SET FDB
	HRLI	T1,.FBBYV	;SET BYTE SIZE FIELD
	MOVSI	T2,(77B11)	;MASK
	MOVSI	T3,(<^D36>B11)	;BYTE SIZE
	CHFDB			;SET IT
	HRRZS	T1		;JFN ONLY
	PJRST	DOCLSF		;CLOSE IT
;ROUTINE TO DUMP BUFFER FROM BUFP TO (T1)

DUMP:	MOVE	T2,BUFP
	CAMGE	T2,T1		;CHECK TO SEE IF WE ARE DUMPING ANYTHING
	TRZ	FL,BOF		;IF SO TURN OFF BOF
	TRNN	FL,READOF	;RETURN IF READ ONLY MODE
DUMP1:	CAML	T2,T1		;MORE TO DO?
	POPJ	P,		;NO, RETURN
	LDB	T3,[POINT 7,OUPNT,17]
	CAIN	T3,176		;LAST WORD OF SECTOR?
	PUSHJ	P,OUTWDZ	;YES - DUMP ZERO
	MOVE	T3,0(T2)	;DUMP FIRST WORD
	CAMN	T3,PGMK		;COUNT PAGES
	AOS	OPG		;FOR =LOC COMMAND
	PUSHJ	P,OUTWD		;...
DUMP2:	SKIPE	T3,1(T2)	;LOOK FOR END
	TRNE	T3,1		; OR SEQUENCE NUMBER?
	AOJA	T2,DUMP1	;ANY END WILL DO
	PUSHJ	P,OUTWD		;DUMP WORD
	AOJA	T2,DUMP2	;LOOP BACK
	JRST	DUMP1		;GO CHECK FOR END

;ROUTINE TO DELETE FILE AND EXPUNGE

DODELF:	TLO	T1,(DF%NRJ) 	;RETAIN JFN
DDELFR:	TLO	T1,(DF%EXP)	;EXPUNGE ALSO
	DELF			;DELETE FILE
	  FJERR
	HRRZS	T1		;RETURN JFN
	RET			;RETURN

;ROUTINE TO CLOSE FILE AND RETAIN JFN

DOCLSF:	TLO	T1,(1B0)	;NO RELEASE JFN
DOCLSR:	CLOSF			;CLOSE
	  FJERR
	HRRZS	T1		;CLEAR LHS
	RET			;RETURN
INSIST:	OUTSTR	[ASCIZ "? You must type either "]
CONFRM:	OUTSTR	[ASCIZ "(y or n): "]
	CALL	INHELP		;GET RESPONSE
	 JRST	INSIST		;HE ASK FOR HELP
	CAIN	T1,"Y"		;IS IT YES?
	JRST	CPOPJ1		;YEP - SKIP RETURN
	CAIN	T1,"N"		;OR NO
	POPJ	P,		;NON-SKIP
	JRST	INSIST		;ELSE GRUMP AT HIM

GETN:	MOVE T1,WC	;GET THE NEXT BUFFER. FIND CURRENT WORD COUNT
	CAMGE T1,HLFWC	;GREATER THAN HALF OF MAX POSSIBLE?
	JRST FILLBF	;NO, JUST REFILL BUFFER
	ASH T1,-1	;YES, TAKE HALF OF IT
	ADD T1,BUFP	;CONVERT TO POINTER
GETN1:	SKIPN T2,(T1)	;LOOK FOR A WORD BOUNDARY
	JRST NOWFL	;WE ARE HERE?
	TRNN T2,1	;SEQUENCE NUMBER?
	SOJA T1,GETN1
NOWFL:	PUSHJ P,DUMP	;DUMP IT
	MOVE T2,T1	;COPY POINTER
	SUB T2,BUFP	;AND FIND OUT HOW MANY DUMPED
	SUB PNTR,T2	;ADJUST POINTER
	EXCH T2,WC	;CALC NEW WORD COUNT
	SUBB T2,WC
	ADD T2,BUFP	;GET POINTER TO END OF BUFFER
	HRLS T1		;SET UP BLT
	HRR T1,BUFP
	BLT T1,(T2)
	JRST FILLBF	;AND FINISH FILLIN BUFFER



FILLBF:	MOVE T1,WC	;GET WORD COUNT
	ADD T1,BUFP	;AND CONVERT TO POINTER TO END OF BUFFER
FILBF3:	CAML T1,FILPT	;FULL ENOUGH?
	POPJ P,		;YES, RETURN
	TLNE FL,TECOF	;SPECIAL READING FOR TECO FILES
	JRST RDTECO
	HRLI T1,-MXWPL-2	;GET A COUNT FOR MAX LINE SIZE
	SKIPN T3,SVWD	;SEE IF THERE IS A WORD LEFT FROM LAST TIME
	PUSHJ P,GETWD	;ELSE GET A NEW ONE
	JUMPE T3,SNEOF	;MUST BE EOF
	CAMN	T3,PGMK		;CHECK FOR PAGE MARKS
	JRST	CKPGMK		;GO FUDGE P/M
	TLZE FL,FSTOPF	;IF FIRST OP
	JRST CKTECO	;CHECK FOR TECO FILE
NOTECO:	MOVEM T3,SVWD2	;SAVE FOR SEQUENCE CHECK
	JRST FILBF4	;GO PUT IT AWAY
FILBF1:	PUSHJ P,GETWD	;ELSE GET A NEW ONE
	JUMPE T3,FILBF2	;0 WORD MUST BE EOF
	TRNE T3,1	;CHECK FOR SEQNUM
	JRST FILBF2	;YES, FINISH PUTTING IT IN
FILBF4:	MOVEM T3,(T1)	;PUT IN THIS WORD
	AOS WC		;AND ADVANCE WORD COUNT
	AOBJN T1,FILBF1	;ADVANCE POINTER AND CHECK COUNT
	JRST INLTL	;LINE IS TOO LONG
FILBF2:	MOVEM T3,SVWD	;SAVE THIS WORD
FILBF0:	SETZM (T1)	;MAKE SURE OF A ZERO WORD
	HRRZS T1	;ELIMINATE COUNT INFO
	MOVE T3,SVWD2	;CHECK ON ORDER OF INPUT LINES
	CAMG T3,OLDLIN	;CHECK FOR CORRECT ORDER
	JRST OUTOFO	;LINES ARE OUT OF ORDER
FILBF5:	MOVEM T3,OLDLIN	;SAVE FOR LATER
	SKIPE SVWD	;CHECK TO SEE IF WAS EOF
	JRST FILBF3	;AND TRY FOR MORE
SNEOF:	SETZM (T1)	;MAKE SURE OF ZERO WORD
	TRO FL,EOF2	;SET EOF FLAG
	MOVE T1,INPG	;GET INPUT PAGE
	MOVEM T1,BGPG	;AND SET LARGEST PAGE
	TRO FL,BGSN
	SETZM SVWD	;ALSO ZERO EXTRA WORD
	POPJ P,		;AND RETURN

CKPGMK:	SETZM	OLDLIN		;RESET LINE LAST INPUT
	AOS	INPG		;INCR INPUT PAGE
	MOVEM	T3,0(T1)	;STASH PGMK
	AOS	WC		;INCR WORD/COUNT
	PUSHJ	P,GETWD		;PASS NEXT WORD
	MOVE	T3,PGMKW2	;GRNTEE CORRECT P/M 2ND WORD
	MOVEM	T3,1(T1)	;STASH
	AOS	WC		;INCR WC
	SETZM	2(T1)		;GRNTEE ZERO WORD
	SETZM	SVWD		;FORCE READ
	MOVEI	T1,2(T1)	;CORRECT PNTR
	JRST	FILBF3		;CHECK FULL

INLTL:	PUSHJ P,GETWD	;FIND THE END OF THE LINE ON INPUT
	JUMPE T3,INLTL2	;THIS IS IT
	TRNN T3,1	;OR MAYBE THIS
	JRST INLTL	;KEEP LOOKING
INLTL2:	MOVEM T3,SVWD	;SAVE IT
	PUSH P,T1	;SAVE POINTER TO END OF IT
	SUBI T1,2	;LAST PART THAT IS IN THE LINE
	MOVEI T2,<BYTE (21)0(7)15,12>	;A CRLF
	DPB T2,[POINT 15,(T1),35]	;MAKE SURE IT ENDS PROPERLY
INLTL1:	SKIPN T2,(T1)	;NOW LOOK FOR THE START OF IT
	ERROR ICN	;SOMETHING HAS GONE WRONG, THERE IS NO LINE 
	TRNN T2,1	;START?
	SOJA T1,INLTL1	;NO, TRY AGAIN
	MOVE T2,INPG	;PRINT HIM THE CURRENT PAGE
	PUSHJ P,PGPRN
	PUSHJ P,OUTLIN	;PRINT THE LINE
	RERROR LTL	;AND THE ERROR MESSAGE
	POP P,T1	;RESTORE POINTER TO END
	SOS WC	;GET WORD COUNT CORRECTED
	SOJA T1,FILBF0	;AND CONTINUE FILL

OUTOFO:	PUSH P,T1	;SAVE THE POINTER
	PUSH P,T3	;SAVE T3 ALSO
	SUBI T1,1	;GET BACK INTO LINE
OUTOF1:	SKIPN T2,(T1)	;LOOK FOR START OF LINE
	ERROR ICN	;HORRIBLE CONFUSION
	TRNN T2,1	;CHECK FOR SEQ NUM
	SOJA T1,OUTOF1	;NOPE, TRY SOME MORE
	MOVE T2,INPG	;PRINT HIM THE PAGE
	PUSHJ P,PGPRN
	PUSHJ P,OUTLIN	;PRINT THE LINE
	RERROR ORDER	;GIVE HIM SOMETHING TO THINK ABOUT
	POP P,T3	;RESTORE
	POP P,T1	;GET SET TO GO ON
	JRST FILBF5	;GO
CKTECO:	TRNE	T3,1		;CHECK FOR A LINE NUMBER
	JRST	NOTECO		;NO ITS NOT A TECO FILE
	TLO	FL,TECOF	;SET WARNING FLAG
	SETZM	SVWD		;GRNTEE USE FIRST SEQ #
	SETZM	SVWD3		;CLEAR THIS (FORCED PM HACK)
	PUSH	P,T1		;SAVE T1
	TLNE	FL,COPFIL	;IS IT ANOTHER FILE?
	JRST	[SETZM AIPBYT	;CLEAR INPUT BYTE COUNT
		 HRRZ T2,AIPBUF	;PAGE TO UNMAP
		 CALL UNMAPL	;...
		 HRRZ T1,AIPJFN	;JFN TO RESET
		 JRST RDTECR]
	TLO	FL2,PCHGF!FCHGF	;SAY WE'VE CHANGED
	SETZM	CIPBYT		;CLEAR INPUT BYTE COUNT
	HRRZ	T2,CIPBUF	;PAGE TO UNMAP
	CALL	UNMAPL		;DO IT
	HRRZ	T1,CIPJFN	;SET UP FOR FILE RESET
RDTECR:	MOVEI	T2,0		;SET PTR TO ZERO
	SFPTR			;...
	  FJERR			;SHOULDNT HAPPEN
	POP	P,T1		;RESTORE T1

RDTECO:	HRRZM	T1,TMPT1	;SAVE THIS FOR A WHILE
	MOVEI	T3,1(T1)	;ZERO OUT A FEW WORDS
	HRL	T3,T1
	SETZM	(T1)
	BLT	T3,MXWPL(T1)
	ADDI	T1,1		;THIS IS WHERE CHRS SHOULD BE PUT
	PUSH	P,T1		;SAVE
	SKIPE	T1,SVWD		;CHECK BEGINNING OF PAGE
	CAIN	T1,1		;...
	JRST	[MOVE T1,TECFST
		 MOVEM T1,SVWD
		 MOVEM T1,SVWD2
		 JRST RDTEC1]
	MOVE	T2,TECINC	;GET INCREMENT
	PUSHJ	P,ASCIAD
	MOVEM	T1,SVWD		;SAVE FOR LATER
	MOVEM	T1,SVWD2	;AND FOR ORDER CHECK
	CAMGE	T1,TECINC	;CHECK WAR
	JRST	INSPG1		;FORCE PAGE INSERT
RDTEC1:	EXCH	T1,(P)		;GET OLD T1 BACK AND SAVE NUMBER
	MOVEI	T2,MXWPL*5-2	;COUNT
	MOVEI	T3,11		;FIRST CHR
	HRLI	T1,(<POINT 7,0>)
	IDPB	T3,T1
	SKIPN	T3,SVWD3	;SEE IF WE ALREADY TOOK CHAR
LINL1:	CALL	GCHAR		;NEXT CHR
LINL1A:	CAIN	T3,15
	JRST	LINL1		;IGNORE RETURNS
	SETZM	SVWD3		;SAY WE GOT IT
	CAIN	T3,14
	JRST	IPGMK		;INSERT PAGE MARK
	JUMPE	T3,EOF1		;MUST BE END OF FILE
	POP	P,-1(T1)	;PUT NUMBER IN PROPER PLACE
	JRST	LP1		;AND READ MORE OF LINE
CLP:	CALL	GCHAR
LP1:	CAIN	T3,15		;IGNORE RETURNS
	JRST	CLP
	CAIE	T3,0		;FOR EOF
	CAIN	T3,12		;OR LINE FEED
	JRST	LINFD		;GO PUT IN RETURN LINE FEED
	CAIN	T3,14
	JRST	LINFD
	IDPB	T3,T1		;ELSE DEPOSIT
	SOJG	T2,CLP		;HAVE WE RUN OUT
	ADD	T1,[XWD 700,0]	;BACK UP POINTER
	TLZ	FL,TECOF	;USE THE ABSENCE AS A FLAG
LP2:	CALL	GCHAR		;(205) GET A CHARACTER
;**;[254]  Add 1 line after LP2:+0			DML	27-Mar-85
	CAIE 	T3,0		;[254] At the end of the file?
	CAIN	T3,12		;(205) IS IT A LINEFEED?
	JRST	LINFD		;(205) YES
	CAIN	T3,14		;(205) FORMFEED?
	JRST	LINFD		;(205) YES
	JRST	LP2		;(205)
LINFD:	CAIN	T3,14		;(200) IS IT A FORMFEED?
	MOVEM	T3,SVWD3	;(200) YES
	MOVEI	T3,15		;(200)
	IDPB	T3,T1
	MOVEI	T3,12
	IDPB	T3,T1
	MOVEI	T1,1(T1)
	MOVE	T3,T1
	SUB	T3,TMPT1	;GET COUNT
	ADDM	T3,WC
	TLOE	FL,TECOF	;IF OFF WE HAD A LTL ERR
	JRST	FILBF0		;THIS WILL FINISH UP
	PUSH	P,T1		;SET UP FOR LTL CODE
	AOS	WC
	AOS	(P)
	SOJA	T1,INLTL1

INSPG1:	POP	P,T1		;RESTORE PNTR
	PUSHJ	P,MAKPM		;GENERATE PAGE MARK
	CALL	GCHAR		;PEEK AT NEXT CHAR
	CAIN	T3,15		;IGNORE CRS
	JRST	.-2
	CAIN	T3,14		;IF FF THEN SKIP IT
	JRST	FILBF3		; (ALREADY HAVE PM)
	MOVEM	T3,SVWD3	;SAVE FOR LATER
	JRST	RDTECO		;PROCESS NEXT LINE.

IPGMK:	POP	P,0(P)		;CLEAN OFF STACK
	PUSHJ	P,MAKPM		;GENERATE PAGE MARK
	JRST	FILBF3		;FINISH OFF

MAKPM:	MOVEI	T3,1		;SO IT WILL NOT BE EOF
	MOVEM	T3,SVWD		;SO WE START OVER
	MOVE	T3,PGMK
	MOVEM	T3,OLDLIN
	MOVEM	T3,-1(T1)
	MOVEI	T2,2
	ADDM	T2,WC
	MOVE	T3,PGMKW2
	MOVEM	T3,(T1)
	SETZM	1(T1)		;GRNTEE ZERO
	MOVEI	T1,1(T1)	;UPDATE PNTR
	AOS	INPG		;INCR INPUT PAGE
	POPJ	P,		;RETURN

EOF1:	POP	P,T2		;CLEAR STACK
	SOJA	T1,SNEOF

SUBTTL RANGE SPECIFIER READERS

;ROUTINE TO GET ONE LINE NUMBER FROM INPUT STREAM. HANDLES + AND -

GETLS:	PUSHJ P,SCAN
GETL:	TRZ FL,LINSN!ADDL!SUBL
	TRZ FL2,STARF
	TLZ FL2,UARWF
	CAIN C,"^"
	JRST DOFST
	CAIN C,"*"
	JRST DOLST
IFN EXTEND,<
	CAIN C,200	;DO WE HAVE TO SEARCH FOR IT
	PUSHJ P,LSRCH	;OK THEN HERE WE GO
>
	TRZN FL,NUMF
	POPJ P,		;SCAN DID NOT SEE A NUMBER RETURN (CALLER CAN GIVER ERR)
	MOVEM T1,HILN	;SAVE THE NUMBER HERE
GETL1:	TRO FL,LINSN	;SET A FLAG TO SAY WE SAW THE LINE
	PUSHJ P,SCAN	;SCAN FOR + OR -
	CAIN C,"+"
	JRST ADDNUM
	CAIE C,"-"
	POPJ P,		;NEITHER
	TROA FL,SUBL	;SET SUBTRACT FLAG
ADDNUM:	TRO FL,ADDL	;SET ADD FLAG
	PUSHJ P,SCAN	;SCAN ANOTHER
	TRZN FL,NUMF	;WAS IT A NUMBER
	NERROR ILC	;ANYTHING ELSE IS ILLEGAL
	MOVEM T2,SVINC	;SAVE IT
	JRST SCAN	;RETURN AFTER SCANNING ONE MORE
DOLST:	TRO FL2,STARF
	JRST GETL1
DOFST:	TLO FL2,UARWF
	JRST GETL1
;ROUTINE TO RESOLVE THE + AND - IN THE LINE NUMBER. WE MUST WAIT
;UNTIL THE PAGE HAS BEEN DEFINED BEFORE DOING THIS

ADDSUB:	MOVE SINDEX,HILN	;GET THE NUMBER
	MOVE T1,HIPG	;GET THE REQUIRED PAGE
	MOVEM T1,DPG	;AND SET IT AS THE DESIRED ONE
	TLNE FL2,UARWF
	JRST	[PUSHJ P,EVALUP
		 JRST DOAS]
	TRNN FL2,STARF
	JRST DOAS
	MOVE SINDEX,[<ASCII /99999/>!1]	;FIND A BIG LINE
	PUSHJ P,FIND
	CAME T1,[<ASCII /99999/>!1]	;IF ITS THERE ITS LAST
	PUSHJ P,FINDB		;ELSE BACK UP
;**;[240]	Delete 3 lines and insert 3 at ADDSUB:+12	KR	5/6/82
	CAIE T1,0	;[240] FIND A 0
	CAMN T1,PGMK	;[240] OR A PAGE MARK?
	MOVE T1,TECFST	;[240] THEN WE HAD EMPTY PAGE, START AT TECFST
	MOVE SINDEX,T1	;OK, USE ONE FOUND, ELSE LEAVE BIG
DOAS:	TRZE FL,ADDL	;DID WE WANT TO ADD?
	JRST ADLIN	;YES, GO ADD
	TRZN FL,SUBL	;OR SUBTRACT?
CPOPJ:	POPJ P,	;NO, RETURN
	PUSHJ P,FIND	;GET THE DESIRED LINE
SUBL1:	SOSGE SVINC	;DO WE WANT TO GO BACK STILL FARTHER
	POPJ P,		;NO, ALL DONE
	PUSHJ P,FINDB	;GET THE PREVIOUS LINE
	SKIPE T1	;0 MUST BE AT START OF BUFFER, QUIT
	CAMN T1,PGMK	;WAS IT A PAGE MARK?
	POPJ P,		;YES, AS FAR AS WE GO, SINDEX HAS CORRECT NUMBER
	MOVE SINDEX,T1	;THIS WILL DO
	JRST SUBL1	;GO TRY FOR MORE
ADLIN:	PUSHJ P,FIND	;GET DESIRED LINE
	CAME T1,PGMK	;WAS IT A PAGE MARK?
;**;[251]  Change 1 line at ADLIN:+2			DML	9-NOV-83
	JUMPN T1,ADLIN2	;[251] OR 0 (I.E. END OF FILE)
	POPJ P,		;RETURN WITH ORIGINAL NUMBER
;**;[251]  Remove 3 lines at ADLIN1:+0			DML	9-NOV-83
REPEAT 0,<		;[251] REMOVE ROUTINE ADLIN1
ADLIN1:	CAME T1,HILN	;SEE IF AN EXACT MATCH
	SOS SVINC	;IF NO, ALREADY ARE +1
	MOVE SINDEX,T1	;GET THE WORD WE HAVE FOUND
>			;[251] END OF REMOVAL
ADLIN2:	SOSGE SVINC	;NEED TO GO FURTHER
	POPJ P,		;NO, RETURN RESULTS
	PUSHJ P,FINDN	;GET THE NEXT LINE IN SEQUENCE
	CAME T1,PGMK	;PAGE MARK?
	JUMPN T1,.+2	;OR EOF
	POPJ P,		;YES, RETURN
	MOVE SINDEX,T1	;ACCEPT NEW NUMBER
	JRST ADLIN2	;AND LOOK FOR MORE
;EVALUP - ROUTINE THAT ASSIGNS THE CORRECT VALUE TO UP-ARROW
;
;	  UP-ARROW IS THE FIRST LINE FOUND ON THE PAGE,
;	  UNLESS WE ARE IN INSERT MODE.  IN INSERT MODE,
;	  IF 00000 DOES NOT EXIST, UP-ARROW IS A LINE
;	  HALFWAY BETWEEN 00000 AND THE FIRST LINE ON THE PAGE.
;	ALSO FOR TRANS/COPY, BECAUSE IF HE SAYS ^/X IS DESTINATION,
;	HE WANTS STUFF AFTER PGMK, NOT AFTER 1ST LINE ON PAGE.

EVALUP:	MOVE	SINDEX,[<ASCII /00000/>!1] ;LOOK FOR LINE 00000
	PUSHJ	P,FIND		;PUT IN T1, ELSE GET NEXT LINE
	SKIPE	T1		;FOUND EOF?
	CAMN	T1,PGMK		;NO, BUT IS IT A PAGE MARK?
	JRST	[MOVE T1,TECFST
		 JRST EVALU1]	;USE line = START IF EOF OR PGMK
;**;[248]  Add 2 lines after EVALUP:+5		DML	27-APR-83
	TLNE	FL,COPFIL	;[248] IS THIS A COPY FROM A FILE?
	JRST	EVALU1		;[248] YES, USE LINE NUMBER ALREADY FOUND
	TLNN	FL2,EXCPFL	;DO SPECIAL STUFF IF COPY
	TRNE	FL2,UPTOPF	;OR IF INSERT 
	SKIPA
	JRST	EVALU1		;GO SAVE WHAT WE GOT
	CAMN	T1,[<ASCII /00000/>!1] ;DID WE FIND LINE 00000 EXISTS?
	JRST	[TLNN FL2,EXCPFL
		  NERROR ILR		;IS AN ERROR OTHERWISE
		JRST .+1]
	CAMLE	T1,TECFST	;IS THIS LINE <= START?
	JRST	[MOVE T1,TECFST
		TLNN FL2,EXCPFL
		 JRST EVALU1	;No, Use line = start 
		JRST .+1]
	MOVE	T2,[<ASCII /00000/>!1] ;Yes, GET READY TO AVERAGE for new one
	PUSHJ	P,ASCAV		;AVERAGE 0 AND FIRST LINE
	MOVE	T1,T2		;PUT ANSWER IN T1
EVALU1:	MOVE	SINDEX,T1	;SAVE RESULT IN SINDEX
	POPJ	P,

;ROUTINE GETS A FULL SEQ NUMBER OF FORM A/B

GETLAS:	PUSHJ P,SCAN
GETLA:	TRZ FL,PGSN	;NO PAGE SEEN YET
	PUSHJ P,GETL	;GET THE LINE NUMBER PART
	MOVE T2,CPGL	;IN CASE LSRCH GOT A NEW PAGE
	TRNE FL,PGSN	;DID LSRCH GET PAGE?
	MOVEM T2,HIPG	;YES, USE IT
	CAIE C,"/"	;IS THIS A PAGE COMING?   
	JRST NOPG	;NO, A LINE NUMBER AT MOST
	PUSHJ P,SCAN	;YES, GET THE PAGE NUMBER
	CAIN C,"*"
	JRST LASTPG		;GET LAST PAGE #
	CAIE C,"^"		;UPARROW MEANS
	JRST GETLPG		;GET PAGE 1
	MOVEI T2,1
	TRO FL,NUMF		;MAKE LIKE NUMBER
GETLPG:	SKIPLE T2	;NUMBERS .LE. 0 LOSE
	TRZN FL,NUMF	;WAS IT A NUMBER
	NERROR ILC	;LOSE LOSE
	TRO FL,PGSN	;YEP, WE SAW IT
	MOVEM T2,HIPG	;SAVE THAT NUMBER
	PUSHJ P,SCAN	;CHECK FOR + OR -
	CAIN C,"+"
	JRST PGPLS
	CAIE C,"-"
	JRST NOPG	;NO, GO DO ADSUB ON LINE NUMBER
	PUSHJ P,SCAN	;GET THE NUMBER
	TRZN FL,NUMF	;MUST BE A NUMBER
	NERROR ILC
	MOVE T1,HIPG
	SUB T1,T2
	MOVEM T1,HIPG	;FILL IN NUMBER
NOPGA:	PUSHJ P,SCAN	;SCAN PAST NUMBER
NOPG:	TRNN FL,LINSN!PGSN	;DID WE SEE A LINE OR A PAGE?
	NERROR ILC	;NO, SOMETHING IS WRONG
	PUSH P,T1	;SAVE (HAVE ALREADY SCANNED)
	PUSH P,T2
	PUSHJ P,ADDSUB	;TAKE CARE OF + AND - FOR LINE
	POP P,T2
	POP P,T1
	MOVEM SINDEX,HILN	;SAVE RESULT
	POPJ P,		;AND RETURN

PGPLS:	PUSHJ P,SCAN	;GET NUMBER TO ADD
	TRZN FL,NUMF	;A NUMBER?
	NERROR ILC	;NO, NERROR
	ADDM T2,HIPG	;ADD IT IN
	JRST NOPGA	;AND CLEAN UP

LASTPG:	TRNE	FL,BGSN		;SEEN LAST
	JRST	LSTPG1		;YES: SKIP CODE
	MOVSI	T1,1
	MOVEM	T1,DPG		;TRY FOR LARGE
	MOVEI	SINDEX,0
	PUSHJ	P,FIND
	TRNN	FL,BGSN		;SHOULD SEE IT NOW
	ERROR	ICN
LSTPG1:	MOVE	T2,BGPG
	TRO	FL,NUMF		;NUMBER SEEN
	JRST	GETLPG



;ROUTINE SETS HIPG IN CASE NONE SEEN BY GETLA, THEN CALLS GETLA

GET1S:	PUSHJ P,SCAN
GET1:	MOVE T3,CPGL
	MOVEM T3,HIPG
	JRST GETLA



;GET A PAIR OF FORM A/B,C/D LOLN IS SET BY CALLER BEFORE CALL

GET2S:	PUSHJ P,SCAN
GET2:	TRZ FL,CNTF	;NOT A ! COMMAND
	PUSHJ P,GET1	;GET A LINE AND PAGE NUMBER PAIR
	MOVE T3,HIPG	;NOW SET LOWER PAGE TO THE ONE SEEN
	MOVEM T3,LOPG
	MOVE T3,HILN	;RESET LOW LINE IS A NUMBER SEEN
	TRNE FL,LINSN
	MOVEM T3,LOLN
GET2HF:MOVE T3,[<ASCII /99999/>!1]	;SET UP A LARGE NUMBER
	TRNN FL,LINSN	;IF NO LINE NUMBER SEEN
	MOVEM T3,HILN
	TRZ FL,PGSN	;SO DELETE CAN DETECT A SECOND PAGE SPEC
	CAIN C,"!"	;IS IT A ! COMMAND?
	JRST GET2CT	;GO TAKE CARE OF IT
	CAIE C,":"	;CHECK FOR SECOND SET
	POPJ P,		;NOPE, RETURN
	MOVEM T3,HILN	;SET HILN ANYWAY
	JRST GETLAS	;AND GO GET THE SECOND PAIR

GET2CT:	TRO FL,CNTF	;SET THE APPROPRIATE FLAG
	PUSHJ P,SCAN	;THERE SHOULD BE A NUMBER HERE
	TRNN FL,NUMF
	NERROR ILC	;LOSE
	MOVEM T2,SVCNT	;HANG ON TO IT
	JRST SCAN	;SCAN NEXT AND RETURN


SUBTTL LINE NUMBER SEARCH
IFN EXTEND,<
;SEARCH FOR A LINE AND USE ITS NUMBER INSTEAD OF .
;MOSTLY PLAGIARIZED FROM SEARCH

LSRCH:	PUSH	P,SVINC	;SAVE PREVIOUSLY GATHERED LINE NUMBERS
	PUSH P,SVCNT
	PUSH	P,HIPG
	PUSH	P,LOLN
	PUSH	P,LOPG
	PUSH	P,FL	;SAVE FLAGS IN CASE CALLED WITHIN SEARCH
	PUSH P,FL2
	TLO FL2,SRCWHO		;(203) SEARCH IS LOOKING
	TLZ	FL,ASSMF	;CLEAR ALL FLAGS
	SETZM LOLN	;JUST LIKE EVERYONE ELSE HAS TO
	SETZM LSCNT	;START WITH ZERO
	MOVE T1,[ASCII "L*"]
	MOVEM T1,FSFLG		;SETUP FLAG
	SOSGE	LSBUFN	;GET STRING BUFFER NUMBER
	NERROR	TMS	;NESTING TOO DEEP
	MOVE	T2,LSBUFN	;INDEX IN STRING BUFFER TABLES
	MOVE	T1,LSPTR(T2)	;SET UP BYTE POINTER
	MOVE T3,LSPTT(T2)	;AND POINTER TO BYTE POINTER TABLE
	PUSHJ P,SSTRNG	;GET A SEARCH STRING
	JRST	[MOVE T2,LSBUFN		;INDEX TO POINTERS
		SKIPN @LSPTT(T2)	;WAS STRING SET?
		NERROR NSG	;NO, TELL HIM
		CAIN C,12
		JRST ASLMD1	;SPECIAL CONTINUE MODE
		JRST .+1]	;YES, USE OLD ONE
	TLZ FL,NUMSRF!DECID!EXCTSR	;CLEAR FLAGS
	PUSHJ P,SCAN	;CHECK FOR WHAT COMES AFTER
	TRNN FL,TERMF	;IF TERMINATOR
	CAIN C,","	;OR ,
	JRST ASLMDT	;SET UP LIMITS SPECIALLY
	CAIE C,"!"
	CAIN C,":"
	JRST ASLMDT	;LET HIM SPECIFY 2ND HALF OF RANGE
	PUSHJ P,GET2	;ELSE CALL USUAL LIMIT ROUTINE
LSC4:	MOVE T1,HILN	;SAVE END OF RANGE
	MOVEM T1,LSHILN
	MOVE T1,HIPG
	MOVEM T1,LSHIPG
	CAIE C,","	;ANY MORE ARGUMENTS?
	JRST LSC1	;NO, CHECK TERMINATOR AND PROCEED
	PUSHJ P,SCAN	;YES, SEE WHAT IT IS
	TRNN FL,IDF	;SHOULD BE IDENT OR NUMBER
	JRST LSC2	;NOT IDENT, CHECK FOR NUMBER OF SEARCHES
	MOVS T1,ACCUM	;GET THE IDENT
	CAIN T1,(<SIXBIT /N  />)	;AND FIND OUT WHAT IT IS
	TLO FL,NUMSRF!DECID
	CAIN T1,(<SIXBIT /D  />)
	TLO FL,DECID	;WANTS TO DECIDE ON LINE
	TLNN FL,NUMSRF!DECID	;WAS IT EITHER?
	JRST LSC3	;NO, CHECK E
	PUSHJ P,SCAN	;CONTINUE LOOKING
	CAIE C,","
	JRST LSC1	;NO MORE ARGUMENTS
	PUSHJ P,SCAN	;WELL WHAT KIND IS THIS ONE?
	TRNN FL,IDF	;MORE IDENTS?
	JRST LSC2	;NO, MUST BE NUMBER OF SEARCHES
	MOVS T1,ACCUM
LSC3:	CAIE T1,(<SIXBIT /E  />)
	NERROR ILC	;NO, HE MUST HAVE MADE A MISTAKE
	TLO FL,EXCTSR	;YES, REMEMBER IT
	PUSHJ P,SCAN	;AND CHECK FOR MORE
	CAIE C,","
	JRST LSC1	;NO MORE
	PUSHJ P,SCAN	;ONLY ONE THING IT CAN BE NOW
LSC2:	TRNN FL,NUMF
	NERROR ILC	;NOPE, LOSE
	MOVEM T2,LSCNT	;SAVE AS COUNT OF LINES TO FIND
	PUSHJ P,SCAN	;GET TERMINATOR (WE HOPE)
LSC1:	TRNN FL,TERMF	;ALLS WELL THAT ENDS WELL
	NERROR ILC	;BUT THIS DOSNT
LSCH1A:	MOVE T1,LSBUFN
	MOVE T1,LSPTT(T1)	;GET POINTER TO STRINGS
	PUSHJ P,CODSR	;AND GENERATE CODE
	MOVE T1,LOPG	;GET SET TO HUNT IT
	MOVEM T1,DPG
	MOVEM T1,LSPG	;FLAG TO SAY IF WE SHOULD PRINT PAGE
	MOVE SINDEX,LOLN
	PUSHJ P,FIND
	TRZ FL,LINSN	;NO LINES YET
ONLSC:	PUSHJ P,ONMOV	;CHECK RANGE
	JRST ENDLSC	;DONE
	TLZE FL,ASSMF	;FIRST TIME AND WANT .+1?
	JRST	[CAME T1,LOLN	;IS THERE EXACT MATCH?
		JRST .+1	;NO, THIS IS .+1
		AOS SVCNT	;PRETEND WE DIDNT SEE IT
		JRST LSNXT]	;AND TAKE NEXT
	CAMN T1,PGMK	;PAGES ARE SPECIAL
	JRST LSCPAG	;SO TAKE GOOD CARE OF THEM
	MOVE T2,LSBUFN
	MOVE T2,LSPTT(T2)	;POINTER TO STRINGS
	PUSHJ P,COMSRC	;GO SEARCH THIS LINE
	JRST LSNXT	;LOSER
	MOVE T2,CPG	;GET CURRENT PAGE
	CAME T2,LSPG	;AND SEE IF WE SHOULD PRINT IT
	PUSHJ P,PGPRN	;YES
	MOVE T2,CPG	;NOW SET IT AS CURRENT
	MOVEM T2,CPGL
	MOVEM T2,LSPG	;ALSO RESET FLAG
	MOVE T2,(PNTR)	;ALSO SET LINE
	MOVEM T2,CLN
	TRO FL,LINSN	;WE SAW ONE
	TLNN FL,DECID	;DOES HE WANT OPTION?
	JRST LSNXTC	;NO, GO GET NEXT ONE OR STOP
	TLNE FL,NUMSRF	;DO WE WANT ONLY LINE NUMBERS?
	JRST LSCNUM	;YES
	MOVE T1,PNTR	;GO PRINT LINE
	PUSHJ P,OUTLIN
LSNXT1:
	INCHRW T1
	ANDI T1,177
	OCRLF
	CAIE T1,177	;DID HE SAY RUBOUT(DO NOT USE)?
	JRST LSOUT	;NO, WE'RE THROUGH
LSNXTC:	SOSG LSCNT	;HAVE WE FOUND ENOUGH
	JRST LSOUT	;YES, GIVE UP (WE HAVE SEEN AT LEAST ONE)
LSNXT:	PUSHJ P,FINDN	;GET NEXT LINE TO LOOK A
	JRST ONLSC
LSCNUM:	MOVE T1,(PNTR)	;PRINT SEQUENCE NUMBER
	PUSHJ P,OUTSN
	OCRLF
	JRST LSNXT1	;AND DECIDE
ENDLSC:	TRZN FL,LINSN	;DID WE SEE ONE?
	NERROR NLN	;NULL RANGE
	JRST LSOUT
LSCPAG:	AOS CPG	;JUST ADVANCE PAGE COUNTER
	JRST LSNXT	;AND PROCEED
LSOUT:	POP P,FL2	;RESTORE THE FLAGS WE USED
	POP P,T1
	AND T1,[XWD ASSMF!NUMSRF!EXCTSR!DECID,ADDL!SUBL!CNTF]
	ANDCM FL,[XWD ASSMF!NUMSRF!EXCTSR!DECID,ADDL!SUBL!CNTF]
	IOR FL,T1
	POP P,LOPG	;RESTORE PREVIOUS LINE NUMBERS
	POP P,LOLN
	POP P,HIPG
	POP P,SVCNT
	POP P,SVINC
	MOVE T1,CLN	;LOAD CURRENT LINE AND PAGE WHICH WE FOUND
	MOVE T2,CPGL
	TRO FL, NUMF!PGSN	;AND MAKE LIKE SCAN SAW A NUMBER
	AOS LSBUFN	;GO BACK TO SEARCH STRING ON PREVIOUS LEVEL IF ANY
	POPJ P,		;AND EXIT VICTORIOUS
ASLMD1:	TROA FL,CNTF	;MARK AS KEEP END OF RANGE
ASLMDT:	TRZ FL,CNTF	;JUST IN CASE
	TLO FL,ASSMF	;WE ASSUME .+1
	MOVE T1,CLN	;SET THINGS UP FOR . TO INFINITY
	MOVEM T1,LOLN
	MOVEM T1,HILN	;AS GOOD AS ANYTHING WITH THE PAGE WE WILL
	MOVE T1,CPGL	;USE
	MOVEM T1,LOPG
	TRZE FL,CNTF	;KEEP END?
	JRST LNOSPC	;YES
	CAIE C,":"	;IF A : OR !
	CAIN C,"!"
	JRST HALFLS	;GET THE SECOND HALF (.+1 TO GIVEN)
	MOVSI T1,377777	;GET A LARGE PAGE
	MOVEM T1,HIPG
	JRST LSC4	;BACK INTO THINGS

HALFLS:	MOVEM T1,HIPG	;SET TOP AS /.
	PUSHJ P,GET2HF	;GET THE SECOND HALF
	JRST LSC4	;AND GO

LNOSPC:	MOVE T1,LSHIPG
	MOVEM T1,HIPG	;PUT BACK END
	MOVE T1,LSHILN
	MOVEM T1,HILN
	JRST LSCH1A
>

SUBTTL INITIALIZE


;HERE IS THE INITIALIZE CODE

STPT:	RESET
	SETZB	T1,RPGSW
	RSCAN			;GET RE-READ OF COMMAND
	  FJERR
RDFLNA:	SETZM	ZEROB
	MOVE	T1,[XWD ZEROB,ZEROB+1]
	BLT	T1,IMPEND-1
	MOVE	T1,[BYTE (7) 15,15,15,15,15]
	MOVEM	T1,CRSX		;PUT CR'S IN PLACE
	MOVE	P,[IOWD PDLSIZ,PDL]

	MOVSI	FL,QMODF	;SET FOR ' IS NOT SPECIAL
	MOVEI	FL2,0		;NOTHING IN SECOND FLAG REGISTER
	SETOM	BAKF		;SET FOR BAK FILE
	MOVEI	T1,TTYCH	;SET UP DEFAULT INPUT
	MOVEM	T1,CHIN		;...
	MOVE	T1,[POINT 7,CMDBUF] ;POINT TO COMMAND BUFFER
	MOVEM	T1,P.TEXT	;STORE POINTER FOR READING
;**;[243]	Replace 7 lines with 8 at RDFLNA:+13	DML	9/21/82	
	HRROI	T1,CMDBUF	;[243] INPUT BUFFER
	HRLI	T2,40000	;[243] ALLOW BREAK ON END OF LINE
	HRRI	T2,5*SRBLG-1	;[243] INPUT BUFFER SIZE
	HRROI	T3,[ASCIZ !Type "EDIT filename" or "CREATE filename": !]	
				;[243] REPROMPT MESSAGE
	RDTTY			;[243] GET USER INPUT
	  FJERR			;[243] 
	MOVEI	T3,12		;[243] GRNTEE PROPER TERMINATOR
	IDPB	T3,T1		;[243] ...
;**;[245]	Change 1 line at RDFLNA+24		DML	10/21/82
CMDCON:	SETOM	RPGSW		;[245] SAY WE HAVE INPUT
	MOVEI	T1,.PRIOU	;CHECK TERMINAL MODE
	RFMOD			;GET MODES
	MOVEM T2,MODW		;SAVE MODE WORD
	RFCOC
	MOVEM T2,COCW1		;SAVE COC WORDS
	MOVEM T3,COCW2		;...
	MOVEI T1,.FHSLF		;SET TO DISABLE COMPAT
	MOVNI T2,1		;BY SETTING EV TO -1
	MOVEI T3,0
	SCVEC			;...
RPGRET:	MOVE	T1,[CALL ERRHD0] ;SET UP LUUO HANDLER
	MOVEM	T1,.JB41##
	CALL	INIPSI		;INIT PSI STUFF
	SETZM	TTICNT		;EMPTY INPUT
	MOVE	T1,[POINT 7,TTOBUF]
	MOVEM	T1,TTOPNT	;SET UP TTY OUTPUT BUFFER
	MOVEI	T1,^D80
	MOVEM	T1,TTOCNT
NOCOM0:	TLNN	FL2,AUTOF
	MOVE	P,[IOWD PDLSIZ,PDL]
	TRNE	FL2,SVIT	;SKIP * IF DOING W COMMAND
	JRST	RPGR1
	TLZ	FL2,INPARS!BELLF ;SAY WE ARE STARTING
	SETZM	OPTION		;LOOK FOR DEFAULT
	PUSHJ	P,DOOPT
	  JRST	.+2		;IGNORE NOT FOUND RETURN
	JRST	[OUTSTR	[ASCIZ "? Syntax error in default options"]
		 SETZM RPGSW	;CLR CMD MODE
		 CALL CLRBFI
		 JRST .+1]
NOCOM1:	TLO	FL2,INPARS	;SET FOR PARSE
	PUSHJ	P,PARSE
RPGR1:	TLZ	FL2,INPARS	;PARSE DONE
	MOVE	T1,[ORGBLK,,ICRBLK]
	BLT	T1,ICRBKE	;MOVE INFO TO INPUT BLOCK
	HRROI	T1,[ASCIZ "EDIT-BUFFER.OUT"]
	HRROI	T2,OCRASZ	;OUTPUT BLOCK
	CALL	MAKTMP		;MAKE TEMP FILE SPEC
	HRROI	T1,OCRASZ	;SETUP PNTR
	MOVEM	T1,OCRFIL	;TO FILESPEC
IFN CRYPSW,<
	MOVE T1,ORGCOD		;GET ORIG FILE PSW
	TRNE FL,NEWFL		;DO WE HAVE A NEW FILE?
	MOVE T1,NEWCOD		;YES - USE IT INSTEAD
	MOVEM T1,OCRCOD		;NO - USE ORIG PSW
>
	SKIPE	T1,CREATF	;WAS FILE FOUND?
	JRST	NOFILE		;NO - TRY CREATE
	MOVEI	T1,IBUF0	;SET UP BUFFER ADDRS
	MOVEM	T1,CIPBUF	;...
	MOVE	T1,ICRJFN	;GET INPUT JFN
	MOVEM	T1,CIPJFN	;SAVE FOR INPUT ROUTINES
	DVCHR			;GET DEVICE CHARACTERISTICS
	LDB	T2,[POINT 9,T2,17]
	CAIE	T2,.DVDSK	;BETTER BE DISK
	JRST	NOTDKI		;NOPE
	MOVE	T1,ICRJFN	;RESTORE JFN
	MOVE	T2,[7B5+OF%RD]	;OPEN FOR READ
	OPENF			;OPEN FILE
	  FJERR			;FATAL JSYS ERROR
	MOVEI	ALTP,CIPB	;BASE PNTR
	CALL	GFSIZE		;GET FILE SIZE IN WORDS
	SETOM	CIPCNT		;INIT PAGE CNTR
	SETZM	CIPPNT		;CLEAR BUFFER
	SETZM	CIPBYT		;...
FILRET:	TRNE	FL,READOF	;READ-ONLY?
	JRST	FILRT1		;YES - SKIP THIS
	MOVSI	T1,(GJ%FOU!GJ%SHT!GJ%TMP)
	MOVE	T2,OCRFIL	;PNTR TO FILESPEC
	PUSHJ	P,GTJFNX	;TRY TO GET A JFN
	 JRST	[CALL CANTOP	;CANT OPEN TEMP FILE
		 CALL CJERR0	; GIVE SYSTEM MESSAGE
		 JRST LOSER]	;T/S
	MOVEM	T1,OCRJFN	;SAVE JFN
	DVCHR			;CHECK ON DISK
	LDB	T1,[POINT 9,T2,17]
	CAIE	T1,.DVDSK
	JRST	NOTDKO		;ULOSE
FILRT1:	MOVEI	T1,BUF0		;START OF EDIT BUFFER
	SETZM	0(T1)		;SAVE A ZERO WORD
	ADDI	T1,1		;NEXT ONE IS START OF
	MOVEM	T1,BUFP		;  BUFFERS
MOCO:	SKIPN	T1,NPAGS	;FIND END OF EDIT WINDOW
	MOVEI	T1,DEFPAG	;USE DEFAULT IF NONE GIVEN
	MOVEM	T1,NPAGS	;...
	LSH	T1,^D9		;SIZE IN WORDS
	ADDI	T1,BUF0-1	;LAST LOC
	PUSH	P,T1		;SAVE AWHILE
	SUBI	T1,2*MXWPL+4	;LEAVE SPACE FOR A COUPLE OF LINES+ 1 PM
	MOVEM	T1,FILPT	;THIS IS HOW FAR TO FILL THE BUFFER
	POP	P,T1		;GET TOP BACK
	SUB	T1,BUFP
	MOVE	T2,T1		;GET A COPY
	SUBI	T2,MXWPL+1	;WHEN TO START DUMPING
	MOVEM	T2,MAXWC
	ASH	T1,-1		;TAKE HALF OF IT
	MOVEM	T1,HLFWC	;SAVE THAT FIGURE
	TRNE	FL2,SVIT
	JRST	NOSV1		;SKIP SOME MORE STUFF IF IN W COMMAND
	MOVEI	T1,.PRIOU	;CHECK TERMINAL MODE
	RFMOD			;GET MODES
	TLNE	T2,(TT%LCA)	;DO WE HAVE LC?
	TRO	FL,M37F		;LC SET SO SAY HE'S M37
	TRO	T2,<.TTATE>B29	;SET NO OUTPUT XLATE
	MOVEM T2,MODW		;SAVE MODE WORD
	SFMOD			;...
	RFCOC
	TRZ T3,3B19		;FIX ESC PROPERLY
	MOVEM T2,COCW1		;SAVE COC WORDS
	MOVEM T3,COCW2		;...
	SFCOC			;...
	TRO FL2,ALTECH		;TURN ON ESC ECHO
	MOVEI T1,.CTTRM		;CONTROLLING TERMINAL
	GTTYP			;GET TYPE
	CAILE T2,MXTRM		;MAX TYPE
	MOVEI T2,DFTRM		;SUPPLY DEFAULT
	MOVEM	T2,DTYPE	;SAVE IT
	MOVE	T1,[<ASCII /00000/>!1]
	MOVEM	T1,CLN		;SET UP THE CURRENT LINE
	SKIPN	T1,TECINC	;USE STEP IF GIVEN
	MOVE	T1,[<ASCII /00100/>!1] ;AND CURRENT INCREMENT
	MOVEM	T1,INCR
	MOVEM	T1,CURINS	;CURRENT PLACE TO INSERT IF NO ARGS TO I
NOSV1:	MOVEI	T1,1		;AND THE CURRENT PAGE
	MOVEM	T1,CPG
	TRNE	FL2,SVIT	;DO NOT CHANGE LOGICAL PAGE (.)
	JRST	NOSV1A
	MOVEM	T1,CPGL
	MOVEM	T1,IPG		;CURRENT PAGE TO INSERT ON
NOSV1A:	MOVE	PNTR,BUFP	;SET THE BUFFER POINTER
	MOVEI	T1,1		;SET INPUT PAGE
	MOVEM	T1,INPG
	SETZM	SVWD		;O WORDS WAITING
	SETZM	WC		;ZERO WORD COUNT FOR START
	SETZM	OLDLIN		;UESD FOR ORDER CHECKING ON INPUT
	TLNN	FL2,AUTOF	;PRESERVE IF IN AUTO SAVE
	SETZM	ALTSN		;USED FOR ALTMODE SEEN FOR I AND R
	SETZM	AUXFLG		;USED TO FLAG AUXILLARY FILE IN USE
	TRNE	FL2,SVIT	;SAVE WORLD?
	JRST	NOSV2	
	SETZM	SRPNT		;NO SEARCH STRING YET
	SETZM	R1PNT		;ALSO REPLACE STRINGS
	SETZM	R2PNT
	MOVSI	T1,1		;SET BIG PAGE LARGE FOR NOW
	MOVEM	T1,BGPG
	TRNE	FL,READOF	;DONT BOTHER IF READ-ONLY
	JRST	NOSV2
	HRROI T2,LIBUF		;BUILD SPEC HERE
	HRROI T1,[ASCIZ "EDIT-BUFFER.IN"]
	CALL MAKTMP
	MOVSI	T1,(GJ%OLD!GJ%SHT!GJ%TMP)
	HRROI T2,LIBUF		;FILESPEC
	PUSHJ	P,GTJFNX	;EXISTS?
	  JRST	NOSV2		;DON'T CARE
	HRLI	T1,(DF%EXP)	;EXPUNGE ALSO
	DELF			;DELETE FILE
	  FJERR			;LOSE IF CAN'T DELETE
NOSV2:	TLO	FL2,BELLF	;ALLOW BELLS
	PUSHJ	P,ENBINT	;ENABLE ^C INTS
	SKIPE	CREATF		;CHECK IF WE ARE CREATING
	  JRST	CRTOK
	TRNE	FL2,SVIT	;WRAP ON SAVE CMD(W)
	JRST	NOSV3		;YES: DON'T PRINT MSG AGAIN!
	MOVEI	T1,[ASCIZ /Edit: /]
	TRNE	FL,READOF	;CHECK FOR R/O
	MOVEI	T1,[ASCIZ /Read: /]
	OUTSTR	@T1		;PRINT MSG
	OUTSTR	ORGASZ		;GIVE FILE NAME
	OCRLF
NOSV3:	TRNE	FL,READOF
	JRST	NOENT		;DO NOT ENTER
	MOVE	T1,OCRJFN	;GET OUTPUT JFN
	MOVEI	T2,OF%WR	;WRITE MODE
	MOVEM	T1,OPNJFN	;SAVE
	OPENF			;OPEN FILE
	 CALL	[CALL CANTOP
		 JRST OPNERR]	;HANDLE IF OVER QUOTA
	SETZM	OPG		;OUTPUT PAGE CNTR
	SETZM	OUPNT		;CLEAR PNTR
	MOVNI	T1,2
	MOVEM	T1,OPCNT	;OUTPUT PAGE COUNT
NOENT:	TRO	FL,BOF		;IS AT START OF FILE
	TLO	FL,FSTOPF	;FIRST OP
	TLZ	FL2,ALLCHG!DOENDF;NO CHANGES YET,& NO LONGER IN END CODE
	PUSHJ	P,FILLBF	;AND FILL UP THE BUFFER
	TLZN	FL2,AUTOF	;SKIP IF AUTO SAVE
	JRST	COMND
	TRZ	FL2,SVIT	;CLR THIS TOO
	MOVE	SINDEX,SVLNUM	;GET BACK TO POINT OF LAST INSERT
	TLZ	FL2,NORENT	;RE-ENABLE FOR REENTER
	JRST	FIND		;EXITS TO CALLER
;ROUTINE TO PARSE A FILE NAME.
;ALTP/ FILE BLOCK
;T1/ GTJFN BITS
;C/ LAST CHARACTER READ. IF ESCAPE, THEN DO RECOGNITION.
;RETURNS:
;.+1 - ERROR FROM GTJFN, MESSAGE PRINTED.
;.+2 - CONTROL-U TYPED BY USER
;.+3 - SUCCESS, FILE BLOCK FILLED.
;	C HAS TERMINATING CHAR

READNM:	MOVEI	T2,0		;NO DEFAULT
READNE:	MOVEM	T2,CJFNBK+.GJEXT
	TRZ	FL2,ALTECH	;TURN OFF ALT ECHO
	CAIN	C,200		;ESC SEEN?
	OUTSTR	[ASCIZ " (FILE) "]
	TLNE	FL2,EXCPFL	;(207) IS THIS A COPY?
	TLOA	T1,(GJ%FNS!GJ%XTN) ;(207) YES DON'T SET FLAGS
	TLO	T1,(GJ%FNS!GJ%XTN!GJ%FLG) ;(206) TURN ON FLAGS
	TLNE	FL2,INPARS	;READING FROM CORE?
	TLZ	T1,(GJ%CFM)	;YES, DON'T WANT CONFIRMATION THEN
	MOVEM	T1,CJFNBK	;STORE FLAGS
	MOVS	T1,OPTJFN	;ASSUME READING FROM OPTION FILE
	HRRI	T1,.NULIO	;AND OUTPUT GOING NOWHERE
	TLNN	FL2,INOPTF	;REALLY DOING OPTION FILE?
	MOVE	T1,[.PRIIN,,.PRIOU]	;NO, GET NORMAL JFNS
	TLNE	FL2,INPARS	;READING FROM CORE?
	MOVE	T1,[.NULIO,,.NULIO]	;YES, THEN ONLY USE STRING
	MOVEM	T1,CJFNBK+.GJSRC	;SAVE IN BLOCK
	TLNE	FL2,INPARS	;READING FROM CORE?
	SKIPA	T2,P.TEXT	;YES, GET STRING FROM COMMAND LINE
	MOVE	T2,TTIPNT	;NO, GET NORMAL INPUT PNTR
	TLNE	FL2,INOPTF	;READING FROM OPTION FILE?
	SETZ	T2,		;YES, NO STRING FROM CORE THEN
READN1:	PUSH	P,FIL(ALTP)	;SAVE IN CASE OF ERROR
	PUSH	P,JFN(ALTP)	;...
	MOVEI	T1,CJFNBK	;POINT TO BLOCK
	PUSHJ	P,GTJFNX
	  JRST	RDNERR		;ANALYSE ERROR RETURN
	TLNE T1,(GJ%TFS)	;(206) TEST FOR TEMP FILE
	JRST [TLZ FL2,INPARS	;(206)
	      OUTSTR [ASCIZ "
? Illegal to write a temporary file"] ;(206)
	JRST RDNER1]		;(206)
	SUB	P,[2,,2]	;CLEAN UP (NO LONGER NEEDED)
	MOVEM	T1,JFN(ALTP)	;STASH JFN
	PUSH	P,T2		;SAVE PNTR
	HRRZS T1		;(206) CLEAR FLAGS
	CALL	JFNSTR		;CONVERT TO PROPER STRING
	AOS	-1(P)		;SET FOR SKIP RETURN
	AOS	-1(P)		;DOUBLE SKIP
	TLNE	FL2,INPARS	;READING COMMAND LINE?
	JRST	[POP	P,P.TEXT	;YES, RESTORE NEW POINTER
		 POPJ	P,]	;AND RETURN
	TLNE	FL2,INOPTF	;READING OPTION FILE?
	JRST	[POP	P,(P)	;YES, TRIM STACK
		 POPJ	P,]	;AND RETURN
	MOVE	T1,0(P)		;GET NEW BYTE PNTR
	MOVE	T2,TTIPNT	;GET OLD BYTE PNTR
	CALL	SUBBP		;GET SIZE
	EXCH	T1,TTICNT	;CALC NEW REMAINDER
	SUBM	T1,TTICNT	;...
	POP	P,T2		;GET NEW PNTR AGAIN
	LDB	T1,T2		;GET TERMINATING CHAR
	CAME	T1,ESC		;CHECK FOR ESC
	CAIN	T1,0		;  OR NULL
	JRST	RDNSCN		;DO BKJFN ON TERMINAL
	AOS	TTICNT		;ELSE BACKUP INPUT
	ADD	T2,[7B5]
	MOVEM	T2,TTIPNT	;STORE PNTR
	PJRST	SCAN		;AND RETURN THRU SCAN

RDNSCN:	SETZM	TTICNT		;CLEAR INPUT
	HLRZ	T1,CJFNBK+1	;JFN TO BACKUP
	BKJFN			;STEP TO REAR
	  FJERR			;GIANT LOSAGE
	PJRST	SCAN		;EXIT THROUGH SCAN
;HERE ON GTJFN ERROR RETURN - CHECK ^U

RDNERR:	POP	P,JFN(ALTP)	;RESTORE OLD VALUES
	POP	P,FIL(ALTP)	;...
;**;[247]	Insert 6 lines after RDNERR:+1		DML	23-NOV-82
	CAIN	T1,GJFX33	;[247] WAS FILENAME ABSENT?
	JRST	[ OCRLF		;[247]
		  OUTSTR [ASCIZ "?Filename was not specified"]
				;[247] YES, PRINT MESSAGE
		  OCRLF		;[247] OUTPUT CRLF FOR LINE
		  JRST RDNCTU]	;[247] CHECK ^U
	CAIN	T1,GJFX37	;BUFFER EMPTY RETURN
	JRST	RDNCTU		;YES - CHECK ^U
	PUSH	P,T1		;SAVE CODE
	CALL	RDNSCN		;GET DELIM INTO C
	OUTSTR	[ASCIZ "
?"]
	MOVEI	T1,.PRIOU	;PLACE FOR MESSAGE
	MOVEI	T3,0
	POP	P,T2		;RESTORE ERROR
	HRLI	T2,.FHSLF
	ERSTR			;PRINT MESSAGE
	  JFCL			;CANT HAPPEN
	  JFCL
	OCRLF
	RET			;EXIT

RDNER1:	POP	P,JFN(ALTP)	;(206) RESTORE OLD VALUES
	POP	P,FIL(ALTP)	;(206) ...
	CAIN	T1,GJFX37	;(206) BUFFER EMPTY RETURN
	JRST	RDNCTU		;(206) YES - CHECK ^U
	OCRLF			;(206) OUTPUT A CRLF
	RET			;(206) RETURN
;HERE ON BUFFER EMPTY RETURN

RDNCTU:	HLRZ	T1,CJFNBK+1	;INPUT JFN
	RFPOS			;GET POSITION
	TRNN	T2,-1		;AT LM?
	RETSKP			;YES - GIVE ^U RETURN
	OUTCHR	[7]		;NO - RING BELL
	MOVEI	T2,0		;BACK TO JFNS ONLY
	JRST	READN1		;TRY AGAIN

;ROUTINE TO COMPUTE THE DIFFERENCE OF TWO BYTE PNTRS IN CHARS
;C(T1) := ORIG PNTR
;C(T2) := NEW PNTR

SUBBP:	HRRZ	T3,T1
	SUBI	T3,(T2)		;DIFF IN WORDS
	IMULI	T3,5		;CHARS
	LDB	T1,[POINT 6,T1,5] ;GET RESIDUES
	LDB	T2,[POINT 6,T2,5]
	SUBM	T2,T1		;RESULT TO T1
	IDIVI	T1,7		;# OF CHARS
	ADD	T1,T3		;COMBINE RESULT
	RET			;DONE # CHARS IN T1

;ROUTINE TO CALL AFTER READNM (OR WHATEVER) TO PARSE /R/S SWITCHES
;AFTER FILENAME.
;ENTER:
; C/ CHARACTER IMMEDIATELY AFTER
;RETURNS:
; .+1 IF NEITHER /R OR /S
; .+2 IF A SWITCH SEEN, RSW OR SSW -1 AS APPROPRIATE

READSW:	SETZM	RSW		;CLEAR OLD SWITCH FLAGS
	SETZM	SSW
	TLNN	FL2,INOPTF	;NO SWITCHES IN OPTION FILE
	CAIE	C,"/"		;CHECK FOR READ ONLY MODE
	JRST	CPOPJ1		;ALL OK
	PUSHJ	P,SCAN
	TRNN	FL,IDF
	POPJ	P,
	MOVS	T1,ACCUM
	CAIN	T1,'R  '
	SETOM	RSW
	CAIN	T1,'S  '
	SETOM	SSW
	PUSHJ	P,SCAN
	SKIPN	RSW
	SKIPE	SSW
	AOS	(P)
	POPJ	P,
;CREATE A NEW FILE

NOFILE:	JUMPL	T1,NOFIL1	;IF NEG THEN OK
	CALL	CHKCOD		;CHECK ERROR CODE
	  FJERR			;REAL LOSAGE
NOFIL1:	OUTSTR	[ASCIZ /Input: /]
	OUTSTR	ORGASZ		;PRINT FILE NAME
	SETOM	CREATF		;SAY WE ARE CREATING
	SETZM	ICRJFN		;CLEAR INPUT BLOCK
	SETZM	ICRFIL
	JRST	FILRET		;GO OPEN IT

CRTOK:	MOVE	T1,OCRJFN	;OUTPUT JFN
	MOVEI	T2,OF%WR	;WRITE PRIVS
	MOVEM	T1,OPNJFN
	OPENF			;OPEN FILE
	  CALL	OPNERR		;CHECK FAILURE
	SETZM	OPG		;OUTPUT PAGE CNTR
	SETZM	OUPNT		;CLEAR BUFFER
	MOVNI	T1,2
	MOVEM	T1,OPCNT	;INIT PAGE COUNT
	SETZM	(PNTR)		;ZERO FIRST WORD OF BUFFER
	TRZ	FL,READOF	;CREAT AND READOF ARE NOT POSSIBLE
	TRO	FL,BOF!EOF!EOF2	;SAY AT START AND NO MORE TO READ
	TLO	FL2,ALLCHG	;NEW FILE - THEREFORE CHANGES
	MOVEI	T1,1		;SET BGPG
	MOVEM	T1,BGPG
	JRST	CRTINS		;AT LAST

SUBTTL PARSE CODE
;LOOK FOR SYSTEM COMMAND.

PARSE:	PUSHJ	P,ZERNEW	;CLR OUT FILE BLOCK
	MOVEI	T1,LDCHR	;SET UP CHIN FOR PARSE
	EXCH	T1,CHIN		;SAVE OLD VALUE
	MOVEM	T1,SVPCIN	;...
	SETZM	CREATF		;NO CREATE
	SETZM	PZBEG		;CLEAR PARSE AREA
	MOVE	T1,[PZBEG,,PZBEG+1]
	BLT	T1,PZEND
	MOVE	T1,P.TEXT	;CHECK FOR PROPER EOL
PARS1:	ILDB	T2,T1		;GET CHAR
	CAIE	T2,15
	CAIN	T2,12		;LOOK FOR TERMINATOR
	SKIPA	T2,[12]		;REPLACE WITH LF
	JRST	PARS1		;LOOP TILL DONE
	DPB	T2,T1		;GRNTEE CORRECT CHAR
; Rules for obtaining a file specification:
;	1.  Try to get it from the rescanned command line.
;	2.  If there is none in the command, try to get it from
;	    TMPCOR:EDS. 
;	3.  If there is none in TMPCOR:EDS, give him an error.

PARSEA:	SKIPN RPGSW		;Anything in TMPCOR?
	JRST NOTMP		;No give him an error
PARSAA:	PUSHJ P,RDSKIP		;Get first nonspace chr in C
	ANDI C,137		;FOrce uppercase

; Check the CREATE or EDIT command...
; If: 	There is a "/" in the command, or
;	The character after noise words and spacing is not <LF>
; DO not read the EDS file.

PARSEB:	CAIN C,12		;Is this character a <LF>?
	JRST NOTMP		;Yes, use the EDS
	CAIN C,"/"		;Did we see a "/"?
	JRST PARSEI		;Yes, do not use EDS
	CAIE C," "		;If it is a space
	CAIN C,"	"	;or tab
	JRST PARSEC		;next non-spacing better be <LF>
	PUSHJ P,@CHIN		;Get the next character
	JRST PARSEB		;Keep checking

PARSEC:	PUSHJ P,RDSKIP		;Get next non-spacing in C
	PUSHJ P,SKPNOI		;Skip noise, too
	CAIE C,12		;If it:
	JRST PARSEI		;Is not a <LF>, use this line
	JRST NOTMP		;Is a <LF>, use the line in EDS

PARSEI:	MOVE T1,[POINT 7,CMDBUF]	;Pointer to command
	MOVEM T1,P.TEXT		;FALL INTO PARSE1...

; 1    2         3      4             5           6
; EDIT /SWITCHES (FROM) INPUT.TYP.GEN (OUTPUT AS) OUTPUT.TYP.GEN [MESSAGE]
; OR   CREATE /SWITCHES (FROM) INPUT.TYP.GEN [MESSAGE]
; OR   PERUSE /SWITCHES (FROM) INPUT.TYP.GET [MESSAGE]

PARSE1:	TRZ FL,F.LAHD		;SET THE LOOK AHEAD BIT
	PUSHJ P,RDSKIP		;Skip spacing, break chr in C

; Set GTJFN bit according to: C (new), E (existing), S (either), P (existing)

	SETZ T1,		;Will contain GTJFN flags
	ANDI C,137		;ENSURE UPPER CASE
	CAIN C,"E"		;Is this EDIT?
	MOVSI T1,(GJ%OLD)	;Yes, get an existing file
	CAIN C,"C"		;OR CREATE?
	JRST	[MOVSI T1,(GJ%FOU) ;FILE FOR OUTPUT
		 SETOM CREATF	;SAY WE ARE CREATING
		 JRST .+1]
;**;[253]  Add 4 lines after PARSE1:+12			DML	20-Nov-84
	CAIN C,"P"		;[253] Or PERUSE?
	JRST [	MOVSI T1,(GJ%OLD)  ;[253] Yes, get an existing file
		TRO FL,READOF	;[253] Set READONLY flag
		JRST .+1]	;[253]
	CAIE C,"S"		;ALLOW SOS CMD TO DO EITHER
	JUMPE T1,BADTMP		;No bad command
	MOVEM T1,GJBITS		;SAVE FOR GTJFN TO FIND
	MOVEI C,"S"		;Change to S command to make
	DPB C,P.TEXT		;  TMPCOR FILE work

; GET FIRST NON-SPACING CHARACTER AFTER COMMAND NAME

PARS1A:	PUSHJ P,@CHIN		;Get a character
	CAIN C,12		;Or a <LF>?
	JRST BADTMP		;yes there is no file spec
	CAIN C,"/"		;Is it a slash?
	JRST PARS2A		;yes, go process it
	CAIE C," "		;Is it a space?
	CAIN C,"	"	;Or a tab?
	JRST PARSE2		;Yes, get next field
	JRST PARS1A		;No continue

; GOT FIRST CHR. OF 2ND ATOM.

PARSE2:	PUSHJ	P,RDSKIP	;Skip spacing, break chr in C
	CAIN	C,12		;Or a <LF>?
	JRST	BADTMP		;Yes there is no file spec
	CAIN	C,"/"		;IS IT A SWITCH?
PARS2A:	PUSHJ	P,GETSWT	;YES, GET THEM
	PUSHJ	P,SKPNOI	;SKIP SPACES & NOISE
	CAIN	C,"/"		;SWITCH AFTER NOISE VALID
	JRST	PARS2A		;PROCESS
	CAIN	C,12		;Find a <LF>?
	JRST	NOTMP		;NO INPUT FILE SPEC.
PARSE4:	MOVEI	ALTP,ORGBLK	;POINT TO DESIRED BLOCK
	MOVE	T1,GJBITS	;GET SAVED BITS
	TLO	T1,(GJ%SHT)	;USE SHORT FORM
	CALL	TRYGTJ		;TRY GTJFN
	  JRST	PARBI		;BAD INPUT FILE SPEC
	PUSHJ P,RDSKIP		;Skip spaces, break chr in C
PARSE5:	PUSHJ P,SKPNOI		;SKIP SPACES & NOISE
	CAIN C,12		;Or <LF>?
	JRST PARSED
	CAIN C,"/"		;Or switch?
	JRST BADSW		;BAD SWITCH PLACEMENT
PARSE6:	MOVEI	ALTP,NEWBLK	;POINT TO NEW BLOCK
	MOVSI	T1,(GJ%FOU!GJ%MSG!GJ%CFM!GJ%SHT)
	CALL	TRYGTJ		;TRY GTJFN
	  JRST	PARBO		;Bad output file
	CALL TSTNEW		;SEE IF THIS IS A "NEW" FILE
PARSED:	SKIPN	NEWFIL		;NEED NEW?
	CALL	DEFNEW		;ASSURE OUTPUT FILE
	JRST	RDEOTX		;FINISH

; SKPNOI - SKIPS SPACES AND NOISE WORDS THEN SPACES

SKPNOI:	CAIE C,"("
	CAIN C,"["
	JRST SKPNO1
	CAIN C,"!"
	JRST SKPNO1
	RET			;JUST RETURN

SKPNO1:	TRZ FL,F.LAHD		;DON'T REREAD THE CHAR
	PUSHJ P,@CHIN
	CAIN C,12			;CHECK FOR TRICKY <LF>
	RET				;HAH!!!
	CAIE C,")"
	CAIN C,"]"			;OTHER BRACKET
	JRST SKPNO2
	CAIN C,"!"
	JRST SKPNO2
	JRST SKPNO1

SKPNO2:	CALL RDSKIP		;SKIP SPACES
	CAIE C,"("		;MAKE SURE NOT ANOTHER
	CAIN C,"["
	JRST SKPNO1		;ANOTHER KEEP GOING
	CAIN C,"!"
	JRST SKPNO1
	RET			;NO - RETURN

; Didn't get a file specification, give errror and die

PARBI:	SKIPN	CREATF		;TROUBLE IF FAILURE
	PUSHJ P,CHKCOD		;File-not-found-type error?
	 JRST PARBO		;No, Run of the mill error
	TRNE	FL,READOF	;READ-ONLY?
	JRST	PARBO		;YES - LOSAGE THEN
	MOVEM	T1,CREATF	;SAVE ERROR CODE AS FLAG
	OUTSTR	[ASCIZ "
%"]
	CALL	CJERRC		;PRINT MESSAGE
	HRROI T1,[ASCIZ /, Creating New file
/]
	PSOUT
	MOVSI	T1,(GJ%FOU)	;FOR IGNORE DELETED BIT
	MOVEM	T1,GJBITS	;TRY ANY FILE
	JRST	PARSE4		;...

PARBO:	OUTSTR	[ASCIZ "
?"]
	CALL	CJERRC		;SYSTEM MESSAGE
	HRROI T1,[ASCIZ / - /]	;Bad output file
	PSOUT
	PUSHJ P,PARPF		;PRINT IT
	JRST LOSER		;AND DIE

PARPF:	MOVE	T2,P.TEXT	;Get pointer
	ADD	T2,[7B5]	;Back it up one
PARP1:	ILDB	T1,T2		;Retrieve a character
	CAIE	T1,"!"		;CHECK COMMENT CHAR
	CAIN	T1,";"
	RET
	CAIE	T1,40		;SPACE OR
	CAIN	T1,11		;  TAB
	RET
	CAIE	T1,12		;EOL
	CAIN	T1,"/"		;OR SWITCH DESIGNATOR
	RET
	PBOUT
	JRST	PARP1

NOTMP:
BADTMP:	TLZ FL2,INPARS		;SAY WE'RE OUT OF THE PARSE
;**;[245]	Replace 6 lines with 14 at BADTMP:+1	DML	10/21/82
	TLO T1,(CM%NOP)		;[245] SET TO INDUCE ERROR
	HRRI T2,GJFX33		;[245] SET APPROPRIATE ERROR CODE
	CALL PAROK		;[245] PRINT ERROR
PAROK:	TLNN T1,(CM%NOP)	;[245] COULD FIELD BE PARSED?
	RET			;[245] YES, RETURN
	OCRLF			;[245] PRINT NEW LINE
	OUTSTR [ASCIZ/?Error in command - /] ;[245] FIRST PART OF ERROR MSG
	MOVEI T1,.CTTRM		;[245] SET OUTPUT TO GO TO TERMINAL
	HRLI T2,.FHSLF		;[245] SET PROCESS TO SELF
	SETZM T3		;[245] ALLOW NO LIMIT TO ERROR MESSAGE OUTPUT
	ERSTR			;[245] PRINT OUT ERROR
	  FJERR			;[245] ERROR - UNDEFINED ERROR NUMBER
	  FJERR			;[245] ERROR - INVALID DESTINATION
	POP P,T3		;[245] KEEP STACK STRAIGHT - REMOVE TOP ENTRY
	RESET			;TO REENABLE <CNTRL>/C
;**;[245]	Replace 1 line with 63 at BADTMP:+8	DML	10/21/82
	MOVEI T1,CMDBLK		;[245] GET COMMAND BLOCK FOR PARSE
	MOVEI T2,INIFDB		;[245] GET FUNC. DESC. BLOCK (FDB) FOR PARSE
	COMND			;[245] INITIALIZE PARSE
	  ERJMP ERRHD0		;[245] ERROR
INPAR:	MOVEI T2,KWFDB		;[245] GET FDB FOR KEYWORD PARSE
	COMND			;[245] PARSE KEYWORD
	  ERJMP ERRHD0		;[245] ERROR
	CALL PAROK		;[245] KEYWORD PARSED?
;**;[253]  Replace 1 line with 2 at INPAR:+4		DML	20-Nov-84
	HRRZ T2,(T2)		;[253][245] ISOLATE COMMAND NUMBER
				;[253] (1=CREATE,0=EDIT,2=PERUSE)
	MOVEM T2,CMDFLG		;[245] STORE IN FLAG REGISTER
	HRROI T2,[ASCIZ/file/]	;[245] PLACE GUIDE WORD IN T2
	MOVEM T2,NOIFDB+.CMDAT	;[245] STORE IN NOISE FDB
;**;[253]  Replace 1 line at INPAR:+8			DML	20-Nov-84
	SKIPE T2,CMDFLG		;[253][245] IS COMMAND EDIT?
	JRST CRESPC		;[245] NO, CONTINUE ELSEWHERE
	MOVE T2,OFFDB+.CMFNP	;[245] GET FIRST WORD OF OUTPUT FILE FDB
	TLO T2,(CM%SDH)		;[245] SET TO SUPPRESS DEFAULT HELP MESSAGE
	HRRI T2,0		;[245] CLEAR OUT ANY LINK TO OTHER FDB'S
	MOVEM T2,OFFDB+.CMFNP	;[245] REPLACE IN OUTPUT FDB
	MOVEI T2,NOIFDB		;[245] GET NOISE FDB FOR PARSE
	COMND			;[245] PARSE NOISE
	  ERJMP ERRHD0		;[245] ERROR
	CALL PAROK		;[245] GUIDE WORD PARSED?
	MOVEI T2,IFFDB		;[245] GET INPUT FILE FDB
	COMND			;[245] PARSE FOR INPUT FILE
	  ERJMP ERRHD0		;[245] ERROR
	CALL PAROK		;[245] LEGAL FILESPEC PARSED? (INPUT OR OUTPUT)
OSPEC:	MOVE T1,T2		;[245] DON'T NEED JFN ACQUIRED....
	RLJFN			;[245] SO RELEASE IT
	  FJERR			;[245] ERROR
	HRROI T2,[ASCIZ/output as/]  ;[245] GUIDE WORDS (FOR EDIT COMMAND ONLY)
	MOVEM T2,NOIFDB+.CMDAT	;[245] PLACE IN NOISE FDB
CRESPC:	MOVE T2,OFFDB+.CMFNP	;[245] GET FIRST WORD OF OUTPUT FILE FDB
	TLZ T2,(CM%SDH)		;[245] ALLOW DEFAULT HELP MESSAGE
	HRRI T2,0		;[245] INITIALLY, SET TO CLEAR ALL FDB LINKS
;**;[253]  Change 1 line at CRESPC:+3			DML	20-Nov-84
	SKIPG T1,CMDFLG		;[253][245] IS THIS A CREATE OR PERUSE COMMAND?
	HRRI T2,CONFDB		;[245] NO, SO ALLOW LINK TO CONFIRM FDB
	MOVEM T2,OFFDB+.CMFNP	;[245] REPLACE IN OUTPUT FDB
	MOVEI T1,CMDBLK		;[245] GET COMMAND BLOCK FOR PARSE
	MOVEI T2,NOIFDB		;[245] GET NOISE FDB FOR PARSE
	COMND			;[245] PARSE GUIDE WORDS
	  ERJMP ERRHD0		;[245] ERROR
	CALL PAROK		;[245] GUIDE WORDS PARSED?
	MOVEI T2,OFFDB		;[245] GET OUTPUT FILE FDB
;**;[253]  Add 7 lines after CRESPC:+12			DML	20-Nov-84
	MOVEI T3,2		;[253] GET COMMAND CODE FOR PERUSE COMMAND
	CAMN T3,CMDFLG		;[253] WAS THE PERUSE COMMAND ENTERED?
	JRST [	MOVE T2,IFFDB+.CMFNP  ;[253] GET FIRST WORD OF INPUT FILE FDB
		HRRI T2,0	;[253] CLEAR OUT ANY LINK TO OTHER FDB'S
		MOVEM T2,IFFDB+.CMFNP	;[253] REPLACE IN INPUT FDB
		MOVEI T2,IFFDB	;[253] GET INPUT FILE FDB
		JRST .+1]	;[253]
	COMND			;[245] PARSE FILESPEC
	  ERJMP ERRHD0		;[245] ERROR
	CALL PAROK		;[245] OUTPUT FILESPEC PARSED?
ENDPAR:	HRRZ T3,T3		;[245] ISOLATE FDB USED IN PARSE
	CAIN T3,CONFDB		;[245] WAS THE CONFIRM FDB USED?
	JRST STPCMD		;[245] YES, SO PARSE IS OVER
	MOVE T1,T2		;[245] DON'T NEED JFN ACQUIRED ....
	RLJFN			;[245] SO RELEASE IT
	  FJERR			;[245] ERROR
	MOVEI T1,CMDBLK		;[245] GET COMMAND BLOCK FOR PARSE
	MOVEI T2,CONFDB		;[245] GET CONFIRM FDB
	COMND			;[245] PARSE FOR CONFIRMATION (CR)
	  ERJMP ERRHD0		;[245] ERROR
	CALL PAROK		;[245] CARRIAGE RETURN PARSED?
STPCMD: MOVE P,[IOWD PDLSIZ,PDL];[245] RESET STACK POINTER
	MOVEI T1,TTYCH		;[245] RESET DEFAULT INPUT ROUTINE
	MOVEM T1,CHIN		;[245] ....
	MOVE T1,[POINT 7,CMDBUF];[245] RESET POINTER TO COMMAND BUFFER
	MOVEM T1,P.TEXT		;[245] STORE POINTER FOR READING
	JRST CMDCON		;[245] BACK TO TRY AGAIN

BADSW:	TLZ FL2,INPARS		;SAY WE'RE OUT OF PARSE
	OUTSTR	[ASCIZ "
?Type switches immediately after CREATE or EDIT"]
	JRST	LOSER		;BYE-BYE


RDEOTX:	TRZ	FL,F.LAHD	;CLEAR PARSE FLAG
	MOVE	T1,SVPCIN	;RESTORE CHIN
	MOVEM	T1,CHIN
	SKIPN	T1,TECINC	;TECO INCREMENT?
	MOVE	T1,[<ASCII /00100/>!1]
	MOVEM	T1,TECINC	;SET CORRECT ONE UP
	SKIPN	TECFST		;START SEQ # GIVEN?
	MOVEM	T1,TECFST	;NO: USE INCREMENT
	POPJ	P,		;EXIT PARSE

;ROUTINE TO DO GTJFN ON STRING POINTED TO BY P.TEXT
;GTJFN BITS IN T1, FILE BLOCK IN ALTP

TRYGTJ:	MOVE	T2,P.TEXT	;GET TEXT POINTER
	ADD	T2,[7B5]	;BACKUP ONE CHAR
	TLO	T1,(GJ%FLG)	;SET TO GET FLAGS
	PUSHJ	P,GTJFNX	;DO GTJFN
	  RET			;ERROR RETURN
	TLNE	T1,(GJ%TFS)	;SEE IF THIS IS A TEMPORARY FILE SPEC
	  JRST	[TLZ FL2,INPARS	;OUT OF PARSE
		 OUTSTR	[ASCIZ "
?Illegal to write a temporary file"]	;TYPE MESSAGE
		 JRST	LOSER]	;GO DIE
	ANDI	T1,-1		;CLEAR FLAGS
	MOVEM	T1,JFN(ALTP)	;SAVE JFN
	MOVEM	T2,P.TEXT	;SAVE UPDATED PNTR
	TRO	FL,F.LAHD	;ONE AHEAD
	AOS	(P)		;SET FOR SKIP RETURN
;	PJRST	JFNSTR		;CONVERT JFN TO STRING

;ROUTINE TO CONVERT JFN IN T1 , TO ASCIZ STRING

JFNSTR:	MOVE	T2,T1		;COPY JFN TO T2
	HRROI	T1,ASZ(ALTP)	;POINT TO BLOCK
	MOVEM	T1,FIL(ALTP)	;SAVE PNTR
;**;[246]	Change 1 line at JFNSTR:+3		DML	11/4/82
	MOVE T3,[JS%SPC]	;[246] WANT ENTIRE FILESPEC
	JFNS			;GET STRING
	RET			;RETURN
;ROUTINE TO READ THE INITIAL SWITCH LIST FROM THE INITIAL PARSER
;ENTER WITH THE FIRST "/" PARSED, EXIT WITH THE TERMINATOR CHAR
;IN C

GETSWT:	TRZ FL,F.LAHD		;INCREMENT THE POINTER FIRST
	PUSHJ P,RDATOM		;GET SWITCH NAME
	MOVEM D,ACCUM		;LEAVE FOR DOSET
	PUSHJ P,DOSET		;CALL APPROPRIATE SET ROUTINE
	  JRST SWTERR		;ILEEGAL SWITCH, COMPLAIN
	TRO FL,F.LAHD		;ENSURE WE SEE BREAK
	PUSHJ P,RDSKIP		;DISCARD ANY SPACES
	PUSHJ P,@CHIN		;THEN GET THE CHARACTER
	CAIN C,"/"		;ANOTHER SWITCH?
	JRST GETSWT		;YES, KEEP GOING
	TRO FL,F.LAHD		;RETURN TO NO LOOK-AHEAD
	POPJ P,			;NOPE, STOP NOW, RETURN THAT CHARACTER

SWTERR:	HRROI T1,[ASCIZ /?Illegal Switch - /]
	PSOUT			;Give message
	MOVEI T3,6		;Print six characters
	MOVE T2,[POINT 6,D]	;Sixbit pointer
SWTER1:	ILDB T1,T2		;Get sixbit chr.
	ADDI T1,40		;Asciize
	PBOUT			;print it
	SOJG T3,SWTER1		;Only six
	JRST LOSER		;Die ungracefully
;ROUTINE TO ZERO OUT NEWBLK

ZERNEW:	MOVE	T1,[NEWBLK,,NEWBLK+1]
	SETZM	NEWBLK
	BLT	T1,NEWBKE
	POPJ	P,

;ROUTINE TO MAKE OUTPUT FILE BE SAME AS INPUT

DEFNEW:	MOVE	T2,ORGJFN	;ORIGINAL FILE JFN
	HRROI	T1,NEWASZ	;NEW STUFF
	MOVEM	T1,NEWFIL	;SAY WE HAVE SOMETHING
	MOVE	T3,[1B8+1B11+1B35] ;GET FILE SPEC DEFAULTS
	SKIPN	CREATF		;(197) CREATING NEW FILE?
	SKIPE	SAMDEV		;(197) NO, SKIP IF DEV:<DIR> NOT EQUAL
	TLO	T3,(1B2+1B5)	;YES - NEED DEV:<STR> ALSO
	JFNS
	HRROI	T2,NEWASZ	;POINT TO TEXT OF FILESPEC
	MOVSI	T1,(GJ%FOU!GJ%SHT)
	PUSHJ	P,GTJFNX
	  FJERR			;BETTER NOT FAIL
	MOVEM T1,NEWJFN		;SAVE A WHILE
	MOVEI	ALTP,NEWBLK	;POINT TO NEWBLK
	CALL	JFNSTR		;CONVERT TO STRING
;	CALLRET TSTNEW		;CHECK IF "NEW" FILE.

;TEST TO SEE IF WE SHOULD TREAT THE OUTPUT FILE AS A "NEW"
;FILE, RATHER THAN THE NEXT HIGHEST GENERATION.

TSTNEW:	HRROI T1,LIBUF		;USE TEMP BUFFER
	MOVE T2,ORGJFN
	MOVE T3,[1B2+1B5+1B8+1B11+1B35]
	JFNS			;GET DEV:<DIR>NAME.EXT
	HRROI T1,LIBUF2		;2ND BUFFER
	MOVE T2,NEWJFN
	JFNS			;GET DEV:<DIR>NAME.EXT (OUTPUT)
	HRROI T1,DEVSTR		;SAVE OUTPUT DEV:<DIR>
	MOVE T3,[1B2+1B5+1B35]
	JFNS
	HRROI T1,LIBUF
	HRROI T2,LIBUF2		;COMPARE THESE 2 FILES
	STCMP			;SAME?
	SKIPE T1		;AC1 := 0 IF EXACT MATCH
	TRO FL,NEWFL		;NO - SET NEW FILE FLAG
	HRROI	T1,DEVST2	;(197) SAVE DEV:<DIR> INPUT
	MOVE	T2,ORGJFN	;(197)
	MOVE	T3,[1B2+1B5+1B35];(197)
	JFNS			;(197) GET DEV:<DIR> INPUT
	HRROI	T1,DEVSTR	;(197) COMPARE OUTPUT DEV:<DIR>
	HRROI	T2,DEVST2	;(197) COMPARE INPUT DEV:<DIR>
	SETZM	SAMDEV		;(197)
	STCMP			;(197) SAME?
	SKIPN	T1		;(197) AC1: =0 IF EXACT MATCH
	SETOM	SAMDEV		;(197) YES THEY ARE EXACT MATCH
	MOVE T1,NEWJFN		;RELEASE THIS HERE
	SETZM NEWJFN
	RLJFN			;...
	 FJERR			;SHOULDN'T HAPPEN
	MOVE T1,ORGCOD		;CHECK PSWS
	CAME T1,NEWCOD
	TRO FL,NEWFL		;NEW FILE IF PSWS DIFFERENT
	MOVE	T1,ORGJFN	;WANT TO GET PROTECTION OF ORIGINAL FILE
	MOVE	T2,[1,,.FBPRT]	;SO READ FROM FDB
	MOVEI	T3,ORGPRT	;INTO STORAGE
	GTFDB			;GET THE INFORMATION
	RET			;RETURN
;COMMAND ERROR ROUTINE

COMERR:	OUTSTR	[ASCIZ /? /]
	OUTSTR	(T1)
	OCRLF
	CALL	CLRBFI		;CLEAR TYPE AHEAD
	SETZM	TTICNT
COMER1:	SETZM	RPGSW		;CLEAR RPG MODE
	TRZ	FL,F.LAHD
	MOVE	T1,SVPCIN	;RESTORE CHIN
	MOVEM	T1,CHIN
	MOVE	P,[IOWD PDLSIZ,PDL] ;RESTORE PDL
	JRST	NOCOM1		;TRY SOME MORE
;CHKCOD - Checks for File-not-found-type GTJFN errors
;Call:  T1/ anything,,error number
;Uses:  T1, and T2

CHKCOD:	HRRZS	T1		;JUST ERROR NUMBER
	MOVSI	T2,-GTJTLN	;- TABLE LEN
	CAME	T1,GTJTAB(T2)	;LOOK IT UP
	AOBJN	T2,.-1		;LOOP
	JUMPGE	T2,CPOPJ	;NOT FOUND
	RETSKP			;FOUND GIVE SKIP RETURN

GTJTAB:	GJFX18			;?No such file name
	GJFX19			;?No such extension
	GJFX20			;?No such generation
	GJFX16
	GJFX17
	GJFX21
	GJFX24			;?File not found
GTJTLN==.-GTJTAB

;ROUTINE TO MAKE FULL FILE SPEC FOR TEMP FILES
;C(T1) := FILE NAME.EXT
;C(T2) := POINTER TO BUFFER

MAKTMP:	PUSH P,T1		;SAVE NAME
	MOVE T1,T2		;POINTER TO T1
	HRROI T2,DEVSTR		;DEVICE STRUCTURE STRING
	MOVEI T3,0
	SOUT
	POP P,T2		;NAME AND EXT
	SOUT
	RET			;DONE

;GET SIZE FOR FILE IN WORDS

GFSIZE:	MOVE	T1,IJFN(ALTP)	;FILE JFN
	MOVE	T2,[2,,.FBBYV]	;BYTE SIZE & COUNT
	MOVEI	T3,T4		;LOAD T4 & T5
	GTFDB
 	LDB	T2,[POINT 6,T4,11] ;FILE BYTE SIZE
	MOVEI	T3,^D36		;BITS / WORD
	IDIV	T3,T2		;BYTES / WORD
	AOS	T1,T5		;# OF BYTES IN FILE
	ADDI	T1,-1(T3)	;ADJUST FOR XTRA WORD
	IDIV	T1,T3		;# OF WORDS IN FILE
	MOVEM	T1,FSZ(ALTP)	;SAVE
	RET			;RETURN
;UTILITY ROUTINES

RDSKIP:	PUSHJ	P,RDSKP1		;SKIP SPACES
	TRO	FL,F.LAHD		;SET LOOK AGAIN
	POPJ	P,

RDSKP1:	PUSHJ	P,@CHIN
	CAIE	C," "
	CAIN	C,"	"	;SPACE OR TAB
	JRST	RDSKP1
	POPJ	P,

RDATOM:	MOVE	T1,[POINT 6,D]
	MOVEI	D,0		;INIT ATOM
RDATO1:	PUSHJ	P,@CHIN
	PUSHJ	P,CKALN		;CHECK ALPHA-NUMERIC
	JRST	RDATO2
	TLNN	T1,770000		;6 YET?
	JRST	RDATO1
	SUBI	C,40
	IDPB	C,T1
	JRST	RDATO1

RDATO2:	CAIE	C," "
	CAIN	C,"	"
	JRST	RDATO4		
RDATO3:	PUSHJ	P,CKALN
	POPJ	P,
	MOVEI	C," "		;RETURN A SPACE IF
	TRO	FL,F.LAHD		;ALPHA-NUMERIC
	POPJ	P,
RDATO4:	CAIN	D,0		;MAYBE IT WAS A LEADING SPACE
	JRST	RDATO1		;YES, SO GET ANOTHER CHAR
	PUSHJ	P,RDSKP1	;NO,SO IT MEANT END-OF-SWITCH-NAME
	JRST	RDATO3		
;HERE TO FETCH NEXT CHAR

LDCHR:	SKIPN	RPGSW		;FROM WHERE
	JRST	LDCHR1
	TRZN	FL,F.LAHD
LDCHRA:	IBP	P.TEXT
	LDB	C,P.TEXT
	CAIN	C,15		;PURGE CR'S
	JRST	LDCHRA
	POPJ	P,

LDCHR1:	TRZE	FL,F.LAHD
	SKIPA	C,SVCCIN
LDCHRB:	PUSHJ	P,TTYCH
	CAIN	C,15		;SKIP OVER CR'S
	JRST	LDCHRB
	MOVEM	C,SVCCIN
	POPJ	P,

;CHECK IF CHAR IS ALPHA-NUMERIC

CKALN:	CAIG	C,"z"
	CAIGE	C,"a"
	SKIPA
	SUBI	C,40	;CONVERT TO UPPER
	CAIL	C,"0"
	CAILE	C,"Z"
	POPJ	P,
	CAILE	C,"9"
	CAIL	C,"A"
	AOS	(P)
	POPJ	P,

;SPECIAL ROUTINE CALLED FROM SET OPTION IN INITIAL PARSE

OPTSWT:	TLZ	FL2,INPARS	;TEMP CLR FLAG
	PUSHJ	P,DOOPT		;PARSE OPTION FILE
	  JRST	OPTSE1		;SAY NOT FOUND
	  JRST	OPTSE2		;SAY ERROR IN FILE
	TLO	FL2,INPARS	;TURN BACK ON
	MOVEI	C," "		;PRETEND LAST CHAR WAS A SPACE
	POPJ	P,		;RETURN

OPTSE1:	MOVEI	T1,[ASCIZ /Option not found/]
	JRST	COMERR
OPTSE2:	MOVEI	T1,[ASCIZ /Syntax error in option file/]
	JRST	COMERR


SUBTTL OPTION FILE HANDLER
;ROUTINE TO EAT AN OPTION FILE IF ANY
;CALL:	PUSHJ	P,DOOPT
;	<OPTION NOT FOUND>
;	<ERROR IN OPTION FILE>
;	<OK RETURN>
; C(OPTION) = SIXBIT OF DESIRED OPTION OR ZERO IF DEFAULT

DOOPT:	TLNE	FL2,INOPTF	;TRYING TO REENTER
	JRST	WRAPUP		;JUST GIVE CURRENT FAILURE
	SETO T1,		;THIS JOB
	HRROI T2,T4		;ONE WORD,,T4
	MOVEI T3,.JILNO		;LOGGED IN DIRECTORY #
	GETJI
	 FJERR
	HRROI T1,LIBUF2		;BUILD STRING HERE
	MOVE T2,T4
	DIRST			;GET STR:<DIR>
	 FJERR
	HRROI	T2,[ASCIZ "SWITCH.INI"]
	MOVEI	T3,0
	SOUT			;COPY STRING
	MOVSI	T1,(GJ%OLD!GJ%PHY!GJ%SHT)
	HRROI	T2,LIBUF2	;POINT TO FILESPEC
	PUSHJ	P,GTJFNX	;GET JFN
	  RET			;SAY NOT FOUND
	MOVEM	T1,OPTJFN	;SAVE JFN
	MOVE	T2,[7B5+OF%RD]	;READ MODE (ASCII)
	OPENF			;OPEN FILE
	  JRST	[MOVE T1,OPTJFN
		 RLJFN		;RELEASE JFN
		   JFCL
		 SETZM OPTJFN	;(222)CLEAR JFN STORAGE
		 RET]		;AND RETURN
	MOVEI	T1,OPTCH	;SET UP INPUT ROUTINE
	EXCH	T1,CHIN		;SAVE CURRENT ONE
	MOVEM	T1,SVOCIN
	TLO	FL2,INOPTF	;SAY WE IS IN OPTION FILE
	SETZM	SAVCHR		;CLEAR SCANNER

RDOPT:	PUSHJ	P,SCAN		;FETCH FIRST ATOM OF LINE
	CAIN	C,177		;EOF OR ERROR?
	JRST	WRAPUP		;YES: FINISH UP AND RETURN
	MOVE	T1,ACCUM	;GET WHAT WE FOUND
	CAME	T1,[SIXBIT "EDIT"]
	JRST	SKPEOL		;NOT WHAT WE WANT - TRY NEXT LINE
	PUSHJ	P,SCAN		;FETCH BREAK CHAR
	SKIPN	OPTION		;NEED DEFAULT?
	JRST	DEFOPT		;YES:
	CAIE	C,":"		;LOOK AT BREAK CHAR
	JRST	SKPEOL		;SKIP LINE IF NOT COLON
	PUSHJ	P,SCAN		;GET NEXT ATOM
	TRNE	FL,IDF		;SEE IF IDENT
	JRST	OPTONE		;YES: TRY THIS
	CAIE	C,"("		;COULD BE LEFTPAREN
	JRST	OPTDN1		;NOPE - IT IS TRASH
OPTMOR:	PUSHJ	P,SCAN		;TRY FOR ATOM
	MOVE	T1,ACCUM
	CAMN	T1,OPTION	;IS THIS THE ONE?
	JRST	OPTMR1		;SCAN FOR RT PAREN
	PUSHJ	P,SCAN		;GULP DOWN BREAK CHAR
	CAIN	C,","		;COMMA MEANS MORE COMING
	JRST	OPTMOR
	CAIN	C,")"		;RT PAREN MEANS THAT'S ALL
	JRST	SKPEOL		;TRY NEXT LINE
	JRST	OPTDN1		;TRASHINESS

OPTMR1:	PUSHJ	P,SCAN		;LOOK FOR RT PAREN
	CAIE	C,177		;EOF OR ERROR
	TRNE	FL,TERMF	;EOL
	JRST	OPTDN1
	CAIE	C,")"		;A GOOD THING
	JRST	OPTMR1		;KEEP LOOKING
	JRST	OPTFN0		;GOT IT

OPTONE:	MOVE	T1,ACCUM
	CAME	T1,OPTION	;IS THIS IT?
	JRST	SKPEOL		;NO: KEEP LOOKING
OPTFN0:	AOS	(P)		;ALL ELSE ARE ERRORS OR AOK
OPTFND:	PUSHJ	P,SCAN		;SCAN NEXT
	TRNE	FL,IDF		;IDENTS ARE OK
	JRST	OPTGOT		;GOT ONE - USE IT
OPTNXT:	CAIE	C,"/"		;CHECK LEGAL DELIMS
	CAIN	C,","
	JRST	OPTGET		;NEED TO SCAN AGAIN
	CAIE	C,"-"		;CHECK LINE CONT.
	JRST	OPTDON		;NOPE - CHECK PROPER EOL
	PUSHJ	P,SCAN		;SCAN PAST DASH
	TRNN	FL,TERMF	;PROPER TERM?
	JRST	WRAPUP		;NO: SYNTAX ERROR
	JRST	OPTFND		;CONTINUE LOOKING
OPTGET:	PUSHJ	P,SCAN		;GET NEXT ATOM
	TRNN	FL,IDF		;IDENT?
	JRST	WRAPUP		;NO: LOSE
OPTGOT:	PUSHJ	P,DOSET		;SWITCH IN "ACCUM" - CALL SET ROUTINE
	JRST	WRAPUP		;ILLEGAL ENTRY IN FILE
	JRST	OPTNXT		;CONTINUE

OPTDON:	TRNE	FL,TERMF	;OK IF PROPER TERM
OPTDN1:	AOS	(P)		;GIVE SKIP RETURN
	JRST	WRAPUP		;FINISH UP

DEFOPT:	CAIE	C,":"		;IF COLON JUST SKIP LINE
	JRST	OPTFN0		;ELSE WE HAVE CORRECT LINE
SKPEOL:	PUSHJ	P,GNCH		;GET A CHAR
	CAIN	C,177		;CHECK ON EOF
	JRST	WRAPUP		;DONE IF SO
	TLNN	CS,TERM_16	;TERMINATOR?
	JRST	SKPEOL		;NO: KEEP GOING
	SETZM	SAVCHR		;CLEAR SCANNER
	SETZM	ACCUM		;...
	JRST	RDOPT		;YES: TRY THIS LINE

WRAPUP:	MOVE	T1,OPTJFN	;GET JFN
	CLOSF			;RELEASE
	  JFCL			;DONT CARE
	SETZM	OPTJFN		;(222)CLEAR JFN STORAGE
	MOVE	T1,SVOCIN	;RESTORE OLD INPUT ROUTINE
	MOVEM	T1,CHIN
	TLZ	FL2,INOPTF
	POPJ	P,		;RETURN
;UTILITY ROUTINES TO READ OPTION FILE

OPTCH:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2		;...
OPTCH1:	MOVE	T1,OPTJFN	;OPTION FILE JFN
	BIN			;READ A CHAR
	JUMPE	T2,OPTEOF	;SEE IF EOF
	MOVE	C,T2		;PLACE IN C
POPRET:	POP	P,T2		;RESTORE REGS
	POP	P,T1
	RET			;RETURN

OPTEOF:	GTSTS			;GET FILE STATUS
	TLNN	T2,(GS%EOF)	;AT EOF?
	JRST	OPTCH1		;NO - PURGE ZERO BYTES
	MOVEI	C,177		;GET A RUBOUT
	JRST	POPRET		;AND RETURN

SUBTTL	ERROR ROUTINES
NOTDKI:
NOTDKO:
NODSK:	CALL NOCTRO
	OUTSTR [ASCIZ /
? No DISK available. Please check the DISK you have requested/]
	JRST	LOSER


CANTOP:	CALL NOCTRO
	OUTSTR [ASCIZ "
? Unable to open temporary file (EDIT-BUFFER.OUT) for this edit."]
	RET
;	THE ERROR HANDLER & SPECIAL FILE OPERATIONS

ERRHD0:	PUSH	P,T1		;SAVE T1
	LDB	T1,[POINT 9,40,8]
	CAILE	T1,MAXUUO	;CHECK LEGAL
	ERROR	ILUUO
	XCT	EDISP(T1)	;DO FUNCTION
	  AOS	-1(P)		;NON-SKIP MEANS SKIP
	POP	P,T1		;RESTORE T1
	RET			;RETURN

ERRCON:	CALL	NOCTRO		;TURN OFF ^O
	HRRZ	T1,40		;PICK UP THE ERROR NUMBER
	SKIPE	T1
	CAILE	T1,NUMER
	ERROR	ILUUO		;WRONG ERROR, CALL SELF
	TLNE	FL2,INOPTF!INPARS ;TREAT OPTION FILE AS SPECIAL
	JRST	OPTERR		;...
	PUSH	P,40		;SAVE FOR LATER
	OCRLF
	MOVEM	T1,SVERN	;SAVE FOR =ERROR COMMAND
	MOVE	T1,ETBL-1(T1)	;PNTR TO MESSAGES
	TRNE	FL,EXTOG
	MOVSS	T1		;USE SHORT FORM
	TLO	T1,-1		;DEFAULT BP
	PSOUT			;PRINT MESSAGE
	OCRLF			;TERMINATE WITH CRLF
	TRNN	FL2,COMFLF	;IN COMMAND FILE?
	JRST	ERRHD1		;NO: SKIP OVER LINE PRINT
	HRROI	T1,COMESS	;MSG ADDRS
	PSOUT			;DUMP IT
ERRHD1:	POP	P,40		;RESTORE OLD VALUE
	LDB	T1,[POINT 9,40,8] ;GET UUO
	XCT	ERND(T1)	;DO GOOD THING
	RET			;RERROR WILL FALL THROUGH XCT AND RETURN

ERND:	ERROR	ILUUO		;(0) IS AN ERROR
	JRST	LOSER		;(1) DIE
	JRST	CKIND		;(2) CHECK IND FILE
	POP	P,T1		;(4) RERROR - RESTORE T1

LOSER:	OCRLF
	MOVEI T1,.TICCC		;DISABLE ^C TRAPS
	DTI			;...
	HALTF			;DONE FOR NOW
	JRST	.-1		;I MEANT IT

CKIND:	TRNE	FL2,COMFLF	;WERE WE USING IND FILE?
	SETOM	USEIND		;YES, REMEMBER IT.
	TRZ	FL2,COMFLF!SUPN!UPTOPF	;RESET SOME FLAGS
;**;[241]	insert 1 line after CKIND+2	YKT	6/1/82
	TLZ 	FL2,DOENDF	;[241] SET FLAG OFF
	CALL	CLRBFI		;CLEAR OUT THINGS
	SETZM	TTICNT
	SKIPE	USEIND		;USING IND FILE BEFORE?
	TRO	FL2,COMFLF	;YES, RESET FLAG
	SETZM	USEIND		;CLEAN UP
	JRST	COMND		;GO ON

EDISP:	ERROR	ILUUO		;(0) ILLEGAL
	JRST	ERRCON		;(1) ERROR
	JRST	ERRCON		;(2) NERROR
	JRST	ERRCON		;(3) RERROR
	CALL	CJERR		;(4) NON-FATAL JSYS ERROR
	CALL	FATAL		;(5) FATAL JSYS ERROR
	CALL	TSOUT		;(6) SOUT
	CALL	TBOUT		;(7) BOUT
	CALL	TBIN		;(10) BIN

;HERE ON FATAL JSYS LOSAGE

FATAL:	CALL	NOCTRO		;LET HIM SEE MSG
	OUTSTR	[ASCIZ "
? Fatal JSYS error - "]
	CALL	CJERR1		;PRINT SYSTEM MESSAGE
	JRST	LOSER		;ALL DONE

;NON-FATAL JSYS ERROR , PRINT MESSAGE LIKE NERROR

CJERR:	CALL	CJERR0		;PRINT MESSAGE
	JRST	CKIND		;SIMULATE NERROR

CJERR0:	CALL	NOCTRO		;FLUSH ^O
	OUTSTR	[ASCIZ "
% "]
	CALL	CJERR1		;PRINT SYSTEM MESSAGE
	OCRLF			;TERMINATE LINE
	RET			;RETURN

CJERRC:	SKIPA	T2,T1		;MOVE CODE TO T2
CJERR1:	SETO T2,		;USE LAST ERROR
	MOVEI	T1,.PRIOU	;WHERE TO PUT MSG
	HRLI	T2,.FHSLF
	MOVEI	T3,0		;ERSTR DRESSING
	ERSTR
	  JRST	[OUTSTR [ASCIZ "?Undefined error code."]
		 JRST LOSER]
	  JRST	[OUTSTR [ASCIZ "?ERSTR confused!"]
		 JRST LOSER]
	RET			;RETURN
;ROUTINES TO HANDLE TERMINAL INPUT/OUTPUT

TSOUT:	JSP T1,SETESC		;SET TRUTH IN ESCAPES
	HRRO T1,40		;GET UUO ADDRS
	PSOUT		;DUMP STRING
	RETSKP		;RETURN

TBOUT:	JSP T1,SETESC
	MOVE T1,@40	;GET CHARACTER
	PBOUT		;DUMP IT
	RETSKP		;RETURN

SETESC:	PUSH P,T2	;SAVE T2,T3
	PUSH P,T3
	PUSH P,T1	;SAVE RETURN ADDRS
	MOVEI T1,.PRIOU	;PRIMARY OUTPUT
	MOVE T2,COCW1	;GET COC WORDS
	MOVE T3,COCW2
	TRZ T3,3B19	;SET THIS FOR ACTUAL ESC CODE
	TRO T3,2B19	; TO BE SENT
	SFCOC		;...
	POP P,T1		;REMOVE RETURN ADDRS
	DMOVE T2,-1(P)		;RESTORE T2 & T3
	CALL @T1		;RETURN
	 SOS -2(P)		;NON-SKIP
	MOVEI T1,.PRIOU		;RESET COC WORDS
	MOVE T2,COCW1
	MOVE T3,COCW2
	SFCOC
	POP P,T3
	POP P,T2		;RESTORE REGS
	RETSKP			;RETURN

TBIN:	PUSH	P,T2		;SAVE XTRA REG
	MOVEI	T1,.PRIIN	;PRIMARY INPUT
	MOVE T2,MODW		;GET MODE WORD
	TRO T2,TT%WAK		;WAKE ON EVERYTHING
	SFMOD			;SET IT
	PBIN			;GET A CHAR
	HRRZ	T2,40		;DEST ADDRS
	CAIN	T2,T1		;IS IT T1?
	MOVEI	T2,-2(P)	;YES - USE PDL THEN
	MOVEM	T1,@T2		;STORE CHAR
	MOVEI	T1,.PRIIN	;RESET MODES
	MOVE T2,MODW		;...
	SFMOD			;...
	POP	P,T2		;RESTORE REG
	RETSKP			;RETURN

;ROUTINE TO TURN OFF POSSIBLE CTRL-O

NOCTRO:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2
	MOVEI T1,.PRIOU		;PRIMARY OUTPUT
	MOVE T2,MODW		;GET MODE WORD
	TLZ T2,(TT%OSP)		;CLEAR FLAG
	SFMOD			;SET NEW MODE
	PJRST	POPRET		;RETURN
SUBTTL	CONTROL-C INTERCEPT CODE

OPTERR:	MOVE	T1,-1(P)	;RESTORE T1
	SUB	P,[3,,3]	;UP A LEVEL
	RET			;AND GIVE ERROR RETURN

;CONTROL C INTERCEPT HANDLERS

;ENABLE ALL INTERCEPTS

ENBINT:	PUSH	P,T1		;SAVE T1,T2
	PUSH	P,T2
	MOVEI	T1,.FHSLF	;CURRENT FORK
	MOVSI	T2,(1B<.TICCC>)
	SKIPL	NOCTLC		;NONE?
	STIW			;OK - SET MASK
	MOVE	T2,ONCHAN	;CHANNEL MASK
	SKIPGE	NOCTLC		;^C ALSO?
	TLZ	T2,(1B<.TICCC>)	;NO - CLR CHL #
	AIC			;
	SETOM	CNCLOK		;CLEAR INTERLOCK FOR FIRST TIME
	POP	P,T2		;RESTORE
	POP	P,T1
	POPJ	P,		;

;DISABLE INTERCEPT

DISINT:	PUSH	P,T1		;SAVE T1,T2
	PUSH	P,T2
	MOVEI	T1,.FHSLF	;CURRENT FORK
	MOVEI	T2,0		;CLEAR MASK
	STIW
OFFIN1:	MOVSI	T2,(1B<.TICCC>)	;^C ONLY
	SKIPN	NOCTLC		;CAN CTRL-C BE DISABLED?
	DIC			;YES
	POP	P,T2		;RESTORE
	POP	P,T1
	POPJ	P,		;RETURN

OFFINT:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2
	MOVEI	T1,.FHSLF	;CURRENT FORK
	JRST	OFFIN1		;DISABLE CHL

;INITIALIZE PSEUDO-INTERRUPT SYSTEM

INIPSI:	SETZM	NOCTLC		;ASSUME OK
	MOVEI	T1,.FHSLF	;THIS FORK
	CIS			;CLEAR PSI SYSTEM
	MOVE	T2,[LEVTAB,,CHNTAB]
	SIR			;SET UP PSI SYSTEM
	RPCAP			;GET CAPABILITIES OF FORK
	TLNN	T2,(1B0)	;CAN WE ENABLE FOR CTRL-C?
	 JRST	[SETOM	NOCTLC	;SET FLAG, CAN'T ENABLE FOR CTRL-C
		 JRST INIPS0]
	TLON	T3,(1B0)	;YES
	EPCAP			;
	MOVE	T1,[.TICCC,,TRPCHN] ;ESTABLISH CTRL-C
	ATI			;
	MOVEI	T1,.FHSLF	;RESTORE T1
INIPS0:	EIR			;ENABLE PSI SYSTEM
	SETOM	CNCLOK		;CLEAR INTERLOCK FOR FIRST TIME
	POPJ	P,		;
;INTERRUPT HANDLER

TRAP:	PUSH	P,T1		;SAVE A REG
	SETZM	CNCLOK		;MARK IN PROGRESS
	TLNN	FL2,DOENDF	;IF WE WERE IN END CODE, GIVE OPP TO ^C OUT
	TLNN	FL2,NORENT	;ARE WE DISABLED?
	 SKIPA			;NO
	JRST	CNCREN		;YES: JUST RE-ENTER
	CALL	OFFINT		;TURN OFF CHL
	MOVEI	T1,.PRIOU	;PRIMARY OUTPUT
	CFOBF			;CLEAR IT
CNCIN0:	CALL	NOCTRO		;CLEAR ^O
	OUTSTR	[ASCIZ "Yes? "]
	TRNN	FL,EXTOG
	OUTSTR	[ASCIZ "(Type H for help): "]
	SKIPN	ECFLG		;(194) IS ECHO FLAG SET?
	CALL	DOECHO		;(194) YES TURN ON ECHO
	CALL	INHELP		;GET CHAR
	  JRST	CNCHLP		;HE WANTS HELP
	CAIN	T1,"R"
	JRST	CNCREN		;DO LIKE REENTER
	CAIN	T1,"C"
	JRST	CNCCON		;CONTINUE
	CAIN	T1,"M"
	JRST	MONRET		;PUNT!
	CAIN	T1,"E"
	JRST	[TLNE	FL2,DOENDF	;WERE WE ALREADY IN END CODE?
		 JRST CNCCON	;YES, JUST GO ON
		MOVEI T1,CNCXIT ;(202) DO "E" COMMAND
		 JRST CNCIN1]	;(202) DISMISS TO NEW PC
	CAIN	T1,"Q"
	JRST	[TLNE	FL2,DOENDF	;WERE WE ALREADY IN END CODE
		 JRST CNCCON	;YES, JUST GO ON
		MOVEI T1,CNCQT	;DO "EQ" COMMAND
		 JRST CNCIN1]	;DISMISS TO NEW PC
	CAIN	T1,"D"
	CALL	CHKDDT		;CHECK DDT ALLOWED
	  JRST	CNCIN0		;TRY AGAIN
	HRRZ	T1,T1
CNCIN1:	MOVEM	T1,RETSAV	;NEW PC FOR DEBRK
	CALL	ENBINT		;RE-ENABLE INTS
	POP	P,T1		;RESTORE T1
	SETOM	CNCLOK		;CLEAR INTERLOCK
	DEBRK			;AND GO TO NEW ROUTINE
	  ERJMP	.+1
	JRSTF	@RETSAV		;DO OUR BEST

;PDL OVERFLOW HANDLER

PDLTRP:	PUSH	P,T1		;SAVE T1
	MOVEI	T1,PDLOV	;WHERE WE WANT TO BE
	MOVEM	T1,RETSAV	;SAVED PC
	POP	P,T1		;RESTORE T1
	DEBRK			;DISMISS
	ERROR	ICN		;NEVER COME HERE

PDLOV:	NERROR	STC		;STRING TOO COMPLEX

;HERE TO DUMMY E CMD

CNCXIT:	TLO	FL2,DOENDF	;SET DO END REQUEST

	MOVEI	T1,12		;(202) FAKE OUT SCANNER
	MOVEM	T1,LIMBO	;(202) SAVE IT
	JRST	ENDIT		;(202) PREPARE FOR EXIT
;HERE TO DUMMY UP EQ

CNCQT:	MOVEI	T1,12		;FAKE OUT SCANNER
	MOVEM	T1,LIMBO
	JRST	QUIT		;AND EXIT

CNCREN:	SKIPGE	CNCLOK		;IS THIS A "REE" CMD?
	JRST	[OUTSTR [ASCIZ "?Cannot REENTER from error."]
		 JRST LOSER]	;SORRY
	POP	P,T1
	CALL	ENBINT		;RE-ENABLE ^C CHL
	TLO	FL2,RENTF	;FLAG THAT WE ARE TRYING TO REENTER SO NEXT TIME
				;CHKREN IS CALLED, CONTROL WILL PASS TO COMND
	DEBRK			;DISMISS
	  ERJMP	.+1
	JRSTF	@RETSAV		;NOT INSIDE INT

;ROUTINE TO CHECK IF WE HAVE REENTERED, SKIP RETURN IF NOT.

CHKREN:	TLNN	FL2,NORENT	;ALLOWED?
	TLZN	FL2,RENTF	;YES: CHECK FLAG
	AOS	(P)		;NO: SKIP RETURN
	POPJ	P,		;NO SKIP IF WE DID

CNCCON:	POP	P,T1		;RESTORE T1
	SKIPE	ECFLG		;(194) IS  ECHO FLAG SET?
	CALL 	NOECHO		;(194) PUT BACK IN NOECHO MODE
	SETZM	ECFLG		;(194) SET FLAG TO ZERO
	CALL	ENBINT		;RE-ENABLE ^C CHL
	DEBRK			;AND CONTINUE
	  ERJMP	.+1
	JRSTF	@RETSAV		;NOT INSIDE INT I GUESS

CNCHLP:	OUTSTR	CNCTXT
	CALL	CHKDDT		;SEE IF OK TO TELL HIM
	  SKIPA			;NO SKIP OVER MSG
	OUTSTR	[ASCIZ "D - transfer to DDT
"]
	JRST	CNCIN0

CNCTXT:	ASCIZ "Type one of (followed by carriage return):
C - to CONTinue automatically
E - to end edit and close file
Q - to quit (delete temporary files)
M - return to MONITOR now
R - to do REEnter (terminate losing search etc.)
"

;ROUTINE TO CHECK DDT EXISTANCE

CHKDDT:	PUSH	P,T2		;SAVE T2
	PUSH	P,T3		; & T3
	MOVEI	T1,.FHSLF
	RPCAP			;GET CAPABILITIES
	POP	P,T3		;DON'T CARE
	TRNN	T2,SC%WHL	;WHEEL?
	JRST	NODDT		;NOPE
	MOVE	T1,[.FHSLF,,770] ;PAGE # OF DDT
	RPACS			;CHECK ACCESS
	TLNE	T2,(PA%PEX)	;EXISTS?
	JRST	CHKDD1		;YES - MORE CHECKING
	MOVSI	T1,(GJ%SHT!GJ%OLD)
	HRROI	T2,[ASCIZ "SYS:UDDT.EXE"]
	PUSHJ	P,GTJFNX	;GET JFN
	  JRST	NODDT		;FAIL RETURN
	HRLI	T1,.FHSLF	;INTO OURSELVES
	GET			;GET IT
	  ERJMP	NODDT		;FORGET IT
	HRRZS	T1		;RESET JFN
	RLJFN			;RELEASE IT
	MOVEI	T1,.FHSLF	;RESET ENTRY VECTOR
	MOVE	T2,[3,,EV]
	SEVEC			;...
	MOVE	T1,.JBSYM##	;GET SYMBOL TABLE PNTR
	HRRZ	T2,770001	;PNTR TO PLACE TO PUT IT
	MOVEM	T1,0(T2)	;STORE IT
	MOVE	T1,.JBUSY##	;UNDEF PNTR
	HRRZ	T2,770002
	MOVEM	T1,0(T2)	;STORE IT ALSO
	JRST	DDTOK		;START UP DDT

CHKDD1:	MOVE	T1,770000	;GET FIRST LOC
	CAMN	T1,[JRST 770002] ;CHECK XFER INST
DDTOK:	AOS	-1(P)		;SET FOR SKIP RETURN
	MOVEI	T1,770000	;START ADDRS
NODDT:	POP	P,T2		;RESTORE T2
	RET			;RETURN
SUBTTL	DISK FULL AND QUOTA EXCEEDED HANDLING

;HERE ON OPENF FAILURE FOR WRITE -- CHECK REASON

OPNERR:	CAIE	T1,OPNX10	;DISK QUOTA EXCEEDED
	CAIN	T1,OPNX23	;ENTIRE DISK FULL
	JRST	OPNER1		;YES - HANDLE
	OUTSTR	[ASCIZ "
? Cannot open "]
	MOVEI	T1,.PRIOU
	MOVE	T2,OPNJFN	;JFN THAT FAILED
	MOVEI	T3,0
	JFNS			;PRINT FILESPEC
	OUTSTR	[ASCIZ " because,"]
	CALL	CJERR0		;SYSTEM MESSAGE
	JRST	LOSER		; AND EXIT
OPNER1:	POP	P,T1		;RETURN ADDRS
	SUBI	T1,2		;ADJUST TO OPENF RETRY
	MOVEM	T1,RETSAV	;USE INT LOC
	PUSH	P,OPNJFN	;PUT THIS ON STACK IN CASE EXIT
	CALL	DSKFUL		;COMMON DISK FULL ROUTINE
	CALL	ENBINT		;RE-ENABLE INTS
	POP	P,T1		;CLEAN UP PDL , SET UP JFN
	JRSTF	@RETSAV		;RETRY

;COME HERE ON CHL 20 INTERUPT (DISK IS FULL ETC...)

DSKTRP:	PUSH	P,T1		;SAVE A REG
	HRRZ	T1,RETSAV	;GET PC OF INSTRUCTION WHICH FAILED
	MOVE	T1,1(T1)	;GET INSTRUCTION FOLLOWING
	TLC	T1,(<CAI>)	;COMPARE WITH SPECIAL INSTRUCTION
	TLNN	T1,-1		;IS IT THE ONE?
	MOVEM	T1,RETSAV	;YES, SET RETURN PC AS DESIRED
	CALL	DSKFUL		;DO COMMON CODE
	CALL	ENBINT		;RE-ENABLE
	POP	P,T1		;RESTORE T1
	DEBRK			;DISMISS INT
	ERROR	ICN		;BETTER NOT
;COMMON DISK FULL ROUTINE -- T1 ALREADY SAVED

DSKFUL:	CALL	NOCTRO		;TURN OFF ^O
	CALL	OFFINT		;DISALLOW ^C
	HRROI	T1,[ASCIZ "
?Disk or directory full, or quota exceeded"]
	PSOUT
DSKFL1:	CALL	CLRBFI		;CLEAR TYPEAHEAD
	HRROI	T1,[ASCIZ "
Type one of (M,P,W): "]
	PSOUT
	CALL	INHELP
	  JRST	DSKHLP		;HE WANTS HELP
	CAIN	T1,"M"		;WANT TO QUIT?
	JRST	[SETZM CNCLOK	;GRNTEE CONTINUE
		 POP P,0(P)	;PRUNE RETURN ADDRS
		 JRST MONRET]	;  AND EXIT
	CAIN	T1,"W"		;WAIT TILL WE CAN TRY AGAIN
	JRST	DSKWAT
	CAIE	T1,"P"		;PURGE AND RETRY
	JRST	DSKFL1		;RE-PROMPT
	PUSH	P,T2		;SAVE SOME REGS
	PUSH	P,T3
	PUSH	P,T4		;...
	GJINF
	PUSH	P,T2		;SAVE CONNECTED DIR
	MOVE	T1,T2		;DIR # TO T1
	GTDAL			;GET CURRENT USAGE
	PUSH	P,T2		;SAVE IT
	MOVEI T1,0
	MOVE T2,-1(P)		;DIR #
	DELDF			;DO EXPUNGE
	  ERJMP	[OUTSTR [ASCIZ "%Expunge failed -- continuing"]
		 OCRLF
		 JRST .+1]
	MOVE	T1,-1(P)	;DIR #
	GTDAL			;CURRENT ALLOCATION
	POP	P,T1		;RESTORE OLD VALUE
	SUB	T1,T2		;TAKE DIFFERENCE
	EXCH	T1,0(P)		;STORE ON PDL
	MOVEI	T1,"["
	PBOUT			;PRINT MESSAGE
	POP	P,T2		;GET VALUE
	CALL	DPRNT		;PRINT DECIMAL
	HRROI	T1,[ASCIZ " Pages freed]"]
	PSOUT
	OCRLF
	POP	P,T4		;RESTORE REGS
	POP	P,T3
	JRST	T2POPJ		;AND RETURN
;ROUTINE TO WAIT FOR DISK SPACE TO APPEAR

DSKWAT:	OUTSTR	[ASCIZ /%NOT IMPLEMENTED YET - WILL WAIT 1 MIN.
THEN CONTINUE AUTOMATICALLY....WAITING.....
/]
	MOVEI	T1,^D60*^D1000
	DISMS
	OUTSTR	[ASCIZ /[OK]
/]
	RET

INHELP:	INCHRW	T1		;GET REPLY
	CAIN	T1,"?"		;CHECK FOR IMMEDIATE HELP
	JRST	[OCRLF		;GIVE CRLF
		 CALL CLRBFI	;CLEAR TYPEAHEAD
		 RET]		;GIVE NON-SKIP RETURN
	PUSH	P,T1		;SAVE IT
	INCHRW	T1		;LOOK AT NEXT CHAR
	CALL	CLRBFI		;CLEAR OUT TTY TYPE AHEAD
	CAIE	T1,15		;CHECK FOR CR
	JRST	[POP P,T1	;PRUNE PDL
		 MOVEI T1,177	;RETURN A RUBOUT
		 JRST INHLPX]	;...
	POP	P,T1		;RESTORE CHAR TYPED
	ANDI	T1,137		;FORCE UPPER CASE
INHLPX:	CAIE	T1,"H"		;CHECK FOR HELP
	AOS	0(P)		;GIVE SKIP
	RET			;RETURN

DSKHLP:	OUTSTR	DSKTXT		;PRINT MSG
	CALL	NOCTRO		;TURN OFF CTRL-O
	JRST	DSKFL1		;TRY AGAIN

DSKTXT:	ASCIZ	\Type one of (followed by carriage return):
M - To exit to the monitor
P - Purge (EXPUNGE) deleted files and try again
W - Wait until space becomes available
\
SUBTTL	ERROR MESSAGES

DEFINE ERRORS <
FERR (ICN,<Internal confusion>,<Internal confusion>)
WERR (ILC,ILC,<Illegal command>)
FERR (ILUUO,ILUUO,<Illegal UUO>)
WERR (LTL,LTL,<Line too long>)
WERR (NLN,NLN,<No such line(s)>)
WERR (NSP,NSP,<No such page>)
WERR (ORDER,ORDER,<Warning -- Sequence numbers out of order, use N command to correct.>)
WERR (ILR,ILR,<Illegal replacement on insert>)
WERR (WAR,WAR,<Wrap around>)
WERR (TMS,TMS,<Too many strings>)
WERR (STL,STL,<String too long>)
WERR (ISS,ISS,<Illegal search string>)
WERR (ILFMT,ILFMT,<Illegal line format>)
WERR (NSG,NSG,<No string given>)
WERR (NEC,SPACE,<Copy exceeds 128 pages>)
WERR (IRS,IRS,<Illegal replacement string>)
WERR (STC,STC,<Search string too complex>)
WERR (ITD,ITD,<Illegal transfer destination>)
WERR (NNN,NNN,<No next line>)
WERR (SRF,SRF,<Search fails>)
WERR (CMEND,CMEND,<End of indirect file>)
WERR (ILDC,ILDC,<Illegal decide character (Type H for help)>)
FERR (NORM,NORM,<No room for identifying line>)
WERR (EMTY,EMTY,<File is empty>)
>

DEFINE FERR (CODE,SHORT,LONG) <ERMS (?,CODE,<SHORT>,<LONG>)>

DEFINE WERR (CODE,SHORT,LONG) <ERMS (%,CODE,<SHORT>,<LONG>)>

DEFINE ERMS (CHAR,CODE,SHORT,LONG) <
	CODE==<%%ERR==%%ERR+1>
	[ASCIZ \CHAR'SHORT\],,[ASCIZ \CHAR'LONG\]
>

%%ERR==0		;INIT COUNTER

ETBL:	ERRORS
NUMER==%%ERR
	PURGE	%%ERR
SUBTTL COMMAND DECODER AND DISPATCH

ERET:
COMND:	SETZM	SAVCHR		;SCAN SHOULD GET RESET AT THIS POINT
	SETZM	SAVC		;...
	SETZM	FSFLG		;CLEAR F/S FLAG
	TLZ	FL2,EXCPFL	;(207) CLEAR FLAG
	TLNE	FL,ISCOP	;THIS CASE IS SPECIAL SINCE WE
	SKIPA	P,COPDL		;SHOULD NOT DESTROY SAVED ITEMS
	MOVE	P,[IOWD PDLSIZ,PDL] ;ALSO PDL (IN CASE OF ERRORS)
	CALL	DOECHO		;TURN ECHO BACK ON JUST IN CASE
	TRNE	FL2,COMFLF	;DON'T BOTHER IF IN CMD FILE
	JRST	CMNDN		;...
	MOVEI T1,.PRIOU
	MOVE T2,MODW		;GET MODES
	TLZ T2,(TT%OSP)		;CLEAR ^O
	TRO T2,<.TTATE>B29	;RESET OUTPUT XLATE
	SFMOD			;...
	TRO	FL2,ALTECH	;GRNTEE $ ECHO
CMNDN:	SKIPN	T1,TEMINC	;TEMP INCR?
	MOVE	T1,INCR		;NO: USE CURRENT ONE
	MOVEM	T1,INCR		;YES: RESOTRE OLD ONE
	SETZM	TEMINC		;CLEAR TEMP
	TLZE	FL2,DOENDF	;NEED END COMMAND?
	JRST	CMDEND		;YES: GO DO IT
	TLNE	FL,SRCOP
	JRST	NOCPCK		;DO NOT GET OUT OF COPY MODE
	TLZE	FL,ISCOP	;IN COPY MODE?
	JRST	COPDON		;YES, DO SPECIAL CLEAR OUT
NOCPCK:	TLZN	FL2,NORENT	;NEED TO CHECK FOR REENTER
	JRST	NORNCK		;NO:
	TLZE	FL2,RENTF	;SEE IF NEED TO REENTER
	JRST	[MOVEI T1,[TLZ FL2,RENTF
			   JRST COMND]
		 MOVEM T1,RETSAV ;HACK SAVED PC
		 JRST TRAP]	;SIMULATE ^C
NORNCK:	TRNN	FL,EXTOG	;SKIP THIS HACK IF IN EXPERT MODE
	SKIPN	T1,DELCNT#	;  OR IF NO DELETIONS
	JRST	CMNDA
	MOVEI	T3,OCHR		;SET UP FOR PRINTER
	PUSHJ	P,DECPR		;PRINT # OF LINES DELETED
	PUSHJ	P,FORCE		;DUMP IT
	OUTSTR	[ASCIZ / Lines (/]
	MOVE	T1,FDELLN#	;GET FIRST LINE DELETED
	MOVEM	T1,LINOUT	;PRINT IT
	OUTSTR	LINOUT
	MOVE	T1,FDELPG#
	PUSHJ	P,DECPR		;AND PAGE #
	PUSHJ	P,FORCE
	MOVE	T2,LDELLN#	;LAST LINE DELETED
	SKIPN	PGDELS		;IF ANY PAGE MARKS DELETED
	CAME	T2,FDELLN	;SAME AS FIRST?
	JRST	[OUTCHR [":"]	;NO: PRINT IT ALSO
		 SETZI T3,
		 OUTSTR T2
		 SKIPN T1,PGDELS
		 JRST .+1
		 ADD T1,FDELPG
		 OUTCHR ["/"]
		 MOVEI T3,OCHR	;ROUTINE TO USE
		 PUSHJ P,DECPR
		 PUSHJ P,FORCE
		 JRST .+1]
	OUTSTR	[ASCIZ /) deleted
/]
CMNDA:	PUSHJ	P,CMDSAV	;CHECK FOR AUTO-SAVE
	  JRST	CMND2		;DO IT
	TRNE	FL2,SUPN!COMFLF	;SUPPRESS * AFTER PRETTY PRINT
	JRST	CMNDB
	MOVE	T1,[ASCII "*"]	;PROMPT
	TLNE	FL,SRCOP	;GIVE XTRA PROMPT IF COPY
	MOVE	T1,[ASCII "C*"]
	MOVEM	T1,CRBUF	;STORE FOR ^R
	OUTSTR	CRBUF		;AND PRINT IT
CMNDB:	TRZ	FL2,SVIT!SUPN	;TURN OFF SOME BITS
IFN EXTEND,<
	MOVEI	T1,LSNUM	;RESET LINE SEARCH STRINGS
	MOVEM	T1,LSBUFN
>
	TRNN	FL2,COMFLF	;COMMAND FILE?
	JRST	CMND1		;NO
	MOVE	T2,[ASCII /00001/] ;INCREMENT CMD CNT
	MOVE	T1,COMCNT
	PUSHJ	P,ASCIAD	;ASCII ADDDER
	MOVEM	T1,COMCNT	;STORE
CMND1:	PUSHJ	P,GNCH		;READ A CHARACTER
	TLZ	FL2,RENTF	;CLEAR FLAG - HE MAY TRY TO REENTER
	CAIE	C,15
	JUMPE	CS,CMND1	;IGNORE SPACES ETC
	TLNE	CS,LETF_16	;CHECK TO SEE IF LETTER
	TRZ	C,40		;AND CONVERT TO UPPER CASE
CMND2:	MOVSI	T1,-CMDLG	;GET LENGTH OF COMMAND TABLE
	CAME	C,CMD1(T1)	;COMPARE
	AOBJN	T1,.-1		;CHECK FOR MATCH
	SETZM	DELCNT
	SETZM	LDELLN
	SETZM	FDELLN
	SETZM	FDELPG		;INIT DELETE CNTS
	CAIE	C,"P"		;(195) IS IT A P COMMAND?
	SETZM	PNOARG		;(195) NO CLEAR P MEMORY
	JUMPL	T1,@CMD2(T1)	;DISPATCH IF FOUND
	NERROR	ILC		;ELSE ERROR
; THE COMMAND TABLE
;	(NAME,DISPATCH ADDRESS,HELP MESSAGE)
;  OR   (OLD NAME,"NOTHER",NEW COMMAND TO USE)

	DEFINE COMTAB <

X	("?",QUEST,<?>)
X	(12,NXTLIN,<<LF>>)
X	(200,BAKLIN,<<ESC>>)
X	("A",ALTER,<Alter - A>)
X	("B",SVCOD,<Backup - B, BI, BJ, BN, BU>)
X	("C",COPY,<Copy - C>)
X	("D",DELETE,<Delete - D>)
X	("E",ENDIT,<End - E, EI, EJ, EN, EU, EK, EQ>)
X	("F",SEARCH,<Find - F>)
X	("=",GIVE,<Give - =>)
X	(";",COMNT,<Comment - ;>)
X	("G",GEND,<Go - G, GI, GJ, GN, GU>)
X	("H",HELP,<Help - H>)
X	("@",COMFIL,<Indirect - @>)
X	("I",INSERT,<Insert - I>)
X	("J",JOIN,<Join - J>)
X	("K",KILL,<Kill - K>)
X	("L",LIST,<List - L>)
X	("M",MARK,<Mark - M>)
X	(".",PMOVE,<Move - .>)
X	("N",NUMBER,<Number - N>)
X	("P",PRINT,<Print - P>)
X	("R",REPLAC,<Replace - R>)
X	("/",SET,<Set - />)
X	("S",SUBST,<Substitute - S>)
X	("T",TRANS,<Transfer - T>)
X	("X",XPAND,<eXtend - X>)
X	(15,NULCMD,)

>

	DEFINE X(A,B,C) <
	EXP A >
CMD1:	COMTAB
CMDLG==.-CMD1

	DEFINE X(A,B,C) <
	EXP B >
CMD2:	COMTAB

	DEFINE X(A,B,C) <
	[ASCIZ !C!]>
CMD3:	COMTAB

;COME HERE TO DO AUTO SAVE

CMDSAV:	TRNE	FL,READOF	;CHECK RO
	JRST	CPOPJ1		;YES - SKIP THIS
	TLZE	FL2,CCHGF	;DID THIS COMMAND CHANGE THINGS?
	SOSE	SAVEN		;YES -- COUNT DOWN
	JRST	CPOPJ1		;STILL OK
	OUTSTR	[ASCIZ "[Doing auto-save, please wait.]"]
	OCRLF
	MOVEI	C,"B"		;FUDGE UP B COMMAND
	MOVEI	T1,12		;FUDGE UP LINE TERM
	MOVEM	T1,LIMBO
	POPJ	P,		;PROCESS COMMAND

NULCMD:	PUSHJ	P,GNCH		;GRNTEE LF AFTER CR COMMAND
	CAIE	C,12		;IS IT?
	NERROR	ILC		;NO: LOSE
	JRST	COMND		;YES: WIN

CMDEND:	MOVEI	C,"E"		;DUMMY CMD
	TLZ	FL2,RENTF	;CLR FLAG
	MOVEI	T1,12
	TLNN	FL,SRCOP	;NEED DUMMY LF IF NOT COPY
	MOVEM	T1,LIMBO
	JRST	CMND2		;PROCESS

COMNT:	SETZM	ALTSN	;NO ALT SEEN YET
	CALL	RDLIN		;GET A LINE TO TOSS OUT
	JFCL			;DONT CARE IF NONSKIP
	SKIPE	ALTSN		;END WITH ALT?
	OCRLF			;YES, CRLF FOR HIM
	SETZM	ALTSN		;CLEAR FLAGS
	JRST	COMND		;AND OUT

SUBTTL MOVE, HELP, AND ?
HELP:	CALL	SCAN		;SCAN TERMINATOR
	TRNN	FL,TERMF	;CHECK EOL
	NERROR	ILC
	MOVSI	T1,(GJ%OLD!GJ%SHT!gj%ifg)
	HRROI	T2,[ASCIZ "HLP:EDIT.HLP"]
	PUSHJ	P,GTJFNX	;FILE TO TRY FOR
	  JRST	SORROW		;EXIT IF NOTHING
	hrrz t1,t1		;clear the left hand bits
	PUSH	P,T1		;SAVE JFN
	MOVE	T2,[7B5+OF%RD]	;OPEN FOR READ
	OPENF
	  JRST	[POP P,T1	;GET JFN
		 RLJFN		;FLUSH
		   JFCL
		 JRST SORROW]	;NOTHING TO DO
HELP1:	MOVE	T1,0(P)		;JFN
	BIN			;CHAR
	JUMPE	T2,HELP2	;CHECK FOR EOF
	MOVE	T1,T2		;COPY CHAR TO T1
	PBOUT			;DUMP ON PRIMARY
	JRST	HELP1		;GET SOMEMORE

HELP2:	GTSTS			;GET DEVICE STATUS
	TLNN	T2,(GS%EOF)	;EOF?
	JRST	HELP1		;NO - TRY NEXT (IGNORE NULLS)
	CLOSF			;YES - FLUSH JFN
	  FJERR
	OCRLF			;XTRA ANYHOW
	JRST	COMND		;AND RETURN TO USER

SORROW:	OUTSTR	[ASCIZ "% I'm sorry I can't help you."]
	OCRLF
	JRST	COMND		;T-S
PMOVE:	SETZM LOLN
	PUSHJ P,GET1S		;GET A POS.
	TRNE FL,TERMF		;CHECK ARG
	SKIPN HILN
	NERROR ILC
	MOVE T1,HIPG
	MOVEM T1,DPG
	MOVE SINDEX,HILN	;PERFORM SEARCH
	PUSHJ P,FIND
	MOVE T2,CPG		;FIND THE ONE WE WANT
	CAME T2,HIPG
	NERROR NSP
	CAME T1,HILN
	NERROR NLN
	MOVEM T1,CLN		;MAKE IT CURRENT
	MOVEM T2,CPGL
	JRST COMND

QUEST:	PUSHJ P,SCAN		;CHECK FOR VALID TERMINATOR
	TRNN	FL,TERMF
	NERROR	ILC		;GIVE ERROR IF HE DESERVES IT
	OUTSTR	[ASCIZ / Commands are:/]
	MOVSI	T1,-CMDLG	;GET LENGTH OF COMMAND TABLE
QUEST1:	MOVE	T2,CMD3(T1)	;GET LOCATION
	OCRLF
	OUTSTR	(T2)		;PRINT THE STRING
QUEST2:	AOBJN	T1,QUEST1	;KEEP GOING
	JRST	COMND
 

	SUBTTL PRINT
;PRINT LINES SPECIFIED

PRINT:	SETZM LOLN	;AS A FLAG IN CASE OF /C OR /A,/C
	TRZ	FL2,SUPN
IFN PPNTSW,<
	MOVEI	JF,0		;CLEAR SPECIAL FLAGS
	MOVEI T2,1
	MOVEM T2,LSTCNT
	SETZM LOGPG		;CLEAR COUNTERS AND THINGS
>
	PUSHJ P,SCAN
	CAIE C,","	;IS THERE A SWITCH?
	JRST PRNT5	;NO
	PUSHJ P,PRNSCN	;SCAN FOR SWITCHES
PRNT5:	TRNE FL,TERMF
	JRST	[MOVE T1,CLN	;MAKE P WITH NO ARGS DO P.!<PLINES>
		 MOVEM T1,LOLN
		 MOVE T1,CPGL
		 MOVEM T1,LOPG
		 MOVE T1,PLINES
		 MOVEM T1,SVCNT
		 MOVEI T1,1	;(195) FLAG FOR PNOARG IF NEEDED
		 SKIPE PNOARG	;(195) DO WE NEED TO SKIP?
		 MOVEM T1,PNOARG;(195) YES, SET FLAG SO WE DO
		 TRO FL,CNTF
		 MOVE T1,DTYPE		;TERMINAL TYPE
		 XCT CURUP(T1)		;CURSOR UP FCN
		 OUTCHR [15]
		 JRST PRCNT]
	PUSHJ P,GET2	;GET A DOUBLE STRING
	CAIN C,","	;(195) IS THERE A SWITCH?
	PUSHJ P,PRNSCN	;(195) YES, LOOK AT THEM
	TRNN FL,TERMF	;(195) DID IT END WITH A TERMINATOR
	NERROR ILC	;(195) NO, ILLEGAL
	SETZM PNOARG	;(195) NOT P WITH NO ARGS
PRCNT:	TRZ FL,LINSN	;USE THIS AS A FLAG TO CHECK FOR NULL RANGE
	TRNE	FL2,NONUMF	;NEED TO SUPPRESS NUMBERS
	TRO	FL2,SUPN	;YES:
IFN PPNTSW,<
	TRNE	JF,EJECT!WAIT
	PUSHJ P,PGWT	;WAIT FOR USER!
>
RPGPRN:	MOVE T1,LOPG	;FIND THE FIRST LINE WANTED
	MOVEM T1,DPG	;SET IT AS THE ONE WE WANT
	MOVE SINDEX,LOLN	;PICK UP THE LINE
	PUSHJ P,FIND	;GO GET IT
	JUMPE T1,EPRNT	;(220)IF END OF FILE, STOP!!!!!
	SKIPLE PNOARG	;(195) SKIP THIS LINE (ALREADY PRINTED)
	JRST PRNT4	;(195) YES START WITH NEXT
	SKIPE LOLN	;DID WE WANT TO PRINT AN ENTIRE PAGE
	JRST PRNT1	;NO, GO CHECK BOUNDS
	MOVE T2,CPG	;WHICH ONE ARE WE ON
	MOVEM T2,CPGL
	TRNN	FL2,SUPN
	PUSHJ P,PGPRN	;PRINT THE PAGE HEADER
	TRO FL,LINSN	;THIS CAN COUNT AS A LINE
PRNT1:	PUSHJ P,ONMOV	;CHECK TO SEE IF STILL IN RANGE
	JRST EPRNT	;NO, END
	TRO FL,LINSN	;WE HAVE SEEN ONE
	CAMN T1,PGMK	;IS IT A PAGE MARK?
	JRST PRNT3	;YES, DO SOMETHING SPECIAL
	MOVEM T1,CLN
	MOVEM T2,CPGL	;SAVE PAGE TOO
	MOVE T1,PNTR	;GET THE POINTER TO IT
	PUSHJ P,OUTLIN	;AND PRINT
IFN PPNTSW,<
	AOSN LSTCNT
	PUSHJ P,PAGEND	;END OF PAGE
>
PRNT4:	PUSHJ P,FINDN	;GET THE NEXT LINE
	JRST PRNT1	;AND CONTINUE
PRNT3:	MOVEM T2,CPGL
IFN PPNTSW,<
	SOS LSTCNT	;ADJUST FOR PAGE MARK
	PUSHJ P,PAGEND	;DO END OF PAGE ROUTINE
	SETZM LOGPG	;RESET LOGICAL PAGE COUNTER
>
	TRNE	FL2,NONUMF	;SPECIAL HACK IF NONUM MODE
	OUTCHR	[14]		;WON'T HE BE ...
	TRNN	FL2,SUPN	;UNLESS PRINTING A CLEAN COPY,
	PUSHJ P,PGPRN	;GO PRINT A PAGE HEADER
	AOS CPG
	MOVE T2,[<ASCII /00000/>!1]
	MOVEM T2,CLN	;SET LINE TO FIRST ON THAT PAGE
	JRST PRNT4	;AND CONTINUE
EPRNT:	TRZN FL,LINSN	;DID WE PRINT SOMETHING
	NERROR NLN	;NO, ERROR
IFN PPNTSW,<
	PUSHJ P,PAGEJT	;EJECT PAGE
>
	TRNE	FL2,NONUMF
	TRZ	FL2,SUPN	;TURN IT OFF IF IN NONUM MODE
	JRST COMND	;YES, RETURN FOR COMMAND



;CHECK TO SEE IF OUT OF LIMITS SKIP RETURN IF OK
ONMOV:	JUMPE T1,CPOPJ	;0, MUST BE EOF SO ALL DONE
	PUSHJ	P,CHKREN	;CHECK REENTER
	POPJ	P,		;YES: SAY WE ARE THROUGH
ONMOV1:	MOVE T2,CPG	;GET THE CURRENT PAGE
	CAMN T1,PGMK	;ARE WE AT A PAGE MARK?
	ADDI T2,1	;YES, TREAT AS NEXT PAGE
	TRNE FL,CNTF	;IS THIS A ! TYPE COMMAND?
	JRST ONCNT
	CAMLE T2,HIPG	;HOW DOES IT COMPAGE WITH UPPER LIMIT
	POPJ P,		;HIGHER, ALL DONE
	CAME T1,PGMK	;IF PAGE MARK, DO NOT COMPARE LINE
	CAME T2,HIPG	;OR IF NOT ON LAST PAGE
	SKIPA
	CAMG T1,HILN	;ARE WE OUT OF LINES?
	AOS (P)	;SKIP RETURN ALL OK
	POPJ P,		;GO

ONCNT:	CAMN T1,PGMK	;DO NOT COUNT PAGE MARKS
	SKIPG SVCNT	;IF PAGE MARK, GIVE UP IF DONE
	SOSL SVCNT	;ARE WE OUT
	AOS (P)		;SKIP RETURN FOR OK
	POPJ P,
;HERE TO EJECT PAGE

IFN PPNTSW,<
PAGEJT:	TRNN	JF,EJECT	;EJECTING?
	POPJ P,		;NO: JUST RETURN
	MOVE T5,LSTCNT
	ADD T5,PAGESZ	;GET COUNT LEFT
	SUBI T5,FULLPG	;EJECT TO TOP OF PAGE
	TRNN	JF,WAIT		;IF NOT WAITING
	SUBI T5,1	;ONE MORE LINE
	SUBI T5,1	;HANDLE ZERO CASE
	MOVEI C,15	;PUT OUT CR
	PUSHJ P,OCHR
	JRST PUTLN1

PUTLN:	MOVEI C,12
	PUSHJ P,OCHR	;OUTPUT LF'S
PUTLN1:	CAMN T5,[-11]	;A BIT WEIRD
	PUSHJ P,PUTPG
	AOJL T5,PUTLN
	AOS LOGPG	;INCR LOGICAL PAGE
	PUSHJ	P,FORCE		;OUTPUT
	POPJ P,

;HERE TO WAIT FOR BOTTOM OF PAGE

PAGEWT:	TRNN	JF,WAIT	;WAITING?
	JRST NOWAIT	;NOPE!
PGWT:
	OUTSTR [BYTE (7)10,10,10,10,0]
READ1:	PUSHJ P,GNCH	;GET NEXT CHAR
	CAIE C,"G"
	CAIN C,"g"
	TRZ	JF,WAIT
	CAIE C,"Q"
	CAIN C,"q"
	JRST QPRINT
	CAIE C,12	;LF?
	JRST READ1
NOWAIT:	MOVN T5,PAGESZ	;RESET LINE COUNT
	MOVEM T5,LSTCNT
	POPJ P,

QPRINT:	PUSHJ P,GNCH
	CAIE C,12	;SKIP TO LF
	JRST QPRINT
	JRST COMND
	;;;; STILL IN IFN PPNTSW
;HERE ON END OF PAGE

PAGEND:	PUSHJ P,PAGEJT	;EJECT A PAGE
	JRST PAGEWT	;AND GO WAIT

;ROUTINE TO OUTPUT FUNNY PAGE NUMBERS

PUTPG:	TRNN	JF,PGNOS	;ARE WE?
	POPJ P,
	MOVE T1,RMAR
	ADD T1,LMAR
	ASH T1,-1	;PUT OUT (R+L)/2 BLANKS
PUTPG1:
	OUTCHR [" "]
	SOJG T1,PUTPG1
	OUTCHR ["-"]
	MOVE T2,CPG		;CURRENT PAGE
	PUSHJ P,DPRNT
	MOVE T2,LOGPG		;LOGICAL PAGE
	JUMPE T2,PUTPG2
	OUTCHR ["."]
	PUSHJ P,DPRNT		;SUB-PAGE
PUTPG2:
	OUTSTR [BYTE (7)"-",15]
	POPJ P,
>	;;; END IFN PPNTSW
;PRINT SWITCH SCANNER

IFN PPNTSW,<
PRNSCN:	PUSHJ P,SCAN		;GET NEXT CHAR
	MOVS T1,ACCUM
	CAIN T1,(<SIXBIT /N  />)
	TRO	JF,PGNOS
	CAIN T1,(<SIXBIT /S  />)
	TRO	FL2,SUPN
	CAIN T1,(<SIXBIT /W  />)
	TRO	JF,WAIT
	CAIN T1,(<SIXBIT /E  />)
	TRO	JF,EJECT
	CAIN T1,(<SIXBIT /F  />)
	JRST	[TRO JF,EJECT!WAIT
		 TRO FL2,SUPN
		 JRST .+1]
	PUSHJ P,SCAN		;SCAN PAST IT
	TRNE FL,TERMF		;TERMINATOR
	JRST	[TRNN	JF,EJECT!WAIT!PGNOS
		 TRNE	FL2,SUPN
		 POPJ P,
		 NERROR ILC]
	CAIE C,","		;MORE?
	NERROR ILC
	JRST PRNSCN		;YES - GET EM
>

IFE PPNTSW,<
PRNSCN:	PUSHJ	P,SCAN		;GET NEXT ATOM
	MOVS	T1,ACCUM
	CAIE	T1,(<SIXBIT /S  />)
	NERROR	ILC		;ONLY LEGAL SW IS S
	PUSHJ	P,SCAN		;SCAN PAST IT
	TRNN	FL,TERMF	;MUST BE END
	NERROR	ILC
	TRO	FL2,SUPN	;SET FLAG
	POPJ	P,		;RETURN
>
PGPRN:	PUSH	P,T2		;SAVE PAGE #
	MOVE	T2,DTYPE	;GET TERMINAL TYPE
	XCT	CRLF(T2)	;CRLF BY TYPE
	OUTSTR	[ASCIZ /Page /]
	POP	P,T2		;RESTORE #
	PUSHJ P,DPRNT	;PRINT THE NUMBER IN T2
	OCRLF
	AOS LSTCNT
	AOS LSTCNT		;PAGE N - TAKES 2 LINES
	POPJ P,

;THE USUAL NUMBER PRINTER

DPRNT:	PUSH	P,T1		;SAVE T1
	MOVEI	T1,.PRIOU	;USE PRIMARY OUTPUT
	MOVEI	T3,^D10		;DECIMAL #
	NOUT
	  JRST	[MOVE T1,T3	;ERROR CODE TO T1
		 FJERR]
	JRST	T1POPJ		;RESTORE & RETURN


;CHARACTER OUTPUT

OCHR:	JUMPE	C,CPOPJ		;IGNORE NULLS
	MOVE	CS,CTBL(C)	;GET THE MAJIC BITS
	TLNE	CS,LETF_16	;CHECK FOR LETTER
	TDC	C,CASEBT	;AND CHANGE CASE AS NECESSARY
	TRNE	FL2,SUPN	;IS THIS A PRETTY PRINT? IF SO NO ' CONVERSION
	JRST	OCH2
	PUSH	P,C		;SAVE THE CHARACTER
	LDB	C,[POINT 7,CTBL(C),10]	;GET PRINT EQUIV.
	JUMPE	C,OCH1		;NONE, PRINT ORIGINAL
	TDNE	CS,[XWD LETF_16,M37]	;IS THIS A LETTER OR SPECIAL
	TRNN	FL,M37F		;AND A MODEL 37
	TLNE	FL,QMODF
	JRST	[MOVE C,(P)	;GET ORIG CHAR
		 CAIL C,40	;CHECK FOR CONTROL CHAR
		 JRST OCH1	;NO - JUST PRINT IT
		 ADDI C,100
		 MOVEM C,(P)	;CONVERT TO PRINTING CHAR
		 MOVEI C,"^"
		 JRST OCH0]
	MOVEM	C,(P)		;SAVE IN STACK
	MOVEI	C,"'"
OCH0:	PUSHJ	P,OCH2		;PUT OUT CHR
OCH1:	POP	P,C		;GET CHAR TO PRINT
OCH2:	SOSG	TTOCNT
	PUSHJ	P,FORCE
	IDPB	C,TTOPNT
	POPJ	P,		;AND RETURN



OUTLIN:	TRNE	FL2,SUPN!NONUMF	;ARE WE SUPPRESSING LINE NUMBERS?
	AOS	T1		;YES, SKIP IT
	HRLI	T1,(<POINT 7,0>);GET SET TO PRINT A LINE
	TRNE	FL2,SUPN!NONUMF	;IF SUPPRESSING LINE NUMBERS
	IBP	T1		;ALSO SUPPRESS THE TAB WHICH FOLLOWS
	SETOM	PNOARG	;(195) REMEMBER FOR LATER
OUTL1:	ILDB	C,T1		;GET A CHR
	JUMPE	C,FORCE		;QUIT ON NUL
	PUSHJ	P,OCHR		;AND PRINT IT
	CAIN	C,14		;(205) FORMFEED?
	JRST	FORCE		;(205) YES
	CAIN	C,12		;(205) LINEFEED?
	JRST	FORCE		;(205) YES
	JRST	OUTL1		;NO, CONTINUE
		;;;		;FALLIN FORCE

;ROUTINE TO DUMP TTY BUFFER AND SET UP FOR NEXT

FORCE:	PUSH	P,C		;SAVE CURRENT CHAR
	MOVEI	C,0		;GRNTEE NULL
	IDPB	C,TTOPNT	;AT END OF STRING
	OUTSTR	TTOBUF		;DUMP IT
	MOVEI	C,^D80		;NEW COUNT
	MOVEM	C,TTOCNT
	MOVE	C,[POINT 7,TTOBUF]
	MOVEM	C,TTOPNT	;AND PNTR
	POP	P,C		;RESTORE C
	POPJ	P,		;AND RETURN

SUBTTL END ROUTINE
;CODE TO FINISH OFF EDIT

ASVINS:	SKIPA	T1,HILN		;LAST LINE INSERTED
ASVREP:	MOVE	T1,LOLN		;...
	MOVEM	T1,SVLNUM	;SAVE FOR RESTART
	TLO	FL2,AUTOF	;SET TO DO AUTO SAVE
	SKIPE	ALTSN		;NEED CRLF?
	OCRLF			;YEP
	OUTSTR	[ASCIZ "[Doing auto-save, please wait.]"]
	OCRLF
SVCOD:	TLNE	FL,SRCOP	;IF INSIDE COPY
	JRST	DSCOP		;TREAT LIKE AN E
	TRO	FL2,SVIT	;SET TO DO A SAVE
	MOVE	T1,SSAVEN	;RESET ALL CNTRS
	MOVEM	T1,SAVEN
	MOVE	T1,SISAVN	;RESET ISAVE PARAM
	MOVEM	T1,ISAVEN	;...
	PUSH	P,UNSEQF	;SAVE CURRENT VALUE
	SKIPN	UNSEQF		;CHECK FOR UNSEQ
	JRST	SVCOD1		;PROCEDE
	TRNN	FL,EXTOG	;ONLY PRINT IF NOVICE
	OUTSTR	[ASCIZ "[WARNING: Sequence numbers preserved.]
"]
	SETZM	UNSEQF
SVCOD1:	TRNN	FL,READOF	;READ-ONLY MODE?
	JRST	END0		;NO - CONTINUE
	MOVE	T1,[ORGBLK,,NEWBLK]
	BLT	T1,NEWBKE	;YES - SET UP NEWBLK THEN
	JRST	END0		;CONTINUE CMD
GEND:	TLOA	FL,GCOM		;GO
ENDIT:	TLZ	FL,GCOM		;NORMAL TYPE END
END0:	TLNE	FL,SRCOP
	JRST	DSCOP		;FINISH UP THE COPY COMMAND
	TLO	FL2,NORENT!DOENDF;DISABLE REENTER & MARK WE'RE IN END CODE
	TLZ	FL2,RENTF
	TRNE	FL,READOF	;IF READ ONLY
	JRST	ENDRO		;DO SPECIAL END CODE
	TLZ	FL2,BELLF	;DISABLE <BELL><BELL>
	PUSHJ	P,NSCAN		;SETUP NEWBLK
	NERROR	ILC		;BAD SYNTAX
	SKIPN	UNSEQF
	TRNE	FL,NEWFL
	TLO	FL2,PCHGF!FCHGF	;CHANGED IF UNSEQ OR NEW NAME
	TLNN	FL2,FCHGF
	JRST	[OCRLF
		 OUTSTR [ASCIZ "[No changes.]"]
		 OCRLF
		 CALL RLSINP	;RELEASE INPUT
		 CALL DELOUT	;DELETE OUTPUT FILE
		 JRST ENDEND]
	JRST	END1

;CODE TO HANDLE 'E' COMMANDS IN R/O MODE

ENDRO:	PUSHJ	P,GNCH		;GET A CHAR
	ANDI	C,137		;FORCE UPPER
	CAIE	C,"Q"		;QUIT OK ALSO
	MOVEM	C,SAVC		;BACKUP IF NOT Q
	PUSHJ	P,SCAN		;CHECK FOR EOL
	TRNN	FL,TERMF
	NERROR	ILC
	CALL	RLSINP		;RELEASE INPUT
	JRST	ENDEND		;JUST QUIETLY EXIT
END1:	PUSHJ	P,OCOMPL	;COMPLETE FILE COPY
	SKIPE	T1,ICRJFN	;CLOSE INPUT FILE
	CALL	DOCLSR		;  AND RELEASE JFN
	SETZM	ICRJFN		;RESET INFO
	SKIPE	AUXFLG		;IF NO AUX FILE
	TLNE	FL2,PCHGF	; AND NO CHANGES
	JRST	[PUSHJ P,OUTFIN	;PURGE OUTPUT BUFFERS
		 RLJFN		;RELEASE JFN
		   FJERR
		 SETZM OCRJFN	;SAY NONE
		 JRST END1A]
	SETZM	AUXFLG		;NO AUX FILE ANYMORE
	CALL	DELOUT		;DELETE OUTPUT FILE NOW
	HRROI	T1,OCRASZ
	HRROI	T2,ICRASZ
	MOVEI	T3,0
	SOUT			;REAL FILE NAME IN OCRBLK
END1A:	TRNE	FL,NEWFL	;OUTPUTTING TO NEW <DIR>FIL.EXT?
	JRST	END2		;YES, SEE IF OUTPUT FILE EXISTS
	SKIPN	CREATF		;NO BACKUP REQUIRED IF CREATING
	SKIPN	BAKF		;/BAK SET?
	JRST	END4		;NO, JUST RENAME AND EXIT
	MOVE	T2,ORGFIL	;INPUT FILE (IF PRESENT)
	MOVSI	T1,(GJ%OLD!GJ%SHT)
	PUSHJ	P,GTJFNX	;PEEK
	  JRST	END4		;GIVE UP
	MOVEM	T1,ORGJFN	;SAVE JFN
	MOVE	T2,T1		;COPY TO T2
	MOVE	T3,[2B2+2B5+1B8+1B35]
	HRROI	T1,LIBUF2	;PLACE TO BUILD NAME
	JFNS			;GET DEV:<DIR>NAME
	MOVE	T5,T1		;SAVE PNTR IN T5
	HRLI	T3,(1B11)	;BIT FOR EXTN
	JFNS			;GET IT
	EXCH	T1,T5		;SAVE PNTR GET OLD
	IBP	T1		;ADVANCE OVER .
	MOVEI	T2,"Q"		;ASSUME /BAK
	SKIPLE	BAKF		;UNLESS ITS /OLD
	MOVEI	T2,"Z"		;...
	IDPB	T2,T1		;CHANGE TO .QXX
	EXCH	T1,T5		;SAVE THIS AND RESTORE END PNTR
	MOVEI	T2,0		;GRNTEE NULL EVEN IF ALREADY THERE
	IBP	T1
	IDPB	T2,T1		;...
	SKIPG	BAKF		;IF /OLD THEN DO IT THE HARD WAY
	JRST	END1B		;EASY IF /BAK
	HRROI	T2,LIBUF2	;FILESPEC
	MOVSI	T1,(GJ%OLD!GJ%SHT)
	PUSHJ	P,GTJFNX	;SEE IF .ZXX EXISTS
	  JRST	END1B		;NO - GENERATE .ZXX
	RLJFN			;YES - RELEASE JFN
	  JFCL
	MOVE	T1,T5		;RESTORE BP
	MOVEI	T2,"Q"		;AND CHANGE EXT TO .QXX
	DPB	T2,T1		;...
END1B:	HRROI	T2,LIBUF2	;DESIRED FILESPEC
	MOVSI	T1,(GJ%FOU!GJ%SHT)
	PUSHJ	P,GTJFNX	;GET OUTPUT SPEC
	  FJERR			;CAN'T HAPPEN
	PUSH	P,T1		;SAVE IT TEMPORARILY
	HRLI	T1,.FBPRT(CF%NUD) ;WANT TO CHANGE PROTECTION
	MOVEI	T2,-1		;ONLY THE RIGHT HALF
	MOVE	T3,ORGPRT	;GET PROTECTION OF ORIGINAL FILE
	CHFDB			;SET PROTECTION OF THIS FILE TO IT
	  ERJMP	.+1		;IGNORE ERROR
	POP	P,T2		;RESTORE JFN
	MOVE	T1,ORGJFN	;OLD SPEC JFN
	RNAMF			;RENAME IT
	  JRST	[OUTSTR [ASCIZ "%Backup file protected - ignored."]
		 OCRLF
		 JRST END4]
	SETZM	ORGJFN		;(222)CLEAR JFN STORAGE
	MOVE	T1,T2		;COPY JFN
	RLJFN			;FLUSH IT
	  JFCL
	JRST	END4		;FINISH UP

END2:
	TLO	FL2,NORENT	;GRNTEE NO ^C
	TLZ	FL2,RENTF
	MOVSI	T1,(GJ%SHT!GJ%OLD!GJ%NS)
	MOVE	T2,NEWFIL	;NEW FILE NAME
	PUSHJ	P,GTJFNX	;TRY FOR IT
	 JRST	END4		;ASSUME NOT THERE
	RLJFN			;RELEASE JFN NOW
	  FJERR
	TLZ	FL2,NORENT	;ALLOW ^C
	OUTSTR	[ASCIZ /
Output file exists - delete? /]
	PUSHJ	P,CONFRM	;ASK HIM IF OK
	  JRST	ASKNAM		;HE SAID NO - ASK FOR NEW NAME
	TLO	FL2,NORENT	;OFF ^C
	TLZ	FL2,RENTF
	JRST	END4		;NOW TREAT IT AS NOT THERE
END4:	MOVSI	T1,(GJ%SHT!GJ%OLD!GJ%TMP)
	MOVE	T2,OCRFIL	;FILE WE WANT
	PUSHJ	P,GTJFNX	;TRY FOR IT
	  FJERR			;LOSAGE
	MOVEM	T1,OCRJFN	;SAVE JFN
	MOVSI	T1,(GJ%SHT)
	MOVE	T2,NEWFIL	;NEW FILE NAME
	PUSHJ	P,GTJFNX	;GET ONE
	  FJERR			;BETTER WIN
	MOVEM	T1,NEWJFN	;SAVE JFN
	HRLI	T1,.FBPRT(CF%NUD) ;GET INDEX OF PROTECTION WORD IN FDB
	MOVEI	T2,-1		;CHANGE ONLY RIGHT HALF
	MOVE	T3,ORGPRT	;GET PROTECTION OF ORIGINAL FILE
	TRNN	FL,NEWFL	;CREATING NEW VERSION?
	CHFDB			;YES, SET PROTECTION TO ORIGINAL
	  ERJMP	.+1		;IGNORE ERRORS
	SKIPE	UNSEQF		;SKIP IF NOT UNSEQUENCING
	JRST	UNSEQ		;GO UNSEQUENCE
	PUSHJ	P,ENDNAM	;PRINT FINAL NAME
	MOVE	T2,NEWJFN	;FOR RENAME
	MOVE	T1,OCRJFN	;GET JFN OF EXISTING FILE
	RNAMF			;RENAME IT
	  FJERR			;BETTER NOT
	SETZM	OCRJFN		;(222)CLEAR JFN STORAGE
	GTAD			;GET CURRENT DATE/TIME
	MOVEM	T1,LIBUF2	;TEMP STORAGE
	MOVEM	T1,LIBUF2+1	;CREATION/WRITTEN
	SETZM	LIBUF2+2	;NEVER READ
	MOVE	T1,T2		;COPY JFN TO T1
	MOVEI	T2,LIBUF2	;POINT TO BLOCK
	MOVEI	T3,3		;3 WORDS LONG
	SFTAD			;SET STUFF
	  ERJMP	.+1		;IGNORE IF FAILURE
	RLJFN			;FLUSH JFN
	  FJERR
	SETZM	NEWJFN		;(222)CLEAR JFN STORAGE
	JRST	ENDEND		;AND FINISH UP

ENDNAM:	OUTSTR	[ASCIZ "
["]
	OUTSTR	NEWASZ		;PRINT NEW FILE NAME
	OUTSTR	[ASCIZ "]
"]
	RET

;ROUTINE TO DELETE CURRENT OUTPUT FILE

DELOUT:	SKIPN	OCRJFN		;ANY OUTPUT FILE?
	RET			;NO, DO NOTHING THEN
	CALL	UNMAPO		;UNMAP XTRA PAGE
	MOVE	T1,OCRJFN	;OUTPUT JFN
	CALL	DOCLSF		;CLOSE IT FIRST

;(222)FOLLOWING 1 LINE REPLACED
;	PJRST	DDELFR		;DELETE, EXPUNGE & RELEASE JFN

	CALL 	DDELFR		;(222)DELETE, EXPUNGE & RELEASE JFN
	SETZM	OCRJFN		;(222)CLEAR JFN STORAGE
	RET

;ROUTINE TO RELEASE INPUT FILE

RLSINP:	MOVEI	T2,<IBUF0>B44	;DELETE PAGE
	CALL	UNMAP
	MOVE	T1,ICRJFN	;CURRENT INPUT JFN

;(222)REPLACE FOLLOWING 1 LINE OF CODE
;	PJRST	DOCLSR		;CLOSE & RELEASE

	CALL	DOCLSR		;(222)CLOSE & RELEASE
	SETZM	ICRJFN		;(222)CLEAR JFN STORAGE
	RET
ENDEND:
	PUSHJ	P,DELAUX	;TRY DELETING AUX FILE
	MOVNI	T1,1		;SAY DELETE PAGE
	MOVE	T2,[.FHSLF,,<BUF0>B44]
	MOVE	T3,NPAGS	;GET SIZE OF WINDOW
	TLO	T3,(PM%CNT)	;SET FLAG
	PMAP			;CLEAR EDIT WINDOW
	PUSHJ	P,CLSALL	;CLOSE OFF THE FILES
	TRNE	FL2,SVIT	;CHECK FOR SAVE COMMAND
	JRST	RESTRT		;YES - GO RESTART
	TLNE	FL,GCOM		;IS THIS A 'GO'?
	JRST	CREFIT		;YES - DO RUN UUO
MONRET:	MOVEI T1,.TICCC		;DISABLE ^C TRAPS
	DTI
	HALTF			;RETURN TO EXEC
	SKIPGE	CNCLOK		;SEE IF FROM M OPTION
	JRST	MONRET
	MOVE T1,[.TICCC,,TRPCHN] ;RE-ENABLE ^C
	SKIPL	NOCTLC		;(211) SKIP IF NO ^C SET
	ATI
	JRST	CNCCON		;OK - IF FROM ^C

;ROUTINE TO DELETE AUX FILE IF ANY

DELAUX:	HRROI	T1,[ASCIZ "EDIT-BUFFER.IN"]
	HRROI	T2,LIBUF	;BUILD SPEC HERE
	CALL	MAKTMP		;...
	MOVSI	T1,(GJ%OLD!GJ%SHT!GJ%TMP)
	HRROI	T2,LIBUF
	PUSHJ	P,GTJFNX	;THERE?
	 JRST 	CLAUX		;NO, BUT GO CLEAN-UP ANYWAY
	TLO	T1,(DF%EXP)	;SET TO EXPUNGE ALSO
	DELF			;BLAT
	  JFCL			;DONT CARE
CLAUX:	SETZM	AUXFLG		;SAY ITS GONE
	SETZM	ICRJFN		;(222)CLEAR JFN STORAGE
	RET			;RETURN

;HERE TO START WORLD OVER AFTER 'W'

RESTRT:	POP	P,UNSEQF	;NOW RESTORE ALL GOOD THINGS
	SETZM	RPGSW
	TDZ	FL,[TECOF,,BOF!EOF!EOF2!NEWFL]
	TLNN	FL2,FCHGF	;IFF THERE WERE CHANGES
	JRST	RSTRT1		;NO CHANGES
	MOVE	T1,[NEWBLK,,ORGBLK]
	BLT	T1,ORGBKE	;SET UP INPUT FILE NAME
	HRROI	T1,ORGASZ	;FORM PNTR
	MOVEM	T1,ORGFIL	;...
RSTRT1:	MOVE	T2,ORGFIL	;PNTR TO NAME
	MOVSI	T1,(GJ%OLD!GJ%SHT)
	PUSHJ	P,GTJFNX	;GET JFN OF INPUT
	  FJERR
	MOVEM	T1,ORGJFN	;SAVE
	PUSHJ	P,DEFNEW	;STEP TO NEXT GENERATION
	SETZM	CREATF		;NOT ANY MORE
	JRST	RPGRET		;AND START OVER


;ROUTINE TO CLOSE OFF ALL JFNS, EXCEPT POSSIBLY FOR THE INDIRECT
;FILE.

CLSALL:	TRNE	FL2,COMFLF	;READING FROM AN INDIRECT FILE?
	JRST	CLSAL2		;YES, HAVE TO WORK SOME
	SETO	T1,		;NOPE, CAN CLOSE ALL FILES
	CLOSF			;DO IT
	JFCL			;FORGET ERRORS

;(222)REPLACE FOLLOWING 1 LINE OF CODE
;	POPJ	P,		;RETURN

	JRST	CLSAL3		;(222)GO CLEAR JFN STORAGE FOR CLOSED FILES &RET

CLSAL2:	SKIPE	T1,ORGJFN	;GET JFN IF ANY
	CLOSF			;CLOSE IT
	JFCL
	SKIPE	T1,NEWJFN	;GET JFN IF THERE
	CLOSF			;CLOSE
	JFCL
	SKIPE	T1,ICRJFN
	CLOSF
	JFCL
	SKIPE	T1,OCRJFN
	CLOSF
	JFCL
	SKIPE	T1,ALTJFN	;LAST ONE (DON'T CLOSE INDJFN)
	CLOSF
	JFCL

CLSAL3:	SETZM	ORGJFN		;(222)CLEAR JFN STORAGE
	SETZM	NEWJFN		;(222)CLEAR JFN STORAGE
	SETZM	ICRJFN		;(222)CLEAR JFN STORAGE
	SETZM	OCRJFN		;(222)CLEAR JFN STORAGE
	SETZM	ALTJFN		;(222)CLEAR JFN STORAGE
	POPJ	P,		;RETURN
NSCAN:	TLNE	FL2,AUTOF	;SPECIAL IF AUTO MODE
	RETSKP			;SKIP IF AUTO MODE
NSCAN0:	PUSHJ	P,GNCH		;LOOK FOR ARGS
	CAIE	C,200		;IF ESC , RIGHT TO FILE
	CAIN	C,":"		;IS IT A COLON
	JRST	NSCAN2		;YES: GO LOOK FOR FILE NAME
	ANDI	C,137		;FORCE UPPER CASE
	MOVEI	T1,0		;INITIAL VALUE
	MOVE	T2,[POINT 7,[ASCIZ "BQUKNIJ"]]
NSCNA:	ILDB	T3,T2		;GET CHAR
	JUMPE	T3,NSCAN3	;NOT FOUND IF NULL
	CAIE	C,(T3)		;MATCH?
	AOJA	T1,NSCNA	;NO -- TRY NEXT
	XCT	ENDTBL(T1)	;IF SW SEEN - DO ROUTINE
	JRST	NSCAN0		;LOOK FOR MORE

NSCAN2:	SKIPE	CREATF		;(196) ARE YOU CREATING A FILE?
	JUMPA	NSCNA2		;(196) YES SO SKIP THIS RTN
	MOVEI	ALTP,NEWBLK	;(196) DATA FOR NEW OUTPUT SPEC
	MOVSI	T1,(GJ%FOU!GJ%MSG!GJ%CFM) ;WANT OUTPUT SPEC
	CALL	READNM		;GET NEW NAME
	  JRST	CKIND		;ERROR - MESSAGE PRINTED
;**;[247]	Change 1 line at NSCAN2:+6		DML	23-NOV-82
	  JRST	[ TLZ FL2,DOENDF	;[247] OUT OF END COMMAND CODE
		  OUTSTR [ASCIZ "Aborted..."]  ;[247] SAY ITS ABORTED
		  OCRLF			;[247] OUTPUT CRLF
		  POP P,		;[247] REMOVE UNWANTED ENTRY
		  TRZE FL2,SVIT		;[247] WAS THIS A B COMMAND?
		  POP P,UNSEQF		;[247] YES, RETRIEVE UNSEQF FROM STACK
		  JRST COMND]		;[247] ^U TYPED
	CALL	CKTERM		;GRNTEE EOL
	  RET			;ERROR RETURN
	TRO	FL,NEWFL	;SET NEW FILE
	MOVE	T1,NEWJFN	;JFN
	RLJFN			;DON'T WANT THIS
	  FJERR
	SETZM	NEWJFN		;...
NSCNA2:	RETSKP			;(196) SKIP RETURN
NSCAN3:	MOVEM	C,SAVC		;BACK UP SCANNER
	PUSHJ	P,SCAN
	TRNE	FL,TERMF	;CHECK FOR TERM
	AOS	(P)		;PROPER - GIVE SKIP RETURN
	POPJ	P,		;NO TERM - LOSE
ENDTBL:	SETZM	BAKF		;'B'
	JRST	QUIT		;'Q'
	SETOM	UNSEQF		;'U'
	HRRZM	P,UNSEQF	;'K' - SET FLAG POSITIVE
	SETZM	BAKF		;'N'
	CALL	EIDENT		;'I'
	CALL	EJDENT		;'J'

ASKNAM:	SETZM	SAVCHR		;RESET SCAN
	CALL	CLRBFI
	SETZM	TTIPNT		;CLEAR INPUT
	MOVEI	C,200		;MAKE READNM ALLOW RECOGNITION
	MOVEI	ALTP,NEWBLK	;WHERE TO PUT INFO
	MOVSI	T1,(GJ%FOU!GJ%MSG!GJ%CFM)
	CALL	READNM		;GET NAME
	  JRST	ASKNAM		;ERROR - TRY AGAIN
	  JRST	ASKNAM		;^U - TRY AGAIN
	TRO	FL,NEWFL	;NEW FILENAME
	MOVE	T1,NEWJFN	;JFN
	RLJFN			;FLUSH IT
	  FJERR
	SETZM	NEWJFN		;(222)CLEAR JFN STORAGE
	JRST	END2		;TRY AGAIN

;CODE FOR 'EQ' COMMAND. JUST DELETE TEMPS AND EXIT

QUIT:	POP	P,0(P)		;PRUNE PDL
	PUSHJ	P,SCAN		;MAKE SURE NO ARGS
	TRNN	FL,TERMF
	NERROR	ILC
	SKIPE	ICRJFN		;IF INPUT JFN
	CALL	RLSINP		;FLUSH INPUT FILE
	TRNN	FL,READOF	;DONT BOTHER IF R/O
	CALL	DELOUT		;DELETE OUTPUT FILE
	TRNN	FL2,SVIT	;CHECK FOR WQ
	JRST	ENDEND		;NO - JUST EXIT
	MOVE	T1,[ORGBLK,,NEWBLK]
	BLT	T1,NEWBKE	;FAKE OUT WORLD
	HRROI	T1,NEWASZ	;SET PNTRS
	MOVEM	T1,NEWFIL	;...
	JRST	ENDEND
;HERE TO DO UNSEQUENCING

UNSEQ:	MOVE	T1,[OCRBLK,,ICRBLK]
	BLT	T1,ICRBKE	;SETUP CURRENT INPUT
	MOVE	T1,ICRJFN	;GET JFN
	MOVEM	T1,CIPJFN	;SET UP CIP BLOCK
	MOVE	T2,[7B5+OF%RD]
	OPENF			;OPEN FILE
	  FJERR			;FATAL
	SETZM	CIPBYT		;CLEAR INPUT
	MOVEI	T1,IBUF0	;GRNTEE BUFFER
	MOVEM	T1,CIPBUF	;...
	MOVE	T1,NEWJFN	;OUTPUT JFN
	MOVE	T2,[7B5+OF%WR]
	MOVEM	T1,OPNJFN	;SAVE FOR ERROR
	OPENF			;OPEN FOR WRITE
	  CALL	OPNERR		;MAY BE DISK FULL
	CALL	UNSQO1		;SET UP COUNTS,PNTR ETC
	AOS	OPCNT		;ACCOUNT FOR XTRA SOSG
IFN CRYPSW,<
	MOVE	T1,NEWCOD	;GET CORRECT PSWS
	EXCH	T1,OCRCOD
	MOVEM	T1,ICRCOD	;...
>
	TDZ	FL,[COPFIL,,EOF];CLR FLAGS

UNSEQL:	CALL	GCHAR		;FETCH CHARACTER
	JUMPE	T3,UNSEQD	;DONE IF ZERO RETURNED
	SKIPLE	UNSEQF		;DOING EK INSTEAD OF EU?
	CAIE	T3,14		;AND CHAR IS A FORMFEED?
	JRST	.+2		;NO, NOTHING SPECIAL
	JRST	UNSEQL		;YES, EAT THE FORMFEED
	SOSG	OPCNT		;DECREMENT
	CALL	UNSEQO		;DUMP BUFFER
	IDPB	T3,OUPNT	;DEPOSIT CHAR
	JRST	UNSEQL		;LOOP UNTIL DONE

UNSEQD:	MOVE	T1,ICRJFN	;SET TO DELETE INPUT
	CALL	DOCLSF		;CLOSE FILE & RETAIN JFN
	CALL	DDELFR		;DELETE FILE & JFN
	SETZM	AUXFLG		;(222)CLEAR AUXFLG
	SETZM	ICRJFN		;(222)CLEAR JFN STORAGE
UNSQDR:	MOVE	T1,NEWJFN	;GET JFN
	HRROI	T2,OBUF0	;POINT TO BUFFER
	MOVNI	T3,1000*5+1	;- SIZE - 1
	ADD	T3,OPCNT	;CHRS LEFT +1
	JUMPGE	T3,UNSQD1	;SKIP OUTPUT IF EMPTY
	SOUT			;DUMP PARTIAL
	  CAI	UNSQDR		;RE-TRY ADDRS
UNSQD1:	CALL	DOCLSR		;CLOSE OUTPUT FILE
	SETZM	NEWJFN		;(222)CLEAR JFN STORAGE
	CALL	UNMAPO		;RELESE PAGE
	CALL	ENDNAM		;PRINT FINAL NAME
	JRST	ENDEND
;ROUTINE TO DUMP OUTPUT BUFFER USING SOUT

UNSEQO:	PUSH	P,T3		;SAVE RET
UNSQOR:	MOVE	T1,NEWJFN	;JFN
	HRROI	T2,OBUF0	;WHERE ITS AT
	MOVNI	T3,1000*5	;1 PAGE OF CHARS
	SOUT			;SLURPP!
	  CAI	UNSQOR		;RETRY ADDRS
	POP	P,T3		;RESTORE
UNSQO1:	MOVEI	T1,1000*5	;SHOW EMPTY BUFFER
	MOVEM	T1,OPCNT	;...
	MOVE	T1,[POINT 7,OBUF0]
	MOVEM	T1,OUPNT
	RET			;RETURN
; 'EJ' - LIKE EI BUT DOES D^/^ FIRST

EJDENT:	MOVEI	T1,1		;TRY TO FIND FIRST LINE OF FILE
	MOVEM	T1,DPG
	MOVE	SINDEX,[<ASCII /00000/>!1]
	CALL	FIND		;...
	SKIPE	T1		;IF EOF
	CAMN	T1,PGMK		; OR PAGE-MARK
	JRST	EIDENT		;  THEN OK TO INSERT
	CALL	DODEL		;ELSE DELETE THE LINE
	SETZM	DELCNT		;SO NO MSG
;	JRST	EIDENT		;GO INSERT THE LINE

; 'EI' - Writes an identifying line at the top of the file
;	 before exiting.

EIDENT:	PUSHJ	P,GETIDN	;Write the line in LIBUF
	MOVEI	T1,1		;We want the first page
	MOVEM	T1,DPG		;To contain the line
	MOVE	SINDEX,[<ASCII /00000/>!1]
	PUSHJ	P,FIND		;See what line is first
	CAMN	T1,[<ASCII /00000/>!1] ;DOES 0 ALREADY EXIST
	NERROR	NORM		;Sorry, no room
	CAIN	T1,0		;Did we find EOF?
	 JRST [ RERROR	EMTY
		JRST EIDEN0]
	CAIE	T1,PGMK		;Is Page 1 empty?
	JRST	EIDEN1		;No
EIDEN0:	MOVE	T3,[<ASCII /00100/>!1] ;Yes, use 100
	JRST	EIDEN2		;And skip the bit twiddling
EIDEN1:	MOVE	T3,T1		;Move line number to T3
	PUSHJ	P,NUMCON	;Convert line number to int.
	CAILE	T1,^D100	;Is it .gt. 100 ?
	MOVEI	T1,^D101	;Yes, let's use 100 instead
	SUBI	T1,1		;Subtract one
	PUSHJ	P,ASCON		;Convert to line number
EIDEN2:	MOVEM	T3,LIBUF	;And put it first in the line
	PUSH	P,PNTR		;SAVE PNTR
	MOVEI	PNTR,LIBUF	;POINT TO BUFFER
	PUSHJ	P,GETLTH	;GET LENGTH OF LINE
	POP	P,PNTR		;RESTORE PNTR
	MOVEM	T1,NCNT		;Here is the new count
	SETZM	OCNT		;Set the old count to 0
	PUSHJ	P,INSED		;Go insert into buffer
	POPJ	P,		;Return to caller

; GETIDN - Subroutine to put the line in LIBUF

GETIDN:	CALL	ZBUF		;ZERO LIBUF AND RETURN BP IN T1
	MOVEI	C,11		;INSERT TAB
	IDPB	C,T1		;...
	MOVEI	C,";"		;First chr. is ;
	IDPB	C,T1		;Put it there
	PUSH	P,T1		;Save the pointer
	MOVSI	T1,(GJ%FOU!GJ%SHT) ;Get a JFN on output file
	MOVE	T2,NEWFIL	;NEW FILESPEC
	PUSHJ	P,GTJFNX	;GET A JFN FOR JFNS
	 JRST [ POP P,T1
		HRROI T2,[ASCIZ /?Unknown name?/]
		SETZ T3,
		SOUT
		OUTSTR [ASCIZ "%FILE NAME NOT AVAILABLE"]
		OCRLF
		JRST GETID5]
	MOVE	T2,T1		;Get the JFN
	POP	P,T1		;Retrieve the pointer
	PUSH	P,T2		;But, save the JFN
	MOVE	T3,[2B2+1B5+1B8+1B11+1B14+1B35] ; Print it right
	JFNS			;Send it to LIBUF2
	MOVE	T2,T1		;Save the pointer in T2
	POP	P,T1		;Retrieve the JFN
	RLJFN			;Release the JFN
	  FJERR
	MOVE	T1,T2		;Get the pointer
GETID5:	HRROI	T2,[ASCIZ /, /]
	SETZ	T3,
	SOUT
	SETO	T2,
	SETZ	T3,
	ODTIM			;Output the date and time
	HRROI	T2,[ASCIZ /, Edit by /]
	SETZ	T3,
	SOUT			;And the next phrase
	PUSH	P,T1
	GJINF			;Get logged-in directory no.
	MOVE	T2,T1		;Put in T2 for DIRST
	POP	P,T1
	DIRST			;Write user name
	 JRST [ HRROI T2,[ASCIZ /Unknown user/]
	        SETZ T3,
		SOUT
		JRST .+1]
	HRROI	T2,[ASCIZ /
/]
	SETZ	T3,
	SOUT			;Finish with <CR><LF>
	RET

SUBTTL SOME GENERAL PURPOSE STUFF
;SOME MORE GENERAL ROUTINES


RDLIN:	CALL	ZBUF		;CLEAR LIBUF AND RETURN T1
	MOVEI	T2,5*MXWPL-2	;SET FOR AVAILABLE SPACE
	MOVEI	C,11		;START WITH A TAB
	JRST	RDL3
RDL1:	PUSHJ	P,GNCH		;GET ANOTHER CHARACTER
	CAIN	C,15		;IGNORE RETURN
	JRST	RDL1
	CAIN	C,14		;FF - TREAT AS SPECIAL
	JRST	[OCRLF		;GIVE CRLF
		 CAIN T2,5*MXWPL-3
		 IDPB C,T1	;SAVE IT IF EMPTY LINE
		 JRST RDL2]
	CAIN	C,12		;LINE FEED IS THE ONLY PROPER END
	JRST	RDL2
	CAIE	C,200		;ALTMODE IS A SPECIAL CASE
	JRST	RDL3		;NOT ALTMODE
	SETOM	ALTSN		;FLAG ALTMODE SEEN FOR I AND R
	CAIE	T2,5*MXWPL-3
	JRST	RDL2		;DO END OF LINE STUFF
	POPJ	P,		;EMPTY LINE RETURN

RDL3:	IDPB	C,T1		;PUT IT IN THE BUFFER
	SOJGE	T2,RDL1		;CHECK FOR OVERFLOW AND CONTINUE
	RERROR	LTL		;LINE IS TOO LONG
	POPJ	P,		;NON-SKIP RETURN

RDL2:	MOVEI	C,15		;PUT IN A CR-LF
	IDPB	C,T1
	MOVEI	C,12
	IDPB	C,T1
	HRRZS	T1		;NOW GET THE SIZE
	SUBI	T1,LIBUF-1
	AOS	(P)		;SKIP RETURN IF OK
	POPJ	P,		;AND RETURN

;ROUTINE TO CLEAR LIBUF AND RETURN BP IN T1

ZBUF:	SETZM	LIBUF+1		;FIRST WORD TO CLEAR
	MOVE	T1,[LIBUF+1,,LIBUF+2]
	BLT	T1,LIBUF+MXWPL+1 ;ZOT
	MOVE	T1,[POINT 7,LIBUF+1]
	POPJ	P,		;RETURN
;ROUTINE TO RETURN LENGTH OF LINE IN T1

GETLTH:	MOVE	T1,PNTR		;GET THE LENGTH OF THE LINE POINTED AT
	ADDI	T1,1
GETLN1:	SKIPN	T2,(T1)		;ANY END IS GOOD ENOUGH
	JRST	GETLN2
	TRNN	T2,1		;SEQ-NUM?
	AOJA	T1,GETLN1
GETLN2:	SUB	T1,PNTR		;FIND LENGTH
	POPJ	P,		;AND RETURN

;OUTPUT SEQUENCE NUMBER-TAB HACK

OUTSN:	MOVEM	T1,SQBUF	;PUT IT IN SPACE FOLLOWED BY A TAB
	OUTSTR	SQBUF
	POPJ	P,
ASCIAD:	AND	T2,K2A		;CONVERT TO NUMBERS
	IOR	T1,K4A		;MAKE SURE THIS IS IN DIGIT FORM
	ADD	T1,K1A		;GET EACH DIGIT IN RANGE 166 TO 177 FOR CARRY
	ADD	T2,T1		;SUM
	AND	T2,K3A		;GET RID OF 100 BITS IF THERE
	MOVE	T1,K4A		;FIND OUT WHICH ONES NEED SUBTRACTING
	AND	T1,T2
	ASH	T1,-3		;CONVIENIENTLY THEY NEED 6 SUBTRACTED
	SUBM	T2,T1		;SO DO IT
	IOR	T1,K4A		;AND RECONVERT TO DIGITS
	POPJ	P,		;WE HAVE ADDED THE ASCII IN T1 AND T2 RESULT IN T1

K1A:	BYTE (7) 106,106,106,106,106
K2A:	BYTE (7) 17,17,17,17,17
K3A:	BYTE (7) 77,77,77,77,77
K4A:	<ASCII /00000/>!1
K5A:	BYTE (7) 7,7,7,7,7
K6A:	BYTE (1) 1 (7) 77,77,77,77,77
K7A:	BYTE (1) 0 (7) 106,106,106,106,106

ASCAV:	AND	T2,K2A
	IOR	T1,K4A		;THIS ROUTINE AVERAGES 2 ASCII NUMERS
	LSH	T1,-1
	ADD	T1,K7A		;IT WORKS MOSTLY BY MAJIC
	LSH	T2,-1
	ADD	T2,T1
	AND	T2,K6A
	MOVE	T1,T2
	ANDCM	T1,K3A
	AND	T2,K3A
	MOVE	T3,T2
	LSH	T3,-3
	AND	T3,K2A
	AND	T2,K5A
	SUB	T2,T3
	LSH	T1,-4
	ADD	T2,T1
	LSH	T1,-2
	ADD	T2,T1
	IOR	T2,K4A
	POPJ	P,
;CHECK TO SEE IF BUFFER TOO FULL AND DUMP IF NEEDED

FILLB:	MOVE T1,WC	;GET WORD COUNT
FILLB3:	CAMGE T1,MAXWC	;AND COMPARE WITH MAX PERMISSIBLE
	POPJ P,		;OK, SO RETURN
	MOVE T1,BUFP	;GET BUFFER POINTER
	ADDI T1,1
FILLB1:	SKIPN T2,(T1)	;FIND END OF FIRST LINE
	JRST FILLB2
	TRNN T2,1
	AOJA T1,FILLB1
FILLB2:	PUSHJ P,NOWFL	;PART OF GETN WILL DUMP AND ADJUST POINTERS
	JRST FILLB	;SEE IF IN LIMITS NOW



;INSERT A LINE (IN LIBUF) INTO PLACE POINTED AT BY PNTR
;WORD COUNT OF OLD LINE IN OCNT. OF NEW LINE IN NCNT

INSED:	TLO	FL2,ALLCHG	;CHANGES
	MOVE T1,NCNT	;SEE HOW THE COUNTS DIFFER
	SUB T1,OCNT
	JUMPE T1,NOBLT	;THEY ARE SAME, NO MOVING NECESSARY
	JUMPG T1,BBLT	;NEW IS LARGER, BLT WILL NOT DO
	MOVE T2,PNTR	;SET UP BLT POINTER FROM PNTR+OCNT
	ADD T2,OCNT
	HRLS T2
	HRR T2,PNTR	;TO PNTR+NCNT
	ADD T2,NCNT
	ADDB T1,WC	;ADJUST WC TO OLD WORD COUNT +NCNT-OCNT
	ADD T1,BUFP	;LAST TRANSFERED IS BUFP+WC+NCNT-OCNT
	BLT T2,(T1)
NOBLT:	SKIPN T1,NCNT	;CHECK FOR 0 NEW COUNT (WE ARE DELETING)
	POPJ P,		;IF SO DONE
	MOVE T2,PNTR	;GET THE POINTER POSITION FOR BLT
	HRLI T2,LIBUF	;FROM LIBUF TO PNTR
	ADD T1,PNTR	;STOP AT PNTR+NCNT-1
	BLT T2,-1(T1)
	POPJ P,		;AND ALL DONE
BBLT:	MOVE T2,BUFP	;FAKE BACKWARDS BLT FROM BUFP+WC
	ADD T2,WC
	ADDB T1,WC	;TO BUFP+WC+NCNT-OCNT (ALSO FIX WC)
	ADD T1,BUFP
BBLT1:	CAMGE T2,PNTR	;STOP HERE (COULD STOP SOONER BUT THIS IS EASIER)
	JRST NOBLT	;AND GO MOVE IN NEW STUF
	MOVE T3,(T2)	;TRANSFER A WORD
	MOVEM T3,(T1)
	SUBI T1,1
	SOJA T2,BBLT1	;AND KEEP IT UP

;SUBROUTINE TO DO A GTJFN.  THIS CODE HANDLES THE PROBLEMS OF MULTIPLE
;FILE SPECS IN A LOGICAL NAME WHICH CAUSE PROBLEMS AS FOLLOWS:
;@DEFINE DSK: DSK:, PS:<RANDOM>
;@EDIT FOO.BAR
;WHERE FOO.BAR DOESN'T EXIST, AND THE DIRECTORY <RANDOM> IS PROTECTED.
;CURE: FIRST TRY THE GTJFN AS SPECIFIED, IF THAT FAILS THEN TRY IT AGAIN
;USING ONLY THE FIRST LOGICAL NAME DEFINITION.


GTJFNX:	TLNN	T1,(GJ%NEW+GJ%NS+GJ%OFG)	;SPECIAL CASES?
;**;[247]	Change 1 line at GTJFNX:+1		DML	23-NOV-82
	TLNE	FL2,EXCPFL!DOENDF	;[247] OR IS THIS A COPY OR AN END?
	JRST	GTJFNZ		;YES, NO NEED TO TRY TWICE
	HLLOS	CJFNBK		;(206) SET FOR GENERATION
	DMOVEM	T1,TEMPS	;SAVE THE AC'S
	GTJFN			;TRY THE GTJFN AS SPECIFIED
	SKIPA			;FAILED, GO ANALYSE ERROR
	RETSKP			;IT WORKED, SKIP RETURN
	CAIN	T1,GJFX24	;FILE NOT FOUND ERROR?
	RET			;YES, RETURN NOW
	CAIN	T1,GJFX23	;(221) IS IT "DIRECTORY FULL" ?
	JRST	[MOVEI T1,.FHSLF ;(221)SET UP TO CREATE AN INTERRUPT
		 MOVEI T2,1B20	;(221)ON CHANNEL 20
		 IIC		;(221)TO DSKFUL CODE
		 HRROI T1,[ASCIZ " (FILE) "] ;(221)MIGHT HAVE TO PROMPT USER
		 MOVE T2,TEMPS+1 ;(221)FIND OUT IF WE DO - GET SOURCE WORD
		 TLNE T2,-1	;(221)JFN OR POINTER?
		 PSOUT		;(221)NOT POINTER - MUST ASK FOR FILENAME. PROMPT...
		 DMOVE T1,TEMPS	;(221)GET AC'S BACK
		 JRST GTJFNX]	;(221)AND TRY AGAIN
	DMOVE	T1,TEMPS	;NO, RESTORE ORIGINAL AC'S
	TLO	T1,(GJ%NS)	;SET TO ONLY LOOK AT FIRST LOGICAL SPEC

GTJFNZ:	GTJFN			;TRY THE GTJFN AGAIN
	RET			;FAILED
	RETSKP			;SUCCEEDED

SUBTTL INSERT ROUTINE
;INSERT A LINE

CRTINS:	OCRLF
	MOVEI	T1,1		;SET TO START INSERTING AT LINE 100 PAGE 1
	MOVEM	T1,HIPG
	SKIPN	T1,TECFST	;USE START IF GIVEN
	MOVE	T1,[<ASCII /00100/>!1]
	MOVEM	T1,HILN
	JRST	INSGO		;AND AWAY WE GO

INSERT:	TRNE	FL,READOF	;ERROR IF READ-ONLY
	NERROR	ILC
	PUSHJ	P,SCAN
	TRNE	FL,TERMF	;CHECK FOR NO ARGUMENTS
	JRST	[MOVE  T1,IPG
		 MOVEM T1,HIPG
		 MOVE  T1,CURINS
		 MOVEM T1,HILN
		 SKIPG ISVINC
		 JRST  INSGO
		 MOVE  T1,ISVINC
		 EXCH  T1,INCR
		 MOVEM T1,TEMINC
		 JRST  INSGO]	;IF NONE, GO BACK INSERTING 
				; WHERE YOU WERE
	SETOM	ISVINC		;SET FLAG SO CANNOT USE ISVINC
	TRO	FL2,UPTOPF	;^ =NEW LINE AT TOP OF PAGE
	PUSHJ	P,GET1		;GET ONE LINE/PAGE NUMBER
	TRZ	FL2,UPTOPF	;^ =EXISTING LINE AT TOP OF PAGE
	TRNN	FL,LINSN	;WAS /N GIVEN
	JRST	INSMK		;YES: TREAT SPECIAL
	PUSHJ	P,INSINC	;GET INCR IF ANY
INSGO:	PUSHJ	P,DOINS		;DO THE INSERTS
	JRST	COMND		;RETURN

INSINC:	CAIE	C,","		;GIVING AN INCREMENT WITH COMMA?
	CAIN	C,";"		;OR SEMICOLON (AS BEFORE EDIT 136)?
	SKIPA	T1,INCR		;YES
				;NO, CHECK FOR !<# OF LINES>
	JRST	[CAIN C,"!"
		 JRST ININC1
		 JRST NOINC]	;IF NO ; , OR !, USE DEFAULT
	PUSHJ	P,GNCH		;ALLOW OLD FORMAT I<POS>;!<#>
	CAIE	C,"!"		;IS NEXT CHR. A !
				;NO, BACK UP SCANNER
	JRST	[MOVEM C,SAVC
		 JRST  GETINC]
ININC1:	MOVE	T1,INCR		;SAVE CURRENT INREMENT
	SETOM	INCR		;YES, HE'S SAID # OF LINES TO INSERT

GETINC:	MOVEM	T1,TEMINC	;SAVE THE CURRENT INCREMENT
	PUSHJ	P,SCAN		;GET THE NUMBER
	TRNE	FL,NUMF		;IS IT REALLY A NUMBER?
	CAMN	T1,[<ASCII /00000/>!1]  ;AND NOT EQUAL TO 0?
	NERROR	ILC		;NO, HE IS CONFUSED
	MOVEM	T2,NLIN1	;YES, SAVE AS DECIMAL NUMBER
	SKIPGE	INCR		;MUST WE COMPUTE AN INCREMENT?
	JRST	GTINC1		;YES, DON'T SET INCREMENT YET
	MOVEM	T1,INCR		;NO, SET THE INCREMENT
	MOVEM	T1,ISVINC	; AND SAVE FOR USE WITH I<CR>
GTINC1:	PUSHJ	P,SCAN		;LOOK FOR TERMINATOR
NOINC:	TRNN	FL,TERMF	;FOUND ONE?
	NERROR	ILC		;NO, ILLEGAL COMMAND
	SETZM	ALTSN		;YES, CLEAR ALTMODE FLAG
	POPJ	P,		;RETURN

DOINS:	MOVE	T1,HIPG		;GET THE PAGE TO GO TO
	MOVEM	T1,DPG		;AND SET IT UP
	MOVE	SINDEX,HILN	;ALSO LINE
	PUSHJ	P,FIND		;GO GET UM
	MOVE	T2,CPG		;DEMAND CORRECT PAGE MATCH
	CAME	T2,HIPG
	NERROR	NSP
	SKIPL	INCR		;NEED TO COMPUTE ONE?
	JRST	INSTRY		;NO -- JUST TRY TO INSERT
	MOVE	T2,HILN		;YES -- SET UP FOR CALL
	MOVE	T3,NLIN1
	PUSHJ	P,GETDIF	;GET BEST FIT
	  NERROR ILR		;WHOOPS
	MOVEM	T1,HILN		;USE THESE VALUES
	MOVEM	T2,INCR		;SAVE THE INCREMENT FOR NOW
	MOVEM	T2,ISVINC	;AND FOR USE WITH LATER I<CR>
	JRST	INSLP
INSTRY:	CAME	T1,HILN		;DO THEY MATCH?
	JRST	INSLP		; YES - GO AHEAD
	MOVE	T2,INCR		; NO - GO INVENT A NEW LINE
	PUSHJ	P,FIXLIN
	  EXP	HILN
	 NERROR	ILR		;NO ROOM
	MOVEM	T2,HILN		;STORE NEW NUMBER
INSLP:	SETZM	OCNT
	SKIPE	ALTSN		;ALTMODE SEEN?
	JRST	LVINS		;YES: DONE
	MOVE	T1,HILN		;TELL HIM THE LINE HE IS INSERTING
	MOVEM	T1,LIBUF	;AND PUT IT IN THE BUFFER
	SETZM	CRBUF		;INCASE NONUMBER
	TRNN	FL2,COMFLF!NONUMF	;IGNORE SQ # IF IN CMD FILE
	CALL	[MOVEM T1,CRBUF	;PUT IT IN ^R BUFFER
		 MOVSI T2,(11B6)
		 MOVEM T2,CRBUF+1
		 PJRST OUTSN]	;DUMP SEQ # AND RETURN
	PUSHJ	P,RDLIN		;READ A LINE
	JRST	LVINS		;YES, GET OUT OF INSERT MODE
	MOVEM	T1,NCNT		;HERE IS THE COUNT OF THE NEW ONE
	PUSHJ	P,INSED		;GO INSERT
	SOSN	ISAVEN		;TIME TO SAVE?
	PUSHJ	P,ASVINS	;YES: GO DO IT
	PUSHJ	P,FINDN		;MOVE UP A LINE
	PUSHJ	P,FILLB		;AND DUMP SOME IF NECESSARY
	MOVE	T1,CPG		;SET CURRENT LINE AND PAGE TO LAST
	MOVEM	T1,CPGL		;ONE REALLY INSERTED
	MOVEM	T1,IPG		;(199) UPDATE PAGE COUNTER
	MOVE	T1,HILN
	MOVEM	T1,CLN
	MOVEM	T1,CURINS	;(199) UPDATE INSERT COUNTER
	MOVE	T2,INCR		;GET NEXT LINE TO INSERT
	PUSHJ	P,ASCIAD
	CAMG	T1,INCR		;HAVE WE WRAPED AROUND
	JRST	LVINS1		;YES -- STOP
	MOVEM	T1,HILN		;STORE FOR REFERENCE
	SKIPN	T1,(PNTR)	;GET THE LINE POINTED TO
	JRST	INSLP		;ALWAYS INSERT AT END OF FILE
	CAME	T1,PGMK		;OR AT END OF PAGE
	CAMLE	T1,HILN		;HAVE WE FOUND A MATCH OR PASSED OVER A LINE?
	JRST	INSLP		;NO, INSERT
	JRST	LVINS1		;RETURN TO COMMAND LEVEL

LVINS:	MOVE	T1,HILN
	MOVEM	T1,CURINS	;SET PLACE TO INSERT NEXT TIME
	MOVE	T1,CPG
	MOVEM	T1,IPG
	TRNE	FL2,COMFLF	;CMD FILE?
	JRST	LVINS2		;YES SKIP CR
LVINS1:	SKIPE	ALTSN		;ALT SEEN?
	OCRLF			;YES -- OUTPUT CRLF
LVINS2:	SETZM	ALTSN		;CLEAR ALTMODE FLAG
	POPJ	P,		;RETURN
;ROUTINE TO COMPUTE INCREMENT AS DIFFERENCE OF
; TWO LINES / # OF LINES TO INSERT
;CALL:
;	MOVE	T1,<RESULT OF FIND>
;	MOVE	T2,<LINE TYPED(DESIRED)>
;	MOVE	T3,<# OF LINES TO INSERT>
;	PUSHJ	P,GETDIF
;	  <ERROR RETURN (IE NO ROOM)>
;	<OK RETURN>
;	  C(T2) := COMPUTED INCR
;	  C(T1) := WHERE TO START INSERTING

GETDIF:	PUSH	P,T3		;SAVE ARGS
	PUSH	P,T2
	PUSH	P,T1		;SAVE RESULT OF FIND
	CAMN	T1,T2		;ALREADY HAVE NEXT IF NOT EQUAL
	PUSHJ	P,FINDN		;LOOK FOR NEXT LINE
NOFND:	SKIPE	T3,T1		;NONE IF EOF
	CAMN	T1,PGMK		;  OR PAGE MARK
	SKIPA	T1,[^D100000]	;USE HIGHEST + 1
	PUSHJ	P,NUMCON	;NEXT LINE # IN T1
NONXT:	PUSH	P,T1		;SAVE IT
	MOVE	T3,-2(P)	;GET WHAT WAS TYPED
	CAMN	T3,-1(P)	;DOES IT EXIST?
	SOS	0(P)		;YES - ALLOW FOR IT
	PUSHJ	P,NUMCON	;CONVERT ARG
	MOVE	T2,T1		;MOVE RESULT TO T2
	POP	P,T1		;RESTORE <NEXT>
	SUB	T1,T2		;GET DIFFERENCE
	IDIV	T1,-2(P)	;(<NEXT>-<CURR>)/N
	JUMPE	T1,GOTZER	;DON'T FIT IF ZERO
	CAIGE	T1,3		;IF 1 OR 2 ITS THE BEST
	JRST	GOTIT
	MOVE	T2,[-6,,[DEC 2,5,10,20,50,100,100001]]
	CAML	T1,1(T2)	;LOOK FOR ITEM .GT. T1
	AOBJN	T2,.-1
	JUMPGE	T2,GOTZER	;CAN'T HAPPEN
	MOVE	T1,0(T2)	;GET AESTHETIC INCR
GOTIT:	PUSHJ	P,ASCON		;CONVERT TO INCR FORM
	MOVE	T2,T3		;GET INTO CORRECT AC
	POP	P,T1		;GET BACK ARG
	MOVEM	T2,-1(P)	;STORE COMPUTED INCR
	CAME	T1,0(P)		;FIGURE OUT START POINT
	JRST	GETRET		;OK IF NOT FOUND
	PUSHJ	P,ASCIAD	;ELSE ADD INCR TO IT
	MOVEM	T1,0(P)		;  AND USE IT
GETRET:	POP	P,T1		;STARTING LINE #
	POP	P,T2		;INCR
	JRST	CPOPJ1		;GIVE GOOD RETURN

GOTZER:	SUB	P,[3,,3]	;PRUNE PDL
	POPJ	P,		;ERROR RETURN

;USE THIS ENTRY IF THERE IS NO NEXT LINE KNOWN

GETDF1:	PUSH	P,T3		;SAVE ARGS
	PUSH	P,T2
	PUSH	P,T1
	MOVEI	T1,^D100000	;USE LARGEST + 1
	JRST	NONXT		;ENTER GETDIF
;ROUTINE TO GUESS AT A GOOD PLACE TO INSERT IF CURRENT LINE EXISTS
;CALL:
;	MOVE	T1,<CURRENT POSITION>
;	MOVE	T2,<INCREMENT TO USE>
;	PUSHJ	P,FIXLIN
;	<LOC OF HIGH BOUND>
;	  <ERROR RETURN>
;	<OK RETURN>		;NEW NUMBER IN T2

FIXLIN:	AOS	T4,0(P)		;SKIP OVER ARG
	PUSHJ	P,ASCIAD	;ADD
	PUSH	P,T1		;SAVE RESULT
	PUSHJ	P,FINDN		;GET THE NEXT ONE
	POP	P,T2
	CAMG	T2,@-1(T4)	;IS THERE A WAR PROBLEM
	JRST	FIXBAD		;YES, WE MUST TRY TO COMPUTE ONE
	JUMPE	T1,CPOPJ1	;END OF FILE, ANY INC IS OK
	CAME	T1,PGMK		;ALSO OK IF A PAGE MARK
	CAMGE	T2,T1		;OR IN CORRECT ORDER
	JRST	CPOPJ1
FIXBAD:	CAME	T1,PGMK
	SKIPN	T1
	MOVE	T1,[<ASCII /9999:/>!1]	;ONE OVER THE TOP OF THE WORLD
	MOVE	T2,@-1(T4)	;GET CURRENT
	PUSHJ	P,ASCAV		;FIND AVERAGE
	CAME	T2,@-1(T4)	;THERE MAY HAVE ONLY BEEN A DIF OF 1
	AOS	0(P)		;SKIP RETURN
	POPJ	P,

SUBTTL DELETE ROUTINE
;DELETE A LINE, A NUMBER OF LINES, OR A PAGE MARK

DELETE:	SETZM	LOLN		;JUST AS A START
	SETZM	PGDELS		;NO PAGES DELETED
	TRNE	FL,READOF	;NOT PERMITTED IN READ ONLY
	NERROR	ILC
	PUSHJ	P,GET2S		;GET TWO PAGE-LINE PAIRS
	TRZ	FL,LINSN	;FOR NOW
	CAIE	C,","	;CHECK SWITCH
	JRST	DELT1
	PUSHJ	P,SCAN
	MOVS	T1,ACCUM
	TRNE	FL,IDF
	CAIE	T1,(<SIXBIT /Y  />)
	NERROR	ILC
	TRO	FL,LINSN	;DON'T ASK
	PUSHJ	P,SCAN
DELT1:	TRNN	FL,TERMF	;CHECK FOR TERMINATOR
	NERROR	ILC
	PUSHJ	P,DELSUB	;DO SOME DELETING
	SKIPN	PGDELS		;NEED TO DO ORDER CHECK
	JRST	COMND		;NO - ALL OK
	JRST	ORDCHK		;YES - DO IT

;SUBROUTINE TO DELETE LINES FROM A FILE - COUNTS NUMBER OF
;PAGE MARKS DELETED IN PGDELS

DELSUB:	TRNN	FL,PGSN		;CHECK FOR MASSIVE DELETE
	SKIPN	LOLN
	JRST	[TRNN FL,EXTOG
		 TRNE FL,LINSN
		 JRST .+1
		 OUTSTR [ASCIZ /Massive delete ok? /]
		 PUSHJ P,CONFRM
		 JRST COMND	;NO:
		 JRST .+1]	;YES:
	TRZ	FL,LINSN	;NONE SEEN YET
	MOVE	T1,LOPG		;GET THE PAGE NUMBER
	MOVEM	T1,DPG
	MOVE	SINDEX,LOLN	;AND LINE
	PUSHJ	P,FIND
	MOVE	T2,CPG		;SEE WHERE WE ARE
	CAME	T2,LOPG		;IS THIS OK
	NERROR	NSP
	SKIPN	LOLN		;WANT WHOLE PAGE?
	TRO	FL,LINSN	;YES - SAY WE DID IT
DELSB1:	PUSHJ	P,ONMOV		;CHECK FOR RANGE
	JRST	DELEND
	TRO	FL,LINSN	;SEEN SOMETHING
	CAMN	T1,PGMK		;PAGE MARK
	JRST	DELPAG		;YES - DELETE PAGE
	MOVEM	T1,CLN		;SAVE CURRENT LINE
	PUSHJ	P,DODEL		;GO DO A LINE DELETE
DELSB2:	PUSHJ	P,FINDN1	;FIND NEXT BUT ACCEPT LINE IF ALREADY THERE
	JRST	DELSB1		;GO DO NEXT

DELPAG:	MOVEI	T1,2		;SET TO DELETE PAGE
	MOVEM	T1,OCNT
	SETZM	NCNT		;NEW SIZE IS 0
	PUSHJ	P,INSED		;ZAP
	AOS	PGDELS		;INCR COUNT OF PAGES GONE
	AOS	CPG		;BEWARE!!!
	SETZM	LDELLN		;NO LINES ON THIS PAGE YET
	JRST	DELSB2		;CONTINUE

DELEND:	TRNN	FL,LINSN	;DO ANYTHING?
	NERROR	NLN		;NO - GIVE ERROR
	MOVE	T1,LOPG		;YES - SET CURRENT PAGE
	MOVEM	T1,CPG		;AS THE ONE HE ASKED FOR
	MOVEM	T1,CPGL		;...
	MOVN	T1,PGDELS	;GET NEG # OF PAGES DELETED
	ADDM	T1,BGPG		;ADJUST CNTRS
	ADDM	T1,INPG		;TO SHOW CORRECT # OF PAGES
	POPJ	P,		;RETURN
;DELETE A PAGE MARK

KILL:	SETZM	LOLN	;A GOOD THING
	TRNE	FL,READOF
	NERROR	ILC
	PUSHJ	P,GET1S
	TRZN	FL,LINSN
	TRNN	FL,TERMF
	NERROR	ILC
DELPG:	MOVE T1,HIPG	;GET THE DESIRED PAGE TO DELETE
	MOVEM T1,DPG	;SET IT
	SOJLE T1,DELER	;DO NOT TRY PAGE 1
	MOVEI SINDEX,0	;GUARANTEED TO FIND LINE IMMEDIATELY AFTER PAGE MARK
	PUSHJ P,FIND	;GET IT
	MOVE T2,CPG	;CHECK FOR MATCH
	CAME T2,HIPG
DELER:	NERROR NSP	;NO SUCH PAGE
	PUSHJ P,FINDB	;GO BACK ONE
	CAME T1,PGMK	;IS IT A PAGE MARK?
	NERROR ICN		;CONFUSED, GIVE FATAL ERROR
	MOVEI T1,2	;COUNT IS 2
	MOVEM T1,OCNT
	SETZM NCNT	;AND NEW IS 0
	PUSHJ P,INSED
	MOVE	T1,HIPG		;GET HIGH PAGE
	CAMG	T1,CPGL		;CPG GTR CPGL?
	SOS	CPGL		;NO, CPGL=CPGL-1
	SOS BGPG	;MAX PAGE IS NOW 1 LOWER
	SOS INPG
ORDCHK:	PUSHJ P,FINDN1	;GET THE NEXT LINE
	JUMPE T1,COMND	;IF EOF THERE IS NO ORDER ERROR
	CAMN T1,PGMK	;OR IF A PAGE MARK
	JRST COMND
	MOVEM T1,SVSEQN		;SAVE IT FOR COMPARE
	PUSHJ P,FINDB		;FIND THE PREVIOUS ONE
	JUMPE T1,COMND		;START OF FILE, ALL OK
	CAME T1,PGMK		;ANOTHER PAGE MARK
	CAMGE T1,SVSEQN		;CHECK THE ORDER
	JRST COMND		;ALL OK
	NERROR ORDER		;ALL WRONG

SUBTTL INSERT PAGE MARK

;INSERT A PAGE MARK AT DESIGNATED LINE

MARK:	SETZM	HILN		;IN CASE OF /A
	TRNE FL,READOF	;NOT PERMITTED IN READ ONLY
	NERROR ILC
	PUSHJ P,GET1S	;GET ONE LINE/PAGE NUMBER
	TRNN FL,TERMF	;CHECK FOR TERMINATOR
	NERROR ILC
	PUSHJ	P,MARK0		;INSERT PAGE MARK
	JRST	COMND		;RETURN TO COMMAND LEVEL

MARK0:	MOVE T1,HIPG	;GO LOOK FOR IT
	MOVEM T1,DPG
	MOVE SINDEX,HILN	;AND THE LINE
	PUSHJ P,FIND	;GET IT
	MOVE T1,CPG
	CAME T1,HIPG	;PAGE MUST MATCH
	NERROR NSP	;MUST MATCH
	AOS T1,CPG	;WILL BE ON HIGHER PAGE WHEN DONE
	MOVEM T1,CPGL	;SET UP LOGICAL PAGE
	AOS BGPG	;THERE IS NOW ONE MORE
	AOS INPG
	MOVE T1,TECFST	;Use the START parameter
	MOVEM T1,CLN	;FIRST LINE ON THAt PAGE
	MOVE T1,PGMK	;PUT A PAGE MARK IN LIBUF
	MOVEM T1,LIBUF
	MOVE	T1,PGMKW2	;TEXT OF A PAGE MARK
	MOVEM T1,LIBUF+1
	SETZM OCNT	;THIS IS A STRAIGHT INSEET
	MOVEI T1,2	;OF 2 WORDS
	MOVEM T1,NCNT
	PUSHJ P,INSED	;GO DO IT
	PUSHJ P,FINDN	;SINCE FILLB MAY WANT TO DUMP THIS LINE
	JUMPE T1,FILLB		;SKIP IF EOF SEEN
	CAME T1,PGMK		;CHECK IF EMPTY
	MOVEM T1,CLN		;NO; USE THIS LINE
	JRST	FILLB		;FILL BUFFER

INSMK:	TRNE	FL,TERMF	;(223)do we have a terminator?
	 JRST	INSMK0		;(223)yes,don't check for increment
	CAIE	C,","		;(223)no,check for comma
	 NERROR	ILC		;(223)bad syntax
	MOVE	T1,INCR		;(223)load old INCR into T1
	PUSHJ	P,GETINC	;(223)get increment value
	SETZM	ALTSN		;NO ESC SEEN YET
INSMK0:	MOVE	T1,[<ASCII /9999:/>!1]
	MOVEM	T1,HILN		;ONE PAST END OF WORLD
	PUSHJ	P,MARK0		;INSERT PAGE-MARK
	MOVE	T1,CLN		;GET CURRENT LINE
	MOVEM	T1,HILN
	MOVE	T1,CPG		;AND CURRENT PAGE
	MOVEM	T1,HIPG		;SET UP FOR INSERT
	JRST	INSGO		;GO

SUBTTL	RENUMBER

;RENUMBER SELECTED LINES

NUMBER:	MOVE T1,TECINC		;USE DEFAULT INCR
	MOVEM T1,REINC		;WE WILL USE 100
	MOVE T1,TECFST		; AND DEFAULT START
	MOVEM T1,INCST
	MOVEM T1,REFST		;SAVE FOR NEW PAGE
	SETZM LOLN	;GET THIS SET TO START THINGS OFF
	TRNE FL,READOF	;NOT PERMITTED IN READ ONLY
	NERROR ILC
	TRZ	FL2,ACONST!MONOF
	PUSHJ	P,GNCH		;GET NEXT CHAR
	MOVEM	C,SAVC		;SAVE IN CASE WE NEED IT
	ANDI	C,137		;FORCE UPPER
	CAIN	C,"A"
	TRO	FL2,ACONST	;ADD CONSTANT
	CAIN	C,"P"
	TRO	FL2,MONOF	;NO RESET ON PAGE MARK
	TRNE	FL2,ACONST!MONOF
	SETZM	SAVC		;GOT ONE - DON'T BACK UP SCANNER
	PUSHJ	P,SCAN		;GET THE RENUMBER INCREMENT
	TRNE FL,NUMF	;WAS IT A NUMBER
	CAMN T1,[<ASCII /00000/>!1]	;NO 0 RENUMBER INCR
	JRST NUMBC	;NO NUMBER, CHECK FOR COMMA
	MOVEM T1,REINC	;THE INCREMENT TO USE
	MOVEM T1,INCST	;LINE TO START WITH
	MOVEM	T1,REFST
	PUSHJ P,SCAN	;SCAN PAST NUMBER
NUMBC:	CAIN C,","	;AND CHECK FOR COMMA
	JRST NUMB1	;GET A RANGE
	MOVEI T1,1	;NO RANGE, DO WHOLE FILE
	MOVEM T1,LOPG	;FROM PAGE 1
	MOVSI T1,1	;TO IMPOSSIBLY HIGH
	MOVEM T1,HIPG
	TRZ FL,CNTF	;MAKE SURE THIS IS OFF
	JRST NUMBL	;AND CHECK FOR TERMINATOR
NUMB1:	PUSHJ P,GET2S	;GET A RANGE
	CAIE C,","	;SEE IF THERE IS A FOURTH ARGUMENT
	JRST NUMBL	;NO
	PUSHJ P,SCAN	;YES, GET IT
	TRNN	FL2,ACONST	;ILLEGAL IF ADD MODE
	TRNN FL,NUMF	;IS IT A NUMBER?
	NERROR ILC	;HE WOULD HAVE BEEN BETTER OFF WITHOUT IT
	MOVEM	T1,REFST
	MOVEM T1,INCST	;USS AS STARTING NUMBER
	PUSHJ P,SCAN	;SCAN PAST IT
NUMBL:	TRNN FL,TERMF	;ENDS PROPERLY?
	NERROR ILC	;LOSE
	MOVE T1,LOPG	;GET PLACE TO START
	MOVEM T1,DPG
	MOVE SINDEX,LOLN	;AND LINE
			;FALL THRU
	PUSHJ P,FIND	;GET IT
	TRZ FL,LINSN!ORDF	;SET TO NONE SEEN AND NO ORDER ERROR
	PUSHJ P,FINDB	;BACK UP AND SEE HOW ORDER LOOKS
	JUMPE T1,NUMB5	;START OF FILE IT MUST BE OK
	CAME T1,PGMK	;ALSO IF A PAGE MARK
	CAMGE T1,INCST	;OR IF IN CORRECT ORDER
	SKIPA
	TRO FL,ORDF	;WRONG SET FLAG
NUMB5:	PUSHJ P,FIND	;GET THE CORRECT LINE BACK
NUMB2:	PUSHJ P,ONMOV	;CHECK RANGE
	JRST NUMB3
	CAMN T1,PGMK	;PAGE MARK?
	JRST NUMB4	;SPECIAL TREATMENT
	MOVE	T1,1(PNTR)	;CHECK SPECIAL P.M.
	CAMN	T1,[BYTE (7)11,14,15,12,0]
	JRST	NUMBP		;HANDLE AS WIERD PAGE MARK
	TRNE	FL2,ACONST	;JUST ADD CONSTANT
	JRST	[MOVE T1,(PNTR)	;YES - USE OLD LINE #
		 TRO FL,LINSN	;SAY WE'VE SEEN ONE
		 JRST NUMB2A]
	MOVE T1,INCST	;GET STAATING NUMBER
NUMB2A:	MOVE T2,REINC	;AND INCREMENT
	TRON FL,LINSN	;WAS A LINE SEEN?
	JRST FSTLIN	;NO, FIRST ONE IS SPECIAL
	PUSHJ P,ASCIAD	;SKIP THIS THE FFRST TIME
	CAMGE T1,REINC	;HAVE WE WRAPED
	JRST	[RERROR WAR	;TELL HIM HE LOST
		MOVE T2,CPG	;PRINT THE PAGE
		PUSHJ P,PGPRN
		JRST .+1]	;RETURN
FSTLIN:	MOVEM T1,INCST	;SAVE FOR NEXT LINE
	MOVEM T1,CLN	;AND THE CURRENT LINE
	MOVEM T1,(PNTR)	;PUT IT IN
	PUSHJ P,FINDN	;GET NEXT
	JRST NUMB2	;AND GO RANGE CHECK

NUMB3:	TRNN FL,LINSN	;DONE, WAS THERE SOMETHING THERE?
	NERROR NLN	;NO,  NULL RANGE ERROR
	TLO	FL2,ALLCHG	;CHANGES
	MOVE T2,CPG	;SET UP CURRENT PAGE
	MOVEM T2,CPGL
	TRNE FL,ORDF	;WAS THERE AN ORDER ERROR?
	NERROR ORDER	;YES, FLAG IT
	JUMPE T1,COMND	;CHECK TO SEE IF LOSAGE NOW
	CAME T1,PGMK
	CAMLE T1,INCST
	JRST COMND
	NERROR ORDER
NUMBP:	MOVE	T1,PGMK		;CONVERT TO PAGE MARK
	MOVEM	T1,0(PNTR)
	MOVE	T1,PGMKW2	;REST
	MOVEM	T1,1(PNTR)	;...
	AOS	BGPG		;INCR ALL GOOD STUFF
	AOS	INPG
	AOS	HIPG		;FAKE OUT ONMOV
NUMB4:	AOS	CPG		;NOW ON A HIGHER PAGE
	MOVE	T1,[<ASCII /00000/>!1]
	MOVEM	T1,CLN		;SET TO FIRST LINE ON PAGE
	TRO	FL,LINSN	;WE SAW ONE
	PUSHJ	P,FINDN		;GET NEXT LINE
	PUSHJ	P,ONMOV	;IN RANGE?
	  JRST	NUMB3		;NO - FINISHED
	CAMN	T1,PGMK		;ANOTHER P. M.
	JRST	NUMB4
	MOVE	T1,REFST	;FIRST LINE #
	TRNN	FL2,ACONST!MONOF
	JRST	FSTLIN		;IF NOT SPECIAL
	MOVE	T1,REINC	;ELSE GET INC
	TRNN	FL2,MONOF
	SKIPA	T2,(PNTR)	;CURRENT LINE FOR "NA"
	MOVE	T2,INCST	;ELSE LAST LINE FOR "NP"
	PUSHJ	P,ASCIAD	;DO ARITHMETIC
	JRST	FSTLIN		;STASH NUMBER

SUBTTL ALTER COMMAND
	DEFINE OFFRUB
<	TRZE FL2,RUBF2
	OUTSTR [ASCIZ /\\/]
	TRZE FL2,RUBF
	OUTCHR ["\"]>

	DEFINE ONRUB
<	TRZE FL2,RUBF2
	OUTSTR [ASCII /\\/]
	TRON FL2,RUBF
	OUTCHR ["\"]>

ALTER:	SETZM LOLN	;FOR START OF PAGE
	TRZ FL2,ADECIF	;THIS IS NOT DECIDE MODE ALTER
	PUSHJ P,GET2S	;GET THE RANGE
	TRNN FL,TERMF	;CHECK FOR PROPER END
	NERROR ILC	;UNEND
	MOVE T1,LOPG	;START TO PROCESS
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND	;GO GET IT
	TRZ FL,LINSN	;NOT SEEN YET
ALT1:	PUSHJ P,ONMOV	;CHECK FOR IN RANGE
	JRST ALT2	;NO, FINISH UP
	TRO FL,LINSN	;WE DID SEE SOMETHING
	CAMN T1,PGMK	;CHEC FOR A PAGE
	JRST ALT3	;DO NNT TRY TO CHANGE THIS
	MOVEM T1,CLN	;NOW, IN CASE WE SAID ALTMODE
	MOVE T1,CPG	;SAME FOR PAGE
	MOVEM T1,CPGL
	PUSHJ P,ALTLIN	;GO DO THE ALTER
	JRST LEVINS	;HE SAID ALTMODE
	PUSHJ P,INSED	;GO INSERT
ALT4:	PUSHJ P,FINDN	;GET THE NEXT LINE
	PUSHJ P,FILLB	;AND CHECK FOR BUFFER OVERFLOW
	MOVE T1,(PNTR)	;GET LINE FOR ONMOV
	JRST ALT1	;CONTINUE LOOP
ALT3:	AOS T2,CPG	;WE ARE ON A LATER PAGE NOW
	MOVEM T2,CPGL	;SAVE AS .
	TRNN	FL2,NONUMF	;SKIP IF IN NONUMBER MODE
	PUSHJ P,PGPRN	;PRINT HIM A MESSAGE
	MOVE T1,[<ASCII /00000/>!1]	;SET TO FIRST? LINE
	MOVEM T1,CLN	;FOR .
	JRST ALT4	;CONTINUE PAST IT
ALT2:	TRNN FL,LINSN	;WAS THERE ANYTHING THERE?
	NERROR NLN	;NO, GIVE ERROR
	MOVE T1,CPG	;|ET CURRENT PAGEE
	MOVEM T1,CPGL	;SAVE AS .
	JRST COMND	;GO
ALTLIN:	PUSHJ P,SETALT	;SET UP LINE FOR ALTERATION

ALTN1:
ALTLP2:	MOVEI T2,0	;ZERO REPEAT COUNT
	TLZ FL,NEGF	;TURN OFF "-" SEEN FLG
ALTLP:	TRZ FL2,ALTDUP	;TURN DUPLEXING BACK OFF
	PUSHJ P,GNCH1	;GET ON CHR IN DDT SUBMODE
	TLNE CS,LETF_16	;CHECK FOR LETTER
	TRZ C,40	;AND CONVERT TO UPPER CASE
	MOVSI T1,-ALTLG	;GET LENGTH OF COMMAND TABLE
	CAME C,ALTAB1(T1)	;CHECK FOR EQUAL
	AOBJN T1,.-1	;NO, TRY AGAIN
	JUMPGE	T1,[CAIN C,15		;IGNORE CR'S
		    JRST ALTLP
		    JRST ALTBEL]
	MOVE	T1,ALTAB2(T1)	;GET TABLE ENTRY IN T1
	JUMPL	T1,ALTDSP	;"-" ALLOWED IF NEG.
	TLNN	FL,NEGF		;NO: IS IT SET?
	JRST	ALTDSP		;OK TO EXECUTE COMMAND
ALTBEL:	OUTCHR	[7]		;BONG A GONG
	CALL	CLRBFI		;CLEAR TYPE AHEAD
	JRST	ALTLP2		;TRY AGAIN

ALTDSP:	TLNN	T1,(1B1)	;OK IN ALL MODES?
	TRNN	FL,READOF	;NO -- CHECK R/O
	SKIPA			;YES -- DISPATCH
	JRST	ALTBEL		;R/O RING BELL
	PUSHJ	P,0(T1)		;DISPATCH
	JRST	ALTLP2		;RESET REPEAT COUNT AND GET NEW COMMAND
	JRST	ALTLP		;SKIP RETURN FROM DIGITS NO COUNT RESET

ALTAB1:	EXP " ","I","D","F","K","Q",12
	EXP "C",177,"U"-100,"W","X","R"-100
	EXP "R","L","P","J","E","-",10,11,"?"
	EXP "0","1","2","3","4","5","6","7","8","9","0"
ALTLG=.-ALTAB1

ALTAB2:	EXP <3B1+ALTSP>,ALTIN
	EXP <1B0+ALTDL>,<3B1+ALTSR>,<1B0+ALTKL>
	EXP <1B1+ALTALT>,<1B1+ALTFN>,ALTCN
	EXP <1B1+ALTBS>,<1B1+ALTCU>,<1B1+ALTWD>,ALTWX
	EXP <1B1+APRINR>,<1B0+ALTRP>
	EXP <1B1+ALTLN>,<1B1+APRINT>,AJOIN,<1B1+ALTEX>
	EXP <1B1+ALTNEG>,<1B1+ALTBS>,<3B1+ALTTB>,<1B1+AQUES>
	REPEAT ^D10,<<3B1+ALTDG>>

; ? Prints all the legal Alter mode commands

AQUES:	OFFRUB
	OUTSTR	[ASCIZ "
Alter commands are: C, D, E, I, J, K, L, P, Q, R, F, W, 
X, space, <CR>, Rubout, Backspace, Tab, and CTRL/U.
"]
APRINR:	PUSH	P,ALTCNT	;Save the current place
	PUSHJ	P,ALTLN1	;Print sequence number + tab
	POP	P,T2		;Retrieve current place
	CAILE	T2,0		;Print if > 0
	JRST	ALTSP
	POPJ	P,

ALTNEG:	TLO FL,NEGF
	JRST CPOPJ1

SETALT:	SETZM LIBUF	;ZERO OUT INTERNAL LINE BUFFER
	MOVE T1,[XWD LIBUF,LIBUF+1]
	BLT T1,LIBUF+MXWPL+1
	MOVEI T1,LIBUF	;SET POINTER TO TRANSFER
	MOVE T2,PNTR
	MOVE T3,(T2)	;GET THE FIRST WORD (SEQ NUM)
	JRST SALT3
SALT2:	SKIPE T3,(T2)	;PICK UP A WORD AND CHECK FOR 0
	TRNE T3,1	;CHECK FOR SEQ NTM
	JRST SALT1	;END OF THIS LINE
SALT3:	MOVEM T3,(T1)	;SAVE IT AWAY
	ADDI T1,1	;INCREMENT POINTERS
	AOJA T2,SALT2
SALT1:	MOVE ALTP,[POINT 7,LIBUF+1,13]	;SET UP POINTER
	SETZM ALTCNT	;SO FAR WE ARE 0 CHRS INTO LINE
	SUBI T1,LIBUF	;GET COUNT OF OLD LINE
	HRRZM T1,OCNT	;AND SAVE IT FOR INSED
	CALL	NOECHO		;TURN OFF ECHO
	TRZ FL2,RUBF!ALTDUP!RUBF2	;TURN OFF IN RUBOUT FALG AND NO DUPLEXING
	SETZM ALTFLG	;NOTHING INSERTED SO FAR
	TRNE	FL2,NONUMF	;SKIP IF NORMAL
	POPJ	P,		;ELSE RETURN
	MOVE T1,LIBUF	;PRINT LINE NUMBER AND TAB
	JRST OUTSN

RPSALT=SALT1

GNCH1A:	TRNE FL2,COMFLF	;DO RDCHAR IF CMD FILE NOT ANSWERING
			;A TO DECIDE MODE
	JRST	[TRNE FL2,ADECIF
		 JRST .+1
		 PUSHJ P,RDCHAR
		 JRST GNCH1C]
	INCHRW C
	ANDI C,177
GNCH1C:	CAME C,ESC	;NEVER DUPLEX ESC
	TRNN FL2,ALTDUP	;AND NOT UNLESS DESIRED
	POPJ P,
	CAIE C,12	;NOT LINE FEED
	CAIN C,15	;OR RETURN
	POPJ P,
	CAILE C,5	;DONT ECHO ^E (CAN CAUSE TERMINAL ANSWERBACK)
	CAIN C,177	;AND FINALLY IGNORE RUBOUT
	POPJ P,
	OFFRUB		;IF WE ARE DUPLEXING WE ARE NOT DELETING
	OUTCHR C	;TYPE
	POPJ P,

GNCH1:	PUSHJ P,GNCH1A	;GET A CHR IN DDT MODE
	CAMN C,ESC	;CONVERT ALTMODE TO 200
	MOVEI C,200
	TLNN FL,QMODF
	CAIE	C,"'"		;CHECK FOR QUOTE
	JRST GNCH1B	;NO, THIS CHR IS OK
	PUSHJ P,GNCH1A	;GET ANOTHER
	SKIPE CTBL(C)	;IF 0 HN CTBL, KEEP IT
	MOVS C,CTBL(C)	;GET ALTERNATE CODE
	ANDI C,177	;GET RID OF EXTRA BITS
GNCH1B:	MOVE CS,CTBL(C)	;LOAD CS
	TLNE CS,LETF_16	;CHECK FOR LETTER
	TDC C,CASEBT	;AND APPLY CASE CONVERRION
	POPJ P,		;ALL DONE

ALTDG:	IMULI T2,^D10	;ACCUMULATE REPEAT COUNT
	ADDI T2,-"0"(C)
	JRST CPOPJ1	;SKIP RETURN SO AT NOT TO 0 RPT. CNT.

ALTTB:	MOVEI	T2,MXWPL*5+100	;LOTS OF SPACES
ALTSP:	TLNE FL,NEGF	;CHECK BACKWARDS
	JRST ALTBS	;YES: BACK SPACE
	OFFRUB

ALTSP2:	LDB C,ALTP	;GET THE CHR WE ARE POINTING AT
	CAIN C,15	;IF RETURN THEN AS FAR AS CAN GO
	JRST ALTSP1	;SO QUIT
	TRNN FL2,SUPN	;SPECIAL HACK FOR XTEND
	PUSHJ P,OCHR	;PRINT IT
	IBP ALTP	;ADVANCE POINTER
	AOS ALTCNT	;AND COUNT
	SOJG T2,ALTSP2	;DO CORRECT NUMBER OF TIMES
ALTSP1:	TRNN FL2,SUPN
	PUSHJ	P,FORCE		;DUMP IT
	POPJ P,



ALTIN:	TRO FL2,ALTDUP	;TURN ON DUPLEXING
	MOVEM T2,ALTINC	;SAVE IN CASE HE INSERTS A RETURN
ALTIN1:	PUSHJ P,GNCH1	;GET A CHARACTER
	CAIN C,"R"-100	;CONTROL-R
	JRST [	OFFRUB
		CALL APRINR	;PRINT LINE OVER
		JRST ALTIN1]	;CONTINUE INSERT
	CAIN C,"U"-100		;CONTROL-U
	JRST ALTCU		;ABORT AND START OVER
	CAIN C,15	;FINISH ON CR
	JRST ALTFNZ
	CAIN C,12
	JRST INSCR	;GO INSERT A CRLF
	CAIN C,200	;FINISH ON ALTMODE
	POPJ P,		;GO AWAY
	CAIN C,177	;CHECK FOR BACKSPACE
	JRST ALTIBS	;AND DELETE CHR TO LEFT
	MOVE T3,ALTP	;GET SET TO SHIFT THINGS
	PUSH P,ALTCNT	;SAVE THIS FOR LATER
	LDB T1,T3	;GET CHR FROM LINE
ALTIN2:	DPB C,T3	;SHIFT LINE
	JUMPE C,ALTIN3	;DONE
	AOS ALTCNT	;COUNT IT
	ILDB C,T3
	DPB T1,T3
	JUMPE T1,ALTIN3	;DONE
	AOS ALTCNT	;COUNT
	ILDB T1,T3
	JRST ALTIN2
ALTIN3:	MOVE T2,ALTCNT	;SEE IF OVERFLOW HAPPENED
	CAIL T2,MXWPL*5
	NERROR LTL	;YES
	POP P,ALTCNT	;RESTORE OLD COUNT
	IBP ALTP	;ADVANCE POINTER
	AOS ALTCNT	;AND COUNT
	JRST ALTIN1	;GO GET MORE

INSCR:	OFFRUB
	OCRLF
	SKIPN T1,ALTINC	;DID HE SPECIFY AN INCREMENT?
	SKIPA T3,INCR	;NO, USE STANDARD
	PUSHJ P,ASCON	;CONVERT TO ASCII
	MOVE T1,T3	;FIND THE NEW LINE NUMBER
	MOVE T2,LIBUF	;CURRENT ONE
	PUSHJ	P,FIXLIN
	  EXP	LIBUF
	JRST	[RERROR ORDER
		 PUSHJ P,FINDB	;GET BACK WHERE WE BELONG
		 PUSHJ P,ERCOR	;TYPE OUT LINE TO CURRENT POINT
		 JRST ALTIN1]	;AND CONTINUE INSERT
	MOVEM	T2,LIBUF2	;SAVE IT
	MOVEM T2,CLN	;AND SET AS CURRENT LINE
	PUSHJ P,FINDB	;BACK UP TO WHERE WE BELONG
	MOVE T1,[XWD LIBUF+1,LIBUF2+1]
	BLT T1,LIBUF2+MXWPL+1	;SAVE OLD BUFFER
	PUSH P,ALTP	;SAVE POINTER
	MOVEI C,15
	DPB C,ALTP	;AND TERMINATE THIS LINE
	MOVEI C,12
	IDPB C,ALTP
	MOVEI C,0	;FILL OUT LINE WITH NULLS
AINSC2:	TLNN ALTP,760000
	JRST AINSC3
	IDPB C,ALTP
	JRST AINSC2
AINSC3:	SUBI ALTP,LIBUF-1	;FIND COUNT
	HRRZM ALTP,NCNT
	PUSHJ P,INSED	;REPLACE OLD LINE
	PUSHJ P,FINDN	;MOVE UP TO NEXT
	PUSHJ P,FILLB	;AND DUMP IF OVERFLOW
	SETZM OCNT	;THIS IS A NEW LINE GOING IN
	MOVE T1,LIBUF2	;MOVE LINE NUMBER OVER
	MOVEM T1,LIBUF
	SETZM LIBUF+1
	MOVE T1,[XWD LIBUF+1,LIBUF+2]
	BLT T1,LIBUF+MXWPL+1	;ZERO OUT REST
	POP P,T2	;RESTORE POINTER TO REST OF LINE
	MOVE ALTP,[POINT 7,LIBUF+1]	;DEST POINTER
	ADD T2,[XWD 70000,LIBUF2-LIBUF]	;ADJUST INPUT POINTER
	TLZ T2,17		;CLEAR CARRY
	MOVEI C,11	;AND SET UP THE TAB
MOVNEW:	IDPB C,ALTP
	CAIN C,12
	JRST DONNEW	;FINISHED MOVING REST OF LINE
	ILDB C,T2	;PICK UP ONE
	JRST MOVNEW
DONNEW:	SUBI ALTP,LIBUF			;GET COUNT
	MOVEI ALTP,1(ALTP)	;USED TO BE - MOVEI AC,1-LIBUF(AC)
	MOVEM ALTP,NCNT
	PUSH P,ALTP	;AND SAVE
	PUSHJ P,INSED	;INSERT
	MOVE ALTP,[POINT 7,LIBUF+1,13]	;SET UP FOR ALTER
	SETZM ALTCNT
	POP P,OCNT	;SET FOR OLD COUNT
	MOVE T1,LIBUF
	TRNN	FL2,NONUMF	;SKIP IF NOT PRINTING
	PUSHJ P,OUTSN
	SETOM ALTFLG	;WE HAVE INSERTED AND ALTALT SHOULD CALL FILLB
	JRST ALTIN1	;AND CONTINUE INSERTING

ALTIBS:	MOVEI T2,0	;SET COUNT TO 0
	MOVEM ALTP,SVALTP	;SAVE POINTER
	PUSHJ P,ALTBS	;DO A BACKSPACE
	EXCH ALTP,SVALTP	;GET BACK AND SAVE CURRENT
	PUSHJ P,ALTDL3	;DELETE THAT CHR
	JRST ALTIN1	;GET MORE

ALTDL:	TLNE FL,NEGF		;BACKWARDS?
	JRST ALTBDL		;YES:
	MOVEM ALTP,SVALTP	;SAVE CURRENT POINTER POSITHON
ALTDL1:	LDB C,ALTP	;GET CURRENT CHR
	CAIN C,15	;AT END OF LINE?
	JRST ALTDL5	;YES, GO FINISH OFF
	TRNN	FL,EXTOG	;PRINT ONLY IF NON-EXPERT
	PUSHJ P,ALTDPN	;YES: PRINT CHAR
	IBP ALTP	;ADVANCE POINTER
	SOJG T2,ALTDL1	;CHECK COUNT AND CONTINUE
ALTDL5:	PUSHJ	P,FORCE		;FORCE OUTPUT
ALTDL3:	MOVE T3,SVALTP	;GET BACK POINTER
ALTDL4:	LDB C,ALTP	;MOVE LINE DOWN
	DPB C,T3
	JUMPE C,ALTDL2	;DONE?
	IBP ALTP	;ADVANCE POINTERS
	IBP T3
	JRST ALTDL4
ALTDL2:	MOVE ALTP,SVALTP	;RESTORE POINTER AGAIN
	POPJ P,		;AND LEAVE


APRINT:	PUSH P,ALTCNT	;SAVE CURRENT COUNT
	PUSHJ P,ALTLN	;PRINT REST OF LINE AND START OVER
	POP P,T2	;GET BACK COUNT
	CAILE T2,0	;AND SPACE IF NOT 0
	JRST ALTSP
	POPJ P,

ALTDPN:	PUSH P,C
	MOVEI C,"\"
	TRNN FL2,RUBF2
	PUSHJ P,OCHR
	TRZE FL2,RUBF
	PUSHJ P,OCHR
	TRON FL2,RUBF2
	PUSHJ P,OCHR
	POP P,C
	JRST OCHR

ALTSR:	OFFRUB
	PUSHJ P,GNCH1	;GET THE CHARACTER TO SEARCH FOR
ALTSR1:	PUSH P,T2	;SAVE NUMBER OF TIMES TO SEARCH
	PUSHJ P,ALTCS	;CALL COMMON SEARCH ROUTINE
	PUSH P,C	;SAVE THE CHARACTER
	PUSHJ P,ALTSP	;GO SPACE CORRECT NUMBER
	POP P,C		;RESTORE CHR
	POP P,T2	;AND COUNT
	SOJG T2,ALTSR1	;CONTINUE
	POPJ P,

ALTCS:	MOVEI T2,1	;CREATE A REPEAT COUNT
	TLNE FL,NEGF	;BACKWARDS?
	JRST ALTBCS	;YES: SEARCH BACKWARDS
	LDB T3,ALTP	;CHEC TO SEE IF AT END OF LINE
	CAIN T3,15
	POPJ P,
	MOVE T1,ALTP	;GET A COPY OF THE POINTER
ALTCS1:	ILDB T3,T1	;GET A CHARACTER
	CAIE T3,15	;DONE IF END OF LINE
	CAMN T3,C	;OR A MATCH
	POPJ P,
	AOJA T2,ALTCS1	;ELSE KEEP COUNT AND KEEP LOOKING

ALTKL:	PUSHJ P,GNCH1	;ALMOST LINE ALTSR
	CAIE	C,12		;CHECK FOR K<LF>
	JRST	ALTKL1		;NO - REGULAR CASE THEN
	MOVEI	T2,MXWPL*5+100	;YES - DO SOME DELETING
	JRST	ALTDL		;...

ALTKL1:	PUSH P,T2
	PUSHJ P,ALTCS
	CAIE T3,0	;OFF FRONT END - SKIP
	CAIN T3,15	;BUT GIVE UP IF CHR NOT FOUND
	JRST T2POPJ
	PUSH P,C
	PUSHJ P,ALTDL	;DELETE THAT NUMBER
	POP P,C
	POP P,T2
	SOJG T2,ALTKL1
	POPJ P,
T2POPJ:	POP P,T2	;NEED TO CLEAR STACK
	POPJ P,

ALTALT:	OFFRUB
	SKIPN ALTFLG	;SHOULD WE DO A FILLB?
	JRST ALTAL1
	PUSHJ P,FINDN
	PUSHJ P,FILLB	;YES, WE HAVE INSERTED SOMETHING
ALTAL1:
	CALL	DOECHO		;DUMPLEXING BACK ON
T1POPJ:	POP	P,T1		;RESTORE T1
	RET			;  AND RETURN


ALTFNZ:
	PUSHJ P,GNCH1
ALTFN:
	MOVEI T2,MXWPL*5+100	;FINISH UP LINE
	PUSHJ P,ALTSP	;BY PRINTING A LARGE NUMBER OF SPCAES
ALTFNX:
	OCRLF
	CALL	DOECHO		;GET OUT OF NON-DUPLEX MODE
ALTFN1:	ILDB C,ALTP	;LOOK ONE CHR OVER
	CAIE C,12	;THIS SHOULD BE THE LINE FEED
	NERROR ILFMT	;SOMETHING IS WRONG
	MOVEI C,0	;ZERO REMAINDER OF LINE
ALTFN2:	TLNN ALTP,760000	;ALL DONE?
	JRST ALTFN3	;YES
	IDPB C,ALTP	;NO, PUT IN ANOTHER 0
	JRST ALTFN2
ALTFN3:	SUBI ALTP,LIBUF-1	;GET SIZE OF NEW LINE
	HRRZM ALTP,NCNT	;AND SAVE FOR INSED
	AOS -1(P)	;SET FOR SKIP RETURN
	JRST T1POPJ	;RETURN TO CALLER OF ALTLIN


ALTCU:	OFFRUB
	OUTSTR [ASCIZ /^U
/]
	JRST SETALT	;GO RESTART LINE AND FORGET EDIT SO FAR

ALTRP:	PUSHJ P,ALTDL	;REPLACE IS DELETE THEN INSERT
	TLZ	FL,NEGF
	MOVEI T2,0
	JRST ALTIN


ALTCN:	OFFRUB
	TRO FL2,ALTDUP	;TURN ON DUPLEXING
ALTCN2:	LDB C,ALTP	;AT END OF LINE?
	CAIN C,15
	POPJ P,		;YES, STOP
ALTCN1:	PUSHJ P,GNCH1	;GET A CHARACTER
	CAIE C,177	;DO NOT LET HIM INSERT A RUBOUT
	CAIN C,15	;IGNORE CRET
	JRST ALTCN1
	CAIE C,200	;STOP ON ALTMODE AND LINE FEED
	CAIN C,12
	POPJ P,
	DPB C,ALTP	;REPLACE IT
	IBP ALTP	;ADVANCE POINTER
	AOS ALTCNT	;AND COUNT
	SOJG T2,ALTCN2	;CONTINUE
	POPJ P,



ALTEX:	OFFRUB
ALTEX1:	LDB C,ALTP
	CAIN C,15
	JRST ALTFNX
	IBP ALTP
	AOS ALTCNT
	JRST ALTEX1


AJOIN:	OFFRUB
	PUSHJ P,FINDN	;GO SEE IF NEXT LINE IS REALLY THERE
	CAME T1,PGMK
	SKIPN T1
	JRST ILCER	;MAKE IT ILLEGAL IF NO LINE THERE
	MOVEM T1,LIBUF2	;SAVE ITS NUMBER
	SETZM LIBUF2+1
	MOVE T1,[XWD LIBUF2+1,LIBUF2+2]
	BLT T1,LIBUF2+MXWPL+1	;CLEAR OUT REST OF BUFFER
	PUSH P,ALTP	;SAVE POINTER TO THIS LINE
	ADD ALTP,[XWD 70000,0]	;BACK IT UP
	MOVE T2,[POINT 7,LIBUF2+1]
	MOVEI C,11
	MOVEI T1,6	;COUNT THE CHARACTERS
MOVLIN:	IDPB C,T2
	ILDB C,ALTP
	CAIE C,15	;END OF LINE?
	AOJA T1,MOVLIN	;KEEP COUNT
	MOVEI ALTP,1(PNTR)	;GET POINTER TO SECOND LINE
	HRLI ALTP,(<POINT 7,0,6>)
ATRN1:	ILDB C,ALTP
	IDPB C,T2
	ADDI T1,1
	CAIL T1,MXWPL*5+6	;CHECK SIZE
	JRST LTLER
	CAIE C,12
	JRST ATRN1	;NOT DONE YET
	EXCH T2,(P)	;SAVE OUTPUT POINTER AND GET OLD ALTP BACK
	SUBI ALTP,-1(PNTR)	;GET OLD COUNT OF SECOND LINE
	PUSH P,ALTP	;AND SAVE IT
	MOVEI C,15	;FINISH CURRENT LINE
	DPB C,T2
	MOVEI C,12
	IDPB C,T2
	MOVEI C,0
INSC2:	TLNN T2,760000
	JRST INSC3	;FILL WITH NULLS
	IDPB C,T2
	JRST INSC2
INSC3:	SUBI T2,LIBUF-1	;GET COUNT
	HRRZM T2,NCNT
	PUSHJ P,FINDB	;BACK UP TO POINT TO IT
	PUSHJ P,INSED
	PUSHJ P,FINDN
	PUSHJ P,FILLB
	POP P,OCNT	;OLD CONT
	HRRZS OCNT
	POP P,ALTP	;GET OUTPUT POINTER BACK
	SUBI ALTP,LIBUF2-1
	HRRZM ALTP,NCNT
	MOVE T1,[XWD LIBUF2,LIBUF]
	BLT T1,LIBUF+MXWPL+1
	PUSHJ P,INSED
	SETOM ALTFLG	;MARK AS NEED TO DO FILLB
	MOVE T1,NCNT	;GET THE COUNT JUST USED
	MOVEM T1,OCNT	;AND SET AS THE OLD COUNT
	MOVE ALTP,[POINT 7,LIBUF+1,13]	;SET UP
	SETZM ALTCNT
	OCRLF
	MOVE T1,LIBUF
	MOVEM T1,CLN	;SET UP CURRENT LINE
	TRNE	FL2,NONUMF	;SKIP IF NORMAL
	POPJ	P,
	JRST OUTSN	;AND PRINT NUMBER

LTLER:	RERROR LTL
	POP P,ALTP	;RESTORE ALTP
	SKIPA
ILCER:	RERROR NNN
	PUSHJ P,FINDB	;MOVE BACK TO RIGHT PLACE
ERCOR:	PUSH P,ALTCNT	;SAVE COUNT
	SETZM ALTCNT
	MOVE ALTP,[POINT 7,LIBUF+1,13]	;SET BACK TO START
	PUSHJ P,ALTCBS	;PRINT LINE NUMBER
	POP P,T2	;COUNT
	JUMPN T2,ALTSP	;AND SPACE OVER
	POPJ P,		;NO SPACES TO DO


ALTWD:	OFFRUB
ALTWD1:	PUSH P,T2	;SAVE COUNT IF ANY
	PUSHJ P,ALTWS	;SKIP OVER WORD
	ANDI T2,-1	;CLR FLAG IN CASE
	PUSHJ P,ALTSP	;SPACE CORRECTLY
	POP P,T2	;RESTORE COUNT
	SOJG T2,ALTWD1	;CONTINUE

;ROUTINE TO SKIP OVER NEXT WORD

ALTWS:	HRROI T2,0	;SET FLG AND COUNT
	MOVE T1,ALTP	;GET POINTER
	LDB T3,T1	;AND FIRST CHAR
	JRST .+2	;CHECK FOR CR & GO
ALTWS1:	ILDB T3,T1	;GET A CHARACTER
	CAIN T3,15	;DONE IF END OF LINE
ALTWS2:	POPJ P,
	MOVE T3,CTBL(T3);FETCH CHARATER TABLE ENTRY
	JUMPE T3,ALTWS4	;SKIP BLANKS ETC...
	ANDI T2,-1	;CLR FLAG
	JUMPG T3,ALTWS3	;SKIP LETTERS & NUMBERS
	TRNN FL2,QSEPF	;SEPARATORS
	TRNN T3,NSEPF	;TODAY
	POPJ P,		;REAL BREAK - QUIT!
ALTWS3:	AOJA T2,ALTWS1	;KEEP COUNT AND CONTINUE
ALTWS4:	JUMPL T2,ALTWS3	;FIRST BLNKS
	AOS T2
ALTWS5:	ILDB T3,T1
	CAIE T3,15	;QUIT ON CR
	SKIPE CTBL(T3)	;OR FIRST NON-BLANK
	POPJ P,
	AOJA T2,ALTWS5

ALTWX:	PUSHJ P,ALTWS	;SKIP WORD
	ANDI T2,-1	;CLR FLAG
	PUSHJ P,ALTDL	;DELETE CHARS
	MOVEI T2,0
	JRST ALTIN	;DO INSERT

ALTBS:	PUSHJ P,ALTBAK	;GET PREVIOUS CHAR
	JUMPE T3,ALTCBS	;JUMP IF DONE
	ONRUB
	MOVE C,T3
	PUSHJ P,OCHR
	SOS ALTCNT	;DECREASE COUNT
	SOJG T2,ALTBS	;MORE,MORE
	PUSHJ	P,FORCE
	POPJ P,

ALTCBS:	PUSHJ	P,FORCE		;FINISH BUFFER
	OFFRUB		;NO MORE RUB
	OCRLF
	TRNE	FL2,NONUMF	;MORE NONUMBER STUFF
	POPJ	P,
	MOVE T1,LIBUF	;ALSO PRINT SEQ NUM
	JRST OUTSN


ALTLN:	MOVEI T2,1000	;FINISH PRINTING THE LINE
	PUSHJ P,ALTSP
ALTLN1:	MOVE ALTP,[POINT 7,LIBUF+1,13]	;POINTER TO START
	SETZM ALTCNT	;RESET COUNT
	JRST ALTCBS	;AND PRETEND A BACKSPACE
;COMMON ROUTINES TO MAKE LINE BACKUP

ALTBAK:	CAMN	ALTP,[POINT 7,LIBUF+1,13]
	JRST	ALTRTZ		;RETURN ZERO IF AT BEGINNING
	ADD	ALTP,[POINT 0,0,28]
	TLNE	ALTP,(<1B0>)	;CHECK WORD OVERFLOW
	SUB	ALTP,[POINT 0,1,0]
	LDB	T3,ALTP		;GET CHAR
	POPJ	P,

ALTRTZ:	MOVEI	T3,0		;RETURN 0
	POPJ	P,

ALTBCS:	PUSH	P,ALTP		;SAVE PNTR
ALTBC1:	PUSHJ	P,ALTBAK	;PREV CHAR
	JUMPE	T3,APOPJ	;END OF LINE
	CAMN	T3,C		;MATCH?
	JRST	APOPJ		;YES: RETURN
	AOJA	T2,ALTBC1	;NO: COUNT AND CONTINUE

APOPJ:	POP	P,ALTP		;RESTORE PNTR
	POPJ	P,		;RETURN

ALTBDL:	MOVEM	ALTP,SVALTP	;SAVE PNTR
ALTBD1:	PUSHJ	P,ALTBAK	;BACK A CHAR
	JUMPE	T3,ALTBD2	;DONE IF NO MORE
	MOVE	C,T3		;FOR PRINTING
	TRNN	FL,EXTOG	;PRINT IF NON-EXPERT
	PUSHJ	P,ALTDPN
	SOS	ALTCNT		;(198) DECREMENT COUNTER FOR ^R
	SOJG	T2,ALTBD1
ALTBD2:	PUSHJ	P,FORCE		;FORCE PRINTING
	PUSH	P,ALTP		;SAVE NEW PNTR
	MOVE	T3,SVALTP	;GET SET TO MOVE LINE
ALTBD3:	LDB	C,T3
	DPB	C,ALTP		;MOVE CHAR
	JUMPE	C,APOPJ		;DONE IF ZERO
	IBP	T3		;ADVANCE PNTRS
	IBP	ALTP
	JRST	ALTBD3

SUBTTL THE / COMMAND
SET:	PUSHJ	P,SCAN		;GET THE THING TO SET TO
	CAIN	C,"?"		;IF ITS ?, GIVE LIST
	JRST	GVSTSW		;OF SETTABLE SWITCHES
	TRNN	FL,IDF		;MUST BE AN IDENT
	NERROR	ILC
	PUSHJ	P,DOSET		;CALL SUBROUTINE TO DO SET COMMAND
	NERROR	ILC		;ERROR RETURN
	JRST	COMND		;OK RETURN

DOSET:	PUSHJ	P,XCODE		;FETCH DISPATCH ARG
	TLZ	T1,477777	;CLEAR GIVE ADDRS
	PUSH	P,T1		;SAVE DISPATCH
	TLNN	FL2,INPARS	;SKIP TERM CHECK IF PARSE
	PUSHJ	P,SCAN		;AND CHECK FOR TERMINATOR
	CAIE	C,":"		;COLON OK ALSO
	CAIN	C,200		;IS IT AN ESC?
	JRST	SETVAR		;YES: SET SOMETHING
	POP	P,T1		;GET DISPATCH ADDR
	TLNN	T1,(1B1)	;BETTER NOT REQUIRE ARG
	PUSHJ	P,CKTERM	;CHECK LEGAL TERM
	POPJ	P,
	HRRZ	T1,T1
	JUMPE	T1,CPOPJ
	PUSHJ	P,0(T1)		;DO ROUTINE
	JRST	CPOPJ1		;GIVE OK RETURN

SETM33:	TRZA	FL,M37F		;MODEL 33
SETM37:	TRO	FL,M37F
	POPJ	P,

CLRSEQ:	TDZA	T1,T1
SETSEQ:	MOVNI	T1,1
	MOVEM	T1,UNSEQF
	POPJ	P,

;**;[250]  Change 1 line at SETRED:			DML	10-JUN-83
SETRED:	TLNN	FL2,INPARS!INOPTF  ;[250] ILLEGAL IF NOT INITIAL OR OPTION FILE
	NERROR	ILC
	TRO	FL,READOF
	POPJ	P,

SETDPY:	POPJ	P,		;NO-OP NOW

QON:	TLZA	FL,QMODF
QOFF:	TLO	FL,QMODF
	POPJ	P,

SETDCD:	TLOA	FL2,PDECID
CLRDCD:	TLZ	FL2,PDECID
	POPJ	P,

SETOLD:	MOVEI	T1,1
	JRST	STOBAK
CLRBAK:	TDZA	T1,T1
SETBAK:	MOVNI	T1,1
STOBAK:	MOVEM	T1,BAKF
	POPJ	P,

QSON:	TROA	FL2,QSEPF
QSOFF:	TRZ	FL2,QSEPF
	POPJ	P,

SETNOV:	TRZA	FL,EXTOG
SETEXP:	TRO	FL,EXTOG
	POPJ	P,

SETUPP:	TDZA	T1,T1
SETLOW:	MOVEI	T1,40
	MOVEM	T1,CASEBT
	POPJ	P,

SETNUM:	TRZA	FL2,NONUMF
CLRNUM:	TRO	FL2,NONUMF
	POPJ	P,
SETVAR:	TLNN	FL2,INPARS
	JRST	SETV0		;SKIP OVER EXTRA IF NOT PARSE
	TRZ	FL,F.LAHD	;CLEAR LOOK-AHEAD
	SETZM	SAVCHR		;...
	SETZM	SAVC		;...
SETV0:	MOVE	T3,0(P)		;GET WHAT TO DO
	TLNN	T3,(1B1)	;NEED ARG
	JRST	SETV2		;NO: ERROR
	TLNN	T3,(1B2)	;NEED NUMERIC ARG?
	JRST	SETV1		;NO: JUST DISPATCH
	PUSHJ	P,SCAN		;GO GET NUMBER
	TRNN	FL,NUMF		;IS IT?
	JRST	SETV2		;NOPE - LOSE
	TLNE	FL2,INPARS
	JRST	SETV1		;SKIP TERM CHECK IN PARSE
	PUSH	P,T2		;SAVE IT
	PUSH	P,T1		;IN BINARY AND ASCII
	PUSHJ	P,SCAN		;CHECK FOR TERMINATOR
	POP	P,T1	;GET BACK ASCID
	POP	P,T2	;BINARY
	PUSHJ	P,CKTERM	;WHICH HAD BETTER BE THERE
	JRST	SETV2
SETV1:	POP	P,T3		;GET DISPATCH
	HRRZ	T3,T3
	JUMPE	T3,CPOPJ
	PUSHJ	P,0(T3)		;DISPATCH
	JRST	CPOPJ1		;AND RETURN TO CMD LOOP

SETV2:	POP	P,0(P)		;PRUNE PDL
	POPJ	P,		;AND GIVE ERROR RETURN

SETPLN:	MOVEM	T2,PLINES	;PLINES FOR P
	POPJ	P,

SETINC:	MOVEM	T1,INCR		;PERM INCREMENT
	MOVEM	T1,TECINC	;SETUP OTHER INCR
	POPJ	P,

SETSAV:	MOVEM	T2,SSAVEN	;STORE IN RESET PLACE TOO
	MOVEM	T2,SAVEN
	POPJ	P,

SETISV:	MOVEM	T2,SISAVN
	MOVEM	T2,ISAVEN
	POPJ	P,
IFN PPNTSW,<
SETLEN:	MOVEM	T2,PAGESZ
	POPJ	P,
>
;ROUTINES TO INPUT PASSWORDS

IFN CRYPSW,<

SETPAS:	TLNN FL2,INPARS		;MUST BE IN PARSE
	NERROR ILC
	CALL NOECHO		;TURN OFF ECHO
	SETZM ORGCOD		;INIT TO NULL
	SETZM NEWCOD		; CODES
	HRROI T3,[ASCIZ "INPUT PASSWORD: "]
	CALL GETPAS		;GET A PASSWORD
	 JRST [	OUTCHR ["-"]
		JRST SETPS1]	;ESC TYPED - NO PASSWORDS
	MOVEM T1,ORGCOD		;SAVE ORG SEED
	HRROI T3,[ASCIZ "OUTPUT PASSWORD: "]
	CALL GETPAS
	 JRST [	OUTSTR [ASCIZ "(SAME AS INPUT)"]
		MOVE T1,ORGCOD	;SAME AS INPUT IF ESC TYPED
		JRST .+1]
	MOVEM T1,NEWCOD		;SAVE NEW SEED
SETPS1:	OCRLF			;OUTPUT CRLF
	JRST DOECHO		;RESTORE ECHO

GETPAS:	PUSH P,T3		;SAVE MSG
GETPS1:	MOVE T3,0(P)		;GET MESSAGE TO PRINT
	OCRLF			;OUTPUT CR
	OUTSTR (T3)		;PRINT PROMPT
	HRROI T1,CODBUF		;POINT TO CODE BUFFER
	MOVE T2,[RD%BRK!RD%BEL+^D39]
	RDTTY
	 FJERR
	TLNN T2,(RD%BTM)	;VALID BREAK?
	JRST GETPS1
	POP P,T3		;RESTORE T3
	LDB T1,[POINT 7,CODBUF,6]
	CAIN T1,33		;SEE IF FIRST CHAR IS ESCAPE
	RET			;YES - RETURN NOW
	HRROI T1,CODBUF		;POINT TO STRING
	CALL CRASZ.##		;GET A SEED INTO T1
	JRST CPOPJ1
>
SETNAM:	MOVEI	ALTP,NEWBLK
	MOVSI	T1,(GJ%FOU!GJ%MSG!GJ%CFM);OUTPUT FILE
;**;[247]	Insert 1 line after SETNAM:+1		DML	23-NOV-82
	TLO	FL2,EXCPFL	;[247] SET FLAG AS IF ITS A COPY
	CALL	READNM		;GET FILE SPEC
	  JRST	CKIND		;ERROR - MSG PRINTED
;**;[247]	Change 1 line at SETNAM:+4		DML	23-NOV-82
	  JRST	CTLUAB		;[247] ^U RETURN
	CALL	CKTERM		;GRNTEE EOL
	  NERROR ILC		;SORRY FOLKS
	TRO	FL,NEWFL	;NEW FILE NAME SEEN
	PJRST	RLSRET		;RELEASE AND RETURN

SETRUN:	MOVEI	ALTP,RUNBLK	;DATA FOR NEW RUN SPEC
	MOVSI	T1,(GJ%OLD!GJ%CFM) ;EXISTING FILE
	HRROI	T2,[ASCIZ "EXE"] ;DEFAULT EXTN
;**;[247]	Insert 1 line after SETRUN:+2		DML	23-NOV-82
	TLO	FL2,EXCPFL	;[247] SET FLAG AS IF ITS A COPY
	CALL	READNE		;GET SPEC
	  JRST	[TLNN	FL2,INPARS!INOPTF	;ERROR, FROM TTY INPUT?
		 JRST	CKIND		;YES
		 POPJ	P,]		;NO, JUST RETURN
;**;[247]	Change 1 line at SETRUN:+7		DML	23-NOV-82
	  JRST	CTLUAB		;[247] ^U TYPED
	TLNE	FL2,INOPTF	;IN OPTION FILE?
	  JRST	[MOVE	T1,OPTJFN	;YES, GET JFN
		 BKJFN			;BACK UP TO PREVIOUS CHAR
		 JFCL			;LOSE
		 PUSHJ	P,GNCH		;READ IT
		 TLNE	CS,TERM_16	;END OF LINE?
		 IORI	FL,TERMF	;YES, REMEMBER THAT
		 JRST	.+1]		;BACK TO MAIN CODE
	CALL	CKTERM		;GRNTEE EOL
	 NERROR	ILC
RLSRET:	MOVE	T1,JFN(ALTP)	;JFN
	RLJFN			;RELEASE  IT NOW
	  JFCL
	RET			;EXIT

;ROUTINE TO CHECK PROPER TERMINATION

CKTERM:	TLNE	FL2,INOPTF	;CHECK IF OPTION FILE
	JRST	CKTRM1
	TLNE	FL2,INPARS	;SEE IF CMD STRING
	JRST	CPOPJ1		;ALWAYS SAY PROPER TERM - PARSE WILL CHECK
CKTRM0:	TRNE	FL,TERMF	;PROPER LINE TERM?
	AOS	(P)		;YES
	POPJ	P,		;NON-SKIP IF NO

CKTRM1:	CAIE	C,"/"		;ALLOW SPECIAL CHARS
	CAIN	C,","		;IF IN OPTION FILE
	JRST	CPOPJ1
	CAIN	C,"-"		;IF NO SPEC CHRS FOUND
	JRST	CPOPJ1
	JRST	CKTRM0		;ALSO CHECK EOL

;HANDLE OPTION FILES

SETOPT:	PUSHJ	P,SCAN		;GET OPTION REQUESTED
	TRNE	FL,IDF		;CHECK FOR IDENT
	SKIPN	T1,ACCUM	;AND NON-ZERO ATOM
	NERROR	ILC
	MOVEM	T1,OPTION	;SET UP OPTION
	TLNE	FL2,INPARS	;INITIAL
	JRST	OPTSWT		;YES: USE SPECIIAL ROUTINE
	PUSHJ	P,SCAN		;CHECK TERM
	PUSHJ	P,CKTERM
	NERROR	ILC		;LOSE
	PUSHJ	P,DOOPT
	JRST	SETOP1		;NOT FOUND
	JRST	SETOP2		;GROSS ERROR
	POPJ	P,		;OK RETURN

SETOP1:	OUTSTR	[ASCIZ /? Option not found
/]
	POPJ	P,
SETOP2:	OUTSTR	[ASCIZ /? Syntax error in option file
/]
	POPJ	P,

SETSTP:	MOVEM	T1,TECINC	;SET UP INCRS
	MOVEM	T1,INCR
	POPJ	P,

SETFST:	MOVEM	T1,TECFST	;SET UP START
	POPJ	P,

SETNPG:	CAIG	T2,MAXPAG	;CHECK BOUNDS
	CAIGE	T2,MINPAG
	MOVEI	T2,DEFPAG	;USE DEFAULT IF NG
	MOVEM	T2,NPAGS	;SET WINDOW
	RET			;RETURN

SUBTTL = COMMAND

GIVE:	PUSHJ P,SCAN	;FIND OUT WHAT HE WANTS TO KNOW
	CAIN C,"."	;CURRENT LINE/PAGE?
	JRST GVDOT	;YES
	CAIN	C,"?"	;LIST OF PRINTABLE SWITCHES?
	JRST	GVPRSW	;YES
	TRNN FL,IDF	;IF NOT, MUST BE AN IDENT
	NERROR ILC
	PUSHJ P,XCODE	;FETCH ACTUAL SIXBIT ARG
	HLRZ	T1,T1		;GET GIVE ADDRS
	TRZ	T1,3B20		;CLEAR FUNNY BITS
	JUMPE	T1,XERR
	PUSH	P,T1		;SAVE DISPATCH
	PUSHJ P,SCAN	;CHECK FOR TERM
	TRNN FL,TERMF
	NERROR ILC
	POP P,T1	;NOW FIND OUT WHAT HE WANTS
	PUSHJ	P,0(T1)		;GIV INFO
	JRST	COMND		;AND RETURN

GIVBIG:	TRNE FL,BGSN	;HAVE WE SEEN THAT PAGE
	JRST GVBG1	;YES, ALL IS OK
	MOVSI T1,1	;WILL HAVE TO SEARCH FOR IT
	MOVEM T1,DPG
	MOVEI SINDEX,0
	PUSHJ P,FIND
	TRNN FL,BGSN	;SHOULD HAVE SEEN IT NOW
	ERROR ICN	;WE ARE IN TROUBLE
GVBG1:	MOVE T1,BGPG	;GET IT
GIV2:	MOVEI T3,OCHR	;ROUTINE FOR DECIMAL PRINTER TO OUTPUT TO
	PUSHJ P,DECPR	;PRINT DECIMAL
GIV3:	PUSHJ	P,FORCE		;FORCE OUTPUT
GIV1:
	OCRLF
	POPJ	P,

GVCASE:
	MOVE T1,DTYPE		;TERMINAL TYPE CODE
	OUTSTR @TTYPE(T1)
	OUTCHR [" "]
	TLNE FL,QMODF
	OUTSTR [ASCIZ /C64 /]
	TRNE FL2,QSEPF
	OUTSTR [ASCIZ /Separators /]
	MOVEI T1,[ASCIZ /Lower
/]
	SKIPN CASEBT
	MOVEI T1,[ASCIZ /Upper
/]
	;PRINT CURRENT CASE
	OUTSTR @T1
	POPJ	P,
GIVER:	SKIPN	T1,SVERN
	SKIPA	T1,[-1,,[ASCIZ "No previous error."]]
	HRRO	T1,ETBL-1(T1)	;LONG FORM OF MSG
	PSOUT			;DUMP IT
	OCRLF
	RET
IFN PPNTSW,<
GVPG:	MOVE T1,PAGESZ
	JRST GIV2
>
GVPLN:	MOVE	T1,PLINES
	JRST	GIV2

GVSAV:	SKIPGE	T1,SAVEN	;SAVE LEFT
	MOVEI	T1,0
	JRST	GIV2
GVISAV:	SKIPGE	T1,ISAVEN	;ISAVE LEFT
	MOVEI	T1,0
	JRST	GIV2

GIVDCD:	TLNN	FL2,PDECID
	OUTSTR	[ASCIZ "No "]
	OUTSTR	[ASCIZ "auto decide
"]
	POPJ	P,

GIVBAK:	SKIPN	BAKF
	OUTSTR	[ASCIZ "No "]
	OUTSTR	[ASCIZ "backup file will be created
"]
	POPJ	P,

GIVSEQ:	SKIPE	UNSEQF
	OUTSTR	[ASCIZ "No "]
	OUTSTR	[ASCIZ "sequence numbers will be on output file
"]
	POPJ	P,
GVINC:	MOVE T1,INCR	;GET CURRENT INCREMENT
	PUSHJ P,OUTSN	;GO PRINT IT
	JRST GIV1	;AND A CRRET

GVDOT:	PUSHJ	P,SCAN		;SEE IF A TERMINATOR IS THERE
	TRNN	FL,TERMF
	NERROR	ILC		;NO TERMINATOR
	MOVE	T2,CLN		;GET CURRENT LINE
	MOVE	T1,CPGL		;AND CURRENT PAGE
GVDOT1:	MOVEM	T2,LINOUT
	OUTSTR	LINOUT		;PRINT IT
	PUSHJ	P,GIV2		;PRINT PAGE
	JRST	COMND		;AND RETURN

OCTPR:	SKIPA CS,[^O10]
DECPR:	MOVEI CS,^D10
RDXPR:	IDIVI T1,0(CS)
	HRLM T2,(P)
	SKIPE T1
	PUSHJ P,RDXPR
	HLRZ C,(P)
	ADDI C,"0"
	JRST (T3)	;EXCEPT HAS ARBITRARY OUTPUT ROUTINE

GVSTR:	MOVEI T1,SRPNT	;GET THE POINTER TO POINTER BLOCK
	HRLI T1,-SRNUM	;SET COUNT
	OUTSTR [ASCIZ /	Find:
/]
	PUSHJ P,GVSTR3
	MOVEI T1,R2PNT
	HRLI T1,-SRNUM
	OUTSTR [ASCIZ /	Substitute:
/]
	PUSHJ P,GVSTR3
	MOVEI T1,R1PNT
	HRLI T1,-SRNUM
	OUTSTR [ASCIZ /	For:
/]
	PUSHJ P,GVSTR3
IFN EXTEND,<
	OUTSTR [ASCIZ /	Line-contents:
/]
	MOVEI T4,0
	MOVEI T5,LSNUM
	MOVEI T3,OCHR
GVST1:	MOVEI T1,1(T4)
	PUSHJ P,DECPR
	MOVEI C,":"
	PUSHJ P,OCHR
	PUSHJ	P,FORCE
	OCRLF
	MOVEI T1,-1(T5)
	IMULI T1,SRNUM
	ADDI T1,LSPNT
	HRLI T1,-SRNUM
	PUSHJ P,GVSTR3
	ADDI T4,1
	SOJG T5,GVST1
>
	POPJ	P,

GIVFST:	MOVE	T1,TECFST	;GET CURRENT START
	PUSHJ	P,OUTSN		;PRINT IT
	JRST	GIV1		;CRLF AND RETURN

GIVSTP:	MOVE	T1,TECINC	;GET INPUT INCR
	PUSHJ	P,OUTSN		;PRINT
	JRST	GIV1		;AND RETURN

GIVLOC:	MOVE	T2,BUFP		;GIVE HIM FIRST LOC IN BUFFER
	SKIPN	T2,0(T2)	;IF ANYTHING THERE
	MOVE	T2,[ASCII /00000/]
	MOVE	T1,OPG		;OUTPUT PAGE -1
	AOJA	T1,GVDOT1

GIVNPG:	SKIPGE	T1,NPAGS	;GET SIZE
	MOVEI	T1,DEFPAG	;DEFAULT IF NONE
	JRST	GIV2		;DECIMAL # AND EXIT
GVSTR3:	SKIPN T2,(T1)	;IS THERE ONE THERE?
	POPJ P,		;NO, DONE
GVSTR2:	ILDB C,T2	;NEXT CHR
	JUMPE C,GVSTR1	;DONE
	PUSHJ P,OCHR	;PRINT IT
	JRST GVSTR2	;AND CONTINUE
GVSTR1:	PUSHJ	P,FORCE		;CLEAR OUTPUT DEVICE
	OCRLF
	AOBJN T1,GVSTR3	;IF THERE IS ONE
	POPJ P,

GVNAM:	MOVEI	T4,ORGBLK
	SKIPE	NEWFIL		;NEW NAME GIVEN?
	MOVEI	T4,NEWBLK	;YES - USE IT
GVNM1:	OUTSTR	ASZ(T4)		;DUMP STRING
	JRST	GIV1

GVRUN:	SKIPN	RUNFIL		;NEW NAME GIVEN?
	JRST	GVRUN1		;NO - JUST TELL HIM OLD INFO
	MOVEI	T4,RUNBLK	;YES - USE NEW INFO
	JRST	GVNM1		;PRINT & RETURN

GVRUN1:	OUTSTR	[ASCIZ "Last LOAD class command"]
	JRST	GIV1

; Give location of next insert

GVPLAC:	MOVE	T1,CURINS	;GET LINE NUMBER WHERE I STARTS
	MOVEM	T1,LINOUT	;PUT IN LINE NO. OUTPUT LOC.
	OUTSTR	LINOUT		;OUTPUT LINE NUMBER AND SLASH
	MOVE	T1,IPG		;GET CORRESPONDING PAGE NUMBER
	JRST	GIV2		;OUTPUT NUMBER AND FORCE OUTPUT

; Give the names of all the switches

GVPRSW:	SETZ	T5,		;We are giving print switches
	SKIPA
GVSTSW:	SETO	T5,		;We are giving settable switches
	PUSHJ	P,SCAN	;See if a terminator is there
	TRNN	FL,TERMF
	NERROR	ILC		;If not, it's illegal
	MOVEI	T1,NAMASC	;Get beginning of name table
	MOVEI	T2,NAMLEN	;Get its negative length
	MOVEI	T3,NAMDSP	;Get loc of dispatch table
GVSW:	JUMPE	T5,GVSW1	;If giving print switches, jump
	HRRZ	T4,(T3)		;Retrieve set bits
	SKIPA
GVSW1:	HLRZ	T4,(T3)		;Retrieve print bits
	PUSH	P,T5		;Save T5 on stack
	MOVE	T5,(T1)		;Obtain the address of string
	JUMPE	T4,NOSW		;If they are 0, no print
	OUTSTR	(T5)		;Print what's pointed to
	OCRLF			;And a <CR><LF>
NOSW:	AOS	T1		;Increment the pointers
	AOS	T3		;Continue
	POP	P,T5		;Restore T5
	SOJG	T2,GVSW		;Do another switch
	JRST	COMND		;Then finish

COMMENT ! THIS HERE IS THE UNIQUE INITIAL SEGMENT DECODER
   STOLEN FROM THE PDP10 T-S MONITOR (SEE COMCON).
   IT TAKES THE ARGUMENT IN LOC 'ACCUM' AND RETURNS THE
   FULL SIXBIT VALUE IN SAME. !

DECODE:
	MOVE T1,ACCUM		;FETCH ARG
	MOVNI T2,1		;SET MASK ALL ONES
	LSH T2,-6		;CLEAR OUT ONE MORE CHAR
	LSH T1,6		;SHIFT 1 COMMAND CHAR OFF
	JUMPN T1,.-2		;LUP UNTIL ALL GONE
	EXCH T2,ACCUM		;FETCH ARG IN T2 & SAVE MASK
	MOVNI T3,1		;CLEAR FOUND COUNT
LUP:	MOVE T4,@S1		;FETCH TABLE ENTRY
	TDZ T4,ACCUM		;MASK OUT CHARS NOT TYPED
	CAMN T2,@S1		;EXACT MATCH?
	JRST FOUND		;YES: THIS IS IT
	CAME T2,T4		;CLOSE MATCH?
	JRST LNEXT		;NO: KEEP TRYING
	AOJG T3,LNEXT		;FIRST TIME?
	HRRZ T5,S2		;YES: REMBER INDEX

LNEXT:	AOBJN S2,LUP		;NO: KEEP LOOKING
	SKIPN T3		;FIND ONLY ONE?
	MOVE S2,T5		;YES: OK TO USE SAVED VALUE
FOUND:	POPJ P,			;RETURN

XCODE:	PUSH	P,S1		;SAVE SPECIAL ACS
	PUSH	P,S2
	MOVE	S1,[S2,,NAMTAB]
	MOVSI	S2,-NAMLEN
	PUSHJ	P,DECODE
	MOVE	T1,NAMDSP(S2)	;GET DISPATCH ENTRY
	POP	P,S2		;RESTORE SPECIAL ACS
	POP	P,S1
	POPJ	P,
;THIS IS THE FULL NAME TABLE

	DEFINE NAMES <
X	(BAK,SETBAK,GIVBAK,0)
X	(BIG,0,GIVBIG,0)
X	(C128,QON,0,0)
X	(C64,QOFF,0,0)
X	(CASE,0,GVCASE,0)
X	(DECIDE,SETDCD,GIVDCD,0)
X	(DPY,SETDPY,0,0)
X	(ERROR,0,GIVER,0)
X	(EXPERT,SETEXP,0,0)
X	(INCREMENT,SETINC,GVINC,XNUMF)
X	(INSERT,0,GVPLAC,0)
X	(ISAVE,SETISV,GVISAV,XNUMF)
   IFN PPNTSW,<
X	(LENGTH,SETLEN,GVPG,XNUMF)>
X	(LOCATION,0,GIVLOC,0)
X	(LOWER,SETLOW,0,0)
X	(M33,SETM33,0,0)
X	(M37,SETM37,0,0)
X	(NAME,SETNAM,GVNAM,XVARF)
X	(NOBAK,CLRBAK,0,0)
X	(NODECIDE,CLRDCD,0,0)
X	(NONSEPARATORS,QSOFF,0,0)
X	(NONUMBER,CLRNUM,0,0)
X	(NOVICE,SETNOV,0,0)
X	(NUMBER,SETNUM,0,0)
X	(OLD,SETOLD,0,0)
X	(OPTION,SETOPT,0,XVARF)
   IFN CRYPSW,<
X	(PASSWORD,SETPAS,0,0)>
X	(PLINES,SETPLN,GVPLN,XNUMF)
X	(R,SETRED,0,0)
X	(READONLY,SETRED,0,0)
X	(RONLY,SETRED,0,0)
X	(RUN,SETRUN,GVRUN,XVARF)
X	(SAVE,SETSAV,GVSAV,XNUMF)
X	(SEPARATORS,QSON,0,0)
X	(SEQUENCE,CLRSEQ,GIVSEQ,0)
X	(START,SETFST,GIVFST,XNUMF)
X	(STEP,SETSTP,GIVSTP,XNUMF)
X	(STRING,0,GVSTR,0)
X	(UNSEQUENCE,SETSEQ,0,0)
X	(UPPER,SETUPP,0,0)
X	(WINDOW,SETNPG,GIVNPG,XNUMF)
>
	DEFINE	X(A,B,C,D) <
	EXP	<SIXBIT /A/>>

NAMTAB:
	NAMES

NAMLEN==.-NAMTAB

	DEFINE	X(A,B,C,D) <
	D+C,,B
>

XNUMF==3B20		;SET NEEDS NUMERIC ARG
XVARF==1B19		;SET NEEDS ARG

NAMDSP:
	NAMES

	XERR,,XERR

XERR:	NERROR	ILC

	DEFINE	X(A,B,C,D) <
	EXP	<[ASCIZ /A/]>>

NAMASC:
	NAMES
SUBTTL LIST COMMAND

LIST:	TRZ FL2,SUPN	;ASSUME WE ARE GOING TO LIST LINE NUMBERS
	SETZM LOLN	;FOR START OF PAGE
	PUSHJ P,SCAN	;GET SOME INFORMATION
	CAIE C,","	;IS THERE A SWITCH?
	JRST LIST9	;NO
	PUSHJ P,SCAN	;YES, SCAN FOR IT
	MOVS T1,ACCUM
	CAIE T1,(<SIXBIT /S  />)	;IS IT S?
	NERROR ILC	;NO, LOSE
	TRO FL2,SUPN	;YES, SUPPRESS LINE NUMBERS
	PUSHJ P,SCAN	;AND SCAN PAST IT
LIST9:	TRNN FL,TERMF	;JUST A TERMINATOR
	JRST LIST7	;NO, GO LOOK FOR A COMMAND STRING
	MOVEI T1,1	;LIST ENTIRE FILE
	MOVEM T1,LOPG
	MOVSI T1,1	;FROM 1 TO IMPOSSIBLY HIGH
	MOVEM T1,HIPG
	TRZ FL,CNTF	;MAKE SURE THAT THIS FLAG IS OFF
	JRST LIST8	;GO START WORK
LIST7:	PUSHJ P,GET2	;HAVE ALREADY SCANNED, GET 2 NUMBERS
	CAIE C,","	;IS THERE A SWITCH?
	JRST LIST10	;NO
	PUSHJ P,SCAN	;YES, SCAN FOR IT
	MOVS T1,ACCUM
	CAIE T1,(<SIXBIT /S  />)	;IS IT S?
	NERROR ILC	;NO, LOSE
	TRO FL2,SUPN	;YES, SUPPRESS LINE NUMBERS
	PUSHJ P,SCAN	;AND SCAN PAST IT
LIST10:	TRNN FL,TERMF	;END OK?
	NERROR ILC
LIST8:	TRZ FL,LINSN	;NONE SEEN YET
	MOVE	T2,[POINT 7,LIBUF2] ;GRAB A RANDOM BUFFER
	SKIPA	T1,[POINT 7,[ASCIZ "LPT:"]]
	IDPB	T3,T2		;STASH CHAR
	ILDB	T3,T1		;GET CHAR
	JUMPN	T3,.-2		;STORE IF NON-NULL
	SKIPN	T1,NEWFIL	;NEW FILE NAME?
	MOVE	T1,ORGFIL	;NO - USE ORIGINAL
	HRLI	T1,(POINT 7,,)	;MAKE BP
;**;[252]  Add 3 lines before STUFF:+0			DML	24-JUL-84
	ILDB T3,T1		;[252] Get a byte
	CAIE T3,">"		;[252] Past directory delimiter in filespec?
	JRST .-2		;[252] No, continue scan
STUFF:	ILDB	T3,T1		;GET A BYTE
	IDPB	T3,T2		;STUFF IT INTO BUFFER
	CAIE	T3,"."		; UNTIL . IS SEEN
	JRST	STUFF		;
	MOVE	T1,[POINT 7,[ASCIZ "LPT"]] ;EXTN
	ILDB	T3,T1		;GET A BYTE
	IDPB	T3,T2		; AND STUFF INTO LIBUF2
	JUMPN	T3,.-2		;LOOP TILL NULL
	HRROI	T2,LIBUF2	;PTR FOR GTJFN
	MOVSI	T1,(GJ%FOU!GJ%SHT)
	PUSHJ	P,GTJFNX	;GET LPT JFN
	  JERROR		;LOSSAGE
	MOVE	T2,[7B5+OF%WR]	;OPEN FOR WRITE
	OPENF			;...
	  JERROR		;MILD ANNOYANCE
	MOVEM	T1,LPTJFN	;SAVE JFN
	SETOM LOGPG	;LOGICAL PAGE TO 0
	MOVE T1,LOPG	;GET SET TO PRINT
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND	;GO FIND IT
	SETZM LSTCNT	;COUNT OF NUMBER OF LINES PER PAGE
LST2:	PUSHJ P,ONMOV	;CHECK RANGE
	JRST LST6	;FINISH UP
	TRO FL,LINSN	;YEP, WE HAVE SEEN ONE
	CAMN T1,PGMK	;CHECK FOR PAGE MARK AND HANDLE SPECIAL
	JRST LST4
	MOVEM T1,CLN	;THE CURRENT LINE
	MOVEI T2,0	;COUNT OF NUMBER OF CHRS SEEN
	SOSLE	LSTCNT		;CHECK TO SEE IF RUN OUT
	JRST	LST2A		;NO - PROCEED
	MOVEI	C,14		;OUTPUT A FORM-FEED
	PUSHJ	P,POCHR
	PUSHJ	P,HDPRNT	;GO PRINT HEADING
LST2A:	MOVE T1,PNTR	;GET THE POINTER
	TRNN FL2,SUPN	;DO WE WANT TO SUPPRESS LINE NUMBERS?
	JRST LST3A	;NO
	AOS T1		;YES, SKIP A WORD
	HRLI T1,(<POINT 7,0,6>)	;AND A CHARACTER
	ADDI T2,6	;AND TELL PEOPLE WE HAVE DONE SO
	JRST LST3	;BEFORE GOING ON OUR WAY
LST3A:	HRLI T1,(<POINT 7,0>)	;AND SET UP BYTE POINTER
LST3:	ILDB C,T1	;GET CHR
	CAIGE	C,11		;CHECK ALL SPECIAL CASES
	JRST	LST3B
	CAIGE	C,15
	JRST	SPHD
	CAIN	C,15
	JRST	LST5
	CAIE	C,"'"
	CAIGE	C,40
	JRST	LST3B
	CAIGE	C,140
	JRST	LST5
LST3B:	TLNE	FL,QMODF	;CHECK QUOTE MODE
	JRST	LST5
	PUSH	P,C
	MOVEI	C,"'"
	PUSHJ	P,POCHR
	ADDI	T2,1
	POP	P,C
	LDB	C,[POINT 7,CTBL(C),10]
LST5:	PUSHJ	P,POCHR		;PRINT IT
	AOJA	T2,LST3		;COUNT AND CONTINUE
SPHD:	CAIN C,12	;LINE FEED IS END OF LINE
	JRST	[PUSHJ P,POCHR	;PRINT IT
		PUSHJ P,FINDN	;GET NEXT
		JRST LST2]	;AND GO
	CAIN C,11	;COUNT SPECIAL FOR TAB
	JRST	[ADDI T2,10
		ANDCMI T2,7
		PUSHJ P,POCHR
		JRST LST3]
	CAIN C,14
	JRST	[PUSHJ P,POCHR	;FORM FEED GETS A HEADING
		PUSHJ P,HDPRNT
		JRST LST3]
	CAIN C,"\"	;NEEDS DELETE,DELETE
	JRST	[MOVEI C,177
		PUSHJ P,POCHR
		JRST LST5]	;AND AGAIN
	CAIE C,13	;VERT.TAB
	ERROR ICN	;CONFUSED
	PUSHJ P,POCHR
	MOVE T3,LSTCNT
	CAIG T3,<%LPP+2>/3
	JRST	[PUSHJ P,HDPRNT
		JRST LST3]
	CAIG T3,<2*<%LPP+2>>/3
	MOVEI T3,<%LPP+2>/3
	CAIL T3,<2*<%LPP+2>>/3
	MOVEI T3,<2*<%LPP+2>>/3
	MOVEM T3,LSTCNT
	JRST LST3

LST4:	MOVEI C,14	;PRINT A FORM FEED
	PUSHJ P,POCHR
	AOS T1,CPG	;GET PAGE CORRECTLY
	MOVEM T1,CPGL
	SETOM LOGPG	;ZERO LOGICAL PAGE AGAIN
	MOVEI T2,0	;THIS MUST BE ZERO SO GET IT THAT WAY
	PUSHJ P,HDPRNT	;PRINT A HEADER
	AOS LSTCNT	;INCREASE BY 1 TO MAKE IT COME OUT RIGHT
	PUSHJ P,FINDN	;ADVANCE
	JRST LST2	;AND CONTINUE

LST6:	MOVE	T1,LPTJFN	;RELEASE JFN
	CLOSF			;...
	  JERROR		;GRUMP
	SETZM	LPTJFN		;(222)CLEAR JFN STORAGE
	TRZ FL2,SUPN	;TURN THIS OFF SO * PRINTS
	TRNN FL,LINSN	;WERE ANY SEEN?
	NERROR NLN	;NO, ERROR
	MOVE T1,CPG	;SET UP PAGE
	MOVEM T1,CPGL
	JRST COMND	;AND GET MORE COMMANDS
POCHR:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2
	MOVE	T1,LPTJFN	;JFN FOR LPT
	MOVE	T2,C		;COPY CHAR
	BOUT			;DUMP IT
	JRST	POPRET		;PRUNE AND EXIT

HDPRNT:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2
	PUSH	P,T3
	MOVEI	T3,0		;INITIAL VALUE
	MOVE	T1,LPTJFN	;SET UP JFN
	TRNE	FL2,SUPN	;IF PRETTY PRINTING
	JRST	HDPR3		;WE DON'T REALLY WANT TO DO THIS
	HRROI	T2,[BYTE (7)15,11,11,11,0]
	SOUT			;DUMP STRING (POSITION)
	MOVE	T2,ORGFIL	;FILE STRING PNTR
	SOUT			;PRINT IT
	MOVEI	T2,11		;SEPARATE WITH A TAB
	BOUT
	MOVNI	T2,1		;POLISH OFF WITH DATE AND TIME
	ODTIM
	HRROI	T2,[ASCIZ "	Page "]
	SOUT			;PAGE HEADING
	MOVE	T2,CPG		;GET CURRENT PAGE
	MOVEI	T3,^D10		;RADIX TO USE
	NOUT			;PRINT
	  FJERR
	AOSG	T2,LOGPG	;SEE IF OK TO PRINT
	JRST	HDPR3
	MOVEI	T2,"-"
	BOUT			;OUTPUT SEPARATOR
	MOVE	T2,LOGPG
	NOUT			;DUMP MINOR PAGE #
	  FJERR
HDPR3:	MOVEI	T3,0		;RESTORE T3
	HRROI	T2,[BYTE (7)15,12,12]
	SOUT			;DUMP RET AND 2 LFDS
	MOVEI	T3,%LPP		;RESET LINE COUNT
	MOVEM	T3,LSTCNT
	MOVE	T3,-1(P)	;GET COPY OF CHAR COUNT
	JUMPE	T3,HDPXIT	;IF 0 THEN ALL OK
	MOVEI	T2," "		;PRINT CORRECT NUMBER OF SPACES
	BOUT
	SOJG	T3,.-1
HDPXIT:	POP	P,T3		;RESTORE REGS
	JRST	POPRET		;  AND EXIT

SUBTTL REPLACE COMMAND
;RE-TYPE (REPLACE) COMMAND

REPLAC:	SETZM	LOLN		;I REALLY SHOULD PUT THIS ELSEWHERE
	SETZM	PGDELS		;INIT PAGE DELETED COUNTER
	SETOM	ISVINC		;DO NOT LET I<CR> USE ISVINC
	TRNE	FL,READOF	;NOT PERMITTED IN READ ONLY
	NERROR	ILC
	PUSHJ	P,GET2S		;WHAT DO WE WANT TO REPLACE?
	TRZ	FL,LINSN	;CLR FOR NOW
	PUSHJ	P,INSINC	;GO GET INCR
	PUSHJ	P,DELSUB	;DELETE SOME STUFF
	SKIPN	T1,LOLN		;WHERE TO START INSERTING
	MOVE	T1,[<ASCII /00100/>!1]
	MOVEM	T1,HILN		;SET UP FOR INSERT CODE
	MOVE	T2,LOPG
	MOVEM	T2,HIPG		;...
	SKIPE	PGDELS		;OK IF NONE DELETED
	SKIPN	T1,(PNTR)	;OR AT EOF
	JRST	REPLC1
	CAME	T1,PGMK		;ALSO END OF PAGE
	CAMLE	T1,FDELLN	;OR REALLY IN ORDER
	JRST	REPLC1
	AOS	CPG		;INSERT PAGE MARK TO PREVENT INSANITY
	AOS	INPG		;ADJUST PAGE COUNTERS
	AOS	BGPG
	MOVE	T1,PGMK		;SET UP PAGE MARK TO INSERT
	MOVEM	T1,LIBUF
	MOVE	T1,PGMKW2
	MOVEM	T1,LIBUF+1
	SETZM	OCNT		;STUFF FOR INSED
	MOVEI	T1,2
	MOVEM	T1,NCNT
	PUSHJ	P,INSED		;PUT IT IN
	PUSHJ	P,FINDN		;CREEP PAST IT
	PUSHJ	P,FILLB		;IN CASE OVERFLOW
	OUTSTR	[ASCIZ /%Page mark inserted to prevent order error
/]
REPLC1:	PUSHJ	P,DOINS		;LET HIM TYPE FOR A WHILE
	JRST	COMND		;RETURN

;SUBROUTINE TO DELETE THE LINE POINTED TO BY PNTR

DODEL:	SETZM	NCNT		;NEW IS 0
	MOVEM	T1,LDELLN
	PUSHJ	P,GETLTH	;OLD LENGTH
	MOVEM	T1,OCNT
	AOS	DELCNT		;COUNT OF LINES DELETED
	SKIPE	FDELLN		;FIRST TIME HERE
	JRST	INSED		;NO: GO INSERT AND RETURN
	MOVE	T1,LDELLN	;YES: SET UP FIRST LINE ETC.
	MOVEM	T1,FDELLN
	MOVE	T1,CPG
	SUB	T1,PGDELS	;(225)IN CASE WE DELETED EMPTY PAGES BEFORE
	MOVEM	T1,FDELPG
	JRST	INSED		;AND GO INSERT

SUBTTL COMMON SEARCH ROUTINES FOR F AND S
COMMENT ! SOME COMMON ROUTINES FOR SEARCHING FILES!

COMMENT ! THIS ROUTINE GENERATES CODE FOR FINDING A MATCH
FOR THE FIRST CHARACTER OF A SEARCH STRING. THE POINTER
TO A SET OF BYTE POINTERS FOR SEARCH STRINGS IS IN T1 !



CODSR:	CALL CHKXCT	;(203) GET EXACT MATCH BIT SET UP
	MOVEI T2,CODEBF	;(203) SET UP POINTER TO PLACETO PUT CODE
	MOVEI ALTP,0	;THE NUMBER OF THE CURRENT STRING
	HRLI T1,-SRNUM	;THE NUMBER OF STRINGS
CODS5:	TLZ FL,NEGF!DEMCHR	;TURN OFF THE  SEEN FLAG
	MOVE T3,(T1)	;GET A POINTER
	JUMPE T3,ENDCOD	;A ZERO BYTE POINTER IS END OF CODE
READCD:	ILDB C,T3	;PICK UP A CHARACTER IN STRING
	JUMPE C,[TLNE FL,DEMCHR	;DID WE REALLY WANT ONE
		NERROR ISS	;YES, LOSE
		SUBI T2,2	;NO, ALWAYS MATCH
		JRST COMXCT]
;**;[249]  Add 2 lines after READCD:+4			DML	9-JUN-83
	TLNE FL,QMODF	;[249] ARE WE IN C128 MODE?
	JRST COMLET	;[249] NO, DO NOT TEST FOR SPECIAL CHARACTERS
	CAIN C,""	;ARBIRARY NUMBER OF SOMETHING
	JRST ARBCD
	CAIN C,24	;ANY CHARACTER
	JRST ANYCD
	CAIN C,""	;NOT THIS ONE
	JRST	[TLC FL,NEGF
		TLO FL,DEMCHR	;WE REALLY JEED IT
		JRST READCD]
	CAIN C,"|"	;SEPERATOR
	JRST SEPCD
	CAIN C,""	;QUOTE THE NEXT CHARACTER
	JRST QUOTE
COMLET:	MOVE CS,CTBL(C)	;GET THE MAJIC BITS
	TLNN FL2,EXACT	;(203) EXACT SEARCH?
	TLNN CS,LETF_16	;OR NOT A LETTER
	JRST NORMCR	;YES JUST THE TEST
	HRLI C,(<CAIE C,>)	;DO A CAIE
	MOVEM C,(T2)
	XOR C,[XWD 4000,40]	;CAIN .XOR. CAIE = 4000,,0
	MOVEM C,1(T2)
	TLNE FL,NEGF	; THAT CHR
	JRST GENSKP	;GENERATE A SKIPA
COMXCT:	MOVE C,[XCT JSPR]	;THE CALL TO SEARCH FURTHER
	DPB ALTP,[POINT 4,C,12]	;AC FIELD GIVES STRING NUMBER
	MOVEM C,2(T2)
	ADDI T2,3	;ADVANCE OUTPUT POINTER
ENDSTR:	ADDI ALTP,1	;NEXT STRING
	AOBJN T1,CODS5	;IF ANY
ENDCOD:	MOVE C,[JRST COMSRT]	;A RETURN
	MOVEM C,(T2)
	POPJ P,
SEPCD:	MOVE C,[SKIPG CS,CTBL(C)]	;GET BITS
	MOVEM C,(T2)
	MOVE C,[TRNE CS,NSEPF]	;CHECK FOR %,$,OR .
	TRNE FL2,QSEPF		;SEPARATORS?
	MOVSI C,(<SKIPA>)	;YES;
	MOVEM C,1(T2)
	TLNE FL,NEGF	;SKIPA IN NORMAL CASE
	JRST COMXCT
GENSKP:	MOVSI C,(<SKIPA>)
	MOVEM C,2(T2)
	AOJA T2,COMXCT	;SO XCT WILL GO IN RIGHT PLACE

QUOTE:	ILDB C,T3	;GET NEXT CHR
	JUMPE C,[NERROR ISS]	;END OF STRING IS ILLEGAL
	JRST COMLET	;TREAT AS NORMAL CHARACTER

NORMCR:	HRLI C,(<CAIN C,>)	;EXACT OR NOT LETTER
	TLNE FL,NEGF
	TLC C,4000		;CAIN .XOR. CAIE = 4000,,0
NORMC1:	MOVEM C,(T2)
	SOJA T2,COMXCT	;MAKE THE XCT GO IN RIGHT PL@CE

ANYCD:	MOVE C,[CAIE C,15]	;SPECIAL FOR EOL
	TLNE FL,NEGF
	TLC C,4000		;CAIN .XOR. CAIE = 4000,,0
	JRST NORMC1

ARBCD:	ILDB C,T3	;GET NEXT
	CAIN C,""	;JUST CHECK VALIDITY
	JRST ARBCD
	CAIN C,""
	ILDB C,T3
	JUMPE C,[NERROR ISS]	;END OF STRING ERROR
	JRST READCD	;LOOK FOR FIRST OTHER CHR

JSPR:	JSP T1,SRCRET	;CALL CONTINUE SEARCH


;READ INTHE STRING TO SEARCH FOR
;T3 HAS PLACE TO PUT POINTERS T1 A BYTE POINTER FOR STRINGS


SSTRNG:	MOVEI T2,SRBLG	;THE PERMISSIBLE LENGTH
	HRLI T3,-SRNUM	;T3 HAS POINTER TO PLACE BYTE POINTERS
SSTR0:	MOVEM T1,SVPT	;SAVE THE POINTER FOR END OF STRING
SSTR1:	PUSHJ P,GNCH	;GET A CHR
	CAIN C,200	;ALTMODE TERMINATES
	JRST SSTEND
	CAIN C,15	;IGNORE RETURNS
	JRST SSTR1
	CAIN C,12	;LINE FEED IS END OF ONE STRING
	JRST SSTR2
	IDPB C,T1	;PUT IN OUTPUT STRING
	SOJG T2,SSTR1
SSTR3:	RERROR STL	;THE STRING WAS TOO LONG
SSTR4:	HRLZ T1,T3	;ZERO OUT FIRST POINTER
	MOVNS T1
	ADDI T1,-SRNUM(T3)	;FIND START
	SETZM (T1)
	JRST COMND
SSTR2:	CAMN T1,SVPT	;NULL STRING?
	JRST	[HLRZ C,T3	;FIRST ONE?
		CAIE C,-SRNUM	;WELL?
		JRST .+1	;NO
		MOVEI C,12	;RETURN A LINE FEED
		POPJ P,]
RETSTR:	MOVEI C,0	;TERMINATE STRING WITH 0
	IDPB C,T1
	SOJLE T2,SSTR3
	MOVE C,SVPT	;SET UP POINTER
	MOVEM C,(T3)
	AOBJN T3,[MOVE C,FSFLG	;GET F/S PROMPT
		  MOVEM C,CRBUF	;TO ^R BUFFER
		  OUTSTR CRBUF	;DUMP PROMPT
		  JRST SSTR0]	;IF ROOM FOR MORE, GET THEM
	RERROR TMS	;TOO MANY GIVEN
	JRST SSTR4
SSTEND:	CAIN T2,SRBLG	;DID WE SEE ANY?
	POPJ P,		;NO, RETURN
	MOVEI C,0	;YES, TERMINATE LAST
	IDPB C,T1
	MOVE T1,SVPT
	MOVEM T1,(T3)	;SET POINTER
SSTR5:	AOBJP T3,CPOPJ1	;ZERO OUT OTHER POINTERS
	SETZM (T3)
	JRST SSTR5

CHKXCT:	TLZ FL2,EXACT	;(203) RESET EXACT MATCH BIT
	TLNN FL,EXCTS1!EXCTSR ;(203) EXACT MATCH WANTED?
	RET		;(203) NO, JUST RETURN
	TLNN FL2,SRCWHO	;(203) WHO CALLED US?
	JRST CHKXC1	;(203) SET MEANS SUBST
	TLNE FL,EXCTSR	;(203) DID SEARCH SET HIS BIT?
	TLO FL2,EXACT	;(203) YES
	RET		;(203) RETURN
CHKXC1:	TLNE FL,EXCTS1	;(203) DID SUBST SET HIS BIT?
	TLO FL2,EXACT	;(203) YES WANT EXACT MATCH
	RET		;(203) RETURN
;THE SEARCH ITSELF


COMSRC:	CALL CHKXCT	;(203) SET UP EXACT MATCH
	MOVEM T2,BUFSAV	;(203) SAVE THE POINTER TO STRINGS
	MOVNI T3,1	;THE COUNT OF HOW FAR INTO LINE WE ARE
	MOVEI ALTP,1(PNTR)	;SET BYTE POINTER
	HRLI ALTP,(<POINT 7,0,6>)
	MOVEI C,15	;START WITH A LINE DELIMITER
	JRST CODEBF	;GO SCAN
COMSRT:	ILDB C,ALTP	;WE RETURN HERE IF NO MATCH FOR THIS ONE
	CAIE C,15	;DONE?
	AOJA T3,CODEBF	;NO, GO ON
	POPJ P,		;YES, NON-MATCH RETUNR

SRCRET:	PUSH P,T1	;SAVE THE RETURN ADDRESS
	PUSH P,ALTP	;AND THE STRING POINTER
	PUSH P,C	;AND THE CHARACTER
	LDB T1,[POINT 4,-1(T1),12]	;GET STRING NUMBER
	ADD T1,BUFSAV	;POINT TO BYTE POINTER
	SKIPN T1,(T1)	;GET IT
	ERROR ICN	;THERE SHOULD BE ONE THERE
	MOVE T2,[POINT 7,ARBBUF]	;SET UP ARBIT MATCH
	MOVEI T4,MXWPL*^D10	;POINTER AND COUNT
	SETZM ARBCNT	;THE NUMBER OF ARBITRARY MATCHES SEEN
	TLZ FL,ARBITG	;OFF AT START
	PUSHJ P,LINMAT	;GO CHECK FOR MATCH
	JRST LOSE	;WE LOSE, CONTINUE SCAN
	MOVEM ALTP,SRCALP	;POINTER TO END OF STRING
	POP P,C	;RESTORE
	POP P,ALTP
	POP P,T1
CPOPJ1:	AOS (P)	;SKIP RETURN
	POPJ P,
LOSE:	POP P,C	;RESTORE
	POP P,ALTP
	POPJ P,	;AND CONTINUE SEARCH
NXTCHR:	CAIN C,12	;WAS THAT LAST OF LINE?
	POPJ P,	;YES, LOSE 
	ILDB C,ALTP	;NO, TRY NEXT
LINMAT:	PUSHJ P,CHRMAT	;CHECK FOR MATCH
	POPJ P,	;NONE, RETURN
	CAIE CS,0	;IS SO ALL DONE
	JRST NXTCHR	;NO, TRY MORE
	JRST CPOPJ1	;SKIP RETURN


CHRMAT:	TLZ FL,NEGF!DEMCHR	;NO  SEEN AND CHR CAN BE 0
READCH:	ILDB CS,T1	;GET NEXT
	JUMPE CS,MATCH	;END OF STRING IS USUALLY GOOD
;**;[249]  Add 2 lines after READCH:+1			DML	9-JUN-83
	TLNE FL,QMODF	;[249] ARE WE IN C128 MODE?
	JRST RDCH1	;[249] NO, SO DO NOT TEST FOR SPECIAL CHARACTERS
	CAIN CS,""	;CHEC FOR NEGATE
	JRST	[TLC FL,NEGF
		TLO FL,DEMCHR	;MUST BE FOLLOWED BY A CHR
		JRST READCH]
	CAIN CS,"|"	;SEPERATOR?
	JRST SEP
	CAIN CS,""	;ARBITRARY NUMBER
	JRST ARBIT
	CAIN CS,24	;ANY?
	JRST ANY
	CAIN CS,""	;QUOTE NEXT?
	JRST	[ILDB CS,T1
		JUMPN CS,.+1	;MUST HAVE ONE THERE
		NERROR ISS]	;ELSE ILLEGAL
;**;[249]  Change 1 line at READCH:+16			DML	9-JUN-83
RDCH1:	CAMN C,CS	;[249] ARE THEY THE SAME
	JRST ISTRU1	;YES, CHECK NEGF
	MOVE T5,CTBL(CS)	;GET BITS
	TLNN FL2,EXACT	;(203) EXACT SEARCH?
	TLNN T5,LETF_16	;OR NOT LET
	JRST ISFALS	;NO MATCH
	XORI CS,40	;CHECK OTHER CASE
	CAMN C,CS
	JRST ISTRU1
	JRST ISFALS	;LOSE
MATCH:	TLNE FL,DEMCHR	;DID WE NEED A CHARACTER THERE?
	NERROR ISS	;YES, ILLEGAL STRING
	JRST CPOPJ1	;OK RETURN

ANY:	CAIE C,15
	JRST ISTRU	;YES THIS IS ANY CHR
ISFALS:	CAIN C,15	;IS IT A RETURN
	AOSA T4	;ADJUST COUNT AND ENTER A NULL STRING
	IDPB C,T2	;SAVE IN ARBIT
	MOVEI T5,0
	IDPB T5,T2
	SUBI T4,2	;COUNT THEM
	JUMPLE T4,ILFMTR	;THIS LINE MUST HAVE ILLEGAL FORMAT
	AOS ARBCNT	;ONE MORE SEEN
ISFAL1:	TLNE FL,NEGF	;WAS NEG FLAG ON?
	AOS (P)	;YES, A MATCH
	POPJ P,

SEP:	MOVE T5,CTBL(C)		;GET TABLE ENT
	JUMPG T5,ISFALS		;NOT A SEP
	TRNN FL2,QSEPF		;CHECK . % $
	TRNN T5,NSEPF		;CHECKING - DO WE HAVE ONE?
	JRST ISTRU		;NO: SEP
	JRST ISFALS		;YES: NOT A SEP
ISTRU:	CAIN C,15
	AOSA T4
	IDPB C,T2	;SAVE CHR
	MOVEI T5,0
	IDPB T5,T2
	SUBI T4,2
	JUMPLE T4,ILFMTR
	AOS ARBCNT
ISTRU1:	TLNN FL,NEGF	;NEGATE?
	AOS (P)	;NO, MATCH
	POPJ P,

ILFMTR:	MOVE T2,CPG	;GIVE HIM AN ERROR MESSAGE AND PAGE
	PUSHJ P,PGPRN	;AND LINE
	MOVE T1,(PNTR)
	PUSHJ P,OUTSN
	NERROR ILFMT
ARBIT:	TLNN FL,NEGF	;THIS HAS NO MEANING
	TLOE FL,ARBITG	;ARE WE SEEING 
	NERROR ISS	;YES, ILLEGAL STRING
	PUSH P,T1	;SAVE SEARCH POINTER
	MOVEI T5,0	;SET ARBITRARY STRING TO NULL
	IDPB T5,T2
	SOJLE T4,ILFMTR
	AOS ARBCNT
	PUSH P,ARBCNT	;SAVE IN CASE WE COME BACK WITH NO MATCH
	PUSH P,T2
	PUSH P,T4
	PUSH P,C
CHKTHS:	TLO FL,DEMCHR	;NEED A CHARACTER NOW
	PUSHJ P,READCH	;CALL SELF RECURSIVELY
	JRST PROCED	;THIS COULD NOT MATCH JUST SCAN ON
	MOVE T2,-3(P)	;RESTORE ARBIT COUNT
	MOVEM T2,ARBCNT
	MOVE T4,-1(P)	;AND ARBIT CHR COUNT
	MOVE T2,-2(P)	;AND POINTER
	PUSH P,ALTP	;SAVE CHR POINTER
	TLZ FL,ARBITG	;CAN SEE ANOTHER  NOW
	PUSHJ P,LINMAT	;A MATCH
	JRST RECUR	;NO, TRY FOR ANOTHER OF THAT CHR
	SUB P,[XWD 7,7]	;GET ALL THAT JUNK OFF STACK
	JRST CPOPJ1 	;AND RETURN TO CALLER OF LINMAT
RECUR:	POP P,ALTP	;GET BACK POINTER
	POP P,C	;AND CHR
	MOVE T4,-2(P)	;RESTORE COUNT
	MOVEM T4,ARBCNT
	POP P,T4
	POP P,T2	;ALSO CHR COUNTER AND POINTER
	DPB C,T2	;PUT IN THAT CHR
	MOVEI T5,0	;AN@ TERMINATOR
	IDPB T5,T2
	SOJLE T4,ILFMTR
	PUSH P,T2
	PUSH P,T4	;RESAVE
	MOVE T1,-3(P)	;RESTORE SEARCH POINTER
	ILDB C,ALTP	;GET ANOTHER CHR
	PUSH P,C	;SAV IT
	TLZ FL,NEGF	;TURN THIS OFF FOR RECURSION
	CAIE C,12	;END OF WORLD?
	JRST CHKTHS
	SUB P,[XWD 5,5]	;RECUCE STACK
	POPJ P,	;AND ERROR RET
PROCED:	TLZ FL,ARBITG!NEGF	;JUST GO ON
	POP P,C
	POP P,T4
	POP P,T2
	POP P,ARBCNT
	POP P,(P)	;GET RID OF EXTRA POINTER
	JRST CHRMAT	;CONTINUE MATCH SCANNING


SUBTTL FIND COMMAND (SEARCHES)

;DO A SEARCH OF A FILE

SEARCH:	TLZ FL,ASSMF	;CLEAR ALL FLAGS
	TLO FL2,SRCWHO	;(203) SEARCH IS LOOKING
	SETZM LOLN	;JUST LIKE EVERYONE ELSE HAS TO
	SETZM SRCNT	;START WITH ZERO
	MOVE T1,[ASCII "F*"]
	MOVEM T1,FSFLG	;PROMPT FOR FIND CMD
	MOVE T1,[POINT 7,SRBUF]	;SET UP BYTE POINTER
	MOVEI T3,SRPNT	;AND POINTER TO BYTE POINTER TABLE
	PUSHJ P,SSTRNG	;GET A SEARCH STRING
	JRST	[SKIPN SRPNT	;WAS STRING SET?
		NERROR NSG	;NO, TELL HIM
		CAIN C,12
		JRST ASSMD1	;SPECIAL CONTINUE MODE
		JRST .+1]	;YES, USE OLD ONE
	TLZ FL,NUMSRF!ALTSRF!EXCTSR	;CLEAR FLAGS
	PUSHJ P,SCAN	;CHECK FOR WHAT COMES AFTER
	TRNN FL,TERMF	;IF TERMINATOR
	CAIN C,","	;OR ,
	JRST ASSMDT	;SET UP LIMITS SPECIALLY
	CAIE C,"!"
	CAIN C,":"
	JRST ASSMDT	;LET HIM SPECIFY 2ND HALF OF RANGE
	PUSHJ P,GET2	;ELSE CALL USUAL LIMIT ROUTINE
SRC4:	MOVE T1,HILN	;SAVE END OF RANGE
	MOVEM T1,SRHILN
	MOVE T1,HIPG
	MOVEM T1,SRHIPG
	CAIE C,","	;ANY MORE ARGUMENTS?
	JRST SRC1	;NO, CHECK TERMINATOR AND PROCEED
	PUSHJ P,SCAN	;YES, SEE WHAT IT IS
	TRNN FL,IDF	;SHOULD BE IDENT OR NUMBER
	JRST SRC2	;NOT IDENT, CHECK FOR NUMBER OF SEARCHES
	MOVS T1,ACCUM	;GET THE IDENT
	CAIN T1,(<SIXBIT /N  />)	;AND FIND OUT WHAT IT IS
	TLO FL,NUMSRF
	CAIN T1,(<SIXBIT /A  />)
	TLO FL,ALTSRF	;FIRST CHECK FOR A OR N
	TRNE FL,READOF	;IF READ ONLY AND ALTER
	TLNN FL,ALTSRF
	SKIPA
	NERROR ILC	;WE DO NOT PERMIT IT
	TLNN FL,NUMSRF!ALTSRF	;WAS IT EITHER?
	JRST SRC3	;NO, CHECK E
	PUSHJ P,SCAN	;CONTINUE LOOKING
	CAIE C,","
	JRST SRC1	;NO MORE ARGUMENTS
	PUSHJ P,SCAN	;WELL WHAT KIND IS THIS ONE?
	TRNN FL,IDF	;MORE IDENTS?
	JRST SRC2	;NO, MUST BE NUMBER OF SEARCHES
	MOVS T1,ACCUM
SRC3:	CAIE T1,(<SIXBIT /E  />)
	NERROR ILC	;NO, HE MUST HAVE MADE A MISTAKE
	TLO FL,EXCTSR	;YES, REMEMBER IT
	PUSHJ P,SCAN	;AND CHECK FOR MORE
	CAIE C,","
	JRST SRC1	;NO MORE
	PUSHJ P,SCAN	;ONLY ONE THING IT CAN BE NOW
SRC2:	TRNN FL,NUMF
	NERROR ILC	;NOPE, LOSE
	MOVEM T2,SRCNT	;SAVE AS COUNT OF LINES TO FIND
	PUSHJ P,SCAN	;GET TERMINATOR (WE HOPE)
SRC1:	TRNN FL,TERMF	;ALLS WELL THAT ENDS WELL
	NERROR ILC	;BUT THIS DOSNT
SRCH1A:	MOVEI T1,SRPNT	;GET POINTER TO STRINGS
	PUSHJ P,CODSR	;AND GENERATE CODE
	MOVE T1,LOPG	;GET SET TO HUNT IT
	MOVEM T1,DPG
	MOVEM T1,SRPG	;FLAG TO SAY IF WE SHOULD PRINT PAGE
	MOVE SINDEX,LOLN
	PUSHJ P,FIND
	TRZ FL,LINSN	;NO LINES YET
	SETZM FNDFLG	;NO MATCHES EITHER
ONSRC:	PUSHJ P,ONMOV	;CHECK RANGE
	JRST ENDSRC	;DONE
	TLZE FL,ASSMF	;FIRST TIME AND WANT .+1?
	JRST	[CAME T1,LOLN	;IS THERE EXACT MATCH?
		JRST .+1	;NO, THIS IS .+1
		AOS SVCNT	;PRETEND WE DIDNT SEE IT
		JRST SRNXT]	;AND TAKE NEXT
	TRO FL,LINSN	;WE SAW ONE
	CAMN T1,PGMK	;PAGES ARE SPECIAL
	JRST SRCPAG	;SO TAKE GOOD CARE OF THEM
	MOVEI T2,SRPNT	;POINTER TO STRINGS
	PUSHJ P,COMSRC	;GO SEARCH THIS LINE
	JRST SRNXT	;LOSER
	SETOM FNDFLG	;FOUND!
	MOVEM T3,SVCCNT	;SAVE AWAY THE CHARACTER COUNT
	MOVE T2,CPG	;GET CURRENT PAGE
	TRNN	FL2,NONUMF	;DON'T PRINT IF NONUMBER MODE
	CAMN	T2,SRPG		;SEE IF WE SHOULD PRINT IT
	SKIPA
	PUSHJ	P,PGPRN		;YES
	MOVE T2,CPG	;NOW SET IT AS CURRENT
	MOVEM T2,CPGL
	MOVEM T2,SRPG	;ALSO RESET FLAG
	MOVE T2,(PNTR)	;ALSO SET LINE
	MOVEM T2,CLN
	TLNE FL,ALTSRF	;ARE WE GOING TO EDIT?
	JRST SRCALT	;YES, GO SET THINGS UP
	TLNE FL,NUMSRF	;DO WE WANT ONLY LINE NUMBERS?
	JRST SRCNUM	;YES
	MOVE T1,PNTR	;GO PRINT LINE
	PUSHJ P,OUTLIN
SRNXTC:	SOSG SRCNT	;HAVE WE FOUND ENOUGH
	JRST SRFND	;YES, GIVE UP (WE HAVE SEEN AT LEAST ONE)
SRNXT:	PUSHJ P,FINDN	;GET NEXT LINE TO LOOK A
	JRST ONSRC
SRCNUM:	MOVE T1,(PNTR)	;PRINT SEQUENCE NUMBER
	PUSHJ P,OUTSN
	OCRLF
	JRST SRNXTC	;AND GO
ENDSRC:	TRZN FL,LINSN	;DID WE SEE ONE?
	NERROR NLN	;NULL RANGE
SRFND:	SKIPN FNDFLG	;FIND ANY?
	RERROR SRF	;NO: TELL HIM
	JRST COMND
SRCPAG:	AOS CPG	;JUST ADVANCE PAGE COUNTER
	JRST SRNXT	;AND PROCEED
SRCALT:	PUSHJ P,SETALT	;SET THINGS UP
	SKIPLE T2,SVCCNT	;GET COUNT (DO NOT CALL IF 0
	PUSHJ P,ALTSP	;SPACE OVER CORRECTLY
	PUSHJ P,ALTN1	;GO ALTER
	JRST LEVINS	;HE SAID ALTMODE
	PUSHJ P,INSED	;INSERT IT
	PUSHJ P,FINDN
	PUSHJ P,FILLB	;MAKE SURE WE HAVE NOT GOTTEN TOO BIG
	MOVE T1,(PNTR)	;GET POINTER BACK
	SOSG SRCNT
	JRST COMND	;DONE
	JRST ONSRC	;GO ON

ASSMD1:	TROA FL,CNTF	;MARK AS KEEP END OF RANGE
ASSMDT:	TRZ FL,CNTF	;JUST IN CASE
	TLO FL,ASSMF	;WE ASSUME .+1
	MOVE T1,CLN	;SET THINGS UP FOR . TO INFINITY
	MOVEM T1,LOLN
	MOVEM T1,HILN	;AS GOOD AS ANYTHING WITH THE PAGE WE WILL
	MOVE T1,CPGL	;USE
	MOVEM T1,LOPG
	TRZE FL,CNTF	;KEEP END?
	JRST NOSPC	;YES
	CAIE C,":"	;IF A : OR !
	CAIN C,"!"
	JRST HALFSP	;GET THE SECOND HALF (.+1 TO GIVEN)
	MOVSI T1,377777	;GET A LARGE PAGE
	MOVEM T1,HIPG
	JRST SRC4	;BACK INTO THINGS

HALFSP:	MOVEM T1,HIPG	;SET TOP AS /.
	PUSHJ P,GET2HF	;GET THE SECOND HALF
	JRST SRC4	;AND GO

NOSPC:	MOVE T1,SRHIPG
	MOVEM T1,HIPG	;PUT BACK END
	MOVE T1,SRHILN
	MOVEM T1,HILN
	JRST SRCH1A

LEVINS:	OCRLF			;YES - PUT OUT CRLF
	SETZM	ALTSN		;CLEAR FLAG
	JRST	COMND

SUBTTL ALTMODE AND LINE FEED COMMANDS
NXTLIN:	PUSHJ	P,NBFIND	;GET CURRENT LINE
	CAMN T1,CLN	;DID WE REALLY FIND IT
	PUSHJ P,FINDN	;YES, GET NEXT ELSE WE ALREADY HAVE IT
	JUMPE T1,[NERROR NLN]	;EOF AND NOT FOUND
	MOVE T2,DTYPE	;TERMINAL TYPE
	XCT CURUP(T2)
	OUTCHR [15]
NXTL1:	CAMN T1,PGMK	;IS THIS A PAGE MARK?
	JRST NXTPG	;TREAT SPECIALLY
NBPRNT:	MOVEM T1,CLN	;SET AS CURRENT
	MOVE T1,PNTR	;GET THE CURRENT POINTE
	TRNE	FL2,NONUMF
	TRO	FL2,SUPN
	PUSHJ	P,OUTLIN	;AND PRINT
	TRZ	FL2,SUPN
	JRST	COMND		;DONE

NXTPG:	AOS T2,CPG	;WE ARE ON THE NEXT PAGE
	MOVEM T2,CPGL
	TRNN	FL2,NONUMF
	PUSHJ P,PGPRN	;TELL HIM
	PUSHJ P,FINDN	;FIND A LINE ON IT
	JUMPN T1,NXTL1	;THERE IS ONE THERE, PRINT IT
	JRST COMND



BAKLIN:	PUSHJ	P,NBFIND	;GET CURRENT LINE
	TRNE FL,BOF	;IF NOT AT START OF FILE
	CAME PNTR,BUFP	;OR NOT AT START OF BUFFER
	SKIPA
	NERROR NLN
	OUTCHR	[15]
	MOVE T2,DTYPE
	OUTCHR LFD(T2)
BAK1:	PUSHJ P,FINDB
	CAME T1,PGMK
	JRST	NBPRNT
	MOVE T2,CPG
	MOVEM T2,CPGL
	TRNN	FL2,NONUMF
	PUSHJ P,PGPRN
	TRNE FL,BOF	;CHECK FOR START OF WORLD
	CAME PNTR,BUFP
	JRST BAK1	;OK, BACK UP SOME MOR
	MOVE T1,[<ASCII /00000/>!1]
	MOVEM T1,CLN
	JRST COMND

NBFIND:	MOVE	T1,CPGL		;CURRENT PAGE
	MOVEM	T1,DPG
	MOVE	SINDEX,CLN	;AND CURRENT LINE
	JRST	FIND		;GO FETCH

SUBTTL COPY AND TRANSFER COMMANDS

TRANS:	TLOA FL,TRANFL	;SET AS TRANSFER COMMAND
COPY:	TLZ FL,TRANFL	;JUST TO MAKE SURE
	TRZ FL2,BADORD	;CLEAR BAD ORDER FLAG
	SETZM HILN	;THIS, TOO MAY PROVE USEFUL
	SETZM LOLN	;A GOOD THING TO DO
	TLO FL2,EXCPFL	;(207) SET FLAG ITS A COPY
	TRNE FL,READOF	;DO NOT LET HIM IN READ ONLY MODE
	NERROR ILC
	PUSHJ P,GET1S	;GET PLACE TO PUT LINES
	MOVE T1,HIPG	;STORE IT AWAY FOR LATER
	MOVEM T1,DESTPG	;...
	MOVE T1,HILN	;GET LINE NUMBER OF DESTINATION
	SKIPN	T1	;IF WASN'T SPECIFIED, 
	JRST NOLNUM	;GO FAKE SOMETHING
COPY0:	MOVEM T1,DESTLN	;STORE AWAY LINE NUM. OF DESTINATION
	CAIE C,200	;...
	CAIN C,"="	;DOES HE WANT TO COME FROM ANOTHER FILE?
	JRST	OTHERF	;OTHER FILE REQUESTED
	TLZ FL,COPFIL	;NO, MAKE SURE FLAG IS OFF
COPY1:
	CAIE C,","	;SHOULD BE COMMA EVEN IF FROM ALTFIL
	NERROR ILC	;HE MUST SAY WHERE TO PUT IT
	PUSHJ	P,COPYP		;PARSE RANGE ARGS
COPY2:	SETOM NLIN1	;LINES ON FIRST PAGE
	SETZM NLIN2	;LINES ON LAST PAGE
	TLO	FL2,NORENT	;AND REE-ENTER
	TLZ	FL2,RENTF	;IN CASE HE HAS
	MOVEM P,COPDL	;SAVE STACK POINTER FOR NOW
	TLO FL,ISCOP	;SO WE WILL DO SPECIAL RESET IF ERROR
	MOVE	ALTP,[-1000*NCPAGS,,BUFC-1]
				;PNTR FOR COPY BUFFER
	SETZM LSTPG	;HAVE SEEN NO PAGES YET
	MOVE T1,LOPG	;LOOK FOR SOURCE
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND
	TRZ FL,LINSN	;AND NO LINES
	TLNN FL,TRANFL	;IS THIS A TRANSFER COMMAND?
	JRST GOCOP	;NO, IGNORE ALL THIS SPECIAL STUFF
	HRRZM ALTP,STARTD	;SAVE THE START OF DELETED CODE
	HRRZM ALTP,ENDD	;AND THE END
	MOVE T1,CPG	;GET THE PAGE ON WHICH DELETION STARTS
	MOVEM T1,TRANST	;AND SAVE IT
	SKIPN -1(PNTR)	;ARE WE AT THE START OF THE BUFFER
	TRNN FL,BOF	;AND OF THE WORLD
	SKIPA
	JRST BEGFIL	;YES, DO NOT LOOK BACK
	PUSHJ P,FINDB	;GET THE PREVIOUS LINE
	CAMN T1,PGMK	;A PAGE IS SPECIAL
	JRST SPCPG
	MOVEM T1,BOTLIN	;SAVE IT FOR LATER
	PUSHJ P,FINDN	;GO FORWARD AGAIN
	JRST GOCOP

NOLNUM:	MOVE T1,HIPG	;SET UP FOR FIND
	MOVEM T1,DPG	;...
	MOVE SINDEX, [<ASCII/99999/!1>]	;TRY TO FIND THE BIGGEST 
	PUSHJ P,FIND			;POSSIBLE LINE NUMBER
	CAME T1,[<ASCII/99999/!1>]	;BIG-LINE EXISTS. LEAVE IT BE
	PUSHJ P,FINDB		;LOOK FOR ONE LINE PREVIOUS
	JUMPE T1,[MOVE T1,TECFST;IF 0, SET UP STANDARD TOP OF PAGE
		  JRST .+1]	;...
;**;[244]	Replace 2 lines at NOLNUM:+7		DML	9/29/82	
	CAMN T1,PGMK		;[244] IS LINE FOUND A PAGEMARK?
	MOVE T1,TECFST		;[244] YES, SET TO DEFAULT STARTING LINE
	MOVE SINDEX,T1		;SET UP CORRECT SINDEX...
	MOVEM SINDEX,HILN	;HILN...
	MOVE T1,SINDEX		;AND T1 (IS GONNA BECOME DESTLN)
	JRST COPY0		;RETURN TO FLOW

SPCPG:	SKIPE LOLN	;DO WE INTEND TO ABSORD THIS ONE
	JRST BEGFIS	;MOVE FORWARD AND RECORD
	SKIPN -1(PNTR)	;CHECK FOR START OF WORLD AGAIN
	TRNN FL,BOF
	SKIPA
	JRST BEGFIS
	PUSHJ P,FINDB	;BACK UP
	AOS CPG		;FIX PAGE COUNT
	PUSH P,T1	;SAVE THAT LINE
	PUSHJ P,FINDN
	PUSHJ P,FINDN	;AND GO BACK WHERE WE BELONG
	POP P,T1	;GET LINE NUMBER BACK
	CAMN T1,PGMK	;THERE'S THAT PAGE AGAIN
	JRST BEGFIA
	MOVEM T1,BOTLIN	;SAVE LINE NUMBER
	JRST GOCOP
BEGFIS:	AOSA CPG
BEGFIA:	AOSA CPG
BEGFIF:	PUSHJ P,FINDN
BEGFIL:	SETOM BOTLIN	;A VERY SMALL NUMBER
GOCOP:	SETZM PGDELS	;TOTAL NUMBER OF PAGES DELETED IS 0
	SKIPE LOLN	;DID HE ASK FOR THE WHOLE PAGE
	JRST NOISTP	;NO
;**;[244]	Remove 6 lines at GOCOP:+3		DML	9/29/82
	SETZM NLIN1	;NO LINES ON FIRST PAGE
	TLNN FL,TRANFL	;IS THIS A TRANSFER
	JRST NOISTP	;NO, START TRANSFER OF DATA
	MOVE T1,CPG	;CHECK TO SEE IF WE SHOULD REALLY DELETE
	CAIN T1,1	;NOT IF PAGE 1
	JRST RSTSTP
	PUSHJ P,FINDB	;GET THAT PAGE
	SETZM NCNT	;DELETE
	MOVEI T1,2
	MOVEM T1,OCNT
	PUSHJ P,INSED
	PUSHJ P,FINDN1	;MAKE SURE WE ARE AT THE LINE WE WERE AT
	AOS CPG		;KEEP COUNT STRAIGHT
	AOSA PGDELS	;ONE DELETED
RSTSTP:	HRRZM ALTP,STARTD	;RESET START IF NONE DELETED
	HRRZM ALTP,ENDD	;RESET END
NOISTP:	MOVE T1,(PNTR)	;MAKE SURE WE HAVE THAT JUNK BACK
ONCOPY:	PUSHJ P,ONMOV	;STILL IN RANGE?
	JRST ENDCOP	;NO, START INSERTING
	TRO FL,LINSN	;WE SAW ONE
	CAMN T1,PGMK	;IS IT A PAGE?
	JRST MOVPG	;YES, TREAT SPECIAL
	AOS	NLIN2		;INCR LINE SEEN
MOVLCT:	MOVE T1,PNTR	;START TRANSFER
	MOVE T2,(T1)	;PICK UP FIRST WORD (SEQ NUM)
	MOVEM T2,LSTLN	;SAVE FOR INC CALC
TRLIN:	MOVEM T2,1(ALTP)	;PUT LINE AWAY
	AOBJP ALTP,RESTCR	;NEED MORE CORE?
TRLIN1:	SKIPN T2,1(T1)	;END OF LING?
	JRST NXTLCT
	TRNN T2,1
	AOJA T1,TRLIN	;NO MOVE NEXT WORD
NXTLCT:	TLNN FL,TRANFL	;IS THIS TRANSFER?
	JRST NXTLCP	;NO, DON'T DELETE
	HRRZM ALTP,ENDD	;SAVE END OF DELETED TEXT
	SETZM NCNT
	SUBI T1,-1(PNTR)	;GET LENGTH
	MOVEM T1,OCNT
	PUSHJ P,INSED
	PUSHJ P,FINDN1	;MAKE SURE A LINE IS THERE
	SKIPA		;SKIP THE FINDN
NXTLCP:	PUSHJ P,FINDN	;YES, GET NEXT
	JRST ONCOPY

MOVPG:	AOS CPG	;WE ARE ON NEXT PAGE
	MOVE T1,NLIN2
	SKIPGE NLIN1	;PUT ON FIRST PAGE IF NOT SOME ALREADY THERE
	MOVEM T1,NLIN1
	SETZM NLIN2
	HRRZM ALTP,LSTPG	;SAVE RECORD OF WHERE SEEN
	AOS PGDELS	;RECORD ONE MORE PAGE DELETED
	JRST MOVLCT	;NOW MOVE IT

RESTCR:	NERROR NEC
;	JRST	TRLIN1		;WHERE TO GO IF MORE AVAIL

ENDCOP:	TRNN FL,LINSN	;WERE THERE ANY THERE?
	NERROR NLN	;NO LOSE
	SETZM 1(ALTP)	;MAKE SURE THERG IS AN END FLAG THERE
	TLZE FL,COPFIL	;ARE WE COMMING OFF A FILE
	PUSHJ P,RSCOP	;YES, RESET POINTERS
	MOVE T1,DESTPG	;LOOK FOR DESTINATION
	MOVEM T1,DPG
	TLNN FL,TRANFL	;IS IT A TRANSFER?
	JRST DOINS1	;(223)NO, PUT THE COPIED TEXT IN
	SETZM PGINSD	;NO EXTRA PAGE MARK INSERTED YET
	SKIPN T2,(PNTR)	;ARE WE AT EOF
	JRST NOPGIN	;YES, DO NOT INSERT A PAGE MARK
	CAME T2,PGMK	;ALSO NOT IF PAGE MARK
	CAMLE T2,BOTLIN	;OR GREATER THAN LINE LEFT OVER
	SKIPA
	SETOM PGINSD	;WE WILL HAVE TO INSERT ONE
NOPGIN:	MOVN T2,PGDELS	;GET MINUS NUMBER OF PAGES DELETED
	SUB T2,PGINSD	;ONE LESS IF A PAGE MARK INSERTED
	CAMGE T1,TRANST	;(T1 HAS DEST. PAGE) IF SMALLER THAN START
	JRST DOSUB	;EVERYTHING IS OK
	CAMN T1,TRANST	;IS IT SAME?
	JRST DSEQTR	;SPECIAL CHECK REQUIRED
	CAMGE T1,CPG	;INSIDE RANGE DELETED?
	NERROR ITD	;LOSE BIG
	CAMN T1,CPG	;SAME AS TOP PAGE?
	JRST DSEQCP
	ADDM T2,DESTPG	;ADJUST PGE WE ARE TO FIND
	ADDM T2,DPG
DOSUB:	ADDM T2,CPG	;ADJUST FOR REMOVED PAGES
	ADDM T2,INPG
	ADDM T2,BGPG
	SKIPN PGINSD	;SEE IF WE WANT TO INSERT ONE
	JRST DOINS1	;(223)no, put the copied text in
	MOVE T1,PGMK
	MOVEM T1,LIBUF
	MOVE	T1,PGMKW2
	MOVEM T1,LIBUF+1
	SETZM OCNT
	MOVEI T1,2
	MOVEM T1,NCNT
	PUSHJ P,INSED
	PUSHJ P,FINDN	;ADVANCE OVER IT
	PUSHJ P,FILLB	;IN CASE OF OVERFLOW
	OUTSTR [ASCIZ /%Page mark inserted to prevent order error
/]
	JRST DOINS1	;(223)go put copied text in
ALLSAM:	SKIPN LOLN
	SKIPE PGINSD	;IF DID NOT DELETE PAGE OR INSERTED ONE
	JRST DOSUB	;ALL OK
	SKIPE T1,(PNTR)	;ELSE MUST BE IN UPPER PART
	CAMN T1,PGMK
	NERROR ITD	;THERE IS NO UPPER PART
	CAMLE T1,DESTLN
	NERROR ITD
	SOS T1,DESTPG	;THIS WILL BE ON A LOWER PAGE
	MOVEM T1,DPG
	JRST DOSUB
DSEQTR:	CAMN T1,CPG	;IS IT ALL ON SAME PAGE?
	JRST ALLSAM	;YES, SPECIAL CHECKING
	SKIPN LOLN	;DID WE START WITH A PAGE
	NERROR ITD	;YES, LOSE
	SKIPE PGINSD	;WAS THERE A PAGE INSERTED?
	JRST DOSUB	;YES, ALL OK
	SKIPE T1,(PNTR)	;FIND OUT WHAT THE NEXT LINE IS
	CAMN T1,PGMK
	JRST DOSUB	;THIS WILL BE OK
	CAMG T1,DESTLN	;SEE IF WE ARE IN TROUBLE
	NERROR ITD
	JRST DOSUB	;OK
DSEQCP:	SKIPE PGINSD	;WAS ONE INSERTED
	JRST AOSTRA	;SET PAGE PROPERLY
	MOVE T1,DESTLN
	CAMG T1,BOTLIN
	NERROR ITD
	SKIPA T1,TRANST
AOSTRA:	AOS T1,TRANST
	MOVEM T1,DESTPG
	MOVEM T1,DPG	;ALSO SET THIS
	JRST DOSUB
DOINS1:	MOVE SINDEX,DESTLN
	PUSHJ P,FIND
	PUSH P,T1	;SAVE LINE FOUND
	MOVE T1,CPG
	CAMN	T1,DESTPG	;PAGES MUST MATCH
	JRST	DOINS2
	TLNN	FL,TRANFL	;ONLY TRANSFER
	NERROR	NSP		;ERROR IF COPY
	MOVE	T1,PGMK
	MOVEM	T1,LIBUF
	MOVE	T1,PGMKW2
	MOVEM	T1,LIBUF+1
	SETZM	OCNT
	MOVEI	T1,2
	MOVEM	T1,NCNT
	PUSHJ	P,INSED
	PUSHJ	P,FINDN
	PUSHJ	P,FILLB
	AOS	CPG
	AOS	INPG
	AOS	BGPG
	OUTSTR	[ASCIZ /%Text inserted at end of file
/]
	MOVE	T1,CPG

DOINS2:	MOVEM	T1,CPGL		;SET THIS AS CURRENT PAGE
	POP	P,T1		;RETRIEVE LINE FOUND
	MOVE	T2,[<ASCII /00100/>!1]
	MOVEM	T2,CLN		;AND THIS AS CURRENT LINE
	MOVEM	T2,SVLNUM
	MOVEI	ALTP,BUFC-1	;POINT TO START OF LINES TO COPY
	TLZ	FL,TRANFL	;THIS FLAG NO LONGER NEEDED
TWOSET:	SKIPGE	NLIN1		;DID WE SEE ANY PAGE MARKS?
	JRST	ONSET		;NO -- JUST NEED ONE INCR
	MOVEM	T1,HIGH1	;SAVE THIS FOR LATER
	MOVE	T2,TECFST	;(223)get /START value
	MOVEM	T2,START2	;(223)set default for last page
	JUMPE	T1,[MOVE T2,[<ASCII /00100/>!1]
		    MOVEM T2,SINCR ;USE THIS IF EOF
		    MOVE T3,NLIN1  ;SET UP FOR GETDIF
		    JRST ONST0]    ;GO COMPUTE FIRST INCR
	MOVE	T3,NLIN2	;NUMBER OF LINES ON LAST PG
	MOVE	T2,[<ASCII /00000/>!1]
	MOVE	T1,HIGH1	;RESULT OF FIND
	CAMN	T1,DESTLN	;SAME AS DESTINATION?
	MOVE	T1,T2		;YES - COMPUTE CORRECT INCR
	PUSHJ	P,GETDIF	;CALL ROUTINE
	  JRST	[IORI FL2,BADORD	;ORDER PROBLEM
		 JRST OKINC2]		;CONTINUE
	MOVEM	T2,START2	;PLACE TO START FOR LAST PAGE
	SKIPN	SINCR		;DID HE SAY ONE
	JRST	[MOVE T1,LSTLN	;LAST LINE SEEN
		 CAML T1,(PNTR)	;HOW'S IT LOOK?
		 JRST ONST3	;NOT GOOD ENOUGH
		 JRST OKINC2]
	CAML	T2,SINCR	;SEE WHOSE IS BETTER
	JRST	OKINC2		;WE'LL USE HIS
ONST3:	MOVEM	T2,SINCR	;OURS IS BETTER
	MOVEM	T2,PRNTO2	;INFOR HIM OF THE CHANGE
	OUTSTR	ASCIZ2

OKINC2:	MOVE	SINDEX,DESTLN	;INCASE WE NEED TO FIND IT
	MOVE	T1,HIGH1	;RESULT OF PREVIOUS FIND
	CAMGE	SINDEX,T1	;BEFOR 1ST LINE OF PAGE?
	PUSHJ	P,FIND		;YES - NEED TO REPOSITION
				;T1 HAS CORRECT RESULT
	SKIPG	T3,NLIN1	;CHECK FOR P/M ONLY
	JRST	INSL2		;ALL SET FIRST THING IS P/M
	MOVE	T2,DESTLN	;WHAT HE WANTED
	PUSHJ	P,GETDF1	;DON'T LOOK AT NEXT LINE
	  JRST	[IORI FL2,BADORD	;ORDER PROBLEM WILL FOLLOW
		 JRST INSL2]		;CONTINUE
	MOVEM	T1,CLN		;SET UP GOOD THINGS
	MOVEM	T1,SVLNUM
	CAML	T2,FINCR	;WHICH IS BETTER
	JRST	INSL2		;HIS
	MOVEM	T2,FINCR	;OURS
	JRST	ONST1		;TELL HIM WE CHANGED HIS MIND
ONSET:	SKIPG	T3,NLIN2	;GO ANYTHING TO WORRY ABT
	JRST	INSL2		;NO -- DO OUR WORST
ONST0:	MOVE	T2,DESTLN	;HIS DESIRED PLACE
	MOVEM	T2,SVLNUM	;AS GOOD AS ANY IF ORDER ERROR
	PUSHJ	P,GETDIF	;SEE WHAT THERE IS TO SEE
	  JRST	[IORI FL2,BADORD	;ORDER PROBLEMS, SET FLAG
		 JRST INSL2]		;AND CONTINUE
	MOVEM	T1,SVLNUM	;SET THE GOOD S--T
	MOVEM	T1,CLN
	CAML	T2,FINCR	;THE MOMENT OF TRUTH
	JRST	INSL2		;THAT CRAFTY FELLOW
	MOVEM	T2,FINCR	;TELL HIM HE BLEW IT
ONST1:	MOVEM	T2,PRNTO1	;PUT IN IN PRINT POSITION
	OUTSTR	ASCZ1
	JRST	INSL2		;HE HAS BEEN TOLD


;CONVERT INTEGER IN T1 TO SEQ # IN T3

ASCON:	MOVSI	T3,400000	;WILL BECOME LOW ORDER BIT
ASCO2:	IDIVI	T1,^D10
	ADDI	T2,"0"
	LSHC	T2,-7
	TRNN	T3,1		;HAS IT GOTTEN THERE?
	JRST	ASCO2
	POPJ	P,

;CONVERT SEQ # IN T3 TO INTEGER IN T1

NUMCON:	MOVEI	T1,0
	TRZ	T3,1		;GET RID OF LOW ORDER BIT
NUMC1:	MOVEI	T2,0
	LSHC	T2,7
	IMULI	T1,^D10
	ADDI	T1,-"0"(T2)
	JUMPN	T3,NUMC1
	POPJ	P,
INSLN:	MOVE T2,FINCR	;GENERATE NEW SEQUENCE NUMBER
	SKIPN T1,SVLNUM	;BUT ONLY IF WE ARE SUPPOSED TO
	JRST INSL2
	PUSHJ P,ASCIAD
	MOVEM T1,SVLNUM	;PUT EITHER NGW OR 0 BACK
INSL2:	SETZM LIBUF	;ZERO OUT PLACE TO PUT LINE
	MOVE T1,[XWD LIBUF,LIBUF+1]
	BLT T1,LIBUF+MXWPL+1
	MOVEI T1,LIBUF	;SET UP OUTPUT POINTER
	SKIPN T2,1(ALTP)	;AT END?
	JRST INSDON	;FINISHED
INS1:	MOVEM T2,(T1)	;PUT IT AWAY
	ADDI ALTP,1	;NEXT
	SKIPN T2,1(ALTP)	;CHECK FOR END OF LING
	JRST INS2
	TRNN T2,1	;BY EITHER METHOD
	AOJA T1,INS1	;GO ON WITH TRANSFER
INS2:	SUBI T1,LIBUF-1	;GET COUNT
	MOVEM T1,NCNT	;AND SET AS NEW
	SETZM OCNT	;OLD IS ZERO
	MOVE T1,LIBUF	;GET SEQ NUM
	CAMN T1,PGMK	;CHECK FOR PAGE
	JRST INSPG	;AND DO SPECIAL
	SKIPN T1,SVLNUM	;IF A NON-ZERO NUMBER THEN REPLACE
	MOVE T1,LIBUF
	MOVEM T1,LIBUF
NOINCR:	MOVEM T1,CLN	;SET AS CURRENV LINE
	PUSHJ P,INSED	;INSERT IT
	PUSHJ P,FINDN	;GET NEXT
	PUSHJ P,FILLB	;AND DUMP IF NEEDED
	JRST INSLN	;GO PUT IN MORE

INSPG:	AOS T3,CPG	;WE ARE ON THE NEXT PAGE
	MOVEM T3,CPGL	;SET AS CURRENV
	MOVE T1,[<ASCII /00000/>!1]	;SET TO SAY LINE 0
	AOS BGPG	;ONE MORE PAGE IN FILE
	AOS INPG
	SETZM SVLNUM	;DO NOT DO ANY MORE SEQUENCE REPLACEMENT
	MOVEI T2,-2(ALTP)	;SINCE WE HAVE ALREADY GONE PAST
	CAMN T2,LSTPG	;UNLESS STARTING LAST PAGE
	SKIPN T3,SINCR	;ANF SECOND SEQUENCE NUMBER GIVEN
	JRST NOINCR
	MOVEM T3,FINCR	;SET UP INCREMENT
	MOVE	T3,START2	;GET LAST PAGE START
	MOVEM	T3,SVLNUM
	MOVEM	T1,CLN
	PUSHJ	P,INSED		;INSERT IT
	PUSHJ	P,FINDN		;TO NEXT
	PUSHJ	P,FILLB		;SLURP
	JRST	INSL2		;GO DO IT
INSDON:
COPDON:	SKIPN	ALTJFN		;SKIP THIS IF NO JFN
	JRST	NOCPF		;NO FILE OPEN
	MOVEI	T2,<CPYPG0>B44	;RELEASE THIS PAGE
	CALL	UNMAP		;...
	MOVE	T1,ALTJFN	;RELEASE JFN HERE
	CLOSF			;...
	  JFCL			;DONT CARE NOW
	SETZM	ALTJFN		;(222)CLEAR JFN STORAGE
NOCPF:	TLZE	FL,COPFIL	;ARE WE COPYING FROM A FILE (ERRORS ONLY)
	PUSHJ	P,RSCOP		;YES, CLEAN UP POINTERS
	TLZ	FL,ISCOP	;RESET COPY FLAG
	TLNN	FL,TRANFL	;IF TRANSFER, WE MUST REINSERT
	JRST	COPD1		;NO
	MOVE	ALTP,STARTD
REINXT:	MOVEI	T1,LIBUF
	CAMN	ALTP,ENDD
	JRST	COPD1		;ALL DONE
	MOVE	T2,1(ALTP)
	JRST	REINWD

REINS:	MOVE	T2,1(ALTP)
	CAME	ALTP,ENDD
	TRNE	T2,1
	JRST	ENDLIN		;DONE WITH THIS LINE
REINWD:	MOVEM	T2,(T1)
	ADDI	T1,1
	AOJA	ALTP,REINS

ENDLIN:	SETZM	OCNT
	SUBI	T1,LIBUF
	MOVEM	T1,NCNT
	PUSHJ	P,INSED		;INSERT LINE
	PUSHJ	P,FINDN
	PUSHJ	P,FILLB		;IN CASE OF OVERFLOW
	JRST	REINXT

COPD1:	MOVNI	T1,1		;REMOVE PAGES
	MOVE	T2,[.FHSLF,,<CPYBUF>B44]
	MOVE	T3,[PM%CNT+NCPYP]
	PMAP			;ZAP
	HRRI	T2,<BUFC>B44	;MORE STUFF TO REMOVE
	HRRI	T3,NCPAGS
	PMAP			;BYE BYE
	TRZE	FL2,BADORD	;WAS THE ORDER BAD SOMEPLACE?
	 NERROR	ORDER		;YES, COMPLAIN
	JRST	COMND		;CONTINUE EDITING
OTHERF:	TLZE	FL,TRANFL	;GIVE WARNING IF TRANSFER
	OUTSTR	[ASCIZ /% WARNING - Copy assumed
/]
	SETZM	ALTJFN		;NONE YET
	SETOM	FSFLG		;SPECIAL ^U FLAG
	MOVSI	T1,(GJ%OLD!GJ%CFM)
	MOVEI	ALTP,ALTBLK
	CALL	READNM
	  JRST	CKIND		;ERROR RETURN
;**;[247]	Change 1 line at OTHERF:+9		DML	23-NOV-82
	  JRST	CTLUAB		;[247] ^U RETURN
	PUSHJ	P,READSW	;READ /R OR /S
	 NERROR ILC
	SKIPE	RSW		;/R ILLEGAL
	NERROR	ILC
	MOVE	T1,ALTJFN	;GET JFN
	MOVEM	T1,AIPJFN	;SAVE
	DVCHR			;(224)get device characteristics
	LDB	T2,[POINT 9,T2,17] ;(224)isolate device-type bits
	CAIE	T2,.DVDSK	;(224)make sure it's a disk
	NERROR	ILC		;(224)illegal if it's not
	MOVE	T1,AIPJFN	;(224)get jfn
	MOVE	T2,[7B5+OF%RD]
	OPENF			;OPEN FILE
	  JERROR		;USER LOSAGE
	MOVEI	ALTP,AIPB	;POINT TO BLOCK
	CALL	GFSIZE		;GET INPUT FILE SIZE
	PUSH	P,SAVEN		;TURN OFF AUTO-SAVE
	SETZM	SAVEN
	SETOM	AIPCNT		;CLEAR INPUT PNTRS
	SETZM	AIPPNT
	MOVEI	T1,CPYPG0	;BUFFER ADDRS
	MOVEM	T1,AIPBUF	;...
	MOVEI	T1,<CPYBUF+1000*NCPYP>-1
	SUBI T1,2*MXWPL+2	;SET UP THE VARIOUS POINTERS
	PUSH P,FILPT	;SEE STPT FOR MORE INFO
	MOVEM T1,FILPT
	MOVEI T1,1
	PUSH P,CPGL
	MOVEM T1,CPGL
	MOVE T1,[<ASCII /00000/>!1]
	PUSH P,CLN
	MOVEM T1,CLN
	MOVEI	T1,CPYBUF
	SETZM (T1)
	ADDI T1,1
	PUSH P,BUFP
	MOVEM T1,BUFP
	MOVEI	T1,<CPYBUF+1000*NCPYP>-1
	SUB T1,BUFP
	MOVE T2,T1
	SUBI T2,MXWPL+1
	PUSH P,MAXWC
	MOVEM T2,MAXWC
	ASH T1,-1
	PUSH P,HLFWC
	MOVEM T1,HLFWC
	MOVEI T1,1
	PUSH P,CPG
	PUSH P,INPG
	MOVEM T1,CPG
	MOVEM T1,INPG
	PUSH P,PNTR
	MOVE PNTR,BUFP
	PUSH P,SVWD
	SETZM SVWD
	PUSH P,OLDLIN
	SETZM OLDLIN
	PUSH P,WC
	SETZM WC
	MOVSI T1,1
	PUSH P,BGPG
	MOVEM T1,BGPG
	MOVE T1,FL	;SAVE SELECTED FLAGS
	AND T1,[XWD TECOF+FSTOPF,READOF!BOF!EOF!EOF2!BGSN]
	PUSH P,T1
	TRZ FL,EOF!EOF2
	TRO FL,READOF!BOF
	TLZ FL,TECOF
	TLO FL,FSTOPF
	MOVEM P,COPDL	;SAVE PDL FOR LATER
	TLO FL,COPFIL+ISCOP	;WE ARE USING OTHER FILE POINTERS
	PUSHJ P,FILLBF
	SKIPN SSW
	JRST COPY1
	TRNN FL,TERMF	;MUST END HERE
	NERROR ILC
	TLO FL,SRCOP	;SET THINGS UP
	JRST COMND	;AND GO GET COMMANDS

DSCOP:	PUSHJ	P,GNCH		;GET NEXT CHAR
	ANDI	C,137		;FORCE UPPER
	CAIN	C,"Q"		;CHECK FOR SPECIAL
	JRST	NOCOP		;YES - DO NOTHING
	MOVEM	C,SAVC		;BACK UP SCANNER
	PUSHJ	P,SCAN
	TRNN	FL,TERMF
	NERROR	ILC
	OUTSTR	[ASCIZ /Source lines=/]
	SETZM	LOLN		;THIS MAY HAVE GOTTEN RESET
	SETZM	SAVCHR		;CLEAR THINGS OUT
	SETZM	SSW		;FORGET THIS SWITCH
	PUSHJ	P,COPYP		;GET SOURCE LINES
	TLZ	FL,SRCOP	;TURN OFF FLAG
	JRST	COPY2		;CONTINUE

COPYP:	PUSHJ	P,GET2S		;GO GET PLACE TO FIND LINES
	MOVE	T1,INCR		;SEV INCREMENT AS CURRENT
	MOVEM	T1,FINCR
	SETZM	SINCR		;SET NO SECOND INCREMENT
	CAIE	C,","		;CHECK FOR MORE ARGUMENTS
	JRST	COPYP1		;NO, LOOK FOR TERMINATOR
	PUSHJ	P,SCAN
	CAME	T1,[<ASCII /00000/>!1]	;AVOID 0 INCREMENTS
	TRNN	FL,NUMF		;SHOULD BE INCREMENT, MUST BE NUMBER
	NERROR	ILC
	MOVEM	T1,FINCR
	PUSHJ	P,SCAN
	CAIE	C,","
	JRST	COPYP1
	PUSHJ	P,SCAN
	CAME	T1,[<ASCII /00000/>!1]
	TRNN	FL,NUMF
	NERROR	ILC
	MOVEM	T1,SINCR
	PUSHJ	P,SCAN
COPYP1:	TRNN	FL,TERMF
	NERROR	ILC		;DID NOT END PROPERLY, LOSE
	POPJ	P,		;RETURN

NOCOP:	PUSHJ	P,SCAN		;CHECK EOL
	TRNN	FL,TERMF
	NERROR	ILC
	TLZ	FL,SRCOP	;TURN OFF COPY
	JRST	COPDON
RSCOP:	POP P,T2
	MOVE P,COPDL	;GET PDL BACK
	POP P,T1
	TRZ FL,READOF!BOF!EOF!EOF2!BGSN	;RESTORE SELECTED FLAGS
	TLZ FL,TECOF!FSTOPF
	IOR FL,T1
	POP P,BGPG
	POP P,WC
	POP P,OLDLIN
	POP P,SVWD
	POP P,PNTR
	POP P,INPG
	POP P,CPG
	POP P,HLFWC
	POP P,MAXWC
	POP P,BUFP
	POP P,CLN
	POP P,CPGL
	POP P,FILPT
	POP P,SAVEN		;RESTORE AUTO-SAVE
	JRST (T2)	;NOW RETURN
SUBTTL SUBSTITUTE COMMAND (REPLACES THINGS)

SUBST:	TLZ FL,ASSMF	;DO NOT ASSUME ANYTHING YET
	TLZ FL2,SRCWHO	;(203) SUBST IS DOING THE SEARCH
	TRNE FL,READOF
	NERROR ILC
	SETZM LOLN	;A GOOD THING
	SETZM PARCNT	;ZERO COUNT FOR SEQUENTIAL PARTIALS
	HRLOI T1,377777	;SET FOR LOTS
	MOVEM T1,RPCNT
	MOVE T1,[ASCII "S*"]
	MOVEM T1,FSFLG		;PROMPT FOR SUBST CMD
	MOVE T1,[POINT 7,R1BUF]
	MOVEI T3,R1PNT
	PUSHJ P,SSTRNG	;THIS CODE IS JUST LIKE SEARCH
	JRST	[SKIPE R2PNT	;BOTH STRINGS MUST HAVE BEEN GIVEN
		SKIPN R1PNT
		NERROR NSG	;ELSE THERE HAS BEEN AN ERROR
		CAIN C,12	;CHECK FOR JUST A CRRET
		JRST ASBMD1	;AND DO A CONTINUE
		JRST NOSTR]	;THERE IS NO STRING
	MOVE T1,[POINT 7,R2BUF]	;GET STRING TO REPLACE BY
	MOVEI T3,R2PNT
	PUSHJ P,SSTRNG
	JRST	[CAIN C,12
		JRST	[PUSH P,[.]	;SET UP RETURN
			JRST RETSTR]	;AND READ MORE (FISRT NULL)
		MOVEM T1,R2PNT	;NULL STRING MEANS DELETE
		MOVEI T2,0		;SO SET A REAL NULL STRING
		IDPB T2,T1
		JRST .+1]
	SUBI T3,R2PNT	;GENERATE NUMBER OF REPLACEMENT STRINGS
	MOVEM T3,RSTRCT	;AND SAVE FOR LATER
NOSTR:	TLZ FL,NOPRN!DECID!EXCTS1	;CLEAR FLAGS
	PUSHJ P,SCAN	;AND START LOOKING FOR MORE JUNK
	TRNN FL,TERMF	;NOTHING
	CAIN C,","	;OR JUST A COMMA
	JRST ASBMDT	;THEN SEARCH FROM HERE TO ETERNITY
	CAIE C,"!"	;HE ONLY WANTS TO GIVE A STOPPING POINT
	CAIN C,":"
	JRST ASBMDT
	PUSHJ P,GET2	;GO GET A RANGE
REP4:	MOVE T1,HILN	;SAVE FOR POSSIBLE CONTINUE
	MOVEM T1,RPHILN
	MOVE T1,HIPG
	MOVEM T1,RPHIPG
	CAIE C,","	;IS THERE MORE?
	JRST REP1	;NO
	PUSHJ P,SCAN	;SEE WHAT IT IS
	TRNN FL,IDF	;POSSIBLY AN IDENT
	JRST REP2	;NO MAYBE A NUMBER OF TIMES
	MOVS T1,ACCUM
	CAIN T1,(<SIXBIT /N  />)
	TLO FL,NOPRN	;SET FOR NO PRINTING
	CAIN T1,(<SIXBIT /D  />)
	TLO FL,DECID	;HE WANTS TO BE ABLE TO DECIDE
	TLNN FL,DECID!NOPRN	;IF NEITHER
	JRST REP3	;THEN TRY FOR E SWITCH
	PUSHJ P,SCAN	;SEE IF THERE IS MORE
	CAIE C,","
	JRST REP1	;END OF LINE
	PUSHJ P,SCAN	;LOOK FOR STILL MORE
	TRNN FL,IDF
	JRST REP2
	MOVS T1,ACCUM
REP3:	CAIE T1,(<SIXBIT /E  />)	;IS IT THE EXACT SEARCH SWITCH
	NERROR ILC	;NO,LOSAGE
	TLO FL,EXCTS1
	PUSHJ P,SCAN	;ONE LAST TRY
	CAIE C,","
	JRST REP1	;GO CHECK TERMINATOR
	PUSHJ P,SCAN	;ONLY ONE THING LEFT
REP2:	TRNN FL,NUMF
	NERROR ILC	;BUT IT WAS NOT
	MOVEM T2,RPCNT	;SAVE IT AWAY
	PUSHJ P,SCAN
REP1:	TRNN FL,TERMF	;ALLS WELL THAT ENDS WELL
	NERROR ILC	;BUT NOT THIS ONE
REP1A:	MOVEI T1,R1PNT	;GET THE SEARCH CODE
	PUSHJ P,CODSR
	MOVE T1,LOPG
	MOVEM T1,DPG
	MOVEM T1,RPPG	;FOR PRINT OUTS
	MOVE SINDEX,LOLN
	PUSHJ P,FIND	;GET THAT LINE
	TRZ FL,LINSN	;NOTHING YET
	SETZM FNDFLG	;NO HOW
	TLNE	FL2,PDECID
	TLO	FL,DECID	;SET IF PERM MODE ON
ONREP:	PUSHJ P,ONMOV	;CHECK FOR STILL IN RANGE
	JRST ENDREP	;FINALLY
	TLZE FL,ASSMF	;SHOULD WE START WITH .+1
	JRST 	[CAME T1,LOLN	;IS IT THE ONE WE ASKED FOR
		JRST .+1	;NO, USE IT
		AOS SVCNT	;JUST IN CASE A ! TYPE OF RANGE
		JRST RPNXT]
	TRO FL,LINSN	;THIS LINE IS GOOD ENOUGH
	CAMN T1,PGMK
	JRST RPPAG	;GO TAKE CARE OF PAGE MARKS
	MOVEI T2,R1PNT	;DO THE SEARCH
	PUSHJ P,COMSRC
	JRST RPNXT
	SETOM FNDFLG	;FOUND
	SKIPGE T3	;PROTECT AGAINS SPECIAL KILLING TAB
	IBP ALTP
	PUSH P,T3	;SAVE COUNT OF HOW FAR INTO LINE
	MOVE T3,(PNTR)	;SET UP CURRENT LINE
	MOVEM T3,CLN
	MOVE T3,CPG
	MOVEM T3,CPGL
	MOVE T2,[XWD LIBUF,LIBUF+1]	;CLEAR IT OUT
	SETZM LIBUF
	BLT T2,LIBUF+MXWPL+1	;WE WILL DO REPLACE HERE
	MOVE T2,PNTR	;GET THE POINTER TO THE LINE
	MOVE T3,(T2)	;PICK UP THE FIRST WORD
	MOVEI T4,LIBUF	;THE PLACE TO PUT IT
	JRST SBALT3	;TRANSFER
SBALT2:	SKIPE T3,(T2)
	TRNE T3,1	;IS IT THE END OF THE LINE
	JRST SBALT1
SBALT3:	MOVEM T3,(T4)	;PUT IT AWAY
	ADDI T4,1
	AOJA T2,SBALT2

SBALT1:	SUBI T4,LIBUF	;GET SIZE LINE USED TO BE
	MOVEM T4,OCNT
	POP P,CCNT	;GET THE NUMBER OF CHRS INTO LINE
	SKIPGE CCNT	;MUST BE .GE. 0
	SETZM CCNT
	SUBI ALTP,(PNTR)	;CONVERT POINTER TO LIBUF
	ADD ALTP,[XWD 70000,LIBUF]	;AND BACK UP ONE
NXTRPL:	SETZM PARCNT	;ZERO FOR NEXT REP
	LDB T1,[POINT 4,-1(T1),12]	;GET STRING NUMBER
	CAMLE T1,RSTRCT	;IS IT LARGER
	MOVE T1,RSTRCT	;THEN USE LAST
	MOVE T1,R2PNT(T1)
	MOVSI T4,70000	;DECREMENT POINTER
	ADDM T4,SRCALP
REPSTR:	ILDB C,T1	;GET THE NEXT CHR
	JUMPE C,ENDRP	;THE END OF THE REPLACE STRING
	CAIN C,""	;DOES HE WANT ONE OF THE PARTIAL THINGS
	JRST PARSTR	;YES, GO HANDLE THAT
	CAIN C,""	;CHECK FOR QUOTING NEXT CHR
	JRST INSQT
	CAIN C,""	;SEQUENTIAL PARTIAL
	JRST PARORD	;YES, GO HANDLE
PUTSTR:	IDPB C,ALTP	;PUT IN THE REPLACEMENT
	AOS C,CCNT	;ADVANCE COUNT
	CAIL C,MXWPL*5	;CHECK AGAINST MAX
	NERROR LTL	;AND LOSE
	JRST REPSTR
ENDRP:	MOVE T3,CCNT	;GET COUNT SO SEARCH CAN GO ON
	PUSH P,ALTP	;SAVE REPLACE POINTER
	PUSH P,SRCALP	;AND THE END OF INPUT POINTER
	MOVE ALTP,SRCALP	;CONTINUE FROM HERE
	ILDB T1,SRCALP	;SEE WHAT CHAR WE STOPPED ON
	CAIE T1,12	;HAVE WE GONE TOO FAR?
	PUSHJ P,COMSRT	;THIS WILL CONTINUE
	JRST FINLIN	;ALL DONE WITH MATCHES, FINISH UP
	CAIL T3,MXWPL*5	;ARE THERE TOO MANY?
	NERROR LTL
	POP P,T2
DOMOV:	ILDB C,T2	;MOVE THE CHRS THAT DID NOT MATCH
	CAMN T2,ALTP	;HAVE WE GOTTEN TO THE NEXT MATCH
	JRST DONMOV	;YES
	IDPB C,(P)	;THE BYTE POINTER IS STILL IN THE STACK
	JRST DOMOV
DONMOV:	MOVEM T3,CCNT	;PUT THE COUNT BACK IN CORE
	POP P,ALTP	;THIS IS NOW THE DEPOSIT POINTER
	JRST NXTRPL	;GO DO A REPLACE
FINLIN:	POP P,SRCALP	;GET SET TO MOVE TO END
	POP P,ALTP
	ILDB C,2(P)	;WE JUST HAPPEN TO KNOW ITS STILL THERE
	CAIE C,12	;IF SO WE HAVE EATEN A RETURN
	JRST ENDFIN	;ALL IS OK
FINL2:	MOVEI C,15
	SKIPA	;SO PUT IT IN
ENDFIN:	ILDB C,SRCALP
	IDPB C,ALTP
	AOS CS,CCNT
	CAIL CS,MXWPL*5
	NERROR LTL
	CAIE C,12
	JRST ENDFIN	;DONE WHEN WE SEE THE LINE FEED
	MOVEI T1,0	;ZERO OUT REST OF THIS LINE
DOZER:	TLNN ALTP,760000	;POINTER AT END OF LINE?
	JRST ZEROD
	IDPB T1,ALTP
	JRST DOZER
ZEROD:	SUBI ALTP,LIBUF	;MOVEI AC,1-LIBUF(AC)
	MOVEI ALTP,1(ALTP)	;GET COUNT
	MOVEM ALTP,NCNT
	TLNE FL,NOPRN	;DID HE WANT PRINTING SUPRESSED
	JRST NOPLIN
	MOVE	T2,CPG		;GET CURRENT PAGE
	TRNN	FL2,NONUMF	;DON'T PRINT IF NONUMBER
	CAMN	T2,RPPG		;OR PAGES MATCH
	SKIPA
	PUSHJ	P,PGPRN
	MOVE	T2,CPG
	MOVEM	T2,RPPG		;SET AS CURRENT PAGE
NOVCMD:	MOVEI T1,LIBUF		;PRINT THE LINE
	PUSHJ P,OUTLIN
	TLNN FL,DECID		;DOES HE WANT THE OPTION OF SAYING NO
	JRST NOPLIN		;NO, INSERT IT
NOVCM1:	INCHRW	T1		;WAIT FOR HIM TO TYPE SOMETHING
	ANDI	T1,177
	OCRLF
	CAIN	T1,177		;DID HE SAY RUBOUT(DON'T INSERT)?
	JRST	RPNXT1		;YES, JUST IGNORE THIS LINE
	CAIN	T1," "		;SPACE MEANS USE IT
	JRST	NOPLIN
	ANDI	T1,137		;FORCE UPPER CASE
	CAIE	T1,"Q"
	CAIN	T1,"E"		;DOES HE WANT OUT
	JRST	ENDREP		;YES: QUIT
 	CAIN	T1,"A"
	JRST	RPALT
	CAIN	T1,"G"		;GET OUT OF DECIDE MODE
	JRST	[TLZ FL,DECID	;LEAVE DECIDE MODE
		 JRST NOPLIN]
	CAIN	T1,"H"
	JRST	[OUTSTR	DECIDT
		 JRST NOVCMD]
	PUSH	P,FL2		;TEMP HACK
	TRZ	FL2,COMFLF	;SAY WE NEVER WANT IND CMND #
	RERROR	ILDC		;ILLEGAL CHARACTER
	POP	P,FL2		;RESTORE FLAGS
	OUTCHR	[7]		;DING
	CALL	CLRBFI		;CLEAR HIM OUT
	TRNE	FL,EXTOG	;SHORT ERROR MESSAGES?
	JRST	NOVCM1		;YES, WAIT FOR INPUT
	JRST	NOVCMD		;NO, TRY IT ALL AGAIN

DECIDT:	ASCIZ "Type one of:
SPACE bar  - To accept this substitution.
DELETE key - To reject this substitution.
A          - To do this substitution, then enter Alter mode.
E          - To return immediately to command mode without
             making the substitutions.
G          - To make this substitution, and further ones, 
             automatically.
H          - To type this help text.
"

NOPLIN:	PUSHJ	P,INSED		;ANYTHING ELSE IS OK
	PUSHJ	P,FINDN		;GET NEXT
	PUSHJ	P,FILLB		;IN CASE IT GOT LONGER
	SOSG	RPCNT		;SEE IF OUT OF COUNT
	JRST	COMND
	MOVE	T1,(PNTR)	;GET POINTER BACK
	JRST	ONREP

RPALT:	TRO	FL2,ADECIF	;SAY THIS IS AN "A" ANSWER
	MOVE	T1,OCNT		;SAVE COUNT
	ADDI	T1,LIBUF	;FAKE OUT SETALT
	PUSHJ	P,RPSALT
	PUSHJ	P,ALTN1		;DO ALTER
	JRST	ENDREP		;QUIT
	JRST	NOPLINE		;USE IT NOW
ASBMD1:	TROA FL,CNTF	;MARK AS KEEP END OF RANGE
ASBMDT:	TRZ FL,CNTF	;JUST IN CASE
	TLO FL,ASSMF	;WE ASSUME .+1
	MOVE T1,CLN
	MOVEM T1,LOLN	;SET FOR HERE TO ETERNITY
	MOVEM T1,HILN
	MOVE T1,CPGL
	MOVEM T1,LOPG
	TRZE FL,CNTF	;KEEP END?
	JRST NOSPSB
	CAIE C,":"	;IF A : OR A !
	CAIN C,"!"
	JRST HALFSB	;GET THE SECOND HALF (.+1 TO GIVEN)
	MOVSI T1,377777	;GET A LARGE PAGE
	MOVEM T1,HIPG
	MOVEI T1,1	;SET FOR ONLY ONE
	MOVEM T1,RPCNT
	JRST REP4	;ONWARD
HALFSB:	MOVEM T1,HIPG	;SET TO AS /.
	PUSHJ P,GET2HF	;GET THE SECOND HALF
	JRST REP4	;AND GO

NOSPSB:	MOVE T1,RPHIPG
	MOVEM T1,HIPG
	MOVE T1,RPHILN
	MOVEM T1,HILN
	JRST REP1A
INSQT:	ILDB C,T1	;GET NEXT CHR
	JUMPN C,PUTSTR	;MUST NOT BE 0
	NERROR IRS	;THIS STRING IS ILLEGAL

PARSTR:	MOVEI CS,0	;FIND OUT THE NUMBER
PARST1:	ILDB C,T1	;GET A CHR
	CAIN C,""	;CHECK FOR END
	JRST ENDNUM
	CAIL C,"0"	;MUST BE A DIGIT
	CAILE C,"9"
	NERROR IRS
	IMULI CS,^D10	;CONVERT
	ADDI CS,-"0"(C)
	JRST PARST1
ENDNUM:	CAILE CS,0
	CAMLE CS,ARBCNT	;IS IT IN RANGE
	NERROR IRS	;NO SUCH PARTIAL STRING
	MOVE T4,[POINT 7,ARBBUF]	;START LOOKING FOR IT
	SOJLE CS,FNDRST	;STARTS WITH STRING 1
NXTST:	ILDB C,T4
	JUMPN C,NXTST	;0 IS END OF A PARTIAL STRING
	SOJG CS,NXTST	;LOOK FOR CORRECT STRING
FNDRST:	ILDB C,T4	;NOW INSERT THAT STRING
	JUMPE C,REPSTR	;GO FINISH THE REPLACEMENT STRING
	IDPB C,ALTP
	AOS C,CCNT
	CAIL C,MXWPL*5
	NERROR LTL
	JRST FNDRST

PARORD:	AOS CS,PARCNT	;GET NEXT PARTIAL
	JRST ENDNUM

RPNXT1:	SOSG RPCNT
	JRST RPFND
RPNXT:	PUSHJ P,FINDN
	JRST ONREP	;CONTINUE LOOKING AT LINES

ENDREP:	TRZN FL,LINSN	;WERE THERE ANY?
	NERROR NLN
RPFND:	SKIPN FNDFLG	;FIND ANY?
	RERROR SRF	;NOPE
	JRST COMND	;GO ON

RPPAG:	AOS CPG	;JUST ADVANCE PAGE COUNTER
	JRST RPNXT




SUBTTL XPAND COMMAND


XPAND:	SETZM LOLN	;AS USUAL, A GOOD THING
	TRNE	FL,READOF	;CHECK R/O
	NERROR	ILC
	SETZM SSW	;CLEAR SWITCH
	PUSHJ P,GET2S	;THE RANGE
	CAIE C,","	;SWITCH
	JRST XPAND0
	PUSHJ P,SCAN
	MOVS T1,ACCUM
	CAIE T1,(<SIXBIT /S  />)
	NERROR ILC
	SETOM SSW	;SET TO SUPPRESS TYPEOUT
	PUSHJ P,SCAN
XPAND0:	TRNN FL,TERMF
	NERROR ILC
	TRZ FL,LINSN
	MOVE T1,LOPG
	MOVEM T1,DPG
	MOVE SINDEX,LOLN
	PUSHJ P,FIND
XPND1:	PUSHJ P,ONMOV	;STILL IN RANGE?
	JRST EXPEND
	TRO FL,LINSN
	CAMN T1,PGMK	;IGNORE THESE
	JRST PAGE
	SKIPE SSW	;SUPPRESS?
	TRO FL2,SUPN	;YES:
	MOVEM T1,CLN
	MOVE T1,CPG
	MOVEM T1,CPGL	;SET LINE AND PAGE
	PUSHJ P,SETALT	;SET THINGS UP
	MOVSI T2,1	;A LARGE COUNT
	PUSHJ P,ALTSP	;SPACES
	TRZ FL2,SUPN	;RESET SWITCH
	MOVEI T2,0
	PUSHJ P,[PUSHJ P,ALTIN
		 PUSHJ P,ALTN1
		 JRST LEVINS
		 AOS (P)
		 POPJ P, ]
	JRST LEVINS
	PUSHJ P,INSED	;PUT IN CHANGED LINE
EXPND2:	PUSHJ P,FINDN
	PUSHJ P,FILLB	;IN CASE OF OVERFLOW
	MOVE T1,(PNTR)	;GET BACK NEXT LINE
	JRST XPND1
PAGE:	AOS T2,CPG
	MOVEM T2,CPGL
	PUSHJ P,PGPRN	;SEE ALTER COMMAND
	MOVE T1,[<ASCII /00000/>!1]
	MOVEM T1,CLN
	JRST EXPND2
EXPEND:	TRNN FL,LINSN
	NERROR NLN
	JRST COMND
SUBTTL JOIN COMMAND
JOIN:	SETZM	LOLN	;AS USUAL
	TRNE	FL,READOF
	NERROR	ILC

JOIN1:	PUSHJ P,GET1S	;GET LINE NUMBER
	TRNN FL,TERMF
	NERROR ILC
	MOVE T1,HIPG
	MOVEM T1,DPG
	MOVE SINDEX,HILN	;FIND THE CORRECT LINE
	PUSHJ P,FIND
	MOVE T2,CPG
	MOVE T1,(PNTR)
	CAMN T2,HIPG
	CAME T1,HILN
	NERROR NLN
	MOVEM T2,CPGL
	MOVEM T1,CLN
	SETZM LIBUF	;TO ELIMINATE GARBAGE AT END OF LINE
	MOVE T1,[XWD LIBUF,LIBUF+1]
	BLT T1,LIBUF+MXWPL+1
	MOVE T2,PNTR	;GET THE POINTER TO THE LINE
	MOVE T3,(T2)	;PICK UP THE FIRST WORD
	MOVEI T4,LIBUF	;THE PLACE TO PUT IT
	JRST JSALT3	;TRANSFER
JSALT2:	SKIPE T3,(T2)
	TRNE T3,1	;IS IT THE END OF THE LINE
	JRST JSALT1
JSALT3:	MOVEM T3,(T4)	;PUT IT AWAY
	ADDI T4,1
	AOJA T2,JSALT2
JSALT1:	MOVEI T1,(T4)		;MOVEI T1,-LIBUF(T4)
	SUBI T1,LIBUF
	MOVEM T1,OCNT
	IMULI T1,5	;GET COUNT OF CHRS
	SUBI T1,6	;WE WILL HAVE TO FIND THE TRUE END
	SUBI T4,2
	HRLI T4,(<POINT 7,0,27>)	;SET UP POINTER
FEND1:	ILDB T2,T4
	CAIE T2,15
	AOJA T1,FEND1
	PUSH P,T1
	PUSHJ P,FINDN	;GET THE LINE TO JOIN IT TO
	CAME T1,PGMK
	SKIPN T1
	NERROR NNN	;NO LINE THERE TO CONNECT TO
	POP P,T2	;COUNT
	MOVEI T1,1(PNTR)
	HRLI T1,(<POINT 7,0,6>)	;SET TO POINT THERE
	ADD T4,[XWD 70000,0]
TRN1:	ILDB T3,T1
	IDPB T3,T4
	ADDI T2,1
	CAIL T2,MXWPL*5+6
	NERROR LTL
	CAIE T3,12
	JRST TRN1
	SUBI T1,-1(PNTR)
	PUSH P,OCNT
	HRRZM T1,OCNT	;SIZE OF OLD SECOND LINE
	SETZM NCNT
	PUSHJ P,INSED
	PUSHJ P,FINDB	;BACK UP
	POP P,OCNT	;GET ITS SIZE
	SUBI T4,LIBUF-1
	HRRZM T4,NCNT
	PUSHJ P,INSED
	JRST COMND

SUBTTL INDIRECT COMMAND
;INPUT ROUTINE FOR COMMAND FILE

RDCHAR:	PUSH	P,T1		;SAVE REGS
	PUSH	P,T2
RDCHR1:	MOVE	T1,INDJFN	;GET INPUT JFN
	BIN			;READ CHAR
	JUMPE	T2,INDEOF	;CHECK EOF
	MOVE	C,T2		;CHAR TO C
	JRST	POPRET		;COMMON EXIT

INDEOF:	GTSTS			;GET FILE STATUS
	TLNN	T2,(GS%EOF)	;REAL EOF?
	JRST	RDCHR1		;NO - SKIP NULLS
	MOVE	T1,SVCCIN	;RESTORE INPUT ROUTINE
	MOVEM	T1,CHIN
	TRZ	FL2,COMFLF	;NO LONGER INDIRECT
	MOVE	T1,INDJFN	;RELEASE WORLD
	CLOSF
	  FJERR
	HRROI	T1,[ASCIZ "%End of Indirect file.
"]
	PSOUT			;(215) TELL USER INDIRECT FILE'S DONE
	SETZM	INDJFN		;(222) CLEAR JFN STORAGE
	JRST	COMND		;(215) AND GO GET NEXT COMMAND FROM USER
;	NERROR	CMEND		;(215) OLD METHOD LOST TYPEAHEAD

;HANDLE @ COMMAND - READ COMMANDS FROM FILE

COMFIL:	TRNE	FL2,COMFLF	;TRYING TO NEST?
	NERROR  ILC
	CALL	GNCH		;PEEK AT NEXT CHAR
	CAIN	C,200		;AOK IF ESC
	JRST	COMFL1		;...
	AOS	TTICNT		;NO - BACK UP PNTRS
	MOVE	T1,TTIPNT
	ADD	T1,[7B5]
	MOVEM	T1,TTIPNT
COMFL1:	MOVSI	T1,(GJ%OLD!GJ%CFM) ;EXISTING FILE ONLY
	MOVEI	ALTP,INDBLK	;POINT TO BLOCK
	HRROI	T2,[ASCIZ "CMD"] ;DEFAULT EXTN
	TLO	FL2,EXCPFL	;(207) SET FLAG ITS A COPY
	CALL	READNE		;FILL IT
	  JRST	COMND		;ERROR
;**;[247]	Change 1 line at COMFL1:+6		DML	23-NOV-82
	  JRST	CTLUAB		;[247] ^U RETURN
	CALL	CKTERM		;GRNTEE EOL
	 NERROR	ILC
	MOVE	T1,INDJFN	;USE JFN
	MOVE	T2,[7B5+OF%RD]	;OPEN FOR INPUT
	OPENF
	  JERROR		;JSYS LOSAGE
	MOVE	T1,[ASCII /00000/]	;SET UP CMD COUNT
	MOVEM	T1,COMCNT
	TRO	FL2,COMFLF
	MOVEI	T1,RDCHAR	;SET UP INPUT ROUTINE
	EXCH	T1,CHIN		;AND SAVE CURRENT
	MOVEM	T1,SVCCIN
	JRST	COMND



	SUBTTL	DISPLAY TERMINAL INFO

;CURSOR UP FUNCTION

;**;[256]Add 7 lines at CURUP+9L		DEE	14-JUL-86
CURUP:
   REPEAT ^D10,<	;TYPES 0-9 ARE NON-DPY
	JFCL
   >
	OUTSTR [BYTE (7)32,177,177,177] ;VT05
	OUTSTR [BYTE (7)33,"A"]		;VT50
	JFCL				;LA30
	OUTSTR [BYTE (7)32,177,177,177]	;GT40 (VT05)
	JFCL				;LA36
	OUTSTR [BYTE (7)33,"A"]		;VT52
	OUTSTR [BYTE(7)33,"[","A"]	;VT100
	JFCL				;LA38
	JFCL				;LA120
   REPEAT ^D17,<
	JFCL
   >					;[256]RESERVED
	OUTSTR [BYTE(7)33,"[","A"]      ;[256]VT125
	OUTSTR [BYTE(7)33,"[","A"]	;[256]VK100
	OUTSTR [BYTE(7)33,"[","A"]	;[256]VT102
	JFCL				;[256]RESERVED
	OUTSTR [BYTE(7)33,"[","A"]	;[256]VT131
	OUTSTR [BYTE(7)33,"[","A"]	;[256]VT200-SERIES



;CRLF IF NOT A DPY

;**;[256]Add 7 lines at CRLF+10L		DEE	14-JUL-86
CRLF:	REPEAT ^D10,<
	OCRLF
    >
	JFCL				;VT05
	JFCL				;VT50
	OCRLF				;LA30
	JFCL				;GT40
	OCRLF				;LA36
	JFCL				;VT52
	JFCL				;VT100
	OCRLF				;LA38
	OCRLF				;LA120
	REPEAT ^D17,<
	JFCL	
    >					;[256]RESERVED
	JFCL				;[256]VT125
	JFCL				;[256]VK100
	JFCL				;[256]VT102
	JFCL				;[256]RESERVED
	JFCL				;[256]VT131
	JFCL				;[256]VT200-SERIES


;LINE-FEED IF NOT A DPY

;**;[256]Add 7 lines at LFD+10L		DEE	14-JUL-86
LFD:	REPEAT ^D10,<
	12
    >
	0				;VT05
	0				;VT50
	12				;LA30
	0				;GT40
	12				;LA36
	0				;VT52
	0				;VT100
	12				;LA38
	12				;LA120
	REPEAT ^D17,<			
	0
    >					;[256]RESERVED
	0				;[256]VT125
	0				;[256]VK100
	0				;[256]VT102
	0				;[256]RESERVED
	0				;[256]VT131
	0				;[256]VT200-SERIES



;TERMINAL TYPE NAME TABLE

;**;[256]Add 22 lines at TTYPE:+18L		DEE	14-JUL-86
TTYPE:	Z [ASCIZ "M33"]
	Z [ASCIZ "M35"]
	Z [ASCIZ "M37"]
	Z [ASCIZ "TI"]
	Z [ASCIZ "UNDEFINED"]
	Z [ASCIZ "UNDEFINED"]
	Z [ASCIZ "UNDEFINED"]
	Z [ASCIZ "UNDEFINED"]
	Z [ASCIZ "DEFAULT"]
	Z [ASCIZ "IDEAL"]
	Z [ASCIZ "VT05"]
	Z [ASCIZ "VT50"]
	Z [ASCIZ "LA30"]
	Z [ASCIZ "GT40"]
	Z [ASCIZ "LA36"]
	Z [ASCIZ "VT52"]
	Z [ASCIZ "VT100"]
	Z [ASCIZ "LA38"]
	Z [ASCIZ "LA120"]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "VT125"]	;[256]
	Z [ASCIZ "VK100"]	;[256]
	Z [ASCIZ "VT102"]	;[256]
	Z [ASCIZ "UNDEFINED"]	;[256]
	Z [ASCIZ "VT131"]	;[256]
	Z [ASCIZ "VT200-SERIES"] ;[256]

MXTRM=.-TTYPE-1				;MAX TERMINAL TYPE

DFTRM=^D8				;DEFAULT

SUBTTL LITERALS
XLIST
LIT		;CLEAR ALL LITERALS
LIST
SUBTTL IMPURE AREA
;IMPURE SECTION IS DIVIDED INTO TWO AREAS
;1) DATA WHICH IS SEMI CONSTANT
;2) DATA WHICH IS INITIALLY ZEROED

DATAB:
;**;[245]	Insert 58 lines after DATAB:+0		DML	10/21/82

INIFDB:	BYTE (9).CMINI		;[245] INITIALIZATION FUNC. DESC. BLOCK (FDB)
	Z			;[245]
	Z			;[245]
	Z			;[245]
	Z			;[245]

KWFDB:	<BYTE (9).CMKEY>+CM%DPP ;[245] KEYWORD FDB
	CMDTAB			;[245] ADDRESS OF COMMAND TABLE
	Z			;[245]
	-1,,[ASCIZ/EDIT/]	;[245] POINTER TO DEFAULT COMMAND
	Z			;[245]

NOIFDB:	BYTE (9).CMNOI		;[245] NOISE FDB
	Z			;[245]
	Z			;[245]
	Z			;[245]
	Z			;[245]

IFFDB:	<BYTE (9).CMIFI>+OFFDB	;[245] INPUT FILESPEC FDB (LINK TO OFFDB)
	Z			;[245]
	Z			;[245]
	Z			;[245]
	Z			;[245]

OFFDB:	BYTE (9).CMOFI		;[245] OUTPUT FILESPEC FDB
	Z			;[245]
	Z			;[245]
	Z			;[245]
	Z			;[245]

CONFDB:	BYTE (9).CMCFM		;[245] CONFIRMATION FDB
	Z			;[245]
	Z			;[245]
	Z			;[245]
	Z			;[245]

CBUFSZ==^D200			;[245] COMMAND BUFFER SIZE
ABUFSZ==^D50			;[245] ATOM BUFFER SIZE

;**;[253]  Replace 3 lines with 4 at CMDTAB:+0		DML	20-Nov-84
CMDTAB:	3,,3			;[253][245] # OF ENTRIES,,MAX # OF ENTRIES
	[ASCIZ/CREATE/],,1	;[253][245] CREATE COMMAND ENTRY
	[ASCIZ/EDIT/],,0	;[253][245] EDIT COMMAND ENTRY
	[ASCIZ/PERUSE/],,2	;[253] PERUSE COMMAND ENTRY

CMDBLK:	CM%RAI+INPAR		;[245] COMMAND BLOCK FOR PARSE
	.PRIIN,,.PRIOU		;[245] INPUT JFN,,OUTPUT JFN
	-1,,[ASCIZ/Retype command: /]  ;[245] PROMPT TEXT (CTRL/R TEXT)
	-1,,CMDBUF		;[245] START OF TEXT
	-1,,CMDBUF		;[245] NEXT INPUT TO BE PARSED
	5*CBUFSZ-1		;[245] SPACE LEFT IN BUFFER
	0			;[245] UNPARSED CHARACTERS
	-1,,ATMBUF		;[245] ATOM BUFFER LOCATION
	5*ABUFSZ-1		;[245] SIZE OF ATOM BUFFER
	GTJBLK			;[245] LOCATION OF GTJFN BLOCK FOR COMND

ATMBUF:	BLOCK ABUFSZ		;[245] ATOM BUFFER
GTJBLK:	BLOCK 17		;[245] GTJFN BLOCK FOR COMND
;**;[253]  Replace 1 line with 2 at CMDFLG:+0		DML	20-Nov-84
CMDFLG: BLOCK 1			;[253][245] COMMAND FLAG 
				;[253] (1=CREATE,0=EDIT,2=PERUSE)

TEXTIB:	EXP	6		;LENGTH OF BLOCK
	RD%TOP!RD%JFN		;FLAGS
	.PRIIN,,.PRIOU		;INPUT,,OUTPUT
	-1,,TTIBUF		;BUFFER PNTR
	5*20			;CHAR COUNT
	-1,,TTIBUF		;TOP OF BUFFER
	-1,,CRBUF		;CONTROL-R BUFFER

CJFNBK:	Z			;BLOCK FOR GTJFN
	.PRIIN,,.PRIOU		;JFNS
	Z			;DEVICE
	Z			;DIRECTORY
	Z			;NAME
	Z			;EXTENSION
	Z			;PROTECTION
	Z			;ACCOUNT
	Z			;DESIRED JFN
	G1%RBF!G1%RND+4		;FLAGS,,LEN
	Z			;COPY BUFFER PNTR
	Z			;COPY BUFFER COUNT
	-1,,CRBUF		;^R BUFFER
	-1,,TTIBUF		;TOP OF BUFFER

IFN EXTEND,<
LSBUFN: 	LSNUM
LSPTR:
	I==0
REPEAT LSNUM,< POINT 7,LSBUF+<SRBLG/5+2>*I
	I==I+1
>
LSPTT:
	I==0
REPEAT LSNUM,< EXP LSPNT+SRNUM*I
	I==I+1
>
>
PGMK:	<ASCII /     />!1
PGMKW2:	BYTE (7)15,14,0,0,0
SQBUF:	BLOCK 1
	ASCII /	/

ASCZ1: ASCII /INC1=/
PRNTO1: EXP	0
	ASCIZ /
/
ASCIZ2: ASCII /Inc2=/
PRNTO2: EXP	0
	ASCIZ /
/

;STUFF FOR JUSTIFICATION

PAGESZ:	EXP	PGSZ
PLINES:		20	;DEFAULT VALUE FOR P CMD
ESC:		33	;DEFAULT ESCAPE CHAR
COMESS: ASCII /COMMAND # /
COMCNT:  EXP	0
	BYTE (7) 15,12
LINOUT:  EXP	0
	  ASCIZ ./.

;CONTROL BLOCK FOR CNTRL C TRAPPING

CNCLOK:	-1		;INTERLOCK FOR RE-ENTRANT HANDLING

;PSI TABLES

RETSAV:	0		;INTERRUPT PC

LEVTAB:	0,,RETSAV	;PSI-LEVEL TABLE
	0
	0

CHNTAB:	BLOCK 3		;0 TO 2
TRPCHN==.-CHNTAB
	1,,TRAP		;CTRL-C HAS OWN CHANNEL
	BLOCK 5		;4 TO 8
	1,,PDLTRP	;9-PDL OVERFLOW
	BLOCK 2		;10 - 11
	1,,DSKTRP	;12 - QUOTA EXCEEDED
	BLOCK 7		;13 - 19
	1,,DSKTRP	;20-MACHINE SIZE EXCEEDED (QUOTA ALSO)
	BLOCK	^D15	;21 TO 35

ONCHAN:	1B<TRPCHN>+1B<.ICPOV>+1B<.ICQTA>+1B<.ICMSE> ;CHANNELS TO BE ACTIVATED

;MACRO TO GENERATE FILE-SPEC BLOCKS

JFN==0		;JFN ASSIGNED TO THIS SPEC
FIL==1		;POINTER TO FILESPEC
COD==2		;ENCRYPTION PSW
ASZ==3		;ASCIZ STRING FOR FILESPEC

	DEFINE FILDES (F) <
	IRP F,<
F'BLK==.
F'JFN:	BLOCK	1
F'FIL:	BLOCK	1
F'COD:	BLOCK	1
F'ASZ:	BLOCK	FILSIZ
F'BKE==.-1>>
;REST IS RANDOM VARIABLES AND BUFFERS


ZEROB==.
PNOARG:	BLOCK	1	;(195) 0=LAST CMND NOT P W/ NO ARGS
			;(195) NOT 0= WAS P W/ NO ARGS
BAKF:	BLOCK	1	;0 := NOBACKUP , -1 := BAK , +1 := OLD
CREATF:	BLOCK	1
SVWD:	BLOCK	1
SVWD2:	BLOCK	1
SVWD3:	BLOCK	1
SVSEQN:	BLOCK	1		;SAVED SEQUENCE NUMBER FOR ORDCHK
TMPT1:	BLOCK	1
MODW:	BLOCK	1	;PLACE TO SAVE TERMINAL MODE WORD (RFMOD)
COCW1:	BLOCK	1	;PLACE TO SAVE RFCOC WORDS
COCW2:	BLOCK	1	;...
UNSEQF:	BLOCK	1
RPGSW:	BLOCK	1
PZBEG==.
IFN CRYPSW,<
CODBUF: BLOCK	10
>
FILDES <ORG,NEW,ICR,OCR,IND,ALT>

PZEND==.-1
FILDES <RUN>

ORGPRT:	BLOCK	1		;PROTECTION OF ORIGINAL FILE
GJBITS:	BLOCK	1	;BITS FOR GTJFN OF INPUT FILE
OPNJFN:	BLOCK	1	;SAVED JFN FOR OPENF RECOVERY
LPTJFN:	BLOCK	1		;JFN FOR L COMMAND
OPTJFN:	BLOCK	1		;JFN FOR OPTION FILE
NOCTLC:	BLOCK	1		;CTRL-C ON/OFF FLAG
ERCOD:	BLOCK	1	;LAST JSYS LOSAGE
DTYPE:	BLOCK	1	;TERMINAL TYPE CODE
BUFP:	BLOCK	1	;POINTER TO CURRENT LOC IN EDIT BUFFER
SSW:	BLOCK	1
RSW:	BLOCK	1
CORTOP:	BLOCK	1
FILPT:	BLOCK	1
MAXWC:	BLOCK	1	;MAX FULL POINT IN EDIT BUFFER
HLFWC:	BLOCK	1	;HALF FULL POINT IN EDIT BUFFER
CLN:	BLOCK	1	;CURRENT LINE
INCR:	BLOCK	1
ISVINC:	BLOCK	1	;SAVED TEMPORARY INCR. FOR INSERT
CURINS:	BLOCK	1
CPG:	BLOCK	1	;CURRENT PAGE
CPGL:	BLOCK	1	;LOGICAL CURRENT PAGE "/."
IPG:	BLOCK	1	;INSERT PAGE
INPG:	BLOCK	1	;CURRENT INPUT PAGE SEEN
OPG:	BLOCK	1	;COUNT OF PAGES OUTPUT
WC:	BLOCK	1	;WORD COUNT IN EDIT BUFFER
OLDLIN:	BLOCK	1
SSAVEN:	BLOCK	1
SAVEN:	BLOCK	1
SISAVN:	BLOCK	1
ISAVEN:	BLOCK	1
ALTSN:	BLOCK	1	;ALTMODE SEEN FLAG (I&R)
ALTINC:	BLOCK	1	;ALTER MODE I CMD INCR
ALTFLG:	BLOCK	1
CASEBT:	BLOCK	1
BGPG:	BLOCK	1
ACCUM:	BLOCK	1
SVERN:	BLOCK	1
SAVCHR:	BLOCK	1
TECINC:	BLOCK	1
TECFST:	BLOCK	1
TEMINC:	BLOCK	1
REINC:	BLOCK	1
INCST:	BLOCK	1
REFST:	BLOCK	1
ALTCNT:	BLOCK	1
LOGPG:	BLOCK	1
LSTCNT:	BLOCK	1
SVCCNT:	BLOCK	1
SAVC:	BLOCK	1
IFN EXTEND,<
LSHIPG:	BLOCK	1
LSHILN:	BLOCK	1
LSCNT:	BLOCK	1
LSPG:	BLOCK	1
LSBUF:	BLOCK	<SRBLG/5+2>*LSNUM
LSPNT:	BLOCK	SRNUM*LSNUM
>
LIMBO:	BLOCK	1	;LIMBO CHAR AFTER BELL
CHIN:	BLOCK	1	;INPUT PNTR
SVCCIN:	BLOCK	1	;SAVED INPUT ROUTINE FOR @ CMDS
SVPCIN:	BLOCK	1	;SAVED INPUT ROUTINE FOR PARSE
TTOBUF:	BLOCK	^D200/5+1
TTOCNT:	BLOCK	1	;OUTPUT CNTR
TTOPNT:	BLOCK	1	;OUTPUT PNTR
TTICNT:	BLOCK	1	;INPUT CNTR
TTIPNT:	BLOCK	1	;INPUT PNTR
CRBUF:	BLOCK	2	;CONTROL-R BUFFER
FSFLG:	BLOCK	1	;PROMPT INFO/FLAG FOR F & S COMMANDS

AIPB:			;ALT INPUT BLOCK
AIPJFN:	BLOCK	1	;JFN
AIPCNT:	BLOCK	1
AIPBYT:	BLOCK	1
AIPTXT:	BLOCK	1
AIPPNT:	BLOCK	1
AIPFSZ:	BLOCK	1
AIPBUF:	BLOCK	1

CIPB:
CIPJFN:	BLOCK	1
CIPCNT:	BLOCK	1
CIPBYT:	BLOCK	1
CIPTXT:	BLOCK	1
CIPPNT:	BLOCK	1
CIPFSZ:	BLOCK	1
CIPBUF:	BLOCK	1

IJFN==0
CNT==1
BYT==2
TXT==3
PNT==4
FSZ==5
BUF==6

OUPNT:	BLOCK	1	;OUTPUT BUFFER PNTR
OPCNT:	BLOCK	1	;OUTPUT PAGE # CNTR
AUXFLG:	BLOCK	1
PDL:	BLOCK	PDLSIZ+1	;PUSHDOWN LIST
P.TEXT: BLOCK	1
NPAGS:	BLOCK	1		;EDIT WINDOW SIZE
DEVSTR:	BLOCK	20		;BUFFER FOR OUTPUT DEV:<STR>
DEVST2:	BLOCK	20		;(197)
SAMDEV:	BLOCK	1		;(197)
TEMPS:	BLOCK	2		;VERY TEMPORARY STORAGE
CMDBUF==LIBUF			;COMMAND BUFFER
CRSX==LIBUF+777		;PLACE FOR CR'S
SVPT:	BLOCK	1
CODEBF:	BLOCK	4*SRNUM+2
BUFSAV:	BLOCK	1
ARBCNT:	BLOCK	1
SRHIPG: BLOCK	1
SRHILN: BLOCK	1
SRCNT:	BLOCK	1
SRBUF:	BLOCK	SRBLG/5+2
SRPG:	BLOCK	1
SRPNT:	BLOCK	SRNUM
BOTLIN:	BLOCK	1
PGDELS:	BLOCK	1
STARTD:	BLOCK	1	;WHERE TO START TO DELETE ON TRANSFER
ENDD:	BLOCK	1	;WHERE TO END DELETING ON TRANSFER
TRANST:	BLOCK	1
PGINSD:	BLOCK	1
DESTLN:	BLOCK	1
DESTPG:	BLOCK	1
FINCR:	BLOCK	1
SINCR:	BLOCK	1
SVLNUM:	BLOCK	1
LSTPG:	BLOCK	1
COPDL:	BLOCK	1
HIGH1:	BLOCK	1
NLIN1:	BLOCK	1	;# OF LINES ON FIRST PAGE OF C/T
NLIN2:	BLOCK	1	;# OF LINES ON LAST PAGE OF C/T
START2:	BLOCK	1	;STARTING LINE # FOR LAST PG OF C/T
LSTLN:	BLOCK	1	;LAST LINE # SEEN DURING C/T
PARCNT:	BLOCK	1
RPPG:	BLOCK	1
RPCNT:	BLOCK	1
FNDFLG:	BLOCK	1
R1BUF:	BLOCK	SRBLG/5+2
R2BUF:	BLOCK	SRBLG/5+2
RPHILN:	BLOCK	1
RPHIPG:	BLOCK	1
R1PNT:	BLOCK	SRNUM
R2PNT:	BLOCK	SRNUM
CCNT:	BLOCK	1
RSTRCT:	BLOCK	1
SVOCIN:	BLOCK	1
OPTION:	BLOCK	1
SVALTP:	BLOCK	1
DPG:	BLOCK	1
SVINC:	BLOCK	1
SVCNT:	BLOCK	1
OCNT:	BLOCK	1	;OLD WC FOR INSED
NCNT:	BLOCK	1	;NEW WC FOR INSED
SRCALP:	BLOCK	1
VAR		;IF ANY (I HOPE THIS WORKS)
ZEROE==.-1
HILN:	BLOCK	1	;RESULTS OF RANGE PARSE
HIPG:	BLOCK	1	; <LOLN>/<LOPG>:<HILN>/<HIPG>
LOLN:	BLOCK	1
LOPG:	BLOCK	1

ECFLG:	BLOCK	1		;(194) ECHO FLAG
USEIND:	BLOCK	1	;IF WE WERE IN IND FILE AT TIME OF CKIND

EPAT::
IMPEND:


	END	3,,EV		;POINT TO ENTRY VECTOR
