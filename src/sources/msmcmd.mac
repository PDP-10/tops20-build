;This software is furnished under a license and may only be used
;  or copied in accordance with the terms of such license.
;
;Copyright (C) 1979,1980,1981,1982 by Digital Equipment Corporation
;	       1983,1984,1985,1986    Maynard, Massachusetts, USA


	TITLE MSMCMD - Misc MS commands

	SEARCH GLXMAC,MSUNV,MACSYM
TOPS20<	SEARCH MONSYM>
	PROLOG (MSMCMD)

	CPYRYT
	MSINIT

	.DIRECTIVE FLBLST
	SALL

;Define globals

	GLOBS			; Storage
	GLOBRS			; Routines


;Globals defined elsewhere

	EXTERNAL BINOUT,MOVST0,CRIF,CRLF,TTINI,NETFLG,RJ.AMA,RJ.VMA
TOPS20<	EXTERNAL UNMAPF>
	EXTERNAL ABREL,ADRLST,ALCSB,ATMBUF,AUTCMT,AUTEXP,BLKTIM,CFIELD
	EXTERNAL CJFNBK,CKEXIT,CLOSEF,CMDTAB,COMPAC,COUNTS,CPYATM,CRFDEV
	EXTERNAL CRFDIR,CRFDTB,CRFPRT,DEFCC,DFCMTB,EXPRNC,F%NO,FILPGS,FILSIZ
	EXTERNAL FLAGS2,FSPEC,GET1,GETHLP,GO,HD%KWD,HDITAB,HDTNAM,HLPTAB,HLPTXT
	EXTERNAL HOSTAB,INIFOB,INIIFN,ININAM,INIP,KWDLST,LASTRD,LIBVER,MINWSZ
	EXTERNAL MOVDSP,MOVHDO,MVALST,NDELET,NFLAGD,OHSNMX,PERSON,RCMDTB,RECEN0
	EXTERNAL REDNOV,REDPTR,RELFOB,RELSB,REPADD,RFIELD
TOPS20<	EXTERNAL RUNFIL,RUNFL0,RUNFL2>
	EXTERNAL SCMDTB,SCRBTM,SCRLFL,SCRREG,SCRRGR,SENNOV,SENPTR,SETIOJ,SETNOV
	EXTERNAL SETPTR,SHCMTB,STCMT0,STCMTB,STRBSZ,SVMFOB,TBADDS,TOPNOV,TOPPTR
	EXTERNAL TYPE1,UNSEEN,V52FLG
TOPS10<	EXTERNAL CTX,ECHOON,MSGFD,MYPPN,CRFFDH>
	INTERNAL BLANK0,.BBORD,.BLANK,.CREAT,.ECHO,.FINIS,.HELP
	INTERNAL .PUSH,.QUINI,.QUIT,.SET,.SHADL,.SHDEF,.SHHDI
	INTERNAL .SHINT,.SHOW,.SHSYN,.STATU,.STAUF,.STAUT,.STBFD
	INTERNAL .STCDI,.STCLZ,.STCNC,.DAYTI
	INTERNAL .STCPR,.STDCC,.STDFT,.STDLC,.STEXP,.STHLP,.STHPR
	INTERNAL .STINC,.STNO,.STOHS,.STPNM,.STPN1,.STRAD,.STRPA,.STRPS
	INTERNAL .STSPH,.STSUM,.STVID,.STWSZ,.TAKE,.VERSI,MSGOD0,.MSGOD
	INTERNAL KWDREL, .TAKE0, SUMMRY, .STEX0
	INTERNAL .STLGD,.STCND,.STFDI
TOPS20<	INTERNAL .MAILR>

SUBTTL TAKE command (used for init file)

.TAKE:	NOISE (commands from)
	MOVE T,TAKPTR		; Init IFN stack pointer
TOPS10<	CALL ECHOON >		; In case monitor command
   TOPS20<
	HRROI A,[ASCIZ /CMD/]	; default extension
	MOVEM A,CJFNBK+.GJEXT	;  ..
   >;End TOPS20
   TOPS10<
	SETZM CJFNBK		; Zero previous defaults
	MOVE A,[CJFNBK,,CJFNBK+1]
	BLT A,CJFNBK+CJFNLN-1
	MOVSI A,(SIXBIT /CMD/)	; Default only the extension
	MOVEM A,CJFNBK+.FDEXT
   >;End TOPS10
	CALL FSPEC		; get filespec
	 JRST [	WARN (No file specified)
		RET]
	HLRE C,T		; First check room on the stack
	MOVN C,C		; Get size of area left
	CAIGE C,3		; Need three words
	JRST [	MOVE C,FOB.FD(B)	; No room, point to FD for error msg
		CALL CRIF		; Get to left margin
		$TEXT (KBFTOR,<?Command files nested too deeply, detected in opening ^F/(C)/>)
		CALLRET RELFOB]		; Release FOB and give failure return
	PUSH T,A		; Save FOB info
	PUSH T,B		;  ..
	$CALL F%IOPN		; Open the file
	JUMPF [	POP T,B			; Recover FOB info
		POP T,A			;  ..
		HRRZ C,FOB.FD(B)	; For error message
 		$TEXT (KBFTOR,<?Can't open command file ^F/(C)/ because: ^E/[-1]/>)
		CALLRET RELFOB]		; Release chunks
.TAKE0:	PUSH T,A		; Push IFN onto take stack
	MOVEM T,TAKPTR		; Preserve stack pointer
	CALLRET SETIOJ		; Set up COMND I/O pointers and return

SUBTTL Help command for structured help file

;First word on each page of help file is topic name

.HELP:	STKVAR <<.HELP1,4>>	; Temp space for 2 FLDDBs
	NOISE (with topic)
	SKIPN HLPTAB		;  ..
	CALL HLPINI		; No, get one then
	SKIPN HLPTAB		; Did we make it?
	 RET			; Nope, give up.
	DMOVE A,[FLDDB. (.CMCFM)]
	DMOVEM A,.HELP1
	DMOVE A,[FLDDB. (.CMKEY)]
	DMOVEM A,2+.HELP1
	MOVE A,HLPTAB		; Pointer to help keyword table
	MOVEM A,2+.CMDAT+.HELP1	; Init FLDDB block
	MOVEI A,2+.HELP1	; Chain the blocks together
	HRRM A,.CMFNP+.HELP1	;  ..
	MOVEI A,.HELP1		; Point to the chain
	CALL RFIELD		; Parse user response
	MOVE A,CR.COD(A)	; Get function parsed
	CAIN A,.CMCFM		; Just CR typed?
	JRST [	$TEXT (KBFTOR,<
Type "help topic" to get help with a particular topic.  Type
"help ?" to get a list of all the topics for which help is available.
If this is the first time you have used MS, type "help introduction".
>)
		RET]
	HRRZ C,(B)		; Get character address of topic
	CONFRM
	MOVE A,HLPTXT		; Point to first byte
	ADJBP C,A		; Point to topic
.HELP0:	ILDB A,C		; Get next byte
	SKIPE A			; Last byte?
	CAIN A,14		;  or form feed?
	CALLRET CRLF		; Yes, crlf and quit
	$CALL KBFTOR		; No, type this char
	JRST .HELP0		;  and go for next


;Parse help file -- adds each topic name to TBLUK-style table
; Each page of the help file starts with the topic name

HLPINI:	ACVAR <HPTR,LOC>	; Ptr to help text, loc of topic name
	STKVAR <HLPST0>		; Topic name addr, temp string space
	CALL GETHLP		; Read help file
	SKIPN HPTR,HLPTXT	; Point to it, if it's there
	 RET			; Not there, GETHLP couldn't open it.
	SETZB D,LOC		; First topic is at byte zero
	JRST HLPIN3		; Go find first topic name

;Here with HPTR pointing to first byte of a topic name

HLPIN4:	MOVE B,[POINT 7,STRBUF]	; Temporary storage for string
	MOVEI C,<STRBSZ*5>-1	; Maximum bytes in the string
HLPIN0:	ILDB A,HPTR		; Get next byte of topic name
	JUMPE A,HLPINX		; Null -- end of help text
	CAIE A,15		; Anything funny terminates it
	CAIN A,12
	AOJA D,HLPIN1		; Count chars
	CAIE A,11		; Tab
	CAIN A,40		; Space
	AOJA D,HLPIN1
	IDPB A,B		; Nonfunny - store char
	SOJLE C,[MOVE A,[POINT 7,STRBUF] ; Name too long -- point to fragment
		WARN (Topic name too long -- %1S)
		AOJA D,HLPIN1]		; Just truncate the name
	AOJA D,HLPIN0		; Go get next char
HLPIN1:	SETZ A,			; Insure ASCIZ
	IDPB A,B		;  ..
	MOVE A,[POINT 7,STRBUF]	; Point to topic name string
	CALL COUNTS		; Count the bytes
	CALL ALCSB		; Allocate a string block
	 JRST [	WARN <Can't build HELP table, insufficient memory>
		RET]
	MOVEM B,HLPST0		; Save address of string
	MOVE A,B		; Set up for MOVST0
	HRLI A,(POINT 7,)	; Form kosher byte pointer
	MOVEI B,STRBUF		; Point to string parsed
	CALL MOVST0		; Copy to string space
	HRLZ B,HLPST0		; Get string addr of topic name in LH
	HRR B,LOC		; Put char addr of this topic in RH
	MOVEI A,HLPTAB		; Addr of ptr to TBLUK table
	CALL TBADDS		; Add the entry
	JUMPF [	WARN (Problem building help topic table)
		CALL CRLF
      		JRST .+1]
HLPIN2:	ILDB A,HPTR		; Next char of help text
	JUMPE A,HLPINX	  	; Null -- end of help file
	ADDI D,1		; Count chars
	CAIE A,14		; Look for form feed
	JRST HLPIN2		; Not yet
HLPIN3:	ILDB A,HPTR		; Skip to first non-white-space char
	JUMPE A,HLPINX		; Null means end of help text
	CAIE A,15		;  ..
	CAIN A,12		;  ..
	AOJA D,HLPIN3		; Count chars
	CAIE A,40		; Space
	CAIN A,11		; Tab
	AOJA D,HLPIN3		; Count chars
	MOVNI A,1		; Back up so ILDB at HLPIN0 works
	ADJBP A,HPTR		;  ..
	MOVEM A,HPTR		;  ..
	MOVEM D,LOC		; Save char addr of next topic
	JRST HLPIN4		; Go add it to table

HLPINX:	MOVE A,HLPTAB		; Done, compact table
	CALLRET COMPAC		;  and return

SUBTTL BBOARD - Bulletin board reader

.BBORD:	NOISE (from file)
	TXZ F,F%F2		; Allow printing of file status
	TXZ F,F%RSCN		; Don't return to EXEC after reading file
   TOPS20<
	MOVX A,GJ%OLD		; Must exist
	MOVEM A,CJFNBK+.GJGEN
	HRROI A,[ASCIZ /POBOX:/]	; Default to PS:<logged-in-directory>
	MOVEM A,CJFNBK+.GJDEV
	HRROI A,[ASCIZ /BBOARD/]
	MOVEM A,CJFNBK+.GJDIR
	HRROI A,[ASCIZ /MAIL/]
	MOVEM A,CJFNBK+.GJNAM
	HRROI A,[ASCIZ /TXT/]
	MOVEM A,CJFNBK+.GJEXT
   >;End TOPS20
   TOPS10<
	SETZM CJFNBK		; First zero the block
	MOVE A,[CJFNBK,,CJFNBK+1]
	BLT A,CJFNBK+CJFNLN-1
	MOVE A,[SIXBIT /PUB/]
	MOVE A,CJFNBK+.FDSTR
	MOVE A,[SIXBIT /MAIL/]
	MOVEM A,CJFNBK+.FDNAM
	MOVSI A,(SIXBIT /TXT/)
	MOVEM A,CJFNBK+.FDEXT
	MOVE A,[1,,6]
	MOVEM A,CJFNBK+.FDPPN
   >;End TOPS10
	MOVEI A,[FLDDB. .CMFIL]
	CALL CFIELD
	TXZ F,F%AMOD
	TXO F,F%MOD		; Like system-messages...
	JRST GET1

SUBTTL MSGOD - Message of the day

.MSGOD:	CONFRM
	TXZ F,F%RSCN		; Don't uselessly return to EXEC if EXEC cmd
MSGOD1:
   TOPS20<
	MOVX A,GJ%SHT!GJ%OLD!GJ%PHY	; Existing file, physical-only
	HRROI B,[ASCIZ /POBOX:<SYSTEM>MAIL.TXT.1/]
	GTJFN			; Get JFN on system message file
	 ERJMP [WARN (No system message file)
		RET]
	MOVE B,A		; Copy JFN to b for GET1
	TXO F,F%MOD		; Set flag for system mail
	JRST GET1		; Now get file
   >;End TOPS20

   TOPS10<
	STKVAR <SYSFD>
	MOVEI A,FDXSIZ		; Get a chunk for an FD
	$CALL M%GMEM		;  ..
	JUMPF [	WARN (Can't read system message file -- insufficient memory)
		RET]
	MOVEM B,SYSFD
	HRLZM A,.FDLEN(B)	; Stuff its length
	MOVSI A,'STD'		; Where file lives
	MOVEM A,.FDSTR(B)
	MOVE A,[SIXBIT /MAIL/]
	MOVEM A,.FDNAM(B)
	MOVE A,[SIXBIT /TXT/]
	MOVEM A,.FDEXT(B)
	TXO F,F%MOD		; Set funny flag
	CALL GET1		; Read, parse file
	MOVEI A,FDXSIZ		; Release the FD now
	MOVE B,SYSFD		;  ..
	$CALL M%RMEM		;  ..
	RET
   >;End TOPS10

; Auto MOD stuff

MSGOD0:	CALL MSGOD1		; Commom get routine
	MOVEI A,NXTNEW		; Setup message sequencer
	MOVEM A,NXTMSG
	MOVE L,MSGSEQ		;**
	ADD L,[POINT 18,0]
	CALL STQDL2		; Create msg sequence
	CALL TYPE1		; Use type routine (New)
	PUSH P,[GO]		; In case continue
TOPS20<	CALL UNMAPF>		; Unmap it
	CALL CLOSEF		; Close and release lock on message file
	CALLRET CKEXIT		; Now exit


.ECHO:	MOVEI A,[FLDDB. (.CMTXT)]
	CALL RFIELD		; Parse arbitrary text
	CONFRM
	MOVE A,[POINT 7,ATMBUF]
	CALL KBFTOR		; Type the string and return
	CALL CRLF
	$CALL K%FLSH		; Empty the buffer
	RET



.QUIT:	NOISE (MS)
	CONFRM			; Confirm first
	CALLRET CKEXIT


;Quit from MS Create-init>> mode without writing init file

.QUINI:	NOISE (without updating init file)
	CONFRM
	MOVE A,INIIFN		; Close the init file
	$CALL F%RREL		; Release without writing
	DMOVE A,INIFOB		; Release chunks associated with file
	CALL RELFOB		;  ..
	SETZM INIIFN
	RET


;Finish creating init file (close init file nicely)

.FINIS:	NOISE (and update init file)
	CONFRM
	MOVE A,INIIFN
	$CALL F%REL		; Close file
	DMOVE A,INIFOB		; Release chunks associated with file
	CALL RELFOB
	SETZM INIIFN
	RET


.BLANK:	NOISE (screen)
	CONFRM
	SKIPE INIP		; If doing init file,
	TXNN F,F%AMOD		;  while doing auto MOD,
	SKIPA			;  ..
	RET			; Don't blank the screen
BLANK0:	SKIPN V52FLG		; Doing screen clearing?
	JRST BLANK2		; No, skip this
	$CALL K%FLSH		; Yes, insure TTY buffers flushed
	SKIPN BLKTIM		; Are we possibly delayed here?
	JRST BLANK1		; No, just do it then
	$CALL I%NOW		; Get current date/time
	SUB A,BLKTIM		; Get interval to next OK time for clearing
	JUMPGE A,BLANK1		; Interval already passed, just do it
	MOVN A,A		; Get positive delay time (fractions of a day)
	IDIVI A,<<1,,0>/<^D24*^D60*^D60>> ; Compute seconds (from UDT format)
	JUMPE A,BLANK1		; Not enough time left to care about
	$CALL I%SLP		; OK, sleep that amount before clearing
BLANK1:	MOVE A,V52FLG		; Get clear-screen sequence pointer
	CALL BINOUT		; Type it
	CALL @SCRRGR		; Undo any scroll-region junk
	SETZM SCRLFL		; Reset scroll-region flag
BLANK2:	$CALL K%FLSH		; Dump TTY output
	SETZM BLKTIM
	RET



;Create-init-file

.CREAT: NOISE (for setting permanent defaults)
	CONFRM
	TXZ F,F%RSCN		; Don't uselessly return to EXEC
	MOVE T,TAKPTR		; Insure not from command file
	MOVE A,(T)		; Get input IFN
	CAIE A,.PRIIN		; Better be TTY
	JRST [	CMERR (Create-init-file command not allowed inside command file)
		RET]
	CALL ININAM		; Do common init filespec build
	 RET			; Failure, msg already typed
	DMOVEM A,INIFOB		; Save FOB size and address
	$CALL F%IOPN		; See if already exists
	JUMPF .CREA0		; No, this is OK then
	WARN <Superseding existing init file>
	$CALL F%REL		; Release input IFN
.CREA0:	DMOVE A,INIFOB		; Get FOB pointers again
	$CALL F%OOPN		; Open for output
	MOVEM A,INIIFN		; remember the IFN
	TXNE F,F%CONC		; concise mode?
	RET			; yes, return now
	CITYPE (<
Give commands whose effects you wish to have remembered as permanent
defaults (for example, SET PERSONAL-NAME, SET CONCISE-MODE, etc.).
Commands which cause actions (READ, SUMMARIZE NEW, etc.) will be executed
every time MS starts up.  Give the QUIT command to leave this mode
without changing anything, or the FINISH command to make your
changes permanent.>)
	CALL CRLF
	RET

 SUBTTL Set commands


.SET:	NOISE (parameter)
	TXZ F,F%NO		; Note "no" not typed yet
	SKIPN INIP		; If not in init file,
	TXZ F,F%RSCN		;  then don't uselessly return to EXEC
	MOVE A,SETPTR		; Point to command set
.SET0:	CALL RFIELD
	HRRZ A,(B)
	CALL (A)
	TXZ F,F%NO
	RET


;No

.STNO:	TXO F,F%NO		; Remember "no" typed
	MOVEI A,[FLDDB. (.CMKEY,,STCMT0)]
	JRST .SET0		; table without "no" in it


;Set include-me-in-replies

.STINC:	CONFRM
	TXNE F,F%NO		; "no" typed?
	TXZA F,F%RPIN		; yes, clear include-me flag
	TXO F,F%RPIN		; set it
	RET


;Set brief-address-list-display

.STBFD:	CONFRM
	TXNE F,F%NO
	TXZA F,F%BREF
	TXO F,F%BREF
	RET


;Set Personal-name <text>

.STPNM:	NOISE (used in outgoing mail)
	TXZE F,F%NO		; "No" typed?
	JRST [	CONFRM
		SETZ	A,	; Yes, flush personal name
		JRST .STPN4]
	MOVEI A,[FLDDB. (.CMTXT,CM%SDH,,<
Your full name, as you'd like it to appear in mail you send
>)]
	CALL RFIELD
.STPN1:	LDB A,[POINT 7,ATMBUF,6]
	JUMPE A,.STPN4		; If null arg given, zap whole word
	CALL CPYATM		; Allocate string block, copy string to it
	 JRST [	WARN <Can't set personal name, insufficient storage>
		RET]
.stpn4:	EXCH A,PERSON		; Stuff address of new string
	caie	a,0		; Was anything there before?
	jrst	relsb		; Yes, return through deallocation routine
	RET			; OK, normal return
SUBTTL Set commands - SPCCHK - check for special characters

;Check for special characters in string (per RFC822)
;
;	specials    =  "(" / ")" / "<" / ">" / "@"  ; To use in a word,
;	            /  "," / ";" / ":" / "\" / <">  ;  word must be a
;		    /  "." / "[" / "]"		    ;  quoted-string.
;	            /  " " (Not per spec but VMS is a bit slow witted)
;
;Call:	B/ Byte pointer to ASCIZ string to be checked
;
;Return	+1: Specials found, or quoted string not closed
;	+2: No specials found

SPCCHK:	$SAVE <A,B>		; Be safe
SPCCH0:	ILDB A,B		; Check for no-no characters
	JUMPE A,[RETSKP]	; Return on end of string
	CAIE A,"("
	CAIN A,")"
	JRST SPCCH2		; Parentheses not allowed (per RFC733)
	CAIE A,"<"		; Check for all no-no chars
	CAIN A,">"
	JRST SPCCH2
	CAIE A,"@"
	CAIN A,","
	JRST SPCCH2
	CAIE A,";"
	CAIN A,":"
	JRST SPCCH2
	CAIE A,"\"
	CAIN A,"."
	JRST SPCCH2
	CAIE A,"["
	CAIN A,"]"
	JRST SPCCH2
	CAIN A," "
	JRST SPCCH2
	CAIE A,42		; Start of quoted string?
	JRST SPCCH0		; No, keep checking
SPCCH1:	ILDB A,B		; Yes, eat chars in quoted string
	JUMPE A,[WARN <Unterminated quoted string>
		RET]			; Give bad return
	CAIE A,42		; Close of quoted string?
	JRST SPCCH1		; No, keep eating chars
	JRST SPCCH0		; Yes, return to ordinary mode
SPCCH2:	RET			; Failure

SUBTTL Set commands - continued

;Set default reply-to-all

.STRPA:	CONFRM
	TXO F,F%RPAL
	RET

;Set default reply-to-sender-only

.STRPS:	CONFRM
	TXZ F,F%RPAL
	RET


;Set experience-level

.STEXP:	NOISE (to)
	MOVEI A,[FLDDB. (.CMKEY,,<[2,,2
				  CMD (Expert,0)
				  CMD (Novice,1)]>,,<novice>)]
	CALL CFIELD		; Parse keyword and confirm
	HRRZ A,(B)		; Get magic number
	MOVEM A,EXPRNC		; Save in good place
.STEX0:	MOVE B,[[FLDDB. (.CMKEY,,CMDTAB)]
		[FLDDB. (.CMKEY,,TOPNOV)]](A)	; Top level
	MOVEM B,TOPPTR
	MOVE B,[[FLDDB. (.CMKEY,,RCMDTB,,<next>)]
		[FLDDB. (.CMKEY,,REDNOV,,<next>)]](A)	; Read level
	MOVEM B,REDPTR
	MOVE B,[[FLDDB. (.CMKEY,,SCMDTB)]
		[FLDDB. (.CMKEY,,SENNOV)]](A)	; Send level
	MOVEM B,SENPTR
	MOVE B,[[FLDDB. (.CMKEY,,STCMTB)]
		[FLDDB. (.CMKEY,,SETNOV)]](A)	; Set commands
	MOVEM B,SETPTR
	CAIE A,1		; Novice mode?
	RET			; No, quit now
	TXO F,F%NSUM!F%PRSN!F%BREF ; Default flag settings for novices
	TXZ F,F%CONC		; Not concise mode
	MOVEI A,^D8		; set text-scroll-region (to) 8 (lines)
	MOVEM A,MINWSZ		;  ..
	RET


;Set closing-text

.STCLZ:	NOISE (to)
	MOVEI A,[FLDDB. (.CMTXT)]
	CALL CFIELD		; Parse text and confirm
	SKIPE A,CLZTXT		; Release old, if any
	CALL RELSB		;  ..
	SETZM CLZTXT		;  ..
	CALL CPYATM		; Copy new to string block
	 JRST [	WARN <Insufficient memory>
		WARN <Closing text ignored>
		RET]
	MOVEM A,CLZTXT		; Store address of new block
	RET

;Set [no] concise-mode

.STCNC:	CONFRM
	TXNE F,F%NO		; "no" typed?
	TXZA F,F%CONC		; yes, clear flag
	TXO F,F%CONC		; no, set concise flag
	RET


;Set [no] directory-lookup-confirmation

.STDLC:	jrst	.stfdi
;	CONFRM
;	MOVX A,F2%NDC		; Get "no directory-lookup-confirmation" bit
;	TXNE F,F%NO		; "no" typed?
;	IORM A,FLAGS2		; Yes, set bit
;	TXNN F,F%NO		; Otherwise
;	ANDCAM A,FLAGS2		;  clear it
;	RET

;Set default

.STDFT:	MOVEI A,[FLDDB. (.CMKEY,,DFCMTB)]
	CALL RFIELD
	HRRZ A,(B)		; Get routine address
	CALL (A)
	RET

;Set [no] force-directory-lookup

.STFDI:	CONFRM
	TXNE F,F%NO
	TXZA F,F%FDIR
	TXO F,F%FDIR
	RET

;Set [no] summary-on-printer-output

.STHLP:	CONFRM
	TXNE F,F%NO		; "no" typed?
	TXZA F,F%HLPT		; Yes, clear the flag
	TXO F,F%HLPT		; No, set it
	RET
SUBTTL Set commands - .STCDI - set default directory

.STCDI:	TRVAR <<DIR0,10>>	; Full directory name space
	SETZM CJFNBK
	NOISE (to)
	MOVE A,[CJFNBK,,CJFNBK+1]
	BLT A,CJFNBK+CJFNLN-1
TOPS10<	MOVEI A,[FLDDB. (.CMKEY,,CRFDTB,,,[FLDDB. (.CMOFI,CM%SDH,,<Path spec>)])]>
TOPS20<	MOVEI A,[FLDDB. (.CMKEY,,CRFDTB,,,[FLDDB. (.CMDIR)])]>
	CALL RFIELD		; Get keyword or directory name
	MOVE A,CR.COD(A)	; Get function parsed
TOPS20<	CAIE A,.CMDIR		; Directory name typed?>
TOPS10<	CAIE A,.CMOFI>
	JRST [	HRRZ A,0(B)		; Get routine addr for keyword
		CALLRET 0(A)]		; Do it and return
.STCD1:
TOPS20<
	HRROI A,DIR0		; Where to put directory name
	DIRST			; Remember it
	 JCERR (Bad directory name)
	MOVEI B,DIR0		; Point to directory spec
	HRLI B,(POINT 7,)	;  ..
	MOVE A,[POINT 7,CRFDEV]	; First do device name
.STCD2:	ILDB C,B		; Get next byte of device name
	IDPB C,A
	CAIE C,":"		; Do until colon
	JRST .STCD2		; Do for all chars in device field
	SETZ C,			; Make sure a null is at the end
	IDPB C,A		;  ..
	IBP B			; Skip opening wedge
	MOVE A,[POINT 7,CRFDIR]	; Where to put directory name
.STCD4:	ILDB C,B		; Get next byte of directory name
	CAIN C,76		; (This is a closing wedge) until closing wedge
	JRST [	SETZ C,			; Done, insure ASCIZ
		IDPB C,A		;  ..
		RET]			; and quit
	IDPB C,A		; Stuff it
	JRST .STCD4		; Go for more

;Connected-directory and logged-in-directory keywords

.STCND:	SKIPA C,[.JIDNO]	; Connected
.STLGD:	MOVEI C,.JILNO		; Logged-in
	CONFRM
	SETO A,			; This job
	HRROI B,D		; -length,,where to put it
	GETJI
	 JFCL
	MOVE B,D		; Get dirnum in right AC for DIRST
	CALLRET .STCD1		; Go join common code
   >;End TOPS20
TOPS10<
	MOVE A,[CJFNBK+.FDPPN,,CRFDIR]
	BLT A,CRFDIR+FDXSIZ-.FDPPN
	RET

.STCND:	SETZM CRFDIR		; Connected = current path
	RET
.STLGD:	MOVE C,MYPPN		; Logged-in
	MOVEM C,CRFDIR
	MOVE C,[CRFDIR+1,,CRFDIR+2]
	SETZM CRFDIR+1
	BLT C,CRFDIR+FDXSIZ-.FDPPN
	RET
>;END TOPS10
SUBTTL Set commands - continued

;set default protection (for created files)

.STCPR:	NOISE (for created files)
TOPS10<	MOVEI A,[FLDDB. (.CMNUM,,^D8,,<157>)]>
TOPS20<	MOVEI A,[FLDDB. (.CMNUM,,^D8,,<775200>)]>
	CALL RFIELD
   TOPS20<
	HRROI A,CRFPRT		; Where to put protection string
	MOVX C,^D8		; Radix
	NOUT
	 JFCL
   >;End TOPS20

   TOPS10<
	MOVEM B,CRFPRT		; On TOPS10, save octal number
   >;End TOPS10
	RET			; Common return


;Set [no] summary-personal-name-only

.STHPR:	CONFRM
	TXNE F,F%NO		; "no" typed?
	TXZA F,F%PRSN		; Yes, clear bit
	TXO F,F%PRSN		; No, set bit
	RET


;Set auto-expunge (on) <condition>

.STAUT:	NOISE (on)
	MOVEI A,[FLDDB. (.CMKEY,,AUTCMT)]
	CALL RFIELD		; Read keyword
	HRRZ D,(B)		; Get value of this keyword
	CONFRM
	MOVEM D,AUTEXP		; Save for later
	RET

;set auto-fill

.STAUF:	TXNE F,F%NO		; 'set no auto-fill'?
	JRST [	CONFRM			;[ESM]
		MOVX A,<1B9>		; Yes, clear break-on-tab
		ANDCAM A,TXTMS2		;  ..
		MOVX A,<1B0>		;  and break-on-space
		ANDCAM A,TXTMS2+1	;  ..
		RET]
	NOISE (at column)	; 'set auto-fill'
	MOVEI A,[FLDDB. (.CMNUM,,^D10,,<60>)]
	CALL CFIELD		; Get fill column and confirm
	MOVEM B,FILCOL		; Save it
	MOVX A,<1B9>		; set break-on-tab
	IORM A,TXTMS2		;  ..
	MOVX A,<1B0>		;  and break-on-space
	IORM A,TXTMS2+1		;  ..
	RET

SUBTTL Set commands - .STDCC - set [no] default-cc-list

.STDCC:	TXNE F,F%NO		; "no" typed?
	JRST [	CONFRM			; yes, confirm it
		JRST .+1]
	SKIPE B,DEFCC		; Any current list?
	CALL ABREL		; Yes, release it
	CALL ADRLST		; Parse an address list
	 RET			; Error msg already type
	MOVEM A,DEFCC		; Stuff address
	RET

;Set [no] type-initial-summary

.STSUM:	CONFRM
	TXNE F,F%NO		; "no" typed?
	TXOA F,F%NSUM		; Yes, set "no-summary" bit
	TXZ F,F%NSUM		; No, clear bit so summary gets typed
	RET
SUBTTL Set commands - continued
;Set reply-address (supplies "Reply-to: addr" in sent mail)

.STRAD:	STKVAR <PTR>		; Pointer to current A-block
	TXZE F,F%NO		; set no reply-address?
	JRST [	CONFRM			; Yes, confirm
		SKIPE B,REPADD		; Release A-blocks
		CALL ABREL		;  ..
		SETZM REPADD		; Zap list
		RET]			;  and quit
	NOISE (to)
	SKIPE B,REPADD		; Any existing addresses?
	CALL ABREL		; Yes, release their A-blocks
	SETZM REPADD		; Empty list
	CALL ADRLST		; Parse some addresses
	 CMERR (Can't allocate memory for address blocks)
	MOVEM A,REPADD		; Save pointer to list
	RET


;Set [no] video-mode

.STVID:	CONFRM
	CALL TTINI		; Re-init TTY parameters
	TXNN F,F%NO		; Default is video mode
	RET
	SETZM V52FLG		; Hmmm... OK, insure no fancy video stuff
	MOVEI A,[RET]
	MOVEM A,SCRREG
	MOVEM A,SCRRGR
	MOVEM A,SCRBTM
	RET

;Set text-scroll-region

.STWSZ:	TXNE F,F%NO		; 'set no text-scroll-region'?
	JRST [	CONFRM			; Yes, zap it
		SETZM MINWSZ
		RET]
	NOISE (to)
	MOVEI A,[FLDDB. (.CMNUM,,^D10,,<8>)]
	CALL RFIELD
	PUSH P,B
	NOISE (lines)
	CONFRM
	POP P,B
	CAIG B,2		; Check for unreasonable values
	JRST [	WARN <Value too small, ignored>
		RET]
	MOVEM B,MINWSZ		; Save
	RET

SUBTTL Set commands - .STOHS - set [no] only-headers-shown

.STOHS:	NOISE (to)
	CALL ZAPOHS

.STOH1:	MOVEI A,[FLDDB. .CMFLD,CM%SDH,,<
The names of the only header items you wish displayed when showing
messages, separated by commas.  If you don't specify any particular
header items to display, they will all be displayed.  Header items
are things like Subject, Date, To, cc, Reply-to, and so forth.
>]
	CALL RFIELD
	LDB A,[POINT 7,ATMBUF,6]
	JUMPE A,R		; Insure something typed
	CAIE A,15		; If nothing typed, quit now
	CAIN A,12
	RET
	CALL CPYATM		; Copy the header-item name into a string block
	 JRST [	WARN <Insufficient memory>
		RET]
	AOS B,OHSN		; Increment number of header-names given
	CAILE B,OHSNMX		; Too many given?
	CERR (Too many header items given)
	MOVEM A,OHSPTR-1(B)	; Save pointer to it
	MOVEI A,[FLDDB. .CMCFM,,,,,[FLDDB. .CMCMA]]
	CALL RFIELD
	MOVE A,CR.COD(A)	; Get function parsed
	CAIN A,.CMCMA		; Comma typed?
	JRST .STOH1		; Yes, go get another header name
	RET			; Confirm - finished

;Empty the only-headers-shown table, return storage to free pool

ZAPOHS:	SKIPN E,OHSN		; Anything there?
	RET			; No, quit now
	MOVN E,E		; Negate count
	HRLZ E,E		; Form AOBJN ptr
ZAPOH0:	SKIPE A,OHSPTR(E)	; Get next block's address
	CALL RELSB		; Release it if there is one
	SETZM OHSPTR(E)		;  ..
	AOBJN E,ZAPOH0		; Loop through all entries
	SETZM OHSN		; No more entries
	RET			; Done!

SUBTTL Set commands - .STSPH - set suppressed-headers

.STSPH:	STKVAR <TBL0>
	TXNE F,F%NO		; "NO" typed?
	JRST [	CONFRM
		SKIPN A,CNCLHD		; See if previous defs
		RET			; No, quit
		SETZM CNCLHD
		CALLRET KWDREL]		; Yes, release and quit
	NOISE (to be)
	MOVEI A,^D100		; Space for keyword table
	$CALL M%GMEM		; Allocate it
	MOVEM B,TBL0		; Remember presence
	MOVEI A,^D99		; Maximum number of entries
	MOVEM A,(B)		; Init TBLUK-style table
	MOVE A,B		; Set up for KWDLST
	CALL KWDLST		; Parse keywords and stuff into table
	MOVE A,TBL0		; Get address of table
	CALL COMPAC		; Compact the table, release unused space
	MOVE A,TBL0		; Get address of table
	HLRZ B,(A)		; Get count of entries presented
	JUMPE B,[MOVE A,TBL0		; None, just release storage
		 CALLRET KWDREL]	;  and quit
	SKIPE A,CNCLHD		; If something already defined,
	CALL KWDREL		;  release it
	SKIPE OHSN		; Warn if conflicting commands given
	WARN <There is an overriding "set only-headers-shown" command in effect>
	MOVE A,TBL0
	MOVEM A,CNCLHD		; Stuff table address and return
	RET

;Release storage for dynamically allocated keyword table
; and associated string blocks
;Call:	A/ address of table

KWDREL:	PUSH P,E		; Need this register
	PUSH P,A		; Save address of table
	HLLZ E,(A)		; Get number of entries used
	JUMPE E,KWDRL1		; If table empty, this is easy
	MOVN E,E		; Form AOBJN pointer to them
	HRRI E,1(A)		;  ..
KWDRL0:	HLRZ A,(E)		; Get address of string block
	CALL RELSB		; Release it
	AOBJN E,KWDRL0		; Do for all
KWDRL1:	POP P,B			; Address of table
	HRRZ A,(B)		; Length
	ADDI A,1		; Account for header word
	$CALL M%RMEM		; Release it
	POP P,E			; Restore work reg
	RET

SUBTTL Show commands - .SHDEF - show defaults

.SHOW:	NOISE (information about)
	MOVEI A,[FLDDB. (.CMKEY,,SHCMTB)]
	CALL RFIELD
	HRRZ A,(B)		; Get routine address
	CALL (A)		; Go do it up
	RET


;Show internal-information

.SHINT:	CONFRM
	SKIPE HOSTAB		; Any host table yet?
	IFSKP.			; Nope, so say so
	 $TEXT (KBFTOR,< The Host name cache is empty.>)
	ELSE.			; Otherwise
	 HLRZ A,@HOSTAB		; Get the number of used slots
	 HRRZ B,@HOSTAB		; And the table size
	 $TEXT (KBFTOR,< The Host name cache has ^D/A/ out of ^D/B/ slots in use.>)
	ENDIF.			; rejoin main stuff
	SKIPE A,HLPTAB
	HLRZ A,(A)		;  and HLPTAB
	$TEXT (KBFTOR,< HLPTAB contains ^D/A/ entries.>)
	$CALL M%FPGS		; Get the available free pages
	$TEXT (KBFTOR,< There are ^D/A/. free memory pages available.>)
	$TEXT (KBFTOR,< The largest block of pages is ^D/B/. pages long.>)
	SKIPN A,TXTTOT
	IFSKP.
	 $TEXT (KBFTOR,< The text buffer contains ^D/A/ characters.>)
	ELSE.			;
	 $TEXT (KBFTOR,< The text buffer is empty.>)
	ENDIF.			;
	RET

;Show defaults

.SHDEF:	CONFRM
	$TEXT (KBFTOR,< set auto-expunge (on) ^A>)
	MOVE A,AUTEXP
	HRRO A,[[ASCIZ /exit-command-only/]
		[ASCIZ /any-exit/]
		[ASCIZ /exit-command-only/]
		[ASCIZ /never/]](A)
	$CALL KBFTOR
	CALL CRLF
	SKIPE A,FILCOL		; Fill column set?
	$TEXT (KBFTOR,< set auto-fill (at column) ^D/A/>)
	TXNE F,F%BREF
	$TEXT (KBFTOR,< set brief-address-list-display>)
	SKIPE A,CLZTXT		; Any closing text?
	JRST [	HRLI A,(POINT 7,)	; Yes, display it
		$TEXT (KBFTOR,< set closing-text (to) ^Q/A/>)
		JRST .+1]
	TXNE F,F%CONC		; Concise mode?
	$TEXT (KBFTOR,< set concise-mode>)
	SKIPE A,DEFCC		; Default cc list?
	CALL [	$TEXT (KBFTOR,< set default cc-list (to) ^A>)
		MOVE B,[$CALL KBFTOR]	; What to do with each char
		MOVEM B,MOVDSP		;  ..
		MOVEI X,^D26		; Initial horizontal position
		CALL MVALST		; Type the address list
		CALLRET CRLF]
	$TEXT (KBFTOR,< set default directory (to) ^A>)
	SKIPN CRFDIR		; Any directory set?
	JRST [	$TEXT (KBFTOR,<connected-directory>)
		JRST .SHDE0]		;  No, punt then
TOPS20<
	HRROI A,CRFDEV		; Show device and directory
	$CALL KBFTOR
	MOVEI A,"<"		; Punctuate
	$CALL KBFTOR
	HRROI A,CRFDIR		; Directory name
	$CALL KBFTOR
	MOVEI A,">"
	$CALL KBFTOR
	CALL CRLF
   >;End TOPS20
	; ..
	; ..

TOPS10<
	$TEXT (KBFTOR,<^F/CRFFDH/>)
>
.SHDE0:	SKIPN CRFPRT
	JRST .SHD00
	$TEXT (KBFTOR,< set default protection (for created files) ^A>)
   TOPS20<
	HRROI A,CRFPRT
	$CALL KBFTOR
   >;End TOPS20
   TOPS10<
	$TEXT (KBFTOR,<^O3R0/CRFPRT/^A>)
   >;End TOPS10
	CALL CRLF
.SHD00:	$TEXT (KBFTOR,< set default ^A>)	; Type state of reply switch
	TXNN F,F%RPAL
	$TEXT (KBFTOR,<reply-to-sender-only>)
	TXNE F,F%RPAL		; Reply-to-all default?
	$TEXT (KBFTOR,<reply-to-all>)
	TXNE F,F%HLPT
	$TEXT (KBFTOR,< set summary-on-printer-output>)
	$TEXT (KBFTOR,< set ^A>)
	MOVX A,F2%NDC		; No directory confirmation?
	TDNE A,FLAGS2		;  ..
	$TEXT (KBFTOR,<no ^A>)
	$TEXT (KBFTOR,<directory-lookup-confirmation>)
	TXNE F,F%RPIN		; Flag on?
	$TEXT (KBFTOR,< set include-me-in-replies>)
	SKIPN A,MINWSZ		; Get text scroll region size
	JRST [	$TEXT (KBFTOR,< set no text-scroll-region>)
		JRST .SHDE2]
	$TEXT (KBFTOR,< set text-scroll-region (to) ^D/A/ (lines)>)
.SHDE2:	SKIPE A,OHSN		; Any only-headers-shown?
	JRST [	CALL SHOOHS		; Yes, show them
		JRST .SHDE1]
	SKIPE D,CNCLHD		; Suppressed headers?
	JRST [	$TEXT (KBFTOR,< set suppressed-headers ^A>)
		MOVE A,D
		CALL .SHHK0
		CALL CRLF
		JRST .SHDE1]
.SHDE1:	SKIPE PERSON		; Personal name?
	JRST [	$TEXT (KBFTOR,< set personal-name ^A>)
		HRRO A,PERSON		; Yes, show it
		$CALL KBFTOR
		CALL CRLF
		JRST .+1]
	SKIPE REPADD		; Any reply-address?
	JRST [	$TEXT (KBFTOR,< set reply-address ^A>)
		MOVEI X,^D19		; Init horizontal position
		MOVE A,[$CALL KBFTOR]
		MOVEM A,MOVDSP
		MOVE A,REPADD		; Point to address list
		CALL MVALST		; Type it
		CALL CRLF
		JRST .+1]
	TXNE F,F%PRSN		; set summary-personal-name-only?
	$TEXT (KBFTOR,< set summary-personal-name-only>)
	TXNE F,F%NSUM
	$TEXT (KBFTOR,< set no type-initial-summary>)
	SKIPN SVMFOB		; Any outgoing-messages file?
	RET			; No, all done
	MOVE A,SVMFOB+1		; Yes, point to FOB
	MOVE A,FOB.FD(A)	; Point to FD
	$TEXT (KBFTOR,< save outgoing-messages (in file) ^F/(A)/>)
	RET

;Display only-headers-shown
; A/ contents of OHSN (number of headers shown)

SHOOHS:	MOVN E,A		; Form AOBJN ptr
	HRLZ E,E		;  ..
	$TEXT (KBFTOR,< set only-headers-shown (to) ^A>)
	TXZ F,F%F1		; Remember nothing typed yet
	MOVEI X,^D29		; Init horizontal position
SHOOH0:	HRRZ C,OHSPTR(E)	; Get ptr to next name
	TXON F,F%F1		; Anything typed yet?
	JRST SHOOH1		; No, skip this then
	HRROI A,[ASCIZ /, /]	; Yes, get comma space in case needed
	ADDI X,2		; Account for horizontal movement
	MOVE B,LINEW		; Get terminal line width
	SUBI B,^D16		; Leave reasonable margin
	CAIL X,(B)		; Time to wrap line yet?
	JRST [	HRROI A,[ASCIZ /, -
     /]					; Yes, get the string to do it
		MOVEI X,4		; Reset horizontal position
		JRST .+1]
	$CALL KBFTOR		; Type the comma
SHOOH1:	HRLI C,(POINT 7,)	; Form byte pointer
SHOOH2:	ILDB A,C		; Next char of header name
	JUMPE A,SHOOH3		; Stop on null
	$CALL KBFTOR
	ADDI X,1		; Update horizontal position
	JRST SHOOH2
SHOOH3:	AOBJN E,SHOOH0		; Do for all
	CALLRET CRLF		; CRLF and return
SUBTTL Show commands - show aliases and show address-lists

.SHADL:	TDZA U,U		; Match no bits for address-lists
.SHSYN:	MOVX U,AB%INV		; Bits to match for aliases
	CONFRM
	HLLZ E,@KWDTBL		; Get count of entries in keyword table
	JUMPE E,R		; If none, just quit
	MOVN E,E		; Form AOBJN ptr
	HRR E,KWDTBL		; Point to first entry
	ADDI E,1		; Skip header word
	MOVE A,[$CALL KBFTOR]	; What to do with chars of address string
	MOVEM A,MOVDSP		;  ..

.SHSY0:	HRRZ A,(E)		; Get pointer to block for next entry
	CAIN A,SYSCOD		; SYSTEM?
	JRST .SHSY9		; Yes, skip it
	MOVE B,AB.FLG(A)	; Get flags for this entry
	XOR B,U			; Match ones we're interested in?
	JUMPN B,.SHSY9		; No, skip this one
	HLRZ B,(E)		; Yes, Get the synonym name pointer
	HRLI B,(POINT 7,)	; Make byte ptrs
	SETZM UPDX		; Horizontal postion where TOR can get to it
	$TEXT (.SHSY8,< ^Q/B/ = ^A>)
	MOVE X,UPDX		; Get horizontal position
	TXO F,F%LCL		; Don't type our own host name
	CALL MVALST		; Move address list
	TXZ F,F%LCL
	MOVEI B,[BYTE (7) 15, 12, 0]		; CRLF
	CALL MOVSB2		;  ..
.SHSY9:	AOBJN E,.SHSY0
	RET

;Call this to type chars of synonym, updates column position

.SHSY8:	AOS UPDX		; Count columns
	$CALL KBFTOR
	RET
SUBTTL Show commands - show header-items (defined by user)

.SHHDI:	NOISE (defined by user)
	CONFRM
	SKIPN A,HDITAB		; Anything?
	RET			; No
	HLLZ E,(A)		; Get number of header-items defined
	JUMPE E,R		; Just quit if none
	MOVN E,E		; Form AOBJN pointer
	HRR E,A			;  ..
	ADDI E,1		; Skip header word
	MOVE A,[$CALL KBFTOR]
	MOVEM A,MOVDSP		; Instruction to handle each character
.SHHD0:	HLRZ A,(E)		; Point to name of item
	HRRZ B,(E)		; Point to H-block
	MOVE C,HD.FLG(B)	; Get flags and type
	TXNE C,HD%OPT		; Fetch appropriate words
	MOVE D,[POINT 7,[ASCIZ /optional/]]
	TXNE C,HD%PDF
	MOVE D,[POINT 7,[ASCIZ /predefined/]]
	TXNE C,HD%RQD
	MOVE D,[POINT 7,[ASCIZ /required/]]
	ANDI C,HD%TYP		; Isolate type field
	MOVE C,HDTNAM(C)	; Get word for this type
	$TEXT (KBFTOR,< define header-item ^Q/A/ (to be) ^Q/D/ ^Q/C/ ^A>)
	MOVE A,HD.FLG(B)	; Get type field
	MOVEI C,HD%TYP		; Isolate type code
	AND C,A			;  .. *** should use LOAD
;	LOAD C,HDTYP,A		; Get type code
	CAIN C,HD%KWD		; Keyword?
	JRST [	CALL .SHHDK		; Yes, display possible keywords
		JRST .SHHD1]		; Continue
	TXNN A,HD%PDF		; Predefined?
	JRST .SHHD1		; No, all done with this one then
	ANDI A,HD%TYP		; ***Should use LOAD
;	LOAD A,HDTYP(B)		; Get type of this header-item
	TXO F,F%LCL		; Don't type local host name
	EXCH A,B		; Set up ACs correctly for MOVHDO
	CALL @MOVHDO(B)		; Display if predefined
.SHHD1:	CALL CRLF
	TXZ F,F%LCL
	AOBJN E,.SHHD0
	RET

;Display keywords, B points to H-block

.SHHDK:	MOVE A,HD.DAT+1(B)	; Get address of table
.SHHK0:	HLLZ D,(A)		; Get number of elements
	JUMPE D,R		; Just quit if table empty
	TXZ F,F%F1		; Init comma flag
	MOVN D,D		; Form AOBJN ptr
	HRRI D,1(A)		;  ..
.SHHK1:	HLRZ A,(D)		; Point to string name
	HRLI A,(POINT 7,)	;  ..
	TXOE F,F%F1		; Comma typed yet?
	$TEXT (KBFTOR,<, ^A>)	; No, type comma space
	$TEXT (KBFTOR,<^Q/A/^A>)
	AOBJN D,.SHHK1		; Do for all keywords
	RET

; Type out summary of the current file (status command)

.STATU:	NOISE (of current message file)
	CONFRM
	SKIPG B,MSGJFN		; Have a file?
	 JRST [	WARN (No current mail file)
		RET]
	$TEXT (KBFTOR,< Current message file is ^A>)
   TOPS20<
	PUSH P,B
	$CALL K%FLSH
	POP P,B
	MOVEI A,.PRIOU		; Type filespec on terminal
	MOVX C,<1B2+1B5+1B8+1B11+1B14>+JS%PAF
	JFNS
	TXZ F,F%F1		; No headers
   >;End TOPS20
   TOPS10<
	$TEXT (KBFTOR,<^F/MSGFD/^A>)
   >;End TOPS10
	CALL SUMMRY		; Print summary
	MOVEI A,1(M)		; M is zero-origin
	$TEXT (KBFTOR,< Currently at message ^D/A/.>)
	RET

; Print out summary of message file

SUMMRY:	MOVE A,LASTM		; Get number of messages
	ADDI A,1		;  ..
	MOVEI B,[ASCIZ /Last read:  %3T/]
;	TXNE F,F%MOD		; MOD hack?
;	MOVEI B,[ASCIZ /Last login: %3T/]
	SKIPG C,LASTRD		; Last read date
	 MOVEI B,[ASCIZ /Never read/]
	SKIPN D,UNSEEN		; Any new messages?
	 TDZA E,E		; No
	 MOVEI E,[ASCIZ / (%4D new)/]
	HRRZ T,FILPGS		; Number of pages
	MOVE U,FILSIZ		; Number of bytes
   TOPS20<
	CIETYPE < %2S.%C %1D message%P%5S (%7D characters), in %6D disk page%P.
>
   >;End TOPS20
   TOPS10<
	CIETYPE < %1D message%P%5S (%7D characters), in %6D disk block%P.
>
   >;End TOPS10
	SKIPE D,NDELET		; Check for deleted
	 ETYPE < (You have %4D message%P deleted.)>
	SKIPN A,NFLAGD		; Messages flaged?
	 RET
	MOVX D,M%ATTN		; Bit to check
	CAIE A,1		; Singular or plural?
	JRST [	CIETYP < Messages%4L flagged.
>
		RET]
	CIETYP < Message%4L flagged.
>
	RET

; Version command

.VERSI:	CONFRM
	$TEXT (KBFTOR,< MS version ^V/VERSN./ + GLXLIB version ^V/libver/^M>)
;	SKIPN HOSTAB		; If don't know about any nets yet,
;	CALL HSTINI		; Find out so can tell user what we know
;	TXNE F,F%XMLR		; XMAILR support?
;	$TEXT (KBFTOR,< XMAILR support^M>)
	TXNE F,F%DECN
	$TEXT (KBFTOR,< DECNET support^M>)
	TXNE F,F%ARPA
	$TEXT (KBFTOR,< ARPANET support^M>)
	TXNE F,F%ANFX
	$TEXT (KBFTOR,< ANF10 support^M>)
	RET

 SUBTTL Run network mailer to deliver mail

   TOPS20<

; Run mailer to send off what we queued

.MAILR:	NOISE (queued messages)
	CONFRM
	$CALL K%FLSH		; Clear TTY output
	TXNN F,F%ARPA!F%DECN	; Net?
	IFNSK.
	 WARN (No network)	; no network to talk to
	 RET
	ENDIF.
	TXNE F,F%XMLR		; XMAILR support?
	IFNSK.
	 $TEXT (KBFTOR,<
[MS: Running XMAILR]>)
	 $CALL K%FLSH		; Push it out before XMAILR starts
	 HRROI B,[ASCIZ /SYS:XMAILR.EXE/]
	 CALLRET .MAIL1		; Yes, excludes all else
	ENDIF.
	MOVE	B,NETFLG
	TXNN	B,RJ.AMA	;
	TXNE F,F%ARPA		; Any non-XMAILR ARPANET mail going out?
	IFNSK.
	 $TEXT (KBFTOR,<
[MS: Running MMAILR]>)
	 $CALL K%FLSH		; push the message out before MMAILR starts
	 HRROI B,[ASCIZ /SYS:MMAILR.EXE/]
	 CALL .MAIL1		; Yes, send it
	ENDIF.
	MOVE	B,NETFLG
	TXNN	B,RJ.VMA
	TXNN F,F%DECN		; DECNET exists?
	 RET			; No, quit now
	TXNE F,F%ARPA		; Did we run the ARPANET mailer?
	 CALL CRLF		; clean up after MMAILR
	$TEXT (KBFTOR,<
%This version of MS does not use VMAILR or DMAILR to deliver mail.
>)
	$TEXT (KBFTOR,<
[MS: Running VMAILR]>)
	$CALL K%FLSH		;
	HRROI B,[ASCIZ /SYS:VMAILR.EXE/]
	CALL .MAIL1		; go run it
	$TEXT (KBFTOR,<
[MS: Running DMAILR]>)
	$CALL K%FLSH		; Push out the message
	HRROI B,[ASCIZ /SYS:DMAILR.EXE/]
	CALL .MAIL1		; go run DMAILR
	RET

.MAIL1:	TXO F,F%F3		; Make sure it doesnt run enabled
	CALL RUNFL0
	 RET
	KFORK			; Dont need it any more
	MOVE A,[SIXBIT /MS/]	; Restore our name
	MOVE B,[SIXBIT /MS/]
	SETSN			;  ..
	 JFCL
	RET

>; END TOPS20
.PUSH:
TOPS10<	NOISE	(to monitor level)
	CONFRM
	SETZB 	T1,T2
	PUSHJ 	P,CTX		; Push to an alternate context
	  JFCL			; Oh well
	POPJ	P,		; All done
>
TOPS20<	NOISE (command level)
	CONFRM
	SKIPLE A,EXECFK		; Already have a fork?
	JRST [	CALL RUNFL2		; Yes, just restart it
		 SETZM EXECFK		; Hmmm...
		RET]
	HRROI B,[ASCIZ /DEFAULT-EXEC:/]
	CALL RUNFIL		; Else make a fork and run it
	 RET			; Failure...
	MOVEM A,EXECFK		; And keep the fork handle
	RET

   >;End TOPS20


SUBTTL Random small command routines

.DAYTI:	CONFRM
   TOPS20<
	$CALL K%FLSH
	MOVX A,.PRIOU
	SETO B,
	MOVX C,OT%DAY!OT%FDY!OT%FMN!OT%4YR!OT%DAM!OT%SPA!OT%NSC!OT%TMZ!OT%SCL
	ODTIM
   >;End TOPS20
   TOPS10<
	$TEXT (KBFTOR,<^H/[-1]/>)	; Type current date/time
   >;End TOPS10
	RET



	END

; *** Edit 2474 to MSMCMD.MAC by PRATT on 18-Nov-85
; Changes for TOPS10 to make MS.MAC smaller


; *** Edit 2486 to MSMCMD.MAC by PRATT on 22-Nov-85
; Copyright statements
; *** Edit 2614 to MSMCMD.MAC by SANTEE on 18-Dec-85
; Keep the number of messages deleted, new, and flagged up-to-date. This makes
; several paths faster and we end up doing alot less work. Also, with windowing
; it is important on the -10 to know if we have any work to do at expunge time.
; Some minor code rearrangements were made in related areas for speed up
; purposes. Finally some comments were added or lined up and paging was
; adjusted in some places.
; *** Edit 2615 to MSMCMD.MAC by PRATT on 18-Dec-85
; Clean up -20 only symbols that were EXTERN'd in common code and change the
; SHOW message for SET HEADERS-OUTPUT-ON-PRINTER.
; *** Edit 2616 to MSMCMD.MAC by JROSSELL on 18-Dec-85
; When a message is read or typed; or when SKIM, SUMMARIZE, HEADERS, GET or
; NEXT is given - update the last time the mail file was read. On TOPS20 also
; update the FDB.
; *** Edit 2622 to MSMCMD.MAC by PRATT on 23-Dec-85
; Fix "MOVE or DELETE" length invalid error, SET DEF DIR, SET DEF PROT (-10)
; *** Edit 2636 to MSMCMD.MAC by APPELLOF on 15-Jan-86
; Finish SET DEFAULT DIRECTORY for TOPS-10
; *** Edit 2651 to MSMCMD.MAC by SANTEE on 2-Feb-86
; Eliminate the need for MSUTAB at all. Move the few useful lines elsewhere.
; *** Edit 2666 to MSMCMD.MAC by MAYO on 3-Mar-86
; Make the -10's SET {no} DIRECTORY-CONFIRMATION command do the same things as
; the -20's SET FORCE-DIRECTORY-LOOKUP. Using either controls F%FDIR, which
; controls whether GETUSR verifies local usernames.
; *** Edit 2687 to MSMCMD.MAC by MAYO on 25-Mar-86
; The NET command shouldn't bother with VMAILR and DMAILR if NETFLG says they
; aren't useful.
; *** Edit 2703 to MSMCMD.MAC by PRATT on 22-May-86
; In .STCD1, make sure a null gets tacked onto the end of the connected
; structure string (CRFDEV).
; *** Edit 2723 to MSMCMD.MAC by SANTEE on 16-Jun-86
; Update SPCCHK for RFC822. Also add " " to the list of special characters
; because VAXmail is a bit slow witted about user names with spaces.
