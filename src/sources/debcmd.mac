;
;	COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION 1986.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED  AND
;	COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH
;	THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE  OR
;	ANY  OTHER  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE
;	AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE
;	SOFTWARE IS HEREBY TRANSFERRED.
;
;	THE INFORMATION IN THIS SOFTWARE IS  SUBJECT  TO  CHANGE  WITHOUT
;	NOTICE  AND  SHOULD  NOT  BE CONSTRUED AS A COMMITMENT BY DIGITAL
;	EQUIPMENT CORPORATION.
;
;	DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF
;	ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;

TITLE	DEBCMD - SYNTAX TABLES FOR RMSDEB
SUBTTL S. COHEN
; 
; 510 - Add new fields and commands and support wildcarding
; 527 - Add NDA & NDL to field name command tables
; 554 - Make the Config XAB known to RMSDEB
; 600 - Add TRACE, NOTRACE, and $FREE
; 10/3/85 asp - cleanup search libraries
; 634 - 6/17/86 asp, re-order TYP class values
;
SEARCH RMSMAC,RMSINT,CMDPAR
$PROLOG(DEB)

P$COLON==0				;;INIT DEF OF IT
					;;USED TO APP COLON TO TOK NAME

C$MAXB==^D17				; Highest legal block type	;AAAA
C$XABS==C$MAXB+1			; Offset in dispatch for XABs	;AAAA


; AK$TAB - DEFINES KYWD TABLE IN WHICH EACH ENTRY IS AN RMS ARG BLK FIELD
;
DEFINE AK$TAB(NEXT$,TYP$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<RF.'X$'##>	;;ADDRESS OF FLD DESCRIPTOR
	$KEY(NEXT$,TYP$'TB,<KOPT$>)	;;KEY TABLE
	TB$KEY(TYP$,<FLD$>)		;;DO THE REAL WORK
>

; AO$TAB - DEFINES DISPATCH TABLE IN WHICH EACH ENTRY IS RMS SYMBOLIC VAL
;
DEFINE AO$TAB(T$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<RF.'X$'##>	;;ADDRESS OF FLD DESCRIPTOR
	DEFINE $$LABL(X$)<T$''X$>	;;DISPATCH BASED ON FLD NAME
	$KEYDSP(T$'TB,<KOPT$>)		;;KEY TABLE
	TB$DSP(T$,<FLD$>)		;;DO THE REAL WORK
>

; AS$TAB - DEFINES SWITCH DISPATCH TABLE FOR RMS ARGBLK FIELDS
; DISPATCH LABEL IS LOCAL -- SO VALUE CAN BE PICKED UP
; PARSE CODE IS ADDRESS -- SO APPROP $STORE CAN BE DONE
;
DEFINE AS$TAB(T$,FLD$,KDOPT$)<
	DEFINE $$CODE(X$)<RF.'X$'##>	;;ADDRESS OF FLD DESCRIPTOR
	DEFINE $$LABL(X$)<T$''X$>	;;DISPATCH BASED ON FLD NAME
	P$COLON==1			;;APPEND COLONS
	$SWITCH	(0,T$'TB,<KDOPT$>)	;;DISPATCH TO KYWD TABLE
	TB$DSP(T$,<FLD$>)		;;DO THE REAL WORK
	P$COLON==0			;;TURN OFF
>

; AV$TAB - DEFINES TABLE IN WHICH EACH ENTRY IS RMS SYMBOLIC VAL
;
DEFINE AV$TAB(NEXT$,TYP$,P$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<P$'$'X$>	;;SYMBOL IN RMSINT
	$KEY(NEXT$,TYP$'TB,<KOPT$>)	;;KEY TABLE
	TB$KEY(TYP$,<FLD$>)		;;DO THE REAL WORK
>

; $FILEF - ALLOW SYMBOLS THAT INCLUDE . < > : [ ] ; $ % *
;
DEFINE $FILEF (NXT$,HELP$,ARGS$) <$FNAME(NXT$,<HELP$>,<$BREAK(MSKFIL),ARGS$>)>

; $MACF - ALLOW SYMBOLS THAT INCLUDE . $ OR %
;
DEFINE $MACF (NXT$,HELP$,ARGS$) <$FNAME(NXT$,<HELP$>,<$BREAK(MSKMAC),ARGS$>)>

; SO$TAB - DEFINES DISPATCH TABLE IN WHICH EACH ENTRY IS RMS SYMBOLIC VAL
;
DEFINE SO$TAB(T$,P$,FLD$,KOPT$)<
	DEFINE $$CODE(X$)<P$'$'X$>	;;SYMBOL IN RMSINT
	DEFINE $$LABL(X$)<T$''X$>	;;DISPATCH BASED ON FLD NAME
	$KEYDSP(T$'TB,KOPT$)		;;KEY TABLE
	TB$DSP(T$,<FLD$>)		;;DO THE REAL WORK
>

SUBTTL	SPECIAL STUFF FOR CMDPAR INTERFACE

BASE10==^D10				;FOR $NUMGE MACRO

$IMPURE

CHABTO:	$NOISE	(0,TO)			;FOR NOISE AFTER ARGBLK TABLE
DEFNMI:	$NOISE	(0,NAMING IT)		;FOR NOISE AFT DEF TYPE 	;m510
XABCOM:	0				;SPACE FOR PDB AFTER CMA IN XAB
PDBPAG:	BLOCK	200			;SPACE FOR PARSED DATA

$PURE


MSKFIL:	; bits specified are bits that are not break characters.
	FLDB0.				;WORD-N OF MASK
	FLDB1.&<^-<1B0!1B2!1B4!1B5!1B10!1B12!1B13!1B14!1B26!1B27!1B28!1B30>> 
;	         SPACE  "   $   %   *     ,    -    .    :    ;    <    >
	FLDB2.&<^-<1B27!1B29!1B31>>
;	             [    ]   _					     
	FLDB3.
; Include " for access info in nodename, and ; so attributes can be given ;m501
; Include * and % for wildcarding					  ;m510

MSKMAC:
	FLDB0.				;WORD-N OF MASK
	FLDB1.&<^-<1B4!1B5!1B14>>!1B13	;B4=$ B5=% B14=. AND EXCL B13=-
	FLDB2.
	FLDB3.

CHANXT:
	SZ%BID==C$XABS+XB$MAX+1		;NUMBER OF ARGBLK TYPES  	;M554
	$INIT	(BID)
	 $SET	(DA$TYP,CHADAT)
	 $SET	(FA$TYP,CHAFAB)
	 $SET	(RA$TYP,CHARAB)
	 $SET	(FS$TYP,CHAFST)
	 $SET	(RS$TYP,CHARST)
	 $SET	(KD$TYP,CHAKDB)
	 $SET	(NA$TYP,CHANAM)
	 $SET	(TY$TYP,CHATYP)
	 $SET	(C$XABS+XB$AREA,CHAXA)
	 $SET	(C$XABS+XB$CFG,CHAXC)					;A554
	 $SET	(C$XABS+XB$KEY,CHAXK)
	 $SET	(C$XABS+XB$DAT,CHAXD)
	 $SET	(C$XABS+XB$SUM,CHAXS)
	$ENDINIT

CHDNXT:				;CHANGE datafield (dispatch by datatype) ;A411
	SZ%TYP==XB$UN4+1	;Size of table
	$INIT	(TYP)
	 $SET (DFT%ASC,CHDTTX)		; STRING DATA-TYPE
;;	 $SET (DFT%ASC,CHDTTX)		; EBCDIC DATA-TYPE
	 $SET (DFT%SIX,CHDTTX)		; SIXBIT DATA-TYPE
	 $SET (DFT%PAC,CHDTPA)		; PACKED DECIMAL DATA-TYPE	;A411
	 $SET (DFT%DEC,CHDTDE)		; INTEGER DATA-TYPE		;A411
	 $SET (DFT%FLO,CHDTFL)		; FLOAT (1 word) DATA-TYPE	;A411
	 $SET (DFT%DOU,CHDTGF)		; DOUBLE FLOAT DATA-TYPE	;A411
	 $SET (DFT%GFL,CHDTGF)		; G-FLOAT DATA-TYPE		;A411
	 $SET (DFT%LON,CHDTPA)		; INTEGER (2 word) DATA-TYPE   	;A411
;;	 $SET (DFT%ASC,CHDTTX)		; 8-bit ASCII (in 9-bit bytes)	;A411
	 $SET (DFT%UNS,CHDTPA)		; Unsigned Integer (1 word)	;A411
	$ENDINIT

DISNXT:
	$INIT	(BID)
	 $SET	(DA$TYP,DIDCMA)		;COMPLETE CMD COULD BE D D1 [,D2,...]
	 $SET	(FA$TYP,DISFAB)
	 $SET	(RA$TYP,DISRAB)
	 $SET	(FS$TYP,DISFST)
	 $SET	(RS$TYP,DISRST)
	 $SET	(KD$TYP,DISKDB)
	 $SET	(NA$TYP,DISNAM)
	 $SET	(TY$TYP,DISTYP)
	 $SET	(C$XABS+XB$AREA,DISXA)
	 $SET	(C$XABS+XB$CFG,DISXC) 				;A554
	 $SET	(C$XABS+XB$KEY,DISXK)
	 $SET	(C$XABS+XB$DAT,DISXD)
	 $SET	(C$XABS+XB$SUM,DISXS)
	$ENDINIT

SUBTTL	ACTION ROUTINES

CXXNXT:					;SETS PLACE TO GO AFTER COMMA IN XAB
	MOVE	T1,XABCOM
	MOVEM	T1,.NEXT
	POPJ	P,

;Action routine for CHANGE

CHACAS:	$CALL	FLDTYP			;SETUP BID TO DRIVE SETTING OF .NEXT
	JUMPF	[POPJ P,]		;TRANSIT RET FAILURE
	IFE DA$TYP,<							;A411
	JUMPE	T2,CHADAT		;				
	>
	IFN DA$TYP,<
	CAIN	T2,DA$TYP
	 JRST	CHADAT
	>								;A411
	MOVE	T1,CHANXT(T2)		;SET GLOBAL "NEXT PDB" FLD
CHACA1:	MOVEM	T1,.NEXT
	MOVEM	T1,XABCOM		;SAVE WHERE TO GO AFTER COMMA
	POPJ	P,			;TRANSIT RET TRUE

CHADAT:	LDB	T3,[UF.TYP(T1)]		;Get data type of field
	MOVE	T1,CHDNXT(T3)		;Get next state
	JRST	CHACA1			;Merge with common code

;Action routine for DISPLAY

DISCAS:	$CALL	FLDTYP			;SETUP BID TO DRIVE SETTING OF .NEXT
	JUMPF	[POPJ P,]		;TRANSIT RET FAILURE
	MOVE	T1,DISNXT(T2)		;SET GLOBAL "NEXT PDB" FLD
	MOVEM	T1,.NEXT
	MOVEM	T1,XABCOM		;SAVE WHERE TO GO AFTER COMMA
	POPJ	P,			;TRANSIT RET TRUE

; FLDTYP - ACTION ROUTINE TO DETERMINE NEXT PDB OF A FIELD
; ARGUMENTS:
;	T1 = LENGTH OF CMDRET BLK
;	T2 = ADDR OF CMDRET BLK

FLDTYP:	MOVE	T5,CR.SAV(T2)		;GET ADDRESS OF PARSE DATA
	MOVEI	T1,TK.VAL(T5)		;PASS THE FIELD VALUE
	$CALL	SY.FIND
	JUMPT	FLDTY1			;A MATCH?
	MOVEI	T2,[ASCIZ/Name not known/] ;NO, TELL CALLER
FLDFAI:	SETZ	TF,			;FAILURE RET
	POPJ	P,

FLDTY1:	$FETCH	T2,BID,<(T1)>		;GET TYPE OF FLD
	CAILE	T2,C$MAXB		;Range check			;A554
	 JRST	[MOVEI T2,[ASCIZ /Not an RMS block/]	;Out of range	;A554
		 JRST FLDFAI]						;A554
IFE <XA$TYP-FS$TYP>,<			; FST and XAB have same BID	;A554
	$FETCH	T3,BLN,(T1)		; Get length of field		;A554
	CAIN	T3,FS$LNG		; Is is same as an FST?		;A554
	 JRST	FLDTY2			; Yes. It is an FST		;A554
	>								;A554
	CAIE	T2,XA$TYP		;XAB?
	 JRST	FLDTY2			;NO
	$FETCH	T3,COD,(T1)		;GET TYPE OF XAB
	MOVEI	T2,C$XABS(T3)		;SEP PDB FOR EACH TYPE OF XAB  ;MAAA
FLDTY2:	SETO	TF,			;SUCC RET
	POPJ	P,

SUBTTL	TOP-LEVEL SYNTAX OF RMSDEB

; THE MAIN PARSER DESCRIPTOR BLOCK, THIS IS WHAT IS PASSED DIRECTLY TO COMND
;
DB.CMD::
	CMDINI				;PT TO CMD TABLE
	[ASCIZ/RMSDEB>/]		;PROMPT
	PDBPAG				;PAGE FOR PARSED DATA
	0				;USE TTY

CMDINI:	$INITC(CMDS)			;THE INIT BLK

CMDS:	CM$TAB	(<$CLOSE,$CONNECT,$CREATE,$DELETE,$DISCONNECT,$DISPLAY,$ERASE,$FIND,$FLUSH,$FREE,$GET,$MESSAGE,$NOMESSAGE,$OPEN,$PARSE,$PUT,$READ,$RENAME,$SEARCH,$TRUNCATE,$UPDATE,$WRITE,ASSIGN,CHANGE,DDT,DEFINE,DISPLAY,EXIT,HELP,INFORMATION,NOTRACE,TAKE,TRACE,UNDEFINE>,$BREAK(MSKMAC))


CFM:	$CRLF				;CRLF IS COMMON TERMINATOR OF COMMANDS

; THESE COMMANDS ARE QUITE SIMPLE: CMD [FAB-NAME ! RAB-NAME]
;
DEFINE $LABEL(V$)<IRP V$,<.'V$:>>	;;VERBS HAVE SIMPLE SYNTAX, SO GROUP THEM

$LABEL	<$CONNECT,$DELETE,$DISCONNECT,$FIND,$FLUSH,$FREE,$GET,$PUT,$READ,$WRITE,$TRUNCATE,$UPDATE>
	$NOISE	(RABNAM,<USING RAB>)
RABNAM:	$MACF	(CFM,<RAB name>)

$LABEL	<$CLOSE,$CREATE,$DISPLAY,$ERASE,$OPEN,$PARSE,$SEARCH>
	$NOISE	(FABNAM,<USING FAB>)
FABNAM:	$MACF	(CFM,<FAB name>)

$LABEL	<$MESSAGE,$NOMESSAGE,DDT,EXIT,HELP,TRACE,NOTRACE>
	$NOISE	(CFM,PLEASE)

$LABEL	<$RENAME>
	$NOISE	(OLDFAB,<Using Old FAB>)
OLDFAB: $MACF	(NEWNOI,<FAB describing existing file>)
NEWNOI:	$NOISE	(NEWFAB,<And New Fab>)
NEWFAB:	$MACF	(CFM,<FAB with new file name>)

SUBTTL	SYNTAX FOR ASSIGN CMD

; ASSIGN name = addres

.ASSIG:	$NOISE	(ASSNAM,NAME)
ASSNAM:	$MACF	(ASSEQL,<block name>)
ASSEQL:	$NOISE	(ASSOLD,<TO ADDRESS>)
ASSOLD:	$NUMGE	(CFM,8,<octal number>)

SUBTTL	SYNTAX FOR CHANGE CMD

; CHANGE ARGBLK-NAME FIELD-KYWD (TO) FLD-DEP-VALUE, ...
; CHANGE [RAB-NAME] FLD-NAME (TO) FLD-DEP-VALUE, ...
;		KEY-BUFFER (TO) STRING OR NUMBER   (IDX OR REL)

.CHANG:	$NOISE	(CHATP,VALUE IDENTIFIED BY)				;m510
CHATP:	OP$TAB	(CHA,<<KEY,KEY-BUFFER>>,$ALTERN(CHAFNM))		;m510
CHAFNM:	$MACF	(0,<argblk or datafield name>,$ACTION(CHACAS))

CHAKEY:	$NOISE	(CHKDEC,TO)
CHKDEC:	$NUMBER	(CFM,BASE10,relative record number,<$ALTERN(CHKTEX)>)
CHKTEX:	$QUOTE	(CFM,<quoted key value>)

CHAFAB:	$NOISE	(CHAFF,AND)
CHAFF:	AO$TAB	(CHF,<ALQ,BKS,BSZ,FAC,FOP,FSZ,MRN,MRS,NAM,ORG,RAT,RFM,SHR,TYP,XAB>,AC$NOI(CHABTO))	;[2]
CHFBKS:	$NUMGE	(CHFCOM,BASE10,<number of pages per bucket>)
CHFBSZ:	$NUMGE	(CHFCOM,BASE10,<bits in byte>)
CHFMRN:	$NUMGE	(CHFCOM,BASE10,<maximum record number>)
CHFMRS:	$NUMGE	(CHFCOM,BASE10,<maximum bytes in record>)
CHFORG:	AV$TAB	(CHFCOM,CRG,FB,<IDX,REL,SEQ>)
CHFXAB:	$MACF	(CHFCOM,<XAB name>)
;
; SYMBOLIC BITS
;
CHFSHR:
CHFFAC:	AV$TAB	(CACPLU,CAC,FB,<ALL,APP,BIO,BRO,DEL,GET,NIL,PUT,TRN,UPD>) ;[2]
CACPLU:	$TOKEN	(CHFFAC,+,<$ALTERN(CHFCOM)>)
CHFFOP:	AV$TAB	(COPPLU,COP,FB,<CIF,CTG,DFW,DLT,DRJ,LKO,MKD,NAM,NIL,OFP,SCF,SPL,SUP,TMP,WAT>) ;[572]
COPPLU:	$TOKEN	(CHFFOP,+,<$ALTERN(CHFCOM)>)
CHFRAT:	AV$TAB	(CHFCOM,CRT,FB,<BLK>)
CHFRFM:	AV$TAB	(CRFPLU,CRF,FB,<FIX,LSA,SCR,SLF,STM,UDF,VAR,VFC>)	;m572
CHFALQ: $NUMGE  (CHRCOM,BASE10,<size of file>) ;[2]
CHFNAM: $MACF	(CHFCOM,<NAM block name>) ;[2]
CHFTYP:	$MACF	(CHFCOM,<TYP block name>) ;[2]
CHFFSZ: $NUMBE  (CHRCOM,BASE10,<size of fixed header>) ;[2]
CRFPLU:	$TOKEN	(CHFRFM,+,<$ALTERN(CHFCOM)>)
CHFCOM:	$COMMA	(CHAFF,<$ALTERN(CFM)>)

CHARAB:	$NOISE	(CHRFLD,AND)
CHRFLD:	AO$TAB	(CHR,<BKT,ELS,FAB,KRF,LSN,MBF,PAD,RAC,RFA,ROP,RSZ,USZ>,<$ALTERN(CHRKEY),AC$NOI(CHABTO)>)
CHRKEY:	$KEYDSP	(CHATB,<$ALTERN(CHDFLD)>)
CHRFAB:	$MACF	(CHRCOM,name of FAB)
CHRBKT: $NUMGE  (CHRCOM,8,<bucket number>)
CHRELS: $NUMGE  (CHRCOM,8,<address of end-of-line sequence>)
CHRRAC:	AV$TAB	(CRCPLU,CRAC,RB,<BFT,BLK,KEY,RFA,SEQ,TRA>)
CRCPLU:	$TOKEN	(CHRRAC,+,<$ALTERN(CHRCOM)>)
CHRROP:	AV$TAB	(CRPPLU,CROP,RB,<EOF,FDL,KGE,KGT,LOA,LOC,NIL,NRP,PAD,RAH,WAA,WBA,WBH>)
CRPPLU:	$TOKEN	(CHRROP,+,<$ALTERN(CHRCOM)>)
CHRKRF:	$NUMGE	(CHRCOM,BASE10,<key number>)
CHRLSN:	$NUMGE	(CHRCOM,BASE10,<line-sequence-number>)
CHRMBF:	$NUMGE	(CHRCOM,BASE10,<number of buffers to allocate>)
CHRPAD:	$NUMGE	(CHRCOM,8,<octal code of pad byte>)
CHRRFA: $NUMGE  (DEFRF,8,<RFA of record>)
CHRRSZ:	$NUMGE	(CHRCOM,BASE10,<bytes in record>)
CHRUSZ:	$NUMGE	(CHRCOM,BASE10,<words in record buffer>)
CHRCOM:	$COMMA	(CHARF,<$ALTERN(CFM)>)
CHARF:	$KEYDSP	(CHRTB,AC$NOI(CHABTO))

CHANAM: $NOISE	(CHANF,AND)
CHANF:	AO$TAB	(CHN,<CHA,DRA,DRL,DVA,DVL,ESA,ESL,ESS,FNB,NDA,NDL,NMA,NML,NOP,RLF,RSA,RSL,RSS,TPA,TPL,VRA,VRL,WCT,WNX>)
CHANFC:	$COMMA	(CHANF,<$ALTERN(CFM)>)
CHNCHA: AV$TAB	(CHNCOM,CNC,NA,<CEX,CNA,CDI,CDE,NIL>)			;m600
CHNDRA:	$NUMGE	(CHNCOM,8,<Byte pointer to Directory within filespec>)
CHNDRL:	$NUMGE	(CHNCOM,BASE10,<Length of Directory>)
CHNDVA:	$NUMGE	(CHNCOM,8,<Byte pointer to Device within filespec>)
CHNDVL:	$NUMGE	(CHNCOM,BASE10,<Length of Device>)
CHNESA:	$MACF	(CHNCOM,<Byte pointer to Expanded String>)
CHNESL:	$NUMGE	(CHNCOM,BASE10,<Length of Expanded String>)
CHNESS:	$NUMGE	(CHNCOM,BASE10,<Size of Expanded String buffer>)

;AV$TAB only wants 18-bit quantities
;CHNFNB:	AV$TAB	(CHNCOM,CNF,NA,<ACT,DEV,DIR,EDE,EDI,ENA,ETY,EVE,EXT,GND,INV,MUL,NAM,NIL,NOD,NHV,PRO,QUO,TFS,UHV,ULV,UNT,VER,WLD>) ; NAME OPTION BITS

CHNFNB:	$NUMGE	(CHNCOM,8,<Wildcarding Bits returned by $PARSE or $SEARCH>)
CHNNOP:	AV$TAB	(CHNPLU,CNN,NA,<NIL,PWD,SYN>)				;m600
CHNPLU:	$TOKEN	(CHNNOP,+,<$ALTERN(CHNCOM)>)
CHNNDA:	$NUMGE	(CHNCOM,8,<Byte pointer to Node Name within filespec>)
CHNNDL:	$NUMGE	(CHNCOM,BASE10,<Length of Node name>)
CHNNMA:	$NUMGE	(CHNCOM,8,<Byte pointer to File Name within filespec>)
CHNNML:	$NUMGE	(CHNCOM,BASE10,<Length of File name>)
CHNRLF:	$MACF	(CHNCOM,<NAM block name for Related File>)
CHNRSA:	$MACF	(CHNCOM,<Byte pointer to Related String>)
CHNRSL:	$NUMGE	(CHNCOM,BASE10,<Length of Related String>)
CHNRSS:	$NUMGE	(CHNCOM,BASE10,<Size of Related String buffer>)
CHNTPA:	$NUMGE	(CHNCOM,8,<Byte pointer to File Type within filespec>)
CHNTPL:	$NUMGE	(CHNCOM,BASE10,<Length of File Type>)
CHNVRA:	$NUMGE	(CHNCOM,8,<Byte pointer to Version Number within filespec>)
CHNVRL:	$NUMGE	(CHNCOM,BASE10,<Length of Version Number>)
CHNWCT:	$NUMGE	(CHNCOM,BASE10,<Number of files processed on this wildcard>)
CHNWNX:	$NUMGE	(CHNCOM,BASE10,<Length of filespec already processed>)
CHNCOM: $COMMA	(CHANF,<$ALTERN(CFM)>)

CHATYP: $NOISE	(CHATF,AND)
CHATF:	AO$TAB	(CHT,<CLA,FDT,FLN,FSC,MOR,NEX>)
CHTCLA:	AV$TAB	(CHTCOM,CTC,TY,<ASC,BYT,IMA,M11>,$ALTERN(CHTCLV))
CHTCLV: $NUMBE	(CHTCOM,8,<Value of File Class>)
CHTFDT:	AV$TAB	(CHTCOM,CTD,TY,<ASC,BYT,IMA,M11>,$ALTERN(CHTFDV))
CHTFDV: $NUMBE	(CHTCOM,8,<Value of Field Data Type>)
CHTFLN:	$NUMGE	(CHTCOM,BASE10,<Length of Field>)
CHTFSC:	$NUMGE	(CHTCOM,BASE10,<Scale Factor>)
CHTMOR:	$MACF	(CHTCOM,<TYP block name for variant record>)
CHTNEX:	$MACF	(CHTCOM,<TYP block name for next field>)
CHTCOM: $COMMA	(CHATF,<$ALTERN(CFM)>)

CHAXA:	$NOISE	(CHAXAF,AND)
CHAXC:	$NOISE	(CHAXCF,AND)
CHAXD:	$NOISE	(CHAXDF,AND)
CHAXK:	$NOISE	(CHAXKF,AND)
CHAXS:	$NOISE	(CHAXSF,AND)
CXANXT:
CXCNXT:
CXDNXT:
CXKNXT:
CXSNXT:
	$MACF	(CHXCOM,name of next XAB)

CHAXAF:	AO$TAB	(CXA,<AID,BKZ,NXT>,AC$NOI(CHABTO))
CXAAID:	$NUMGE	(CHXCOM,BASE10,<area ID>)
CXABKZ:	$NUMGE	(CHXCOM,BASE10,<words in bucket>)

CHAXDF:
CHAXSF:
CHAXCF:
	AO$TAB	(CXD,<NXT>,AC$NOI(CHABTO))

CHAXKF:	AO$TAB	(CXK,<DAN,DFL,DTP,FLG,IAN,IFL,KNM,NXT,PS0,PS1,PS2,PS3,REF,SZ0,SZ1,SZ2,SZ3>,AC$NOI(CHABTO))
CXKDTP:	AV$TAB	(CHXCOM,CXKD,XB,<AS8,EBC,FL1,FL2,GFL,IN4,IN8,PAC,SIX,STG,UN4>)
CXKFLG:	AV$TAB	(CXKFPL,CXKF,XB,<CHG,DUP,NIL>)
CXKFPL:	$TOKEN	(CXKFLG,+,<$ALTERN(CHXCOM)>)
CXKKNM:	$FILEF	(CHXCOM,<name of key>)
CXKDAN:	$NUMGE	(CHXCOM,BASE10,<area ID of data bucket>)
CXKDFL:	$NUMGE	(CHXCOM,BASE10,<data fill word count>)
CXKIAN:	$NUMGE	(CHXCOM,BASE10,<area ID of index bucket>)
CXKIFL:	$NUMGE	(CHXCOM,BASE10,<index fill word count>)
CXKPOS:
CXKPS0:
CXKPS1:
CXKPS2:
CXKPS3:	$NUMGE	(CHXCOM,BASE10,<starting byte number of key segment>)
CXKREF:	$NUMGE	(CHXCOM,BASE10,<key number>)
CXKSIZ:
CXKSZ0:
CXKSZ1:
CXKSZ2:
CXKSZ3:	$NUMGE	(CHXCOM,BASE10,<number of bytes in key segment>)
CHXCOM:	$COMMA	(0,<$ACTION(CXXNXT),$ALTERN(CFM)>)

CHDTDE:	$NOISE	(CHDDEC,TO)
CHDDEC:	$NUMBER	(CHDCOM,BASE10)

CHDTTX:	$NOISE	(CHDTEX,TO)
CHDTEX:	$QUOTE	(CHDCOM,<quoted text>)

CHDTFL:	$NOISE	(CHDFLT,TO)
CHDFLT: $FLOAT	(CHDCOM,<Floating-Point number>)			;A411

CHDTGF:	$NOISE	(CHDGFL,TO)
CHDGFL: $UQSTR	(CHDCOM,FLTMSK,<Floating-Point number>)			;A411

CHDTPA:	$NOISE	(CHDPAC,TO)
CHDPAC: $UQSTR	(CHDCOM,PACMSK,<Packed-decimal number>)			;A411

BRINI.
BRKCH.	(0,37)			;Break on control characters
BRKCH.	(40,52)			;Break on Space thru *
BRKCH.	(54,54)			;Break on ,
BRKCH.	(57,57)			;Break on /
BRKCH.	(72,103)		;Break on : thru C
BRKCH.	(110,143)		;Break on H thru c
BRKCH.	(150,177)		;Break on h thru rubout

FLTMSK: EXP W0.,W1.,W2.,W3.		;Mask for floating-point	;A411

UNBRK.	"."
UNBRK.	"D"
UNBRK.	"E"
UNBRK.	"F"
UNBRK.	"G"
UNBRK.	"d"
UNBRK.	"e"
UNBRK.	"f"
UNBRK.	"g"

PACMSK: EXP W0.,W1.,W2.,W3.		;Mask for packed decimal	;A411

CHDCOM:	$COMMA	(CHDFLD,<$ALTERN(CFM)>)
CHDFLD:	$MACF	(CHADAT,name of datafield)


CHAFST:
CHARST:
CHAKDB: $CRLF

SUBTTL	SYNTAX FOR DEFINE CMD

; DEFINE FAB new-name (FOR) file-name [/FIELD-KYWD:VALUE ...]
; DEFINE RAB new-name (FOR) FAB-name [/FIELD-KYWD:VALUE ...]
; DEFINE XAB new-name (FOR) ALLOCATION!DATE!KEY!SUMMARY [/FIELD-KYWD:VALUE ...]
; DEFINE NAM nem-name (FOR) FAB-name [/FIELD-KYWD:VALUE ...]
; DEFINE DATAFIELD new-name [/POS /SIZE /TYPE]

.DEFIN:	$NOISE	(DEFTPN,<TYPE OF NAME>)
DEFTPN:	OP$TAB	(DEF,<DATAFIELD,FAB,NAM,RAB,TYP,XAB>,<AC$NOI(DEFNMI)>)
			;M510 fix naming conflict

; DEFINE FAB
;
DEFFAB:	$MACF	(DEFFI,<FAB name>)
DEFFI:	$NOISE	(DEFFN,FOR)
DEFFN:	$FILEF	(DEFFF,<file name>)
DEFFF:	AS$TAB	(DFF,<ALQ,BKS,BSZ,FAC,FOP,FSZ,MRN,MRS,NAM,ORG,RAT,RFM,SHR,TYP,XAB>,<$ALTER(DEFFDF)>) ;[2]
DEFFDF:	$CRLF	($HELP<confirm with CRLF (defaults are BSZ=7 FAC=GET MRS=250 ORG=SEQ RFM=VAR SHR=NIL)>)
DFFBKS:	$NUMGE	(DEFFF,BASE10,<number of pages per bucket>)
DFFBSZ:	$NUMGE	(DEFFF,BASE10,<bits in byte>)
DFFMRN:	$NUMGE	(DEFFF,BASE10,<maximum record number>)
DFFMRS:	$NUMGE	(DEFFF,BASE10,<maximum bytes in record>)
DFFFSZ:	$NUMGE	(DEFFF,BASE10,<size of fixed header>) ;[2]
DFFALQ:	$NUMGE	(DEFFF,BASE10,<size of file>) ;[2]
DFFORG:	AV$TAB	(DEFFF,DRG,FB,<IDX,REL,SEQ>)
DFFXAB:	$MACF	(DEFFF,<XAB name>)
DFFTYP:	$MACF	(DEFFF,<TYP block name>) ;[2]
DFFNAM:	$MACF	(DEFFF,<NAM block name>) ;[2]
;
; SYMBOLIC BITS
;
DFFSHR:
DFFFAC:	AV$TAB	(DACPLU,DAC,FB,<ALL,APP,BIO,BRO,DEL,GET,NIL,PUT,TRN,UPD>) ;[2]
DACPLU:	$TOKEN	(DFFFAC,+,<$ALTERN(DEFFF)>)
DFFFOP:	AV$TAB	(DOPPLU,DOP,FB,<CIF,CTG,DFW,DLT,DRJ,NIL,LKO,MKD,NAM,OFP,SCF,SPL,SUP,TMP,WAT>) ;[2]
DOPPLU:	$TOKEN	(DFFFOP,+,<$ALTERN(DEFFF)>)
DFFRAT:	AV$TAB	(DEFFF,DRT,FB,<BLK>)
DFFRFM:	AV$TAB	(DRFPLU,DRF,FB,<FIX,LSA,SCR,SLF,STM,UDF,VAR,VFC>)	;m572
DRFPLU:	$TOKEN	(DFFRFM,+,<$ALTERN(DEFFF)>)

;
; DEFINE NAM
;
;							;A510 VV
DEFNAM:	$MACF	(DEFNF,<NAM block name>)
DEFNF:	AS$TAB	(DFN,<NOP>,<$ALTERN(DEFNDF)>)
DEFNDF:	$CRLF	($HELP<confirm with CRLF>)
DFNNOP:	AV$TAB	(DNMPLU,DNAM,NA,<PWD,SYN>)
DNMPLU:	$TOKEN	(DFNNOP,+,<$ALTERN(DEFNF)>)
							;A510 ^^

;
; DEFINE TYP
;
;							;A510 VV
DEFTYP:	$MACF	(DEFTF,<TYP block name>)
DEFTF:	AS$TAB	(DTY,<CLA,FDT,FLN,FSC,MOR,NEX>,<$ALTERN(DEFTDF)>)
DEFTDF:	$CRLF	($HELP<confirm with CRLF>)
DTYCLA:	AV$TAB	(DEFTF,DCLA,TY,<ASC,BYT,IMA,M11>)
DTYFDT:	AV$TAB	(DEFTF,DFDT,TY,<ASC,BYT,IMA,M11>)
DTYMOR: $FNAME	(DEFTF,<Name of Next Variant Typ block>)
DTYNEX: $FNAME	(DEFTF,<Name of Next Field Typ block>)
DTYFSC: $NUMGE	(DEFTF,BASE10,<Scale Factor>)
DTYFLN: $NUMGE	(DEFTF,BASE10,<Length of Field>)
							;A510 ^^

; DEFINE RAB
;
DEFRAB:	$MACF	(DEFRFB,<RAB name>)
DEFRFB:	$NOISE	(DEFRFN,FOR)
DEFRFN:	$FNAME	(DEFRF,<name of FAB to connect to>)
DEFRF:	AS$TAB	(DFR,<BKT,ELS,KRF,LSN,MBF,PAD,RAC,RFA,ROP,RSZ,USZ>,<$ALTERN(DEFRDF)>)
DEFRDF:	$CRLF	($HELP<confirm with CRLF (defaults are KSZ=30 RAC=SEQ ROP=WBH USZ=50)>)

DFRRAC:	AV$TAB	(DRCPLU,DRAC,RB,<BFT,BLK,KEY,RFA,SEQ,TRA>)
DRCPLU:	$TOKEN	(DFRRAC,+,<$ALTERN(DEFRF)>)
DFRROP:	AV$TAB	(DRPPLU,DROP,RB,<EOF,FDL,KGE,KGT,LOA,LOC,NIL,NRP,PAD,RAH,WAA,WBA,WBH>)
DRPPLU:	$TOKEN	(DFRROP,+,<$ALTERN(DEFRF)>)
DFRKRF:	$NUMGE	(DEFRF,BASE10,<key number>)
DFRLSN:	$NUMGE	(DEFRF,BASE10,<line-sequence-number>)
DFRBKT: $NUMGE  (DEFRF,8,<bucket number>)
DFRELS: $NUMGE  (DEFRF,8,<address of end-of-line sequence>)
DFRMBF:	$NUMGE	(DEFRF,BASE10,<number of buffers to allocate>)
DFRRFA: $NUMGE  (DEFRF,8,<RFA of record>)
DFRPAD:	$NUMGE	(DEFRF,8,<octal code of pad byte>)
DFRRSZ:	$NUMGE	(DEFRF,BASE10,<bytes in record>)
DFRUSZ:	$NUMGE	(DEFRF,BASE10,<words in record buffer>)

; DEFINE XAB
;
DEFXAB:	$MACF	(DEFXBC,<XAB name>)
DEFXBC:	$NOISE	(DEFXCO,FOR)
DEFXCO:	SO$TAB	(DXC,XB,<AREA,CONFIG,DATE,KEY,SUMMARY>)			;M554
DXCCON:
DXCDAT:
DXCSUM:
	AS$TAB	(DXS,<NXT>,$ALTERN(CFM))
DXSNXT:	$MACF	(CFM,name of next XAB)

DXCARE:	AS$TAB	(DXA,<AID,BKZ,NXT>,<$ALTERN(DXCADF)>)
DXCADF:	$CRLF	($HELP<confirm with CRLF (defaults are AID=1 BKZ=1)>)
DXAAID:	$NUMGE	(DXCARE,BASE10,<area ID>)
DXABKZ:	$NUMGE	(DXCARE,BASE10,<number of pages in bucket>)
DXANXT:	$MACF	(DXCARE,name of next XAB)

DXCKEY:	AS$TAB	(DXK,<DAN,DFL,DTP,FLG,IAN,IFL,KNM,NXT,POS,REF,SIZ>,<$ALTERN(DXCKDF)>)
DXCKDF:	$CRLF	($HELP<confirm with CRLF (defaults are DTP=STG SIZ=1)>)

DXKDTP:	AV$TAB	(DXCKEY,DXKD,XB,<AS8,EBC,FL1,FL2,GFL,IN4,IN8,PAC,SIX,STG,UN4>)
DXKFLG:	AV$TAB	(DXKFPL,DXKF,XB,<CHG,DUP,NIL>)
DXKFPL:	$TOKEN	(DXKFLG,+,<$ALTERN(DXCKEY)>)
DXKDAN:	$NUMGE	(DXCKEY,BASE10,<area ID of data bucket>)
DXKDFL:	$NUMGE	(DXCKEY,BASE10,<max # of words to load into data bucket>)
DXKIAN:	$NUMGE	(DXCKEY,BASE10,<area ID of index bucket>)
DXKIFL:	$NUMGE	(DXCKEY,BASE10,<max # of words to load into index bucket>)
DXKKNM:	$FILEF	(DXCKEY,<name of key for $DISPLAY>)
DXKNXT:	$MACF	(DXCKEY,name of next XAB)
DXKPOS:	$NUMGE	(DXKPOC,BASE10,<starting byte number of key segment>)
DXKPOC:	$TOKEN	(DXKPOS,:,<$ALTERN(DXCKEY)>)
DXKREF:	$NUMGE	(DXCKEY,BASE10,<key number>)
DXKSIZ:	$NUMGE	(DXKSIC,BASE10,<number of bytes in key segment>)
DXKSIC:	$TOKEN	(DXKSIZ,:,<$ALTERN(DXCKEY)>)

; DEFINE FIELD
;
DISW%D==DFT%DEC
DISW%O==DFT%OCT
DESW%D==0
DEFDAT:	$MACF	(DEFDAS,<field name>)
DEFDAS:	$NOISE	(DEDTYP,WITH TYPE)
DEDTYP:	OP$TAB	(DFT,<ASCII,<FILE,BYTES>,<DOUBLE,DOUBLE_FLOATING>,FLOATING,GFLOATING,INTEGER,<LONG,LONG_INTEGER>,PACKED,SIXBIT,UNSIGNED>)

DFTUNS:
DFTDOU:
DFTFLO:
DFTGFL:
DFTLON:
DFTINT:	$NOISE	(DEDWRD,STARTING AT WORD)
DEDWRD:	$NUMGE	(DEDISW,BASE10,<number of words before field>,$ALTERN(DEDISW))
DEDISW:	SW$TAB	(DESW,<DISPLAY>,$ALTERN(CFM))
DESWDI:	KY$TAB	(CFM,DISW,<DECIMAL,OCTAL>,$ALTERN(CFM))

DFTASC:
DFTFIL:
DFTPAC:
DFTSIX:	$NOISE	(DEDLEN,WITH LENGTH)
DEDLEN:	$NUMGT	(DEDBYT,BASE10,<number of bytes in field>)
DEDBYT:	$NOISE	(DEDBNM,STARTING AT BYTE)
DEDBNM:	$NUMGE	(CFM,BASE10,<number of bytes before field>,$ALTERN(CFM))

SUBTTL	SYNTAX OF DISPLAY COMMAND

; DISPLAY argblk-name [FIELD-KYWD-list]
; DISPLAY [RAB-name] DATA!KEY-BUFFER!field-name-list

.DISPL:	$NOISE	(DISTP,VALUE IDENTIFIED BY)
DISTP:	KY$TAB	(CFM,DISD,<DATA,<KEY,KEY-BUFFER>>,<$ALTERN(DISFLD)>)
DISFLD:	$MACF	(0,<argblk or datafield name>,$ACTION(DISCAS))

DISFAB:	$NOISE	(DISFF,AND)
DISFF:	AK$TAB	(DISFFC,DISF,<ALQ,BKS,BSZ,DEV,FAC,FNA,FOP,FSZ,IFI,JFN,MRN,MRS,NAM,ORG,RAT,RFM,SHR,STS,STV,TYP,XAB>,<$ALTERN(CFM)>)
DISFFC:	$COMMA	(DISFF,<$ALTERN(CFM)>)

DISNAM: $NOISE	(DISTN,AND)						;m600
DISTN:	KY$TAB	(CFM,DSN,<DEVICE,DIRECTORY,<EXP,EXPANDED-STRING>,NAME,NODE,<RES,RESULTANT-STRING>,TYPE,VERSION>,<$ALTERN(DISNF)>)	;a600
DISNF:	AK$TAB	(DISNFC,DISN,<CHA,DRA,DRL,DVA,DVL,ESA,ESL,ESS,FNB,NDA,NDL,NMA,NML,NOP,RLF,RSA,RSL,RSS,TPA,TPL,VRA,VRL,WCT,WNX>,<$ALTERN(CFM)>)
DISNFC:	$COMMA	(DISNF,<$ALTERN(CFM)>)

DISTYP: $NOISE	(DISTF,AND)
DISTF:	AK$TAB	(DISTFC,DIST,<CLA,FDT,FLN,FSC,MOR,NEX>,<$ALTERN(CFM)>)
DISTFC:	$COMMA	(DISTF,<$ALTERN(CFM)>)

DISRAB:	$NOISE	(DIRFLD,AND)
DIRFLD:	AK$TAB	(DISRFC,DISR,<BKT,FAB,ISI,KBF,KRF,KSZ,LSN,MBF,PAD,RAC,RBF,RFA,ROP,RSZ,STS,STV,UBF,USZ>,<$ALTERN(DISRD)>)
DISRFC:	$COMMA	(DISRF,<$ALTERN(CFM)>)
DISRF:	$KEY	(DISRFC,DISRTB)
DISRD:	$KEY	(CFM,DISDTB,<$ALTERN(DIRCFM)>)
DIRCFM:	$CRLF	($ALTERN(DIDFLD))

DISXA:	$NOISE	(DISXAF,AND)
DISXC:	$NOISE	(DISXCF,AND)
DISXD:	$NOISE	(DISXDF,AND)
DISXK:	$NOISE	(DISXKF,AND)
DISXS:	$NOISE	(DISXSF,AND)

DISXAF:	AK$TAB	(DISXFC,DIXA,<AID,BKZ,NXT>,$ALTERN(CFM))
DISXCF: AK$TAB  (DISXFC,DIXC,<BFS,CAP,DSV,ECO,FIL,OST,USN,USV,VER>,$ALTERN(CFM))
DISXDF:	AK$TAB	(DISXFC,DIXD,<CDT,EDT,NXT,RDT>,$ALTERN(CFM))
DISXKF:	AK$TAB	(DISXFC,DIXK,<DAN,DFL,DTP,FLG,IAN,IFL,KNM,NXT,POS,REF,SIZ>,<$ALTERN(CFM)>)
DISXSF:	AK$TAB	(DISXFC,DIXS,<NOA,NOK,NXT>,$ALTERN(CFM))
DISXFC:	$COMMA	(0,<$ACTION(CXXNXT),$ALTERN(CFM)>)

DIDFLD:	$MACF	(DIDCMA,<name of datafield>)
DIDCMA:	$COMMA	(DIDFLD,<$ALTERN(CFM)>)

DISFST:
DISRST:
DISKDB: $CRLF


SUBTTL	SYNTAX FOR INFORMATION CMD

; INFO ALL!FABS!DATAFIELDS!RABS!XABS

.INFOR:	$NOISE	(INFTYP,ABOUT)
INFTYP:	KY$TAB	(CFM,INF,<ALL,CONTEXT,DATAFIELDS,FABS,RABS,XABS>) ;,<$ALTERN(INFNAM)>)
;INFNAM:	$MACF	(INFCMA,<name of FAB, RAB, XAB, or datafield>)
;INFCMA:	$COMMA	(INFNAM,<$ALTERN(CFM)>)

SUBTTL	SYNTAX FOR UNDEFINE CMD

; UNDEFINE name-list

.UNDEF:	$NOISE	(UNDNAM,NAME)
UNDNAM:	$MACF	(UNDCMA,<name of FAB, RAB, XAB, or datafield>)
UNDCMA:	$COMMA	(UNDNAM,<$ALTERN(CFM)>)

END
