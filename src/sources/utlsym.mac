UNIVERSAL UTLSYM - SYMBOLS FOR RMSUTL
SUBTTL	A. UDDIN/RL
;
;	COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION 1977, 1986.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED  AND
;	COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH
;	THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE  OR
;	ANY  OTHER  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE
;	AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE
;	SOFTWARE IS HEREBY TRANSFERRED.
;
;	THE INFORMATION IN THIS SOFTWARE IS  SUBJECT  TO  CHANGE  WITHOUT
;	NOTICE  AND  SHOULD  NOT  BE CONSTRUED AS A COMMITMENT BY DIGITAL
;	EQUIPMENT CORPORATION.
;
;	DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF
;	ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
;

;++
; FACILITY:	RMSUTL
;
; ABSTRACT:
;
;	UTLSYM defines symbols for RMSUTL
;
; ENVIRONMENT:	User mode?
;
; AUTHOR: Anwar Uddin, CREATION DATE: 1980
;
; MODIFIED BY:
;
;	Ron Lusk, 3-Feb-84 : VERSION 2.0
;
; 423	-	Clean up for version 2.0 of RMS.
; 431	-	Add tables for RSQxxx,RRLxxx (relative and sequential
;		record-to-use clauses)
; 432	-	Add tables to define Seq/Rel files
; 455	-	Change output macros to use RMSM2 routines for output.
;		Add necessary external declarations.
;--
SEARCH	RMSINT
SEARCH	RMSMAC



SUBTTL	MACROS

; $CHKERR - CHK FOR AND HANDLE RMS FAILURE RETURN
;
DEFINE $CHKERR(TITLE$,XLAB$<L$UNW>)<
	$CALLB M$ERMS,<T1,[[ASCIZ/TITLE$/]]>	;;DO REAL WORK
	JUMPLE	T1,XLAB$
>

; $P - CALL P$<TYP$> & GIVE ERROR IF IT FAILS
;
DEFINE	$P(TYP$)<
	$CALL	P$'TYP$
	JUMPF	L$ERRU(ISC)
>

; RP$CRLF - OUTPUT BLANK TO REPORT (IS SKIPPABLE)
;
DEFINE RP$CRLF<
	PUSHJ	P,[RP$OUT([[0]])	;;CRLF "SUBROUTINE"
		 POPJ P,]
>

; RP$OUT - BUILDS A MSG IN MEMORY AND OUTPUTS IT TO THE REPORT FILE
; TT$OUT - BUILDS A MSG AND OUTPUTS IT TO PRIMARY OUTPUT DEVICE
;
;	MSG$ = ADDRESS OF A $FMT BLOCK
;	ARGS$ = VARIABLES MERGED INTO THE MSG, AS THEY WOULD BE ON $CALLB
;
DEFINE	RP$OUT	(MSG$,ARGS$)<
	$CALLB TX$RPT,<ARGS$,MSG$>	;[455] USE RMSM2 FOR OUTPUT
	$CALL	RP$TTY			;;DONT BUFFER ANYTHING WHEN GOING TO TTY
>
DEFINE	TT$OUT	(MSG$,ARGS$)<$CALLB TX$OUT,<ARGS$,MSG$>>

; $TAB - DEFINES CODE VALUES FOR PARSING KEYWORDS
;
DEFINE	$TAB(PFX$,FLD$)<
	MX%'PFX$==-1			;;INIT FOR TABLE ITERATION
	IRP FLD$,<
		PFX$'%'FLD$==MX%'PFX$+1	;;SET CURR SYMBOL
		MX%'PFX$==MX%'PFX$+1	;;MOVE TO NEXT SYMBOL
	>
>

SUBTTL	GLOBAL SYMBOLS FOR RMSUTL

EXTERN	BUF$K1			;SPACE FOR ARBIT KEY VALUE
EXTERN	BUF$K2			;SPACE FOR ARBIT KEY VALUE
EXTERN	BYTYPE			;[455] FILE BYTE DATATYPE
EXTERN	CURRBD			;[455] CURRENT BUCKET DESCRIPTOR
EXTERN	CU.BKT			;CURRENT BUCKET NO.
EXTERN	CU.KRF			;CURRENT INDEX(KEY OF REF
EXTERN	CU.REC			;RFA OF CURRENT RECORD
EXTERN	CU.HREC			;HI BNDARY OF SCAN
EXTERN	CU$ENT			;LAST ENTRY RET BY BK$ID OR BK$ENT
EXTERN	CU.ID			;ID OF LAST ENTRY REFFED IN BKT
EXTERN	CU.NRP			;NRP OF LAST REC SUCC RET BY US.NEXT (FOR BUS)
EXTERN	CU.RST			;PTR TO BLK OF RST DATA FOR CURR REC
EXTERN	CU$TYPE			;CURRENT BKT'S TYPE (BK$GET COMPUTES)
EXTERN	FAB,FST				;SEE UTLACT
EXTERN	KDB				;KEY DESCRIPTOR BLOCK FOR CURR KEY
EXTERN	KSIZB,KSIZW,KTYPE		;[455] SEE UTLTOP
EXTERN	NRP$AD				;PTR TO RSTNRP
EXTERN	PATH				;PTR TO INDEX PATH TAKEN ON KEY ACC
EXTERN	OUTRAB,TTYRAB,RAB,RST		;ADDR OF RAB BLK FOR RMS FILE
EXTERN	SC$CASE				;CTL TYPE OF PROC IN UTLVFY
EXTERN	STCAIN,STCINA,STFILL,STRIPT	;SEE UTLTOP
EXTERN	SCANNING			;SET IF VERIF/UNCLUT (SEE RC$FIND)
EXTERN	UTLFLG				;FLAG WORD
EXTERN	V$ACC				;-1 SAYS ACCESS BY ALL 2NDARY KEYS
					;0 SAYS DONT ACC AT ALL
EXTERN	V$ERR				;CNT OF INCONSIS DETECTED BY UTLVFY
EXTERN	V$FIX				;-1 SAYS YES, 0 SAYS NO
EXTERN	V$PREQ				;PROGRESS DISPLAY FREQ DESIRED BY USER

EXTERN	FABINI,FAA1,RABINI,RAA1,XKINI,XAINI,XSINI,XDINI,XABINI,FLDINI
EXTERN	ARETAB,BUCTAB,FPGTAB,INDTAB,SRHTAB,IXHTAB,IFHTAB,IVHTAB,ISHTAB
EXTERN	A.TO.E, E.TO.A, A.TO.S, S.TO.A

; ERROR VECTOR FOR RMSUTL
;
DEFINE $UTLERR<
  H$RET(BNF)			;;BUCKET NOT IN FILE
  H$RET(BNI)			;;BKT NOT PART OF INDEX
  H$RET(DXP)			;;DF EXTENDS PAST EOR
  H$RET(ENA)			;;LAST-ENT N/A
  H$RET(EPC)			;;FILE EMPTY OR PROLOG CHANGED
  H$RET(FAO)			;;REPORT FILE ALREADY OPEN
  H$RET(FNA)			;;FILE DOES NOT HAVE THAT AREA
  H$RET(FNI)			;;FILE DOES NOT HAVE THAT INDEX
  H$RET(FNO)			;;FILE NOT OPEN
  H$RET(IBS)			;;INVALID BYTE SIZE FOR FILE
  H$RET(IFP)			;;INV FLD FOR PTR REC
  H$RET(IOF)
  H$RET(IPX)			;;INVALID PRIMARY XAB
  H$RET(ISC)			;;INVALID SYNTAX IN COMMAND
  H$RET(IUE)			;;INTERNAL UTILITY ERROR
  H$RET(IVF)			;;INVALID VALUE IN FLD
  H$RET(KIB)			;;KEYS HAVE INCONSIS BYTE SIZE
  H$RET(NAD)			;;NAME ALR DEFINED
  H$RET(NCR)			;;NO CURR REC
  H$RET(NLR)			;;NO LAST RECORD
  H$RET(NNK)			;;NAME NOT KNOWN
  H$RET(NOO)			;;FILE NOT OPEN FOR OUTPUT
  H$RET(NOP)			;;NOT OPEN FOR PATCHING
  H$RET(NPS)			;;NO POS SPECIFIED FOR DATAFIELD
  H$RET(NRW)			;;NO REC WITHIN RUSE RANGE
  H$RET(NRF)			;;NOT RMS FILE
  H$RET(PKC)			;;PRIMARY KEY CAN'T CHANGE
  H$RET(TFU)			;;TABLE FULL
  H$RET(RAO)			;;A RMS FILE ALREADY OPEN
  H$RET(RNF)			;;RECORD NOT IN FILE
  H$RET(RSR)			;;REC SIZE REQUIRED
  H$RET(SEN)			;;SPEC ENT NOT IN BKT
  H$RET(SIN)			;;SPEC ID NOT IN BKT
  H$RET(STL)			;;SUBSCR TOO LARGE
  H$RET(TMS)			;;TOO MANY SEGMENTS
  H$RET(WTN)			;;WRONG TYPE OF NAME
  H$RET(XND)			;;XAB NOT DEFINED
>
$ERRD(UTL)
	LALL
$UTLERR
	XALL

SUBTTL	SYMBOLS FOR ALL THE CMD-RELATIVE KEYWORDS DEFINED IN UTLACT

$TAB	(,<CHANGE,CLOSE,DEFINE,DELETE,DISPLAY,EXIT,FIX,HELP,INFORMATION,OPEN,REDEFINE,SET,SPACE,TAKE,UNCLUTTER,VERIFY>)

$TAB	(CHA,<BUCKET,PROLOGUE>)
$TAB	(CHG,<ENT,HEA,ID>)
$TAB	(CFE,<EID,RFA>)
$TAB	(CVE,<EID,RFA,SIZ>)
$TAB	(CIE,<DPTR,KEY>)
$TAB	(CSE,<EID,KEY,RFA,SIZ>)
$TAB	(CHN,<AREA,FILE,KEY>)
$TAB	(CLO,<REPORT,RMSFILE>)

$TAB	(DEF,<AREA,DATAFIELD,FILE,KEY>)

$TAB	(DFI,<BKS,BSZ,RFM,MRS>)
$TAB	(DFR,<BSZ,RFM,MRN,RAT>)		;[432]
$TAB	(DFQ,<BSZ,RFM,MRS,RAT>)		;[432]
$TAB	(DIS,<ENTRY,HEADER,ID,KEY,LAST>)
$TAB	(DS,<AREA,FILE,KEY>)
$TAB	(DSP,<BUCKET,DATA,PROLOGUE>)

$TAB	(DEL,<BUCKET,RECORD>)
$TAB	(DLT,<ENTRY,ID>)

$TAB	(KD,<DISPLAY,KEY,CHA,DAN,DFL,DUP,IAN,IFL>)
$TAB	(RTU,<KEY,LAST,REL>)
$TAB	(RUH,<HIGH,FOUND>)		;HIGH MUST BE 1ST FOR VERIF/UNCL COMPAT
$TAB	(RSQ,<CUR,REL,RFA>)		;[431] For sequential files
$TAB	(RRL,<CUR,KEY,REL,RFA>)		;[431] For relative files

$TAB	(OP,<INPUT,OUTPUT,PATCH>)
$TAB	(OPN,<APPEND>)
$TAB	(OPE,<REPORT,RMSFILE>)

$TAB	(TYP,<PRI,IND,SEC>)

$TAB	(SET,<BUCKET,INDEX,RECORD>)
$TAB	(INF,<ALL,AREAS,CONTEXT,DATAFIELDS,KEYS>)
$TAB	(DD,<CURRENT,KEY,NEXT,PREV>)
$TAB	(DFSW,<POSITION,SIZE,TYPE>)
$TAB	(DFT,<ASCII,EBCDIC,FILE,SIXBIT,DECIMAL,OCTAL,FLOATING,DOUBLEFLOATING,GFLOATING,LONGINTEGER,PACKED,UNSIGNED>)	;DEFINE INTERNAL DATA TYPES	  ;M433
	DFT%INT==DFT%DEC		;SET DEFAULT TO DECIMAL
$TAB	(DSB,<ROOT,DATA,UP,DOWN,NEXT,CURRENT>)
$TAB	(SIL,<BUCKET,ROOT,RFA>)
$TAB	(STB,<DATA,DOWN,LAST,NEXT,ROOT,UP>)
$TAB	(DFO,<SEQ,REL,IND,STR,LSA>)
$TAB	(SPA,<ALL,KEY,SEC>)		;SPA & VER MUST BE COMPAT
$TAB	(VER,<ALL,KEY,SEC>)
$TAB	(VSW,<ACC,FIX,PRO>)

SUBTTL	SYMBOL DEFINITIONS FOR FIELD POSITIONS -- SEE RMSLIB FOR DESCRIPTIONS

DEFINE $WHOLE(F$)<$BYTE(F$,^D36)>
DEFINE $HALF(F$)<$BYTE(F$,^D18)>
DEFINE $QTR(F$)<$BYTE(F$,9)>
DEFINE $3Q(F$)<$BYTE(F$,^D27)>

$BLOCK	(FPR)			;FILE PROLOG
$WORD	(RSV)
$BYTE	(RSV,^D13)
$BYTE	(FP$RFM,5)
$BYTE	(FP$BSZ,6)
$BYTE	(FP$BKS,8)
$BYTE	(FP$ORG,4)
$HALF	(FP$RAT)
$HALF	(FP$MRS)
$WHOLE	(FP$MRN)
$HALF	(RSV)
$HALF	(FP$PIF)
$QTR	(FP$ARC)
$QTR	(FP$ARO)
$QTR	(FP$KYC)
$QTR	(FP$KYO)
$WORD	(RSV,7)
$EOB

$BLOCK	(ADB)			;AREA DESC BLK
$3Q	(RSV)
$QTR	(AD$BKZ)
$EOB

$BLOCK	(KDB)			;INDEX DESCRIPTOR FIELDS
$WORD	(RSV)
$HALF	(KD$ROOT)
$HALF	(RSV)
$QTR	(KD$LVS)
$3Q	(KD$NKP)
$WORD	(RSV,5)
$BYTE	(RSV,^D12)
$BYTE	(KD$DTP,6)
$HALF	(KD$KYA)
$QTR	(KD$IAN)
$QTR	(KD$DAN)
$QTR	(KD$LAN)
$QTR	(KD$REF)
$HALF	(KD$IFL)
$HALF	(KD$DFL)
$WORD	(RSV,6)
$HALF	(KD$POS)
$HALF	(KD$SIZ)
$HALF	(KD$PS1)
$HALF	(KD$SZ1)
$HALF	(KD$PS2)
$HALF	(KD$SZ2)
$HALF	(KD$PS3)
$HALF	(KD$SZ3)
$HALF	(KD$PS4)
$HALF	(KD$SZ4)
$HALF	(KD$PS5)
$HALF	(KD$SZ5)
$HALF	(KD$PS6)
$HALF	(KD$SZ6)
$HALF	(KD$PS7)
$HALF	(KD$SZ7)
$WORD	(KD$KNM)
$EOB

$BLOCK	(IBH)			;IDX BUCKET HDR
$QTR	(IB$IBA)
$BYTE	(IB$LEV,6)
$BYTE	(IB$IBT,3)
$HALF	(IB$WIU)
$BYTE	(RSV,^D10)
$BYTE	(IB$ANO,8)
$HALF	(IB$NBP)
$HALF	(IB$LID)
$HALF	(IB$NID)
$EOB

; SYMBOLIC VALUES IN INDEX BKT HEADER
;
IB$ROOT==1
IB$RIGHT==2
IB$DATA==1
IB$INDEX==0
IB$NIL==0				;MUST BE ABLE TO 0 BIT FIELD


$BLOCK	(IRH)				;INDEX-FILE ENTRY HEADER (COMMON)
$HALF	(IR$IRA)
$HALF	(IR$RID)
$EOB

$BLOCK	(IFH)				;FIXED LEN UDR
$WORD	(SAME,SZ%IRH)
$WHOLE	(IR$RFA)
$EOB

$BLOCK	(IVH)				;VAR LEN HDR
$WORD	(SAME,SZ%IFH)
$HALF	(RSV)
$HALF	(IR$IRS)
$EOB

$BLOCK	(ISH)				;SIDR ENTRY
$WORD	(SAME,SZ%IRH)
$HALF	(RSV)
$HALF	(IR$SRS)
$WORD	(IR$SKEY,0)
$EOB

$BLOCK	(IXH)				;INDEX ENTRY
$HALF	(IR$IRA)
$HALF	(IR$DBP)
$WORD	(IR$XKEY,0)
$EOB

; HEADER FLAG DEFINITIONS

IR$DELE==1
IR$POINT==2
IR$HIKEY==4
IR$I1==10				;INTERNAL BIT, IRRELEV ON DISPLAY
IR$KEEP==20
IR$NIL==0				;MUST BE ABLE TO 0 BIT FIELD

SUBTTL	OTHER SYMBOLS

;MISC DEFINITIONS
;
DA$TYP==4	;MAKE PSEUDO-ARGBLK
K%NM==7		;SIZE OF BLOCK POINTED TO BY KNM FIELD
K%BF==^D52	;SIZE OF KEY ALLOCATED FOR INDEXED FILE
P%OS==8		;SIZE OF ARRAY
XB$NIL==0	;FOR CHANGE PRO KEY ATTR

;SYMBOL DEFINITIONS FOR RECORD HEADER FLAGS
;
MHF%DE==40	;DELETED RECORD	
MHF%VA==20	;VALID RECORD

;SYMBOL DEFINITIONS FOR BUCKET HEADER FLAGS
;
MF$ROO==1	;ROOT BUCKET
MF$END==2	;END BUCKET

SUBTTL	STRUCTURE DEFINITIONS

;DDT SYMBOL TABLE ENTRY FOR ARGBLKS CREATED BY RMSDEB
;
$BLOCK	(DD)			;DDT COMPAT SYMTAB ENTRY
  $WORD	(DD.NAM)		;PTR TO ASCIZ NAME OF SYMBOL
  $WORD	(DD.VAL)		;LOCATION OF FAB/RAB/XAB OR DATAFIELD
$EOB

;RMS ARGBLK-FIELD DESCRIPTOR
;
$BLOCK	(RF)			;ARGBLK DESCRIPTOR
  $WORD	(RF.BP)			;BYTE PTR TO FLD (ALWAYS NON-0...0 ENDS TABLE)
  $BYTE	(RF.CNT,HALF)		;# OF SYM VALUES ASSOC WITH FIELD
  $BYTE	(RF.FLAG,QTR)		;FLAGS
  $BYTE	(RF.TYP,QTR)		;"DATA TYPE" OF SWITCH-VALUE
  $WORD	(RF.NAM)		;PTR TO ASCIZ NAME OF FLD
$EOB
$BLOCK	(SYV)			;SYMBOLIC VALUE
  $BYTE	(SYV.NM,HALF)		;PTR TO ASCIZ NAME
  $BYTE	(SYV.VL,HALF)		;VALUE ASSOC WITH NAME
$EOB

; FMT OF TOKEN IN PARSED DATA BLK
;
$BLOCK	(TK)
  $BYTE	(TK.LEN,HALF)			;;# OR WORDS IN TOK BLK (INCL)
  $BYTE	(TK.COD,HALF)			;;TYPE OF TOKEN
  $WORD	(TK.VAL,0)			;;VAR-LEN VALUE
$EOB

; USER DATA FLD DESCRIPTOR
;
$BLOCK	(UF)
  $BYTE	(UF.BID,HALF)			;PSEUDO-ARGBLK TYPE
  $BYTE	(UF.BLN,HALF)			;LEN OF UF BLK
  $BYTE	(UF.TYP,4)			;DATA TYPE OF FIELD
  $BYTE	(UF.SIZ,^D14)			;# OF BYTES IN FLD
  $BYTE	(UF.POS,HALF)			;BYTE OFFSET FROM BEGIN OF RECORD
  $WORD	(UF.KEY)			;PTR TO KEY XAB FOR THIS DATFLD
$EOB

; KEY XAB "FIELDS" FOR SUPPORTING AREA NAME REFS
;
$BLOCK	(XK,XA$SXK)		;PUT SUFFIX ON KEY XAB
  $WORD	(XK.DAP)		;DATA AREA PTR
  $WORD	(XK.IAP)		;IDX AREA PTR
  $WORD	(XK.SEG,8)		;SEG NAMES
$EOB

SUBTTL SYMBOLS AND FLAGS

; BKT TYPES
;
$BLOCK	(BTY)
  $WORD	(BTY%CLOB)			;BKT CLOBBED (MUST BE 1ST)
  $WORD	(BTY%IDX)			;INDEX BKT
  $WORD	(BTY%PRIM)			;UDR BKT
  $WORD	(BTY%SEC)			;SEC DATA BKT
$EOB

; DATA TYPE CASES OF RMS ARGBLK FIELDS
;
$BLOCK	(DT)			;IMPORTANT: THRU DT%SYA IS FMT VECTOR
  $WORD	(DT%DEC)		;DECIMAL VALUE
  $WORD	(DT%DATE)		;STANDARD DATE/TIME FMT
  $WORD	(DT%OCT)		;OCTAL VALUE
  $WORD	(DT%RFA)		;FLD IS RFA
  $WORD	(DT%STR)		;VAR-LEN STRING, ALLOC BUFFER FOR IT
  $WORD	(DT%SYA)		;FIELD CONTAINS ADDR OF PREV DEF BLK (EG. F$XAB)
				;(BY NAME ON DEFINE, IN OCTAL ON DISPLAY)
  $WORD	(DT%SYB)		;SYMBOLIC BITS
  $WORD	(DT%SYV)		;SYMBOLIC VALUE
  $WORD	(DT%INV)		;FIELD IS INVISIBLE, NEITHER DEF OR DISP
$EOB

$BLOCK	(SPEC)			;SPECIAL RMS DATA FLDS
 $WORD	(SP%DF)			;USER FLD (MUST BE 1ST -- TEST FOR 0 MADE)
 $WORD	(SP%IKV)		;IDX ENTRY KEY VAL
 $WORD	(SP%POS)		;SEGM POS ARRAY FOR KEY
 $WORD	(SP%RFA)		;RFA ARRAY ELEM
 $WORD	(SP%SIZ)		;SEGM SIZE ARRAY FOR KEY
 $WORD	(SP%SKV)		;SIDR KEY VALUE
$EOB

;FLAG BIT DEFINITIONS IN RAB/FAB/XAB TABLE

E%ARY==1B35			;FIELD IS AN ARRAY
E%ID==1B34			;FIELD IS REC ID
E%INV==1B33
E%ARL==1B32			;LAST ELEM OF ARRAY
E%DIZ==1B31			;DISPLAY EVEN IF 0
E%BKT==1B30			;NUMERIC FLD IS A BKT #
E%RRV==1B29			;FIELD IS ALLOWED FOR RRV

; FLAG VALUES FOR UTLFLG
;
UT%IN==1B35			;RMS FILE IS OPEN FOR INPUT
UT%RFO==1B34			;REPORT FILE IS OPEN
UT%EMP==1B33			;FILE IS EMPTY
UT%PAT==1B32			;FILE OPENED TO ALLOW PATCHING
UT%NCK==1B31			;NO CURRENT KEY
UT%OUT==1B30			;FILE OPEN FOR OUTPUT
UT%PCH==1B29			;PROLOG CHANGED & NO CLOSE YET

UT%FOP==UT%IN!UT%OUT		;RMS FILE IS OPEN

END
