!
!	COPYRIGHT (C) DIGITAL EQUIPMENT CORPORATION 1979, 1986.
!	ALL RIGHTS RESERVED.
!
!	THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY  BE  USED  AND
!	COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH
!	THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS  SOFTWARE  OR
!	ANY  OTHER  COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE
!	AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE
!	SOFTWARE IS HEREBY TRANSFERRED.
!
!	THE INFORMATION IN THIS SOFTWARE IS  SUBJECT  TO  CHANGE  WITHOUT
!	NOTICE  AND  SHOULD  NOT  BE CONSTRUED AS A COMMITMENT BY DIGITAL
!	EQUIPMENT CORPORATION.
!
!	DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF
!	ITS SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.
!

!****************************************************************
!*								*
!*			START OF RMSSYM.BUS			*
!*								*
!*			RMS USER MACRO DEFINITIONS		*
!*								*
!*								*
!****************************************************************

!AUTHOR: S. BLOUNT
!EDIT DATE: 27-FEB-78

%([*************************************************
*						*
*		NEW REVISION HISTORY		*
*						*
*************************************************

PRODUCT	MODULE	 SPR
 EDIT	 EDIT	 QAR		DESCRIPTION
======	======	=====		===========


	***** END OF REVISION HISTORY *****])%

! THIS MODULE CONTAINS ALL THE RMS SYMBOLS NEEDED BY THE RMS USER
! BUT NOT NEEDED BY RMS ITSELF. THE SYSTEM SYMBOLS APPEAR IN RMSSYM.BSY.
!
! PRIMARILY RMSSYM.BUS CONTAINS THE MACROS PROVIDED TO THE RMS USER.

!****************************************************************
!*	4.1  GENERAL PURPOSE RMS DECLARATIONS USED BY		*
!*		FAB, RAB, AND XAB DECLARATION MACROS		*
!****************************************************************

!	STR$$PTR	DEFINES A BLOCK THAT IS REFERENCED INDIRECTLY VIA A POINTER TO THE BLOCK
!
!		OFF	IS THE OFFSET OF THE FIELD INTO THE BLOCK
!		P	IS THE POSITION OF THE FIELD (NO. BITS AT RIGHT)
!		S	IS THE SIZE OF THE FIELD IN BITS
!
	STRUCTURE STR$$PTR [ OFF, P, S ] = [1]( .STR$$PTR + OFF )< P, S >;

! ***	MACRO $$UNDCL (NAME)
!	INSURES THAT NAME IS NOT DECLARED.
	MACRO $$UNDCL (NAME) =
	%IF %DECLARED (NAME) %THEN UNDECLARE NAME %;

! ***	MACRO $$MAPADD (ADDREXPR, REGNAME)
!	MAPS LOCATION OF CTL BLK EXPRESSION AS PTR STRUCTURE
!	ARGUMENTS:
!		ADDREXPR	A BLISS EXPRESSION WHOSE VALUE IS THE ADDRESS OF A BLOCK
!		REGNAME		REGISTER NAME.  ADDREXPR IS LOADED INTO THIS REGISTER
!
	MACRO	$$MAPADD (ADDREXPR,REGNAME) =
		REGISTER REGNAME: STR$$PTR ;	!PREP TO MAKE REG DEST OF COPIES
		$$UNDCL (B$$ADR);
		BIND B$$ADR = ADDREXPR %;

! ***	MACRO $$CURR (PREFIX,FIELDID)
!	UNDECLARES C$$'FIELDID SO THAT $E WILL USE FIELDID'S DEFAULT VALUE
!
	MACRO	$$CURR (PREFIX,FIELDID) =
		$$UNDCL (%NAME(C$$,FIELDID)) %;	!ELIM EARLIER USE

! ***	MACRO $$NEWVAL (FIELDID,VALUE)
!	OVERRIDES DEFAULT VALUE OF FIELDID WITH "VALUE"
!	(DOES BIND C$$### = VALUE WHERE ### IS THE FIELDID).
!
	MACRO	$$NEWVAL (FIELDID,VALUE)=
		BIND %NAME(C$$,FIELDID) = VALUE %;

! ***	MACRO $$NEWARRVAL (FIELDID,VALUE)
!	AS FOR $$NEWVAL, EXCEPT SKIPS NULL VALUES
!
	MACRO	$$NEWARRVAL (FIELDID,VALUE)=
	%IF NOT %NULL(VALUE) %THEN
		BIND %NAME(C$$,FIELDID) = VALUE
	%FI %;

! ***	MACRO $$SET(FIELDID) - SETS SPECIFIED FIELD TO DESIRED VALUE
!
!	FOR EFFICIENCY, RMS ASSUMES THAT A BLOCK IS 0.
!	SO $$SET IGNORES ATTEMPTS TO 0 A FIELD.
!
!	RT/CT = RUN-TIME/COMPILE-TIME
!	SF/SR/SX = SET FAB/SET RAB/SET XAB
!
	MACRO SF$$RT(FID)=
		%IF %DECLARED (%NAME(C$$,FID))
		%THEN $$REG [$$OPS(FID)] = %NAME(C$$,FID)
		%ELSE	%IF %NAME(D$$F,FID) NEQ 0
			%THEN $$REG [$$OPS(FID)] = %NAME(D$$F,FID)
			%FI
		%FI
	% ;
	MACRO SF$$CT(FID)=
		%IF %DECLARED (%NAME(C$$,FID))
		%THEN %NAME(C$$,FID)
		%ELSE %NAME(D$$F,FID)
		%FI
	% ;

	MACRO SR$$RT(FID)=
		%IF %DECLARED (%NAME(C$$,FID))
		%THEN $$REG [$$OPS(FID)] = %NAME(C$$,FID)
		%ELSE	%IF %NAME(D$$R,FID) NEQ 0
			%THEN $$REG [$$OPS(FID)] = %NAME(D$$R,FID)
			%FI
		%FI
	% ;
	MACRO SR$$CT(FID)=
		%IF %DECLARED (%NAME(C$$,FID))
		%THEN %NAME(C$$,FID)
		%ELSE %NAME(D$$R,FID)
		%FI
	% ;

	MACRO SX$$RT(FID)=
		%IF %DECLARED (%NAME(C$$,FID))
		%THEN $$REG [$$OPS(FID)] = %NAME(C$$,FID)
		%ELSE	%IF %NAME(D$$X,FID) NEQ 0
			%THEN $$REG [$$OPS(FID)] = %NAME(D$$X,FID)
			%FI
		%FI
	% ;
	MACRO SX$$CT(FID)=
		%IF %DECLARED (%NAME(C$$,FID))
		%THEN %NAME(C$$,FID)
		%ELSE %NAME(D$$X,FID)
		%FI
	% ;

!****************************************************************
!	CONTROL BLOCK INITIALIZATION
!
!	MACRO	xAB$B	(xABADDR)
!
!	THIS MACRO BEGINS THE DEFINITION OF A xAB.  A CALL TO xAB$B CAN BE FOLLOWED BY AN ARBITRARY NUMBER
!	OF FIELD INITIALIZATION MACROS (x$### WHERE ### IS THE FIELD NAME).  THE xAB$B AND FIELD INITIALIZATION
!	MACRO CALLS MUST BE FOLLOWED BY A xAB$E MACRO CALL.
!
!	ARGUMENT:
!		xABADDR		ADDRESS OF THE xAB (OPTIONAL)
!	USAGE:
!		IF xABADDR PRESENT, PERFORM RUNTIME INIT.
!		xAB$B(ADDR)			WITH EXECUTABLE CODE
!		  0 OR MORE x$xxx(value)	value DOESNT HAVE TO BE L-TIME
!		xAB$E
!
!		IF xABADDR ABSENT, PERFORM COMPILE-TIME INIT.
!		xAB$B				WITH DECLARATIONS
!		  0 OR MORE x$xxx(value)	VALUE MUST BE L-TIME CONSTANT
!		storage xAB-name: xAB$E		STORAGE= OWN OR GLOBAL
!
!	OPERATION:
!		$B SETS CURR VALUE OF EACH CTL BLK FLD TO DEFAULT VALUE.
!		EACH x$ MACRO OVERRIDES A DEFAULT VALUE WITH THE SPEC VALUE.
!		$E ACTUALLY STORES THE VALUES IN THE CTL BLK:
!		1)	IF NO FABADDR, VIA INITIAL(....)
!		2)	IF FABADDR, VIA ASSIGNMENT STATEMENTS
!		IF CASE 2), THEN $B STARTS BEGIN BLK AND $E ENDS IT.

!****************************************************************
!*	4.2  FILE ACCESS BLOCK (FAB) DECLARATION MACROS		*
!****************************************************************


	MACRO	FAB$B (FABADDR) =
	%IF NOT %NULL(FABADDR) %THEN		!RUN-TIME INIT
		BEGIN
		$$MAPADD (FABADDR,$$REG);	! WILL REFERENCE THE BLOCK INDIRECTLY
						! VIA THE ADDRESS IN REGISTER $$REG
		MACRO $$SET = SF$$RT %QUOTE %;		!RUN-TIME INIT
	%ELSE	UNDECLARE %QUOTE %QUOTE $$SET;		!PREP TO CREATE PROPER $$SET
		MACRO $$SET = SF$$CT %QUOTE %;		!COMPILE-TIME INIT
	%FI
		$$CURR (F,BID);
		$$CURR (F,BLN);
		$$CURR (F,STS);
		$$CURR (F,STV);
		$$CURR (F,IFI);
		$$CURR (F,JFN);
		$$CURR (F,FAC);
		$$CURR (F,SHR);
		$$CURR (F,FOP);
		$$CURR (F,ORG);
		$$CURR (F,FNA);
		$$CURR (F,RAT);
		$$CURR (F,MRS);
		$$CURR (F,MRN);
		$$CURR (F,BSZ);
		$$CURR (F,RFM);
		$$CURR (F,XAB);
		$$CURR (F,JNL);
		$$CURR (F,BLS);
		$$CURR (F,BKS);
		$$CURR (F,DEV);
		$$CURR (F,CTX) %;



!	FAB DECLARATION MACROS  (CONTINUED)

!	MACRO	F$###	(VALUE)
!
!	THESE MACROS INITIALIZE FAB FIELD ### WHERE ### REPRESENTS THE FIELD NAME.
!	CALLS TO THESE MACROS MUST BE PRECEDED BY A FAB$B MACRO CALL AND FOLLOWED BY A FAB$E CALL.
!
!	ARGUMENT:
!		VALUE		VALUE TO SET THE FIELD TO
!
	MACRO	F$JFN (VALUE)	= $$NEWVAL (JFN,VALUE) %,
		F$FAC (VALUE)	= $$NEWVAL (FAC,VALUE) %,
		F$SHR (VALUE)	= $$NEWVAL (SHR,VALUE) %,
		F$FOP (VALUE)	= $$NEWVAL (FOP,VALUE) %,
		F$ORG (VALUE)	= $$NEWVAL (ORG,VALUE) %,
		F$FNA (VALUE)	= $$NEWVAL (FNA,VALUE) %,
		F$RAT (VALUE)	= $$NEWVAL (RAT,VALUE) %,
		F$MRS (VALUE)	= $$NEWVAL (MRS,VALUE) %,
		F$MRN (VALUE)	= $$NEWVAL (MRN,VALUE) %,
		F$BSZ (VALUE)	= $$NEWVAL (BSZ,VALUE) %,
		F$RFM (VALUE)	= $$NEWVAL (RFM,VALUE) %,
		F$XAB (VALUE)	= $$NEWVAL (XAB,VALUE) %,
		F$JNL (VALUE)	= $$NEWVAL (JNL,VALUE) %,
		F$BLS (VALUE)	= $$NEWVAL (BLS,VALUE) %,
		F$BKS (VALUE)	= $$NEWVAL (BKS,VALUE) %,
		F$CTX (VALUE)	= $$NEWVAL (CTX,VALUE) %;




!	MACRO	FAB$E
!
!	THIS MACRO ENDS THE DEFINITION OF A FAB.  A CALL TO FAB$E MUST BE PRECEDED BY A FAB$B MACRO CALL.
!
	MACRO	FAB$E =
	%IF NOT %DECLARED($$REG) %THEN		!STATIC ALLOCATION
		BLOCK [FA$LNG]
		INITIAL ($$SET(BID)^18 OR $$SET(BLN),
			$$SET(STS)^18 OR $$SET(STV),
			$$SET(CTX),
			$$SET(IFI)^18 OR $$SET(JFN),
			$$SET(FAC)^18 OR $$SET(SHR),
			$$SET(FOP)^18 OR $$SET(ORG)^14 OR $$SET(BSZ)^8 OR $$SET(BLS),
			$$SET(FNA),
			$$SET(RAT)^18 OR $$SET(MRS),
			$$SET(MRN),
			$$SET(BKS)^5 OR $$SET(RFM),
			$$SET(JNL)^18 OR $$SET(XAB),
			$$SET(DEV)^18 OR $$SET(SDC),
			REP 4 OF (0))
	%ELSE
		$$REG = B$$ADR;
		$$SET(BID);
		$$SET(BLN);
		$$SET(STS);
		$$SET(STV);
		$$SET(IFI);
		$$SET(JFN);
		$$SET(FAC);
		$$SET(SHR);
		$$SET(FOP);
		$$SET(ORG);
		$$SET(FNA);
		$$SET(RAT);
		$$SET(MRS);
		$$SET(MRN);
		$$SET(BSZ);
		$$SET(RFM);
		$$SET(XAB);
		$$SET(JNL);
		$$SET(BLS);
		$$SET(BKS);
		$$SET(DEV);
		$$SET(CTX);

		END				! END OF BLOCK STARTED IN FAB$B (FAB BEGIN) MACRO
	%FI %;

!****************************************************************
!*	4.3  RECORD ACCESS BLOCK (RAB) DECLARATION MACROS	*
!****************************************************************



	MACRO	RAB$B (RABADDR) =
	%IF NOT %NULL(RABADDR) %THEN		!RUN-TIME INIT
		BEGIN
		$$MAPADD (RABADDR,$$REG);	! WILL REFERENCE THE BLOCK INDIRECTLY
						! VIA THE ADDRESS IN REGISTER $$REG
		MACRO $$SET = SR$$RT %QUOTE %;		!RUN-TIME INIT
	%ELSE	UNDECLARE %QUOTE %QUOTE $$SET;		!PREP TO CREATE PROPER $$SET
		MACRO $$SET = SR$$CT %QUOTE %;		!COMPILE-TIME INIT
	%FI
		$$CURR (R,BID);
		$$CURR (R,BLN);
		$$CURR (R,STS);
		$$CURR (R,STV);
		$$CURR (R,ISI);
		$$CURR (R,FAB);
		$$CURR (R,RAC);
		$$CURR (R,ROP);
		$$CURR (R,UBF);
		$$CURR (R,RBF);
		$$CURR (R,RSZ);
		$$CURR (R,USZ);
		$$CURR (R,RFA);
		$$CURR (R,KRF);
		$$CURR (R,KSZ);
		$$CURR (R,KBF);
		$$CURR (R,MBF);
		$$CURR (R,LSN);
		$$CURR (R,BKT);
		$$CURR (R,PAD);
		$$CURR (R,CTX) %;




!	RAB DECLARATION MACROS  (CONTINUED)

	MACRO	R$FAB (VALUE)	=  $$NEWVAL (FAB,VALUE) %,
		R$RAC (VALUE)	=  $$NEWVAL (RAC,VALUE) %,
		R$ROP (VALUE)	=  $$NEWVAL (ROP,VALUE) %,
		R$UBF (VALUE)	=  $$NEWVAL (UBF,VALUE) %,
		R$RBF (VALUE)	=  $$NEWVAL (RBF,VALUE) %,
		R$RSZ (VALUE)	=  $$NEWVAL (RSZ,VALUE) %,
		R$USZ (VALUE)	=  $$NEWVAL (USZ,VALUE) %,
		R$KRF (VALUE)	=  $$NEWVAL (KRF,VALUE) %,
		R$KSZ (VALUE)	=  $$NEWVAL (KSZ,VALUE) %,
		R$KBF (VALUE)	=  $$NEWVAL (KBF,VALUE) %,
		R$MBF (VALUE)	=  $$NEWVAL (MBF,VALUE) %,
		R$PAD (VALUE)	=  $$NEWVAL (PAD,VALUE) %,
		R$LSN (VALUE)	=  $$NEWVAL (LSN,VALUE) %,
		R$CTX (VALUE)	=  $$NEWVAL (CTX,VALUE) %;




!	RAB DECLARATION MACROS  (CONTINUED)

!	MACRO	RAB$E
!
!	THIS MACRO ENDS THE DEFINITION OF A RAB.  A CALL TO RAB$E MUST BE PRECEDED BY A RAB$B MACRO CALL.
!
	MACRO	RAB$E =
	%IF NOT %DECLARED($$REG) %THEN		!STATIC ALLOCATION
		BLOCK [RA$LNG]
		INITIAL ($$SET(BID)^18 OR $$SET(BLN),
			$$SET(STS)^18 OR $$SET(STV),
			$$SET(CTX),
			$$SET(ISI)^18 OR $$SET(FAB),
			$$SET(RAC)^27 OR $$SET(MBF)^18 OR $$SET(ROP),
			$$SET(UBF),
			$$SET(RBF),
			$$SET(RSZ)^18 OR $$SET(USZ),
			$$SET(RFA),
			$$SET(KRF)^27 OR $$SET(KSZ)^18 OR $$SET(LSN),
			$$SET(KBF),
			$$SET(BKT),
			$$SET(PAD)^27,
			REP 3 OF (0))
	%ELSE
		$$REG = B$$ADR;
		$$SET(BID);
		$$SET(BLN);
		$$SET(STS);
		$$SET(STV);
		$$SET(ISI);
		$$SET(FAB);
		$$SET(RAC);
		$$SET(ROP);
		$$SET(UBF);
		$$SET(RBF);
		$$SET(RSZ);
		$$SET(USZ);
		$$SET(RFA);
		$$SET(KRF);
		$$SET(KSZ);
		$$SET(KBF);
		$$SET(MBF);
		$$SET(LSN);
		$$SET(BKT);
		$$SET(PAD);
		$$SET(CTX);

		END				! END OF BLOCK STARTED IN RAB$B (RAB BEGIN) MACRO
	%FI %;

!****************************************************************
!*	4.4  EXTENDED ATTRIBUTES BLOCK (XAB) DECLARATION MACROS	*
!****************************************************************


!	MACRO	XAB$B	(CODE,XABADDR)
!
!	ADDITIONAL ARGUMENT:
!		CODE = TYPE OF XAB:
!			KEY	(KEY DESCRIPTOR XAB)
!			DAT	(DATE XAB)
!			ALL	(AREA ALLOCATION XAB)
!			SUM	(FILE SUMMARY XAB)
!
	MACRO	XAB$B (CODE,XABADDR) =
	%IF NOT %NULL(XABADDR) %THEN		!RUN-TIME INIT
		BEGIN
		$$MAPADD (XABADDR,$$REG);	! WILL REFERENCE THE BLOCK INDIRECTLY
						! VIA THE ADDRESS IN REGISTER .FABREG
		MACRO $$SET = SX$$RT %QUOTE %;		!RUN-TIME INIT
	%ELSE	UNDECLARE %QUOTE %QUOTE $$SET;		!PREP TO CREATE PROPER $$SET
		MACRO $$SET = SX$$CT %QUOTE %;		!COMPILE-TIME INIT
	%FI
					! COMMON XAB HEADER
		$$CURR (X,BLN);
		$$NEWVAL (BLN, %NAME(XA$,SX,CODE));
		$$CURR (X,COD);
		$$NEWVAL (COD, %NAME (XB$, CODE));

		$$CURR (X,BID);
		$$CURR (X,RS1);
		$$CURR (X,NXT);

					! DATE XAB
		$$CURR (X,CDT);
		$$CURR (X,RDT);
		$$CURR (X,EDT);

					! AREA ALLOCATION XAB
		$$CURR (X,RS2);
		$$CURR (X,AID);
		$$CURR (X,BKZ);

					! KEY DEFINITION XAB
		$$CURR (X,IFL);
		$$CURR (X,DFL);
		$$CURR (X,DTP);
		$$CURR (X,FLG);
		$$CURR (X,IAN);
		$$CURR (X,DAN);
		$$CURR (X,LAN);
		$$CURR (X,REF);
		$$CURR (X,KNM);
		$$CURR (X,RX0);
		$$CURR (X,RX1);
		$$CURR (X,RX2);
		$$CURR (X,RX3);
		$$CURR (X,RX4);
		$$CURR (X,RX5);

		$$CURR (X,PS0);
		$$CURR (X,PS1);
		$$CURR (X,PS2);
		$$CURR (X,PS3);
		$$CURR (X,PS4);
		$$CURR (X,PS5);
		$$CURR (X,PS6);
		$$CURR (X,PS7);
		$$CURR (X,SZ0);
		$$CURR (X,SZ1);
		$$CURR (X,SZ2);
		$$CURR (X,SZ3);
		$$CURR (X,SZ4);
		$$CURR (X,SZ5);
		$$CURR (X,SZ6);
		$$CURR (X,SZ7);

					! FILE SUMMARY XAB
		$$CURR (X,RS6);
		$$CURR (X,NOK);
		$$CURR (X,NOA);
		$$CURR (X,RS7);
		$$CURR (X,RS8);
		$$CURR (X,RS9) %;




!					REQUIRE FILE:  RMSSYM.BUS  (CONTINUED)

!	XAB DECLARATION MACROS  (CONTINUED)

							! XAB HEADER
	MACRO	X$NXT (VALUE)	=	$$NEWVAL (NXT,VALUE) %,

							! DATE XAB
		X$EDT (VALUE)	=	$$NEWVAL (EDT,VALUE) %,

							! AREA ALLOCATION XAB
		X$AID (VALUE)	=	$$NEWVAL (AID,VALUE) %,
		X$BKZ (VALUE)	=	$$NEWVAL (BKZ,VALUE) %,

							! KEY DEFINITION XAB
		X$IFL (VALUE)	=	$$NEWVAL (IFL,VALUE) %,
		X$DFL (VALUE)	=	$$NEWVAL (DFL,VALUE) %,
		X$DTP (VALUE)	=	$$NEWVAL (DTP,VALUE) %,
		X$FLG (VALUE)	=	$$NEWVAL (FLG,VALUE) %,
		X$IAN (VALUE)	=	$$NEWVAL (IAN,VALUE) %,
		X$DAN (VALUE)	=	$$NEWVAL (DAN,VALUE) %,
		X$LAN (VALUE)	=	$$NEWVAL (LAN,VALUE) %,
		X$REF (VALUE)	=	$$NEWVAL (REF,VALUE) %,
		X$KNM (VALUE)	=	$$NEWVAL (KNM,VALUE) %;

							! THE XPOS AND XSIZ INITIALIZATION MACROS
							! DIFFER FROM THE OTHERS SINCE UP TO 8 VALUES
							! CAN BE SPECIFIED.

							! NO BLANKS CAN BE USED AROUND THE ACTUAL ARGUMENTS.
							! USE OF A BLANK WILL RESULT IN A BLISS SYNTAX ERROR.
							! (OPERAND PAIR WITHOUT INTERVENING DELIMITER)

	MACRO	X$POS (VAL0,VAL1,VAL2,VAL3,VAL4,VAL5,VAL6,VAL7) =

		$$NEWARRVAL (PS0,VAL0);
		$$NEWARRVAL (PS1,VAL1);
		$$NEWARRVAL (PS2,VAL2);
		$$NEWARRVAL (PS3,VAL3);
		$$NEWARRVAL (PS4,VAL4);
		$$NEWARRVAL (PS5,VAL5);
		$$NEWARRVAL (PS6,VAL6);
		$$NEWARRVAL (PS7,VAL7) %;

	MACRO	X$SIZ (VAL0,VAL1,VAL2,VAL3,VAL4,VAL5,VAL6,VAL7) =

		$$NEWARRVAL (SZ0,VAL0);
		$$NEWARRVAL (SZ1,VAL1);
		$$NEWARRVAL (SZ2,VAL2);
		$$NEWARRVAL (SZ3,VAL3);
		$$NEWARRVAL (SZ4,VAL4);
		$$NEWARRVAL (SZ5,VAL5);
		$$NEWARRVAL (SZ6,VAL6);
		$$NEWARRVAL (SZ7,VAL7) %;


!	XAB DECLARATION MACROS  (CONTINUED)

!	MACRO	XAB$E
!
!	THIS MACRO ENDS THE DEFINITION OF A XAB.  A CALL TO XAB$E MUST BE PRECEDED BY A XAB$B MACRO CALL.
!
	MACRO	XAB$E =
	%IF NOT %DECLARED($$REG) %THEN		!STATIC ALLOCATION
		BLOCK [C$$BLN]
		INITIAL ($$SET(BID)^18 OR $$SET(BLN),
			$$SET(COD)^18 OR $$SET(NXT),
		%IF C$$COD EQL XB$DAT %THEN
			$$SET(CDT),
			$$SET(RDT),
			$$SET(EDT))
		%FI
		%IF C$$COD EQL XB$ALL %THEN
			$$SET(AID)^9 OR $$SET(BKZ),
			REP 3 OF (0))
		%FI
		%IF C$$COD EQL XB$KEY %THEN
			$$SET(DTP)^18 OR $$SET(FLG),
			$$SET(IAN)^27 OR $$SET(DAN)^18 OR $$SET(LAN)^9 OR $$SET(REF),
			$$SET(IFL)^18 OR $$SET(DFL),
			$$SET(KNM),
			REP 5 OF (0),
			$$SET(PS0)^18 OR $$SET(SZ0),
			$$SET(PS1)^18 OR $$SET(SZ1),
			$$SET(PS2)^18 OR $$SET(SZ2),
			$$SET(PS3)^18 OR $$SET(SZ3),
			$$SET(PS4)^18 OR $$SET(SZ4),
			$$SET(PS5)^18 OR $$SET(SZ5),
			$$SET(PS6)^18 OR $$SET(SZ6),
			$$SET(PS7)^18 OR $$SET(SZ7))
		%FI
		%IF C$$COD EQL XB$SUM %THEN
			$$SET(NOK)^9 OR $$SET(NOA),
			REP 3 OF (0))
		%FI
	%ELSE

		$$REG = B$$ADR;	! WILL REFERENCE THE BLOCK INDIRECTLY
					! VIA THE ADDRESS IN REGISTER $$REG

							! STORE COMMON HEADER FOR ALL XAB TYPES
		$$SET(BLN);
		$$SET(BID);
		$$SET(RS1);
		$$SET(COD);
		$$SET(NXT);
							! STORE REST OF XAB DEPENDING ON IT'S TYPE
		%IF C$$COD EQL XB$DAT %THEN
		$$SET(CDT);
		$$SET(RDT);
		$$SET(EDT);
		%FI

		%IF C$$COD EQL XB$ALL %THEN
		$$SET(RS2);
		$$SET(AID);
		$$SET(BKZ);
		%FI

		%IF C$$COD EQL XB$KEY %THEN
		$$SET(IFL);
		$$SET(DFL);
		$$SET(DTP);
		$$SET(FLG);
		$$SET(IAN);
		$$SET(DAN);
		$$SET(LAN);
		$$SET(REF);
		$$SET(KNM);
		$$SET(RX0);
		$$SET(RX1);
		$$SET(RX2);
		$$SET(RX3);
		$$SET(RX4);
		$$SET(RX5);

		$$SET(PS0);
		$$SET(PS1);
		$$SET(PS2);
		$$SET(PS3);
		$$SET(PS4);
		$$SET(PS5);
		$$SET(PS6);
		$$SET(PS7);

		$$SET(SZ0);
		$$SET(SZ1);
		$$SET(SZ2);
		$$SET(SZ3);
		$$SET(SZ4);
		$$SET(SZ5);
		$$SET(SZ6);
		$$SET(SZ7);
		%FI

		%IF C$$COD EQL XB$SUM %THEN		! FILE SUMMARY XAB
		$$SET(RS6);
		$$SET(NOK);
		$$SET(NOA);
		$$SET(RS7);
		$$SET(RS8);
		$$SET(RS9);
		%FI

		END					! END OF BLOCK STARTED IN XAB$B MACRO
	%FI %;

!****************************************************************
!*	5. USE OF INDIVIDUAL RMS CTL FIELDS & OTHER ACTION MACROS *
!****************************************************************

! xxx$Z - ZERO THE SPECIFIED ARGUMENT BLK
!
MACRO FAB$Z(ADDR) = $$ZERO(ADDR,FA$LNG) %;
MACRO RAB$Z(ADDR) = $$ZERO(ADDR,RA$LNG) %;
MACRO XAB$Z(ADDR,CODE) = $$ZERO(ADDR,%NAME(XA$SX,CODE)) %;

MACRO $$ZERO(ADDR,LEN) =
	BEGIN
		REGISTER SAC;
		ADDR = 0;		!PREP THE BLT
		SAC = ADDR^18 OR ADDR+1;!SOURCE AC
		MACHOP (%O'251',SAC,ADDR+LEN-1);
	END %;

! $FIELD(FLD$, ADDR$) - CREATES ACCESS EXPRESSION FOR SPECIFIED RMS FIELD
!	$FIELD(X,Y) CAN BE USED ANYWHERE ANY OTHER DATA SEGMENT NAME CAN BE USED
!	FOR EXAMPLE, IF .$FIELD(X,Y) = 7 THEN ...
!
! ARGUMENTS:
!	ADDR$	THE VALUE OF THIS EXPRESSION IS THE ADDRESS
!		OF THE USER CONTROL BLOCK TO BE REFERENCED
!	FLD$	NAME OF FIELD TO BE REFERENCED
!
MACRO $FIELD(FLD$,ADDR$) =
	(ADDR$ + %NAME(O$$,FLD$)) <%NAME(P$$,FLD$) , %NAME(S$$,FLD$)> %;

! $FETCH(TEMP$, FLD$, ADDR$) - COPIES RMS FIELD TO USER SPEC LOCATION
!
! ARGUMENTS:
!	TEMP$ = THE DESTINATION FIELD
!	ADDR$/FLD$ = AS FOR $FIELD
!
MACRO $FETCH(TEMP$, FLD$, ADDR$) = TEMP$ = .$FIELD(FLD$, ADDR$) %;

! $STORE(TEMP$,FLD$, ADDR$) - COPIES USE SPEC LOCATION TO RMS FIELD
!
! ARGUMENTS:
!	TEMP$ = THE VALUE TO STORE
!	ADDR$/FLD$ = AS FOR $FIELD
!
MACRO $STORE(TEMP$, FLD$, ADDR$) = $FIELD(FLD$, ADDR$) = TEMP$ %;

! $RETURN - USED TO RETURN FROM A USER ERROR ROUTINE.
! CURRENTLY, THE $RETURN MACRO EXPANDS TO A BLISS
! RETURN STATEMENT. HOWEVER, $RETURN SHOULD BE USED TO AVOID
! CONVERSION PROBLEMS IN THE EVENT RMS HANDLES ERROR RETURNS
! DIFFERENTLY IN THE FUTURE.
!
MACRO	$RETURN = RETURN %;

!****************************************************************
!		.BUS SPECIFIC STUFF

MACRO	$$SYNM =
	LITERAL FB$ALL=FB$GET+FB$PUT+FB$DEL+FB$UPD+FB$TRN;
%;

MACRO	$$VERB = $$V_USER %;				!DEFINE USER MACROS


!*****************************************************************
!********************END OF RMSSYM.BUS REQUIRE FILE***************
!*****************************************************************

