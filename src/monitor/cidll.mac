; UPD ID= 8490, RIP:<7.MONITOR>CIDLL.MAC.5,   9-Feb-88 12:17:52 by GSCOTT
;TCO 7.1218 - Update copyright notice.
; UPD ID= 8407, RIP:<7.MONITOR>CIDLL.MAC.4,   4-Feb-88 10:27:45 by GSCOTT
;TCO 7.1210 - Set CINRWP to be not normally dumpable.
; UPD ID= 70, RIP:<7.MONITOR>CIDLL.MAC.3,  12-Aug-87 14:47:02 by MCCOLLUM
;TCO 7.1037 - Fix up calls to SCAMPI, which is now in section XCDSEC.
; *** Edit 7211 to CIDLL.MAC by GRANT on 18-Dec-85
; Add CI counters for WATCH 
; UPD ID= 2283, SNARK:<6.1.MONITOR>CIDLL.MAC.42,  26-Jun-85 14:34:51 by NICHOLS
;TCO 6.1.2296 - Round up receive buffer size to account for up to 7 bytes
;of padding.
; UPD ID= 2056, SNARK:<6.1.MONITOR>CIDLL.MAC.41,   3-Jun-85 14:21:34 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 1974, SNARK:<6.1.MONITOR>CIDLL.MAC.40,  14-May-85 11:29:31 by GLINDELL
;More documentation around BEGSTR's for 6.1 monitor tables manual
; UPD ID= 1868, SNARK:<6.1.MONITOR>CIDLL.MAC.39,   4-May-85 10:54:00 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1810, SNARK:<6.1.MONITOR>CIDLL.MAC.38,  24-Apr-85 14:28:22 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1766, SNARK:<6.1.MONITOR>CIDLL.MAC.37,  19-Apr-85 17:04:34 by GLINDELL
;  TCO 6.1.1332 - return NF.NDP instead of NF.FNS on ZERO LINE COUNTERS
; UPD ID= 1451, SNARK:<6.1.MONITOR>CIDLL.MAC.36,   1-Feb-85 14:19:32 by LOMARTIRE
;Add new symbols to describe the priority used by SC.SDG
; UPD ID= 1344, SNARK:<6.1.MONITOR>CIDLL.MAC.35,  16-Jan-85 11:26:30 by GLINDELL
;Remove TSTS6 tests
; UPD ID= 1154, SNARK:<6.1.MONITOR>CIDLL.MAC.34,   5-Dec-84 17:23:02 by GLINDELL
;Remove unnecessary intra-section transfers
; UPD ID= 1101, SNARK:<6.1.MONITOR>CIDLL.MAC.33,  19-Nov-84 15:44:05 by GLINDELL
;Fix typo
; UPD ID= 1087, SNARK:<6.1.MONITOR>CIDLL.MAC.32,  16-Nov-84 17:29:05 by GLINDELL
;Change line parameter 2848 to 2500, and circuit counter 2500 to 1064
; UPD ID= 1071, SNARK:<6.1.MONITOR>CIDLL.MAC.31,  14-Nov-84 13:32:10 by GLINDELL
;Fix IFIW's
;Add line parameter "buffer size" and circuit counter "data overrun"
; UPD ID= 1061, SNARK:<6.1.MONITOR>CIDLL.MAC.30,  13-Nov-84 09:07:06 by LOMARTIRE
;Use new sending priority symbols in SC.SDG calls.
; UPD ID= 969, SNARK:<6.1.MONITOR>CIDLL.MAC.29,   6-Nov-84 16:08:13 by GLINDELL
;Remove FTT1, insert comments, take out length check
; UPD ID= 864, SNARK:<6.1.MONITOR>CIDLL.MAC.28,  10-Oct-84 17:56:18 by GLINDELL
;Move CIDLL to extended section
; UPD ID= 813, SLICE:<6.1.MONITOR>CIDLL.MAC.24,  20-Sep-84 16:46:01 by GLINDELL
;Forgot to set PBCFLG for .SSPBC callback.. Caused CINBCD bugchk's.
; UPD ID= 770, SNARK:<6.1.MONITOR>CIDLL.MAC.23,  31-Aug-84 12:16:55 by PALMIERI
;Change to new counter macro format
; UPD ID= 738, SNARK:<6.1.MONITOR>CIDLL.MAC.22,  11-Aug-84 11:45:47 by GLINDELL
;Add additional data, and fix comments for all BUG.'s in CIDLL
; UPD ID= 730, SNARK:<6.1.MONITOR>CIDLL.MAC.21,   8-Aug-84 09:34:20 by GLINDELL
;.SSPBC callback has changed: T2 may contain -1 (no CID)
; UPD ID= 702, SNARK:<6.1.MONITOR>CIDLL.MAC.20,  23-Jul-84 17:54:50 by HALPIN
;Add a RET statement to the literal CALL in the PARAMETER macro for Line
;parameter 0 (STATE).
; UPD ID= 698, SNARK:<6.1.MONITOR>CIDLL.MAC.19,  20-Jul-84 13:37:43 by GLINDELL
;Add network management parameters STATE and RECEIVE BUFFERS
;Fix AC bug in network management dispatch
; UPD ID= 692, SNARK:<6.1.MONITOR>CIDLL.MAC.18,  18-Jul-84 09:47:51 by GLINDELL
;Forgot to change .SSMNT to .SSDMA in function code range check
; UPD ID= 691, SNARK:<6.1.MONITOR>CIDLL.MAC.17,  18-Jul-84 09:10:44 by GLINDELL
;More SCAMPI changes: .SSDDG, ACs in .SSDGR, remove .SSCBD, .SSNWO, .SSMNT
; UPD ID= 682, SNARK:<6.1.MONITOR>CIDLL.MAC.16,  13-Jul-84 17:57:46 by GLINDELL
;SCAMPI will no more put back a 'rejected listener' in listen state
; UPD ID= 669, SNARK:<6.1.MONITOR>CIDLL.MAC.15,   6-Jul-84 18:06:40 by PALMIERI
;Turn off FTT1 - for multinode CI testing (requires newer DNADLL)
; UPD ID= 667, SNARK:<6.1.MONITOR>CIDLL.MAC.14,   5-Jul-84 15:47:12 by PALMIERI
;Reorder DLL NTMAN calls to agree with NTMAN
; UPD ID= 654, SNARK:<6.1.MONITOR>CIDLL.MAC.13,   2-Jul-84 16:48:51 by GLINDELL
;Remove PBSBI since SBI # is now equal to node number
;DNAOPN/DNACLS can be called at both jsys and scheduler level
;Correct AC usage in PARAMETER macro
;Test for KLPX9 as well as for SCSISB on SC.CON fail return
;
; UPD ID= 617, SNARK:<6.1.MONITOR>CIDLL.MAC.12,  11-Jun-84 13:42:43 by GLINDELL
;Use RNMXER instead of RETBAD for network management error codes
; UPD ID= 610, SNARK:<6.1.MONITOR>CIDLL.MAC.11,   8-Jun-84 17:27:00 by GLINDELL
;Remove network management entry point, calls come through CINDSP
;
; UPD ID= 591, SNARK:<6.1.MONITOR>CIDLL.MAC.10,   1-Jun-84 18:06:09 by GLINDELL
;Step 1 in allowing DNAOPN/DNACLS to be called at scheduler level
;
; UPD ID= 571, SNARK:<6.1.MONITOR>CIDLL.MAC.9,  28-May-84 15:58:01 by GLINDELL
;New network management entry point
;Remove use of SC.SBI in light of future SCAMPI changes
;
; UPD ID= 523, SNARK:<6.1.MONITOR>CIDLL.MAC.8,  14-May-84 17:29:57 by GLINDELL
;Change reject codes in accordance with new SCAPAR
;
; UPD ID= 506, SNARK:<6.1.MONITOR>CIDLL.MAC.7,   7-May-84 13:07:18 by GLINDELL
;Remove usage of FREE3, make CID be P2 instead
;Remove CIOFF/CION in transmit code
;
; UPD ID= 486, SNARK:<6.1.MONITOR>CIDLL.MAC.6,  30-Apr-84 13:23:10 by GLINDELL
;Change feature tests FTT2 and FTT7 to use 'new' DNADLL
;
; UPD ID= 456, SNARK:<6.1.MONITOR>CIDLL.MAC.5,  25-Apr-84 18:22:04 by GLINDELL
;RONCO is now node 11, change DRPTAB accordingly
;
; UPD ID= 445, SNARK:<6.1.MONITOR>CIDLL.MAC.4,  19-Apr-84 14:12:15 by GLINDELL
;Move NTPARM, NTCTRS and COPMSD (DNCMSG) to D36COM
;
; UPD ID= 441, SNARK:<6.1.MONITOR>CIDLL.MAC.3,  17-Apr-84 11:29:33 by GLINDELL
;Network management interface coded
;Move BEGSTRs CB and PB back because of multiple definition (SCPAR)
;
; UPD ID= 434, SNARK:<6.1.MONITOR>CIDLL.MAC.2,   8-Apr-84 18:34:53 by GLINDELL
;DNADLL and SCA interface coded.
;
; UPD ID= 366, SNARK:<6.1.MONITOR>CIDLL.MAC.1,   1-Mar-84 16:24:11 by GLINDELL


;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1985, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


;CIDLL - DECnet-36 CI Data Link Layer
	SUBTTL Gunnar Lindell 1984
	SEARCH D36PAR,SCAPAR

;The functional and design specification for this module is found in
; R61SPC:CI-DECNET-SPEC.MEM, Gunnar Lindell, 13-Nov-1984

IFN FTOPS20 <
	SEARCH PROLOG
	TTITLE CIDLL,,< - CI Data Link Layer for DECnet-36>
	XRESCD
>

IFN FTOPS10 <
	SEARCH F,S
	TITLE CIDLL - DECnet-36 CI Data Link Layer
	$RELOC
>
	D36SYM			;Set up D36 specific parameters

	RESCD

	Subttl	Table of Contents

;		     Table of Contents for CIDLL
;
;				  Section		      Page
;
;
;    1. Definitions
;        1.1    External and Internals . . . . . . . . . . . .   5
;        1.2    Local symbols and macros . . . . . . . . . . .   6
;        1.3    Protocol parameters  . . . . . . . . . . . . .   7
;        1.4    DECnet/CI
;            1.4.1    Controller block . . . . . . . . . . . .   8
;            1.4.2    Port block . . . . . . . . . . . . . . .   9
;        1.5    Port connection states and macros  . . . . . .  10
;        1.6    Network management
;            1.6.1    Parameters . . . . . . . . . . . . . . .  11
;            1.6.2    Counters . . . . . . . . . . . . . . . .  12
;        1.7    Local storage  . . . . . . . . . . . . . . . .  13
;    2. DNADLL General calls
;        2.1    CININI - Module initialization . . . . . . . .  14
;        2.2    CINSEC - Once-a-second routine . . . . . . . .  15
;        2.3    CINTIC - Once-a-tick service . . . . . . . . .  16
;    3. Dispatches
;        3.1    DECnet-36 calls  . . . . . . . . . . . . . . .  17
;        3.2    SCA callbacks  . . . . . . . . . . . . . . . .  19
;    4. Connection management
;        4.1    DNADLL
;            4.1.1    Open data link layer port  . . . . . . .  20
;            4.1.2    Close data link layer port . . . . . . .  21
;        4.2    SCA callback
;            4.2.1    "Port broke connection"  . . . . . . . .  22
;            4.2.2    "Node came online" . . . . . . . . . . .  23
;            4.2.3    "Connection to listen" . . . . . . . . .  24
;            4.2.4    "Connection response available"  . . . .  25
;            4.2.5    "Ok to send data"  . . . . . . . . . . .  26
;            4.2.6    "Remote initiated disconnect"  . . . . .  27
;        4.3    Subroutines
;            4.3.1    DOLIS  . . . . . . . . . . . . . . . . .  28
;            4.3.2    ACTIVAte . . . . . . . . . . . . . . . .  29
;            4.3.3    DOCONN . . . . . . . . . . . . . . . . .  30
;            4.3.4    LOCDIS . . . . . . . . . . . . . . . . .  31
;            4.3.5    REMDIS . . . . . . . . . . . . . . . . .  32
;            4.3.6    CIDDIS . . . . . . . . . . . . . . . . .  33
;            4.3.7    CANBUF . . . . . . . . . . . . . . . . .  34
;            4.3.8    SCAUCB . . . . . . . . . . . . . . . . .  35
;    5. Data transmission
;        5.1    DNADLL
;            5.1.1    Transmit message . . . . . . . . . . . .  36
;        5.2    SCA callback
;            5.2.1    "Datagram received"  . . . . . . . . . .  37
;            5.2.2    "Message/datagram send complete" . . . .  38
;            5.2.3    "Dropped datagram" . . . . . . . . . . .  39
	Subttl	Table of Contents (page 2)

;		     Table of Contents for CIDLL
;
;				  Section		      Page
;
;
;    6. Network management
;        6.1    Read parameter . . . . . . . . . . . . . . . .  40
;        6.2    Set parameter  . . . . . . . . . . . . . . . .  41
;        6.3    Clear parameter  . . . . . . . . . . . . . . .  42
;        6.4    Show and zero counters . . . . . . . . . . . .  43
	SUBTTL Definitions -- External and Internals

;CIDLL has the following entry points:
	INTERN CININI		;Initialization
	INTERN CINSEC		;Once-a-second routine
;	INTERN CINTIC		;Once-a-tick service - not used
	INTERN CINDSP		;DECnet-36 function dispatch

;CIDLL makes the following external references:
	EXTERN DNGMSG		;Get a DECnet-36 message block
	EXTERN DNSKBY		;Skip bytes in MSD
	EXTERN DNCMSD		;Copy MSD chain to contiguous block
	EXTERN NTPARM		;Network management parameters
	EXTERN NTCTRS		;Network management counters

	SUBTTL Definitions -- Local symbols and macros

;CIDLL specific AC definitions: CB, PB and CID
	DEFAC(CID,P2)
	DEFAC(CB,FREE1)
	DEFAC(PB,FREE2)

;Dispatch macros
	DEFINE $SDSP <...DSP=.>
	DEFINE $DSP(A,B,C) <
		IFN <A - <.-...DSP>>,
			<IF1 <PRINTX Dispatch out of range: 'A 'B>>
		B
	>
	DEFINE $EDSP <PURGE ...DSP>

	SUBTTL Definitions -- Protocol parameters

	XRESCD

;DNANAM is the DECnet SCA process name
DNANAM:	ASCI8(<DECNET$PHASE_III>)

;.CNDRP is the DECnet/CI protocol version
	XP .CNDRP,1

;DNADAT is the DECnet/CI connection data
DNADAT:	BYTE (8) .CNDRP,0,0,0
	REPEAT 3,<BYTE (8) 0,0,0,0>

;Define DECnet/CI reject codes
	XP CNRJNL,.CMNRV+1	;Reject, not listening now
	XP CNRJWP,CNRJNL+1	;Reject, bad protocol version

;Define DECnet/CI disconnect codes
	XP CNDSWS,1		;Wrong state
	XP CNDSLD,2		;Local disconnect
	XP CNDSRD,3		;Remote disconnect

;NDGBUF is the number of receive buffers to queue for each connection
	XP NDGBUF,4		;Heuristic value
	ASSUME NDGBUF,GT,0	;Make sure reasonable value

;POLTIM is the number of seconds between connect attempts
	XP POLTIM,^D30		;Heuristic value
	ASSUME POLTIM,GT,0	;Make sure reasonable

	SUBTTL Definitions --  DECnet/CI -- Controller block

;This structure defines one CI controller for DECnet use.  Since TOPS-20
;only supports one CI20, only one CB block is needed.  That block is
;allocated in static resident space with name CBBLK.

BEGSTR CB			;DECnet/CI controller block
	FIELD CPU,3		;Cpu #
	FIELD CI,3		;Ci interface #
	FIELD KLP,1		;CI ("KLIPA") interface present
	HWORD LPT		;Local port #
	WORD CID		;Connect ID of current listener
	WORD PRT,^D16		;Pointers to port blocks, indexed by port #
ENDSTR

	SUBTTL Definitions --  DECnet/CI -- Port block

;This structure defines one CI port for DECnet use.  The port block is
;allocated when a user says "SET CIRCUIT CI-0-0.x STATE ON" to NCP.  It
;is alloacted from resident extended free space, and is pointed to by
;a table in CBBLK (see BEGSTR CB).
;
;The port block is never deallocated.

BEGSTR PB
	WORD CB			;Pointer to DECnet/CI controller block
	WORD CID		;Connect ID
	WORD DID		;DNADLL ID for this circuit
	HWORD STA		;Connect state for port
	HWORD PNR		;Port # of this port
	HWORD DRE		;Disconnect reason
	WORD BYR		;# of bytes received
	WORD BYS		;# of bytes sent
	WORD DGR		;# of datagrams received
	WORD DGS		;# of datagrams sent
	WORD DDG		;# of datagrams dropped by DECnet
	WORD SDG		;# of datagrams dropped by SCA
	WORD DOR		;# of data overruns
ENDSTR

	SUBTTL Definitions -- Port connection states and macros

;The Port connection states are:
	XP .PSOFF,0		;OFF
	XP .PSLIS,1		;LISTEN
	XP .PSACC,2		;ACCEPT
	XP .PSCDOWN,3		;CONNECT, remote believed down
	XP .PSCUP,4		;CONNECT, remote believed up
	XP .PSCSE,5		;CONNECT sent
	XP .PSRUN,6		;RUN

;The GETSTATE macro loads the port connect state into the AC argument
	DEFINE GETSTATE (A) <
		LOAD A,PBSTA,(PB)
	>

;The CHKSTATE macro skips if the port connect state is equal to the
; state given as argument
	DEFINE CHKSTATE (A) <
		LOAD CX,PBSTA,(PB)
		CAIE CX,.PS'A
	>

;The NEWSTATE macro sets the port connect state to a new value
	DEFINE NEWSTATE (A) <
		MOVX CX,.PS'A
		STOR CX,PBSTA,(PB)
	>

	SUBTTL Definitions -- Network management -- Parameters

;Generate the parameter table
	XSWAPCD
LINTAB:	

PARAMETER(^D0,PANST!PANCL,,,,JFCL,<CALL [ LOAD T2,CBKLP,+CBBLK
					  TRC T2,1
					  RET ]>,JFCL,<STATE>)
PARAMETER(^D1110,PANST!PANCL,,,,JFCL,<SETZ T2,>,JFCL,<CONTROLLER NORMAL>)
PARAMETER(^D1105,PANST!PANCL,,,,JFCL,<MOVX T2,NDGBUF>,JFCL,<RECEIVE BUFFERS>)
PARAMETER(^D1112,PANST!PANCL,,,,JFCL,<MOVX T2,^D7>,JFCL,<PROTOCOL CI>)
PARAMETER(^D2500,PANST!PANCL,,,,JFCL,<MOVE T2,RCVBSZ>,JFCL,<Buffer size>)

NRLPAR==.-LINTAB

CIRTAB:

PARAMETER(^D1112,PANST!PANCL,,,,JFCL,<MOVX T2,^D7>,JFCL,<TYPE CI>)

NRCPAR==.-CIRTAB

	XRESCD

	SUBTTL Definitions -- Network management -- Counters

;Generate the counter table
	XRESCD
COUTAB:

COUNTER(^D1000,^D32,<LOAD T1,PBBYR,(PB)>,<SETZRO PBBYR,(PB)>,,<# of bytes read>)
COUNTER(^D1001,^D32,<LOAD T1,PBBYS,(PB)>,<SETZRO PBBYS,(PB)>,,<# of bytes sent>)
COUNTER(^D1010,^D32,<LOAD T1,PBDGR,(PB)>,<SETZRO PBDGR,(PB)>,,<# of datagrams read>)
COUNTER(^D1011,^D32,<LOAD T1,PBDGS,(PB)>,<SETZRO PBDGS,(PB)>,,<# of datagrams sent>)
COUNTER(^D1020,^D8,<CALL [ LOAD T1,PBDDG,(PB)
		       OPSTR <ADD T1,>,PBSDG,(PB)
		       RET
				  ]>,<CALL [ SETZRO PBDDG,(PB)
				      SETZRO PBSDG,(PB)
				      RET
					   ]>,,<# of dropped datagrams>)
COUNTER(^D1064,^D8,<LOAD T1,PBDOR,(PB)>,<SETZRO PBDOR,(PB)>,,<Data overrun>)

NRCOUN==.-COUTAB

	SUBTTL Definitions -- Local storage

;TOPS-20 can have only one CB block, and it is statically defined here.
; In a possible future TOPS-10 implementation, the CININI should loop
; over all possible CI interfaces and build a CB block for each.
;
;Also, TOPS-20 relies on there being only 1 CB block when locating the
; CB block associated with a connection. On TOPS-10, the "XMOVEI CB,CBBLK"
; has to be replaced with something else.

;The CB block
	RESVR			;Into zeroed resident storage
CBBLK:	BLOCK CB.LEN


;DNACBK has the DNA callback address as supplied in the CININI call
DNACBK:	BLOCK 1

;RCVBSZ has the maximum DECnet receive buffer size
RCVBSZ:	BLOCK 1

;CONTIM is the connect timer, decremented by CINSEC
	RESDT
CONTIM:	EXP -1			;No timer set initially

	XRESCD

	SUBTTL DNADLL General calls -- CININI - Module initialization

;CININI - initializes CIDLL.

;Call:	T1/ line ID (BEGSTR LI)
;	T2/ callback address
;	T3/ maximum DECnet receive buffer size
;	CALL CININI
;	 +1 on error with error code in T1
;	+2 on success
;
;Context: Process

;CININI will initialize the CBBLK, and post a "promiscuous listen".
; Note that since CBBLK is static and zeroed at boot time, only the
; non-zero fields are filled in

	XSWAPCD
CININI:	SAVEAC <CB,P1>
	MOVEM T2,DNACBK		;Save DNADLL callback address
	ADDI T3,7               ; round up to account for padding
	MOVEM T3,RCVBSZ		; and DECnet receive buffer size
	CALL STCBPB		;Set CB from device ID (LI word) supplied in T1
	 RETBAD (CNNCI%)	; -propagate error return

;Note: CPU and CI # are always zero for TOPS-20
	CALL SC.PRT		;Get local port # from SCA
	 RETBAD (CNNCI%)	; -error, "No CI interface present"
	SETONE CBKLP,(CB)	;Set bit in CB "KLIPA present"
	STOR T1,CBLPT,(CB)	; and save local port number

;Since there is a KLIPA on the system, get the poll timer going
	MOVX T1,POLTIM		;Get poll interval
	MOVEM T1,CONTIM		; and store in timer

;Post a "promiscuous listen"
	CALL DOLIS
	 RETBAD (CNNRE%)	; On error, return "No resources"

;Enable "node came online" interrupts
	BLCAL. (<XENT SC.SOA>,<[XADDR. SCACBK]>) ;[7.1037]
	 RETBAD (CNNRE%)	; On error, return "No resources"
	RETSKP

	XRESCD

	SUBTTL DNADLL General calls -- CINSEC - Once-a-second routine

;CINSEC - called once a second

;Call:	CALL CINSEC
;	+1 return always
;
;Context: Scheduler
;
;Retries connect attempts

	XRESCD
CINSEC:	SKIPL CONTIM		;Any timer set?
	SOSLE CONTIM		; -yes, see if time for cycle?
	RET			;  -no, return

;It is time to do a retry on all ports in CUP state.
	SAVEAC <CB,PB,P1>	;Save ACs
	MOVX T1,POLTIM		;Get new timer going
	MOVEM T1,CONTIM		; ...

;Now loop over all CBs. It is of course easy on TOPS-20 since there is
; only one: this has to be reworked on the 10.
	XMOVEI CB,CBBLK		;Load CB address

;Now loop over all ports on this CB
	SETZ P1,		;P1 := port number (begin at 0)
	DO.
	  CAILE P1,<C%SBLL-1>	;Done all ports yet?
	  RET			; -yes, just return
	  XMOVEI T1,CB.PRT(CB)	;Get address to port blocks
	  ADD T1,P1		;Add in port number
	  SKIPN PB,(T1)		;Is there a port block?
	  IFSKP.		; -yes, check connection state
	    CHKSTATE CUP	;  Is it CONNECT, and we believe remote is UP?
	    ANSKP.		;    -yes, then
	      CALL DOCONN	;     call DOCONN
	  ENDIF.
	  AOJA P1,TOP.		;Count up port and loop back
	ENDDO.
;Will never get here

	SUBTTL DNADLL General calls -- CINTIC - Once-a-tick service

;CIDLL does not use the once-a-tick service that DNADLL provides
;	RESCD
;CINTIC:RET

	SUBTTL Dispatches -- DECnet-36 calls

;CINDSP - called to perform a DECnet-36 function

;Call:	T1/ function code
;	T2/ CIDLL ID
;	T3/ data
;	T4/ additional data, if needed
;	CALL CINDSP
;	 +1 on error with error code in T1
;	+2 on success
;
;Context: Jsys, scheduler

	ASSUME DF.OPN,EQ,0

;Define flags to determine what predispatch processing that should be done
	OPNFLG==:1B1		;Device ID is LI word, and PB may not exist
	PBFLG==:1B2		;Device ID is PB address
	NTMFLG==:1B3		;Network management call

	XRESCD
CINDSP:
  IFN FTDEBUG <			;Range check while debugging
	CAIL T1,DF.OPN
	CAILE T1,DF.SZC
	BUG.(CHK,CINDOR,CIDLL,SOFT,<DNA dispatch out of range>,<<T1,FUNCOD>>,<

Cause:	ROUTER called CIDLL with a function code that is out of range.

Data:	FUNCOD - The bad function code
>,RTN)
  >
	SAVEAC <T5,T6,P1,MS,CB,PB,MB> ;Save ACs
	DMOVE T5,T2		;Save T2-T3
	MOVE MB,DNADSP(T1)	;Get dispatch word and flags

;Check PBFLG - if set, then the PB address was passed
	TXZN MB,PBFLG		;Is PB flag set?
	IFSKP.			; -yes,
	  MOVE PB,T5		;   T2 contains PB
	  LOAD CB,PBCB,(PB)	;   and PB points to CB
	ENDIF.

;Check OPNFLG - if set, then this is a call to open a new port, and a PB
; may or may not exist
	TXZN MB,OPNFLG		;Should we get CB and PB from LI word, but
				; allow PB to be non-existing?
	IFSKP.			; -yes,
	  SETZ PB,		;  Clear PB to flag non-existent port block
	  MOVE T1,T5		;  Get LI word
	  CALL STCBPB		;  Set CB and PB from LI word
	  CAIN T1,CNPNA%	;  Is the error code "port block not allocated"
	  SKIPA			;  -skip return or the "right" error code, skip
	  RET			;   the error return
	ENDIF.

;Check NTMFLG - if set, then this is a network management call
	TXZN MB,NTMFLG		;Is NTMFLG set (network management request)
	IFSKP.			;  -yes,
	  MOVE P1,T5		;   move NF address to a safer place
	  LOAD T1,NFEID,(P1)	;   get LI word from NF block
	  CALL STCBPB		;    and set up CB (and PB) from block
	   RNMXER (NF.URC)	;     -error "Unrecognized component"
	ENDIF.

;Dispatch to processing routine
	DMOVE T2,T5		;Restore T2-T3
	JRST (MB)		; and dispatch

;DNA function dispatch table

DNADSP:	$SDSP
	 $DSP(DF.OPN,<IFIW!OPNFLG!<DNAOPN&777777>>,<Open data link layer port>)
	 $DSP(DF.CLS,<IFIW!PBFLG!<DNACLS&777777>>,<Close data link layer port>)
	 $DSP(DF.XMT,<IFIW!PBFLG!<DNAXMT&777777>>,<Transmit DECnet message>)
	 $DSP(DF.SET,<IFIW!NTMFLG!<NTMSET&777777>>,<Set parameter>)
	 $DSP(DF.CLR,<IFIW!NTMFLG!<NTMCLR&777777>>,<Clear parameter>)
	 $DSP(DF.RED,<IFIW!NTMFLG!<NTMRED&777777>>,<Read parameter>)
	 $DSP(DF.SHC,<IFIW!NTMFLG!<NTMCOU&777777>>,<Show counters>)
	 $DSP(DF.SZC,<IFIW!NTMFLG!<NTMSZC&777777>>,<Show and zero counters>)
	$EDSP



;STCBPB sets up CB and PB from a LI word.
;
;Call:	T1/ LI word
;	CALL STCBPB
;	 +1 error return, status code in T1
;	+2 success return, CB and PB set up
;
;Context: Jsys or scheduler
;
;Note: If the only thing wrong is that the PB is not yet allocated and
; built, CB is set to contain the CB address, and the status code is set
; to CNPNA% (Port block not allocated)
;
;Note: this routine will reject a specification of the local port

STCBPB:	SAVEAC <P1>
	MOVE P1,T1		;Put LI word in a safer place

  IFN FTDEBUG <
	LOAD T1,LIDEV,+P1	;Get device type
	CAIE T1,LD.CIP		; and verify that it is indeed CI port
	IFNSK.
	  BUG.(CHK,CINNCI,CIDLL,SOFT,<Device type not CI>,<<P1,LI>>,<

Cause:	The device type supplied to CIDLL was not a CI. ROUTER and NTMAN
	should only call CIDLL for CI lines and circuits.

Data:	LI - The rejected line ID
>)
	  RETBAD (CNNSP%)	;  and return error after bugcheck
	ENDIF.
  >

;Now setup CB
	LOAD T1,LIKON,+P1	;Get controller number
	LOAD T2,LIUNI,+P1	; and unit number
	SKIPN T1		;Both should be zero on TOPS-20
	SKIPE T2		; ...
	RETBAD (CNNSP%)		; -return error if not
	XMOVEI CB,CBBLK		;Ok, get address of CB block
	
;Is it line or circuit?
	TMNE LILXC,+P1		;Line?
	RETSKP			; -yes, return, all done

;Circuit, proceed and get drop number
	OPSTR <SKIPL T1,>,LIDRP,+P1 ;Get drop number
	CAILE T1,<C%SBLL - 1>	;Between 0 and 15?
	RETBAD (CNNSP%)		; -no, error return

	OPSTR <CAMN T1,>,CBLPT,(CB) ;Is this local port?
	RETBAD (CNLPT%)		; -yes, thats illegal

	XMOVEI T2,CB.PRT(CB)	;Get address of port block
	ADD T2,T1		;Add in port number
	SKIPN PB,(T2)		;Load PB and test if zero
	RETBAD (CNPNA%)		; -not there, return "Port block not allocated"
	RETSKP

	SUBTTL Dispatches -- SCA callbacks

;SCACBK - all SCA callbacks come through here

;Call:	T1/ function code
;	T2/ CID (in general). 
;	T3-4/ function specific data
;
;Context: Scheduler or SCA interrupt

;Define flags to determine what predispatch processing that needs to be done
	CIDFLG==:1B1		;Get CB and PB from CID
	LISFLG==:1B2		;Get CB from CID
	NODFLG==:1B3		;Get CB and PB from node #
	BUGFLG==:1B4		;Generate BUGCHK (unexpected callback)
	NOPFLG==:1B5		;Ignore, i.e. just return
	PBCFLG==:1B6		;Port broke connection call

	ASSUME .SSDGR,EQ,0

	XRESCD			;Run in extended resident code
SCACBK:	SAVEAC <T5,T6,MB,CB,PB,CID> ;Save Acs

;MB is used for the dispatch address and flags
	MOVE MB,SCADSP(T1)	;Dispatch table entry to MB
	MOVE CID,T2		;CID to T2
	DMOVE T5,T3		;Move T3-4 to T5-6 to save them for a while
  IFN FTDEBUG <			;Range check only while debugging
	CAIL T1,.SSDGR		;Range check function code
	CAILE T1,.SSDMA
	SKIPA			;Go bugchk
  >

;Check BUGFLG - if set, then we should never see this callback so BUGCHK
	TXZE MB,BUGFLG		;Is BUGCHK flag set?
	BUG. (CHK,CINBSC,CIDLL,SOFT,<Unexpected SCA callback>,<<T1,SCAFUN>,<CID,SCACID>>,<

Cause:	SCAMPI issued a callback to CIDLL with an unexpected callback.

Data:	SCAFUN - The bad function code
	SCACID - The connect ID that SCAMPI supplied on the call
>,RTN)				;Return after bugcheck

;Check NOPFLG - if set, then we can ignore this callback
	TXZE MB,NOPFLG		;Ignore flag set?
	RET			; then just return

;Check PBCFLG - if set, then it is a "port broke connection" callback. This
; callback is special because it may have a negative "CID", indicating an
; "unsolicited" node offline callback.
	TXZN MB,PBCFLG		;Is it "port broke connection"?
	IFSKP.			; -yes,
	  JUMPL CID,RTN		;  If CID is -1 then it is an unsolicited
				;  pbc, and we are not interested
	  TXO MB,CIDFLG		;  T2 is not -1 =) T2 contains CID. Set CIDFLG.
	ENDIF.

;Check CIDFLG and LISFLG - if any set, then load the CB block address
	TXNN MB,LISFLG!CIDFLG	;CIDFLG or LISFLG set?
	IFSKP.			; -yes, start with getting CB
   IFN FTDEBUG <
	  OPSTR <SKIPE>,SID,CID	;  Verify that user field in CID is zero
	  CALLRET BADCID	;  -no, bugcheck and return
   >
	  XMOVEI CB,CBBLK	;  -yes, load CB address
	ENDIF.

;Check LISFLG - if set, then this is a listener call and we may not have
; a PB set up for the port in question. Therefore we do not load a PB here.
	TXZN MB,LISFLG		;Listener flag set?
	IFSKP.			; -yes, verify listener CID in CB
	  OPSTR <CAME CID,>,CBCID,(CB) ;Equal?
	  CALLRET BADCID	;   -no, bugcheck and return
	ENDIF.

;Check CIDFLG - if set, then the CID is valid and we should have a PB
	TXZN MB,CIDFLG		; Is CID flag set?
	IFSKP.			; -yes, setup and verify PB also
	  MOVE T1,CID		;  Get port number
	  CALL <XENT SC.NOD>	;[7.1037]   from CID into T2
	  XMOVEI T1,CB.PRT(CB)	;  Address of port table
	  ADD T1,T2		;  Add offset into table
	  SKIPN PB,(T1)		;  Load PB and check if zero
	  CALLRET BADCID	;   -yes, bugcheck and return
	  OPSTR <CAME CID,>,PBCID,(PB) ;Verify CID in PB
	  CALLRET BADCID	;        -bad, bugcheck and return
	ENDIF.

;Check NODFLG - if set, then this is a node online call and we may not have
; a CID.
	TXZN MB,NODFLG		;Node flag set?
	IFSKP.			; -yes, means node # is in CID
	  XMOVEI CB,CBBLK	;  Load CB address
	  XMOVEI T1,CB.PRT(CB)	;  Get address of port table
	  ADD T1,CID		;  Add port # as offset
	  MOVE PB,(T1)		;  And load PB (possibly zero)
	ENDIF.

;Predispatch processing done, retrieve T3-4 and dispatch
	DMOVE T3,T5		;Restore T3-4
	JRST (MB)		; and dispatch off MB

;BADCID generates a bugcheck "Bad CID" and returns
BADCID:	BUG.(CHK,CINBCD,CIDLL,SOFT,<Bad CID>,<<CID,CID>,<MB,DSPTCH>>,<

Cause:	SCAMPI supplied a bad connect ID on a callback to CIDLL.
	CIDLL does not have any connection open with the particular
	connect ID.  This bugcheck may occur if one system crashes 
	while a DECnet/CI message is outstanding.

Data:	CID - The bad connect ID
	DSPTCH - The function dispatch word
>,RTN)

;SCA callback dispatch table

SCADSP:	$SDSP
	 $DSP(.SSDGR,<IFIW!CIDFLG!<SCADGR&777777>>,<Datagram received>)
	 $DSP(.SSMGR,<BUGFLG>,<Message received>)
	 $DSP(.SSPBC,<IFIW!PBCFLG!<SCAPBC&777777>>,<Port broke connection>)
	 $DSP(.SSCTL,<IFIW!LISFLG!<SCACTL&777777>>,<Connection to listen>)
	 $DSP(.SSCRA,<IFIW!CIDFLG!<SCACRA&777777>>,<Connect resp. available>)
	 $DSP(.SSMSC,<IFIW!CIDFLG!<SCAMSC&777777>>,<Send complete>)
	 $DSP(.SSDDG,<IFIW!CIDFLG!<SCADDG&777777>>,<Dropped datagram>)
	 $DSP(.SSLCL,<NOPFLG>,<Little credit left>)
	 $DSP(.SSNCO,<IFIW!NODFLG!<SCANCO&777777>>,<Node came online>)
	 $DSP(.SSOSD,<IFIW!CIDFLG!<SCAOSD&777777>>,<Ok to send data>)
	 $DSP(.SSRID,<IFIW!CIDFLG!<SCARID&777777>>,<Remote disconnected>)
	 $DSP(.SSCIA,<NOPFLG>,<Credit is available>)
	 $DSP(.SSDMA,<BUGFLG>,<Named buffer operation complete>)
	$EDSP

	SUBTTL Connection management -- DNADLL -- Open data link layer port

;DNAOPN opens a data link layer port.
;
;Call:	CB and PB set up: PB is zero if port block is not yet allocated
;	T2/ port ID as begstr LI
;	T3/ DNADLL ID for this port
;	CALL DNAOPN
;	 +1 error return, status code in T1
;	+2 success return
;
;Context: Process or scheduler
;
;Ac usage: CB, PB and MB may be clobbered.

	ASSUME LI.LEN,EQ,1	;Make sure LI BEGSTR fits into one word

	XRESCD
DNAOPN:	STKVAR <LIID,DLLID>
	MOVEM T2,LIID		;Save port ID
	MOVEM T3,DLLID		;Save DNADLL ID
	NOSKED			;Protect
	SKIPN PB		;Does PB exist?
	IFSKP.
	  OKSKED		;  Unprotect
	  CHKSTATE OFF
	    RETBAD (CNPAO%,)	;  Return status "Port already open"
	ELSE.
	  ;Come here to build a port block
	  MOVX T1,PB.LEN	;Allocate port block
	  CALL DNGWDZ		;Get zeroed data
	    RETBAD (CNNRE%)	; -error "No resources"
	  MOVE PB,T1		;Make PB point to allocated block
	  STOR CB,PBCB,(PB)	;Store CB address in PB
	  MOVE T1,DLLID		;Get DNADLL ID
	  STOR T1,PBDID,(PB)	; and store in port block
	  NEWSTATE OFF		;Initial state is OFF
	  MOVE T1,LIID		;Get LI word
	  LOAD T1,LIDRP,+T1	; and extract drop number
	  STOR T1,PBPNR,(PB)	; which is port number
	;Link PB into CB. When that is done, the port is in operation
	  XMOVEI T2,CB.PRT(CB)	;Get address of port table
	  ADD T2,T1		; and offset to the port number
	  MOVEM PB,(T2)		; and store pointer to PB in CB
	  OKSKED		;Ok to unprotect
	ENDIF.
;Activate the port, port state =) LISTEN or CONNECT
	CALL ACTIVA
	MOVE T1,PB		;Return port handle ("PB") in T1
	RETSKP
	ENDSV.

	SUBTTL Connection management -- DNADLL -- Close data link layer port

;DNACLS closes a data link layer port
;
;Call:	PB and CB are set up
;	CALL DNACLS
;	 +1 error return, status code in T1
;	+2 success return
;
;Context: Jsys or scheduler level
;
;Ac usage: CB, PB and MB may be clobbered

;Interlocking: DNACLS has to interlock between getting the old state and
; disconnecting the connection if there was one. If CIOFF was not done, DNACLS
; could assume that the status was, say, LISTEN and then set the state to
; OFF. In the window between reading LISTEN and setting state to OFF there
; could be a SCA interrupt establishing a connection.

	XRESCD			;Must be resident since CIOFF is done
DNACLS:	CIOFF			;Implies NOSKED too..
	GETSTATE T1		;Get current state
	CALL @DNACLT(T1)	;Call transition routine
	NEWSTATE OFF		;New state is OFF in all cases
	CION			;No harm can be done now
	RETSKP

;DNACLT is state transition vector for DNADLL Close event
DNACLT:	$SDSP
	 $DSP(.PSOFF,<IFIW <R&777777>>,<Current state is OFF>)
	 $DSP(.PSLIS,<IFIW <R&777777>>,<Current state is LISTEN>)
	 $DSP(.PSACC,<IFIW <LOCDIS&777777>>,<Current state is ACCEPT>)
	 $DSP(.PSCDO,<IFIW <R&777777>>,<Current state is CDOWN>)
	 $DSP(.PSCUP,<IFIW <R&777777>>,<Current state is CUP>)
	 $DSP(.PSCSE,<IFIW <LOCDIS&777777>>,<Current state is CSENT>)
	 $DSP(.PSRUN,<IFIW <LOCDIS&777777>>,<Current state is RUN>)
	$EDSP

	SUBTTL Connection management -- SCA callback -- "Port broke connection"

;"Port broke connection" callback indicate that the connection to the remote
;  node has been broken for some reason.
;
;At the callback the CID is unusable, and the connection is broken. Buffers
; outstanding for it will be cleaned when the SCA reaper runs at a future
; time.
;
;CIDLL shall activate the connection if needed, and report "port state change"
; to DNADLL if the current state was RUN.
;
;Call:	CB,PB and CID set up
;	CALL SCAPBC
;
;Context: Scheduler or SCA interrupt
;
;Note: there is no interlock problem since even if the callback occurred at
; scheduler level, SCA will not interrupt for the same CID (since its broken)

	XRESCD
SCAPBC:	GETSTATE T1		;Get current state
	JRST @SCAPBT(T1)	; and go to transition routine

;SCAPBT is the state transition vector for SCA callback "port broke connection"
SCAPBT:	$SDSP
	 $DSP(.PSOFF,<IFIW <SCAUCB&777777>>,<Current state is OFF>)
	 $DSP(.PSLIS,<IFIW <SCAUCB&777777>>,<Current state is LISTEN>)
	 $DSP(.PSACC,<IFIW <PBCACC&777777>>,<Current state is ACCEPT>)
	 $DSP(.PSCDO,<IFIW <SCAUCB&777777>>,<Current state is CDOWN>)
	 $DSP(.PSCUP,<IFIW <PBCCUP&777777>>,<Current state is CUP>)
	 $DSP(.PSCSE,<IFIW <PBCCSE&777777>>,<Current state is CSENT>)
	 $DSP(.PSRUN,<IFIW <PBCRUN&777777>>,<Current state is RUN>)
	$EDSP

;PBCACC handles ACCEPT state
;
;Move state to LISTEN
PBCACC:	NEWSTATE LISTEN		;CID is disconnected, need not do any more
	RET

;PBCCUP handles CUP state
;PBCCSE handles CSENT state
;
;Move state to CDOWN
PBCCUP:
PBCCSE:	NEWSTATE CDOWN		;Remote is down
	RET

;PBCRUN handles RUN state
;
;Signal port state change (to down) to DNADLL, and activate port
PBCRUN:	MOVX T1,DI.LSC		;Port state change
	LOAD T2,PBDID,(PB)	;DNADLL id
	MOVX T3,LS.OFF		;Port OFF
	CALL @DNACBK		;Call DNADLL at callback address
	CALLRET ACTIVA		;Activate this port and return

	SUBTTL Connection management -- SCA callback -- "Node came online"

;SCANCO is called on SCA callback "node came online"
;
;Call:	CB, PB setup (PB possibly zero)
;	CALL SCANCO
;	+1 return always
;
;Context: SCA interrupt

	XRESCD
SCANCO:	SKIPN PB		;Is there a port block?
	RET			; -no, just return
	GETSTATE T1		;Get state into T1
	JRST @SCANCT(T1)	; and go to transition routine

;SCANCT is the state transition vector for "node came online"
SCANCT:	$SDSP
	 $DSP(.PSOFF,<IFIW <R&777777>>,<Current state is OFF>)
	 $DSP(.PSLIS,<IFIW <R&777777>>,<Current state is LISTEN>)
	 $DSP(.PSACC,<IFIW <SCAUCB&777777>>,<Current state is ACCEPT>)
	 $DSP(.PSCDO,<IFIW <NCOCDO&777777>>,<Current state is CDOWN>)
	 $DSP(.PSCUP,<IFIW <R&777777>>,<Current state is CUP>)
	 $DSP(.PSCSE,<IFIW <NCOCSE&777777>>,<Current state is CSENT>)
	 $DSP(.PSRUN,<IFIW <SCAUCB&777777>>,<Current state is RUN>)
	$EDSP

;NCOCSE handles CSENT state
;NCOCDO handles CDOWN state
;
;Move state to CUP, bugcheck if in CSENT state
NCOCSE:	CALL SCAUCB		;Bugcheck if in CSENT state
NCOCDO:	NEWSTATE CUP
	RET

	SUBTTL Connection management -- SCA callback -- "Connection to listen"

;SCACTL is called on SCA callback "connection to listen"
;
;Call:	CB, PB and CID set up
;	T3/ Address of connection data from remote system
;	CALL SCACTL
;	+1 return always
;
;Context: SCA interrupt

	XRESCD
SCACTL:	STKVAR <REMDAT>
	MOVEM T3,REMDAT		;Save address of remote connect data
	CALL DOLIS		;Post a new promiscuous listener
	JFCL			; ...
;Now get the port number for the remote end
	MOVE T1,CID		;Load CID into T1 to
	CALL <XENT SC.NOD>	;[7.1037] get port number into T2
;See if we are listening on this port: do we have a PB?
	XMOVEI T1,CB.PRT(CB)	;Get address of port blocks
	ADD T2,T1		; add port number offset
	SKIPN PB,(T2)		;Load PB and check for zero
	CALLRET REJNL		; -no, no PB, reject and return
;Yes, we have a PB: are we listening?
;Note: the following section of code replaces the state transition vector
	CHKSTATE LISTEN
	  CALLRET REJNL		;   and do reject
;The only thing that can stop us now is bad connection data
	MOVE T2,REMDAT		;Get address of remote connection data
	LDB T1,[POINT 8,(T2),7]	; and 1st byte of connection data
	CAIN T1,.CNDRP		;Check if protocol type is .CNDRP "Multidrop"
	IFSKP.			; -no,
	  NEWSTATE OFF		;   Set state to OFF
	  CALL REJWP		;   Reject connection
	  MOVX T2,.CNDRP	;   Get our protocol version
	  BUG.(INF,CINRWP,CIDLL,SOFT,<Remote supplied wrong protocol version>,<<T1,REMVER>,<T2,LOCVER>>,<

Cause:	The remote port is not running the same protocol version of DECnet/CI.
	This may happen if you are running DECnet/CI between two different
	versions of TOPS-20, or if you are running DECnet/CI between TOPS-20
	and a VMS system. DECnet/CI between TOPS-20 and VMS is not 
	supported.

Data:	REMVER - The remote ends protocol version
	LOCVER - The local TOPS-20 systems protocol version
>,RTN,<DB%NND>)			;[7.1210]
	ENDIF.
;All ok, accept the connection
	BLCAL. (<XENT SC.ACC>,<CID,[0],[0],[NDGBUF]>) ;[7.1037]Accept
	IFSKP.			;If succeded,
	  STOR CID,PBCID,(PB)
	  NEWSTATE ACCEPT	; and new state is ACCEPT
	ELSE.			;Accept failed
;Note: if the ACCEPT fails nothing bad can happen. State stays LISTEN,
; and no CID has been moved into the PB to confuse things
	  BUG.(CHK,CINACF,CIDLL,SOFT,<Accept failed>,<<T1,ERRCOD>>,<

Cause:	CIDLL decided to accept an incoming connection, but the accept
	call to SCA failed.

Data:	ERRCOD - The error code returned by SCAMPI
>)
	ENDIF.
	RET			;Return
	ENDSV.

;REJECT a connection with code CNRJNL "no listener"
;

REJNL:	MOVX T1,CNRJNL		;Load rejection code
	JRST REJECT		; and go reject

;REJECT a connection with code CNRJWP "wrong protocol version"
;

REJWP:	MOVX T1,CNRJWP		;Load rejection code
;	JRST REJECT		; and go reject

REJECT:	BLCAL. (<XENT SC.REJ>,<CID,T1>) ;[7.1037]
	 JFCL			;Ignore failure to reject
	RET

	SUBTTL Connection management -- SCA callback -- "Connection response available"

;SCACRA is called on SCA callback "Connection response available". It is
; expected to happen while in CSENT state, and informs CIDLL whether the
; connection was accepted (go to RUN) or if it was rejected (go to OFF)
;
;Call:	CB, PB and CID set up.
;	T3/ -1 if accepted, 0 if rejected
;	T4/ reject code, or pointer to connection data
;	CALL SCACRA
;	+1 return always
;
;Context: SCA interrupt

	XRESCD
SCACRA:	STKVAR <REMSTS,REJCOD>
	MOVEM T3,REMSTS		;Save status and rejection code
	MOVEM T4,REJCOD
;The following section of code implements the state transitions for SCACRA:
; if the current state is not CONNECT, then bugchk and do no more. Else process
; the connect response
	CHKSTATE CSENT
	 BUG.(CHK,CINUEC,CIDLL,SOFT,<Unexpected connect response>,<<CID,SCACID>>,<

Cause:	CIDLL received a callback from SCA stating that a connection response
	was available. CIDLL was not expecting any such callback for
	the port.

Data:	SCACID - The connect ID
>,RTN)				; -return after the BUGCHK

;Now, if state is CSENT, then check if it was rejected. If so, go to state
; OFF and BUGINF, else go to state RUN and signal "port state change"
	SKIPN REMSTS		;Rejected or accepted
	IFSKP.			; -accepted!
	  NEWSTATE RUN		;  New state is RUN
	  MOVX T1,DI.LSC	;  Flag port state change to DNADLL
	  LOAD T2,PBDID,(PB)	;  DNADLL id
	  MOVX T3,LS.ON		;  New port state is ON
	  CALLRET @DNACBK	;  Call DNADLL and return
	ELSE.			; -rejected
	  BLCAL. (<XENT SC.DIS>,<CID,[CNDSWS]>) ;[7.1037]Disconnect "wrong state"
	   JFCL			;   -ignore failure to disconnect
	  MOVE T1,REJCOD	;    Get rejection code
	  CAIN T1,CNRJWP	;    Is it wrong protocol version?
	  IFSKP.		;     -no,
	    NEWSTATE CUP	;       just move to CUP
	  ELSE.			;     -yes,
	    NEWSTATE OFF	;      new state is OFF
	    MOVX T1,.CNDRP	;      Get our protocol version
	    BUG.(INF,CINRRL,CIDLL,SOFT,<Remote rejected our protocol version>,<<T1,LOCVER>>,<

Cause:	The remote port does not understand the protocol version of DECnet/CI.
	The other system may be running another version of TOPS-20, or the
	remote system may be running VMS. DECnet/CI between TOPS-20
	and VMS is not supported.

Data:	LOCVER - TOPS-20 DECnet/CI protocol version
>)
	  ENDIF.
	ENDIF.
	RET

	ENDSV.

	SUBTTL Connection management -- SCA callback -- "Ok to send data"

;SCAOSD is called on SCA callback "Ok to send data". It is expected to
; occur while in ACCEPT state, and is an indication that the connection
; is established, i.e. 
;
;Call:	CB, PB and CID set up
;	CALL SCAOSD
;	+1 return always
;
;Context: SCA interrupt

	XRESCD
SCAOSD:	GETSTATE T1		;Get current state
	JRST @SCAOST(T1)	; and go to transition routine

;SCAOST is the state transition vector for SCA callback "Ok to send data"
SCAOST:	$SDSP
	 $DSP(.PSOFF,<IFIW <SCAUCB&777777>>,<Current state is OFF>)
	 $DSP(.PSLIS,<IFIW <SCAUCB&777777>>,<Current state is LISTEN>)
	 $DSP(.PSACC,<IFIW <OSDACC&777777>>,<Current state is ACCEPT>)
	 $DSP(.PSCDO,<IFIW <SCAUCB&777777>>,<Current state is CDOWN>)
	 $DSP(.PSCUP,<IFIW <SCAUCB&777777>>,<Current state is CUP>)
	 $DSP(.PSCSE,<IFIW <SCAUCB&777777>>,<Current state is CSENT>)
	 $DSP(.PSRUN,<IFIW <R&777777>>,<Current state is RUN>)
	$EDSP

;OSDACC is called in ACCEPT state
OSDACC:	NEWSTATE RUN		;Hurrah!
	MOVX T1,DI.LSC		;Tell DNADLL also "port state change"
	LOAD T2,PBDID,(PB)	;DNADLL id
	MOVX T3,LS.ON		;New state is ON
	CALLRET @DNACBK		;Call at supplied address and return

	SUBTTL Connection management -- SCA callback -- "Remote initiated disconnect"

;SCARID is called on SCA callback "remote disconnect". CIDLL will disconnect
; the port if running, notify DNADLL if so, and activate the port again.
;
;Call:	CB, PB and CID set up
;	CALL SCARID
;	+1 return always
;
;Context: SCA interrupt

SCARID:	GETSTATE T1		;Get current state
	JRST @SCARIT(T1)	; and go to transition routine

;SCARIT is the transition vector for SCA callback "Remote initiated disconnect"
SCARIT:	$SDSP
	 $DSP(.PSOFF,<IFIW <SCAUCB&777777>>,<Current state is OFF>)
	 $DSP(.PSLIS,<IFIW <SCAUCB&777777>>,<Current state is LISTEN>)
	 $DSP(.PSACC,<IFIW <RIDACC&777777>>,<Current state is ACCEPT>)
	 $DSP(.PSCDO,<IFIW <SCAUCB&777777>>,<Current state is CDOWN>)
	 $DSP(.PSCUP,<IFIW <SCAUCB&777777>>,<Current state is CUP>)
	 $DSP(.PSCSE,<IFIW <RIDCSE&777777>>,<Current state is CSENT>)
	 $DSP(.PSRUN,<IFIW <RIDRUN&777777>>,<Current state is RUN>)
	$EDSP

;RIDACC is called in ACCEPT state
RIDACC:	CALL REMDIS		;Return receive buffers and disconnect
	NEWSTATE LISTEN		; and new state is LISTEN
	RET

;RIDCSE is called in CSENT state
RIDCSE:	CALL REMDIS		;Return receive buffers and disconnect
	NEWSTATE CUP		; and new state is CUP
	RET

;RIDRUN is called in RUN state
RIDRUN:	CALL REMDIS		;Return receive buffers and disconnect
	MOVX T1,DI.LSC		;Signal port down to DNADLL
	LOAD T2,PBDID,(PB)	;DNADLL id
	MOVX T3,LS.OFF		;Down
	CALL @DNACBK		;Call at supplied address
	CALLRET ACTIVA		; and activate and return

	SUBTTL Connection management -- Subroutines -- DOLIS

;DOLIS posts a promiscuous listen
;
;Call:	CB/ points to CB block
;	CALL DOLIS
;	 +1 error return, SCA error code in T1
;	+2 success return, CID for listen inserted into CBCID
;
;Context: Jsys or SCA interrupt

	XRESCD
DOLIS:	BLCAL. (<XENT SC.LIS>,<[XADDR. DNANAM],[XADDR. DNANAM],[-1],[XADDR. SCACBK],[0],[0],[0]>) ;[7.1037]
	 BUG.(CHK,CINLIE,CIDLL,SOFT,<Listen failed>,<<T1,ERRCOD>>,<

Cause:	CIDLL asked SCA for a "promiscuous listen" but the call failed.
	As a consequence, the system will not accept any future incoming
	DECnet/CI connections.

Data:	ERRCOD - The error code returned from SCAMPI
>,RTN)				;Return after bugcheck

	STOR T1,CBCID,(CB)	;Store new listener CID
	RETSKP

	SUBTTL Connection management -- Subroutines -- ACTIVAte

;ACTIVAte decides whether a port should go to LISTEN or CONNECT state
;
;Call:	CB and PB setup
;	CALL ACTIVA
;	+1 always
;
;Context: Jsys or SCA interrupt
;
;Connection algorithm says that if local port # is less than remote, then
; our side LISTENs, else connects.

	XRESCD
ACTIVA:	LOAD T1,CBLPT,(CB)	;Get local port #
	OPSTR <CAML T1,>,PBPNR,(PB) ; Less than remote port # ?
	IFSKP.			;  -yes, do LISTEN
	  NEWSTATE LISTEN	;   So move state to LISTEN
	ELSE.
	  OPSTR <CAMG T1,>,PBPNR,(PB) ;Local greater than remote port # ?
	  IFSKP.
	    NEWSTATE CUP	;   -yes, move state to CUP
	    CALL DOCONN		;    and do a connect
	  ELSE.			;   Local port = remote port, we're confused
	    NEWSTATE OFF	;   Go to OFF state
	    BUG.(CHK,CINLER,CIDLL,SOFT,<Local port # equal to remote>,,<

Cause:	The ACTIVATE routine noticed that we tried to connect to ourselves.
	CIDLL should have detected this before.
>,RTN)
	  ENDIF.
	ENDIF.
	RET

	SUBTTL Connection management -- Subroutines -- DOCONN

;DOCONN does an active connect
;
;Call:	CB and PB setup
;	CALL DOCONN
;	+1 always
;
;Context: Jsys or scheduler
;

	XRESCD
DOCONN:
;Must interlock here since SCA may interrupt between BLCAL. and the next
; instruction that stores the CID....... 
	CIOFF
;Make sure that -
;    STATE is indeed CUP. This will protect against connect responses
;    coming in between the call of this routine and the actual connect call
;    to SCA
	CHKSTATE CUP		;Make sure we are in CUP state
	IFSKP.			; -yes,
	  BLCAL. (<XENT SC.CON>,<[XADDR. DNANAM],[XADDR. DNANAM],<PBPNR,(PB)>,[0],[0],[XADDR. SCACBK],[0],[XADDR. DNADAT],[0],[NDGBUF]>) ;[7.1037]
	  IFSKP.		; Success return
	    STOR T1,PBCID,(PB)	; Store CID since connect now going
	    NEWSTATE CSENT	;  and move state to connect sent
	  ELSE.			; Fail return
	    CAIE T1,SCSISB	; Is there a system block
	    CAIN T1,KLPX9	;  and is VC open?
	    IFNSK.		;  -yes, move state to CDOWN
	      NEWSTATE CDOWN
	    ENDIF.
	  ENDIF.
	ENDIF.
	CION			;Allow interrupts
	RET

	SUBTTL Connection management -- Subroutines -- LOCDIS

;LOCDIS - disconnect a connection
;
;Called at many state transitions when local node decides to disconnect
;
;Will cancel SCA receive buffers and disconnect the connection

LOCDIS:	CALL CANBUF		;Cancel outstanding receive buffers
	MOVX T1,CNDSLD		;Load disconnect code "Local disconnect"
	CALLRET CIDDIS		;Go disconnect

	SUBTTL Connection management -- Subroutines -- REMDIS

;REMDIS - disconnect a connection
;
;Called at many state transitions when remote node disconnects
;
;Will cancel SCA receive buffers and disconnect the connection

REMDIS:	CALL CANBUF		;Cancel outstanding receive buffers
	MOVX T1,CNDSRD		;Load disconnect code "Remote disconnect"
	CALLRET CIDDIS		;Go disconnect

	SUBTTL Connection management -- Subroutines -- CIDDIS

;CIDDIS - disconnect a disconnection
;
;T1/ disconnect reason code

CIDDIS:	STOR T1,PBDRE,(PB)	;Store disconnect reason code in PB
	BLCAL. (<XENT SC.DIS>,<<PBCID,(PB)>,T1>) ;[7.1037]
	JFCL			;Ignore error return
	RET

	SUBTTL Connection management -- Subroutines -- CANBUF

;CANBUF - cancel receive buffers

CANBUF:	BLCAL. (<XENT SC.CRD>,<<PBCID,(PB)>,[NDGBUF]>)	;[7.1037]
	 JFCL			;Ignore error return
	RET

	SUBTTL Connection management -- Subroutines -- SCAUCB

;SCAUCB issues a callback "Unexpected callback function"
SCAUCB:	BUG.(CHK,CINUCB,CIDLL,SOFT,<Unexpected SCA callback>,<<T1,STATE>,<CID,SCACID>,<MB,ROUADR>>,<

Cause:	SCA issued a callback to DECnet/CI that was not expected in the
	current state of the connection.

Data:	STATE - The DECnet/CI connection state
	SCACID - The connect ID for the connection in question
	ROUADR - The address of the SCA callback processing routine
>,RTN)				;Return after bugcheck

	SUBTTL Data transmission -- DNADLL -- Transmit message

;DNAXMT transmits a DECnet message
;
;Call:	CB and PB are set up
;	T3/ MB address
;	CALL DNAXMT
;	 +1 error return, status code in T1
;	+2 success return
;
;Context: Process or scheduler. **Note: one call to DNAXMT may interrupt
;	  another one**
;
;AC usage: CB, PB, MB, MS, T1-T6, P1 may be clobbered

	XRESCD
DNAXMT:	MOVE MB,T3		;Get MB address

;Check that connect state is RUN. However, no problems if this changes until
; actual send time
	CHKSTATE RUN		;Is state RUN?
	RETBAD(CNPWS%)		; -error return "Port in wrong state"

;Allocate a datagram buffer
	MOVX T1,1		;Need one buffer
	CALL <XENT SC.ALD>	;[7.1037]Try to get it
	 RETBAD(CNNRE%)		; -error "resource error"
	MOVE P1,T1		;Save buffer address in P1
	CAIE T2,1		;Make sure we got only one buffer
	BUG.(CHK,CINWNB,CIDLL,SOFT,<Wrong number of buffers>,<<T2,COUNT>>,<

Cause:	CIDLL asked SCAMPI to allocate 1 buffer, but received more than
	one. The extra buffers will now be lost.

Data:	COUNT - The number of buffers SCAMPI allocated and returned
>)

;Copy the MSD chain to the buffer
	XMOVEI T1,.MHUDA(P1)	;Address of user area in SCA buffer
	MOVX T2,<C%BYTD-C%OVHD>	;Size of maximum user buffer in bytes
	CALL DNCMSD		;Go copy....
	IFNSK.			; -error return means DECnet message longer
	  MOVE T1,P1		;  than SCA buffer, return the buffer
	  CALL <XENT SC.RLD>	;[7.1037]  to SCA
	  RETBAD(CNIMS%)	;   and return "illegal message size"
	ENDIF.
;On success return from DNCMSD, T1 has a bp to destination, T2 # of pad
; bytes to apply and T3 length of message (except pad bytes) in bytes
	SKIPN T2		;Any padding needed?
	IFSKP.
	  ADD T3,T2		;Add up length of message
	  MOVE T1,[POINT 8,.MHUDA(P1)] ;Make our own bp indexed by P1
	  TRO T2,200		;Make a ROUTER pad byte with count
	  IDPB T2,T1		;Put it in front
	ENDIF.

;Verify that state is RUN and send the datagram
;
;If port is closed between the CHKSTATE and the SC.SDG doesnt really matter,
; since we either will get an error return from SC.SDG and then deallocate
; the transmit buffer, or well get a message send complete callback.

	CHKSTATE RUN		;Is it still RUN?
	IFSKP.			;Yes, send datagram
	  OPSTRM <ADDM T3,>,PBBYS,(PB) ;Update # of bytes sent
	  OPSTRM <AOS>,PBDGS,(PB) ; and # of datagrams sent
	  BLCAL.(<XENT SC.SDG>,<<PBCID,(PB)>,[F.RTB],T3,P1,[CIDPRI],[0]>) ;[7.1037]
	  IFSKP.		;Transmit succeeded
	    AOS DNASND		;[7211] COUNT THE SEND
	    MOVX T4,CNSUC%	; so load success code
	  ELSE.			;Error on send
	    MOVX T4,CNXMF%	;  and load error code "transmit failed"
	  ENDIF.
	ELSE.
	  MOVX T4,CNPWS%	; -if not RUN, then "port in wrong state"
	ENDIF.

;Between here and when we callback DNADLL the port may be closed by SCA,
; but DECnet can handle that
	CAIE T4,CNSUC%		;Was it success?
	IFSKP.			;-yes, callback DNADLL
	  MOVX T1,DI.ODN	;  Function is "output done"
	  LOAD T2,PBDID,(PB)	;  DNADLL ID
	  MOVE T3,MB		;  Message block in T3
				;  Status is already in T4
	  CALL @DNACBK		;  Call back
	  RETSKP		;   and skip return to indicate success
	ELSE.			;-no, release buffer and give error return
	  MOVE T1,T4		; Get status into T1 for RET
	  EXCH T1,P1		;  Now save error code while getting buffer adr
	  CALL <XENT SC.RLD>	;[7.1037]  Release the SCA buffer
	  MOVE T1,P1		;  Retrieve the error code
	  RET			;   and return +1 to indicate error
	ENDIF.
;Will never get here

	SUBTTL Data transmission -- SCA callback -- "Datagram received"

;SCADGR is called on SCA callbacks "Datagram received"
;
;Call:	CB, PB and CID are set up.
;	T3/ Address of datagram buffer
;	T4/ Flags (! address of routine to return buffer - not used)
;		Flags are: F.SPM set =) high density mode,
;				 clear =) industry compatiblw mode
;		Packet length (including packet header) (in bytes if
;		industry compatible mode) is in offset .MHPKL in the buffer
;	CALL SCADGR
;	+1 return always
;
;Context: SCA interrupt
;
;Ac usage: CB, PB, CID, MB, MS, T6. P1 = SCA buffer adr
;	   T1-T6 temporary

	XRESCD
SCADGR:	SAVEAC <P1,MS>		;P1 contains SCA buffer adr
	AOS DNARCV		;[7211] COUNT THE RECEPTION
	MOVE P1,T3		;Buffer address
	CALL SCADG1		;Call coroutine to do the job
	 CALLRET RDGBUF		; on +1 return, return buffer and return
	CALL RDGBUF		;+2 return: return buffer and ..
	MOVX T1,DI.INC		; give "input complete" callback to DNADLL
	LOAD T2,PBDID,(PB)	; Get DNADLL ID
	MOVE T3,MB		; MB address
	MOVX T4,CNSUC%		; Success
	CALLRET @DNACBK		;Callback and return

;SCADG1 - worker routine for SCADGR
;	T4/ flags
; returns +1 if message was dropped or some other error
;         +2 with message to be passed to higher layer

SCADG1:	STKVAR <BYTCNT>		;# of DECnet bytes in datagram
	CHKSTATE RUN		;Verify that state is 'RUN'
	BUG.(CHK,CINUDR,CIDLL,SOFT,<Unexpected datagram receive>,<<CID,SCACID>>,<

Cause:	CIDLL received a datagram with the connection state not being RUN.

Data:	SCACID - The connect ID
>,RTN)				;Return after bugcheck
	TXNE T4,F.SPM		;Verify that it is industry compatible
	BUG.(CHK,CINNIC,CIDLL,SOFT,<Received illegal packet format>,<<T4,FLAGS>>,<

Cause:	CIDLL received a DECnet datagram, but the packet mode was not
	industry compatible.

Data:	FLAGS - The flags and mode of the packet
>,RTN)				;Return after bugcheck

;Get length of data portion of packet into BYTCNT
	MOVE T1,.MHPKL(P1)	;Total packet length
	SUBI T1,C%OVHD		; and subtract overhead bytes
	MOVEM T1,BYTCNT		;  and store result

;Verify that the message will fit into a DECnet buffer
	CAMG T1,RCVBSZ		;Too big?
	IFSKP.			; -yes, 'data overrun'
	  OPSTRM <AOS>,PBDOR,(PB) ; Update count
	  RET			;  and return
	ENDIF.

;Allocate message block and input buffer
	CALL DNGMSG		; and ask DECnet-36 for MB and buffer
	 JRST SCADRP		;  -couldnt, drop buffer
	MOVE MB,T1		;Message block address
	XMOVEI MS,UD.MSD(MB)	; and load MSD address

;Update counters for received message
	MOVE T1,BYTCNT		;Get # of bytes in message
	OPSTRM <ADDM T1,>,PBBYR,(PB) ;# of bytes received
	OPSTRM <AOS>,PBDGR,(PB)	; and # of datagrams received

;All set, copy message into DECnet buffer
	STOR T1,MDBYT,(MS)	;Store # of bytes in MSD
	MOVEI T1,3(T1)		;Make ..
	LSH T1,-2		; .. # of words to copy
	XMOVEI T2,.MHUDA(P1)	;Source address
	LOAD T3,MDALA,(MS)	; and destination address from MSD
	EXTEND T1,[XBLT]	;Here we go...
	
;See if we should strip off (VMS) padding of -1 bytes..
; Loop over SCA buffer and check how many -1 bytes there are
; T1/ # of -1 bytes, T2/ bp, T3/ scratch
	SETZ T1,		;No bytes to start with
	MOVE T2,[POINT 8,.MHUDA(P1)] ;Make bp
	DO.
	  ILDB T3,T2		;Get next byte
	  CAIE T3,377		;Is it -1?
	  EXIT.			; -no, exit
	  AOJA T1,TOP.		;-yes, count one more and loop to next
	ENDDO.
	CALL DNSKBY		;Skip that many bytes (count in T1)
	 RET			; -ran out of bytes, dont return a message

;Return success indicating there is a message that should go to DNADLL
	RETSKP
	ENDSV.

;SCADRP is called when a received message is dropped. Update the counters
; and return

SCADRP:	OPSTRM <AOS>,PBDDG,(PB)	;Update # of datagrams lost because of DECnet
	RET

;RDGBUF - return datagram buffer to SCA receive queues


RDGBUF:	BLCAL.(<XENT SC.RDG>,<CID,[0],P1>) ;[7.1037]Recycle buffer to free queue
	BUG.(CHK,CINFRB,CIDLL,SOFT,<Failed to recycle buffer>,<<CID,SCACID>,<P1,BUFADR>>,<

Cause:	CIDLL has received a datagram, and failed to return the buffer to
	the SCA receive queue. One less buffer will now be on the port 
	datagram receive queue.

Data:	SCACID - The connect ID
	BUFADR - The address of the buffer that could not be posted
>)
	RET			;Return

	SUBTTL Data transmission -- SCA callback -- "Message/datagram send complete"

;SCAMSC is called on SCA callbacks "Datagram send complete"
;
;Call:	CB, PB and CID are set up
;	T3/ address of buffer
;	T4/ length of buffer
;	CALL SCAMSC
;	+1 always
;
;Context: SCA interrupt
;
;Ac usage: CB, PB, CID, MB, T1-T6

	XRESCD
SCAMSC:	MOVE T1,T3		;Load address of buffer
	CALLRET <XENT SC.RLD>	;[7.1037] and return it and return

	SUBTTL Data transmission -- SCA callback -- "Dropped datagram"

;SCADDG is called on SCA callbacks "Datagram dropped"
;
;Call:	CB, PB and CID are set up
;	CALL SCADDG
;	+1 always
;
;Context: SCA interrupt

	XRESCD
SCADDG:	OPSTRM <AOS>,PBSDG,(PB)	;Update # of datagrams lost beacuse of SCA
	RET

	SUBTTL Network management -- Read parameter

;NTMRED - called to read a network management parameter

;Call:	P1/ address of NF block
;	CALL NTMRED
;	 +1 on error with code in T1
;	+2 on success
;
;Context: Jsys

	XSWAPCD
NTMRED:
	
;Line or circuit?
	LOAD T1,NFEID,(P1)	;Get entity ID
	TMNN LILXC,+T1		;Line or circuit?
	IFSKP.			; -line
	  MOVX T1,<XADDR. LINTAB> ;  then load address to line parameter table
	  MOVEI T2,NRLPAR	;   and length
	ELSE.			; -circuit
	  MOVX T1,<XADDR. CIRTAB> ;  then load address to circuit param table
	  MOVEI T2,NRCPAR	;   and length
	ENDIF.
	MOVX T3,NF.RED		;Load function code
	CALLRET NTPARM		; and call common function to do work

	SUBTTL Network management -- Set parameter

;NTMSET - called to set a network management parameter

;Call:	P1/ address of NF block
;	CALL NTMSET
;	 +1 on error with code in T1
;	+2 on success
;
;Context: Jsys

;CIDLL does not support the setting of any parameters, so it will always
; return NF.OPF ("operation failure").

	XSWAPCD
NTMSET:	RNMXER (NF.OPF)

	SUBTTL Network management -- Clear parameter

;NTMCLR - called to clear a network management parameter

;Call:	P1/ address of NF block
;	CALL NTMCLR
;	 +1 on error with code in T1
;	+2 on success
;
;Context: Jsys

;CIDLL does not support the setting of any parameters, so it will always
; return NF.OPF ("operation failure").

	XSWAPCD
NTMCLR:	RNMXER (NF.OPF)

	SUBTTL Network management -- Show and zero counters

;NTMCOU - called to show counters

;Call:	P1/ address of NF block
;	CALL NTMCOU
;	 +1 on error with code in T1
;	+2 on success
;
;Context: Jsys

;NTMSZC - called to show and zero counters

;Call:	P1/ address of NF block
;	CALL NTMSZC
;	 +1 on error with code in T1
;	+2 on success
;
;Context: Jsys

	XSWAPCD
NTMCOU:	SKIPA T3,[NF.COU]	;Load function code and skip
NTMSZC:	MOVX T3,NF.SZC		;Load function code
	LOAD T1,NFEID,(P1)	;Get entity ID
	TMNE LILXC,+T1		;Is it line?
	RNMXER (NF.NDP)		; -yes, return "no data present"

;Call NTCTRS to do the real work
	MOVX T1,<XADDR. COUTAB>	;Address of counter table
	MOVEI T2,NRCOUN		;Length of counter table
	CALLRET NTCTRS		;Read the counters and return

	XRESCD



	TNXEND
	END
                                                                                                                                                                                                                                                                                                                                                                                                                                