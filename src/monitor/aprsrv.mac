; UPD ID= 8477, RIP:<7.MONITOR>APRSRV.MAC.8,   9-Feb-88 11:48:37 by GSCOTT
;TCO 7.1218 - Update copyright notice.
; UPD ID= 8405, RIP:<7.MONITOR>APRSRV.MAC.7,   4-Feb-88 10:20:51 by GSCOTT
;TCO 7.1210 - Set BUGs to be not normally dumpable.
; UPD ID= 319, RIP:<7.MONITOR>APRSRV.MAC.6,  10-Dec-87 14:40:05 by GSCOTT
;TCO 7.1158 - Insure proper BUGHLT name stored in BUGNAM.
; UPD ID= 202, RIP:<7.MONITOR>APRSRV.MAC.4,  23-Oct-87 15:16:46 by GSCOTT
;TCO 7.1081 - Call DODOB from BUGFIN, check DB%DIP, save BUG name for SETSPD.
; UPD ID= 3, RIP:<7.MONITOR>APRSRV.MAC.3,  28-May-87 16:06:02 by RASPUZZI
;TCO 7.1002 - Implement PMOVE/M instructions.
; *** Edit 7463 to APRSRV.MAC by RASPUZZI on 28-Apr-87, for SPR #20634
; Catch ILLUUOs before they happen on a non-existant RH20 channel. Instead,
; let's crash with a RH2NXC.
; *** Edit 7447 to APRSRV.MAC by RASPUZZI on 14-Apr-87, for SPR #20703
; Make sure that we queue up a SYSERR block when an APR interrupt happens
; during a page fault. All we need to do is switch to the APR stack (MEMPP)
; when the interrupt hits.
; *** Edit 7376 to APRSRV.MAC by RASPUZZI on 6-Oct-86
; Fix silliness in edit 7363. Use a TXNE not a TXNN when checking for PMOV. 
; *** Edit 7363 to APRSRV.MAC by RASPUZZI on 12-Sep-86
; If the PMOVE/PMOVEM instructions are available, then use them instead of
; routines MOVRCA and STORCA for more efficiency.
; *** Edit 7357 to APRSRV.MAC by RASPUZZI on 22-Aug-86
; Remove routine GAPRID since the processor serial number is already in APRSER
; and make all CALLs to GAPRID refer to that resident location. 
; *** Edit 7240 to APRSRV.MAC by MCCOLLUM on 10-Feb-86
; Change BUGSTO to convert the local job index to a global job number. 
; *** Edit 7224 to APRSRV.MAC by MCCOLLUM on 8-Jan-86
; Remove edit 7222. It caused SKDPF1's. 
; *** Edit 7222 to APRSRV.MAC by MCCOLLUM on 3-Jan-86
; Use global job number in BUGCHKs and BUGINFs instead of local index 
; Edit 7134 to APRSRV.MAC by GRANT on 15-Aug-85 (TCO 6-1-1522)
; Turn off the NI at BUGHLT and PAR>SHUT time 
; UPD ID= 2311, SNARK:<6.1.MONITOR>APRSRV.MAC.204,  12-Aug-85 15:23:19 by MOSER
;TCO 6.1.1487 - FIX BUGHLT SAVING OF ACS FROM BUGHLT IN XCDSEC
; UPD ID= 2304, SNARK:<6.1.MONITOR>APRSRV.MAC.203,  19-Jul-85 16:42:00 by MOSER
;TCO 6.1.1492 - MORE JFNS NO SZCOD
; UPD ID= 2206, SNARK:<6.1.MONITOR>APRSRV.MAC.202,   6-Jun-85 21:06:28 by MOSER
;TCO 6.1.1436 - BUGHLT CODE SHOULDN'T PAGE FAULT!!!
; UPD ID= 2047, SNARK:<6.1.MONITOR>APRSRV.MAC.201,   3-Jun-85 14:13:32 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 2034, SNARK:<6.1.MONITOR>APRSRV.MAC.200,  30-May-85 13:42:51 by GROSSMAN
;TCO 6.1.1417 - Fix generation of SYSERR blocks for BUGHLTs from XCDSEC.
; UPD ID= 1891, SNARK:<6.1.MONITOR>APRSRV.MAC.199,   4-May-85 15:28:40 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1865, SNARK:<6.1.MONITOR>APRSRV.MAC.198,   4-May-85 10:31:55 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1808, SNARK:<6.1.MONITOR>APRSRV.MAC.197,  24-Apr-85 14:01:47 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1784, SNARK:<6.1.MONITOR>APRSRV.MAC.196,  23-Apr-85 12:40:03 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1721, SNARK:<6.1.MONITOR>APRSRV.MAC.195,   8-Apr-85 10:11:40 by MCCOLLUM
;TCO 6.1.1238 - Fix BUG. documentation
; UPD ID= 1692, SNARK:<6.1.MONITOR>APRSRV.MAC.194,  28-Mar-85 10:46:32 by GROSSMAN
;TCO 6.1.1293 - Save PI state better for BUGHLT's.
; UPD ID= 1658, SNARK:<6.1.MONITOR>APRSRV.MAC.193,  20-Mar-85 14:51:50 by LOMARTIRE
;TCO 6.1.1279 - Rework previous edit
; UPD ID= 1403, SNARK:<6.1.MONITOR>APRSRV.MAC.192,  24-Jan-85 16:45:41 by LOMARTIRE
;TCO 6.1.1127 - Prevent ILLUUO from bad byte pointer to GTJFN
; UPD ID= 1070, SNARK:<6.1.MONITOR>APRSRV.MAC.191,  14-Nov-84 00:13:50 by GROSSMAN
;TCO 6.1.1051 - Redo $EAENT using XJRST.
; UPD ID= 1027, SNARK:<6.1.MONITOR>APRSRV.MAC.190,  12-Nov-84 14:17:09 by GLINDELL
;TCO 6.1.1021 - fix BUGINF to work in section XCDSEC
; UPD ID= 994, SNARK:<6.1.MONITOR>APRSRV.MAC.189,   7-Nov-84 13:46:55 by MOSER
;MORE TCO 6.2262 - FIX KA KLOAT POINT INSTRS NOT TO ILLUUO
; UPD ID= 943, SNARK:<6.1.MONITOR>APRSRV.MAC.188,   4-Nov-84 15:23:01 by GLINDELL
;More TCO 6.1.1021 - make PAGRST do CONI/CONO PAG.
; UPD ID= 5021, SNARK:<6.MONITOR>APRSRV.MAC.187,  26-Oct-84 22:56:19 by MOSER
;TCO 6.2263 - REMOVE KIMXCT MAKE THIS STUFF FINALLY WORK RIGHT
; FIX USER MODE ILLEGAL BYTE POINTERS TO GIVE ILINS1 AGAIN
; UPD ID= 4989, SNARK:<6.MONITOR>APRSRV.MAC.186,  24-Oct-84 16:21:55 by LOMARTIRE
;TCO 6.2252 - Fix power fail and spurious power fail restarting
; UPD ID= 4911, SNARK:<6.MONITOR>APRSRV.MAC.185,  10-Oct-84 16:57:11 by GLINDELL
;TCO 6.1.1021 - 6.1 address space
;	1. BUGHLT does not transfer into section 0 any more
;	2. BUG code will handle 30-bit addresses when referencing bug blocks
; UPD ID= 4674, SNARK:<6.MONITOR>APRSRV.MAC.184,  10-Aug-84 17:16:36 by GROSSMAN
;TCO 6.2169 - Split PIINIT into two parts.  One part (PVINIT) just sets up the
;interrupt vectors.  The other part (PSINIT) just turns the PI system on.
; UPD ID= 4638, SNARK:<6.MONITOR>APRSRV.MAC.183,  31-Jul-84 14:26:40 by PURRETTA
;Update copyright notice
; UPD ID= 4611, SNARK:<6.MONITOR>APRSRV.MAC.182,  27-Jul-84 14:52:31 by TBOYLE
;New SYSERR - At BUGST0, call ALCSBX, and use EXTEND BLT
; UPD ID= 4583, SNARK:<6.MONITOR>APRSRV.MAC.181,  24-Jul-84 20:33:06 by GRANT
;Stop the CI-20 when we BUGHLT
; UPD ID= 4567, SNARK:<6.MONITOR>APRSRV.MAC.179,  19-Jul-84 10:11:53 by SHTIL
; Remove previous edit because of illegal use of cx
; UPD ID= 4551, SNARK:<6.MONITOR>APRSRV.MAC.178,  18-Jul-84 08:36:29 by SHTIL
;TCO 6.2122  MTIME:store time in smallest units in CX
; UPD ID= 4120, SNARK:<6.MONITOR>APRSRV.MAC.175,  24-Apr-84 18:09:37 by TBOYLE
;More TCO 6.2045 Increment BUGLST if more than BUGMAX in the queue.
; UPD ID= 4076, SNARK:<6.MONITOR>APRSRV.MAC.174,  11-Apr-84 22:19:50 by TBOYLE
;TCO 6.2027 AOS BUGLST down at BUGST0 on fail of ALCSEB.
; UPD ID= 4073, SNARK:<6.MONITOR>APRSRV.MAC.173,  11-Apr-84 19:31:01 by MOSER
;TCO 6.6026 - FIX KIMXCT - FIRST PASS
; UPD ID= 4050, SNARK:<6.MONITOR>APRSRV.MAC.172,   5-Apr-84 08:35:50 by PAETZOLD
;TCO 6.2022 - Remove MSTKOV as we now have global stack pointers.
; UPD ID= 4030, SNARK:<6.MONITOR>APRSRV.MAC.171,  31-Mar-84 20:42:21 by GRANT
;Remove references to FTKLIPA and FTCI
; UPD ID= 3793, SNARK:<6.MONITOR>APRSRV.MAC.170,  29-Feb-84 01:40:36 by TGRADY
; Implement Global Job Numbers
; - In BUGH5, Print Global Job number, not local Job index (JOBNO)
; UPD ID= 3630, SNARK:<6.MONITOR>APRSRV.MAC.169,   1-Feb-84 22:07:11 by MURPHY
;Ever more 6.1525 - Move DDTs and bugstrings to SYMSEC.
; UPD ID= 3589, SNARK:<6.MONITOR>APRSRV.MAC.168,  30-Jan-84 09:19:49 by HAUDEL
;More TCO 6.1798 - Keep me change. Change STKEEP.
; UPD ID= 3509, SNARK:<6.MONITOR>APRSRV.MAC.167,  23-Jan-84 09:38:35 by PRATT
;TCO 6.1924 - WTO routines need the display type value for QUEUE%
; UPD ID= 3487, SNARK:<6.MONITOR>APRSRV.MAC.166,  20-Jan-84 09:08:52 by HAUDEL
;More TCO 6.1798 - Fix AC reference in keep me change.
; UPD ID= 3468, SNARK:<6.MONITOR>APRSRV.MAC.165,  16-Jan-84 14:11:22 by HAUDEL
;More TCO 6.1798 - Keep me change, remove PGCLKP bit from KIPGW0.
; UPD ID= 3448, SNARK:<6.MONITOR>APRSRV.MAC.164,  12-Jan-84 14:22:04 by PAETZOLD
;TCO 6.1929 - Change FKJOBN to FKJBN
; UPD ID= 3316, SNARK:<6.MONITOR>APRSRV.MAC.163,  14-Dec-83 14:35:00 by MURPHY
;TCO 6.1909 - Fix ACSAV and SAVEPQ routines to work with global stack pointer.
; UPD ID= 3285, SNARK:<6.MONITOR>APRSRV.MAC.162,  10-Dec-83 15:53:20 by PAETZOLD
;TCO 6.1900 - Handle PI0 unvectored interrupts.
; UPD ID= 3273, SNARK:<6.MONITOR>APRSRV.MAC.161,   7-Dec-83 11:41:55 by MOSER
;TCO 6.1889 MORE FIXES FOR ARITHMETIC TRAPPING
;TCO 6.1877 FIX ARITHMETIC TRAPPING
; UPD ID= 3269, SNARK:<6.MONITOR>APRSRV.MAC.160,   6-Dec-83 21:21:39 by MCLEAN
;SWITCH AC BLOCKS INSTEAD OF SAVING ACS
; UPD ID= 3261, SNARK:<6.MONITOR>APRSRV.MAC.159,   6-Dec-83 14:30:52 by MCLEAN
;TCO 6.1892  SAVE AND RESTORE AC'S FOR PIAPR INTERRUPTS
; UPD ID= 3162, SNARK:<6.MONITOR>APRSRV.MAC.158,  16-Nov-83 14:15:50 by PAETZOLD
;TCO 6.1867 - Add SAVP1
; UPD ID= 3066, SNARK:<6.MONITOR>APRSRV.MAC.157,  25-Oct-83 08:21:54 by MILLER
;Remove previous edit
; UPD ID= 3064, SNARK:<6.MONITOR>APRSRV.MAC.156,  24-Oct-83 15:42:52 by MILLER
;Try turning off the KLIPA when we BUGHLT
; UPD ID= 3058, SNARK:<6.MONITOR>APRSRV.MAC.155,  22-Oct-83 09:27:11 by MILLER
;TCO 6.1832. Improve CLRALL routine
; UPD ID= 3055, SNARK:<6.MONITOR>APRSRV.MAC.154,  21-Oct-83 19:30:29 by MURPHY
;Get rid of some PUSH's.
; UPD ID= 3038, SNARK:<6.MONITOR>APRSRV.MAC.153,  17-Oct-83 14:16:30 by MILLER
;TCO 6.1832. Retry page table parity errors
; UPD ID= 3034, SNARK:<6.MONITOR>APRSRV.MAC.152,  12-Oct-83 12:11:59 by MCINTEE
;More TCO 6.1764 - Save AC3 in PFSA1 area
; UPD ID= 2903, SNARK:<6.MONITOR>APRSRV.MAC.151,  19-Sep-83 11:25:21 by MURPHY
;Make IORST turn off paging like it says it does.
; UPD ID= 2894, SNARK:<6.MONITOR>APRSRV.MAC.150,  13-Sep-83 13:38:12 by HALL
;Typo in previous edit - lost an angle bracket
; UPD ID= 2892, SNARK:<6.MONITOR>APRSRV.MAC.149,  12-Sep-83 15:47:02 by HALL
;TCO 6.1798 - Provide support (possibly temporary) for "keep me" bit in
;		hardware page table
;	Change SMAPOK macro to check "hard error" rather than "paged
;		reference"
;	Add PGCLKP bit to KIPGW0 (clear all entries on first DATAO PAG)
;	Move remaining page fail bit definitions to PROLOG
;	Add STKEEP and TESTKP routines
; UPD ID= 2858, SNARK:<6.MONITOR>APRSRV.MAC.148,  23-Aug-83 11:28:21 by LOMARTIRE
;TCO 6.1769 - Allow system to continue after a power fail
; UPD ID= 2857, SNARK:<6.MONITOR>APRSRV.MAC.147,  23-Aug-83 11:19:35 by LOMARTIRE
;TCO 6.1768 - Allow system to continue after spurious power fail
; UPD ID= 2845, SNARK:<6.MONITOR>APRSRV.MAC.146,  17-Aug-83 22:23:12 by MURPHY
;More 6.1525 - Map split.  Make a few things here stay in section 0.
; UPD ID= 2814, SNARK:<6.MONITOR>APRSRV.MAC.145,   9-Aug-83 11:53:18 by MCINTEE
;TCO 6.1764 - In SKDPF1 bughlt, move data into ACs, and display it.
; UPD ID= 2624, SNARK:<6.MONITOR>APRSRV.MAC.144,  22-Jun-83 11:25:52 by HALL
;TCO 1689 - Move fork tables to extended section
;	Reference fork tables via DEFSTR
; UPD ID= 2619, SNARK:<6.MONITOR>APRSRV.MAC.143,  21-Jun-83 15:32:55 by MURPHY
;Move PGRCST to PAGUTL.
; UPD ID= 2490, SNARK:<6.MONITOR>APRSRV.MAC.142,  18-May-83 15:02:08 by MURPHY
;TCO 6.1525 - Add routine MAPIPG, like SETSPG except uses PIPG.
; UPD ID= 2424, SNARK:<6.MONITOR>APRSRV.MAC.141,   5-May-83 17:22:37 by MURPHY
;More of previous - fix difficulties with external/internal refs.
; UPD ID= 2404, SNARK:<6.MONITOR>APRSRV.MAC.140,   3-May-83 15:56:23 by COBB
;TCO 6.1639 - ?s and %s after PRINTX messages
; UPD ID= 2373, SNARK:<6.MONITOR>APRSRV.MAC.139,  29-Apr-83 14:23:26 by MURPHY
;TCO 6.1635 - define MONENV as standard flag word value for monitor context.
; UPD ID= 2144, SNARK:<6.MONITOR>APRSRV.MAC.138,   4-Apr-83 09:54:41 by MILLER
;TCO 6.1588. Add CPPCON for CFSSRV to use.
; UPD ID= 2125, SNARK:<6.MONITOR>APRSRV.MAC.137,   1-Apr-83 11:51:20 by MILLER
;TCO 6.1585. Fix trap handling for user-defined trap block
; UPD ID= 2000, SNARK:<6.MONITOR>APRSRV.MAC.136,  15-Mar-83 19:18:53 by HALL
;TCO 6.1502 - Allow resident free space in extended sections
;	Make secondary protocol DTE stuff run in section 1 because it calls
;	TTYSRV.
; UPD ID= 1983, SNARK:<6.MONITOR>APRSRV.MAC.135,  12-Mar-83 17:39:22 by MILLER
;More TCO 6.1540
; UPD ID= 1977, SNARK:<6.MONITOR>APRSRV.MAC.134,  11-Mar-83 12:50:04 by MILLER
;TCO 6.1540. Fix BLCAL support routines
; UPD ID= 1930, SNARK:<6.MONITOR>APRSRV.MAC.133,   7-Mar-83 21:06:22 by CDUNN
;Change default to include KLIPA support code
; UPD ID= 1902, SNARK:<6.MONITOR>APRSRV.MAC.131,   1-Mar-83 23:43:20 by MURPHY
;Try again on making KA FPT simulation work after previous edit.
; UPD ID= 1889, SNARK:<6.MONITOR>APRSRV.MAC.130,   1-Mar-83 10:38:18 by HALL
;TCO 6.1502 - Allow free space outside of section 0
;	At least temporarily, make all callers request section 0
; UPD ID= 1879, SNARK:<6.MONITOR>APRSRV.MAC.129,  27-Feb-83 22:04:01 by MURPHY
;TCO 6.1525 - Support code for TSTMS0.
;Make KA10 floating point instructions in monitor do ILUUO bughlt.
;Resolve conflicting edit with 6.1527.
; UPD ID= 1876, SNARK:<6.MONITOR>APRSRV.MAC.128,  25-Feb-83 01:15:02 by PAETZOLD
;TCO 6.1527 - Artificially increment and decrement the stack pointer before and
; after calling KIMXCT in the ILLUUO code.
; UPD ID= 1835, SNARK:<6.MONITOR>APRSRV.MAC.127,  20-Feb-83 20:18:35 by MURPHY
;More 6.1470 - Make BUGCHK and BUGINF not clobber CX, no continue handling here.
; UPD ID= 1813, SNARK:<6.MONITOR>APRSRV.MAC.126,  16-Feb-83 14:51:24 by HALL
;Clarify comments on trap-setting routines
; UPD ID= 1679, SNARK:<6.MONITOR>APRSRV.MAC.125,  19-Jan-83 12:53:22 by MCINTEE
;TCO 6.1470 - Fix continuation feature for BUGs
; UPD ID= 1611, SNARK:<6.MONITOR>APRSRV.MAC.124,   3-Jan-83 15:19:43 by MCINTEE
;Add RTN
; UPD ID= 1585, SNARK:<6.MONITOR>APRSRV.MAC.123,  27-Dec-82 20:15:33 by NICHOLS
;Turns out some callers depend on being able to call XBLTA with garbage
;in the left half of the length word!  Restore HRRZS T1 to BLT routines.
;Add XBLTAT as an alternate entry for XBLTA which tests LH of T1
; UPD ID= 1582, SNARK:<6.MONITOR>APRSRV.MAC.122,  27-Dec-82 16:45:25 by NICHOLS
;BUGHLT if XBLT. is asked to BLT more than a section.
; UPD ID= 1559, SNARK:<6.MONITOR>APRSRV.MAC.121,  21-Dec-82 15:37:04 by MOSER
;TCO 6.1391 Yet again - Do it better
; UPD ID= 1502, SNARK:<6.MONITOR>APRSRV.MAC.120,   1-Dec-82 14:30:11 by HALL
;TCO 6.1000 - Support the 2080
;	Fix BUGSTO to check the correct AC after MAP instruction
; UPD ID= 1480, SNARK:<6.MONITOR>APRSRV.MAC.119,  29-Nov-82 09:30:16 by GRANT
;TCO 6.1010 - Rewrite PGRCST and eliminate PGRCSX, add a few EA.ENTs
; UPD ID= 1476, SNARK:<6.MONITOR>APRSRV.MAC.118,  28-Nov-82 16:36:23 by PAETZOLD
;Delete very old edit history
; UPD ID= 1475, SNARK:<6.MONITOR>APRSRV.MAC.117,  24-Nov-82 11:31:14 by PAETZOLD
;TCO 6.1391 - Go NOSKED in GFLT0 for a little bit
; UPD ID= 1458, SNARK:<6.MONITOR>APRSRV.MAC.116,  18-Nov-82 11:38:27 by PAETZOLD
;TCO 6.1385 - refetch information in GFLT0 after the MCENTR
; UPD ID= 1425, SNARK:<6.MONITOR>APRSRV.MAC.115,   8-Nov-82 10:54:58 by MILLER
;CHKCFS again. Account for bug in MAP instruction
; UPD ID= 1422, SNARK:<6.MONITOR>APRSRV.MAC.114,   7-Nov-82 14:49:22 by MILLER
;TCO 6.1094. Add CHKCFS to check for CFS-required UCODE
; UPD ID= 1387, SNARK:<6.MONITOR>APRSRV.MAC.113,  27-Oct-82 23:27:32 by CDUNN
;More TCO 6.1127 - Make CI emulator clock level code faster
; UPD ID= 1367, SNARK:<6.MONITOR>APRSRV.MAC.112,  22-Oct-82 03:54:35 by CDUNN
;More TCO 6.1127 - Change clock code (under FTCI feature test) to make memory
;lights show total emulated CFS traffic.
; UPD ID= 1358, SNARK:<6.MONITOR>APRSRV.MAC.111,  20-Oct-82 00:59:51 by CDUNN
;More TCO 6.1127 - Make CI emulator keep alive happen at clock level instead
;of sceduler lever (Under FTCI feature test)...
; UPD ID= 1287, SNARK:<6.MONITOR>APRSRV.MAC.110,   6-Oct-82 13:43:42 by MILLER
;Set CSWRB in all instances of "temporary" mapping (TCO 6.1094)
; UPD ID= 1279, SNARK:<6.MONITOR>APRSRV.MAC.109,   4-Oct-82 22:51:51 by LEACHE
;TCO 6.1299 - Change KIMXCT
; UPD ID= 1262, SNARK:<6.MONITOR>APRSRV.MAC.108,   1-Oct-82 08:43:50 by NEUSTAEDTER
;TCO 6.1294 - Add recovery address to BUG.
; UPD ID= 1210, SNARK:<6.MONITOR>APRSRV.MAC.107,  21-Sep-82 17:09:46 by HALL
;TCO 6.1000 - Support the 2080
;	Make STEXBK global
;Remove change to SWPZPG (temporarily).
; UPD ID= 1188, SNARK:<6.MONITOR>APRSRV.MAC.105,  15-Sep-82 19:12:26 by MILLER
;SWPZPG must preserve initial value of CST0X (for the CST write bit)
; UPD ID= 1132, SNARK:<6.MONITOR>APRSRV.MAC.104,   1-Sep-82 22:53:56 by MILLER
;tco 6.1094. Fix SETSPG for CFS support
; UPD ID= 1113, SNARK:<6.MONITOR>APRSRV.MAC.103,  25-Aug-82 12:26:47 by LEACHE
;TCO 6.1237 - Increase size of BUGSPL
; UPD ID= 1070, SNARK:<6.MONITOR>APRSRV.MAC.102,  10-Aug-82 10:00:19 by HALL
;TCO 6.1000 - Support the 2080
;	Fix bit name for user mode address break in STEXBK
; UPD ID= 1021, SNARK:<6.MONITOR>APRSRV.MAC.101,   1-Aug-82 09:14:12 by HALL
;TCO 6.1000 - Support the 2080
;	Make MONACB and USRACB be global for BOOT
; UPD ID= 1011, SNARK:<6.MONITOR>APRSRV.MAC.100,  28-Jul-82 18:51:24 by PAETZOLD
;More TCO 6.1010 - Fix typo in PGRCSX
; UPD ID= 962, SNARK:<6.MONITOR>APRSRV.MAC.99,  28-Jun-82 13:57:52 by PAETZOLD
;TCO 6.1180 - Move the MCENTR in the gfloat code to avoid ucode/hardware problems
; UPD ID= 956, SNARK:<6.MONITOR>APRSRV.MAC.98,  23-Jun-82 16:48:36 by HALL
;Some comments in EAENT and S0ENT
; UPD ID= 952, SNARK:<6.MONITOR>APRSRV.MAC.97,  18-Jun-82 13:51:46 by MURPHY
;TCO 6.1147 - Move bugdefs from BUGS.MAC to here and put them in-line.
; UPD ID= 944, SNARK:<6.MONITOR>APRSRV.MAC.96,  17-Jun-82 10:40:41 by CDUNN
;Remove CISRV support code in BUGxxx code.
; UPD ID= 934, SNARK:<6.MONITOR>APRSRV.MAC.95,  15-Jun-82 05:04:45 by CDUNN
;Make STEXBK global such that the referance from STG works
; UPD ID= 931, SNARK:<6.MONITOR>APRSRV.MAC.94,  14-Jun-82 17:11:22 by HALL
;TCO 6.1000 - Support the 2080
;	Add KC support for address break (KISLOD, SETBRK)
;	Add CLRBRK routine
;TCO 6.1156 - Add NOSKED to STEXBK
; UPD ID= 917, SNARK:<6.MONITOR>APRSRV.MAC.93,  10-Jun-82 08:57:53 by WALLACE
;TCO 6.1162 - Add labels .XSTKS and .XTRST since STKVAR and TRVAR
;  use them.  Leave .STKST and .TRSET intact for symbols in DDT.
; UPD ID= 886, SNARK:<6.MONITOR>APRSRV.MAC.92,   9-Jun-82 16:33:30 by WALLACE
;TCO 6.1162 - Modify the support routines .STKST and .TRSET to properly
;  use ADJSP in conjunction with the new count format, EXP n, which follows
;  the JSP's of STKVAR and TRVAR.  Also see MACSYM and TCO 6.1161.
; UPD ID= 864, SNARK:<6.MONITOR>APRSRV.MAC.91,   7-Jun-82 10:44:21 by HALL
;TCO 6.1156 - ALlow exec mode address break
;	KISSAV - Don't clear user break if exec break is set
;	KISLOD - Don't set user break if exec break is set
;	Add STEXBK and CLEXBK to set and clear exec mode break
; UPD ID= 813, SNARK:<6.MONITOR>APRSRV.MAC.90,   2-Jun-82 16:41:45 by HALL
;TCO 6.1151 - Make TRVAR get a trap on overflow by subtracting the offending
; value before doing the ADJSP.
; UPD ID= 806, SNARK:<6.MONITOR>APRSRV.MAC.89,   1-Jun-82 11:50:40 by PAETZOLD
;TCO 6.1010 - Temporarily add PGRCSX
; UPD ID= 797, SNARK:<6.MONITOR>APRSRV.MAC.88,  27-May-82 20:59:13 by MILLER
;TCO 6.1142. Send parity error messages to OPR
; UPD ID= 794, SNARK:<6.MONITOR>APRSRV.MAC.87,  27-May-82 07:43:24 by HALL
;TCO 6.1000 - Support the 2080
;	Make CASHF always contain zero. We don't control the cache on the 2080
; UPD ID= 781, SNARK:<6.MONITOR>APRSRV.MAC.86,  24-May-82 14:43:02 by HALL
;TCO 6.1000 - Support the 2080
;	Don't assemble KIMXCT for the 2080
; UPD ID= 775, SNARK:<6.MONITOR>APRSRV.MAC.85,  20-May-82 16:30:37 by HALL
;TCO 6.1000 - Support the 2080
;	Change KISSAV and KISLOD to use macros for previous context AC
;		load/store
;	Change BUGHLT code to use STPAC
; UPD ID= 767, SNARK:<6.MONITOR>APRSRV.MAC.84,  19-May-82 14:39:55 by CDUNN
;TCO 6.1127 - Add code to BUGHLT mechanism to clear the keep alive counter
;for CISRV. This makes coming up alot easier, and possible. All code
;is under IFN FTCI
; UPD ID= 765, SNARK:<6.MONITOR>APRSRV.MAC.83,  19-May-82 14:07:23 by HALL
;TCO 6.1000 - Support the 2080
;	Provide CAB field in new flags word of LUUBLK
;	Move RLODPC here from STG, and put under processor conditional
; UPD ID= 758, SNARK:<6.MONITOR>APRSRV.MAC.82,  15-May-82 14:25:08 by HALL
;TCO 6.1000 - Fix KC's WRAPR data
; UPD ID= 747, SNARK:<6.MONITOR>APRSRV.MAC.81,  14-May-82 16:29:42 by HALL
;TCO 6.1000 - Support the 2080
;	Fix initialization of APR stuff to assign interrupt channel
; UPD ID= 741, SNARK:<6.MONITOR>APRSRV.MAC.80,  13-May-82 11:36:08 by HALL
;TCO 6.1000 - Support the 2080
;	Fix definitions for initializing IO page
; UPD ID= 738, SNARK:<6.MONITOR>APRSRV.MAC.79,  12-May-82 12:53:14 by HALL
;TCO 6.1000 - Support the 2080
;	PAGRST - fix size of copy of prototype UPT; include CST write bit
;		in mask word for KC and KL
;	Fix definitions of trap words
; UPD ID= 701, SNARK:<6.MONITOR>APRSRV.MAC.78,   8-May-82 14:10:05 by HALL
;TCO 6.1000 - Support the 2080
;	Define USRCTX for describing the user mode flags
; UPD ID= 698, SNARK:<6.MONITOR>APRSRV.MAC.77,   6-May-82 15:10:57 by HALL
;TCO 6.1000 - Support the 2080
;	Move definition of flags word fields to PROLOG
;	Add USRFLG
;	Fix typo in definition of MONFLG
;	For the KC, use LDPAC and STPAC for previous context AC's
; UPD ID= 631, SNARK:<6.MONITOR>APRSRV.MAC.76,  12-Apr-82 15:14:24 by HALL
;TCO 6.1000 - Support the 2080
;	Define CLNXMF to be a no-op
; UPD ID= 627, SNARK:<6.MONITOR>APRSRV.MAC.75,  12-Apr-82 09:33:28 by HALL
;TCO 6.1000 - Support the 2080
;	Fix UPT references in BUGHLT code
;	Remove level 5 interrupt code here. Make it go to STG.
; UPD ID= 620, SNARK:<6.MONITOR>APRSRV.MAC.74,   9-Apr-82 14:41:15 by HALL
;Fix typo in definition of PIAPRX for KC
; UPD ID= 619, SNARK:<6.MONITOR>APRSRV.MAC.73,   9-Apr-82 12:08:25 by HALL
;TCO 6.1000 - Fix references to page fail data (names were changed)
; UPD ID= 613, SNARK:<6.MONITOR>APRSRV.MAC.72,   8-Apr-82 16:06:23 by HALL
;TCO 6.1000 - Support the 2080
;	Provide KC-specific analysis of MAP instruction format
; UPD ID= 610, SNARK:<6.MONITOR>APRSRV.MAC.71,   8-Apr-82 10:05:09 by PAETZOLD
;Add a comment for TARL to GFLOAT stuff indicating that code is common with TOPS10
; UPD ID= 608, SNARK:<6.MONITOR>APRSRV.MAC.70,   7-Apr-82 16:59:57 by PAETZOLD
;TCO 5.1773 - Add IFIWs to GFLTD
; UPD ID= 600, SNARK:<6.MONITOR>APRSRV.MAC.69,   5-Apr-82 16:43:06 by MILLER
;TCO 6.1066. Add code KC code for BUGMON and BUGPRI
; UPD ID= 599, SNARK:<6.MONITOR>APRSRV.MAC.68,   5-Apr-82 16:38:14 by HALL
;TCO 6.1000 - Support the 2080
;	Fix CONOAPR for KC to set "load PIA" bit
;	Change software interrupt vectors to generate error on all but
;	  channels 6 and 7
;	PIINIT - fix APR vector
;	Don't set cache bits in WREBR. Do disable traps and enable them later.
;	IORST - turn off traps. Don't save state of cache. Clear console
;	  interrupt condition.
;	Fix references to MONFLG to use MOVX
;	Change names of some paging bits
;	Make PIAPR complain if there's no reason for the interrupt.
;	Make CASHOF and CASHON do nothing.
;	Make UPT words point to section 1 for UUO's
;	Don't call KIMXCT for the KC
;	Remove DATAO PAG from PGRON.
;	PAGRST - turn on traps.
;	Change KL-specific page fault handling to use KL-specific UPT
;	  locations for data: PFCD23, PGNXM0, PFNXM, PFCDPE, PFCD27
; UPD ID= 571, SNARK:<6.MONITOR>APRSRV.MAC.67,   1-Apr-82 20:17:05 by MILLER
;TCO 6.1066 SOME MORE. SETUP AND USE LOCAL STACK IN APR INT.
; UPD ID= 567, SNARK:<6.MONITOR>APRSRV.MAC.66,  31-Mar-82 16:10:30 by MURPHY
;TCO 6.1074 - Revise build procedures, eliminate KLPRE, etc.
; UPD ID= 538, SNARK:<6.MONITOR>APRSRV.MAC.64,  19-Mar-82 16:40:07 by PAETZOLD
;TCO 5.1764 - Make PFCODT a full word table and make PFAID not reference
; bad sections.
; UPD ID= 528, SNARK:<6.MONITOR>APRSRV.MAC.63,  18-Mar-82 07:38:57 by HALL
;TCO 6.1072 - Make SETPFH be global
; UPD ID= 526, SNARK:<6.MONITOR>APRSRV.MAC.62,  18-Mar-82 07:36:30 by MILLER
;TCO 6.1066 SOME MORE
; UPD ID= 523, SNARK:<6.MONITOR>APRSRV.MAC.61,  17-Mar-82 15:45:44 by HALL
;TCO 6.1072 - Make PGRINI use special page fault handler
;	Add SETPFH routine
; UPD ID= 477, SNARK:<6.MONITOR>APRSRV.MAC.60,  13-Mar-82 15:08:56 by HALL
;TCO 6.1000 - Support the 2080
;	Make KIPFS global
; UPD ID= 454, SNARK:<6.MONITOR>APRSRV.MAC.59,  11-Mar-82 08:25:09 by MILLER
;TCO 6.1066. First set of changes for KCRSP support.
; UPD ID= 448, SNARK:<6.MONITOR>APRSRV.MAC.58,   7-Mar-82 18:54:06 by MILLER
;tco 5.1487 AGAIN. FIX MBERRB
; UPD ID= 431, SNARK:<6.MONITOR>APRSRV.MAC.57,   2-Mar-82 17:38:56 by MILLER
;MORE TCO.5.1735. Fix up analysis to use IOP word correctly
; UPD ID= 422, SNARK:<6.MONITOR>APRSRV.MAC.56,  24-Feb-82 12:19:41 by PAETZOLD
;TCO 5.1735 - Change IO Page Fail code to reflect fact that IOP word
; now gets saved in ACB7 AC2 and not the PFW
; UPD ID= 421, SNARK:<6.MONITOR>APRSRV.MAC.55,  24-Feb-82 11:07:28 by MILLER
;TCO 6.1064. Prevent page faults out of the BUGHLT code
; UPD ID= 416, SNARK:<6.MONITOR>APRSRV.MAC.54,  21-Feb-82 14:34:19 by HALL
;Fix typo in previous edit
; UPD ID= 415, SNARK:<6.MONITOR>APRSRV.MAC.53,  21-Feb-82 14:09:29 by HALL
;TCO 6.1000- Support the 2080
;Clean up problems with linking monitor.
;	Make SETAOV, SETPOV, and APRRPT global
;	Remove MEMPA and WREQ from KL conditional
;	Define CLRMPE as JFCL for PAGEM
;	Make BUGM0 and BUGP0 return quietly
; UPD ID= 393, SNARK:<6.MONITOR>APRSRV.MAC.52,  11-Feb-82 10:54:14 by HALL
;Fix previous edit for TCO 6.1000 -  Bad reference to bits in IORST
; UPD ID= 390, SNARK:<6.MONITOR>APRSRV.MAC.51,   8-Feb-82 11:12:16 by PAETZOLD
;More TCO 5.1672 - also turn on TRAP1 during overflow in GFLOAT
; UPD ID= 383, SNARK:<6.MONITOR>APRSRV.MAC.50,   5-Feb-82 13:40:05 by HALL
;TCO 6.1000 - Support the 2080
;	Remove checks on EXADFL from SECALE, XBLTA, BLTMU1, BLTUM1, BLTUU
;	Make CKXADR always return success
;	Remove check for EXADF1 and conversion of one-word page fail
;	  flags/PC in MEMPTP, KIPFS, PFCPTP
; UPD ID= 373, SNARK:<6.MONITOR>APRSRV.MAC.49,   2-Feb-82 09:46:06 by HALL
;TCO 6.1000 - Support the 2080
;Add dummy routine PFERRB for KC
;Add definition of I/O page offset for APR interrupt
; UPD ID= 363, SNARK:<6.MONITOR>APRSRV.MAC.48,  30-Jan-82 16:05:31 by HALL
;TCO 6.1000 - Support the 2080
;	In PIINIT, set the I/O page
; UPD ID= 358, SNARK:<6.MONITOR>APRSRV.MAC.47,  28-Jan-82 20:24:24 by HALL
;Fix to my last edit. Restore KICLKP
; UPD ID= 356, SNARK:<6.MONITOR>APRSRV.MAC.46,  27-Jan-82 17:32:11 by PAETZOLD
;TCO 5.1705 - Save BGCCHK and BGCINF calling adrs in BUGCHK and BUGINF
;TCO 5.1672 Simulate GFIX, GFIXR, DGFIX, and DGFIXR in the KL for users
; UPD ID= 355, SNARK:<6.MONITOR>APRSRV.MAC.45,  27-Jan-82 17:23:21 by HALL
;TCO 6.1000 - Support for the 2080
;	Add location for physical I/O page
;	Set "ignore keep me" in KIPGWD
;	Define SETEPT macro
;	Initialize I/O page for APR interrupts and I/O page fail
;	Do KC versions of IORST, PIRST, PAGRST, PGRON, PGROFF
;	remove code for checking for model A
;	Add KC code for KIPFS
;	Remove "No load AC" bits
;Make KISLOD preserve flags word when setting PCU
; UPD ID= 339, SNARK:<6.MONITOR>APRSRV.MAC.44,  22-Jan-82 11:34:17 by HALL
;Rename mask field for APRID, because it conflicts with another symbol
;FOR KL, USE PAGE FAIL WORD DEFINITIONS FROM PROLOG, REMOVE LOCAL DEFINITIONS
; UPD ID= 309, SNARK:<6.MONITOR>APRSRV.MAC.43,  18-Jan-82 08:00:44 by HALL
;Put DEQERR under KL conditional
; UPD ID= 307, SNARK:<6.MONITOR>APRSRV.MAC.42,  16-Jan-82 14:37:48 by HALL
;TCO 6.1000 - Support for the 2080
;	Rearrange timer data base and add KC stuff
;	Change initialization of TIMINT to use RSI macro
;	Add lots of KC stuff for APR control
; UPD ID= 292, SNARK:<6.MONITOR>APRSRV.MAC.41,  11-Jan-82 13:31:42 by MILLER
;More non-vectored int. fix-up. Make BUGCHL preserve PION/PIOFF
; UPD ID= 289, SNARK:<6.MONITOR>APRSRV.MAC.40,  10-Jan-82 12:54:31 by MILLER
;CLEAN UP THE MOS MEMORY CODE A BIT
; UPD ID= 387, SNARK:<5.MONITOR>APRSRV.MAC.47,   9-Jan-82 18:31:05 by MILLER
;TCO 5.1661. ADD CODE TO UNLATCH CONTROLLERS AFTER TGHA RUNS
; UPD ID= 286, SNARK:<6.MONITOR>APRSRV.MAC.38,   8-Jan-82 15:34:16 by MILLER
;Make sure non-vector PI routines have a stack.
; UPD ID= 275, SNARK:<6.MONITOR>APRSRV.MAC.37,   5-Jan-82 11:05:49 by MILLER
;TCO 5.1652. Open code CHKINT at power fail interrupt.
; UPD ID= 260, SNARK:<6.MONITOR>APRSRV.MAC.36,  16-Dec-81 11:24:55 by MILLER
;TCO 6.1047. Check for INSKED at BUGH5
; UPD ID= 257, SNARK:<6.MONITOR>APRSRV.MAC.35,  16-Dec-81 00:28:26 by PAETZOLD
;More TCO 6.1010 - fix up early CST references
;Remove TCO 5.1505 for now (this edit by MILLER)
;Remove TCO 5.1505 for now
; UPD ID= 218, SNARK:<6.MONITOR>APRSRV.MAC.33,  30-Nov-81 08:40:18 by PAETZOLD
;More TCO 6.1010 - Remove all CST0, CST1, CST2, and CST3 references
; UPD ID= 207, SNARK:<6.MONITOR>APRSRV.MAC.32,  12-Nov-81 16:22:59 by HALL
;Move routines for setting overflow to be with routines for detecting it
;TCO 6.1037 and TCO 6.1000- fix bug in storing into PSB (forgot T1)
;	Remove definition of flag bit (It's in MONSYM)
; UPD ID= 204, SNARK:<6.MONITOR>APRSRV.MAC.31,  11-Nov-81 16:39:48 by HALL
;TCO 6.1000 - Support the 2080
;	Add support for trap functions
;TCO 6.1037 - add support for PDL overflow
; UPD ID= 196, SNARK:<6.MONITOR>APRSRV.MAC.30,   8-Nov-81 15:40:18 by HALL
;Fix typo in previous edit
; UPD ID= 195, SNARK:<6.MONITOR>APRSRV.MAC.29,   8-Nov-81 15:28:15 by HALL
;TCO 6.1000 - Remove setting of PCU in MUUO locations -- ucode does it
;	Add MUUO code for KC.  Add prototype UPT and EPT for KC
; UPD ID= 127, SNARK:<6.MONITOR>APRSRV.MAC.28,  19-Oct-81 14:30:09 by COBB
;TCO 6.1029 CHANGE SE1CAL TO EA.ENT
; UPD ID= 99, SNARK:<6.MONITOR>APRSRV.MAC.26,  12-Oct-81 11:20:38 by COBB
;TCO 6.1026 MAKE INSTRUCTION ADDRESS LITERALS BE SECTION 1
; UPD ID= 84, SNARK:<6.MONITOR>APRSRV.MAC.23,  29-Sep-81 11:53:50 by MILLER
; More TCO 5.1487. Clean up type out
; UPD ID= 83, SNARK:<6.MONITOR>APRSRV.MAC.22,  29-Sep-81 08:24:33 by PAETZOLD
;TCO 5.1531 - Check for ILLUUO's caused by PXCT of byte instruction
;with bad pointer
; UPD ID= 78, SNARK:<6.MONITOR>APRSRV.MAC.21,  17-Sep-81 01:50:11 by PAETZOLD
;More TCO 6.1010 - Change field references to CST0, CST1
; UPD ID= 71, SNARK:<6.MONITOR>APRSRV.MAC.20,  15-Sep-81 16:01:53 by PAETZOLD
;TCO 6.1010 - Start moving CSTs to CSTSEC
;Change non-mask cst references CST0, CST1, CST2
; UPD ID= 67, SNARK:<6.MONITOR>APRSRV.MAC.19,  14-Sep-81 13:21:34 by MURPHY
;TCO 5.1505 - IN MPE PAGE FAULT, ZERO THE BAD WORD IN MEMORY.
;FIX TYPEO IN LAST EDIT
;Hand merge more changes from 5
; UPD ID= 59, SNARK:<6.MONITOR>APRSRV.MAC.16,   3-Sep-81 15:45:54 by MILLER
;TCO 5.1487. Fix parity error stuff
; UPD ID= 53, SNARK:<6.MONITOR>APRSRV.MAC.15,  22-Aug-81 16:12:38 by PAETZOLD
;TCO 5.1008X - ADD SPCSNZ ROUTINE
; UPD ID= 52, SNARK:<6.MONITOR>APRSRV.MAC.14,  15-Aug-81 16:57:23 by HALL
;TCO 6.1000 - remove XJRSTF at KISSAV and DATAO at KIMUOM
; UPD ID= 49, SNARK:<6.MONITOR>APRSRV.MAC.13,  11-Aug-81 14:24:05 by HALL
;comments
; UPD ID= 46, SNARK:<6.MONITOR>APRSRV.MAC.12,   8-Aug-81 14:01:29 by HALL
;TCO 6.1000 - Add comments, make LUUO block be defined by RSI, remove
;reduntant jump in BUGHLT code.
; UPD ID= 40, SNARK:<6.MONITOR>APRSRV.MAC.11,  24-Jul-81 05:20:06 by PAETZOLD
;TCO 5.1380 - Add call to IMPFPF in APRIOP to see if AN20 caused IOPGF
; UPD ID= 35, SNARK:<6.MONITOR>APRSRV.MAC.10,  20-Jul-81 13:56:31 by MURPHY
;Args for BUG UNXMPE
; UPD ID= 34, SNARK:<6.MONITOR>APRSRV.MAC.9,  17-Jul-81 14:18:06 by PAETZOLD
;Fix typo in previous edit
; UPD ID= 33, SNARK:<6.MONITOR>APRSRV.MAC.8,  17-Jul-81 13:51:50 by PAETZOLD
;TCO 5.1380 - increase size of MEMPP stack
; UPD ID= 1856, SNARK:<6.MONITOR>APRSRV.MAC.7,  21-Apr-81 07:10:29 by WACHS
;TCO 5.1289 RETURN DIAG RESOURCES PROCESS OWNS ON THE BUGCHK
; UPD ID= 1836, SNARK:<6.MONITOR>APRSRV.MAC.6,  17-Apr-81 14:56:57 by MURPHY
;FIX .ENTER FOR NEW BLSUB. MACRO
;FIX .ENTER FOR NEW BLSUB. MACRO
;DITTO
;Make BUGCHK and BUGINF called with PUSHJ
; UPD ID= 1712, SNARK:<6.MONITOR>APRSRV.MAC.5,  16-Mar-81 15:13:27 by MURPHY
;MOVE ENTSKD TO SCHED
; UPD ID= 1632, SNARK:<6.MONITOR>APRSRV.MAC.4,   2-Mar-81 16:35:02 by MURPHY
;NEW EXT ADR ENTER/LEAVE ROUTINES
; UPD ID= 1627, SNARK:<6.MONITOR>APRSRV.MAC.3,   2-Mar-81 11:55:33 by HALL
;TCO 6.1000 - Fix conditional on XPCW definitions
; UPD ID= 1617, SNARK:<6.MONITOR>APRSRV.MAC.2,  28-Feb-81 11:39:05 by HALL
;TCO 6.1000 - Support the 2080
;	Change PIINIT -- build XPCW words statically, copy to EPT at PIINIT.
;	define KCIOPG
;	Move data definitions to start of module
;	Add TTITLE for KC
;	Initialize LUUBLK with RSI instead of in PIINIT.
;	IN PIINIT, CLEAR APCDPE ALONG WITH OTHER ERROR CONDITIONS
; UPD ID= 146, SNARK:<5.MONITOR>APRSRV.MAC.35,   3-Sep-81 15:04:36 by MILLER
; UPD ID= 144, SNARK:<5.MONITOR>APRSRV.MAC.34,   3-Sep-81 12:40:59 by MILLER
;TCO 5.1487. FIX PARITY ERROR CODE
; UPD ID= 113, SNARK:<5.MONITOR>APRSRV.MAC.33,  21-Aug-81 16:12:42 by PAETZOLD
;TCO 5.1008X - ADD SPCSNZ ROUTINE
; UPD ID= 71, SNARK:<5.MONITOR>APRSRV.MAC.32,  24-Jul-81 05:19:09 by PAETZOLD
;TCO 5.1380 - Add call to IMPFPF in APRIOP to see if AN20 caused IOPGF
; UPD ID= 41, SNARK:<5.MONITOR>APRSRV.MAC.31,  17-Jul-81 14:15:25 by PAETZOLD
;Fix typo in previous edit
; UPD ID= 40, SNARK:<5.MONITOR>APRSRV.MAC.30,  17-Jul-81 13:50:28 by PAETZOLD
;TCO 5.1380 - increase size of MEMPP stack
; UPD ID= 2122, SNARK:<5.MONITOR>APRSRV.MAC.29,   3-Jun-81 17:04:46 by PAETZOLD
;MORE OF TCO 5.1318 ADD BAD DATA WORD TO UPTMPE AND EPTMPE BUGHLT'S
; UPD ID= 1975, SNARK:<5.MONITOR>APRSRV.MAC.28,  11-May-81 11:40:03 by PAETZOLD
;FIX TYPO IN PREVIOUS EDIT
; UPD ID= 1971, SNARK:<5.MONITOR>APRSRV.MAC.27,  11-May-81 10:05:02 by PAETZOLD
;TCO 5.1318 DETECT PARITY ERRORS FOR EPT AND UPT RELATIVE ADDRESSING
; UPD ID= 1882, SNARK:<5.MONITOR>APRSRV.MAC.26,  24-Apr-81 09:07:59 by GRANT
;Fix typo in previous edit
; UPD ID= 1880, SNARK:<5.MONITOR>APRSRV.MAC.24,  23-Apr-81 17:52:30 by LYONS
;FIX AN20 ABILITY TO HANG SYSTEM
; UPD ID= 1854, SNARK:<5.MONITOR>APRSRV.MAC.23,  21-Apr-81 07:02:21 by WACHS
;TCO 5.1289 RETURN DIAG RESOURCES ON A BUGCHK
; UPD ID= 1775, SNARK:<5.MONITOR>APRSRV.MAC.22,  27-Mar-81 13:30:28 by MURPHY
;FIX .ENTER FOR NEW BLSUB. MACRO
; UPD ID= 1764, SNARK:<5.MONITOR>APRSRV.MAC.21,  24-Mar-81 16:36:44 by MURPHY
;DITTO
; UPD ID= 1757, SNARK:<5.MONITOR>APRSRV.MAC.20,  23-Mar-81 16:29:15 by MURPHY
;Make BUGCHK and BUGINF called with PUSHJ
; UPD ID= 1705, SNARK:<5.MONITOR>APRSRV.MAC.19,  16-Mar-81 11:42:07 by MURPHY
;MOVE ENTSKD TO SCHED
; UPD ID= 1631, SNARK:<5.MONITOR>APRSRV.MAC.18,   2-Mar-81 16:26:48 by MURPHY
;NEW EXT ADR ENTER/LEAVE ROUTINES
; UPD ID= 1505, SNARK:<5.MONITOR>APRSRV.MAC.17,  27-Jan-81 16:54:04 by HALL
;Miscellaneous cleanup and comments
; UPD ID= 1494, SNARK:<5.MONITOR>APRSRV.MAC.16,  26-Jan-81 12:35:08 by HALL
;Clean up conditionals, add comments. Put MEMPJ0 under Kl conditional.
; UPD ID= 1482, SNARK:<5.MONITOR>APRSRV.MAC.15,  23-Jan-81 09:09:05 by HALL
;Change IFE SMFLG to IFN KLFLG
; UPD ID= 1268, SNARK:<5.MONITOR>APRSRV.MAC.14,  12-Nov-80 16:27:00 by DONAHUE
;TCO 5.1196 - REMOVE SAVET MACRO IN GENBLK
; UPD ID= 1195, SNARK:<5.MONITOR>APRSRV.MAC.13,  25-Oct-80 12:14:54 by HALL
;TCO 5.1180 - MOVE THE DST INTO NON-ZERO SECTION
;	FKSETK - MAKE UPTPFN INCLUDE SECTION 1 SO PAGE FAULT HANDLER
;	RUNS IN SECTION 1
; UPD ID= 1182, SNARK:<5.MONITOR>APRSRV.MAC.12,  20-Oct-80 17:59:16 by MURPHY
;BLSUBR SUPPORT CODE
; UPD ID= 1148, SNARK:<5.MONITOR>APRSRV.MAC.11,  10-Oct-80 14:45:41 by MURPHY
;SASUBR SUPPORT CODE
; UPD ID= 1082, SNARK:<5.MONITOR>APRSRV.MAC.10,   1-Oct-80 11:54:58 by MURPHY
;FIX ACVAR
;NEW SAVEAC SUPPORT ROUTINES
;MAKE STKVAR AND TRVAR GET REAL TRAP ON STACK OVERFLOW
; UPD ID= 1035, SNARK:<5.MONITOR>APRSRV.MAC.9,  23-Sep-80 15:21:44 by HALL
;FIX BUGM0 AND BUGP0 ON KS -- FORGOT TO TAKE OUT THE ZERO WHEN MOVING
; BUGMON AND BUGPRI TO RSDAT PSECT
; UPD ID= 1002, SNARK:<5.MONITOR>APRSRV.MAC.8,  11-Sep-80 17:57:35 by GRANT
;Change MONX01 to MONX05 in GENGEN routine
; UPD ID= 785, SNARK:<5.MONITOR>APRSRV.MAC.7,  23-Jul-80 12:26:44 by HALL
;CLEAN UP COMMENTS ON SECONDARY PROTOCOL OUTPUT ROUTINES
; UPD ID= 687, SNARK:<5.MONITOR>APRSRV.MAC.6,  24-Jun-80 09:50:50 by MURPHY
;NOW MAKE SECALL, SECALE WORK AGAIN
; UPD ID= 652, SNARK:<5.MONITOR>APRSRV.MAC.5,  16-Jun-80 16:00:54 by MURPHY
;MAKE SECALL, SECALE FASTER
; UPD ID= 464, SNARK:<5.MONITOR>APRSRV.MAC.4,  23-Apr-80 13:22:03 by MURPHY
;ALLOW DDT BREAKPOINT WHEN MONITOR WRITE PROTECTED
; UPD ID= 420, SNARK:<5.MONITOR>APRSRV.MAC.3,   8-Apr-80 15:30:37 by HALL
;CHANGED BUGMON AND BUGPRI FOR KS MONITOR (MORE OF PRECEDING EDIT)
; UPD ID= 406, SNARK:<5.MONITOR>APRSRV.MAC.2,   3-Apr-80 16:12:26 by HALL
;CHANGES TO WRITE-PROTECT THE RESIDENT MONITOR:
;	MOVE DEFINITION OF CONOPG TO STG
;	MAKE CASHF BE AN RS
;	MAKE BUG-HANDLING CODE AVOID BREAKPOINT IF MONITOR IS WRITE-PROTECTED
;	TAKE OUT JSR LOCATIONS
; UPD ID= 335, SNARK:<4.1.MONITOR>APRSRV.MAC.264,  14-Mar-80 11:42:52 by HALL
;GET THE NAME FOR FATCDP RIGHT THIS TIME
; UPD ID= 333, SNARK:<4.1.MONITOR>APRSRV.MAC.263,  14-Mar-80 11:04:04 by HALL
;PUT NAMES IN OPTIONAL DATA FOR IOPGF AND FATCDP
; UPD ID= 254, SNARK:<4.1.MONITOR>APRSRV.MAC.262,   7-Feb-80 17:18:52 by HALL
;put names in optional data for bug ilpsec
; UPD ID= 249, SNARK:<4.1.MONITOR>APRSRV.MAC.261,   6-Feb-80 17:24:32 by HALL
;ADD NAMES OF OPTIONAL DATA TO BUG EBSPER
; UPD ID= 238, SNARK:<4.1.MONITOR>APRSRV.MAC.260,   1-Feb-80 14:39:25 by ENGEL
;CALL RQTAD1 AT CLKINI IF KS
; UPD ID= 90, SNARK:<4.1.MONITOR>APRSRV.MAC.259,   5-Dec-79 09:03:00 by OSMAN
;tco 4.1.1043 - Change XCT APHLT1 to BUG(APRNX1)
;<4.1.MONITOR>APRSRV.MAC.258, 15-Nov-79 16:15:46, EDIT BY MILLER
;<4.1.MONITOR>APRSRV.MAC.257, 15-Nov-79 16:12:09, EDIT BY MILLER
;<4.1.MONITOR>APRSRV.MAC.256, 15-Nov-79 16:05:13, EDIT BY MILLER
;SUPPRESS MEM SCAN ON MB PARITY IF CHANNEL WRITE IS CAUSE
;<4.1.MONITOR>APRSRV.MAC.255, 13-Nov-79 06:44:04, EDIT BY R.ACE
;ADD PC ARGUMENT TO ILLDMS AND ILLFLT BUGCHKS
;<4.1.MONITOR>APRSRV.MAC.254,  8-Nov-79 17:39:44, EDIT BY MURPHY
;ADD LSTPFK IN SETPSK
;<4.1.MONITOR>APRSRV.MAC.253,  6-Nov-79 05:45:43, EDIT BY R.ACE
;CHANGE NAMES OF ARGUMENTS TO ILLUUO BUGHLT

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


;PROCESSOR SERVICE, PROCESSOR-DEPENDENT PAGING. D. MURPHY


	SEARCH PROLOG,SERCOD
	EXTN <PI7P,PIXCX,XPISK,PIXSTK,PIBITS,WROPR0>

	TTITLE APRSRV

  IFN KLFLG,<
EXTN <DTEINA,DTEACT,ENDRGN,NMD16K,MEMTAB,DTICON,SYRMAP>
   >				;END OF IFN KLFLG

   IFN KCFLG,<
 EXTN <CNBOUT>			;NON-PI TYPE-OUT ROUTINE


   >				;END OF IFN KCFLG

;NEED FX FOR BUGH0 -- BUGHLT CODE

FX==Q3				;DEFINE AC FOR FKJSB

	Subttl	Table of Contents

;		     Table of Contents for COPYRIGHT
;
;				  Section		      Page
;
;
;    1. Definitions  . . . . . . . . . . . . . . . . . . . . .   4
;    2. Generally Used Constants . . . . . . . . . . . . . . .  23
;    3. Utility routines . . . . . . . . . . . . . . . . . . .  25
;    4. System Initialization  . . . . . . . . . . . . . . . .  43
;    5. PI System Initialization . . . . . . . . . . . . . . .  49
;    6. APR Interrupt Service  . . . . . . . . . . . . . . . .  55
;    7. Memory Parity Error routines (KL only) . . . . . . . .  65
;    8. Gather KL10 Status Block . . . . . . . . . . . . . . .  94
;    9. Routines to handle BUGHLT, BUGCHK, BUGINF  . . . . . .  99
;   10. Write to CTY when PI's are off . . . . . . . . . . . . 110
;   11. Routines to switch protocols with front end  . . . . . 113
;   12. Clock Service  . . . . . . . . . . . . . . . . . . . . 116
;   13. DTE Control Routines . . . . . . . . . . . . . . . . . 121
;   14. Cache Control  . . . . . . . . . . . . . . . . . . . . 123
;   15. Context Handling Routines  . . . . . . . . . . . . . . 125
;   16. Address Break  . . . . . . . . . . . . . . . . . . . . 151
;   17. Pager Control Routines . . . . . . . . . . . . . . . . 157
;   18. Page Fail Handler (Hard Error Codes and Unusual Cases) 173
;   19. KA floating point simulation . . . . . . . . . . . . . 193
;   20. Gfloat to Integer Conversion Simulation Routines . . . 200
;   21. METER JSYS . . . . . . . . . . . . . . . . . . . . . . 204
;   22. End of APRSRV  . . . . . . . . . . . . . . . . . . . . 205
	SUBTTL Definitions

;CONI/CONO APR BIT DEFINITIONS

   IFN KLFLG,<

;FLAG FUNCTIONS (CONO APR)

APIOPR==:1B19			;IOB RESET
APEINT==:1B20			;FLAG ENABLE
APDINT==:1B21			;FLAG DISABLE
APFCLR==:1B22			;FLAG CLEAR
APFSET==:1B23			;FLAG SET

;FLAGS - AFFECTED AS CONTROLLED BY FLAG FUNCTION BITS

APSBER==:1B24			;SBUS ERROR
APNXM==: 1B25			;NONX MEM
APIOPF==:1B26			;IO PAGE FAIL
APMPE==: 1B27			;MBOX-DETECTED DATA PARITY ERROR
APCDPE==:1B28			;CACHE DIRECTORY PARITY ERROR
APAPE==: 1B29			;ADDRESS PARITY ERROR
APPWF==: 1B30			;POWER FAIL
APSWPD==:1B31			;SWEEP DONE

APIRQ==: 1B32			;INTERRUPT REQUEST (CONI ONLY)
APPIA==: 7B35			;PI ASSIGNMENT

GOPDEF CLRMPE,<CONO APR,APFCLR+APSBER+APMPE+APRCHN>	;CLEAR PAR FLAG

GOPDEF CLNXMF,<CONO APR,APFCLR+APNXM+APRCHN> ;CLEAR NXM FLAG

APSWPB==:1B19			;SWEEP BUSY (CONI APR OR RDAPR)

;CONO APR WHERE PI CHANNEL IS ALWAYS NEEDED

DEFINE CONOAPR (E)<
	CONO APR,E+APRCHN>

;SKIP IF RESULT OF MAP INSTRUCTION SAYS PAGE CAN BE REFERENCED.

DEFINE SMAPOK (AC)<
	TXNN AC,TWHPFF		;HARD FAILURE?
	TXNN AC,TWVALD>		;NO. VALID MAPPING?
				;HERE FOR FAILURE
				;HERE FOR SUCCESS
   >				;END IFN KLFLG
;Bits for WRAPR/RDAPR

   IFN KCFLG,<

APLDPI==:1B18			;LOAD PI LEVEL FROM BITS 33-35
APIOPR==:1B19			;ASSERT RESET ON THE I/O BUS
APEINT==:1B20			;ENABLE INTERRUPTS ON LEVELS IN BITS 24-31
APDINT==:1B21			;DISABLE INTERRUPTS ON LEVELS IN BITS 24-31
APFCLR==:1B22			;CLEAR FLAGS IN BITS 24-31
APFSET==:1B23			;SET FLAGS IN BITS 24-31

;In WRAPR, these bits select particular conditions in conjunction with
;bits APEINT,APDINT,APFCLR,APFSET.
;In RDAPR, each of these bits indicates a condition for which an interrupt
;is pending.
				;BITS 24-29 RESERVED
APCONS==:1B30			;CONSOLE ATTENTION
APPWF==:1B31			;POWER FAILURE

APPIA==: 7B35			;PI ASSIGNMENT

APIRQ==: 1B32			;INTERRUPT REQUEST (RDAPR ONLY)

GOPDEF CLRMPE,<JFCL>		;NO KC EQUIVALENT OF "CLEAR MEMORY PARITY ERROR"
				; BECAUSE IT'S NOT AN APR CONDITION

GOPDEF CLNXMF,<JFCL>		;NO KC EQUIVALENT OF "CLEAR NXM" BECAUSE
				; IT'S NOT AN APR CONDITION

;CONO APR WHERE PI CHANNEL IS ALWAYS NEEDED

DEFINE CONOAPR (E)<
	WRAPR E+APLDPI+APRCHN>

;SKIP IF RESULTS OF MAP INSTRUCTION SAYS PAGE CAN BE REFERENCED

DEFINE SMAPOK (AC)<
	TXNN AC,MPHPFF		;HARD FAILURE?
	TXNN AC,MPVALD>		;NO. DOES MAPPING EXIST?
   >				;END OF IFN KCFLG

;local storage

RSI PTPARC,<-2>			;Allow 2 PT parity errors before dying


;GET PROCESSOR SERIAL NUMBER

   IFN KLFLG,<
APRSN==:MASKB(24,35)
   >				;END OF IFN KLFLG
   IFN KCFLG,<
APRSN==:MASKB(18,35)
   >				;END OF IFN KCFLG


RS PI1ACS,20			;STORAGE FOR AC'S DURING APR INTERRUPT


   IFN DTFLG,<

;DTE20 SERVICE

RS DTESV,4			;PC AND DISPATCH FOR JSR

;DTE20 CONI/CONO BITS

DTE0==200			;DEVICE CODE, DTE #0
DTECHN==DLSCHN			;PI CHANNEL ASSIGNMENT

DEFINE CONODTE (E)<
	CONO DTE0,E>

;DTE20 DATAO BITS AND FIELDS

; 0-22				;UNUSED
DTETI==:1B23			;TO-10 "I" BIT
DTEBYC==:007777			;(NEGATIVE) BYTE COUNT

;KLDTE PROTOCOL

DTEDAT==377			;DATA BYTE IN DTECMD
DTECCD==17B27			;COMMAND CODE IN DTECMD

;COMMAND CODES

DTETTO==0B27			;TTY OUTPUT
; 1 - PROGRAM CONTROL, NOT USED
DTECOF==2B27+0			;CLOCK OFF
DTECON==2B27+1			;CLOCK ON
; 3 - SWITCHES, NOT USED
; 4 - TTY OUTPUT, SAME AS 0?
; 5 - TTY INPUT, NOT USED
DTEPTN==6B27+0			;PRINT NORMAL
DTEPTF==6B27+1			;PRINT FORCED
DTEDDI==7B27			;DDT INPUT
DTEMNO==10B27			;MONITOR TTY OUTPUT
DTEMMN==11B27			;MONITOR MODE ON
DTEMMF==12B27			;MONITOR MODE OFF
DTERMM==13B27			;READ MONITOR MODE

   >				;END OF IFN DTFLG

;STORAGE FOR PARITY ROUTINES

RS MEMPA,1			;ONE WORD FOR PAGEM TO USE
RS WREQ,1			;WRITE ERROR QUEUE

   IFN KLFLG,<

RS MEMAP,1			;FOR STACK STORAGE
RS DEVMPE,1			;AOS'D TO REQUEST CORE SCAN
RS MPITIM,1			;TIME OF LAST PAR ERR
RS MPISEB,PI%LN2		;TEMP SYSERR DATA
NMEMPP==^D54			;SIZE OF LOCAL STACK
RS MEMPP,NMEMPP			;LOCAL STACK
RS MEMPDP,1			;SAVE AC BLOCK SETTINGS
RS MEMPFF,1			;FATAL FLAG
RS MTSADR,1			;HOLD MEMORY TEST ADDRESS

;DEFINITIONS FOR MF20 CONTROLLERS

MOSTBL:	-10,,10			;FIRST GROUP OF CONTROLLERS
	-5,,0			;THE MB/MB AND DMA CONTROLLERS
MOSLEN==.-MOSTBL		;# OF GROUPS

FMOS==:10			;FIRST MF20 CONTROLLER
MOS==5				;MEMORY TYPE FOR MF20
DEFSTR (MEMTYP,,11,4)		;FIELD IS SBUSD FNC 1 FOR MEMORY TYPE
MOSCER==1B1			;CORRECTABLE ERROR BIT
MOSWPE==1B4			;DATA WRITE PARITY ERROR
MOSDBL==1B25			;DISABLE BIT IN FNC 1 FOR MOS
SBSHER==57B5			;HARD ERROR BITS FOR ANY SBSUS CONTROLLER
SBSRPE==1B3			;READ PARITY ERROR
SBSMAX==2			;# OF SBDIAG'S TO READ
MFBXDS==1B14			;BOX DISABLE IN FNC 12

;OTHER KNOWN MEMORY TYPES FOR SBDIAG USED BY MEMLOK ROUTINE
DMA20==2
MA20==1
MB20==3
	ARQENB==17B35		;TO TEST ANY REQUESTS ENABLED FOR MA20/MB20
MX20==4	;NOT CURRENTLY IMPLEMENTED

;DEFINE NEEDED ERA BITS

	ER%CHN==:1B3		;CHANNEL DETECTED ERROR
	ER%WRT==:1B6		;WRITE TO MEMORY
SBCLER==1B5			;SBUSDIAG CLEARR ERROR BIT

PFCPT:	SEBPTR 0,SBTEVC,SEC%PT	;EVENT CODE
	SEBPTR 0,SBTFNA,PFCPJ0	;FUNCTION ADDRESS--JOB 0 FIXUP
NPFCPT==.-PFCPT

RS CCHECT,1			;CACHE HARD ERROR COUNT

>				;END OF IFN KLFLG

RSI CASHF,,1			;STATE OF THE CACHE (-1 FOR ON, 0 FOR OFF)
				;(used early before RS zeroed)


;AC BLOCK ASSIGNMENTS

MONACB==:0			;MONITOR
USRACB==:1			;USER
APRACB==2			;APR INT AC BLOCK
CH6ACB==3			;FOR CONSOLE TTY HANDLING ON THE KC
   IFN KLFLG,<
HW7ACB==7			;HARDWARE HAS SOME THINGS IN BLOCK 7
	BK7PFD==0		;DATA WORD ON AR/ARX PARITY ERROR
	BK7IOP==2		;PF WORD ON IO PAGE FAIL
   >				;END OF IFN KLFLG

;Fields in a flags word for AC blocks for instructions that load flags.
;MONFLG sets context for monitor; USRFLG sets context for user.

   IFN KLFLG,<
MONFLG=:0
USRFLG=:0
   >

   IFN KCFLG,<
MONFLG=:FLD(MONACB,EXCAB)+FLD(USRACB,EXPAB)
USRFLG=:FLD(USRACB,EXCAB)
   >

;COMPLETE MONITOR FLAG WORD (I.E. MONITOR ENVIRONMENT)

MONENV==:PCU+MONFLG+1		;DEFAULT PCS TO 1

USRCTX=:UMODF+USRFLG		;FLAGS WORD WHEN SETTING USER CONTEXT

;ASSORTED STANDARD FORMS OF DATAO PAG/WRCTX.

;KIPGW0 - LOAD UBR TO POINT TO SCHEDULER'S UPT, CLEAR KEPT ENTRIES, DON'T
;	  DO ACCOUNTING
;SETMON - SET CURRENT AC'S TO MONITOR'S AC'S (0), PREVIOUS TO USER'S (1)
;SETUSR - SET CURRENT AC'S TO USER'S AC'S (1)
;SETBK7 - SET CURRENT AC'S TO MONITOR'S, PREVIOUS TO AC'S USED BY HARDWARE
;SETAPI - SET CURRENT AC'S TO AC'S USED BY HARDWARE, PREVIOUS TO APR INTERRUPT AC'S

;Initial DATAO PAG sets PGNSAC so that the previous UPT won't be updated.
;We don't have a previous UPT at this point. The update could cause a
;bad reference.


   IFN KLFLG,<
KIPGW0: PGLUBR+PGNSAC+SKHWPT/PGSIZ
SETMON::PGLACB+FLD(MONACB,PGCACB)+FLD(USRACB,PGPACB) ;SET MON CONTEXT
SETUSR::PGLACB+FLD(USRACB,PGCACB)		 ;SET USER CONTEXT
SETBK7::PGLACB+FLD(MONACB,PGCACB)+FLD(HW7ACB,PGPACB) ;SET BK7 PREVIOUS
SETAPI:	PGLACB+FLD(HW7ACB,PGPACB)+FLD(APRACB,PGCACB) ;APR INT ACS
SETHWR::PGLACB+FLD(MONACB,PGCACB)+FLD(HWRACB,PGPACB) ;HARDWARE REGISTERS
   >				;END OF IFN KLFLG

   IFN KCFLG,<
; * * * *
;Temporarily clear all ignoring "keep me" bit
; * * * *
KIPGW0: PGLUBR+PGNSAC+PGCLKP+FLD(SKHWPT/PGSIZ,PGUBRM)
SETMON::PGLACB
	FLD(MONACB,PGCACB)+FLD(USRACB,PGPACB)
SETUSR::PGLACB
	FLD(USRACB,PGCACB)

;Local storage for APR conditions

NDG APRSIZ,10
RS APRSTK,APRSIZ		;STACK FOR APR INT
   >				;END OF IFN KCFLG


;This location is used in all WRCTX (DATAO PAG) instructions after the
;monitor has been initialized. It is updated with the physical page number
;of the new UPT when a new process is scheduled. It is not used to change
;AC blocks. SETMON, SETUSR, etc., load AC blocks and do NOT change the UPT.

   IFN KLFLG,<
RS KIPGWD,1			;PAGER WORD FOR DATAO
   >				;END OF IFN KLFLG

   IFN KCFLG,<
RS KIPGWD,2
   >				;END OF IFN KCFLG

DEFINE CLHWPT<
	DATAO PAG,KIPGWD>	;CLEAR AND LOAD PAGING HARDWARE

RS PFSA1,2			;SAVED ACS AT KIPFS
RS PFSA3,1			;MORE SAVED ACS AT KIPFS
;Data for clocks and timers

;Four "clocks" are used.

;The hardware provides a time base, which counts in 1 usec units and stores
;its current value in two words, and a timer, which counts in 10 usec units
;and causes an interrupt when its count reaches a value set by the software.

;The software maintains a "high precision clock", which it computes from
;the hardware time base. This clock is stored in one word in units of 10
;usecs. Other clock values, including TODCLK, are in 1 ms units.

;Various constants provide conversion among these clocks.


;TIME BASE

;Time base ticks every usec. This converts between time base ticks and
;milliseconds. The value of BASUNT reflects the placement of the units
;digit of the time base in a two-word format.

;On the KL, only bits 0-23 of the second word are used. On the KC both words
;are used fully.

BASTMS==^D1000			;TICKS/MS OF TIME BASE CLOCK
   IFN KLFLG,<
BASBIT==^D23
BASUNT==1B<BASBIT>		;UNITS POSITION TIME BASE CLOCK 2ND WORD
>				;END IFN KLFLG
   IFN KCFLG,<
BASUNT==1B35			;UNITS POSITION TIME BASE CLOCK 2ND WORD
>				;end of IFN kcflg
BASDIV::BASTMS*BASUNT		;CONVERT TO MILLISECONDS

;HIGH PRECISION CLOCK

;Software high precision clock is in 10 usec units. This converts between
;high precision ticks and milliseconds.

NTMS==:^D100			;TICKS/MS OF SOFTWARE HIGH PRECISION CLOCK

;Number of time base ticks per high precision tick, taking into account format
;of time base

BASND0==<BASTMS/NTMS>*BASUNT	;HW UNITS PER HP UNIT
BASNDV::BASND0			;CONVERT TO HP UNITS
BASDV2:	BASTMS/NTMS
;Number of time base ticks at which high precision counter overflows one word

BASOV0==1B<^L<BASND0>>		;VALUE AT WHICH HP WORD OVERFLOWS
RS BASOVV,1			;OVERFLOW VALUE FOR HP CLOCK

;TIMER

;Interval timer ticks every 10 usec. This converts between timer ticks and
;milliseconds

TIMTMS==^D100			;TICKS/MILLISECOND INTERVAL COUNTER


RS JFDAY,1			;JIFFIES PER DAY - USED IN GTAD, STAD
RS JFDAY2,1			;JIFFIES/DAY/2 - FOR ROUNDING

;Bits and instructions for controlling clocks for the KL

   IFN KLFLG,<

;CONI/CONO MTR,

MTR==024			;DEVICE CODE

MTRLOD==1B18			;LOAD ACCOUNTING BITS 21-23
;	19-20			;UNUSED, MBZ
MTREPA==1B21			;ENABLE EXEC PI ACCOUNTING
MTRENA==1B22			;ENABLE EXEC NON-PI ACCOUNTING
MTRAMN==1B23			;ACCOUNTING METERS ON
MTRTBF==1B24			;TIME BASE OFF
MTRTBN==1B25			;TIME BASE ON
MTRCTB==1B26			;CLEAR TIME BASE
;	27-32			;UNUSED, MBZ
MTRPIA==7B35			;PI ASSIGNMENT FOR INTERVAL COUNTER

;The following EPT locations are used for clocks

TIMBAS=KIEPT+510		;TIME BASE CLOCK DOUBLEWORD
;	KIEPT+512		;PERF ANAL CLOCK DOUBLEWORD
TIMVIL=KIEPT+514		;VECTOR INTERRUPT LOCATION

;Timer interrupts execute location at TIMVIL, which is XPCW TIMINT.
;This causes the monitor to run at TIMIN0

RSI TIMINT,<0,0,0,<MSEC1,,TIMIN0>>

   >				;END IFN KLFLG

;Bits and instructions for controlling clocks for the KC

   IFN KCFLG,<

;For WRTMB and RDTMB (controls time base and interrupt level for
;interval timer)

TMBLPI==1B18			;LOAD PI LEVEL FROM BITS 33-35
TMBLTB==1B19			;LOAD TIME BASE FROM BITS 20 AND 23
TMBCTB==1B20			;CLEAR TIME BASE
TMBBON==1B23			;TURN ON TIME BASE
TMBPIA==<MASKB 33,35>		;PI LEVEL FOR INTERVAL TIMER

;For WRACT and RDACT (controls user runtime meter)

ACTLOD==1B18			;LOAD CONTROLS FROM BITS 19-21
ACTEPI==1B19			;ENABLE METER DURING EXEC PI
ACTENP==1B20			;ENABLE METER DURING EXEC NON-PI
ACTAON==1B21			;TURN ON USER RUNTIME METER


;Timer interrupt executes XPCW block pointed to by offset 202 in the I/O
;page. This initializes the XPCW block to go to TIMIN0.

TIMVIL=KCIOPG+202
RSI TIMINT,<0,0,<FLD(MONACB,EXCAB)>,<MSEC1,,TIMIN0>>
>				;End of IFN KCFLG

;Common clock definitions

;Interrupt level for the clock (same as APR)

TIMCHN==APRCHN			;PI ASSIGNMENT

;CONI/CONO TIM on KL, WRINT and RDINT on KC (controls interval counter)

TIMCIC==1B18			;CLEAR INTERVAL COUNTER
;	19-20			;UNUSED, MBZ
TIMITO==1B21			;INTERVAL TIMER ON
TIMDON==1B22			;DONE (FOR READ)/CLEAR DONE (FOR WRITE)
TIMICO==1B23			;COUNTER OVERFLOW (FOR READ)
TIMPER==<MASKB 24,35>		;PERIOD REGISTER

   IFN KLFLG,<
TIM==020			;DEVICE ASSIGNMENT

DEFINE RDTIME (XX)<
	DATAI TIM,XX>

   >				;END OF IFN KLFLG


;Data for PI system initialization

   IFN KLFLG,<

;Set common names for initialization of vector words

VECST==40+KIEPT			;WHERE TO START VECTOR WORDS
VECINC==2			;HOW MUCH TO INCREMENT FOR NEXT LEVEL

;Generate XPCW blocks for non-vectored interrupts
;NOTE: Hardware requires that XPCW block be in section 0

RSI PI0ER,<0,0,0,PIERR0>	;LEVEL 0
RSI PI1ER,<0,0,0,PIERR1>	;LEVEL 1
RSI PI2ER,<0,0,0,PIERR2>	;LEVEL 2
RSI PIAPRX,<0,0,0,PIAPR>	;LEVEL 3
RSI PI4ER,<0,0,0,PIERR4>	;LEVEL 4
RSI PI5R,<0,0,0,PISC5>		;LEVEL 5
RSI PI6R,<0,0,0,PISC6>		;LEVEL 6
RSI PISC7R,<0,0,0,PISC7>	;LEVEL 7

;Edit [7463] was made to help diagnose broken RH20s. These next 8 lines
;must be in order ALWAYS! If you must change them, then you must change
;EPTINI in PHYH2.

RSI RH0ERR,<0,0,0,RH0BAD>	;[7463] No RH in channel 0
RSI RH1ERR,<0,0,0,RH1BAD>	;[7463] No RH in channel 1
RSI RH2ERR,<0,0,0,RH2BAD>	;[7463] No RH in channel 2
RSI RH3ERR,<0,0,0,RH3BAD>	;[7463] No RH in channel 3
RSI RH4ERR,<0,0,0,RH4BAD>	;[7463] No RH in channel 4
RSI RH5ERR,<0,0,0,RH5BAD>	;[7463] No RH in channel 5
RSI RH6ERR,<0,0,0,RH6BAD>	;[7463] No RH in channel 6
RSI RH7ERR,<0,0,0,RH7BAD>	;[7463] No RH in channel 7

;THESE XPCW WORDS ARE COPIED TO THE EPT BY PIINIT
;When a nonvectored interrupt occurs, the word corresponding to its
;level is executed.

PIVEC:	XPCW PI0ER		;LEVEL 0
	XPCW PI1ER		;LEVEL 1
	XPCW PI2ER		;LEVEL 2
	XPCW PIAPRX		;LEVEL 3
	XPCW PI4ER		;LEVEL 4
	XPCW PI5R		;LEVEL 5
	XPCW PI6R		;LEVEL 6
	XPCW PISC7R		;LEVEL 7
NPISET==:.-PIVEC

RSI LUUBLK,<0,0,0,LUUBUG>	;XPCW BLOCK FOR LUUO IN NON-ZERO SECTION
RSI RLODPC,<0,0,0,RLDHLT>	;XPCW BLOCK FOR KEEP ALIVE RELOAD
   >				;END IFN KLFLG


;Data for PI system initialization

IFN KCFLG,<
KCIOPG==:1000			;Virtual address of I/O page
RSI KCIPHY,KCIOPG/PGSIZ		;Physical page for I/O page
IOPVEC==230			;OFFSET IN IO PAGE WHERE VECTORS START
VECST==IOPVEC+KCIOPG		;WHERE TO START VECTOR WORDS
VECINC==1			;HOW MUCH TO INCREMENT FOR NEXT LEVEL

;Generate 4-word blocks pointed to by interrupt vector words for
;software-requested interrupts

RSI PI0ER,<0,0,<FLD(MONACB,EXCAB)>,<MSEC1,,PIERR0>>
RSI PI1ER,<0,0,<FLD(MONACB,EXCAB)>,<MSEC1,,PIERR1>>
RSI PI2ER,<0,0,<FLD(MONACB,EXCAB)>,<MSEC1,,PIERR2>>
RSI PI3ER,<0,0,<FLD(MONACB,EXCAB)>,<MSEC1,,PIERR3>>
RSI PI4ER,<0,0,<FLD(MONACB,EXCAB)>,<MSEC1,,PIERR4>>
RSI PI5R,<0,0,<FLD(MONACB,EXCAB)>,<MSEC1,,PISC5>>
RSI PI6R,<0,0,<FLD(CH6ACB,EXCAB)>,<MSEC1,,PISC6>>
RSI PISC7R,<0,0,<FLD(MONACB,EXCAB)>,<MSEC1,,PISC7>>

;THESE WORDS ARE COPIED INTO THE I/O PAGE BY PIINIT
;When a software-requested interrupt occurs, the microcode looks at
;the word in the I/O page corresponding to its level. That word contains
;the address of a 4 word block similar to an XPCW block.

PIVEC:	MSEC1,,PI1ER		;LEVEL 1
	MSEC1,,PI2ER		;LEVEL 2
	MSEC1,,PI3ER		;LEVEL 3
	MSEC1,,PI4ER		;LEVEL 4
	MSEC1,,PI5R		;LEVEL 5
	MSEC1,,PI6R		;LEVEL 6
	MSEC1,,PISC7R		;LEVEL 7
NPISET==:.-PIVEC

IOPAPR==201			;OFFSET IN I/O PAGE FOR APR INTERRUPT VECTOR
IOPNPC==247			;OFFSET IN I/O PAGE FOR NEW FLAGS/PC FOR IO PAGE FAIL

;Interrupt vector for APR interrupt.

RSI PIAPRX,<0,0,<FLD(APRACB,EXCAB)>,<MSEC1,,PIAPR>>

RSI LUUBLK,<0,0,<FLD(MONACB,EXCAB)>,LUUBUG> ;XPCW BLOCK FOR LUUO IN NON-ZERO SECTION

RSI RLODPC,<0,0,<FLD(MONACB,EXCAB)>,RLDHLT> ;XPCW BLOCK FOR KEEP ALIVE RELOAD

;Offsets in the I/O page:

;	0-77	Port register access blocks
;IOPAPR	201	APR interrupt
;TIMVIL	202	Interval timer
;	210-217	Port interrupt vectors
;	220-230	Reserved for ucode
;IOPVEC	231-237	Software interrupt vectors
;	240-246	Data for I/O page fail
;IOPNPC	247-250	New flags/PC for I/O page fail
;	400-777	Console comm region

>				;END OF IFN KCFLG

	SUBTTL Generally Used Constants

;6-BIT POINTER TABLE

	POINT 6,0,-1
CH6TAB::POINT 6,0,5
	POINT 6,0,11
	POINT 6,0,17
	POINT 6,0,23
	POINT 6,0,29
	POINT 6,0,35

;BHC+N CONTAINS N,,N

XX=0
BHC::	REPEAT 20,<EXP XX*1000001
		XX=XX+1>

;BITS+N CONTAINS A WORD WITH A 1 IN BIT N

XX==0
BITS::	REPEAT ^D36,<EXP 1B<XX>
		XX=XX+1>
	SUBTTL Utility routines

;GLOBAL STANDARD RETURNS

;POP AC'S DOWN TO 1 AND RETURN

PA7::	POP P,7
PA6::	POP P,6
PA5::	POP P,5
PA4::	POP P,4
PA3::	POP P,3
PA2::	POP P,2
PA1::	POP P,1
	RET

;POP AC'S DOWN TO 2 AND RETURN

PB7::	POP P,7
PB6::	POP P,6
PB5::	POP P,5
PB4::	POP P,4
PB3::	POP P,3
PB2::	POP P,2
	RET

;FALSE (AC1=0) AND TRUE (AC1#0) RETURNS

RETZ::				;RETURN ZERO
RFALSE::SETZ 1,
	RET

RETO::				;RETURN ONES
RTRUE::	SETO 1,
	RET

;SKIP AND NO-SKIP RETURNS

RSKP::	AOS 0(P)
RTN::
R::	RET

repeat 0,<
;This is an artifact of the SZCOD PSECT which takes up space that we need
; it might be nice to have it back sometime
	RESCD (SEC0)		;These kinda have to be in section 0
>
	RESCD

;$EAENT - Routine to jump into extended section if necessary and set stack for
;automatic return to caller's section. Called upon entry into a routine that
;must run in an extended section.

;Invoked via EA.ENT macro (JSP CX,$EAENT)

$EAENT::
; The proper section 0 test would be these 2 instructions, but efficiency
; forbids this solution.
;	XHLLI CX,.		;GET SECTION NUMBER INTO CX
;	TLNE CX,-1		;ALREADY IN NON-0 SECTION?

	TXNE CX,EXSCBT		;ALREADY IN NON-0 SECTION?
	JRST 0(CX)		;YES, DO NOTHING

;When routine returns via POPJ, it will be in extended section. Fix return
;PC on stack so that section number is zero.

	HRRZS 0(P)		;FIX UP STACK FOR RETURN TO SECTION 0

;Now return to the routine, running in extended section.

	HRLI CX,MSEC1		;MAKE RETURN PC BE IN SECTION 1
	XJRST CX		;DO 30 BIT JRST

;S0ENT - Routine to cause subroutine to run in section 0. Causes automatic return
;to section of caller on return. Called upon entry to a routine that must run
;in section 0

;Invoked via S0.ENT macro (JSP CX,$S0ENT)

;NOTE: The check for PC section assumes that section number and flags
;cannot overlap. Therefore, this is invalid if PC section is greater than 32

$S0ENT::TXNN CX,EXSCBT		;ALREADY IN SECTION 0?
	JRST 0(CX)		;YES, DO NOTHING

;Routine was called from extended section. Jump into section 0 and call
;the routine again.

	JRST @[.+1]		;JUMP INTO SECTION 0
	PUSHJ P,0(CX)		;CONTINUE WITH ROUTINE
	 CAIA			;HERE IF ROUTINE RETURNS +1
	AOS 0(P)		;HANDLE SKIP RETURN

;Routine returned from section 0. Construct flags/PC block on the stack
;so that we can go to extended section.

	ADJSP P,1		;SET ASIDE STACK SPACE
	XSFM 0(P)		;STORE FLAGS
	PUSH P,[MSEC1,,S0ENT1]	;STORE PC IN EXTENDED SECTION
	XJRSTF -1(P)		;JUMP INTO EXTENDED SECTION, KEEPING FLAGS
S0ENT1:	ADJSP P,-2		;FLUSH STACK

;Return from extended section to caller in extended section.

	RET

;Debugging check for code running in section 0.  Invoked
;by TSTMS0 macro defined in PROLOG.

   IFN SEC0SW,<		;IF SECTION 0 CHECKING ENABLED
$TSMS0::TXNE CX,EXSCBT		;NOW IN NON-0 SECTION?
	JRST 0(CX)		;YES, ALL IS WELL
	BUG.(CHK,MCSEC0,APRSRV,SOFT,<MONITOR CODE RUNNING IN SECTION 0>,<<CX,PC>>,<

Cause:	Monitor code which should not be running in section 0 and does
	not expect to run in section 0 has run in section 0.  This should 
	be investigated and fixed. This is under the SEC0SW debug switch 
	and should not be seen in the field.

Data:	PC at which check was made.
>)
	ADJSP P,1		;MAKE STACK SPACE
	XSFM 0(P)		;SAVE FLAGS
	PUSH P,[MSEC1,,TSTM1]	;CONSTRUCT PC, FLAGS
	XJRSTF -1(P)		;JUMP .+1 AND KEEP FLAGS
TSTM1:	ADJSP P,-2		;CLEAN UP STACK
	HRLI CX,MSEC1		;FIX UP LOCAL RETURN
	JRST 0(CX)		;RETURN, NOW IN SE 1
   >			;END SEC0SW

;SECALL -- SUPPORT FOR SECTION CALL TO CALL SECTION 1
;SECALE -- REMOVES THE SECTION NUMBER FROM HIGH ORDER BITS OF -1(P)
; SO POPJ WILL WORK THEN ENTERS SECTION 1
;
; REQUIRES A STACK (P) AND IS CALLED USING THE
; SE1ENT AND SE1CAL MACRO'S
;
; ALWAYS RETURNS +1
;
SECALE::MOVX CX,EXFLBT		;GET FLAGS TO CLEAR
	ANDCAM CX,-1(P)		;CLEAR FLAGS FROM RETURN PC
SECALL::MOVE CX,[MSEC1,,SCALL1]	;SECTION TO ENTER AND LOCAL PC
	HLLM CX,0(P)		;SET IT
	PUSH P,P6		;ASSUME P6 = CX-1
	XSFM P6			;PRESERVE FLAGS
	XJRSTF P6		;ENTER NEW SECTION AND PRESERVE FLAGS
SCALL1:	POP P,P6		;RESTORE AC
	RET			;RETURN

; SE0CAL -- SUBROUTINE TO SUPPORT SE1ENT MACRO
;
; ENTRY SE0ENT (MACRO)
; REQUIRES STACK BUT DOES NOT DESTROY ANYTHING

SE0CAL::JRST @[.+1]
	RET

; SPCSNZ - Skip if Previous Context Section Non Zero
;	   Destroys no ACs but uses the stack

	RESCD			;ASSUME NO SECTION 0 CALLERS HEREAFTER

SPCSNZ::
	PUSH P,T1		; SAVE AN AC
	SETZ T1,		; ZERO THE AC
	XCTU [XHLLI T1,0]	; GET PCS INTO LEFT HALF T1
	SKIPE T1		; PCS NON-ZERO?
	 AOS -1(P)		; YES SO BUMP RETURN PC
	POP P,T1		; GET THE AC BACK
	RET			; RETURN TO CALLER OR CALLER+1


; EXTENDED ADDRESSING BLT SIMULATION FOR CROSSING SECTIONS

; XBLTA SIMULATE AN XBLT 1
;
; CALLING SEQENCE:
;
;	T1	LENGTH TO BLT
;	T2	FROM ADDRESS
;	T3	TO ADDRESS
;	CALL XBLTA
;RETURNS +1 ALWAYS
; PRESERVES T4 AND DESTROYS T1,T2,T3
;

XBLTAT::TLNE T1,-1		;MAKE SURE REASONABLE SIZE
	BUG.(HLT,XBLTAL,APRSRV,SOFT,<XBLTA asked to copy too much>,<<T1,LENGTH>>,<

Cause:	XBLTA was called with a 'length to BLT' of more than one section.
	It is unlikely that the caller really intended to copy this much.

Data:	LENGTH - Number of words XBLTA was asked to copy
>)
XBLTA::	HRRZS T1		;SOME CALLERS DEPEND ON THIS
	XBLT. T1
	RET

;EXTENDED BLT MONITOR TO USER FOR EXTENDED ADDRESSING
;
; CALLING SEQUENCE:
;
;	T1	LENGTH TO BLT
;	T2	FROM ADDRESS
;	T3	TO ADDRESS
;	CALL BLTMU
;		OR
;	CALL BLTMU1

;RETURNS +1 ALWAYS
; PRESERVES T4 ALTERS T1,T2,T3

;BLTMU1 IS ALTERNATE ENTRY POINT THAT APPLIES PREVIOUS CONTEXT
;SECTION TO THE USER'S ADDRESS. THIS IS USED IF THE CALLER HAS
;NOT PREVIOUSLY SET UP A 30-BIT ADDRESS AND WANTS THE SECTION FROM
;WHICH THE USER ENTERED THE MONITOR.

BLTMU1::XSFM CX			;GET FLAGS, INCLUDING PCS
	ANDI CX,EXPCS		;GET JUST PREVIOUS CONTEXT SECTION
	TXNN T3,VSECNO		;USER'S ADDRESS IN NON-ZERO SECTION?
	CAIGE T3,20		;NO. STARTING IN THE AC'S?
	SKIPA			;SECTION GIVEN OR AC'S. DON'T APPLY PCS
	HRL T3,CX		;NEED A SECTION. USE PCS
BLTMU::	HRRZS T1		;ASSURE REASONABLE SIZE
	XCT 1,[XBLT. T1]	;DO PXCT OF XBLT
	RET			;RETURN

; BLTUM -- EXTENDED BLT FROM USER TO MONITOR SPACE

;
; CALLING SEQUENCE:
;
;	T1 -- COUNT OF WORDS TO TRANSFER
;	T2 -- FROM ADDRESS
;	T3 -- TO ADDRESS
;	CALL BLTUM
;RETURNS +1 ALWAYS AND PRESERVES T4 ALTERS T1,T2,T3
;

;BLTUM1 IS ALTERNATE ENTRY POINT THAT APPLIES PREVIOUS CONTEXT
;SECTION TO THE USER'S ADDRESS. THIS IS USED IF THE CALLER HAS
;NOT PREVIOUSLY SET UP A 30-BIT ADDRESS AND WANTS THE SECTION FROM
;WHICH THE USER ENTERED THE MONITOR.

BLTUM1::XSFM CX			;GET FLAGS, INCLUDING PCS
	ANDI CX,EXPCS		;GET JUST PREVIOUS CONTEXT SECTION
	TXNN T2,VSECNO		;USER'S ADDRESS IN NON-ZERO SECTION?
	CAIGE T2,20		;NO. STARTING IN THE AC'S?
	SKIPA			;SECTION GIVEN OR AC'S. DON'T APPLY PCS
	HRL T2,CX		;NEED A SECTION. USE PCS
BLTUM::	HRRZS T1		;ASSURE REASONABL SIZE
	XCT 2,[XBLT. T1]	;DO PXCT OF XBLT
	RET			;RETURN TO CALLER

; BLTUU -- EXTENDED BLT FROM USER TO USER SPACE

;
; CALLING SEQUENCE:
;
;	T1 -- COUNT OF WORDS TO TRANSFER
;	T2 -- FROM ADDRESS
;	T3 -- TO ADDRESS
;	CALL BLTUU
;RETURNS +1 ALWAYS AND PRESERVES T4 ALTERS T1,T2,T3
;

BLTUU::	HRRZS T1		;ASSURE REASONABLE SIZE
	XCT 3,[XBLT. T1]	;DO PXCT OF XBLT
	RET			;RETURN TO CALLER

;COMMON ENTRY AND EXIT ROUTINE FOR STACK VARIABLE FACILITY

.STKST::
.XSTKS::ADJSP P,@0(CX)		;Adjust stack pointer for variables used
	PUSH P,0(CX)		;Save block size for return
	PUSHJ P,1(CX)		;Call routine and return following here
.STKRT::IFSKP.			;Skip return comes here so
	 POP P,CX		;  recover count,
	 MOVNS CX		;  get size for deallocation,
	 ADJSP P,(CX)		;  adjust stack to remove block,
	 AOS 0(P)		;  and now adjust for skip return
	ELSE.			;Now for Non-Skip return so
	 POP P,CX		;  recover count,
	 MOVNS CX		;  get size for deallocation,
	 ADJSP P,(CX)		;  and adjust stack to remove block
	ENDIF.
	RET			;Now just return


;SUPPORT ROUTINE FOR TRVAR

.TRSET::
.XTRST::PUSH P,P6		;Save old frame pointer
	MOVE P6,P		;Set up new frame pointer
	ADJSP P,@0(CX)		;Adjust stack pointer for variables used
	PUSHJ P,1(CX)		;Call routine and return following here
.TRRET::IFSKP.			;Skip return comes here so
	 MOVEM P6,P		;  deallocate space for variables,
	 POP P,P6		;  restore old frame pointer,
	 AOS 0(P)		;  and now adjust for skip return
	ELSE.			;Now for Non-Skip return so
	 MOVEM P6,P		;  deallocate space for variables
	 POP P,P6		;  and restore old frame pointer
	ENDIF.
	RET			;Now just return

;SUPPORT ROUTINE FOR ASUBR

.ASSET::PUSH P,P6		;SAVE AC FOR STACK POINTER
	MOVE P6,P		;SETUP FRAME PTR
	ADJSP P,4		;ALLOCATE SPACE
	DMOVEM T1,1(P6)		;SAVE ARGS
	DMOVEM T3,3(P6)
	PUSHJ P,0(CX)		;CONTINUE ROUTINE
.ASRET:: JRST [	MOVEM P6,P	;NO-SKIP RETURN, CLEAR STACK
		POP P,P6
		RET]
	MOVEM P6,P
	POP P,P6
	RETSKP

;SUPPORT ROUTINE FOR SASUBR

.SASET::PUSH P,P6		;SAVE P6
	MOVE P6,P		;SETUP FRAME POINTER
	ADJSP P,4		;BUMP STACK
	DMOVEM A,1(P6)	;SAVE ARGS
	DMOVEM C,3(P6)
	PUSHJ P,0(CX)		;CONTINUE ROUTINE
.SARET:: JRST [	DMOVE A,1(P6)	;RESTORE
		DMOVE C,3(P6)
		MOVEM P6,P	;NO-SKIP RETURN, CLEAR STACK
		POP P,P6
		POPJ P,]
	DMOVE A,1(P6)		;RESTORE
	DMOVE C,3(P6)
	MOVEM P6,P		;SKIP RETURN, CLEAR STACK
	POP P,P6
	AOS 0(P)
	POPJ P,

;SUPPORT CODE FOR BLSUBR

.ENTER::PUSH P,P6
	MOVE P6,P
	ADD P,0(CX)		;ALLOCATE LOCAL STORAGE
	JUMPGE P,ENTOV		;JUMP IF OVERFLOW
ENTOV1:	PUSHJ P,1(CX)
	 JRST [	MOVE P,P6	;RESET STACK PTR
		JRST ENTX1]
	MOVE P,P6
	AOS -1(P)		;PROPAGATE SKIP
ENTX1:	POP P,P6
	MOVN CX,-1(P)		;get -<n,,n>
	HRRZM CX,-1(P)		;Store 0,,-n
	POP P,CX		;REcover return address
	ADJSP P,@0(P)		;Clean up the stack
	JRST 0(CX)		;RETURN

ENTOV:	MOVE P,P6		;STACK OVERFLOW, UNDO ADD
	PUSH P,CX		;SAVE LOCAL RETURN IN 1(P6)
	HRRZ CX,0(CX)		;GET COUNT
	ADJSP P,-1(CX)		;ALLOCATE SPACE, GET TRAP HERE OR ON PUSH
	MOVE CX,1(P6)		;RESTORE LOCAL RETURN
	JRST ENTOV1		;CHARGE AHEAD
;SUPPORT ROUTINE FOR JSBVAR.
;BUILDS A STACK FRAME AS FOLLOWS
; -5(P) := RETURN PC FROM CALLING PROGRAM
; -4(P) THRU -1(P) := PLACE TO SAVE T1-T4
;  0(P) := PLACE TO SAVE PREVIOUS FRAME PNTR

.JSSET::ADJSP P,5		;BUILD STACK FRAME
	DMOVEM T1,-4(P)		;SAVE T1-T2
	DMOVEM T3,-2(P)		; AND T3-T4
	MOVEM CX,0(P)		;SAVE TEMP
	HLRZ T2,0(CX)		;SIZE OF BLOCK REQUIRED
	NOINT			;PROTECT FREE SPACE
	CALL ASGJFS		;ASSIGN SPACE IN JSB
	IFNSK.
	  MOVE CX,0(P)		;RETURN ADDRS
	  HRRZ T1,0(CX)		;SEE IF USER ERROR ROUTINE?
	  OKINT			;UNDO NOINT ABOVE
	  IFE. T1
	    MOVEI T1,MONX02
	    ITERR
	  ENDIF.
	  DMOVE T1,-4(P)	;RESTORE ACS
	  DMOVE T3,-2(P)
	  MOVEI T1,MONX02	;ERROR CODE
	  ADJSP P,-5		;CLEAN OFF STACK
	  HRRZ CX,0(CX)		;GET ERROR ADDRS
	  JRST 0(CX)		;XFER TO USER ROUTINE
	ENDIF.
	OKINT			;UNDO NOINT ABOVE
	MOVE CX,0(P)		;RESTORE CONTEXT
	MOVEM P6,0(P)		;SAVE PREVIOUS FRAME
	MOVEI P6,1(T1)		;POINT TO FIRST LOC
	DMOVE T1,-4(P)		;RESTORE T1-T4
	DMOVE T3,-2(P)
	PUSHJ P,1(CX)		;RETURN TO CALLER
.JSRET:: SKIPA			;NORMAL RETURN
	AOS -5(P)		; SET UP SKIP RETURN
	DMOVEM T1,-4(P)		;SAVE T1-T4 AGAIN
	DMOVEM T3,-2(P)
	MOVEI T1,JSBFRE		;RELEASE STG FROM HER
	MOVEI T2,-1(P6)		;POINT TO BLOCK
	NOINT			;BE NOINT FOR ENTIRE RELEASE
	CALL RELFRS		;RELEASE IT
	OKINT			;STORAGE FREE
	MOVE P6,0(P)		;RESTORE FRAME PNTR
	DMOVE T1,-4(P)		;RESTORE T1-T4
	DMOVE T3,-2(P)
	ADJSP P,-5		;REMOVE STACK FRAME
	RET			;RETURN APPROPRIATELY

;FACILITY TO SAVE ALL ACS.
;NORMALLY INVOKED BY ACSAV MACRO, = JSP CX,ACSAV0
;DUMMY RETURN PUT ON STACK TO DO AUTOMATIC RESTORE ON RETURN

ACSAV0::ADJSP P,16		;MAKE ROOM FOR 16 ACS
	DMOVEM 0,-15(P)
	DMOVEM 2,-13(P)
	DMOVEM 4,-11(P)
	DMOVEM 6,-7(P)
	DMOVEM 10,-5(P)
	DMOVEM 12,-3(P)
	DMOVEM 14,-1(P)
	PUSHJ P,0(CX)		;CONTINUE ROUTINE, EXIT VIA .+1
ACRET0:: SKIPA			;NO-SKIP ENTRY
	AOS -16(P)		;SKIP ENTRY, PASS IT UPWARD
	DMOVE 0,-15(P)
	DMOVE 2,-13(P)
	DMOVE 4,-11(P)
	DMOVE 6,-7(P)
	DMOVE 10,-5(P)
	DMOVE 12,-3(P)
	DMOVE 14,-1(P)
	ADJSP P,-16		;CLEAR STACK
	RET

;ROUTINES TO SAVE P1-P6, OR Q1-Q3, OR Q1-Q3 AND P1-P6
;CALLED WITH SAVEP, SAVEQ, AND SAVEPQ MACROS

SAVP::	ADJSP P,6		;NEED TO SAVE 6 REGS
	DMOVEM P1,-5(P)
	DMOVEM P3,-3(P)
	DMOVEM P5,-1(P)		;SAVE THEM ALL
	PUSHJ P,0(CX)		;CONTINUE ROUTINE, EXIT VIA .+1
RESTP::	 SKIPA			;NON-SKIP RETURN
	AOS -6(P)		;SKIP RETURN
	DMOVE P1,-5(P)
	DMOVE P3,-3(P)
	DMOVE P5,-1(P)		;RESTORE THEM ALL
	ADJSP P,-6		;FIX UP STACK
	RET			;AND RETURN

.SAV3::				;USED BY ACVAR FACILITY
SAVQ::	ADJSP P,3		;NEED TO SAVE 3 REGS
	DMOVEM Q1,-2(P)		;SAVE Q1 AND Q2
	MOVEM Q3,0(P)		;SAVE Q3
	PUSHJ P,0(CX)		;CONTINUE ROUTINE, EXIT VIA .+1
RESTQ::	 SKIPA			;NON-SKIP RETURN
	AOS -3(P)		;SKIP RETURN
	DMOVE Q1,-2(P)		;RESTORE Q1 AND Q2
	MOVE Q3,0(P)		;RESTORE Q3
	ADJSP P,-3		;CLEAN UP THE STACK
	RET

   IFN Q3+1-P1,<PRINTX ?SAVPQ REQUIRES P1 TO FOLLOW Q3>

SAVPQ::	ADJSP P,11		;GET STACK SPACE
	DMOVEM Q1,-10(P)
	DMOVEM Q3,-6(P)
	DMOVEM P2,-4(P)
	DMOVEM P4,-2(P)
	MOVEM P6,0(P)
	PUSHJ P,0(CX)		;CONTINUE ROUTINE, RETURN VIA .+1
RESTPQ:: SKIPA			;NON-SKIP RETURN
	AOS -11(P)		;SKIP RETURN
	DMOVE Q1,-10(P)
	DMOVE Q3,-6(P)
	DMOVE P2,-4(P)
	DMOVE P4,-2(P)
	MOVE P6,0(P)
	ADJSP P,-11		;FIX UP STACK
	RET

;SAVE/RESTORE TEMP ACS

SAVT::	ADJSP P,4		;NEED FOUR LOCATION
	DMOVEM T1,-3(P)		;SAVE T1 AND T2
	DMOVEM T3,-1(P)		;SAVE T3 AND T4
	PUSHJ P,0(CX)		;CONTINUE ROUTINE, RETURN VIA .+1
RESTT::	 SKIPA			;NO-SKIP RETURN
	AOS -4(P)		;PASS ALONG SKIP RETURN
	DMOVE T1,-3(P)		;RESTORE T1 AND T2
	DMOVE T3,-1(P)		;RESTORE T3 AND T4
	ADJSP P,-4		;CLEAN UP THE STACK
	RET

;VARIOUS AC SAVE COMBINATION - INVOKED BY SAVEAC MACRO

.SAV24::PUSH P,T2
	PUSH P,T3
	PUSH P,T4
	PUSHJ P,0(CX)
	 TRNA
	AOS -3(P)
	POP P,T4
	POP P,T3
	POP P,T2
	RET

.SAV34::PUSH P,T3
	PUSH P,T4
	PUSHJ P,0(CX)
	 TRNA
	AOS -2(P)
	POP P,T4
	POP P,T3
	RET

.SAV44::PUSH P,T4
	PUSHJ P,0(CX)
	 TRNA
	AOS -1(P)
	POP P,T4
	RET

.SAV33::PUSH P,T3
	PUSHJ P,0(CX)
	 TRNA
	AOS -1(P)
	POP P,T3
	RET

.SAV22::PUSH P,T2
	PUSHJ P,0(CX)
	 TRNA
	AOS -1(P)
	POP P,T2
	RET

.SAV11::PUSH P,T1
	PUSHJ P,0(CX)
	 TRNA
	AOS -1(P)
	POP P,T1
	RET

.SAV12::PUSH P,T1
	PUSH P,T2
	PUSHJ P,0(CX)
	 TRNA
	AOS -2(P)
	POP P,T2
	POP P,T1
	RET

.SAV13::PUSH P,T1
	PUSH P,T2
	PUSH P,T3
	PUSHJ P,0(CX)
	 TRNA
	AOS -3(P)
	POP P,T3
	POP P,T2
	POP P,T1
	RET

;SUPPORT ROUTINES FOR AC VARIABLE FACILITY

.SAV1::	PUSH P,Q1
	PUSHJ P,0(CX)		;CONTINUE PROGRAM
	 SKIPA
	AOS -1(P)
	POP P,Q1
	POPJ P,

.SAV2::	ADJSP P,2		;NEED TWO WORDS OF STACK
	DMOVEM Q1,-1(P)		;SAVE REGS
	PUSHJ P,0(CX)
	 SKIPA
	AOS -2(P)
	DMOVE Q1,-1(P)		;RESTORE REGS
	ADJSP P,-2		;CLEAN UP STACK
	POPJ P,

.SAV4::	ADJSP P,4		;NEED TO SAVE FOUR REGS
	DMOVEM Q1,-3(P)		;SAVE Q1 AND Q2
	DMOVEM Q1+2,-1(P)	;SAVE Q3 AND P1
	PUSHJ P,0(CX)
	 SKIPA
	AOS -4(P)
	DMOVE Q1,-3(P)		;RESTORE Q1 AND Q2
	DMOVE Q1+2,-1(P)	;RESTORE Q3 AND P1
	ADJSP P,-4		;CLEAN UP THE STACK
	POPJ P,

.SAV8::	ADJSP P,10		;NEED TO SAVE EIGHT REGS
	DMOVEM Q1,-7(P)
	DMOVEM Q1+2,-5(P)
	DMOVEM Q1+4,-3(P)
	DMOVEM Q1+6,-1(P)
	PUSHJ P,0(CX)
	 SKIPA
	AOS -10(P)
	DMOVE Q1+6,-1(P)
	DMOVE Q1+4,-3(P)
	DMOVE Q1+2,-5(P)
	DMOVE Q1,-7(P)
	ADJSP P,-10		;CLEAN UP THE STACK
	POPJ P,

.SAVP1::PUSH P,P1		; Save it on stack
	CALL 0(CX)		; Call the routine
	 SKIPA			; +1 return
	  AOS -1(P)		; Add to return PC
	POP P,P1		; Restore old one
	RET			; And return

	SUBTTL System Initialization

;The following routines are executed during system initialization before
;paging has been turned on. Locations in the EPT and I/O page are referenced
;virtually even though their physical page numbers must be specified to the
;hardware. This is legal because, with paging off, virtual page n and physical
;page n are the same.

;PIRST - Clear PI system

;Invoked via XCT PIRST

   IFN KLFLG,<
PIRST::	CONO PI,PICLPI
   >				;END OF IFN KLFLG
   IFN KCFLG,<
PIRST::	WRPI PICLPI
   >				;END OF IFN KCFLG

;IORST - Reset I/O and put machine into a known state. Clear all flags that
;can cause errors. Turn off paging. Preserve the state of the cache as
;the front end set it. Set the current UPT to be the scheduler's UPT.
;NOTE:	 This routine does not change the page number of the EPT

   IFN KLFLG,<
IORST::	JSP T1,IORST0		;Done by XCT IORST only

IORST0:	MOVEM T1,CONOPG		;SAVE AN AC

;Set up the standard word for CONO PAG. Preserve the state of the cache as
;it was set by the front end and preserve the current EPT. Turn off paging.
;Initialize CASHF to reflect the state of the cache (-1 means on, 0 means off)

	CONI PAG,T1		;READ THE CACHE BITS
	ANDI T1,PGCLKE!PGCLDE!PGEBRM	;CLEAR ALL BUT CACHE & EBR
	SETZM CASHF		;INITIALIZE CACHE FLAG
	TRNE T1,PGCLKE!PGCLDE	;IS CACHE ON?
	SETOM CASHF		;YES, REMEMBER THAT
	EXCH T1,CONOPG		;SAVE THE PAGER CONO BITS

;Clear APR conditions, and issue IO reset.

	CONO APR,APIOPR+APFCLR+APSBER+APNXM+APIOPF+APMPE+APAPE+APPWF+APSWPD
	CONO PAG,@CONOPG 	;CLEAR PAGING AND CACHE

;Tell hardware to use special UPT for now

	DATAO PAG,KIPGW0 ;USE SCHED CONTEXT UPT
	JRST 0(T1)
   >				;END IFN KLFLG

   IFN KCFLG,<
IORST::	JSP T1,IORST0

IORST0:	MOVEM T1,CONOPG		;SAVE AN AC
	SETZM CASHF		;PRETEND THAT CACHE IS ALWAYS OFF

;Set up the standard word for WREBR. Preserve the current EPT.
;Turn off paging by clearing PGENPG. Turn off trap processing by
;setting PGLTPE and clearing PGENTP.

	RDEBR T1		;GET CURRENT EPT BASE
	ANDX T1,PGEBRM		;CLEAR PAGING BITS, KEEP EBR
	TXO T1,PGLTPE		;LOAD TRAP ENABLE (TURN OFF TRAPS)
	EXCH T1,CONOPG		;SAVE THE PAGER CONO BITS, RESTORE AC

;Clear APR conditions, and issue IO reset.

	WRAPR APIOPR+APFCLR+APPWF+APCONS ;CLEAR ERROR CONDITIONS, RESET IO
	WREBR CONOPG		;TURN OFF PAGING

;Tell hardware to use special UPT for now

	WRCTX KIPGW0		;USE SCHED CONTEXT UPT
	JRST 0(T1)
   >				;END IFN KCFLG

;* * * * *
;Need to define default port interrupt vector words
; * * * * *

;PAGRST - Called during system startup to initialize data for turning on
;paging.  Paging is assumed to be turned off, and virtual-to-physical mapping
;is one-to-one.

   IFN KLFLG,<

;Initialize standard word used in DATAO PAG. This will load the UBR
;to point to the scheduler's hardware page table.

PAGRST::
	MOVEI T1,KIEPT/PGSIZ	;PAGE NUMBER OF EPT
	DPB T1,[POINTR CONOPG,PGEBRM]	;STORE FOR PGRON/PGROFF
	MOVE 1,KIPGW0
	TXZ T1,PGNSAC		;STORE ACCOUNT DATA FROM NOW ON
	MOVEM 1,KIPGWD		;SET UP FOR DATAO PAG

;Initialize the EPT by copying the prototype version. Initialize the
;scheduler's UPT by copying the prototype.

	MOVE 1,[XWD IEPT0,EPTTPI]
	BLT 1,EPTTPI+NIEPT-1
	MOVE 1,[IUPT0,,SKHWPT+420]
	BLT 1,SKHWPT+437	;INIT SYSTEM HWPT

;Set the previous AC block to block 6. Use this to initialize SPT base
;register, CST base register, CST mask and data.

	DATAO PAG,SETHWR	;SET TO REFERENCE HARDWARE RESERVED ACS
	MOVEI T1,SPT		;DECLARE SPT BASE
	UMOVEM T1,SPTBR		;(WORD IN RESERVED AC BLOCK)
	MOVE T1,CSTLOC		;PHYSICAL LOC OF CST0
	UMOVEM T1,CSTBR		;(WORD IN RESERVED AC BLOCK)
	MOVX T1,XGAGE+CORMB+PSTFLD+CSWRB  ;SET BITS TO BE PRESERVED ON PAGER REFILL
	UMOVEM T1,CSTMSK	;(WORD IN RESERVED AC BLOCK)
	MOVX T1,PSASM		;SET AGE TO ARBITRARY LEGAL VALUE
	UMOVEM T1,CSTDAT	;(WORD IN RESERVED AC BLOCK)
	DATAO PAG,SETMON	;SET TO MONITOR ACS

;Initialize new PC for page fail in the scheduler.

	MOVE A,[KIPFS]		;SETUP PAGE FAIL DISPATCH
	MOVEM A,UPTPFN-HWPTA+SKHWPT ;SETUP PAGE FAIL DISPATCH

;DDT works better if this is done. (Why? I dont know! But its the
; result of 4 days debugging of a problem....)
	CONI PAG,T1		;Read PAGER status
	CONO PAG,(T1)		; and write it back resetting pager
	RET
   >				;END IFN KLFLG

   IFN KCFLG,<

;Initialize standard word used in DATAO PAG. This will load the UBR to
;point to the scheduler's hardware page table.

PAGRST::
	MOVEI T1,KIEPT/PGSIZ	;PAGE NUMBER OF EPT
	DPB T1,[POINTR CONOPG,PGEBRM]	;STORE FOR PGRON/PGROFF
	MOVE T1,KIPGW0
	TXZ T1,PGNSAC		;UPDATE ACCOUNTS FROM NOW ON
	MOVEM T1,KIPGWD		;SET UP FOR WRCTX
	SETZM KIPGWD+1		;NOT USED, BUT THIS SHOULD AVOID CONFUSION

;Initialize the EPT by copying the prototype version. Initialize the
;scheduler's UPT by copying the prototype.

	MOVE T1,[XWD IEPT0,EPTTPI]
	BLT T1,EPTTPI+NIEPT-1	;INIT TRAP FUNCTION WORDS IN EPT
	MOVE T1,[IUPT0,,SKHWPT+420] ;INIT TRAP FUNCTION WORDS AND MUUO
	BLT T1,SKHWPT+420+NIUPT-1 ; BLOCKS IN UPT

;Initialize SPT base register, CST base register, CST mask and data.

	MOVEI T1,SPT		;DECLARE SPT BASE
	WRSPB T1
	XMOVEI T1,@CST0X	;DECLARE CST BASE
	WRCSB T1
	MOVX T1,XGAGE+CORMB+PSTFLD+CSWRB  ;SET BITS TO BE PRESERVED ON PAGER REFILL
	WRCSTM T1
	MOVX T1,PSASM		;SET AGE TO ARBITRARY LEGAL VALUE
	WRPUR T1

;Initialize new PC for page fail in the scheduler.

	MOVE T1,[KIPFS]		;SETUP PAGE FAIL DISPATCH
	MOVEM T1,KCPFNP-HWPTA+SKHWPT ;SETUP PAGE FAIL DISPATCH
	MOVX T1,MONENV		;NEW FLAGS WORD
	MOVEM T1,KCPFNF-HWPTA+SKHWPT ;STORE IN THE UPT

;Set up standard word for WREBR to turn on KL paging and enable
;trap processing. Note that WREBR is not done here.

	MOVX T1,PG20MD+PGENPG+PGENTP
	IORM A,CONOPG		;USE KL MODE PAGING
	RET

   >				;END IFN KCFLG

;SETPFH - Set the page fault handler
;ACCEPTS:
;	T1/ ADDRESS OF ROUTINE
;	CALL SETPFH

;RETURNS +1: ALWAYS

;This routine is called from PGRINI to set the page fault handler address
;in the UPT. It assumes that the caller has done a WRUBR setting the
;scheduler's UPT (SKHWPT) to be the UPT. This stores the routine in the
;"new PC" word for page faults.

SETPFH::
   IFN KLFLG,<
	MOVEM T1,UPTPFN-HWPTA+SKHWPT
   >
   IFN KCFLG,<
	MOVEM T1,KCPFNP-HWPTA+SKHWPT
   >
	RET

	SUBTTL PI System Initialization

;Initialize nonvectored interrupt words in EPT for KL, or software-
;requested interrupts in the IOPAGE for KC

PVINIT::MOVSI T4,-NPISET
	MOVEI T2,VECST		;POINT TO FIRST WORD IN I/O PAGE OR EPT
PIINI1:	MOVE T1,PIVEC(T4)	;GET THE VECTOR WORD
	MOVEM T1,0(T2)		;STORE IT IN I/O PAGE OR EPT
	ADDI T2,VECINC		;INCREMENT TO NEXT LEVEL
	AOBJN T4,PIINI1		;LOOP THROUGH ALL WORDS

;Set up instructions for front end to execute on power failure and
;keep-alive cease

	MOVE T1,[JRST PWRRST]	;INITIALIZE LOCATION EXECUTED BY FRONT END
	MOVEM T1,PWRTRP		; ON POWER FAILURE
	MOVE T1,[XPCW RLODPC]	;INITIALIZE LOCATION EXECUTED BY FRONT END
	MOVEM T1,RLDADR		; ON KEEP-ALIVE CEASE
	SETZM FEFLG		;FORCE SECONDARY PROTOCOL

;Set up for LUUO from EXEC section 0. This causes location 41 to be
;executed. This will lead to a BUGHLT.

	MOVE T1,[XPCW LUUBLK]	;SET UP BUGHLT FOR LUUO'S
	MOVEM T1,41

   IFN KCFLG,<

;Initialize locations in the I/O page for APR interrupt and I/O page fail.

	MOVE T2,[PIAPRX]	;GO TO PIAPR ON APR INTERRUPT
	XMOVEI T1,KCIOPG	;POINT TO THE I/O PAGE
	MOVEM T2,IOPAPR(T1)	;TELL HARDWARE WHERE XPCW BLOCK IS
	MOVX T2,MONENV		;NEW FLAGS WORD
	MOVE T3,[MSEC1,,APRFAT]	;GO HERE WHEN I/O PAGE FAIL OCCURS
	DMOVEM T2,IOPNPC(T1)	;POINT TO IT FROM THE I/O PAGE
;Note: In theory this instruction is unnecessary. The console should initialize
;this value to page 1, which is what the monitor expects. For now we'll be
;paranoid and do it since we've just initialized the things that we need.

   >; End of IFN KCFLG

	RET

; Initialize the PI system.  Turn on the meters, and start the system clock.

PSINIT::
   IFN KLFLG,<
	SKIPL PWRDWN		;DOING POWER-FAIL RESTART
	CALL DTEINS		;START MONITOR IN SECONDARY PROTOCOL
	CALL MEMLOK		;LOOKUP MEMORY TYPES
   >				;END IFN KLFLG

   IFN KCFLG,<
	WRIOP KCIPHY		;SET THE PAGE NUMBER OF THE I/O PAGE
   >				;END OF IFN KCFLG

;Initialize the clocks

	CALL CLKINI		;INIT INTERVAL TIMER, ETC.

;Clear APR condition flags, turn on all interrupt levels and interrupt system,
;and enable interrupts for all conditions. On the KC, this is also the first
;time we have assigned the interrupt level.

   IFN KLFLG,<
	CONOAPR APFCLR+APSBER+APNXM+APIOPF+APMPE+APCDPE+APAPE+APPWF
	CONO PI,PICHON+PIPION+PICHNM
	CONOAPR APEINT+APSBER+APNXM+APIOPF+APMPE+APCDPE+APAPE+APPWF
   >				;END IFN KLFLG
   IFN KCFLG,<
	WRAPR APFCLR+APPWF+APCONS
	WRPI PICHON+PIPION+PICHNM
	WRAPR APLDPI+APEINT+APPWF+APCONS+FLD(APRCHN,APPIA)
   >				;END OF IFN KCFLG
	RET

;Here when unexpected interrupt occurs. On KL, unvectored interrupt comes
;here. On KC, software-requested interrupt comes here.

;Level 0

PIERR0:	PIOFF			;TURN OFF PIS
	DMOVEM CX,PIXCX		;SAVE SOME ACS
	MOVE P,[IOWD XPISK,PIXSTK] ;GET A STACK
	BUG.(HLT,PI0ERR,APRSRV,HARD,<Unvectored interrupt on channel 0>,,<

Cause:	The monitor has received an unvectored hardware interrupt on PI
	channel 0.  This is not supposed to happen. This could possibly
	be faulty hardware generating incorrect PI requests.

>)
	HALT .			;JUST IN CASE

;Level 1

PIERR1:	PIOFF			;TURN OFF PIS
	DMOVEM CX,PIXCX		;SAVE REGS
	MOVE P,[IOWD XPISK,PIXSTK]
	BUG.(CHK,PI1ERR,APRSRV,HARD,<Unexpected unvectored interrupt on channel 1>,,<

Cause:	The monitor has received an unvectored hardware interrupt on PI
	channel 1.  Currently, there is no processing assigned to this
	channel.  This could possibly indicate faulty hardware that is
	generating spurious PI requests.
>,,<DB%NND>)			;[7.1210]
	CLSB 1			;CLEAR THE INTERRUPT ON 1
	DMOVE CX,PIXCX
	PION
	XJEN PI1ER		;DISMISS INTERRUPT AND RETURN

;Level 2

PIERR2:	PIOFF			;TURN OFF PIS
	DMOVEM CX,PIXCX
	MOVE P,[IOWD XPISK,PIXSTK]
	BUG.(CHK,PI2ERR,APRSRV,HARD,<Unexpected unvectored interrupt on channel 2>,,<

Cause:	The monitor has received an unvectored hardware interrupt on PI
	channel 2.  Currently, there is no processing assigned to this
	channel.  This could possibly indicate faulty hardware that is
	generating spurious PI requests.
>,,<DB%NND>)			;[7.1210]
	CLSB 2			;CLEAR THE INTERRUPT ON 2
	DMOVE CX,PIXCX
	PION
	XJEN PI2ER		;DISMISS INTERRUPT AND RETURN

   IFN KCFLG,<
;Level 3

PIERR3:	PIOFF			;TURN OFF PIS
	DMOVEM CX,PIXCX		;SAVE REGS
	MOVE P,[IOWD XPISK,PIXSTK]
	BUG.(CHK,PI3ERR,APRSRV,HARD,<Unexpected unvectored interrupt on channel 3>,,<

Cause:	The monitor has received an unvectored hardware interrupt on PI
	channel 3.  Currently, there is no processing assigned to this
	channel.  This could possibly indicate faulty hardware that is
	generating spurious PI requests.
>)
	CLSB 3			;CLEAR THE INTERRUPT ON 3
	DMOVE CX,PIXCX
	PION
	XJEN PI3ER		;DISMISS INTERRUPT AND RETURN
   >				;END OF IFN KCFLG

;Level 4

PIERR4:	PIOFF
	DMOVEM CX,PIXCX
	MOVE P,[IOWD XPISK,PIXSTK]
	BUG.(CHK,PI4ERR,APRSRV,HARD,<Unexpected unvectored interrupt on channel 4>,,<

Cause:	The monitor has received an unvectored hardware interrupt on PI
	channel 4.  Currently, there is no processing assigned to this
	channel.  This could possibly indicate faulty hardware that is
	generating spurious PI requests.
>,,<DB%NND>)			;[7.1210]
	CLSB 4			;CLEAR THE INTERRUPT ON 4
	DMOVE CX,PIXCX
	PION
	XJEN PI4ER		;DISMISS INTERRUPT AND RETURN


;Here when monitor executes an LUUO in section 0.
;PIINIT makes 41 point to this XPCW block

LUUBUG:	BUG.(HLT,LUUMN0,APRSRV,SOFT,<LUUO in monitor context>,,<

Cause:	While running in section 0, the monitor has executed an LUUO.
	The flags and PC are stored in LUUBLK and LUUBLK+1, respectively.
>)


;FIND MEMORY TYPES AND BUILD TABLE

   IFN KLFLG,<
MEMLOK:	MOVSI T1,-40		;# OF CONTROLLERS
MEMLK1:	MOVEI T2,1		;FUNC 1
	DPB T1,[POINT 5,T2,4]	;SET CONTROLLER NUMBER
	SBDIAG T2		;GET BOUNDS
	LOAD T2,MEMTYP,T3	;GET MEM TYPE
	CAIE T2,MA20
	CAIN T2,MB20
	JRST MEMLK5		;MA/MB HAVE UPPER LOWER BOUNDS
	CAIN T2,MOS
	JRST MEMLK6		;MOS MUST BE POLLED
MEMLK4:	AOBJN T1,MEMLK1		;CHECK ALL CONTROLLERS
	RET			;NOW, BIT OFF MEANS EXT OR NON-EX

MEMLK5:	TRNN T3,ARQENB		;ANY REQUESTS ENABLED?
	JRST MEMLK4		;NO, SKIP THIS ONE
	LDB T2,[POINT 8,T3,21]	;GET LOWER BOUND
	LDB T3,[POINT 4,T3,25]	;GET UPPER BOUND
	SUBI T3,(T2)
	ANDI T3,17		;GET NUMBER OF HUNKS - 1
	MOVNI T3,1(T3)		;MAKE IT - NUMBER OF HUNKS
	HRL T2,T3		;MAKE AOBJN POINTER
MEMLK2:	HRRZ T3,T2		;HUNK # IN T3
	CALL STHUNK
	AOBJN T2,MEMLK2		;NEXT HUNK
	JRST MEMLK4

MEMLK6:	TXNE T3,MOSDBL		;DISABLED?
	JRST MEMLK4		;YES, SKIP IT
	MOVEI T2,12		;FUNC 12
	DPB T1,[POINT 5,T2,4]	;SET CONTROLLER NUMBER
MEMLK7:	SBDIAG T2
	TXNE T3,MFBXDS		;DESELECTED?
	JRST MEMLK8		;YES, SKIP
	LDB T3,[POINT 8,T2,27]	;GET BOX #
	CALL STHUNK		;SET BIT FOR HUNK
MEMLK8:	ADDI T2,1B27		;INC BOX #
	TXNN T2,1B19		;OVERFLOWED?
	JRST MEMLK7		;NO, KEEP GOING
	JRST MEMLK4

;CALL WITH 16K HUNK # IN T3
STHUNK:	CAIL T3,NMD16K		;LEGAL HUNK?
	RET
	IDIVI T3,^D36		;GET WORD AND BIT #
	MOVE T4,BITS(T4)	;GET BIT
	IORM T4,MEMTAB(T3)	;AND LIGHT IT
	RET
   >				;END IFN KLFLG
;RESTORE APR PI ASSIGNMENT

SETPPI::CONOAPR 0
	SUBTTL APR Interrupt Service

   IFN KCFLG,<

;Here when the hardware generates an APR interrupt. The I/O page points to a
;4-word block at PIAPRX, which contains this location as the new PC. It also
;selects a special AC block for APR interrupts. Thus no AC-saving is required.

PIAPR:	MOVE P,[IOWD APRSIZ,APRSTK] ;LOCAL STACK
	SZAPR APPWF		;IS IT A POWER FAILURE?
	JRST [	WRAPR APDINT+APPWF ;YES. DISABLE FURTHER INTERRUPTS ON THIS CONDITION
		AOS PWRDWN	;SIGNAL THIS TO SCHED
		AOS SKEDF3	;GET SCHEDULER TO RUN
		ISB SCDCHN	;ISSUE CHANNEL 7 INTERRUPT
		JRST PIAP5]	;DISMISS THE INTERRUPT
	SZAPR APCONS		;CONSOLE DID SOMETHING?
	CALL [	WRAPR APFCLR+APCONS ;CLEAR CONDITION
		CALL CNINTC	;GO DO THE PROCESSING.
		JRST PIAP5]

;Here when an APR interrupt occurred but there's no condition bit set in the
;APR word. Record this and dismiss the interrupt.

	BUG.(CHK,SPUAPR,APRSRV,HARD,<SPURIOUS APR INTERRUPT>,,<

Cause:	An APR interrupt occurred but no condition bit was set.

>)
PIAP5:	XJEN PIAPRX		;DISMISS THE INTERRUPT
   >				;END OF IFN KCFLG

;What happens on a power failure:

;APR interrupt leads to PIAPR. PIAPR AOS's PWRDWN, which was initialized to 0,
;and signals the scheduler to run.  SPWFFL is set to zero assuming that the 
;power fail is a real one.

;Scheduler goes to SCHPRF, which dismisses the running fork and executes any
;special code pointed to by PWRFLE. It JRST's to SCHPF0 in APRSRV.

;SCHPF0 SETOM's PWRDWN and waits in a loop for power to go away.  If it is a 
;real power fail, the front end will start the monitor at location 70 before 
;the loop is done.  However, if it is spurious, the loop will complete, a
;SPWRFL BUGCHK is issued, SPWFFL is set to -1 to indicate spurious, and the
;system is restarted at SYSRST.

;After the failure, the front end starts the monitor at location 70, which
;contains JRST PWRRST.

;At PWRRST, the following conditions are possible:
;	PWRDWN/ 0 -- we never saw the interrupt - PWRFL BUGHLT
;	PWRDWN .GT. 0 -- we didn't have time to finish shutting down - PWRFL
;	PWRDWN/ -1 -- we finished shutting down in time - restart at PWRRS1

;Here on APR interrupt.

   IFN KLFLG,<
PIAPR:	DATAI PAG,MEMPDP	;SAVE STATE
	DATAO PAG,SETAPI	;SET APR STATE
	CONSZ APR,APPWF		;POWER FAIL?
	JRST [	CONOAPR APDINT+APPWF ;YES, DISABLE FLAG
		AOS PWRDWN	;NOTIFY SCHED, ETC.
		SETZM SPWFFL	;Assume it is not spurious
		AOS SKEDF3	;SIGNAL SCHEDULER
		ISB SCDCHN	; ""
		JRST OV0]	;DEBREAK
;	MOVEI P,^D10000
;	SOJG P,.		;WAIT FOR CONDITIONS TO SETTLE
	MOVE P,[IOWD NMEMPP,MEMPP] ;GET A STACK FOR STATUS BLOCK
	MOVEI T1,APRBUG-BUGBUG	;GET TYPE OF ERROR
	CALL GENBLK		;DO ERROR REPORTING IF ENABLED

;Get the APR conditions and transfer according to them.

	CONI APR,A		;GET CONI BITS FOR POSSIBLE BUGHLT
	CONSZ APR,APIOPF	;IO PAGE FAIL?
	JRST APRIOP		;GO SEE ABOUT THE PAGE FAIL
	CONSZ APR,APAPE		;ADDRESS PARITY ERROR?
	JRST ADRPER		;YES. GO DO IT
	CONSZ APR,APNXM		;NXM?
	JRST P1NXM		;YES
	CLSB APRCHN		;CLEAR SOFTWARE REQUEST IF ANY
	CONSZ APR,APSBER	;SBUS ERROR?
	JRST SBSERR		;YES. GO POLL SBUS CONTROLLERS
	SKIPN DEVMPE		;DEVICE MPE REQUEST?
	CONSZ APR,APMPE		;MEM PAR ERROR?
	JRST MEMPAR		;YES. MEMORY SCAN
	CONSZ APR,APCDPE	;CACHE DIR PARITY ERROR?
	BUG.(HLT,FATCDP,APRSRV,HARD,<Fatal cache directory parity error>,<<A,CONIAP>>,<

Cause:	An APR interrupt occurred because a physical page number with
	even parity was encountered in the cache directory.

Data:	CONIAP - Result of CONI APR
>)
	JRST OV0		;GO DEBREAK

;P1NXM - Here on NXM (APNXM set in CONI word)

P1NXM:	PIOFF			;OWN THE MACHINE
	MOVE P,[IOWD NMEMPP,MEMPP] ;SET UP A STACK
	MOVEI T1,[SIXBIT '$$NXM DETECTED BY /']
	CALL APRCMN		;DO COMMON STUFF
	PION			;AND RESTORE MACHINE
	BUG.(HLT,APRNX1,APRSRV,HARD,<NXM detected by APR>,,<

Cause:	An APR interrupt occurred because the processor attempted to
	access a memory that did not respond within a preset time. This
	can indicate broken hardware or a software bug. The monitor
	has printed a description of the problem on the CTY.

Action:	The analysis of this BUGHLT is extremely complicated.
	The physical address from the error register is printed on the
	CTY ("ERA="). If there is physical memory at this address, the
	problem is probably in the hardware. If the address does not
	exist, the problem may be in either hardware or software.

	One software problem that has led to this BUGHLT in the past
	is code that returns an SPT slot to the free pool while leaving
	a pointer to that slot in some page table. The content of
	the SPT entry, instead of being a pointer to memory, is a
	pointer to another SPT slot.

	In this case, a page fault will have occurred just before the
	interrupt. The PC will point into the page fault handler.  The page
	fault word and PC (TRAPSW and TRAPPC, respectively) will
	indicate the virtual address and instruction at the time of
	the page fault. Tracing this virtual address to the SPT will
	produce the erroneous SPT entry.

	Note, however, that this BUGHLT is rarely caused by software
	in the field. The hardware is probably broken.
 >)		;CAUSE A BUGHLT
	CONOAPR APFCLR+APSBER+APMPE ;CLEAR SUPRIOUS PARITY ERROR INDICATIONS
	CLNXMF			;CLEAR FLAG
	JRST OV0

;COMMON PROCESSING FOR NXM AND ADDRESS PARITY ERROR

;	CALL APRCMN

;RETURNS +1: ALWAYS

APRCMN:	JSR BUGMON		;ENTER SECONDARY PROTOCOL
	JSR BUGMSG
	RDERA T2		;GET THE ERA
	MOVEI T1,[SIXBIT 'APR/'] ;ASSUME APR DETECTED ERROR
	TXNE T2,ER%CHN		;CHANNEL DETECTED?
	MOVEI T1,[SIXBIT 'CHANNEL/'] ;YES
	JSR BUGMSG		;SAY SO
	MOVEI T1,[SIXBIT ', ERA= /']
	JSR BUGMSG		;NEED TO OUPTUT THE ERA
	RDERA T1		;GET THE ERA
	CALL BUGWPT		;OUTPUT IT
	MOVEI T3,PI%SBA+MPISEB
	MOVEI T2,PI%MXS		;MAX SPACE FOR DATA
	CALL RDDIAG		;READ SBUS DIAGS
	HLL T1,T3		;GET COUNT
	HRRI T1,PI%SBA+MPISEB	;WHERE THEY ARE
	CALL PRISBS		;TYPE THEM OUT
	JSR BUGPRI		;RESTORE INCOMING PROTOCOL
	RET			;AND RETURN

;ADRPER - Address parity error (APAPE was on in CONI word)

ADRPER:	PIOFF			;OWN MACHINE
	MOVE P,[IOWD NMEMPP,MEMPP] ;GET A STACK
	MOVEI T1,[SIXBIT '$$ADDRESS PARITY ERROR DETECTED BY /']
	CALL APRCMN		;DO COMMON CODE
	PION			;RESTORE MACHINE
	BUG.(HLT,APRAPE,APRSRV,HARD,<Address parity error>,,<

Cause:	An APR interrupt occurred because a memory controller
	signaled that it received an address with even parity
	from the processor. There is a description of the problem 
	on the CTY.

Action:	Using SBUS diag 0 for all memory controllers, check the
	address parity error bit(s). Test the bus and controller.
>)
	CONOAPR APFCLR+APAPE+APSBER ;CLEAR ERROOR
	CLNXMF			;CLEAR NXM INDICATORS
	JRST OV0		;AND TRY AGAIN
   >				;END IFN KLFLG

   IFN SMFLG,<
PIAPR:	XWD PIAPRX,.+1
	CONSZ APR,APTMR		;TIMER REQUEST?
	JRST TIMIN0		;YES -- GO DO TIMER
	CONSZ APR,APINK		;CTY INTERRUPT?
	JRST [	ISB DLSCHN	;REQUEST TERMINAL INTERRUPT
		CONO APR,APFCLR+APINK+APRCHN ;CLEAR INTERRUPTING FLAG
		XJEN PIAPRX]	;EXIT
	CONSZ APR,APPWF		;POWER FAIL?
	JRST [	CONO APR,APDINT+APPWF ;YES, DISABLE FLAG
		AOS PWRDWN	;NOTIFY SCHED, ETC.
		CHKINT
		XJEN PIAPRX]	;DEBREAK
	CONSZ APR,APNXM		;NXM?
	JRST P1NXM		;YES
	CLSB APRCHN		;CLEAR SOFTWARE REQUEST IF ANY
	XJEN PIAPRX		;RETURN

P1NXM:	BUG(APRNX1)
	CONOAPR APFCLR+APHMP+APSMP ;CLEAR SUPRIOUS PARITY ERROR
	CLNXMF			;CLEAR FLAG
	XJEN PIAPRX
   >				;END IFN SMFLG


;EXIT FROM APR PI SERVICE

OV0:	DATAO PAG,MEMPDP	;RESTORE ACS
	XJEN PIAPRX		;Dismiss the interrupt

;FINAL PHASE OF POWERDOWN SEQUENCE, ENTERED FROM SCHED
;THIS WILL LOOP IN THE ACS UNTIL POWER ACTUALLY VANISHES.
;IF THE POWER FAIL INTERRUPT WAS SPURIOUS, THE LOOP WILL TIME OUT
;AFTER A FEW SECONDS AND THE SYSTEM WILL BE CONTINUED.

SCHPF0::PIOFF			;QUIET DOWN MACHINE
	SETOM PWRDWN		;SAYS WE FINISHED PWR DWN SEQUENCE
	DMOVE Q1,[SOJG T1,Q1	;PUT COUNT LOOP IN ACS
		JRST SCHPR2]
	MOVX T1,^D5000000	;INIT COUNT.  DEPENDING ON MACHINE
	JRST Q1			; SPEED, THIS WILL TAKE FROM 1 TO 20 SECS

;Timed out. BUGCHK and go restart as if front end had restarted us.

SCHPR2:	XCT KEPALV		;Update keep alive counter
	BUG.(CHK,SPWRFL,APRSRV,HARD,<Spurious power fail indication>,,<

Cause:	A power-fail indication was given and the monitor has
	executed its sequence for an orderly power-down. The machine
	is still running after a long delay, so the monitor has
	declared the power-fail warning to be a mistake. The system
	will restart as if power had failed.
>,,<DB%NND>)			;[7.1210]
	SETOM SPWFFL		;Indicate that it was spurious
	JRST SYSRST		;GO RESTART IMMEDIATELY

;I/O PAGE FAIL DETECTED. IF ON A KL10, SEE IF IT WAS CAUSED BY
;A MISCREANT FE

	IFN KLFLG,<		;IF THE KL

;Note Well....As of KL microcode version 275
;
;	IO Page Fails now return the IOP word in AC block 7 AC 2.
;	The IOP word will also be in UPTPFW.  If the IOPGF should
;	happen during the initial code of page fault handling before
;	UPTPFW is saved in a permanent location then the monitor will get very
;	confused.

IOPDEV==17B10			;DEVICE FIELD IN IOP WORD
IODTE0==10			;CODE FOR DTE0
IODTE3==13			;CODE FOR DTE3
IODIA==17			;IO BUS

APRIOP:	PIOFF			;PREVENT INTS
	JSR BUGMON		;GET IN SECONDARY PROTOCOL
	MOVE P,[IOWD NMEMPP,MEMPP] ;BORROW PAR ERROR STACK
	UMOVE Q1,BK7IOP		;GET THE IOP WORD
	MOVEI T1,[SIXBIT "$$IO PAGE FAIL, IOP= /"]
	JSR BUGMSG		;TELL CTY
	MOVE T1,Q1
	CALL BUGWPT		;AND OUTPUT THE IOP
	MOVEI T1,[SIXBIT "$$/"]
	JSR BUGMSG		;MAKE IT PRETTY
	LOAD T1,IOPDEV,Q1	;GET DEVICE CODE
	CAIL T1,IODTE0		;CHECK FOR A DTE
	CAILE T1,IODTE3		;IS IT?
	IFSKP.			;IF SKIP, IT IS
	 SUBI T1,IODTE0		;COMPUTE DEVICE NUMBER
	 CAMN T1,MSTRDT		;IS THIS THE MASTER?
	 JRST APRFAT		;YES. CAN'T SHUT IT OFF
	 CALL DTEIOP		;SHUT OFF THE DTE
	ELSE.
	 CAIE T1,IODIA		;IS THE DEVICE ON THE IOBUS?
	 JRST APRFAT		;NO
	 LOAD T1,VPGNO,Q1	;GET VIRTUAL PAGE ADDRESS
	 CALL IMPFPF		;SEE IF AN20 DID IT
	  JRST APRFAT		;NO. CAN'T RECOVER THEN
	ENDIF.
APRIO0:	JSR BUGPRI		;ENTER PRIMARY PROTOCOL
;	MOVEI T1,IOBUG-BUGBUG	;INDEX TO PROPER MESSAGE
;	CALL GENBLK		;REPORT THE PROBLEM
	CONOAPR APFCLR+APIOPF	;TURN OFF THE INDICATOR
	PION			;TURN ON INTS
	JRST OV0		;AND LET IT GO
   >				;END OF IFN KLFLG

;Could not find the reason for the IO page fail, or the condition
;was caused by something we can't proceed without having.

APRFAT:	BUG.(HLT,IOPGF,APRSRV,SOFT,<IO page fail>,<<Q1,IOP>>,<

Cause:	An APR interrupt occurred because an interrupt instruction caused
	a page failure. This probably indicates that the interrupt instruction
	provided by the monitor referenced a page that was not in memory.
	The monitor has already checked for a DTE that made the reference
	and found none. (However, it is possible for a software bug
	to cause a DTE to generate an I/O page fail that the monitor
	cannot detect.)  The monitor has printed a description of the problem 
	on the CTY.

Data:	IOP - IOP word

>)

;BUGHLT GOTTEN TO BY AN XCT 71 DONE BY THE FE (OR THE OPERATOR)
;ON A KEEP ALIVE CEASED. THE PC IS IN RLODPC AND RLODPC+1

RLDHLT::BUG.(HLT,KPALVH,APRSRV,SOFT,<Keep alive ceased>,,<

Cause:	The immediate cause of this BUGHLT is the execution of
	location 71. The front end does this if the monitor has
	not updated its keep-alive counter recently. This usually
	indicates that the monitor is looping and preventing the
	scheduler from running. This can be due to a software
	bug or hardware that interrupts abnormally frequently.
	This BUGHLT can be caused manually by requesting the
	front end to jump to location 71.

Action:	Look at the CTY output to see which case occurred. Look at
	the PC to see where the monitor was running. If the crash was 
	done manually, the PC will contain 72.
>)

;ROUTINE USED BY PHYSIO TO OUTPUT RH20/CHANNEL MEMORY
;ERROR INFORMATION
;	T1/ CHANNEL NUMBER
;	T2/ LOGOUT STATUS WORD
;	T3/ UPDATED CCW
;STACK MUST BE SET UP
;REGRETTABLY CLOBBERS T1-T4

   IFN KLFLG,<			;ONLY NEEDED FOR THE KL
APRRPT::SAVEQ
	DMOVE Q1,T1		;SAVE ARGS
	MOVE Q3,T3		;SAVE ALL OF THEM
	PIOFF			;OWN MACHINE
	JSR BUGMON		;REALLY OWN IT
	MOVEI T1,[SIXBIT '$$RH20 OR CHANNEL DETECTED MEMORY ERROR$CHANNEL /']
	JSR BUGMSG		;DO THE MESSAGE
	MOVE T1,Q1		;GET CHANNEL #
	CALL BUGOPT		;PRINT IT
	MOVEI T1,[SIXBIT '$CHANNEL STATUS WORD /']
	JSR BUGMSG
	MOVE T1,Q2		;GET WORD
	CALL BUGWPT		;TYPE IT
	MOVEI T1,[SIXBIT '$FINAL CCW /']
	JSR BUGMSG
	MOVE T1,Q3		;GET FINAL CCW
	CALL BUGWPT
	MOVEI T1,[SIXBIT '$$/']
	JSR BUGMSG		;MAKE OUTPUT PRETTY
	JSR BUGPRI		;TURN ON FE
	PION			;TURN ON PIS
	RET			;AND DONE
   >				;END OF IFN KLFLG
;DUMMY ROUTINES FOR HARD PAGE FAILS

IFN KCFLG,<
MASBGX==:0			;DUMMY VALUE TO KEEP PHYSIO HAPPY
MEMPAR::JRST OV0
DEQERR::
MOSULE::
MEMSTR::
	RET
MEMSCN::RETSKP
GENGEN::
UNGEN::
GENBLK::
APRRPT::RET
   >				;END OF IFN KCFLG

	SUBTTL Memory Parity Error routines (KL only)

   IFN KLFLG,<
;MEMPAR - MEMORY PARITY ERROR DETECTED

;Here when APR interrupt occurs with bit 27 (MB parity error) set or
;when APR interrupt occurs with bit 24 (SBUS error) set but no MOS
;controller reports a correctable error

MEMPAR::PIOFF
	MOVE P,[IOWD NMEMPP,MEMPP]
	CONSO APR,APMPE		;MB PARITY ERROR?
	JRST MEMPRX		;NO
	RDERA T1		;GET ERROR INFORMATION
	TXC T1,ER%CHN!ER%WRT	;SEE IF "CHANNEL WRITE" ERROR
	TXNE T1,ER%CHN!ER%WRT	;IS IT?
	JRST MEMPRX		;NO. DO NORMAL PROCESSING

;A CHANNEL WRITE PARITY ERROR HAPPENED. GATHER INFORMATION

	LDB T2,[POINT 2,T1,1]	;GET WORD OFFSET
	ANDX T1,<PHCPNO!PGWD>	;GET PHYSICAL ADDRESS
	IORI T1,0(T2)		;PUT IN WORD OFFSET
	SKIPN T2,WREQ		;ANY QUEUED ENTRIES?
	JRST MEMRXX		;NO
MEMRX0:	CAMN T1,1(T2)		;ALREADY QUEUE?
	JRST NOBLK0		;YEP
	MOVE T2,0(T2)		;GET NEXT
	JUMPN T2,MEMRX0
MEMRXX:	PUSH P,T1		;SAVE ERA
	MOVX T1,<.RESP1,,3>
	MOVX T2,RS%SE0!.RESGP	;FROM GENERAL POOL, SECTION 0
	CALL ASGRES		;GET SOME SPACE
	 JRST [	MOVEI T1,[SIXBIT '$?No free space for channel error$/']
		CALL MEMOUT
		JRST MEMNBK]
	POP P,1(T1)		;SAVE ERROR ADDRESS
	MOVE T2,TODCLK		;TIME
	MOVEM T2,2(T1)		;TIME STAMP
	EXCH T1,WREQ		;ENQUEUE IT
	MOVEM T1,@WREQ		;""

;ADDRESS IS QUEUED ON THE ERROR QUEUE AND ACCOUNTED FOR

MEMNBK: MOVEI Q3,MPISEB		;BLOCK TO STORE ERROR INFORMATION
	CALL PARGER		;GET ERROR STUFF INTO BLOCK
	MOVEI P1,0(T1)		;SAVE COUNT
	ADDI T1,PI%SZ2		;COMPUTE WORDS TO PUT IN SYSERR
	MOVE T2,T1		;COPY WORD COUNT
	CALL ALCSEB		;GET SYSERR BLOCK
	 JRST [	MOVEI T1,[SIXBIT '$? No SYSERR block on channel error$/']
		CALL MEMOUT
		JRST NOBLK0]
	PUSH P,T1		;SAVE BLOCK ADDRESS
	ADDI P1,SEBDAT+PI%SZ2-1(T1) ;WORDS TO MOVE
	MOVEI T1,SEBDAT(T1)	;START OF DEST.
	HRL T1,Q3
	BLT T1,0(P1)		;COPY DATA
	MOVE T1,0(P)
	MOVE T2,[-NMEMPT,,MEMPT]
	CALL SEBCPY		;FINISH OFF DATA COPYING
	 NOP
	POP P,T1
	CALL QUESEB		;AND QUEUE IT
NOBLK0:	CONOAPR APFCLR+APMPE	;CLEAR CONDITION
	CONSO APR,APSBER	;SBUS ERROR PENDING?
	CALL UNLCON		;NO
NOBLKS:	PION			;AND PIS
	JRST OV0		;AND DONE

;Routine to output a message in secondary protocol

MEMOUT:	ASUBR <ERRSTR>
	JSR BUGMON		;STOP MACHINE
	MOVE T1,ERRSTR
	JSR BUGMSG		;DO MESSAGE
	JSR BUGPRI		;BACK TO PRIMARY
	RET			;AND DONE


;NOT A CHANNEL WRITE PARITY ERROR. DO NORMAL PROCESSING

MEMPRX: EA.ENT			;RUN IN SECTION 1
	MOVE T1,MPITIM		;GET TIME OF LAST ERROR
	ADDI T1,^D5000		;PROJECT INTO THE FUTURE
	CAMLE T1,TODCLK		;WITHIN 5 SECS OF LAST ERROR?
	JRST [	CLRMPE		;YES. SKIP THIS ONE
		JRST NOBLKS]	;DONE
	SETZM MEMPFF		;CLEAR FATAL ERROR FLAG
	PUSH P,UPTPFO		;SAVE PAGE TRAP VARIABLES
	PUSH P,UPTPFL
	PUSH P,UPTPFN
	PUSH P,UPTPFW
	XPSHUM [PUSH P,BK7PFD]	;SAVE BAD DATA WORD AS WELL
	MOVEI T1,MEMPTP		;SETUP LOCAL TRAP ROUTINE
	MOVEM T1,UPTPFN
	MOVEI Q3,MPISEB		;SETUP BLOCK TO RECEIVE SYSERR INFO
	CALL PARGER
	MOVE P1,T1		;SAVE COUNT
	CONSO APR,APMPE		;AN MB PARITY ERROR?
	AOS MEMPFF		;NO. REMEMBER THIS
MEMPR0:	CONOAPR APFCLR+APMPE	;CLEAR CONDITION

	; ..

;MEMORY SCAN LOOP. THIS IS EXECUTED ONLY FOR MB PARITY ERRORS DETECTED
;BY THE APR OR BY A CHANNEL READ. THE PAGE CONTAINING THE BAD
;ADDRESS (FROM THE ERA) IS SCANNED FOR ERRORS.

	; ..
	LOAD P2,PHCPNO,PI%ER2(Q3); GET ERROR PAGE
	LOAD T1,CSTAGE,+P2	;GET AGE OF THIS PAGE
	LOAD T2,CSTPST,+P2	;GET STATE
	CAIE T1,PSSPQ		;ON SPECIAL MEM QUEUE?
	CAIN T2,PSTERR		;NO. ALREADY HAVE AN ERROR?
	JRST MEMP45		;YES. NO SCAN THEN
	MOVE T1,CONOPG
	TXZ T1,PGCLDE		;TURN CACHE LOAD OFF
	CONO PAG,0(T1)
	MOVSI Q1,-PGSIZ		;LOOP COUNTER
	PUSH P,@CST0X+P2	;SAVE CST0 FOR THIS PAGE
	MOVX T2,<PSASM+CSWRB>	;SET CST0 TO ALLOW ACCESS TO PAGE
	IORM T2,@CST0X+P2
	MOVE T1,P2
	CALL MAPRCA
	MOVE T4,T1		;SAVE VIRT ADR WHERE MAPPED
	HRLI T4,T3		;MAKE IT INDEXED BY T3
MEMP3:	CALL MEMPXX		;DO THE REFERENCE
	CONSZ APR,APNXM		;NXM?
	JRST MEMP44		;YES. DONE THEN
	CONSZ APR,APMPE+APSBER	;MPE IN THIS LOCATION?
	JRST MEMP1		;YES, GO REPORT IT
MEMP4:	AOBJN Q1,MEMP3 		;DO NEXT LOCATION
MEMP44:	POP P,@CST0X+P2		;RESTORE CST0
	CONO PAG,@CONOPG	;RESTORE CACHE STATE
	; ..

	; ..
MEMP45:	CONSO APR,APSBER	;SBUS ERROR PENDING?
	CALL UNLCON		;NO. CLEAR CONTROLLERS THEN
	MOVEI T1,PI%SZ2
	MOVE T2,P1		;WORDS USED IN SBDIAGS
	ADDB T1,T2		;COMPUTE WORDS NEEDED
	CALL ALCSEB		;ALLOCATE SYSERR DATA BLOCK
	 JRST [	MOVEI 1,[SIXBIT '?NO SYSERR BUFFER FOR MB PARITY ERROR$$/']
		CALL MEMOUT
		JRST MEMP10]	;SKIP SYSERR STUFF
	MOVEM T1,Q1		;SAVE SYSERR BUFFER ADDRESS
	MOVE T2,P1		;WORDS USED IN SBDIAGS
	ADDI T2,SEBDAT+PI%SZ2-1(T1) ;COMPUTE END OF DATA
	MOVEI T1,SEBDAT(Q1)
	HRL T1,Q3		;COPY DATA INTO SYSERR BUFFER
	BLT T1,0(T2)

;Copy data to the buffer, and arrange to have MEMPJ0 run from job 0

	MOVE T1,Q1
	MOVE T2,[-NMEMPT,,MEMPT]
	CALL SEBCPY		;INCLUDE EVENT CODE
	 JFCL
	MOVE T1,Q1
	CALL QUESEB		;QUEUE SYSERR BLOCK
MEMP10:
	XPOPMU [POP P,BK7PFD]	;RESTORE BAD DATA WORD
	POP P,UPTPFW		;RESTORE PAGE TRAP VARIABLES
	POP P,UPTPFN
	POP P,UPTPFL
	POP P,UPTPFO
	; ..

;ALL DONE. RESTORE PROPER PROTCOLS

;	MOVEI T1,MBBUG-BUGBUG	;INDEX TO PROPER MESSAGE
;	CALL GENBLK		;REPORT STATUS
	CALL UPDTCK		;UPDATE TODCLK NOW
	PION
;	BUG(MPEDEV)
	SKIPE MEMPFF		;FATAL ERRORS FOUND?
	JRST MEMP8		;YES
	SETZM DEVMPE
	MOVE T1,TODCLK		;GET NOW
	MOVEM T1,MPITIM		;SET TIME OF MP INTERRUPT
	JRST OV0		;CONTINUE RUNNING

MEMP8:	BUG.(HLT,FATMER,APRSRV,HARD,<Fatal memory error>,,<

Cause:	An APR interrupt occurred indicating an SBUS error and no
	MB parity error. However, no MOS controller reports an error.
	The monitor is unable to determine the cause of the SBUS error.
	The monitor has printed a description of the problem on the CTY.

Action:	Diagnose the memory system.
>)

MEMPT:	SEBPTR 0,SBTEVC,SEC%P1	;EVENT CODE
	SEBPTR 0,SBTFNA,MEMPJ0	;joB 0 CLEANUP ROUTINE
NMEMPT==.-MEMPT

;TEST REFERENCE TO CHECK FOR PARITY ERROR

MEMPXX:	LOAD T3,PGWD,Q1		;GET WORD WITHIN CURRENT PAGE
MEMPXY:	MOVE T1,@T4
	RET

;LOCAL PAGE TRAP ROUTINE. WE EXPECT TO COME HERE WHEN A REFERENCE GENERATES
;AN ERROR DURING THE MEMORY SCAN. PC SHOULD POINT TO MEMPXY.
;IF NOT, SOME OTHER ERROR OCCURRED.

MEMPTP:	HRRZ T1,UPTPFO		;CHECK PC OF TRAP
	CAIE T1,MEMPXY		;FROM EXPECTED PLACE?
	CALL MEMXXX
	CONOAPR APFSET+APMPE	;make damn sure bit is set
	AOS UPTPFO		;SIMULATE COMPLETION OF INSTRUCTION
	UMOVE T1,BK7PFD		;GET BAD DATA FROM AC BLOCK 7
	XJRSTF UPTPFL		;UNTRAP

;Common error place for unexpected page fault. To figure out which
;page fault routine was working, look at UPTPFN!!!

MEMXXX:BUG.(HLT,UNPGF1,APRSRV,HARD,<MEMPAR - Parity error during mem scan>,,<

Cause:	A page fault occurred while the monitor was scanning memory
	looking for an MB parity error. The monitor expects to cause
	such a fault when it references the bad word in memory. However,
	the PC indicates that the error occurred somewhere other than
	in the instruction that is expected to fail.  The monitor has printed
	a description of the problem on the CTY. A SYSERR block has been
	created and will be placed in the SYSERR file when the monitor is
	rebooted.  If the memory scan has detected any errors, the monitor has
	printed a description of them on the CTY, too.
>)		;ERROR!


;FOUND MEM PAR ERR ON DIRECT REFERENCE
; T4/ 3,,ADDRESS
MEMP1:
	PUSH P,T4		;SAVE MAP ADDRESS
	CONOAPR APFCLR+APMPE	;CLEAR APR PE BITS
	MOVE T4,P2		;GET PAGE NUMBER
	LSH T4,PGSFT		;MAKE IT AN ADDRESS
	ADDI T4,0(Q1)		;AND WITH THE RIGHT WORD
	ANDM T1,PI%AD2(Q3)	;COMPUTE LOGICAL AND/OR OF DATA AND ADR
	IORM T1,PI%OD2(Q3)
	ANDM T4,PI%AA2(Q3)
	IORM T4,PI%OR2(Q3)
	MOVE Q2,PI%ERC(Q3)	;GET ERROR COUNT
	AOS PI%ERC(Q3)		;BUMP IT
	CAIL Q2,PI%NB2		;REPORTED MAX NUMBER ERRORS?
	JRST MPEX1		;YES, DON'T REPORT THIS ONE
	ADD Q2,Q3		;OFFSET TO SYSERR BLOCK
	MOVEM T1,PI%DA2(Q2)	;SAVE DATA
	MOVEM T4,PI%BAD(Q2)	;SAVE ADDRESS
	LOAD T1,PHCPNO,T4	;GET PAGE NUMBER
	CCHUO 0(T1)		;UNLOAD CACHE FOR PAGE
	CONSO APR,APSWPD	;WAIT FOR COMPLETION
	JRST .-1
	CONOAPR APFCLR+APSWPD+APMPE
	CALL MEMPXX		;TRY REFERENCE WITHOUT CACHE
	CONSZ APR,APMPE+APSBER	;ERROR?
	JRST [	SETONE PI%FAT,PI%BAD(Q2) ;YES. MARK HARD ERROR THEN
		JRST MEMP11]	;AND PROCEED
	MOVEM T1,PI%MDA(Q2)	;NO, SAVE DATA
MEMP11:	CONOAPR APFCLR+APMPE	;CLEAR CONDITION
				;END NOCACHE TEST
MPEX1:
	POP P,T4		;RESTORE ADDRESS
	JRST MEMP4		;CONTINUE CORE SCAN

;common code to setup SYSERR block and gather processor info
;Entered with Q3/Pointer to SYSERR block

;returns +1 T1/ count of words used

PARGER:	CONI APR,PI%CN2(Q3)	;GATHER ERROR INFO, CONI...
	CONSZ APR,APMPE		;MB PARITY ERROR?
	RDERA PI%ER2(Q3)	; ...ERA...
	DMOVE T1,PIAPRX		; ...PC...
	MOVEM T1,PI%FL2(Q3)	;STORE FLAGS
	MOVEM T2,PI%PC2(Q3)	;STORE PC

	SETZM PI%ERC(Q3)	;INIT ERROR COUNT
	SETZM PI%OR2(Q3)	;INIT LOGICAL AND/OR WORDS
	SETZM PI%OD2(Q3)
	SETOM PI%AA2(Q3)
	SETOM PI%AD2(Q3)

;READ SBUS DIAG INFO FOR ALL CONTROLLERS

	MOVEI T1,PI%DA2(Q3)	;BAD ADDRESS BLOCK
	HRLI T1,-PI%NB2		;# OF ENTRIES
	SETZM 0(T1)
	AOBJN T1,.-1		;ZERO THE BLOCK
	MOVEI T3,PI%SBA(Q3)	;SBDAG DATA ADDRESSES
	MOVEI T2,PI%SBA		;GET OFFSET
	MOVEM T2,PI%SB2(Q3)	;POINTER TO OFFSET
	MOVEI T2,PI%MXS		;MAX AREA FOR SBDIAGS
	CALL RDDIAG		;READ SBUSDIAG'S
	HLLM T3,PI%SB2(Q3)	;SAVE COUNT OF CONTROLLERS FOUND
	MOVE T1,T2
	RET

;ROUTINE TO READ SBUSDIAG DATA INTO A BUFFER
;ACCEPTS:	T3/ FIRST ADDRESS TO USE
;		T2/ COUNT OF WORDS AVAIALABLE
;RETURNS:	+1 ALWAYS

RDDIAG:	SAVEAC <Q3,P1>
	MOVSI T4,-PI%MXS/2	;SETUP NUMBER OF CONTROLLERS
	SETZM T1		;INIT CONTROL WORD
	MOVNI Q3,-<SBSMAX+1>(T2) ;WORDS AVAILABLE
	HRLZS Q3		;COMPUTE AOBJN WORD
MEMPS1:	SETZM T1		;SET UP TO READ FUNCTIONS
	DPB T4,[POINT 5,T1,4]	;SET CONTROLLER NUMBER
	SBDIAG T1		;DO FIRST FUNCTION, DATA TO T2
	CAMN T2,[-1]		;NON-EX FBUS CONTROLLER?
	JRST RDDIA3		;YES. SKIP PROCESSING
	MOVE P1,T2		;SAVE DATA
	HRRI T1,1		;SET NEXT FUNCTION NUMBER
	SBDIAG T1		;DO SECOND FUNCTION
	SKIPN P1		;EXIST?
	JUMPE T2,RDDIA3		;?
	MOVEM P1,1(T3)		;YES. SAVE IT
	MOVEM T2,2(T3)		;SAVE THEM BOTH
	MOVEM T4,0(T3)		;SAVE CONTROLLER #
	LOAD T2,MEMTYP,T2	;GET MEM TYPE
	CAIN T2,MOS		;MOS MEMORY?
	JRST RDMOS		;YES. SEE IF ANY MOS ERRORS AROUND
	CALL CLRCON		;NO, CLEAR CONTROLLER NOW
RDDIA1:	MOVNI T2,SBSMAX		;# OF SBDIAGS
RDDIA2:	HRLM T2,0(T3)		;SAVE COUNT
	ADD T3,[-1,,SBSMAX+1]	;ADJUST VALUE
	ADD Q3,BHC+SBSMAX	;ACCOUNT FOR 2 OF THE WORDS
	AOBJP Q3,RDDIA4		;ROOM FOR MORE?
RDDIA3:	AOBJN T4,MEMPS1		;LOOP FOR ALL CONTROLLERS
RDDIA4:	HRRZ T2,Q3		;RETURN WORDS USED
	RET			;DONE

;ROUTINE TO TYPE OUT ALL SBUS ERROR REGS
;ACCEPTS: 	T1/ -COUNT,,ADDRESS

PRISBS:	SAVEAC <Q1,Q2>		;GET SOME WORK REGS
	JUMPGE T1,R		;IF NONE, GIVE UP NOW
	MOVE Q1,T1		;SAVE START ADDRESS
	MOVEI T1,[SIXBIT '$$SBUS DIAGS$$CNTRLR FNC 0          FNC 1$/']
	JSR BUGMSG
PRISB1:	HRRZ T1,0(Q1)		;GET CONTROLLER #
	CAIN T1,PI%DMA		;IS THIS THE DMA?
	CALL [	MOVEI T1,[SIXBIT 'DMA   /'] ;YES
		JSR BUGMSG	;SAY SO
		RETSKP]		;AND PROCEED
	CALL BUGOPT		;OUTPUT IT
	MOVEI T1," "		;A SPACE
	JSR BUGTYO
	MOVE T1,1(Q1)		;GET FUNCTION 1
	CALL BUGWPT		;OUTPUT 36 BITS
	MOVEI T1," "		;A SPACE AGAIN
	JSR BUGTYO
	MOVE T1,2(Q1)		;GET FUNCTION 2
	CALL BUGWPT		;OUTPUT IT
	MOVEI T1,[SIXBIT '$/']	;GET EOL
	JSR BUGMSG		;AND GET A NEW LINE
	HLRE T1,0(Q1)		;GET COUNT OF SBDIAGS DONE
	SUB Q1,T1		;SKIP UNWANTED AND WANTED FUNCTIONS
	AOBJN Q1,PRISB1		;DO IT
	RET			;DONE

;RDDIAG CONTINUED...

;READING FOR A MOS CONTROLLER. LOOK FOR ANY MOS HARD ERRORS
;	P1/ SBUSDIAG FUNCTION 1

RDMOS:	TXNN P1,MOSCER		;MOS CORRECTABLE ERROR?
	TXNN P1,SBSHER		;NO. ANY HARD ERRORS?
	CALL CLRCON		;CLEAR CONTROLLER
	HLRZ T2,Q3		;GET REMAINING COUNT
	CAIL T2,-<SBSMAX+1+.PIMSZ> ;ROOM TO RECORD A MOS HARD ERROR?
	SKIPN T2,ERRTBL		;HAVE ANY?
	JRST RDDIA1		;NO. PROCEED AS NORMAL
	HRRZ T1,T4		;YES. GET CONTROLLER
RDMOS0:	OPSTR <CAME T1,>,SBSCN,(T2) ;IS THIS THE CONTROLLER?
	JRST RDMOS1		;NO. SKIP THIS ENTRY
	JE SBHEB,(T2),RDMOS1	;IF ALREADY RECORDED, GO ON

;FOUND ONE TO RECORD

	SETZRO SBHEB,(T2)	;MARK IT RECORDED
	MOVE T1,SBSEAD(T2)	;GET ERROR ADDRESS
	MOVEM T1,PI%MEA(T3)	;STORE IT
	LOAD T1,SBSBN,(T2)	;GET BLOCK NUMBER
	MOVEM T1,PI%MBN(T3)	;STORE IT
	LOAD T1,SBSSB,(T2)	;GET SPARE BIT NUMBER
	MOVEM T1,PI%MSB(T3)	;STORE IT
	LOAD T1,SBSSY,(T2)	;GET SYNDROME OF ERROR
	MOVEM T1,PI%MSY(T3)	;STORE IT
	ADDI T3,.PIMSZ		;ACCOUNT FOR USED WORDS
	ADD Q3,BHC+.PIMSZ	;HERE TOO
	MOVNI T2,SBSMAX+.PIMSZ	;NUMBER OF ENTRIES
	JRST RDDIA2		;AND PROCEED

;THIS ENTRY NOT INTERESTING

RDMOS1:	SKIPE T2,SBSLNK(T2)	;GET NEXT ONE
	JRST RDMOS0		;FOUND ONE
	JRST RDDIA1		;PROCEED

;LOCAL ROUTINE TO CLEAR A CONTROLLER.
;	T4/ COUNT,,CONTROLLER# IF CLRCON CALLED
;	Q1/ COUNT,,CONTROLLER# IF CLRCN0 CALLED

CLRCN0:	MOVE T4,Q1		;ENTRY FOR CONTROLLER NUMBER IN Q1
CLRCON:	MOVX T1,SBCLER		;GET CLEAR BIT
	DPB T4,[POINT 5,T1,4]	;STORE CONTROLLER NUMBER
	SBDIAG T1		;CLEAR CONTROLLER
	RET			;AND DONE

;PROCESS SBUS ERROR FOR KL10. THIS CODE IS GOTTEN TO
;ON AN APR INTERRUPT INDICATING SBUS ERROR.
;THE CODE LOOKS FOR MOS CONTROLLERS THAT INDICATE
;CORRECTABLE ERROR SO THAT THE MOS DIAGNOSITC (TGHA) CAN ANALYZE
;THE PROBLEM. IF A HARD ERROR IS FOUND IN ANY CONTROLLER
;(MOS OR CORE), THEN A MEMORY SCAN WILL BE DONE LATER.
;THE MEMEORY SCAN IS ARRANGED BY TREATING THE HARD SBUS ERROR
;AS A MEM PAR ERROR. ANY CERS THAT ARE FOUND ARE LOGGED IN
;A RESIDENT BUFFER FOR LATER RETRIEVAL BY TGHA.

;Here on APR interrupt with bit 24 on

SBSERR:	MOVE P,[IOWD NMEMPP,MEMPP] ;ESTABLISH TEMP STACK
	RDERA PI%ER2+MPISEB	;SAVE ERA IN CASE
	SETZM P3		;NO HARD ERRORS YET
	CONOAPR APFCLR+APSBER 	;CLEAR APR FLAG NOW
	MOVEI Q2,MOSLEN		;# OF CONTROLLER GROUPS
	JRST SBSER3		;DO IT
SBSER1:	MOVEI T1,0		;START WITH FUNCTION ZERO
	DPB Q1,[POINT 5,T1,4]	;STORE CONTROLLER NUMBER
	SBDIAG T1		;GET CONTROLLER INFORMATION
	CAME T2,[-1]		;CONTROLLER EXIST?
	TXNN T2,SBSHER!MOSCER	;ANY SORT OF ERROR?
	JRST SBSER2		;NO. GO ON
	MOVE Q3,T2		;SAVE FNC 0 RESULTS
	HRRI T1,1		;DO FNC 1
	SBDIAG T1		;""
	LOAD T3,MEMTYP,T2	;GET TYPE OF THIS MEMORY
	CAIN T3,MOS		;MOS CONTROLLER?
	TXNE T2,MOSDBL		;ENABLED?
	JRST SBSER2		;NO. SKIP THIS CONTROLLER THEN
	JRST SBSER0		;MAYBE. GO LOOK

;NOT MOS OR NOT A CORRECTABLE ERROR. GO ON TO NEXT

SBSER2:	AOBJN Q1,SBSER1		;DO NEXT CONTROLLER
SBSER3:	SOJL Q2,[SKIPN MEMPDP	;FOUND ERROR?
		JRST [	CONOAPR APSBER+APFSET ;NO. REASSERT ERROR AND DO SCAN
			JRST MEMPAR] ;GO CHECK FOR MB PARITY ERROR
		JRST OV0]	;AND PROCEED
	MOVE Q1,MOSTBL(Q2)	;GET NEXT GROUP
	JRST SBSER1		;AND DO IT

;FOUND A MOS CONTROLLER WITH ERROR UP. GET INFORMATION
;FOR TGHA.
;	Q1/-N,,CNTRL#
;	Q3/SBDIAG FNC 0 RESULTS

SBSER0:	MOVE F,Q3		;SAVE SBDIAG FNC 0
	SKIPE T1,MTSADR		;TESTING AN ADDRESS?
	JRST [	XOR T1,Q3	;YES. SEE IF IN ERROR PAGE
		TXNE T1,PHCPNO	;IS IT?
		JRST .+1	;NO
		CALL CLRCN0
		AOJA P3,SBSER2]	;AND DONE
REPEAT 0,<
	CONSZ APR,APMPE		;ACCOMPANYING MB PARITY ERROR?
	JRST [	RDERA T1	;YES. GET ERA
		TXNN T1,ER%WRT	;WRITING?
		JRST .+1	;NO
		ANDX T1,<PHCPNO!PGWD> ;GET ADDRESS
		LOAD T2,<PHCPNO!PGWD>,Q3 ;GET MEM ADDRESS
		CAME T2,T1	;SAME ADDRESS?
		JRST .+1	;NO
		CALL CLRCNO	;CLEAR IT
		AOJA P3,SBSER2]	;AND DONE
 >				;END OF REPEAT 0
	TXNE F,MOSWPE		;A WRITE ERROR?
	JRST SBSER7		;YES. GO ANALYZE
SBSER8:	TXNE F,MOSCER!MOSWPE	;A CORRECTABLE ERROR?
	AOS P3			;YES. REMEMBER THIS
	MOVX T1,<.RESP1,,ERRSIZ> ;GET A BLOCK TO STORE DATA
	MOVX T2,RS%SE0!.RESGP	;FROM GENERAL POOL, SECTION 0
	CALL ASGRES		;GET IT
	 JRST [	BUG.(INF,SBSERF,APRSRV,SOFT,<SBSERR - Could not get error block>,,<

Cause:	An APR interrupt occurred because a memory controller detected
	an error in its own operation or in information received over
	the S bus or from a memory module. The monitor has determined
	that a MOS controller is involved. Normally the monitor creates
	a block and records information about the error for later
	retrieval by TGHA. However, no free space is available so this
	information will be lost.
>,,<DB%NND>)			;[7.1210]
		JRST SBSER6]	;CAN'T DO IT THEN

	MOVE P1,T1		;SAVE BLOCK ADDRESS
	EXCH T1,ERRTBL		;MAKE THIS NEW HEAD.
	MOVEM T1,@ERRTBL	;LINK IN REMAINDER OF CHAIN
	STOR Q1,SBSCN,(P1)	;STORE CONTROLLER NUMBER
	MOVEI T1,.PMMER		;ENTRY TYPE
	STOR T1,SBSTP,(P1)	;STORE THIS TOO
	RDERA SBSERA(P1)	;SAVE ERA AT TIME OF ERROR
	TRZ Q3,3		;GET LEFT-MOST 34 BITS OF ERROR ADDRESS
	MOVEI T1,2		;NEED TO GET FNC 2
	DPB Q1,[POINT 5,T1,4]	;FOR THIS CONTROLLER
	SBDIAG T1		;""
	LDB T2,[POINT 2,T2,6]	;GET LOW ORDER-TWO BITS OF ADDRESS
	IOR Q3,T2		;FORM FULL WORD ADDRESS
	MOVEM Q3,SBSEAD(P1)	;SAVE ERROR ADDRESS
	HRRI T1,1B27+6		;DO FUNCTION 6.1
	SBDIAG T1		;TO GET SYNDROME
	LDB T2,[POINT 6,T2,12]	;GET SYNDROME
	STOR T2,SBSSY,(P1)	;SAVE SYNDROME IN ERROR BLOCK
	HRRI T1,12		;SET UP TO GET BN
	LDB T2,[POINT 8,Q3,21]	;GET RAM ADDRESS FROM EA
	DPB T2,[POINT 8,T1,27]	;PUT IN THE FUNCTION
	SBDIAG T1		;GET IT
	LDB T2,[POINT 4,T2,13]	;GET BN
	STOR T2,SBSBN,(P1)	;SAVE IN ERROR BLOCK
	HRRI T1,7		;NOW GET SPARE BIT NUMBER
	DPB T2,[POINT 4,T1,24]	;PUT IN BLOCK #
	LDB T3,[POINT 3,Q3,35]	;GET OFFSET IN INTERLEAVE GROUP
	DPB T3,[POINT 3,T1,27]	;STORE IN FUNCTION
	SBDIAG T1		;GET SPARE BIT #
	LDB T3,[POINT 6,T2,12]	;GET IT
	STOR T3,SBSSB,(P1)	;SAVE IT IN THE ERROR BLOCK
	TXC T2,7B15		;COMPLEMENT ICE FIELD
	IOR T1,T2		;SET UP TO SUPPRESS ERROR REPORTING
	TXNE F,MOSCER		;HARD ERROR?
	SBDIAG T1		;NO, DO IT
	; ..

;NOW READ THE 4 32-BIT SERIAL NUMBERS FROM THE CONTROLLER.

	MOVEI T1,2		;DO IT WITH FUNCTION 2
	DPB Q1,[POINT 5,T1,4]	;STORE CONTROLLER #
	LOAD T2,SBSBN,(P1)	;GET BACK BN
	LSH T2,-2		;DIVIDE BY 4
	DPB T2,[POINT 2,T1,10]	;INTO THE INPUT WORD
	MOVE P2,[POINT 8,SBSSER(P1)] ;BYTE POINTER TO SERIAL # STORAGE
	MOVEI T4,^D16		;# OF BYTES TO GET
SBSER5:	SBDIAG T1		;GET NEXT BYTE
	LDB T2,[POINT 8,T2,14]	;GET BYTE
	IDPB T2,P2		;SAVE BYTE
	ADD T1,[1B14]		;NEXT ONE
	SOJG T4,SBSER5		;GET REST OF THIS ONE
	TXNE F,MOSCER!MOSWPE	;HARD ERROR?
	JRST SBSER6		;NO. PROCEED
	SETONE SBHEB,(P1)	;YES. MARK IT

;DONE WITH ERROR ANALYSIS. CLEAR ERROR AND PROCEED

SBSER6:
   IFNDEF DODBE,<		;IF NOT DOING DOUBLE-BIT CORRECTION
	TXNN F,MOSCER!MOSWPE	;HARD ERROR?
	JRST SBSER2		;YES. LEAVE EVERYTHING ALONE
   >				;END OF IFNDEF DODBE
	LOAD T2,PHCPNO,Q3	;GET PHYSICAL PAGE NUMBER
	LOAD T3,PGWD,Q3		;GET WORD WITHIN PAGE
   IFDEF DODBE,<		;FOR CORRECTING 2-BIT ERRORS
	TXNN F,MOSCER!MOSWPE	;HARD ERROR?
	JRST SBSDBE		;YES. GO SEE IF CORRECTABLE
   >				;END OF IFDEF DODBE
	MOVE T4,[MOVES PIPGA(T3)] ;TO CORRECT IT
	TXNN F,MOSWPE		;WRITE ERROR?
	CALL XCTRCA		;NO, DO CORRECTION
	MOVX T1,SBCLER		;SET UP FOR CLEAR
	DPB Q1,[POINT 5,T1,4]	;THE CONTROLLER
	SBDIAG T1		;CLEAR IT
	JRST SBSER2		;AND PROCEED WITH SCAN

;Here if a controller indicates "write data parity error".

SBSER7:	CONSZ APR,APMPE		;MB ERROR PENDING?
	AOJA P3,SBSER2		;YES. GO ON
	MOVE T1,PI%ER2+MPISEB	;NO. GET LAST MB ERROR REPORTED
	XOR T1,Q3		;SEE IF IN SAME PAGE
	TXNE T1,PHCPNO		;IS IT?
	JRST SBSER8		;NO. REPORT IT THEN
	CALL CLRCN0		;YES. UNLATCH CONTROLLER THEN
	AOJA P3,SBSER2		;DONE


;ROUTINE TO CORRECT DOUBLE BIT ERRORS. AT THIS POINT:

   IFDEF DODBE,<		;IF WANT TO CORRECT 2-BIT ERRORS
SBSDBE:	PIOFF			;OWN MACHINE
	SKIPE P1,CASHF		;GET CACHE STATE
	CALL CASHOF		;WAS ON. TURN IT OFF
	LOAD T1,PHCPNO,Q3	;GET MEM PAGE NUMBER
	PUSH P,@CST0X+T1	;SAVE CST0 ENTRY FOR THIS PAGE
	PUSH P,T1		;SAVE PAGE NUMBER
	SETOM @CST0X+T1		;MAKE IT FULLY ACCESSIBLE
	CALL MAPRCA		;GET ACCESS TO IT
	LOAD T4,PGWD,Q3		;GET WORD NUMBER IN PAGE
	ADD T4,T1		;FORM ADDRESS OF ERROR WORD
	MOVX T1,SBCLER		;NEED TO CLEAR ERROR NOW
	DPB Q1,[POINT 5,T1,4]
	SBDIAG T1		;DO IT
	MOVE P2,0(T4)		;GET ERROR WORD
	TXZ T1,SBCLER		;SEE IT STILL HAVE AN ERROR
	SBDIAG T1		;"
	TXNN T2,MOSCER		;STILL UNCORRECTABLE?
	TXNN T2,SBSRPE		;DO WE?
	JRST SBSHR5		;NO. FLAKEY MEMORY. IT IS HOPELESS
	SETCAM P2,0(T4)		;COMPLEMENT BAD LOCATION
	MOVE T1,P2		;GET ORIGINAL WORD AGAIN
	EQV T1,0(T4)		;FORM EQUIVALENCE
	MOVE Q3,T1		;SAVE EQV
	JUMPE T1,SBSHR0		;IF ZERO, FATAL ERROR

;NOW COUNT # OF BITS IN RESULTING WORD AND ACCUMULATE SYNDROME

	SETZM P3		;WHERE TO ACCUMULATE SYNDROME
	MOVEI T3,1		;HAVE AT LEAST ONE BIT
SBSHR1:	JFFO T1,.+1		;GET NEXT ONE BIT
	TDZ T1,BITS(T2)		;TURN OFF THE BIT
	ADJBP T2,[POINT 6,SYNWRD,5] ;GET TO PROPER SYNDROME
	LDB T2,T2		;GET SYNDROME FOR BIT
	XOR P3,T2		;COMPUTE SYNDROME
	SKIPE T1		;DONE YET?
	AOJA T3,SBSHR1		;NO. FIND NEXT BIT THEN

;FOUND ALL BITS

	SOJE T3,SBSHR2		;ONE BIT FOUND?
	SOJG T3,SBSHR0		;NO. TWO BITS THEN?
	MOVEI T1,1B27+6		;READ ERROR SYNDROME
	DPB Q1,[POINT 5,T1,4]
	SBDIAG T1		;GET THE SYNDROME
	LDB T2,[POINT 6,T2,12]	;FETCH IT FROM THE WORD
	CAME T2,P3		;SAME SYNDROME?
	JRST SBSHR0		;NO. FLAKEY AGAIN
	;..

;COMPUTED SYNDROME MATCHES REPORTED SYNDROME. CAN CORRECT ERROR

	;..
SBSHR4:	XOR P2,Q3		;GET CORRECT DATA
SBSHR0:	MOVEM P2,0(T4)		;PUT BACK DATA
SBSHR5:	POP P,T1		;GET BACK MEM PAGE NUMBER
	POP P,@CST0X+T1		;RESTORE PAGE STATE
	CALL UNMRCA		;FREE MAPPING
	SKIPE P1		;WAS CACHE ON?
	CALL CASHON		;YES. TURN IT ON AGAIN THEN
	PION			;TURN ON SYSTEM AGAIN
	AOJA P3,SBSER2		;AND DONE. BUT RECORED HARD ERROR

;EQV WORD HAS ONE BIT ON. SEE IF CAN FIND A MATCHING SYNDROME

SBSHR2:	MOVEI T1,1B27+6		;SET UP TO READ SYNDROME
	DPB Q1,[POINT 5,T1,4]
	SBDIAG T1		;GET SYNDROME OF ERROR
	LDB T2,[POINT 6,T2,12]	;EXTRACT THE SYNDROME
	XOR P3,T2		;COMPUTE SYNDROME OF OTHER BIT

;NOW HAVE SYNDROME OF THE OTHER BIT. SEE IF WE CAN FIND THE BIT

	CAMN P3,T2		;MAKE SURE NOT SELF
	JRST SBSHR0		;IT IS. BOO HIS!!!
	MOVEI T3,^D43		;# OF BITS IN A WORD
SBSHR3:	MOVE T2,T3		;COPY BIT NUMBER
	ADJBP T2,[POINT 6,SYNWRD,5] ;GET POINTER TO SYNDROME
	LDB T2,T2		;GET SYNDROME
	CAMN P3,T2		;FOUND IT?
	JRST [	CAIG T3,^D35	;A DATA BIT?
		TDO Q3,BITS(T3)	;YES. PUT IT IN CORRECTION WORD
		JRST SBSHR4]	;AND GO CORRECT DATA
	SOJGE T3,SBSHR3		;NO. DO OTHER BITS
	JRST SBSHR0		;NOT FOUND. CAN'T CORRECT IT

;DEFINE SYNDROMES OF BITS

SYNWRD:	BYTE (6)14B37,24B37,30B37,34B37,44B37,50B37,54B37,60B37,64B37,70B37,74B37,104B37
	BYTE (6)110B37,114B37,120B37,124B37,130B37,134B37,140B37,144B37,150B37,154B37,160B37,164B37
	BYTE (6)170B37,174B37,204B37,210B37,214B37,220B37,224B37,230B37,234B37,240B37,244B37,250B37
	BYTE (6)200B37,100B37,40B37,20B37,10B37,4B37,0B37
   >				;END OF IFDEF DODBE
   >				;END OF IFN KLFLG IN MEMPAR

;UTILITY ROUTINE TO GET NEXT MEM ERROR BLOCK
;ACCEPTS:	T1/ TYPE OF ENTRY WANTED
;RETURNS:	+1 NONE FOUND
;		+2 FOUND. T1/ ADDRESS

   IFN KLFLG,<			;FOR THE KL, HOWEVER,
DEQERR::
	CAIE T1,.PMMER		;WANT MOS ERRORS?
	RET			;NO. YES, WE HAVE NONE OF THESE
	PIOFF			;OWN MACHINE FOR A WHILE
	SKIPN T1,ERRTBL		;ANY ENTRIES?
	RETBAD (,<PION>)	;NO. GIVE UP THEN
	MOVE T2,SBSLNK(T1)	;YES. GET LINK WORD
	MOVEM T2,ERRTBL		;REMOVE TOP ENTRY
	PION			;RELEASE MACHINE
	RETSKP			;AND DONE
   >				;END OF IFN KLFLG

;Routine to unlatch all MOS memory controllers. MOS controllers
;latch error information and will not report subsequent errors
;while latched. This code is used by the monitor start up routines
;in PAGEM, by the channel write parity error code in APRSRV and MEXEC.

   IFN KLFLG,<

MOSULE::PIOFF			;OWN THE MACHINE
	SKIPN ERRTBL		;ANY ERRORS?
	CALL MEMSTR		;NO. UNLATCH CONTROLLERS
	PION
	RET

MEMSTR::MOVSI T3,-MOSLEN	;# OF CONTROLLER PAIRS
MEMST1:	MOVE T4,MOSTBL(T3)	;GET GROUP
	CALL CLRCON		;CLEAR CONTROLLER
	AOBJN T4,.-1		;DO ALL OF THE CONTROLLERS
	AOBJN T3,MEMST1		;DO ALL GROUPS
	RET			;DONE

;ROUTINE TO CLEAR ALL CONTROLLERS WITH WRITE PARITY ERROR

UNLCON:	MOVSI T3,-MOSLEN	;SIZE OF TABLE
UNLCN0:	MOVE T4,MOSTBL(T3)	;GET NEXT GROUP
UNLCN1:	SETZM T1
	DPB T4,[POINT 5,T1,4]	;PUT IN CONTROLLER #
	SBDIAG T1		;GET FUNCTION 0
	TXNE T2,MOSWPE		;WRITE ERROR?
	CALL CLRCON		;YEP. UNLATCH THEN
	AOBJN T4,UNLCN1		;DO ALL OF GROUP
	AOBJN T3,UNLCN0		;DO ALL GROUPS
	RET			;AND DONE

   >				;IF OF IFN KLFLG

IFN KLFLG,<

;JOB 0 CLEANUP ROUTINE--MARK PAGES FOUND AS BAD
; T1/ SYSERR BLOCK PTR
;	CALL MEMPJ0
; RETURNS +1 ALWAYS

	SWAPCD
MEMPJ0:	SAVEQ
	STKVAR <<CTYBLK,^D70>>	;LOTS OF WORDS FOR THE STRING
	MOVEI Q1,SEBDAT(T1)	;SETUP PTR TO DATA BLOCK

;DO TYPEOUT OF PROCESSOR INFORMATION

	HRROI T1,CTYBLK		;GET ADDRESS OF STRING
	HRROI T2,[ASCIZ /


Parity Error Detected by/]
	TMNN APMPE,PI%CN2(Q1)
	HRROI T2,[ASCIZ /


SBUS Error Detected by/]
	SETZM T3
	SOUT			;COPY STRING
	HRROI T2,[ASCIZ / APR/]
	TMNE ER%CHN,PI%ER2(Q1)
	HRROI T2,[ASCIZ / CHANNEL/]
	SOUT
	HRROI T2,[ASCIZ /, ERA = /]
	SOUT
	MOVE T2,PI%ER2(Q1)
	MOVX T3,<NO%MAG!NO%LFL!NO%ZRO+10>+FLD(^D12,NO%COL)
	NOUT
	 NOP
	HRROI T2,[ASCIZ /
/]
	SETZM T3
	SOUT			;TIE OFF THE STRING
	MOVEI T2,CTYBLK
	MOVEI T3,.QBSYS		;.QBDTY VALUE FOR SYSTEM MESSAGE
	CALL WROPR0		;SEND IT OUT
	MOVE T1,PI%SB2(Q1)		;GET SDBIAG WORD
	ADDI T1,0(Q1)			;ADD IN START IF BLOCK
	CALL PPRSBS			;TYPE OUT INFO

	HRROI T1,[ASCIZ /

   LOC      CONTENTS

/]
	PSOUT
	HRLI Q1,-PI%NB2		;SCAN BLOCK OF BAD ADDRESSES
	SETO Q2,

;Now look at bad word and report on each of them

MEMPJ1:	JN ER%WRT,PI%ER2(Q1),MEMPJ2 ;IF WRITE, DON'T KILL PAGE
	JE PI%FAT,PI%BAD(Q1),MEMPJ2 ;IF NOT FATAL, SKIP IT
	LOAD T1,PHCPNO,PI%BAD(Q1) ;GET PHYS PAGE NUMBER THIS ADDRESS
	CAME T1,Q2		;SAVE AS PREVIOUS?
	SKIPN T1		;OR NONE?
	JRST MEMPJ2		;YES, DO NOTHING
	MOVEM T1,Q2		;SAVE
	CALL BADCPG		;MARK PAGE BAD
	 JFCL
MEMPJ2: SKIPN T2,PI%BAD(Q1)	;HAVE AN ADDRESS?
	RET			;NO. ALL DONE THEN
	ANDX T2,<PHCPNO+PGWD>	;JUST USE ADDRESS BITS
	MOVEI T1,.PRIOU		;YES
	MOVX T3,<NO%LFL!NO%ZRO+10>+FLD(^D8,NO%COL)
	NOUT			;TYPE IT OUT THEN
	 NOP
	MOVEI T2," "
	BOUT			;SPACE
	MOVE T2,PI%DA2(Q1)	;GET BAD DATA
	MOVX T3,<NO%MAG!NO%LFL!NO%ZRO+10>+FLD(^D12,NO%COL)
	NOUT			;TYPE IT OUT ALSO
	 NOP
	MOVEI T2," "
	BOUT
	JN PI%FAT,PI%BAD(Q1),MEMPJ3 ;IF HARD NO GOOD DATA
	MOVE T2,PI%MDA(Q1)
	NOUT
	 NOP
MEMPJ3:	HRROI T1,[ASCIZ /
/]
	PSOUT
	AOBJN Q1,MEMPJ1		;DO ALL ADDRESSES
	RET
	ENDSV.

;PRINT SBUS DIAGS FOR JOB 0 ROUTINES
PPRSBS:	SAVEAC <Q1,Q2>		;GET SOME WORK REGS
	JUMPGE T1,R		;IF NONE, GIVE UP NOW
	MOVE Q1,T1		;SAVE START ADDRESS
	HRROI T1,[ASCIZ '

SBUS DIAGS

CNTRLR    FNC 0       FNC 1
']
	PSOUT
PPRSB1:	HRRZ T2,0(Q1)		;GET CONTROLLER #
	CAIN T2,PI%DMA		;IS THIS THE DMA?
	JRST [	HRROI T1,[ASCIZ 'DMA    '] ;YES
		PSOUT		;SAY SO
		MOVEI T1,.PRIOU	;PRIMARY OUTPUT
		JRST PPRSB2]
	MOVEI T1,.PRIOU
	MOVX T3,<NO%MAG!NO%LFL!NO%ZRO+10>+FLD(2,NO%COL)
	NOUT
	 NOP
	HRROI T2,[ASCIZ /     /]
	SETZM T3
	SOUT			;SPACES
PPRSB2:	MOVE T2,1(Q1)		;GET FUNCTION 1
	MOVX T3,<NO%MAG!NO%LFL!NO%ZRO+10>+FLD(^D12,NO%COL)
	NOUT
	 NOP
	MOVEI T2," "		;A SPACE
	BOUT
	MOVE T2,2(Q1)		;GET FUNCTION 2
	NOUT
	 NOP
	HRROI T1,[ASCIZ /
/]				;EOL
	PSOUT
	HLRE T1,0(Q1)		;GET COUNT OF SBDIAGS DONE
	SUB Q1,T1		;SKIP UNWANTED AND WANTED FUNCTIONS
	AOBJN Q1,PPRSB1		;DO IT
	RET			;DONE
>				;END OF IFN KLFLG

;ROUTINE TO FINISH LOGGING OF PARITY ERROR - RUN IN JOB 0 CONTEXT

; T1/ ADDRESS OF SYSERR BLOCK

PFCPJ0:	SAVEQ
	STKVAR <<CTYBLK,70>>
	HLRZ Q3,SEBDAT+PT%JOB(T1) ;GET FORKX AT TRAP
	CAIE Q3,-1
	SKIPGE FKPT(Q3)
	JRST PFCPJ1
	LOAD T2,FKJBN		;GET JOB NUMBER
	HRRM T2,SEBDAT+PT%JOB(T1) ;REPORT IT
	HRRZ T3,JOBDIR(T2)	;GET LOGGED-IN DIRECTORY
	HRLI T3,USRLH		;MAKE IT A USER NUMBER
	MOVEM T3,SEBDAT+PT%USR(T1) ;REPORT IT
	MOVE T3,JOBPNM(T2)	;GET PROGRAM NAME
	MOVEM T3,SEBDAT+PT%PGM(T1) ;REPORT IT

; Report on CTY

PFCPJ1:	MOVEI Q1,SEBDAT(T1)
	HRROI T1,CTYBLK
	HRROI T2,[ASCIZ '


AR/ARX Parity error
PFW= ']
	SETZM T3
	SOUT
	MOVE T2,PT%PFW(Q1)
	MOVX T3,<NO%MAG!NO%LFL!NO%ZRO+10>+FLD(^D12,NO%COL)
	NOUT
	 NOP
	HRROI T2,[ASCIZ / MAP WORD= /]
	SETZM T3
	SOUT
	MOVE T2,PT%PMA(Q1)
	MOVX T3,<NO%MAG!NO%LFL!NO%ZRO+10>+FLD(^D12,NO%COL)
	NOUT
	 NOP
	HRROI T2,[ASCIZ /
BAD DATA= /]
	SETZM T3
	SOUT
	MOVE T2,PT%BDW(Q1)
	MOVX T3,<NO%MAG!NO%LFL!NO%ZRO+10>+FLD(^D12,NO%COL)
	NOUT
	 NOP
	TMNE PT%HRD,PT%TRY(Q1)
	IFSKP.
	 HRROI T2,[ASCIZ /
GOOD DATA= /]
	 SETZM T3
	 SOUT
	 MOVX T3,<NO%MAG!NO%LFL!NO%ZRO+10>+FLD(^D12,NO%COL)
	 MOVE T2,PT%GDW(Q1)
	 NOUT
	  NOP
	ENDIF.
	HRROI T2,[ASCIZ/
/]
	SETZM T3
	SOUT
	MOVEI T2,CTYBLK
	MOVEI T3,.QBSYS		;.QBDTY VALUE FOR SYSTEM MESSAGE
	CALLRET WROPR0
	ENDSV.

;Routine to scann portion of memory looking for parity errors.
; This is called from Channel logout code when channel write
; parity errors have occurred.
;
; T1/	STARTING PHYSICAL ADDRESS
; T2/	WORD COUNT

; RETURNS:
;	+1 ONE OR MORE ERRORS FOUND
;	+2 NO ERRORS FOUND

   IFN KLFLG,<
	RESCD
MEMSCN::SAVEP			;SAVE ACS
	SETZM P1		;NO ERRORS YET
	DMOVE P2,T1		;SAVE ARGS

;MUST SCAN ERROR QUEUE

	MOVE P4,T1		;START ADDRESS
	ADDI P4,-1(T2)		;END ADDRESS
MEMSC3:	PIOFF
	SKIPN T1,WREQ		;HEAD OF QUEUE
	JRST MEMSC1		;NONE TO DO
	MOVE T4,TODCLK		;TIME
	SUBI T4,^D30000		;MAX TIME TO HOLD AN ETNRY
	MOVEI T2,WREQ		;PREVIOUS
MEMSC2:	MOVE T3,1(T1)		;GET ERROR ADDRESS
	CAML T3,P2		;WITHIN RANGE?
	CAMLE T3,P4		;STILL?
	JRST [	CAMG T4,2(T1)	;TIME TO FLUSH IT?
		JRST MEMSC4	;NO. KEEP IT FOR THE NEXT TIME
		JRST MEMSC6]	;YES
	AOS P1			;FORCE ERROR
MEMSC6:	MOVE T3,0(T1)		;NXT
	MOVEM T3,0(T2)		;UNLINK THIS ONE
	CALL RELRES		;FREE BLOCK
	JRST MEMSC3		;AND TRY AGAIN

MEMSC4:
	MOVE T2,T1		;NEW PREVIOUS
	MOVE T1,0(T1)		;NEW NEXT
	JUMPN T1,MEMSC2		;DO IT


;Scan of error queue all done


MEMSC1:	EA.ENT			;RUN INSECTION 1
	PUSH P,UPTPFO		;SAVE PAGE FAIL STATE
	PUSH P,UPTPFL
	PUSH P,UPTPFN
	PUSH P,UPTPFW
	XMOVEI T3,MEMPT0	;LOCAL PAGE FAIL ROUTINE
	MOVEM T3,UPTPFN		;STASH IT

;SCAN THE MEMORY

	MOVEM P2,MTSADR		;SAVE AS TEST ADDRESS
	LOAD T3,PGWD,P2		;GET WORD OFFSET
	LSH P2,-PGSFT		;PAGE NUMBER
	MOVE T1,P2
	CALL MAPRCA		;MAP ADDRESS
	PUSH P,@CST0X+P2	;SAVE CST STATE
	MOVX T4,<PSASM+CSWRB>
	IORM T4,@CST0X+P2	;MAKE IT WRITABLE
	ADDI T1,0(T3)		;STARTING WORD
MEMSC5:	MOVES 0(T1)		;TOUCH IT
	ADDI T1,1
	SOJG P3,MEMSC5		;DO ALL OF RANGE

;SCAN IS DONE

	POP P,@CST0X+P2		;RESTORE CST STATE
	CALL UNMRCA		;UNMAP PAGE
	POP P,UPTPFW
	POP P,UPTPFN
	POP P,UPTPFL
	POP P,UPTPFO
	PION			;RETURN MACHINE TO OTHERS
	CONSZ APR,APSBER	;SBUS ERROR UP?
	JRST .-1		;YEP. WAIT FOR IT
	SETZM MTSADR		;AND CLEAR TEST LOCATION
	JUMPN P1,R		;IF ERRORS, SAY SO
	RETSKP			;OTHERWISE, DONE

;PAGE fault handler for MEMSCN

MEMPT0:	HRRZ T3,UPTPFO		;GET PAGE FAIL PLACE
	CAIE T3,MEMSC5		;RIGHT PLACE?
	CALL MEMXXX		;ERROR!
	SETZM 0(T1)		;ZAP THE WORD
	CONOAPR APFCLR+APMPE	;CLEAR MB ERROR
	AOJA P1,1(T3)		;INDICATE ERROR, AND PROCEED WITH SCAN
   >				;END OF IFN KLFLG

	SUBTTL Gather KL10 Status Block

;THIS CODE GENERATES THE KL10 STATUS BLOCK. THIS BLOCK CONTAINS
;INFORMATION ABOUT THE SYSTEM THAT MAY BE RELEVANT IN DEBUGGING
;HARDWARE FAULTS. THIS ROUTINE IS CALLED ON EVERY BUGHLT,BUGCHK,
;BUGINF AND MASSBUS ERROR.
;ACCEPTS:	T1/ TYPE OF ERROR THAT OCCURRED
;USES PRIVATE STACK BUT CALLER MUST PROVIDE SMALL STACK FOR REG SAVES

;TABLE OF TITLES


   IFN KLFLG,<			;ONLY ON THE KL
BUGBUG:	[SIXBIT 'BUGHLT,BUGCHK, OR BUGINF$/']
MASBUG:	[SIXBIT 'MASSBUS ERROR$/']
ARBUG:	[SIXBIT 'AR ARX PARITY ERROR$/']
APRBUG:	[SIXBIT "APR INTERRUPT$/"]
MASBGX==:MASBUG-BUGBUG		;INDEX VALUE FOR MASSBUS ERROR
BUGPL==^D54			;REQUIRED PDL
RS BUGSP,1			;TO HOLD OLD PDL
RS BUGSPL,BUGPL			;ALLOCATE A STACK

GENBLK::SKIPN STSBLK		;HAVE A STATUS BLOCK
	RET			;NO. NO REPORT THEN
	CONI PI,BUGSPL		;SAVE INCOMING PI STATE
	MOVEM T1,BUGSPL+1	;SAVE INCOMING MESSAGE POINTER
	PIOFF			;YES. STOP MACHINE
	JSR BUGMON		;AND THE FE AS WELL
	MOVEI T1,[SIXBIT '$$$CPU STATUS BLOCK FOR /']
	JSR BUGMSG
	MOVE T1,BUGSPL+1	;GET MESSAGE POINTER
	MOVE T1,BUGBUG(T1)	;GET ADDRESS OF MESSAGE
	JSR BUGMSG
	MOVE P1,STSBLK		;GET BLOCK ADDRESS
	APRID SB%API(P1)	;GET APR ID
	CONI APR,SB%APR(P1)	;GET APR STATUS
	RDERA SB%ERA(P1)	;GET ERROR REG
	MOVE P2,BUGSPL		;GET INCOMING PI STATUS
	MOVEM P2,SB%PIC(P1)	;SAVE IT
	MOVEM P,BUGSP		;SAVE INCOMING STACK
	MOVE P,[IOWD BUGPL,BUGSPL] ;GET TEMP STACK
	DATAI PAG,SB%PGD(P1)	;GET PAGING DATA
	CONI PAG,SB%PGC(P1)	;GET PAGING STATUS
	MOVEI P2,SB%RHC(P1)
	MOVE P3,[CONI 540,0(P2)] ;THE INSTRUCTION
	MOVEI P4,10		;# OF RH20'S
CTLBL0:	XCT P3			;GET CONI
	ADD P3,[4B11+1]		;NEXT RH20, NEXT MEM LOC
	SOJG P4,CTLBL0		;DO THEM ALL
	; ..

;GENBLK CODE CONTINUED

	CONI DTE0,SB%DTC(P1)	;DTE0 STATUS
	CONI DTE1,SB%DTC+1(P1)	;DTE1 STATUS
	CONI DTE2,SB%DTC+2(P1)	;DTE2 STATUS
	CONI DTE3,SB%DTC+3(P1)	;DTE2 STATUS
	MOVEI P2,SB%EP0(P1)	;DEST OF EPT LOCS 0-37
	HRLI P2,KIEPT		;SOURCE OF SAME
	BLT P2,SB%EP0+37(P1)	;DO THEM ALL
	MOVEI P2,SB%EP1(P1)	;DEST OF EPT LOCS 140-177
	HRLI P2,KIEPT+140
	BLT P2,SB%EP1+37(P1)	;DO THEM ALL
	MOVEI P2,SB%UP0(P1)	;DEST OF UPT LOCS 424-427
	HRLI P2,HWPTA+424
	BLT P2,SB%UP0+3(P1)	;DO THEM ALL
	MOVEI P2,SB%UP1(P1)	;DEST OF UPT LOCS 500-503
	HRLI P2,HWPTA+500
	BLT P2,SB%UP1+3(P1)	;DO THEM ALL
	MOVE P4,SB%PGD(P1)	;GET INCOMING DATAI PAG,
	MOVEI P3,HWRACB		;SWITCH TO AC BLOCK 6
	STOR P3,PGPACB,P4	;SET UP TO REFERENCE AC BLOCK 6
	DATAO PAG,P4		;DO IT
	XCTU [DMOVE P2,CSTMSK]	;GET FIRST TWO
	DMOVEM P2,SB%6(P1)	;STORE THEM
	XCTU [DMOVE P2,CSTBR]	;GET NEXT SET
	DMOVEM P2,SB%6+2(P1)
	UMOVE P2,12		;GET REG 12
	MOVEM P2,SB%6+4(P1)	;SAVE IT FOR LATER SCRUTINY
	MOVEI P3,HW7ACB		;AC BLOCK 7
	STOR P3,PGPACB,P4	;INTO DATAO WORD
	DATAO PAG,P4		;SWITCH TO AC BLOCK 7
	XCTU [DMOVE P2,0]	;GET REGS 0 AND 1
	UMOVE P4,2		;GET REG 2
	DMOVEM P2,SB%7(P1)	;STORE IT
	MOVEM P4,SB%7+2(P1)	;SAVE ALL REGS
	DATAO PAG,SB%PGD(P1)	;BACK TO STANDARD AC BLOCKS
	MOVEI T2,SB%SBL		;COUNT OF WORDS IN SBUSDIAG BLOCK
	MOVEI T3,SB%SBD+1(P1)	;WHERE TO PUT BLOCK
	CALL RDDIAG		;READ THEM
	HRRI T3,SB%SBD+1	;START OF SBUSDIAG DATA
	MOVEM T3,SB%SBD(P1)	;STORE IT
	; ..

;ALL DATA GATHERED. NOW TYPE SOME OF IT OUT ON THE CTY.

;FIRST TRY TO QUEUE UP A SYSERR BLOCK

	MOVE P3,T2		;GET COUNT OF WORDS USED BY RDDIAG
	MOVEI T1,SB%SBD-SB%API+1(P3) ;GET WORDS NEEDED
	MOVEM T1,T2		;THIS NEEDED AS WELL
	CALL ALCSEB		;GET A SYSERR BLOCK
	 JRST [	MOVEI T1,[SIXBIT '$$?NO SYSERR BUFFER. EVENT NOT RECORDED$$/']
		JSR BUGMSG	;TYPE IT OUT
		JRST STSBL1]	;AND GO ON
	MOVSI P2,SB%API(P1)	;GET START OF DATA
	HRRI P2,SEBDAT(T1)	;GET DEST OF DATA
	ADDI P3,SB%SBD+SEBDAT(T1) ;COMPUTE END ADDRESS OF DATA
	BLT P2,0(P3)		;MOVE IT
	MOVE P2,T1		;SAVE POINTER
	MOVE T2,[-1,,[SEBPTR 0,SBTEVC,SB%BLK]]
	CALL SEBCPY		;COPY EVENT CODE
	 JFCL
	MOVE T1,P2		;GET BACK BLOCK ADDRESS
	CALL QUESEB		;QUEUE UP THE BLOCK
STSBL1:	MOVEI T1,[SIXBIT '$/']
	JSR BUGMSG		;GET SOME SPACING
	; ..

;ALL DATA GATHERED AND RECORDED IN SYSERR. NOW TYPE OUT SOME
;IMPORTANT RESULTS ON THE CTY

	MOVEI T1,[SIXBIT '$ERA = /']
	JSR BUGMSG
	MOVE T1,SB%ERA(P1)	;GET ERA
	CALL BUGWPT		;OUTPUT IT
	MOVEI T1,[SIXBIT '$CONI APR, = /']
	JSR BUGMSG
	MOVE T1,SB%APR(P1)
	CALL BUGWPT		;TYPE IT
	MOVEI T1,[SIXBIT '$CONI PI, = /']
	JSR BUGMSG
	MOVE T1,SB%PIC(P1)	;GET DATA
	CALL BUGWPT		;TYPE IT
	MOVEI T1,[SIXBIT '$CONI PAG, = /']
	JSR BUGMSG
	MOVE T1,SB%PGC(P1)	;GET DATA
	CALL BUGWPT
	MOVEI T1,[SIXBIT '$DATAI PAG, = /']
	JSR BUGMSG
	MOVE T1,SB%PGD(P1)	;GET DATA
	CALL BUGWPT		;TYPE IT
	MOVEI T1,[SIXBIT '$AR ARX DATA WORD = /']
	JSR BUGMSG
	MOVE T1,SB%7(P1)	;GET IT
	CALL BUGWPT		;TYPE IT
	MOVEI T1,[SIXBIT '$IO PAGE FAIL WORD = /']
	JSR BUGMSG
	MOVE T1,SB%7+2(P1)	;GET DATA
	CALL BUGWPT		;TYPE IT
	MOVEI T1,SB%SBD+1(P1)	;START OF SBUSDIAG DATA
	HLL T1,SB%SBD(P1)	;GET NEG COUNT
	CALL PRISBS		;PRINT SBUS DIAGS
	MOVEI T1,[SIXBIT '$$$$/'] ;CLEAN UP OUTPUT
	JSR BUGMSG		;CLEAN UP CTY OUTPUT
	JSR BUGPRI		;TURN ON FE
	MOVE T1,SB%PIC(P1)	;GET CONI PI,
	MOVE P,BUGSP		;GET INCOMING STACK
	TXNE T1,PIPION		;WAS PI ON WHEN WE GOT HERE?
	PION			;YES, TURN ON MACHINE
	RET			;AND WE ARE DONE

;ROUTINES TO ENABLE/DISABLE STATUS BLOCK REPROTING

	SWAPCD			;FROM JSYS ONLY
GENGEN::SKIPE STSBLK		;NOW ENABLED?
	RET			;YES. DONE
	MOVE T1,[.RESP3,,SB%SBD+SB%SBL+1] ;REQUIRED LENGTH
	MOVX T2,RS%SE0!.RESGP	;FROM GENERAL POOL, SECTION 0
	CALL ASGRES		;GET SPACE
	 ITERR (MONX05)		;INSUFFICIENT RESOURCES - NO RESIDENT FREE PSACE
	MAP T2,0(T1)		;FIND PHYSICAL ADDRESS OF BLOCK
	DMOVEM T1,STSBLK	;START IT UP
	RET			;AND DONE

;DISABLE STATUS BLOCK REPORTING

UNGEN::	SKIPN T1,STSBLK		;HAVE ONE?
	RET			;NO
	SETZM STSBLK		;NOW DISABLED
	CALLRET RELRES		;AND DONE
	RESCD			;AND RETURN TO RESIDENT MONITOR
   >				;END OF IFN KLFLG
	SUBTTL Routines to handle BUGHLT, BUGCHK, BUGINF

;DDT BREAKPOINT LOCATIONS - THESE ARE EXECUTED BY THE ROUTINES
;BELOW DEPENDING ON THE SETTING OF DBUGSW AND DDTPRS.  THEY
;MUST BE IN A WRITABLE AREA SO THAT DDT CAN INSERT THE BREAKPOINT
;INSTRUCTION

RSI HLTADR,<NOP>		;BUGHLT
RSI CHKADR,<NOP>		;BUGCHK
RSI INFADR,<NOP>		;BUGINF

;IMPOSSIBLE SITUATION HALT
;ACTION DEPENDS ON SETTING OF DBUGSW AND DCHKSW
;REACHED VIA JSR BUGHLT

BUGH0::	AOS BUGNUM		;COUNT UP BUG CHECKS SINCE STARTUP
	SOS BUGHLT
	SKIPE DBUGSW		;BREAKPOINT WANTED?
	SKIPN DDTPRS		;YES. DDT LOCKED?
	JRST SKPHLT		;SKIP THE BREAKPOINT

;HERE WHEN DEBUGGING IS ENABLED, DDT IS LOCKED DOWN.
;BREAKPOINT CAN BE PLACED HERE TO ALLOW ANALYSIS OF
;A BUGHLT BEFORE THE DUMP IS TAKEN. PROCEED THE BREAKPOINT TO EFFECT A
;NORMAL RELOAD.

HLTAD0::XCT HLTADR		;EXECUTE THE BREAKPOINT
SKPHLT:
;	SKIPN INSKED		;IN SCHEDULER?
;	CONSZ PI,177B27		;OR IN PI?
;	JRST .+2
;	JRST EXBUGH		;NO, CRASH THIS JOB
	CONI PI,PISV1		;Save PI state for a moment
	PIOFF			;TURN OFF SYSTEM
	AOSE BUGLCK		;FIRST TIME?
	HALT .			;NO!!
	EXCH T1,PISV1		;Get PI state before PIOFF
	MOVEM T1,PISAV		;Put it in a safer place (in case of recursive
				; BUGHLT)
	MOVE T1,PISV1		;Restore T1
	MOVEM 17,BUGACS+17	;SAVE ACS FOR DUMP
	MOVEI 17,BUGACS
	BLT 17,BUGACS+16

;THIS CODE IS REPLACED BECAUSE OF A KL MICROCODE BUG WHERE PREV CONTEXT IS
;MONITOR AND PC NOT SECTION 0/1 (XCDSEC) THEN WE PF ON XCDSEC,,0 INSTEAD OF 
;GETTING AC0 IF U-CODE IS FIXED CHANGE THIS BACK
REPEAT 0,< ;MICROCODE HACK
	STPAC. 17,BUGACU	;SAVE PREVIOUS CONTEXT AC'S
> ;END U-CODE HACK
REPEAT 1,< ;MICROCODE HACK
	MOVEI T1,20		;NUMBER OF ACS
	SETZ T2,		;SOURCE
	XMOVEI T3,BUGACU	;DEST
	XCT 2,[XBLT. T1]	;DO PXCT OF XBLT
> ;END U-CODE HACK
				;HAVE PRIMARY PROTOCOL?
	JSR BUGMON		;YES. SWITCH TO MONITOR FOR THIS
	MOVE P,[-BUGPLN,,BUGPDL-1]
	XMOVEI T1,[HALT .]	;GET A HALT INSTUCTION
   IFN KLFLG,<
	PUSH P,UPTPFN		;SAVE OLD PF HANDLER
	MOVEM T1,UPTPFN		;AND SET IT UP IN CASE
   >				;END OF IFN KLFLG
   IFN KCFLG,<
	PUSH P,KCPFNP		;SAVE OLD PAGE FAULT HANDLER
	MOVEM T1,KCPFNP		;AND SET IT UP IN CASE
   >				;END OF IFN KCFLG
	CALL CASHOF		;TURN CASH OFF IN CASE DUMP
	CALL SYRMAP		;CHECK OUT SYSERR BLOCKS
	 CALL [	CAIN T1,SEC%PT	;AR/ARX ERROR?
		JRST [	CALLRET PFERRB] ;YEP. DO IT
		CAIN T1,SEC%P1	;MB PARITY?
		CALL MBERRB	;YEP. DO IT
		RET]
	MOVEI 1,[SIXBIT \$**********$*BUGHLT "/\]
	JSR BUGMSG		;TYPE CRASH MESSAGE
	MOVE T1,BUGHLT		;Get address of BUGHLT block
	MOVE T2,T1		;Save T1
	XHLLI T1,(T2)		;Get section #
	HRR T1,(T2)		; and section-local part of BUGHLT address
	MOVE Q1,T1		;STORE ADDRESS
	;..

	;..
BUGH3:	XMOVEI T2,1000(Q1)	;Get ending address
	CAML T1,T2		;Looked far enough?
	HALT .			;SUPER LOSSAGE
	MOVE T2,1(T1)		;FIND THE SIXBIT NAME
	TLNN T2,770000		;IS THIS SIXBIT?
	AOJA T1,BUGH3		;NO, KEEP LOOKING
	MOVEM T2,BUGNAM		;[7.1158] Save SIXBIT name for SETSPD's use
	MOVE T3,[POINT 6,T2]	;SET UP TO TYPE OUT NAME
BUGH1:	ILDB T1,T3		;GET A CHARACTER
	ADDI T1," "		;MAKE IT ASCII
	JSR BUGTYO		;TYPE IT OUT
	TLNE T3,770000		;DONE?
	JRST BUGH1		;NO, LOOP BACK TILL ALL ARE TYPED
	MOVEI T1,42		;TYPE OUT DOUBLE QUOTE
	JSR BUGTYO
	SKIPN BUGTIM		;ARE DATE AND TIME SET UP YET
	JRST BUGH7		;NO, JUST LOOK FOR ADDITIONAL INFO
	MOVEI T1,[SIXBIT \ AT /\]
	JSR BUGMSG
	MOVNI T2,17		;MAX NUMBER OF CHARACTERS IN TIME & DATE
	MOVE T3,[POINT 7,BUGTIM] ;GET POINTER TO TIME & DATE
BUGH4:	ILDB T1,T3		;GET A CHARACTER
	JUMPE T1,BUGH5		;JUMP IF END OF STRING
	JSR BUGTYO		;TYPE CHARACTER OUT
	AOJN T2,BUGH4		;JUMP IF MORE CHARACTERS
BUGH5:	CONSZ PI,177B27		;ARE WE AT INTERRUPT LEVEL?
	JRST BUGH7		;YES, FORGET USER AND JOB
	SKIPG INSKED		;IN PROCESS CONTEXT?
	SKIPGE FX,FORKX		;WAS A USER RUNNING? SNAG FX FOR LOAD.
	JRST BUGH7		;NO, CONTINUE ON
	LOAD T1,FKJSB		;GET JSB PAGE ADDRESS
	MOVE T1,SPT(T1)
	TXNE T1,NCORTM		;IS JSB IN CORE
	JRST BUGH7		;NO, FORGET THIS
	MOVEI T1,[SIXBIT \$*JOB: /\]
	JSR BUGMSG
	MOVE T1,GBLJNO		;GET JOB NUMBER
	JSR BUGNO		;PRINT IT
	MOVEI T1,[SIXBIT \, USER: /\]
	JSR BUGMSG
	MOVE T3,USRNAM		;GET NUMBER OF WORDS IN USER NAME
	IMULI T3,5		;5 CHARACTERS PER WORD
	MOVE T2,[POINT 7,USRNAM+1] ;GET POINTER TO USER NAME
BUGH6:	ILDB T1,T2
	JUMPE T1,BUGH7		;JUMP IF END OF STRING
	JSR BUGTYO		;TYPE CHARACTER
	SOJN T3,BUGH6		;JUMP IF MORE CHARACTERS
BUGH7:	MOVE T2,1(Q1)		;GET FIRST WORD OF BUGHLT BLOCK
	TLNE T2,770000		;IS THIS SIXBIT?
	JRST BUGH10		;YES, THERE IS NO ADDITIONAL INFO
	MOVEI T1,[SIXBIT \$*ADDITIONAL DATA: /\]
	JSR BUGMSG
	;..
	;..
BUGH8:
  REPEAT 0,<		;**NEW FEATURE NOT YET FULLY READY **
	MOVE T1,2(Q1)		;GET DATUM IDENTIFIER TO PRINT FIRST
	JSR BUGMSG
	MOVEI T1,[SIXBIT /=/]
	JSR BUGMSG
  >
	MOVE T2,1(Q1)		;GET DATA ADDRESS
	CAIG T2,17		;IS THIS AN AC?
	JRST [ MOVE T1,BUGACS(T2) ;YES,GET CONTENTS OF AC
		JSR BUGNO	;PRINT CONTENTS
		JRST BUGH9]
	MAP T1,(T2)		;IS THIS ADDRESS IN CORE?
	SMAPOK T1		;SKIP IF REF WOULD BE OK
	 JRST BUGH9		;NO MAPPING. DON'T TRY TO PRINT IT
	MOVE T1,(T2)		;GET THE CONTENTS OF LOCATION
	JSR BUGNO		;PRINT IT OUT
BUGH9:	AOS Q1
  REPEAT 0,<AOS Q1>		;GOES WITH NEW FEATURE ABOVE
	MOVE T2,1(Q1)		;GET NEXT ARGUMENT WORD
	TLNE T2,770000		;IS IT SIXBIT?
	JRST BUGH10		;YES, FINISHED
	MOVEI T1,[SIXBIT \, /\]
	JSR BUGMSG
	JRST BUGH8		;GET NEXT DATUM PRINTED

BUGH10:	MOVEI 1,[SIXBIT \$**********$/\]
	JSR BUGMSG
	JSR BUGPRI		;BACK INTO PRIMARY
BUGH2:
;**** NOTE WELL **** The following instruction assmues that the PC and flags
;do not overlap.
	LOAD T1,EXPCBT,BUGHLT	;GET ADDRESS OF BUGHLT
	MOVX P1,BG%HLT		;SAY THIS IS A BUGHLT
	CALL BUGSTO		;QUEUE UP A SYSERR BLOCK
   IFN KLFLG!KCFLG,<
	CALL XCKLP		;STOP THE CI
	CALL XCKNI		;STOP THE NI
	CALL LOADME		;LET THE FRONT END REBOOT US
   >				; END IFN KLFLG!KCFLG
	HALT .			;WAIT TO BE REBOOTED
	JRST SYSGO		;RELOAD AND RESTART

;LESS SERIOUS HALT - BUGCHK

BGCCHK::			;HERE VIA CALL BGCCHK
BUGC0::	AOS BUGNUM		;COUNT UP BUGCHK'S AND BUGINF'S SINCE STARTUP
	SKIPE DCHKSW		;BREAKPOINT WANTED?
	SKIPN DDTPRS		;YES. DDT LOCKED?
	JRST SKPCHK		;SKIP THE BREAKPOINT
	MOVEM T1,BUGCHK		;SAVE T1
	MOVE T1,0(P)		;GET THE CALLING ADDRESS
	EXCH T1,BUGCHK		;RESTORE T1 AND SET BUGCHK

;HERE WHEN DEBUGGING IS ENABLED, DDT IS LOCKED DOWN.
;A BREAKPOINT CAN BE PLACED HERE TO ALLOW ANALYSIS OF
;A BUGCHK

CHKAD0::XCT CHKADR		;YES, EXECUTE BREAKPOINT
SKPCHK:	PUSH P,0		;MAKE SLOT ON STACK
	CONI PI,0(P)		;SAVE PI STATE HERE
	PIOFF
	AOSN BUGLCK		;[7.1081] First time through here?
	IFSKP.			;[7.1081] If not
	  PUSH P,T1		;[7.1081] Save an AC
	  MOVE T1,DOBSTS	;[7.1081] Load DOB status word
	  TXNN T1,DB%DIP	;[7.1081] Is there a dump in progress?
	  HALT .		;[7.1081] No, halt now
	  POP P,T1		;[7.1081] Remove saved T1 from stack
	  EXCH T1,(P)		;[7.1081] Swap origional T1 with saved CONI PI
	  TXNE T1,PIPION	;[7.1081] PI was ON?
	  PION			;[7.1081] Yes, turn it back on
	  POP P,T1		;[7.1081] Get back the saved T1
	  AOS BUGLST		;[7.1081] Count lost BUG
	  RET			;[7.1081] Return doing very little
	ENDIF.			;[7.1081] 
	MOVEM 17,BUGACS+17	;SAVE ACS
	MOVEI 17,BUGACS
	BLT 17,BUGACS+16

;NOW START LOOKING FOR INFORMATION TO PUT IN SYSERR BLOCK

	MOVE P,BUGACS+P		;GET BACK P FOR A MOMENT
	MOVE T1,-1(P)		;BUGCHK ADR
	MOVEM T1,BUGCHK		;LEAVE TRACKS
	MOVE P,[-BUGPLN,,BUGPDL-1] ;GET A STACK
	XMOVEI T1,-1(T1)	;MAKE PTR TO INSTRUCTION
	MOVX P1,BG%CHK		;SAY THIS IS A BUGCHK

;COMMON FINISH FOR BUGCHK AND BUGINF

BUGFIN:	PUSH P,T1		;[7.1081] Save address of BUG
	PUSH P,P1		;[7.1081]  and CHK/INF bit
	CALL BUGSTO		;GO CREATE SYSERR ENTRY
	POP P,T2		;[7.1081] Restore CHK/INF bit
	POP P,T1		;[7.1081]  and BUG address
	CALL DODOB		;[7.1081] (T1,T2/) See if we should dump this 
	MOVSI 17,BUGACS		;RESTORE ACS
	BLT 17,17
	SETOM BUGLCK		;UNLOCK
	EXCH T1,0(P)		;SAVE T1, GET PI STATUS
	TXNE T1,PIPION		;NEED TO ENABLE?
	PION
	POP P,T1		;RESTORE T1
	AOS JB0FLG		;GET IT REPORTED
	RET			;RETURN

;PROCESS BUGINF

BGCINF::			;HERE VIA CALL BUGINF
BUGI0::	AOS BUGNUM		;COUNT UP BUGCHK'S AND BUGINF'S SINCE STARTUP
	SKIPE DINFSW		;BREAKPOINT WANTED?
	SKIPN DDTPRS		;YES. DDT LOCKED?
	JRST SKPINF		;SKIP THE BREAKPOINT
	MOVEM T1,BUGINF		;SAVE T1
	MOVE T1,-1(P)		;GET THE ADDRESS OF THE CALLER
	EXCH T1,BUGINF		;SAVE BUGINF AND RESTORE T1

;HERE WHEN DEBUGGING IS ENABLED, DDT IS LOCKED DOWN. A BREAKPOINT CAN BE
;PLACED HERE TO ALLOW ANALYSIS OF A BUGINF

INFAD0::XCT INFADR		;YES, EXECUTE BREAKPOINT
SKPINF:	PUSH P,0		;MAKE SLOT ON STACK
	CONI PI,0(P)		;SAVE PI STATUS
	PIOFF
	AOSN BUGLCK		;[7.1081] First time through here?
	IFSKP.			;[7.1081] If not
	  PUSH P,T1		;[7.1081] Save an AC
	  MOVE T1,DOBSTS	;[7.1081] Load DOB status word
	  TXNN T1,DB%DIP	;[7.1081] Is there a dump in progress?
	  HALT .		;[7.1081] No, halt now
	  POP P,T1		;[7.1081] Remove saved T1 from stack
	  EXCH T1,(P)		;[7.1081] Swap origional T1 with saved CONI PI
	  TXNE T1,PIPION	;[7.1081] PI was ON?
	  PION			;[7.1081] Yes, turn it back on
	  POP P,T1		;[7.1081] Get back the saved T1
	  AOS BUGLST		;[7.1081] Count lost BUG
	  RET			;[7.1081] Return doing very little
	ENDIF.			;[7.1081] 
	MOVEM 17,BUGACS+17	;SAVE ACS
	MOVEI 17,BUGACS
	BLT 17,BUGACS+16

;ROUTINE TO GENERATE INFORMATION FOR SYSERR BLOCK FOR BUGINFS.

	MOVE P,BUGACS+P		;GET BACK P FOR A MOMENT
	MOVE T1,-1(P)		;GET ADDRESS OF BUGINF
	MOVEM T1,BUGINF		;LEAVE TRACKS
	XMOVEI T1,-1(T1)	;...
	MOVE P,[-BUGPLN,,BUGPDL-1] ;GET A STACK
	MOVX P1,BG%INF		;SAY THIS IS A BUGINF
	JRST BUGFIN		;JOIN BUGCHK TO FINISH UP

;ROUTINE TO BUILD A SYSERR BLOCK
;ACCEPTS IN T1/	POINTER TO BUG HLT/CHK BLOCK
;	    P1/	HLT/CHK
;CALLED BY BUGHLT, BUGCHK, AND BUGINF CODE

BUGSTO:	EA.ENT			;NEEDED TO REFERENCE FORK TABLES
	ACVAR <BLK>		;USED TO SAVE BLOCK ADDRESS
	MOVE T2,T1		;To T2
	XHLLI T1,(T2)		;Get section #
	HRR T1,(T2)		; and destination address of block
	MOVEM T1,BUGP1		;SAVE POINTER TO BLOCK
	SETOM CRSTD1		;INITIALIZE TIME OF CRASH
	SKIPGE TADIDT		;TIME AND DATE NOW SET?
	JRST BUGST0		;NO
	MOVE T1,TADIDT		;GET INITIAL TIME
	MOVEM T1,CRSHTM		;SAVE IN LOW CORE FOR RELOAD
	MOVE T1,TODPWL		;YES, REMEMBER IT FOR RESTART
	MUL T1,[1B17]		;COMPUTE UNIV FORMAT (SEE GTAD)
	DIV T1,JFDAY
	CAML T2,JFDAY2
	AOS T1
	ADD T1,TADIDT
	MOVEM T1,CRSTD1		;PUT WHERE WILL SURVIVE OVER RELOAD

BUGST0:	MOVE T1,BUGCNT		;SEE HOW MANY ARE IN QUEUE
	CAIL T1,BUGMAX		;TOO MANY?
	JRST BUGSTX		;[7.1158] Yes, count lost BUG and lose
	MOVX T1,BG%LEN		;GET LENGTH OF DATA SEG OF SYSERR BLK
	MOVX T2,BG%SIZ		;GET SIZE OF BLOCK
	CALL ALCSBX		;ALLOCATE A SYSERR BLOCK
	 JRST BUGSTX		;[7.1158] No space left, count lost BUG & exit
	AOS BUGCNT		;COUNT UP THE QUEUED UP BLOCKS
	MOVEM T1,BUGSEB		;SAVE ADR OF BLOCK
	MOVE T2,[-BUGTLN,,BUGTBL]
	CALL SEBCPY		;LOAD UP BLOCK
	 JFCL			;IGNORING ERRORS
	MOVEI T1,20		;LENGTH OF BLT FOR ALL THE ACS
	XMOVEI T2,BUGACS	;GET THEM FROM THE BUGGY ACS
	MOVE T3,BUGSEB		;GET POINTER TO BLOCK
	XMOVEI T3,SEBDAT+BG%ACS(T3) ;PUT THEM INTO BG%ACS
	EXTEND T1,[XBLT]	;BLT
	MOVE T1,BUGSEB		;GET BACK THE POINTER TO THE BLOCK
	MOVEM P1,SEBDAT+BG%FLG(T1) ;SAVE CHK/HLT FLAG
	CONI PI,SEBDAT+BG%PIS(T1) ;SAVE PI FLAGS IN BLOCK
	CONI APR,SEBDAT+BG%APS(T1) ;SAVE APR FLAGS IN BLOCK
	CONI PAG,SEBDAT+BG%PGS(T1) ;SAVE PAGER FLAGS IN BLOCK
	DATAI PAG,SEBDAT+BG%PGD(T1) ;SAVE PAGER DATA IN BLOCK
   IFN KLFLG,<			;IF ON THE KL
	RDERA SEBDAT+BG%ERG(T1)	;READ ERROR REGISTER
   >				;END OF IFN KLFLG
	HRRZ T2,FORKX		;SEE IF THERE IS A FORK RUNNING
	HRLOM T2,SEBDAT+BG%JOB(T1) ;SAVE FORK NUMBER IN BLOCK
	CAIE T2,-1		;ANY FORK THERE?
	SKIPGE FKPT(T2)		;...
	JRST BUGST1		;NO, NO JOB EITHER
	MOVE BLK,T1		;[7240]SAVE THE BLOCK ADDRESS
	HLRZ T1,FKJOB(T2)	;[7240]GET LOCAL JOB NUMBER
	HRR T2,JOBDIR(T1)	;[7240]GET LOGGED-IN DIRECTORY NUMBER
	HRLI T2,USRLH		;[7240]MAKE THIS A USER NUMBER
	MOVEM T2,SEBDAT+BG%USR(BLK) ;[7240]STORE IN BLOCK
	CALL LCL2GL		;[7240](T1/T1)CONVERT JOB NUMBER TO GLOBAL
	IFNSK.
	 MOVE T1,BLK		;[7240]RESTORE THE BLOCK ADDRESS
	 JRST BUGST1		;[7240]ASSUME NO SUCH JOB
	ENDIF.
	MOVE T2,T1		;[7240]GET GLOBAL JOB NUMBER IN T2
	MOVE T1,BLK		;[7240]RESTORE BLOCK ADDRESS
	HRRM T2,SEBDAT+BG%JOB(T1) ;[7240]SAVE JOB NUMBER
	ENDAV.			;[7240]
	;..
	;..
BUGST1:	SETZM SEBDAT+BG%RCT(T1)	;MARK NO REGISTERS CURRENTLY
	ADDI T1,SEBDAT+BG%REG	;MAKE POINTER TO REGISTER BLOCK
	MOVEM T1,BUGP2		;SAVE POINTER
	CAIE P1,BG%HLT		;[7.1081] Was it a BUGHLT?
	AOS BUGP1		;[7.1081] No, bump pointer past config word
BUGSTL:	AOS BUGP1		;STEP POINTER TO BUG CHECK BLOCK
	MAP T2,@BUGP1		;CHECK ADDRESS BEFORE REFERENCING
	SMAPOK T2		;OK TO REF PAGE?
	IFNSK.
	  SETZ T2,
	  JRST BUGSTD		;CAN'T REFERENCE BLOCK, USE 0 FOR NAME
	ENDIF.
	MOVE T2,@BUGP1		;GET FIRST DATA WORD IN BLOCK
	TLNE T2,770000		;SIXBIT NAME?
	JRST BUGSTD		;YES, DONE
	MOVEM T2,BUGP3		;SAVE POINTER TO REGISTER TO GET
	CAIL T2,20		;AN AC?
      IFSKP.
	MOVE T2,BUGACS(T2)	;YES, GET IT FROM SAVED AC BLOCK
      ELSE.
	MAP T2,@BUGP3		;CHECK ADDRESS BEFORE REFERENCING
	SMAPOK T2		;OK TO REFERENCE IT?
	 TDZA T2,T2		;NO, USE 0 AND SKIP REF
	MOVE T2,@BUGP3	;GET CONTENTS OF REGISTER
      ENDIF.
	MOVEM T2,@BUGP2		;SAVE IT IN SYSERR BLOCK
	AOS BUGP2		;STEP POINTER TO SYSERR BLOCK
	MOVE T2,BUGSEB		;GET POINTER TO BLOCK
	AOS SEBDAT+BG%RCT(T2)	;COUNT UP REGISTER COUNT
	JRST BUGSTL		;LOOP BACK TIL ALL COPIED

BUGSTD::MOVE T1,BUGSEB		;GET POINTER TO BLOCK AGAIN
	MOVEM T2,SEBDAT+BG%NAM(T1) ;SAVE SIXBIT NAME OF BUG CHECK
	MOVEM T2,BUGNAM		;[7.1081] Save SIXBIT name for SETSPD's use
	CALL QUESEB		;QUEUE UP ERROR BLOCK
BUGST2:
   IFN KLFLG,<			;IF THE KL
	MOVEI T1,BUGBUG-BUGBUG	;GET PROPER INDEX FOR MESSAGE
	CALL GENBLK>		;DO STATUS
	RET

;HERE ON FAILURE.

BUGSTX:	AOS BUGLST		;[7.1158] Count lossage, no SYSERR entry
	JRST BUGST2		;[7.1158] Continue with CPU status then return


BUGTBL:	SEBPTR 0,SBTEVC,SEC%BG	;EVENT CODE
	SEBPTR 0,SBTFNA,LOGBUG	;CALL LOGBUG TO GET MESSAGE STRING
	SEBPTR BG%ADR,SBTWD,BUGP1 ;ADDRESS OF BUG HLT/CHK
	SEBPTR BG%DAT,SBTWD,CRSTD1 ;TIME AND DATE OF CRASH
	SEBPTR BG%SER,SBTWD,APRSER ;APR SERIAL NUMBER
	SEBPTR BG%VER,SBTWD,[EXP SVNM] ;VERSION
	SEBPTR BG%SDT,SBTWD,SYSTAD ;BUILD TAD OF MONITOR BUILD
	SEBPTR BG%CNT,SBTWD,BUGNUM ;NUMBER OF BUG CHECKS SINCE STARTUP
BUGTLN==.-BUGTBL
	SUBTTL Write to CTY when PI's are off

;THESE ROUTINES SEND DATA TO THE CTY WHEN PI'S ARE OFF. NOTE THAT
;BUGT0 WAITS FOR CONFIRMATION THAT A CHARACTER WAS SENT

;HERE VIA JSR BUGTYO
;SEND A CHARACTER, AND FILL WITH NULLS IF IT'S A LINE FEED

BUGTY0::
	JSR BUGTYC		;OUTPUT THE CHARACTER
	CAIN 1,12		;LF?
	JRST [	MOVEI 1,0	;YES, PAD
		JSR BUGTYC
		JSR BUGTYC
		JSR BUGTYC
		JSR BUGTYC
		JRST .+1]
	JRST @BUGTYO		;RETURN TO CALLER

;HERE VIA JSR BUGTYC
;OUTPUT A SINGLE CHARACTER AND WAIT FOR IT TO GO.
;	T1/ CHARACTER TO BE SENT

BUGT0::
   IFN KCFLG,<			;KC TYPE OUT ROUTINE
	CALL CNBOUT		;DOES A CALL, SO MUST HAVE A STACK!
   >				;END OF KCFLG NE CONDITIONAL

   IFN DTFLG,<			;THE KL BUG TYPE OUT CODE
	SETZM DTETMD		;CLEAR FLAG
	TXO A,DTEMNO		;SET COMMAND FOR OUTPUT
	MOVEM A,DTECMD		;SET IN COMMAND WORD
	MOVEI A,DTEEDB		;MUST RING BELL
	XCT DTSCNW		;DO IT
	SKIPN DTETMD		;WAIT FOR RESPONSE
	JRST .-1
	LDB A,[POINT 7,DTECMD,35] ;RESTORE CHARACTER
   >				;END OF DTFLG NE CONDITIONAL
	JRST @BUGTYC		;RETURN TO CALLER

;HERE VIA JSR BUGMSG
;TYPE A STRING. REPLACE "$" WITH <CR><LF>. TERMINATE ON "/".
;	T1/ ADDRESS OF STRING

BUGMS0::
	MOVEM 7,BUG7		;PRESERVE AN AC
	MOVE 7,1
	HRLI 7,440600
BUGM2:	ILDB 1,7
	ADDI 1,40
	CAIN 1,"/"
	JRST BUGM5		; / MARKS END OF STRING
	CAIN 1,"$"
	JRST BUGM1
BUGM3:	JSR BUGTYO
	JRST BUGM2

;FOUND A "$". REPLACE IT WITH <CR><LF>.

BUGM1:	MOVEI 1,15
	JSR BUGTYO
	MOVEI 1,12
	JRST BUGM3

;FOUND A "/". THIS COMPLETES THE STRING

BUGM5:
BUGM6:	MOVE 7,BUG7		;RESTORE AC
	JRST @BUGMSG		;RETURN TO CALLER

RS BUG7,2			;TEMP

;HERE VIA JSR BUGNO
;TYPE A NUMBER
;	T1/ THE VALUE TO BE TYPED

BUGNO0::
	DMOVEM T2,BUG7			;PRESERVE AN AC
	MOVE T2,T1
	MOVNI T3,14			;THERE ARE 14 DIGITS IN NUMBER
BUGN1:	SETZ T1,
	LSHC T1,3			;GET FIRST DIGIT
	ADDI T1,60			;MAKE IT ASCII
	JSR BUGTYO			;TYPE IT OUT
	AOJN T3,BUGN1			;LOOP FOR ALL DIGITS
	DMOVE T2,BUG7			;RESTORE AC'S
	JRST @BUGNO			;RETURN

;LOCAL TYPOUT OF WORD IN OCTAL

BUGWPT:	PUSH P,T1
	HLRZ T1,T1
	CALL BUGOPT		;TYPE LH
	MOVEI T1,","
	JSR BUGTYO
	JSR BUGTYO
	POP P,T1
	HRRZ T1,T1
	CALL BUGOPT		;TYPE RH
	RET

;NON-PI OCTAL NUMBER TYPEOUT ON CONSOLE TTY

;8-OCTIT, USED FOR PHYSICAL ADDRESSES

BUGOP8:	SAVEAC <Q1,Q2>
	MOVE Q2,[POINT 3,Q1,11]
	JRST BUGOP0

;6-OCTIT

BUGOPT:	SAVEAC <Q1,Q2>
	MOVE Q2,[POINT 3,Q1,17]
BUGOP0:	MOVEM T1,Q1		;SAVE NUMBER
BUGOPA:	ILDB T1,Q2		;GET NEXT OCTIT
	ADDI T1,"0"		;CONVERT TO ASCII
	JSR BUGTYO		;TYPE IT
	TXNE Q2,77B5		;BYTE PTR AT END OF WORD?
	JRST BUGOPA		;NO, LOOP
	RET			;YES, DONE
	SUBTTL Routines to switch protocols with front end

   IFN DTFLG,<

;HERE VIA JSR BUGMON
;ENTER SECONDARY PROTOCOL

BUGM0::
	DMOVEM T1,BUG7		;SAVE WORK REGISTERS
	MOVE T2,MSTRDT		;GET ID OF MASTER DTE
	LSH T2,SDTE		;FIND DTE SET
	SKIPN T1,DTEEPW(T2)	;IN PRIMARY?
	JRST BUGEXT		;NO. ALL DONE
	MOVEM T1,SVVEXM		;SAVE VALUE
	SETZM DTEEPW(T2)	;FORCE MONITOR PROTOCOL
	MOVEI T1,DTEEDB		;GET CODE FOR DOOR BELL
	MOVE T2,DTSCNW		;GET CONO WORD
	ADD T2,[<CONSZ 0>-<CONO 0>] ;MAKE A TEST INSTRUCTION
	XCT T2			;WAIT FOR -11 DOORBELL TO CLEAR
	JRST .-1
	MOVEI T1,DTEEMP		;GET COMMAND
	SETZM DTEFLG		;CLEAR FLAG
	MOVEM T1,DTECMD		;THE COMMAND WORD
	MOVEI T1,DTEEDB		;MUST RING BELL
	XCT DTSCNW		;DO IT
	SKIPN DTEFLG		;-11 ANSWER?
	JRST .-1		;NO
BUGEXT:	DMOVE T1,BUG7		;RESTORE REGS
	JRST @BUGMON		;YES. DONE

;HERE VIA JSR BUGPRI
;ENTER PRIMARY PROTOCOL

BUGP0::
	DMOVEM T1,BUG7		;SAVE REGS
	MOVE T2,MSTRDT		;GET ID OF MASTER DTE
	LSH T2,SDTE		;FIND EPT SET
	SKIPE DTEEPW(T2)	;NOW IN MONITOR PROTOCOL?
	JRST BUGEX1		;NO. JUST GET OUT
	SKIPN T1,SVVEXM		;GET SAVED VALUE
	JRST BUGEX1		;NO. NOTHING TO DO
	SETZM SVVEXM		;LEAVE IT 0 FOR THE NEXT GUY
	MOVEM T1,DTEEPW(T2)	;TURN ON VALID EXAMINE
	MOVEI T1,DTEEPP		;ENTER PRIMARY
	SETZM DTEFLG		;THE FLAG
	MOVEM T1,DTECMD		;THE COMMAND WORD
	MOVEI T1,DTEEDB		;SET UP TO RING -11'S BELL
	XCT DTSCNW		;DO IT
	SKIPN DTEFLG		;ANSWER YET?
	JRST .-1		;NO
BUGEX1:	DMOVE T1,BUG7		;RESTORE REGS
	JRST @BUGPRI		;YES. ALL DONE
   >

   IFN KCFLG,<

BUGM0::	JSR KCMON		;Go do KC style of protocol switch
	JRST @BUGMON		;And done
BUGP0::	JSR KCPRI		;Go do KC style
	JRST @BUGPRI		;And done
   >				;End of IFN KCFLG

   IFN SMFLG,<

;HERE VIA JSR BUGMON -- ENTER MONTIOR MODE

BUGM0::	SKIPE PROFLG		;IF PROTOCOL POSSIBLE DO IT
	JRST [	SETZM FEFLG	;CLEAR FE FLAG
		MOVEM T1,SVVEXM	;SAVE REGISTER
		MOVE T1,RLWORD	;GET RELOAD WORD
		EXCH T1,SVVEXM ;RESTORE REGISTER AND SAVE RELOAD WORD
		SETZRO KPACT	;STOP KEEPALIVE
		JRST .+1]
	JRST @BUGMON

;HERE VIA JSR BUGPRI -- ENTER PRIMARY MODE

BUGP0::	SKIPE PROFLG		;IF PROTOCOL POSSIBLE DO IT
	AOS FEFLG		;SET FLAG
	EXCH T1,SVVEXM		;RESTORE RELOAD WORD
	MOVEM T1,RLWORD
	MOVE T1,SVVEXM		;RESTORE REGISTER
	JRST @BUGPRI		;RETURN

   >				;END IFN SMFLG

	SUBTTL Clock Service

;CLOCK INITIALIZATION

CLKINI:	MOVE T1,[^D<24*3600*1000>]
	MOVEM T1,JFDAY		;COMPUTE JIFFIES PER DAY
	IDIVI T1,2		;AND HALF THAT FOR ROUNDING
	MOVEM T1,JFDAY2
	MOVX T1,BASOV0		;COMPUTE HP CLOCK OVERFLOW VALUE
	SETZ T2,
	DIV T1,BASNDV
	MOVEM T1,BASOVV		;SAVE IT FOR USE BY MTIME CALLERS
   IFN KLFLG,<
	MOVE T1,[XPCW TIMINT]
   >
   IFN KCFLG,<
	MOVE T1,[TIMINT]
>
	MOVEM T1,TIMVIL
	CALL MTRON		;TURN ON METER AND INTERVAL TIMER
	RET

;MTRON - Enable meter updates.

MTRON::

;Turn on the interval counter. Clear it (TIMCIC), turn it on (TIMITO),
;clear flags (TIMDON), and initialize its period (TIMTMS)

   IFN KLFLG,<
	CONO TIM,TIMCIC+TIMITO+TIMDON+TIMTMS
   >
   IFN KCFLG,<
	WRINT TIMCIC+TIMITO+TIMDON+TIMTMS
   >

   IFN KLFLG,<

;Turn on the time base, and assign interrupt level for interval counter
;Load accounts (MTRLOD), turn on time base (MTRTBN), clear time base (MTRCTB),
;turn on accounting (MTRAMN), assign interrupt level (TIMCHN).
;PIBITS is defined in STG as 0 but can be changed to enable accounting
;for PI or non-PI exec mode

	CONO MTR,MTRLOD+MTRTBN+MTRCTB+MTRAMN+PIBITS+FLD(TIMCHN,MTRPIA)
   >				;END OF IFN KLFLG

   IFN KCFLG,<

;Turn on the time base, and assign interrupt level for interval counter
;Load PI level for timer (WRBLPI), load time base controls (TMBLTB),
;clear time base (WTBCTB), turn on time base (TMBBON), assign interrupt
;level (TIMCHN).

	WRTMB TMBLPI+TMBLTB+TMBCTB+TMBBON+FLD(TIMCHN,TMBPIA)

;Turn on user run time meter. Load controls (ACTLOD), turn on meter (ACTAON)
;PIBITS is defined in STG as 0 but can be changed to enable accounting
;for PI or non-PI exec mode

	WRACT ACTLOD+ACTAON+PIBITS
   >				;End of IFN KCFLG

	RET			;AND DONE

;INTERVAL TIMER INTERRUPT SERVICE
;The timer counts in units of 10 usec. We set it to interrupt once per ms.
;The scheduler stores a number of milliseconds in SCKATM. When the clock
;interrupts, this routine decrements the count. When the count goes to zero,
;it issues a channel 7 interrupt, which causes the scheduler to run at PISC7.

;NOTE: On both the KL and the KC, the counter is automatically cleared
;when DONE is set and the interrupt occurs. Thus this code turns on the timer
;(TIMITO), clears flags (TIMDON), and sets the interval (TIMTMS). It does
;not clear the counter.
TIMIN0:
   IFN KLFLG,<CONO TIM,TIMITO+TIMDON+TIMTMS> ;CLEAR DONE
   IFN KCFLG,<WRINT TIMITO+TIMDON+TIMTMS>


	SOSN SCKATM		;DECREMENT SCHED ALARM, DUE NOW?
	ISB SCDCHN		;YES. CAUSE LEVEL 7 INTERRUPT
	XJEN TIMINT		;DISMISS INT


;UPDATE TODCLK - DONE ONLY ON REQUEST
;Read the time base and convert to milliseconds for TODCLK

UPDTCK::RDTIME T1		;READ TIME BASE
	DIV T1,BASDIV		;CONVERT TO MILLISECONDS
	MOVEM T1,TODCLK		;UPDATE MS CLOCK
	MOVEM T1,TODPWL		;UPDATE GTAD CLOCK
	RET

;read clock, convert to normal millisecond units

GETMST::RDTIME T1		;READ TIME BASE
	DIV T1,BASDIV
	RET

;READ HIGH-PRECISION CLOCK
;Convert time base to high precision clock units modulo 2**36-1.
;	JSP T4,MTIME
;Returns via T4: always
;	T1/ time base as converted in 10 microsec
;	CX/ time base in units as small as possible   /WARNING- CX IS USED/

MTIME::	RDTIME T1		;READ TIME BASE
	ANDI T1,BASOV0-1	;DO MODULO 76 HOURS
;	ASHC T1,-<^D35-BASBIT>	;TIME IN T2 IN MICROSECONDS
;	MOVE CX,T2		;STORE IT IN CX
;	DIV T1,BASDV2		;CONVERT TO HP UNITS
	DIV T1,BASNDV 		;CONVERT TO HP UNITS
	JRST 0(4)



;GETMID - ROUTINE TO GENERATE A MEDIA ID FOR A STRUCTURE. THE LOW ORDER
;	  PART OF TIMBAS IS USED, SINCE AT STRUCTURE CREATION TIME THE
;	  NORMAL TIME AND DATE (A LA LGTAD) MAY NOT YET EXIST.
;
;CALL:		CALL GETMID
;RETURNS: +1 ALWAYS, WITH T1/ MEDIA ID

   IFN KLFLG,<
GETMID::MOVE T1,TIMBAS+1	;GET LOW ORDER PART OF TIMBAS AS MEDIA ID
   >				;END IFN KLFLG
   IFN KCFLG,<
GETMID::PUSH P,T2		;SAVE T2
	RDTIME T1		;READ TIME BASE
	EXCH T1,T2		;RETURN LOW ORDER TIME BASE
	POP P,T2		;RESTORE T2
   >				;END IFN KCFLG
	RET			;RETURN
	SUBTTL DTE Control Routines

;DTE20 INITIALIZATION
;START MONITOR IN SECONDARY PROTOCOL
   IFN DTFLG,<

DTEINS:	MOVE T1,[MSEC1,,DTESV0]
	MOVEM T1,DTESV+3	;INTERRUPT INITIATION
	SETZM DTESV+2
	MOVE T2,MSTRDT		;GET MASTER DTE
	LSH T2,SDTE		;FIND CORRECT EPT SET
	MOVE T1,[XPCW DTESV]
	MOVEM T1,DTEINT(T2)
	MOVEI T1,DTEMMN		;TURN ON MONITOR MODE TTY
	SETZM DTEFLG
	MOVEM T1,DTECMD
	MOVEI T1,DTEEDB+DTEPIE+DTECHN ;POKE -11 AND SET UP PI
	XCT DTSCNW		;DO IT
	SKIPN DTEFLG		;WAIT FOR COMPLETION
	JRST .-1
	RET

;SEND TTY CHARACTER VIA DTE20
; T1/ CHARACTER
; T2/ LINE NUMBER
;	CALL DTECHO
; RETURN +1, FAILURE, UNKNOWN LINE.
; RETURN +2, SUCCESS CHARACTER SENT.  TTODON WILL BE CALLED WHEN
;	OUTPUT HAS BEEN COMPLETED

DTECHO::CAME T2,CTYLNO		;CTY?
	RET			;NO, NOTHING ELSE SUPPORTED YET
	TXO T1,DTEMNO		;SET MONITOR MODE OUTPUT
	MOVEM T1,DTECMD		;PUT WHERE -11 SEES IT
	MOVEI T1,DTEEDB		;NEED TO RING -11'S BELL
	XCT DTSCNW		;DO IT
	RETSKP


;DTE20 INTERRUPT SERVICE
;HERE FROM JSR IN VECTOR INTERRUPT LOCATION

DTESV0:	MOVEM P,DTEACB+P	;SAVE HIGH ONE
	MOVEI P,DTEACB		;WHERE TO SAVE THE REGS
	BLT P,DTEACB+T4		;SAVE TEMPS
	MOVE P,DTESTK		;SET UP LOCAL STACK
	PUSH P,CX		;SAVE GENERAL TEMP
	MOVEI T1,DTETDB		;CLEAR OUR BELL
	XCT DTSCNW		;DO IT
	SKIPE DTETMD		;TTY OUTPUT DONE?
	JRST DTECO		;YES
	SKIPE DTEMTI		;TTY INPUT READY?
	JRST DTECI		;YES
DTESVX:	POP P,CX		;RESTORE REGS
	MOVSI T4,DTEACB
	BLT T4,T4
	MOVE P,DTEACB+P
	XJEN DTESV		;DISMISS

DTECO:	SETZM DTETMD		;CLEAR FLAG
	MOVE T2,CTYLNO		;ASSUME CTY
	CALL TTODON		;NOTIFY TTYSRV
	JRST DTESVX

DTECI:	MOVE T1,DTEF11		;GET FROM-11 DATA
	MOVE T2,CTYLNO		;ASSUME CTY
	SETZM DTEMTI		;CLEAR FLAG
	CALL TTIDON		;PASS CHAR TO TTYSRV
	JRST DTESVX

   >				; END IFN DTFLG
	SUBTTL Cache Control

;CACHE CONTROL

   IFN KLFLG,<

;TURN CACHE ON

CASHON::SETOM CASHF		;INDICATE CACHE ON
	CONSZ PAG,PGCLKE+PGCLDE	;CASH NOW ON?
	RET			;YES, DO NOTHING
	CONI PI,T2		;SAVE PI STATE
	PIOFF
	CCHIA			;INVALIDATE ALL
	CONSO APR,APSWPD	;WAIT UNTIL DONE
	JRST .-1
	CONOAPR APFCLR+APSWPD	;CLEAR DONE BIT
	MOVX A,PGCLKE+PGCLDE
	IORM A,CONOPG		;SET CACHE ENABLE BITS
	CONO PAG,@CONOPG	;DO IT
	TXNE T2,PIPION		;RESTORE PI STATE
	PION
	RET

;TURN CACHE OFF

CASHOF::SETZM CASHF		;INDICATE CACHE OFF
	CONSO PAG,PGCLKE+PGCLDE	;CASH NOW OFF?
	RET			;YES, DO NOTHING
	MOVX A,PGCLDE		;NO. GET LOAD BIT
	ANDCAB A,CONOPG		;CLEAR LOAD LEAVING ONLY LOOK
	CONO PAG,@A		;SET CACHE TO LOOK ONLY
	CCHUA			;STORE ALL CACHE DATA
	CONSO APR,APSWPD
	JRST .-1		;WAIT FOR DONE
	CONOAPR APFCLR+APSWPD	;CLEAR DONE BIT
	TXZ A,PGCLKE+PGCLDE	;CLEAR CACHE ENABLE BITS
	CONO PAG,@A		;TELL HARDWARE
	MOVEM A,CONOPG
	RET

;FLUSH A SPECIFIED PAGE FROM THE CACHE
;T1/ PHYSICAL PAGE
;	CALL CASHFP
;RETURNS+1(ALWAYS):
;	PAGE WRITTEN BACK AND INVALIDATED
;PRESERVES ALL ACS

CASHFP::CCHUO (T1)		;START UNLOAD SWEEP
	CONSO APR,APSWPD	;WAIT FOR DONE FLAG
	JRST .-1		; ...
	CONOAPR APFCLR+APSWPD	;CLEAR FLAG
	RET			;DONE
   >				;END IFN KLFLG

   IFN KCFLG,<

;The state of the cache is controlled by the hardware and the console, not
;by the operating system. We can determine the state of the cache via RDEBR.

CASHON::RET

CASHOF::RET

CASHFP::RET
   >				;END IFN KCFLG
	SUBTTL Context Handling Routines

;INIT NEWLY CREATED FORK

FKSETK::MOVE 1,[XWD IUPT0,UPTTPI]
	BLT 1,UPTTPI+NIUPT-1	;INIT UPT
	MOVE 1,[MSEC1,,ENSKED]
	MOVEM 1,ENSKR+3
	MOVX T1,MONENV		;NEW FLAGS WORD
	MOVEM T1,ENSKR+2
	MOVE A,[MSEC1,,PGRTRP]
   IFN KLFLG,<
	MOVEM A,UPTPFN		;SETUP PAGE FAIL NEW PC
	SETZM UPTPFL
   >
   IFN KCFLG,<
	MOVEM A,KCPFNP
	SETZM KCPFOF		;OLD FLAGS
	MOVX T1,MONENV		;NEW FLAGS WORD
	MOVEM T1,KCPFNF
   >
	RET


;UPT AND EPT TEMPLATES
	LUUNUL==<7777,,-1>	;DEFAULT ADDRESS -- CAUSES LUUO TO CONVERT TO
				;ILLEGAL MEMORY REFERENCE

   IFN KLFLG,<

 GSOPDEF .AROVT,<41B8>		;AR OV, USER ONLY
 GSOPDEF .PDOVT,<42B8>		;PDL OV, USER OR MONITOR

;IUPT0 - TEMPLATE FOR UPT. COPIED INTO A PROCESS'S PSB WHEN IT IS CREATED
;First location is LUUO word. If left as initalized below, an
;LUUO by the user (from non-zero section) will cause an illegal memory
;reference. User can change the location via SWTRP JSYS.


IUPT0:	LUUNUL			;LUUO TRAP WORD (420)

;Next three locations are trap words. Initial values cause trap 1 and trap 3
;to be ignored. Trap 2 (push down overflow) executes an MUUO.
;If user has executed SWTRP JSYS or enabled for interrupts on arithmetic
;overflow, next location contains an MUUO.

	JFCL			;USER ARITHMETIC OVERFLOW TRAP (421)
	.PDOVT			;USER PDL OV TRAP (422)
	JFCL			;USER TRAP 3 (423)

;Next 4 words are MUUO block. Microcode stores into them when MUUO is
;executed.

	0			;FLAGS, OP CODE, AC, PCS (424)
	0			;PC (425)
	0			;E (426)
	0			;PROCESS CONTEXT WORD (427)

;Next 8 words are trap function words. Each contains location to which
;control is transferred when an MUUO is executed under the conditions
;indicated (trap/no-trap, EXEC mode/user mode)

	MSEC1,,KIMUOM		;KERNAL NO-TRAP (JSYS) (430)
	MSEC1,,KITRPM		;KERNAL TRAP (PAGING, PDL OV) (431)
	MSEC1,,KIMUOS		;SUPV. NO-TRAP (NOT USED) (432)
	MSEC1,,KITRPS		;SUPV. TRAP (NOT USED) (433)
	MSEC1,,KIMUOU		;USER (CONC.) NO-TRAP (434)
	MSEC1,,KITRPU		;USER (CONC.) TRAP (435)
	MSEC1,,KIMUOU		;USER (PUBLIC) NO-TRAP (JSYS, 10/50) (436)
	MSEC1,,KITRPU		; " TRAP (PAGING, OV, PDL OV) (437)
NIUPT==.-IUPT0
>				;END IFN KLFLG

   IFN KCFLG,<
TRFUNC==:MASKB(0,1)
TRNOP==:FLD (0,TRFUNC)		;IGNORE ERROR
TRMON==:FLD (1,TRFUNC)		;TRAP TO MONITOR
TRUSER==:FLD (2,TRFUNC)		;TRAP DIRECTLY TO USER
AROVPC==:TRMON+<MSEC1>B17+KIAROV ;WHERE TO GO ON USER ARITHMETIC OVERFLOW
PDOVPC==:TRMON+<MSEC1>B17+KIPDOV ;WHERE TO GO ON USER PDL OVERFLOW
EXOVPC==:TRMON+<MSEC1>B17+KITRPM ;WHERE TO GO ON EXEC MODE PDL OVERFLOW

;IUPT0 - TEMPLATE FOR UPT. COPIED INTO A PROCESS'S PSB WHEN IT IS CREATED
;First location is LUUO word. If left as initalized below, an
;LUUO by the user (from non-zero section) will cause an illegal memory
;reference. User can change the location via SWTRP JSYS.


IUPT0:	LUUNUL			;LUUO TRAP WORD

;Next three locations are trap words. Initial values cause trap 1 and trap 3
;to be ignored. Trap 2 (push down overflow) simulates an MUUO.
;If user has executed SWTRP JSYS or enabled for interrupts on arithmetic
;overflow, next location contains monitor PC

	TRNOP			;NOP function word -- arithmetic overflow (420)
	PDOVPC			;Monitor address -- PDL overflow (421)
	TRNOP			;NOP function word -- trap 3 (422)

;Next four words are stored on any kind of MUUO.

	0			;Flags, CAB, PAB, PCS (424)
	0			;PC (425)
	0			;op code and AC (426)
	0			;E (427)

;Next word is new flags word for all MUUO's.

	MONFLG			;Flags, CAB and PAB(430)

;Next words are transfer addresses for various kinds of MUUO.


	MSEC1,,VMENT		;Trapped instruction in virtual machine mode (431)
	MSEC1,,EXUUO		;Exec mode unassigned op code or 0 (432)
	MSEC1,,USUUO		;User mode unassigned op code or 0 (433)
	MSEC1,,EXUIO		;Exec mode unassigned I/O op code (434)
	MSEC1,,USUIO		;User mode unassigned or illegal I/O op code (435)
	MSEC1,,EXEXT		;Exec mode undefined EXTEND code (436)
	MSEC1,,USEXT		;User mode undefined EXTEND code (437)
	MSEC1,,EXJSYS		;Exec mode JSYS (440)
	MSEC1,,USJSYS		;User mode JSYS (441)
	MSEC1,,EXMUUO		;Exec mode other MUUO (442)
	MSEC1,,USMUUO		;User mode other MUUO (443)
NIUPT==.-IUPT0

>				;END IFN KCFLG

   IFN KLFLG,<

;Prototype EPT LUUO and trap words
;If the monitor executes an LUUO from non-zero section, it BUGHLT's
;at .LBCHK.

IEPT0:	MSEC1,,.LUTRP		;LUUO FROM MONITOR
	JFCL			;MONITOR AROV
	.PDOVT			;MONITOR PDL OV
	JFCL			;MONITOR TRAP 3
NIEPT==.-IEPT0
>				;End of IFN KLFLG

   IFN KCFLG,<

;Prototype EPT LUUO and trap words

IEPT0:	MSEC1,,.LUTRP		;LUUO from monitor non-zero section (420)
	TRNOP			;Exec mode arithmetic overflow (421)
	EXOVPC			;Exec mode PDL overflow (422)
	TRNOP			;Exec mode trap 3 (423)
NIEPT==.-IEPT0
>				;End of IFN KCFLG

; LUUO FROM MONITOR CONTEXT TRAP

RSI .LUTRP,<0,0,0,<MSEC1,,.LBCHK>> ;LUUO BLOCK

.LBCHK:	BUG.(HLT,LUUMON,APRSRV,SOFT,<.LBCHK: Illegal LUUO from monitor context>,,<

Cause:	While running in a non-zero section, the monitor executed an
	LUUO. The LUUO block is at the 4 locations starting at .LUTRP.
	Note that the hardware reference manual incorrectly states that
	an LUUO in exec mode becomes an MUUO.
>)

;Here when monitor executed a JSYS. Transferred through UPT offset 440 (KC)

   IFN KCFLG,<
EXJSYS:
	;..
  >				;End of IFN KCFLG

;Here for Kernel or Supervisor No-trap MUUO (KL)

   IFN KLFLG,<
KIMUOS:
KIMUOM: LDB CX,[POINT 9,KIMUFL,26] ;GET OPCODE
	CAIE CX,<JSYS>B62	;JSYS?
	JRST KIMUO4		;NO
  >				;End of IFN KLFLG

;Monitor executed a JSYS. See what kind it is.

	HRRZ CX,KIMUEF		;YES, GET E
	CAIGE CX,1000		;EXEC JSYS?
	JRST MENTM		;YES, GO TO ENTRY SEQUENCE
	CAIG CX,DMSMAX		;DMS JSYS?
	JRST BADDMS		;YES, NOT ALLOWED FROM THE MONITOR

;This is "JSYS E", where E points to a word containing (where to store old
;PC,,new PC). Transfer control to the new PC.

	BUG.(CHK,ILLMJS,APRSRV,SOFT,<JSYS with E GTR 1000 executed in monitor>,<<FPC,PC>>,<

Cause:	A JSYS with E greater than 1000 has been executed in the monitor.
	There should be no such cases.

Data:	PC - PC of JSYS
>)
	MOVS CX,0(CX)		;NO, SIMULATE JSYS (NOT USED BY
	HRRZ 2,CX		;GET ADDRESS ONLY
	MOVEM 1,0(2)		; ANY MONITOR CODE, ONLY MDDT)
	MOVE 1,FPC		;GET PC
	EXCH 1,0(2)		;STORE IT VIA LH OF E
	HLRM CX,FPC		;SETUP JUMP ADDRESS
	XCT MJRSTF		;JUMP

;Monitor executed a DMS JSYS. Complain.

BADDMS:	BUG.(HLT,ILLDMS,APRSRV,SOFT,<BADDMS - Illegal DMS JSYS from monitor context>,<<KIMUPC,PC>>,<

Cause:	The monitor has issued a JSYS that requests a service of the
	RMS-20 package.  These JSYSs are legal in user mode only.
	An illegal instruction trap will be given to the current
	process.

Data:	PC - PC in monitor address space where JSYS was invoked
>)

;Here when monitor executed an unassigned op code. Transferred through UPT
;offset 432. (KC)

  IFN KCFLG,<
EXUUO:	LDB CX,[POINT 9,KIMOAC,26] ;GET THE OP CODE
	;..
  >

;Here when op code is not 104 (for JSYS). See what it is.
;The cause appears to be an ILLUUO.  It is possible that
;the cause of the ILLUUO is a PXCT of a byte instruction with a bad
;byte pointer.  If the user sends a <<77B5>!<ANYTHING ELSE>> as a
;byte pointer to a JSYS (EG. PSOUT) then an ILLUUO will result.
;We will check the PC that caused the ILLUUO.  If it contains a PXCT
;of a byte instruction then we will generate an illegal instruction
;trap and not crash.  This code assumes that section zero and section
;one have a common map.  This code also assumes that monitor code will
;never execute code in sections other than zero and one.
; CX/ opcode

KIMUO4:   IFN KCFLG,<
	JRST KIBADU		;ILLUUO ON KC
   >				;END OF IFN KCFLG
   IFN KLFLG,<
	ADJSP P,10		;LEAVE RECENT STACK ALONE IN CASE DEBUGGING

;SEE IF IT WAS A PXCT OF A BYTE POINTER

	BLOCK.			;BE A SUBROUTINE
	  SAVET			;SAVE ALL TEMP ACS
	  STKVAR <<KIMXT,2>,KIMXPC> ;WE NEED SOME STORAGE
	  DMOVEM T1,KIMXT	;SAVE CURRENT T1 AND T2
	  HRRZ T1,KIMUPC	;GET THE UUO PC
	  SOJ T1,		;GET THE PC OF INST THAT CAUSED ILLUUO
	  MOVEM T1,KIMXPC	;SAVE THE ILLUUO PC
	  MOVE T1,KIMXT		;RESTORE T1
	  MOVE T2,@KIMXPC	;GET THE INSTRUCTION WORD
	  LDB T1,[POINT 9,T2,8] ;GET THE OPCODE
	  CAIE T1,<<IBP>_-^D27> ;IS IT AN IBP OR ADJBP
	  JRST [CAIE T1,<<XCT>_-^D27> ;NO, AN XCT?
	       JRST KIBADU	;NO, THAT'S TOO BAD.
	       JRST KIMXLP]	;YES, TRACE IT DOWN

;BYTE INSTR OR XCT OF BYTE INSTR IS OK

KIMXOK:	  MOVEI T1,ARGX09	;SAVE ERROR CODE
	  MOVEM T1,LSTERR
	  DMOVE T1,KIMUFL	;GET FL AND PC
	  CALL ITRSIM		;ERRJMP AVAILABLE?
	  IFNSK.
	    MOVEI 1,.ICILI	;INITIATE ILLEGAL INSTRUCTION INTERRUPT
	    CALL PSIRQ0
	    CHKINT		;GET THE INTERRUPT "SEEN"
	  ELSE.
	    MOVEM T3,KIMUPC	;HAS AN ERRJMP SAVE NEW PC
	  ENDIF.
	ENDBK.
	ADJSP P,-10		;RESET STACK
	XCT MJRSTF		;RETURN

;TRACE XCT

KIMXLP:	CAIE T1,<<XCT>_-^D27>	;IS IT AN XCT?
	JRST [CAIL T1,133	;NO, IS IT A BYTE INSTRUCTION?
	      CAILE T1,137	;IS IT A BYTE INSTRUCTION?
	      JRST KIBADU	;NO, LOSER.
	      JRST KIMXOK]	;YES, OK
	TXZ T2,<777>B8		;ZERO THE OPCODE FIELD
	TXO T2,IFIW		;MAKE THIS AN IFIW POINTER
	MOVEM T2,KIMXPC		;SAVE IT AS THE NEW PC
	DMOVE T1,KIMXT		;RESTORE ACS SO THAT INDEXING IN THE INDIRECT
	MOVE T2,@KIMXPC		;GET THE INSTRUCTION WORD
	LDB T1,[POINT 9,T2,8]	;GET THE OPCODE
	JRST KIMXLP		;LOOP TO FIND NEXT INSTRUCTION
   >				;END OF IFN KLFLG

  IFN KCFLG,<

;Here when monitor executed an unassigned I/O instruction. Transferred
;through UPT offset 434. (KC)

EXUIO::

;Here when monitor executed an unassigned EXTEND instruction. Transferred
;through UPT offset 436. (KC)

EXEXT::

;Here when monitor executed an MUUO. Transferred through UPT offset 442. (KC)

EXMUUO::
	;..
>				;End of IFN KCFLG

;Monitor executed illegal UUO. Complain.

KIBADU:	BUG.(HLT,ILLUUO,APRSRV,SOFT,<KIBADU - Illegal UUO from monitor context>,<<KIMUFL,FLAGS>,<KIMUPC,PC>,<KIMUEF,EFFADR>>,<

Cause:	The monitor has executed an instruction that the microcode
	treats as an MUUO. The op code is not 104 (for a JSYS) or one
	of the KA10 floating point instructions.

Action:	Look for the software bug. Repeated occurrence of this
	BUGHLT may indicate a hardware problem.

Data:	FLAGS - Processor flags when MUUO was executed
	PC - PC in monitor address space where MUUO was executed
	EFFADR - Effective address of MUUO
>)
;Here when user executed a JSYS. Transferred through UPT offset 441. (KC)

   IFN KCFLG,<

USJSYS:	HRR CX,KIMOAC		;GET OP CODE AND AC
	HLL CX,KIMUFL		;GET FLAGS WORD
	MOVEM CX,KIMUU1		;SAVE FIRST WORD
	MOVE CX,KIMUEF		;GET E
	MOVEM CX,KIMUU1+1	;SAVE SECOND WORD
	;..
>

;Here for concealed or public (user) no-trap MUUO. Transferred through
;UPT offset 434 or 436. (KL)

   IFN KLFLG,<
KIMUOU:	DATAO PAG,SETMON	;SET MONITOR CONTEXT

;Save PC and effective address. Transfer according to op code

KIMUOT:	MOVE CX,KIMUFL		;GET FLAGS,OP CODE, AC
	MOVEM CX,KIMUU1		;SAVE IT AS LAST USER UUO
	MOVE CX,KIMUEF		;GET EFFECTIVE ADDRESS
	MOVEM CX,KIMUU1+1
	LDB CX,[POINT 9,KIMUFL,26] ;GET OPCODE
	CAIE CX,<JSYS>B62	;JSYS?
	JRST KIMUO2		;NO
	;..
>				;End of IFN KLFLG

;User executed a JSYS. See what kind it is.

	;..
	HRRZ CX,KIMUEF		;YES, GET E
	CAIGE CX,1000		;EXEC JSYS?
	JRST MENTU		;YES, GO TO ENTRY SEQUENCE
	CAIG CX,DMSMAX		;DMS JSYS?
	JRST DMSENT		;YES, GO JUMP TO DMS CODE

;This is "JSYS E", where E points to a word containing (where to store old
;PC,,new PC). Transfer control to the new PC in user mode. This works only
;if JSYS is called from section 0.

	MOVE 1,FPC		;NO, SIMULATE ORDINARY JSYS
	TXNE 1,VSECNO		;SECTION 0?
	JRST ILUUO		;NO. ERROR THEN
	HLL 1,FFL		;SAVE FLAGS
	XCTU [MOVS CX,0(CX)]	;GET C(E)
	HRRZ 2,CX		;GET ADDRESS ONLY
	XCTU [MOVEM 1,0(2)]	;STORE PC PER LH OF C(E)
	HLR 1,CX		;JUMP ADDRESS - COMBINE WITH FLAGS
	TLZ 1,(FPD)		;FLAGS UNCHANGED EXCEPT FPD CLEARED
	HLLM 1,FFL		;SET FLAGS AND PC (NO EXADR BITS!)
	HRRZM 1,FPC
	JRST GOUSR		;RETURN TO USER

   IFN KCFLG,<

;Here when user executed an MUUO. Tranferred through UPT offset 442.
;Call the compatibility package

USMUUO:	HRR CX,KIMOAC		;GET OP CODE AND AC
	HLL CX,KIMUFL		;GET FLAGS WORD
	MOVEM CX,KIMUU1		;SAVE FIRST WORD
	MOVE CX,KIMUEF		;GET E
	MOVEM CX,KIMUU1+1	;SAVE SECOND WORD
	JRST UU1050		;CALL THE COMPATIBILITY PACKAGE
>				;End of IFN KCFLG

   IFN KLFLG,<

;Not a JSYS. See what it is. If TOPS-10 UUO, go to the compatibility package.

KIMUO2:	CAIL CX,100		;POSSIBLY A TOPS10 UUO?
	JRST KIMUO3		;NO
	CAIL CX,40
	JRST UU1050		;YES, GO TO COMPATBILITY PACKAGE
	JUMPE CX,ILUUO		;0 IS ALWAYS ILLEG

;Remaining op codes are LUUO's. They shouldn't come to the monitor

	BUG.(HLT,IMPUUO,APRSRV,HARD,<Impossible MUUO>,,<

Cause:	The monitor was called at its MUUO handler because the user
	executed an MUUO. However, the op code reported by the
	microcode is in the range 1-37, which should have caused
	an LUUO.
>)
>


   IFN KCFLG,<

;Here when user executed an unassigned op code. See if it was a KA
;floating point instruction.

USUUO:	HRR CX,KIMOAC		;GET OP CODE AND AC
	HLL CX,KIMUFL		;GET FLAGS WORD
	MOVEM CX,KIMUU1		;SAVE FIRST WORD
	MOVE CX,KIMUEF		;GET E
	MOVEM CX,KIMUU1+1	;SAVE SECOND WORD
	LDB CX,[POINT 9,KIMOAC,26] ;GET THE OP CODE
>

;Not a JSYS or a UUO. TEST FOR INTERPRETED OPCODES

KIMUO3:
   IFN KLFLG,<			;IF KL CHECK FOR GFLT STUFF
	CAIN CX,<<EXTEND>_-^D27> ;IS OPCODE AN EXTEND?
	JRST GFLT0		;YES...GO CHECK FOR GFLT
   >

;Here for user mode KA floating point instructions.
;DISPATCH TO KA10 LONG FLOATING POINT SIMULATION ROUTINE, UFA(130),
;DFN(131), FADL(141), FSBL(151), FMPL(161), FDVL(171).

	MCENTR			;ESTABLISH CONTEXT
	LDB CX,[POINT 9,KIMUU1,26] ;GET OPCODE
	CAIL CX,130		;WITHIN LONG FLOATING POINT RANGE?
	CAILE CX,171
	JRST ILUUO1		;NO, UNKNOWN
	CAIG CX,131		;UFA OR DFN?
	IFNSK.
	  TRZ CX,110		;YES, TRANSLATE TO 20,21
	ELSE.
	  TRNN CX,6		;NO BITS 33 OR 34
	  TRNN CX,1		;BUT MUST HAVE 35
	  JRST ILUUO1		;OR IT IS AN ERROR
	  LSH CX,-3		;FADL, ETC.  TRANSLATE TO 14-17
	ENDIF.
	HRRZ CX,FLONGD-14(CX)	;GET ADDRESS
	CALL 0(CX)		;DO FUNCTION
	JRST MRETN		;RETURN +1

;DISPATCH ON DIDDLED OPCODES

FLONGD:	SFADL
	SFSBL
	SFMPL
	SFDVL
	SUFA
	SDFN

IFN KLFLG,<			;GFLT CODE FOR KL'S

; The following code simulates the GFLOAT to INTEGER conversion instructions.
; These instructions were removed from the KL microcode to make room for other
; features and bug fixes.  This code also exists in TOPS10.  If any changes are
; made to this code they should also be made for TOPS10

	GFLT%O==1B1		;GFLOAT OVERFLOW FLAG
	GFLT%2==1B2		;GFLOAT TWO AC STORE FLAG
	PC%TP1==1B10		;TRAP1 PC FLAG...ONLY USED BY GFLOAT

OPDEF DGFIX	[023000,,0]	;GFLT TO DOUBLE INTEGER
OPDEF GFIX	[024000,,0]	;GFLT TO INTEGER
OPDEF DGFIXR	[025000,,0]	;GFLT TO DOUBLE INTEGER ROUNDED
OPDEF GFIXR	[026000,,0]	;GFLT TO INTEGER ROUNDED

GFLT0:				;HERE TO CHECK FOR GFLT'S
	MCENTR			;ENTER JSYS CONTEXT
	MOVE T4,KIMUU1+1	;GET E FOR THE MUUO
	UMOVE T4,(T4)		;GET THE EXTENDED INSTRUCTION
	LDB T3,[POINT 9,T4,8]	;GET THE EXTENDED OPCODE
	CAIL T3,<<DGFIX>_-^D27>	;IS IT A GFLT INSTRUCTION?
	 CAILE T3,<<GFIXR>_-^D27>
	  JRST ILUUO1		;NO
	SUBI T3,<<DGFIX>_-^D27>	;CONVERT TO GFLTD OFFSET
	MOVE T1,T4		;GET THE EXTENDED INSTRUCTION
	TLZ T1,777740		;TURN OFF EVERYTHING EXCEPT I,X,AND Y
	TLO T1,(DMOVE T1,)	;GET THE INSTRUCTION
	XCTUU T1		;GET THE USERS ARGUMENTS
	CALL @GFLTD(T3)		;DISPATCH TO WORKER ROUTINES
	TXNE T4,GFLT%O		;DID IT OVERFLOW
	 JRST GFLT1		;YES...GO HANDLE IT
	LDB T3,[POINT 4,KIMUU1,30] ;GET THE AC THE USER USED
	UMOVEM T1,(T3)		;SAVE THE FIRST AC
	TXNN T4,GFLT%2		;IS IT A TWO AC RESULT?
	 JRST MRETN		;NO...SO WE ARE DONE
	ADDI T3,1		;YES...SO BUMP THE AC VALUE
	ANDI T3,17		;MAKE ADDITION MODULO 16
	UMOVEM T2,(T3)		;SAVE THE SECOND AC RESULT
	JRST MRETN		;RETURN TO USER
GFLT1:	EXCH T2,MPP		;HERE ON AN OVERFLOW...GET STACK FRAME
	MOVX T1,PC%OVF!PC%TP1	;GET OVERFLOW FLAGS
	IORM T1,0(T2)		;SET THE BIT IN THE USER'S FLAGS
	EXCH T2,MPP		;GET OUR STACK BACK
	JRST MRETN		;AND RETURN

GFLTD:	IFIW!.DGFX		;DGFIX
	IFIW!.GFX		;GFIX
	IFIW!.DGFXR		;DGFIXR
	IFIW!.GFXR		;GFIXR
>				;END OF IFN KLFLG
   IFN KCFLG,<

;Here when user executed an unassigned I/O instruction or one that is
;illegal without User IOT. Transferred through UPT offset 435.

USUIO:

;Here when user executed an unassigned EXTEND instruction. Transferred
;through UPT offset 437.

USEXT:	HRR CX,KIMOAC		;GET OP CODE AND AC
	HLL CX,KIMUFL		;GET FLAGS WORD
	MOVEM CX,KIMUU1		;SAVE FIRST WORD
	MOVE CX,KIMUEF		;GET E
	MOVEM CX,KIMUU1+1	;SAVE SECOND WORD
	JRST ILUUO

;Here when user executed a trapped instruction with virtual machine mode
;set

VMENT:	BUG.(HLT,VMMODE,APRSRV,SOFT,<MUUO in virtual machine mode>,,<

Cause:	The microcode transferred through the UPT location for execution of
an instruction in virtual machine mode. This should not happen, because no
code exists to handle this case, and the mode should never be enabled.

Action:	Determine how the mode was set, or debug the microcode.

>)		;No code in monitor for VM mode yet
>				;End of IFN KCFLG

;Here when user executed a trap MUUO.
;UPT locations for trap conditions contain JFCL or MUUO. If here, a trap
;condition occurred, and the monitor had stored an MUUO in the UPT slot.
;Op code indicates which one was executed.

   IFN KLFLG,<
KITRPU:	DATAO PAG,SETMON
	LDB CX,[POINT 9,KIMUFL,26]
	CAIL CX,40		;RANGE OK?
	CAIL CX,40+MAXUTU
KITRPX:	JRST KIMUOT		;NOT INTERSTING. GO SEE ABOUT STANDARD STUFF
	JRST UTUTAB-40(CX)	;DISPATCH

;Transfer vector. Transfer according to op code.

UTUTAB:	JRST KITRPX		;PAGER (Op code 40) (OBSOLETE)
	JRST KIAROV		;OVERFLOW (Op code 41)
	JRST KIPDOV		;PDL OV (OP code 42)
MAXUTU==.-UTUTAB
>				;END OF IFN KLFLG


;Here on EXEC mode trap MUUO
;The monitor has executed an MUUO during a trap. The only location in the
;EPT that causes an MUUO is push-down list overflow.

KITRPS:
KITRPM:	BUG.(HLT,MONPDL,APRSRV,SOFT,<Stack fault in monitor>,<<FPC,PC>>,<

Cause:	The monitor has executed a PUSH instruction that
	caused a stack overflow.  The central processor
	detected this condition and reported it to the monitor.

Data:	PC - PC of instruction which caused stack overflow
>)

;Here if user trap word for overflow had an MUUO in it and user got
;arithmetic overflow. User either has executed SWTRP JSYS, providing a block
;address, or has enabled for an interrupt.

KIAROV:	SKIPE T3,ARTHTR		;USER SPECIFIED-TRAP ADDRESS?
	JRST OVERFL		;YES. GO HANDLE IT THEN

;User did not provide trap address. Give interrupt on channel for specific
;overflow condition.

	SETZ 1,
	MOVE 2,KIMUFL		;GET FLAGS AT TIME OF TRAP
	MOVE 3,PSICHM		;USER'S CHANNEL ENABLED WORD
	TLNE 3,(1B7)		;FOV ENB?
	JRST [	TLNN 2,(1B3)	;AND FOV ON?
		JRST .+1	;NO
		MOVEI 1,7	;YES, CHANNEL 7 INTERRUPT
		JRST KITRP1]
	TLNE 3,(1B6)		;OV ENB?
	JRST [	TLNN 2,(1B0)	;AND OV ON?
		JRST .+1	;NO
		MOVEI 1,6	;YES, CHANNEL 6 INTERRUPT
		JRST KITRP1]
	JRST KITRP1		;ENTER SCHED, FINISH UP

;User has done SWTRP JSYS. Fill in the user's block with the necessary
;information
;	T3/ address of block in previous context

OVERFL:	MOVE T4,KIMUPC		;Get PC of error
	SUBI T4,1		;Back up
	HLL T4,KIMUPC		;But stay in the same section
	UMOVE T4,@T4		;Get the instruction
OVERF2:	LDB T1,[POINT ^D13,T4,12] ;GET OPCODE AND AC
	LSH T1,5		;POSITION IT
	MOVE P1,T1		;Save it for later
	LSH T1,-<5+4>		;ISOLATE OPCODE
	TXZ T4,-1B12		;CLEAR INST AND AC
	TXO T4,<XMOVEI T2,>
	XCTUU T4		;GET EFFECTIVE ADDRESS

;Chase XCT chain if necessary to get real op code

	CAIN T1,<XCT>B62	;IS IT AN XCT?
	JRST [	UMOVE T4,@T2	;YES. GET TARGET OF XCT INSTRUCTION
		JRST OVERF2]	;AND PROCEED

;Found the effective address. Now that we are finished using the
;original value of PCS, we can change it so that we can reference
;the SWTRP block. So,...

	XSFM Q1			;Get flags
	TXNE Q1,EXPCS		;Previous context = 0?
	IFSKP.			;If so.
	 DO.
	  XMOVEI Q2,ENDLP.	;Make it a non-zero section
	  TXO Q1,FLD(1,EXPCS)	;""
	  XJRSTF Q1		;Do it
	 ENDDO.
	ENDIF.
	MOVE T4,T3		;ADDRESS OF USERS BLOCK
	ADDI T4,.AREFA
	UMOVEM T2,@T4		;STORE EFFECTIVE ADDRESS
	DMOVE T1,KIMUFL		;Get trap flags and PC
	HRR T1,P1		;GET OPCODE/AC FROM PREVIOUS SEARCH
	ADD T4,[.ARPFL-.AREFA]
	XCTU [DMOVEM T1,@T4]	;STORE TRAP FLAGS AND PC
	ADD T4,[.ARNPC-.ARPFL]
	UMOVE T2,@T4		;GET NEW PC WORD
	TXZ T1,FPD		;CLEAR FPD SO NEW INSTRUCTION WILL WORK
	DMOVEM T1,FFL		;SET UP NEW PC FOR USER
	JRST GOUSR		;AND RETURN

;Here if user had PDL overflow. Trap word contained an MUUO, stored by the
;monitor. Give an interrupt.

KIPDOV:	SKIPE T3,PDOVTR		;HAS USER DONE AN SWTRP FOR PDL OVERFLOW?
	JRST OVERFL		;YES. GO FILL IN THE BLOCK
	MOVEI T1,^D9		;YES. GIVE CHANNEL 9 INTERRUPT
	JRST KITRP1		;GO GIVE THE INTERRUPT


;ROUTINES USED BY SWTRP TO VERIFY TRAP ARGS

;VERIFY AND SET ARITHMETIC TRAP INSTRUTION
;	T1/ FORK PSB INDEX
;	T2/ USER'S FLAGS
;	T3/ BLOCK ADDRESS TO USE
;RETURNS +1: ALWAYS

;Clobbers T2,T3,T4

	SWAPCD				;SWAPPABLE
SETART::TXNN T2,SW%NMI			;WILLING TO ACCEPT UCODE'S DATA?
	JRST SETAR1			;NO. DON'T SIGNAL IT THEN
   IFN KCFLG,<
	TXO T3,1B0			;ON THE KC, DON'T INVOKE THE MONITOR
>					;END OF IFN KCFLG
SETAR1:	MOVEM T3,ARTHTR(T1)		;SAVE USER'S ADDRESS PLUS FLAG
	CALL SETAOV			;SET UP THE UPT
	RET

;SETAOV - Routine to set the UPT trap word.
;ACCEPTS:
;	T1/ Offset to address PSB for desired fork

;	CALL SETAOV

;RETURNS +1: ALWAYS

;On entry, ARTHTR contains one of the following:
;	0 - don't give user a trap on overflow
;	1B0+address - make processor handle overflow without monitor intervention
;	address - make monitor intervene; address is of user block

;If SWTRP has been done, ARTHTR is non-zero, and SWTRP takes precedence over
;interrupts. If ARTHTR is 0, the monitor will intervene if interrupts are
;enabled. Otherwise, overflow is ignored.

   IFN KLFLG,<
SETAOV::SKIPE ARTHTR(T1)	;USER-SPECIFIED TRAP INSTRUCTION?
	JRST SETOV1		;YES. SET UP TRAP THEN
	MOVE T3,PSICHM(T1)	;PROCESS CHN MASK
	MOVSI T2,<JFCL>B53	;USE JFCL IF NO INTS
	TLNE T3,(1B6+1B7)	;OVERFLOW OR FLOATING OV?
SETOV1:	MOVSI T2,<.AROVT>B53	;YES, USE TRAP MUUO
	MOVEM T2,UPTOVI(T1)
	RET
>				;END OF IFN KLFLG

   IFN KCFLG,<


SETAOV::SKIPE T4,ARTHTR(T1)	;GET USER'S BLOCK ADDRESS
      IFSKP.
	MOVE T4,TRNOP		;DEFAULT IS IGNORE
	MOVE T3,PSICHM(T1)	;GET ENABLED CHANNELS
	TLNE T3,(1B6+1B7)	;EITHER OVERFLOW?
	MOVX T4,AROVPC		;YES. MONITOR MUST INTERVENE
      ELSE.
	JUMPG T4,[	MOVX T4,AROVPC
			JRST SETOV1]
	TXZ T4,1B0		;NO. CLEAR THE FLAG
	TXO T4,TRUSER		;SET FUNCTION FOR USER ONLY
      ENDIF.
SETOV1:	MOVEM T4,UPTOVI(T1)	;SET THE UPT
	RET
>				;END OF IFN KCFLG

;SETLUU - ROUTINE TO VERIFY AND SET LUUO BLOCK ADDRESS
;	T1/ PSB OFFSET
;	T3/ BLOCK ADDRESS
;RETURNS:	+1 INVALID
;		+2 VALID

;Clobbers T3

SETLUU::SKIPN T3		;CLEARING?
	MOVE T3,[LUUNUL]	;YES. GET NULL VALUE
	MOVEM T3,KLLUUO(T1)	;SET IT
	RET			;DO IT THEN

;ROUTINE TO RETURN LUUO BLOCK ADDRESS SETTING
;RETURNS:	+1 ALWAYS
;		T3/ VALUE OF LUUO BLOCK SETTING

GTLUUB::MOVE T3,KLLUUO(T1)	;GET IT
	CAMN T3,[LUUNUL]	;NULL SETTING
	SETZM T3		;YES,. RETURN A ZERO THEN
	RET			;DONE


;SETPDL - Routine to set up PDL overflow trap information for SWTRP JSYS

;ACCEPTS:
;	T1/ OFFSET TO REFERENCE FORK'S PSB
;	T2/ FLAGS,,FUNCTION CODE FROM USER
;	T3/ ADDRESS OF USER'S BLOCK

;	CALL SETPDL

;RETURNS +1: ALWAYS

;Clobbers T3,T4

SETPDL::TXNN T2,SW%NMI		;WILLING TO ACCEPT UCODE'S DATA?
	JRST SETPD1		;NO. DON'T SIGNAL IT THEN
   IFN KCFLG,<
	TXO T3,1B0		;NO MUUO  ONLY ON THE KC
   >				;END OF IFN KCFLG
SETPD1:	MOVEM T3,PDOVTR(T1)	;SAVE USER'S ADDRESS PLUS FLAG
	CALL SETPOV		;SET UP THE UPT
	RET

;SETPOV - Routine to set the UPT trap word.
;ACCEPTS:
;	T1/ Offset to address PSB for desired fork

;	CALL SETPOV

;RETURNS +1: ALWAYS

;On entry, PDOVTR contains one of the following:
;	0 - don't give user a trap on overflow
;	1B0+address - make processor handle overflow without monitor intervention
;	address - make monitor intervene; address is of user block

;If SWTRP has been done, PDOVTR is non-zero, and SWTRP takes precedence over
;interrupts. If PDOVTR is 0, the monitor will intervene if interrupts are
;enabled. Otherwise, overflow is ignored.


   IFN KLFLG,<
SETPOV::RET
>				;END OF IFN KLFLG

   IFN KCFLG,<
SETPOV::SKIPE T4,PDOVTR(T1)	;GET USER'S BLOCK ADDRESS
      IFSKP.
	MOVX T4,PDOVPC		;MONITOR MUST INTERVENE
      ELSE.
	JUMPG T4,[	MOVX T4,PDOVPC ;GOING STRAIGHT TO USER?
			JRST SETPO1] ;NO.
	TXZ T4,1B0		;YES. CLEAR THE FLAG
	TXO T4,TRUSER		;SET FUNCTION FOR USER ONLY
      ENDIF.
SETPO1:	MOVEM T4,UPTOVI(T1)	;SET THE UPT
	RET
>				;END OF IFN KCFLG
;PAGE FAIL ENTRY WHEN IN SCHED CONTEXT

	RESCD
KIPFS::
KIPFS1:	DMOVEM T1,PFSA1		;SAVE ACS
	MOVEM T3,PFSA3		;SAVE MORE ACS
   IFN KLFLG,<
	MOVE T1,UPTPFW		;CHECK PAGE FAIL CODE
   >				;END OF IFN KLFLG
   IFN KCFLG,<
	MOVE T1,KCPFCD

   >				;END OF IFN KCFLG
	TXNE T1,TWHPFF		;SPECIAL?
	IFSKP.
   IFN KLFLG,<
  	  MOVE T2,TRAPPC	;NO. MAKE SURE WE HAVE THIS DATUM
	  MOVE T3,TRAPFL	;MAKE SURE WE HAVE THIS DATUM
   >				;END OF IFN KLFLG
	  BUG.(HLT,SKDPF1,APRSRV,SOFT,<Page fail in scheduler context>,<<T1,UPTPFW>,<T2,TRAPPC>,<T3,TRAPFL>>,<

Cause:	A page fault occurred while the monitor was running in scheduler
	context and the page fail word did not indicate a "hard"
	failure. This is probably a software bug because the
	scheduler executes only resident code.  One cause of this failure is a
	reference to a piece of swappable code or data that is not currently in
	memory.

Data:	UPTPFW - Page fail word
	TRAPPC - The PC of the instruction that caused the page fault
	TRAPFL - The PC flags of the instruction that caused the page fault

>) ;NO
	ENDIF.
	JSP T2,PFAID		;YES, DISPATCH ON TYPE
	CLHWPT			;CONTINUE
	DMOVE T1,PFSA1
	XJRSTF TRAPFL


;SAVE AND RESTORE STUFF POSSIBLY VULNERABLE WHEN SCHEDULER
;IS STARTING AND STOPPING PROCESS
;CALLED WITH JSP 7,

;Here when stopping a process. Save its data away.

KISSAV::JSP 4,MTIME		;READ HIGH PRECISION CLOCK
	MOVEM 1,SKDLST		;NOTE TIME SCHED OVERHEAD STARTED

;If the process had address break turned on, turn it off

	SKIPE ADRBRK		;ADDRESS BREAK IN PLACE?
	SKIPE EXECBK		;DON'T CLEAR BREAK IF EXEC MODE IN EFFECT
	SKIPA			;EXEC MODE BREAK, OR NO USER MODE. DON'T CLEAR
	JSP T4,CLRBRK		;CLEAR IT

;Save previous context AC's in the PSB.

	STPAC. 5,UAC
	JRST 0(7)

;KISLOD - Restore user context information

KISLOD::
	XSFM T1
	TXO T1,PCU
	XMOVEI T2,KISLD1
	XJRSTF T1
KISLD1:

;Load previous context AC's from the PSB.

	LDPAC. 5,UAC

;If process requested address break, tell the hardware.

	OPSTR <SKIPE T2,>,ABFLG	;ADDRESS BREAK IN PLACE?
	SKIPE EXECBK		;IF EXEC MODE BREAK, DON'T ENABLE USER MODE
	SKIPA			;EXEC MODE, OR NO USER MODE
	JRST [	LOAD T1,ABLOW	;YES, GET LOWER ADDRESS
   IFN KCFLG,<
		LOAD T3,ABUPP	;GET UPPER ADDRESS
   >
		JSP T4,SETBRK	; AND SET IT UP
		JRST .+1]

	JSP 4,MTIME		;READ HIGH PRECISION CLOCK
	MOVEM 1,FKT0		;INIT MEASURING INTERVAL
	SKIPE FKTOFF		;CLOCK OFF?
	MOVEM T1,FKTOFF		;YES, UPDATE OFF TIME
	SUB 1,SKDLST		;COMPUTE TIME SINCE LAST SCHED UPDATE
	CAIGE T1,0		;OVERFLOW?
	ADD T1,BASOVV		;YES, CORRECT
	ADDM 1,SKDOVH		;CHARGE IT TO SCHED OVERHEAD
	JRST 0(7)

	SUBTTL Address Break

   IFN KLFLG,<

;SET ADDRESS BREAK.
;ACCEPTS:
;	T1/ ADDRESS
;	T2/ FLAGS, RIGHT-JUSTIFIED

;	JSP T4,SETBRK

;RETURNS VIA JRST 0(T4)

SETBRK:	LSH T2,<^D35-^L<AB%SEC>> ;PUT BITS IN RIGHT PLACE (ASSUMES THAT
				; AB%XCT IS RIGHTMOST FLAG BIT)
	TXZE T2,AB%RED		;CONVERT SOFTWARE BITS TO
	TXO T1,ABDR		; HARDWARE BITS
	TXZE T2,AB%WRT		; ..
	TXO T1,ABDW
	TXZE T2,AB%XCT
	TXO T1,ABIF
	TXO T1,ABUM		;ALL REFERENCES TO USER ADDRESSES
	DATAO APR,T1		;SET IT UP
	JRST 0(T4)		;RETURN
   >				;END OF IFN KLFLG

   IFN KCFLG,<

;SET ADDRESS BREAK.
;ACCEPTS:
;	T1/ LOWER BOUND ADDRESS
;	T2/ FLAGS, RIGHT-JUSTIFIED
;	T3/ UPPER BOUND ADDRESS

;	JSP T4,SETBRK

;RETURNS VIA JRST 0(T4)

;Note: This code uses a resident block to hold arguments to WRCTX. It is called
;only from the scheduler in order to avoid interlock problems.

SETBRK::MOVX T3,PGLABC!PGLABE!PGENAB ;MASK FOR ENABLING AND SETTING CONDITIONS
	MOVEM T3,BRKBLK+WRCTFG	;SET UP FIRST WORD OF WRCTX BLOCK
	MOVEM T1,BRKBLK+WRCTLO	;SET LOWER BOUND
	MOVEM T3,BRKBLK+WRCTUP	;SET UPPER BOUND
	SETZM T1		;INITIALIZE FLAGS WORD
	LSH T2,<^D35-^L<AB%SEC>> ;PUT BITS IN RIGHT PLACE (ASSUMES THAT
				; AB%XCT IS RIGHTMOST FLAG BIT)
	TXNE T2,AB%RED		;CONVERT SOFTWARE BITS TO
	TXO T1,PGABRD		; HARDWARE BITS
	TXNE T2,AB%WRT		; ..
	TXO T1,PGABWR
	TXNE T2,AB%XCT
	TXO T1,PGABPC
	TXNE T2,AB%SEC
	TXO T1,PGABIS
	TXO T1,PGAUSR		;ALL REFERENCES TO USER ADDRESSES
	MOVEM T1,BRKBLK+WRCTAB	;STORE FLAGS WORD
	WRCTX BRKBLK		;TELL THE HARDWARE
	JRST 0(T4)		;RETURN
   >				;END OF IFN KCFLG


;BRKAVL - CHECK AVAILABILITY OF ADDRESS BREAK (DOESN'T EXIST ON KS10)

   IFN KLFLG!KCFLG,<
BRKAVL::RETSKP
   >				;END OF IFN KLFLG!KCFLG

;CLRBRK - CLEAR ADDRESS BREAK

   IFN KLFLG,<
CLRBRK::DATAO APR,[0]
	JRST 0(T4)
   >				;END OF IFN KLFLG

   IFN KCFLG,<
CLRBRK::WRCTX [PGLABE]		;TELL THE HARDWARE TO DISABLE BREAKS
	JRST 0(T4)
   >				;END OF IFN KCFLG

;STEXBK - Set exec mode address break

;Accepts:
;	T1/ word for DATAO APR

;	CALL STEXBK

;Returns +1: failure because user mode break is set
;	 +2: success

;Alternate entry, STEXDM, sets break even though users may be using it. If
;so, address break will cease to work for the users.

;Format of T1:

;Bit 9: PC fetch
;Bit 10: Data read
;Bit 11: Data write
;Bit 12: user mode reference
;Bits 13-35: Address to break on

;NOTE: This code clears the user mode bit but otherwise does not check
;or correct T1!!!

   IFN KLFLG,<
STEXBK::NOSKD1
	SKIPN USERBK		;ANY USER MODE BREAK IN EFFECT?
	JRST STEXB2		;NO. WE CAN DO OURS
	OKSKD1
	RET			;YES. FAIL, THEN
STEXDM:	NOSKD1
STEXB2:	TXZ T1,ABUM		;NO REFERENCES TO USER ADDRESSES
	JUMPE T1,R		;IF NOTHING TO DO, INDICATE FAILURE
	MOVEM T1,EXECBK		;INDICATE THAT IT WAS SET TO LOCK OUT USERS
	DATAO APR,T1		;SET THE BREAK
	OKSKD1
	RETSKP			;RETURN SUCCESS


;CLEXBK - Clear exec mode break

CLEXBK:	NOSKD1
	DATAO APR,[0]		;CLEAR BREAKS
	SETZM EXECBK		;ALLOW USERS TO ENABLE ADDRESS BREAK
	OKSKD1
	RET
   >				;END OF IFN KLFLG

;STEXBK - Set exec mode address break

;Accepts:
;	T1/ flags
;	T2/ lower bound address
;	T3/ upper bound address

;	CALL STEXBK

;Returns +1: failure
;	 +2: success

   IFN KCFLG,<
STEXBK::SAVET
	STKVAR <<EXBRK,5>>
	NOSKD1
	SKIPN USERBK
	JRST STEXB1
	OKSKD1
	RET
STEXDM:	SAVET
	STKVAR <<EXBRK,5>>
	NOSKD1
STEXB1:	TXZ T1,PGAUSR		;NO USER MODE BREAK
	MOVEI T4,EXBRK		;GET ADDRESS OF BLOCK
	MOVEM T1,WRCTAB(T4)	;STORE FLAGS IN BLOCK
	MOVEM T2,WRCTLO(T4)	;STORE LOWER ADDRESS
	MOVEM T3,WRCTUP(T4)	;STORE UPPER ADDRESS
	MOVX T1,PGLABC!PGLABE!PGENAB ;MASK FOR ENABLING AND SETTING CONDITIONS
	MOVEM T1,WRCTAC(T4)	;SET IT
	MOVEM T2,EXECBK		;SAVE ADDRESS AS SIGNAL TO JSYS
	WRCTX EXBRK		;TELL THE HARDWARE
	OKSKD1
	RETSKP

CLEXBK:	NOSKD1
	WRCTX [PGLABE]
	SETZM EXECBK
	OKSKD1
	RET
   >				;END OF IFN KCFLG

;CKXADR - CHECK IF MACHINE SUPPORTS EXTENDED ADDRESSING
;
;call:		call CKXADR
;returns: +1	EXTENDED ADDRESSING NOT SUPPORTED, T1/ ERROR CODE
;	  +2	EXTENDED ADDRESSING SUPPORTED

CKXADR::RETSKP			;YES

;Routine to check for CFS microcode.
;Returns:	+1 if CFS UCODE running.
;		BUGHLT if not

CHKCFS::
   IFN KLFLG,<			;If KC, it will be
	PIOFF			;Own it all for a bit
	MOVEI T1,CHKCFS/PGSIZ	;Page number to test
	PUSH P,@CST0X+T1	;Save CST entry for this page
	PUSH P,UPTPFN		;Save PF word
	XMOVEI T2,CHKCF0	;New PF PC
	MOVEM T2,UPTPFN
	MOVX T2,PSASM		;Make it accessible, but not writable
	MOVEM T2,@CST0X+T1	;Do it
	MOVE T2,IMMPTR		;Page pointer
	HRR T2,T1		;Page number
	MOVEM T2,MMAP+PIPG	;Into MMAP
	MOVES PIPGA		;Try to write it
CHKCFX:	BUG. (HLT,CFSWMC,APRSRV,HARD,<Wrong UCODE for CFS>,,<

Cause:	The KL microcode currently running does not support CFS.

Action:	Install the correct microcode on the front end and reload the
	system. Be sure to answer "YES" to the "RELOAD MICROCODE" prompt
	from KLI.
>) ;Yes. Wrong UCODE then
CHKCF0:	MOVE T2,UPTPFW		;Get PF word
	TXNE T2,TWHPFF		;Hard error?
	JRST CHKCFX		;Yes.
	POP P,UPTPFN
	POP P,@CST0X+T1		;Restore CST
	SETZM MMAP+PIPG		;Restore CST entry
	CLRPT PIPGA		;Clear map
	PION
   >	;IFN KLFLG
	RET
	SUBTTL Pager Control Routines

Repeat 0,<	;[7.1002] Obsolete PMOVE/PMOVEM instructions do the work
;MOVE FROM REAL CORE ADDRESS
; T1/ WORD NUMBER
; T2/ PHYSICAL CORE PAGE NUMBER
;	CALL MOVRCA
; RETURN +1 ALWAYS, T1/ WORD FROM PAGE
;MAY BE CALLED AT ANY PI LEVEL

; Edit 7363 is put in to take advantage of the PMOVE instruction within
; the microcode (if it is there). This edit will be modified in the future
; when everyone has the PMOVE microcode. There will no longer be a need for
; this edit!

MOVRCA::
	MOVE T4,[PMOVE T1,T1]	;[7363] Load the PMOVE instruction
	MOVE CX,APRFLW		;[7363] Get APRID word
	TXNE CX,PMOV		;[7363][7376] Is PMOVE present?
	 CALLRET XCTPMV		;[7363] Yes, use it
	MOVE T4,[MOVE T1,PIPGA(T1)] ;INSTR TO EXECUTE
	CALLRET XCTRCA		;DO INSTR WITH ADDR MAPPED

;STORE TO REAL CORE ADDRESS
;T1/ WORD NUMBER
;T2/ PHYSICAL CORE PAGE NUMBER
;T3/ WORD TO STORE
;	CALL STORCA
;RETURNS+1(ALWAYS)

STORCA::
	EA.ENT			;RUN IN SECTION 1
	MOVX T4,CORMB
	IORM T4,@CST0X+T2	;NOTE PAGE MODIFIED
	MOVE T4,[PMOVEM T3,T1]	;[7363] Load the PMOVEM instruction
	MOVE CX,APRFLW		;[7363] Get APRID word
	TXNE CX,PMOV		;[7363][7376] Is PMOVEM present?
	 CALLRET XCTPMV		;[7363] Yes, use it
	MOVE T4,[MOVEM T3,PIPGA(T1)] ;INSTR TO EXECUTE
;	CALLRET XCTRCA		;DO INSTR WITH ADDR MAPPED
>	;[7.1002] End obsolete code

;LOCAL ROUTINE TO EXECUTE AN INSTRUCTION WITH PIPGA SETUP
;T2/ CORE PAGE NUMBER
;T4/ INSTR TO EXECUTE
;T1 & T3 MAY BE USED BY THE INSTRUCTION.
;THE USUAL CASE IS TO HAVE T1 CONTAIN THE RELATIVE WORD ADDRESS.

XCTRCA:	EA.ENT			;RUN IN SECTION 1
	PIOFF
	PUSH P,@CST0X+T2	;SAVE OLD CST ENTRY
	SETOM @CST0X+T2		;FORCE NO AGE FAULT
	HLL T2,IMMPTR		;CONSTRUCT POINTER
	MOVEM T2,MMAP+PIPG	;PUT IN MON MAP TEMP SLOT
	CLRPT PIPGA		;CLEAR HDWR
	XCT T4			;DO INSTR FOR CALER
	SETZM MMAP+PIPG		;CLEAR TEMP MAPPING
	HRRZS T2		;CLEAR BACK TO ADDRESS ONLY
	POP P,@CST0X+T2		;RESTORE CST
	CLRPT PIPGA		;CLEAR HARDWARE
	PION
	RET

Repeat 0,<	;[7.1002] More obsolete code
;LOCAL ROUTINE TO EXECUTE AN INSTRUCTION (PMOVE OR PMOVEM)
;T2/ CORE PAGE NUMBER
;T4/ INSTR TO EXECUTE
;T1 & T3 MAY BE USED BY THE INSTRUCTION.
;THE USUAL CASE IS TO HAVE T1 CONTAIN THE RELATIVE WORD ADDRESS.

XCTPMV:	LSH T2,PGSFT		;[7363] Tranform T2 from page number to address
	IOR T1,T2		;[7363] Put page and offset together
	XCT T4			;[7363] Do PMOVE/M instruction
	RET			;[7363] And continue
>	;[7.1002] End obsolete code.

;MAPRCA - MAP PHYSICAL CORE PAGE FOR LOCAL REFERENCE.  ASSUMES PI OFF.
; T1/ PHYSICAL CORE PAGE NUMBER
;	CALL MAPRCA
; RETURN +1 ALWAYS, T1/ VIRTUAL ADDRESS WHERE PAGE MAPPED

MAPRCA::HLL T1,IMMPTR		;CONSTRUCT PTR
	MOVEM T1,MMAP+PIPG
	CLRPT PIPGA
	MOVEI T1,PIPGA		;RETURN ADDRESS OF TEMP PAGE
	RET

;SET PI SPECIAL PAGE
; T1/ PTN,,PN
; or
; T1/ 0,,SPTN
;	CALL MAPIPG
; RETURN +1 ALWAYS, PTN MAPPED INTO PIPGA

MAPIPG::CONSZ PI,PIPION		;PI OFF?
	BUG.(HLT,PIRACE,APRSRV,SOFT,<MAPIPG - Called with PI on>,,<

Cause:	This routine uses a MMAP entry which may be used at PI level.
	To avoid races the PI should be off when it is called.
	This particular caller did not turn off the PI.  

Action: Check the stack to find the caller.
>)
	EA.ENT			;RUN IN SECTION 1
	PUSH P,T1
	TLNE T1,-1		;PTN in LH or RH?
	HLRZ T1,T1		;GET PTN
	LOAD T1,STGADR,SPT(T1)	;GET ADDRESS
	CAMLE T1,NHIPG		;LEGAL PAGE?
	BUG.(HLT,PINIC1,APRSRV,SOFT,<MAPIPG - Page table not in core>,,<

Cause:	A routine has been called to map a page into a special
	address slot.  The requested page is not in memory.
>)
	IOR T1,IMMPTR		;CONSTRUCT PRIVATE PTR
	MOVEM T1,MMAP+PIPG	;PUT IN MON MAP
	HRRZS T1
	HLL T1,@CST0X+T1	;CHECK AGE
	TXNN T1,PSASM		;NOW ASSIGNED?
	CALL AGESN		;NO, SET AGE
	CLRPT PIPGA
	POP P,T1
	RET
;UNMRCA - CLEAR MAPPING SETUP BY MAPRCA
;NO ARGUMENTS, PRESERVES ALL REGISTERS

UNMRCA::SETZM MMAP+PIPG		;CLEAR MAP SLOT
	CLRPT PIPGA		;CLEAR HARDWARE PAGER
	RET

;CLEAR PAGING MEMORY - VARIOUS AREAS.  ALL DO COMPLETE CLEAR AT PRESENT.
;KICLDP -- accepts physical  page number in T1

MONCLA::			;CLEAR ALL MONITOR PAGES
PGRCLD::			;CLEAR ALL PAGES
KICLKP::			;CLEAR AND LOAD SELECTED PAGE (T1)
	CLHWPT
	RET

;CLEAR PAGING MEMORY FOR SPECIFIC PAGE
; T1/ PAGE NUMBER
;	CALL MONCLR
; RETURNS +1 ALWAYS

MONCLR::JUMPE T1,MONCLA		;0 MEANS CLEAR ALL
	CLRPT 0(T1)		;CLEAR
	RET

;Clear all of pager, including kept pages
;Preserves all ACs

CLRALL:	CONO PAG,@CONOPG	;Clear the pager
	RET			;And done

;SET BIT IN KIPGWD THAT SAYS "DO NOT CLEAR KEPT ENTRIES". CALLED ONCE DURING
;SYSTEM STARTUP AFTER AT LEAST ONE PAGER CLEAR HAS BEEN DONE. CHECK FOR THE
;PRESENCE OF THE MCA25, AND DO NOT SET THE BIT IF MCA25 IS NOT INSTALLED.


;	CALL STKEEP

;RETURNS +1: ALWAYS

STKEEP::APRID T1
	TXNN T1,MCA25		;IS MCA25 INSTALLED
	RET			;NO.
	MOVX T1,PGCLKP		;YES. GET THE KEEP BIT.
	IORM T1,KIPGWD		;SET IT.
	RET

;TESTKP - test to see if particular address is "kept"

;ACCEPTS:
;	T1/ VIRTUAL ADDRESS

;	CALL TESTKP

;RETURNS +1: INVALID MAPPING OR NOT KEPT
;	 +2: KEPT

;Clobbers T1

TESTKP::MAP T1,(T1)
	SMAPOK T1		;CHECK FOR VALID MAPPING
	RETBAD ()		;INVALID MAPPING
	TXNN T1,TWKEEP		;VALID. IS IT KEPT?
	RETBAD ()		;NO.
	RETSKP			;YES.


;Routine to test if two adjacent virtual pages are also physicall
;adjacent.
;	T1/ virtual address of first page.
;Pages must be accessible, and preferably locked. This routine
;does not insure that the current page accessibility is maintained!
;Returns:	+1 not adjacent
;		+2 they are.
;Clobbers all T regs.
;As a bonus, T1 is returned with the mapping for VA+PGSIZ

CPPCON::MAP T2,0(T1)		;Get mapping of first page
	SMAPOK T2		;Is it OK?
	RETBAD()		;No. Can't be contiguous then
	MAP T1,PGSIZ(T1)	;Get second page
	SMAPOK T1		;Is it OK?
	RETBAD()		;No
	ADDI T2,PGSIZ		;They should be the same now
	XOR T2,T1		;Check it out
	TXNE T2,PHCPNO		;Are they the same now?
	RETBAD()		;No. Not adjacent
	RETSKP			;yes.

;LOAD AGE
; T1/ AGE
;	CALL LDAGER
; RETURN +1 ALWAYS

;Called by PGRINI to initialize the age field in the CST data word
;For the KL, stores age in AC block 6

   IFN KLFLG,<
LDAGER::DATAO PAG,SETHWR	;SET TO LOAD SPECIAL AC BLOCK
	XCTBU [STOR T1,AGEMSK,CSTDAT] ;SET NEW AGE IN CST UPDATE DATA
	DATAO PAG,SETMON	;RESTORE NORMAL AC BLOCKS
	CLHWPT
	RET
   >				; END IFN KLFLG

;Read the process use register, and update its age

   IFN KCFLG,<
LDAGER::RDPUR T2		;FIND OLD VALUE
	STOR T1,AGEMSK,T2	;SET NEW AGE
	WRPUR T2		;RE-WRITE
	CLHWPT
	RET
   >				;END IFN KCFLG

;MOVE TO AGE
; T2 /NEW AGE WORD
;	CALL MVAGER
;	RETURN +1 ALWAYS

;Called by SETPPG when switching processes. Stores new values (age and process
;handle) in CST data word, and sets the new UPT.

   IFN KLFLG,<
MVAGER::DATAO PAG,SETHWR	;SET HARDWARE AC BLOCK ADDRESS
	UMOVEM T2,CSTDAT	;SET CST AGE WORD
	DATAO PAG,SETMON	;SET AC'S BACK
	CLHWPT			;CLEAR HARDWARE PAGE TABLE
	RET			;RETURN

   >				;END IFN KLFLG

;Write full word to process use register

   IFN KCFLG,<
MVAGER::WRPUR T2		;WRITE NEW CST AGE WORD
	CLHWPT			;CLEAR HARDWARE PAGE TABLE
	RET			;RETURN
   >				;END IFN KCFLG

;Routine to set the EPT base address. Assumes CONOPG has been set up
;with address of EPT.

SETEPT::
   IFN KLFLG,<
	CONO PAG,@CONOPG>
   IFN KCFLG,<
	WREBR CONOPG>
	RET

;TURN PAGER ON

PGRON::	SAVEAC <A>
	MOVX A,PGKLMD+PGTPEN
	IORM A,CONOPG		;USE KL MODE PAGING
   IFN KLFLG,<
	CONO PAG,@CONOPG
   >				;END OF IFN KLFLG
   IFN KCFLG,<
	WREBR CONOPG
   >				;END OF IFN KCFLG
;	CLHWPT
	RET

;PGROFF - TURN PAGER OFF

   REPEAT 0,<		;Not presently used.  It would be fatal in any case.

;This routine unconditionally turns off paging. It sets the EPT base
;address according to whatever the caller has set in CONOPG.

PGROFF::MOVE A,CONOPG
   IFN KLFLG,<
	TXZ A,PGTPEN		;CLEAR TRAP ENABLE
	CONO PAG,0(A)
   >
   IFN KCFLG,<
	TXZ A,PGENPG		;TURN OFF PAGING
	WREBR A
   >
	RET
   >			;END REPEAT 0

;SET PAGER FOR SCHEDULER CONTEXT

SETPSK::MOVEI T1,SKHWPT/PGSIZ	;CORE PAGE NUMBER OF SYSTEM PSB
	STOR T1,PAGUBA		;PUT IT IN DATAO WORD
	MOVE T2,PSBBAS
	STOR T1,STGADR,SPT(T2)	;PUT IT IN MMAP BASE
	CLHWPT
	SETOM LSTPFK		;NO FORK NOW SETUP
	RET


;SPECIAL ROUTINES USED BY DIAG MEM MEANAGEMENT TO ENABLE AND
;DISABLE METER UPDATES IN THE EPT.

;DISABLE UPDATES. ARRANGES FOR METER UPDATES TO BE DISABLED
;UPON RETURN TO THE USER.

	RESCD
MTROFF::
   IFN KLFLG,<
	CONO MTR,MTRLOD+MTRTBF	;TURN OFF METER
	CONO TIM,0		;TURN OFF TIME BASE
   >				;END OF IFN KLFLG
   IFN KCFLG,<
	WRTMB TMBLTB		;TURN OFF TIME BASE
	WRINT 0			;TURN OFF INTERVAL COUNTER
   >				;END OF IFN KCFLG
	RET			;DONE

;SPECIAL ROUTINE TO WAIT FOR EPT USERS TO FINISH.
;MUST BE CALLED WITH PIOFF. MAY NOT RETURN FOR A LONG
;TIME, SO CALLER MUST INSURE THAT KEEP-ALIVE CHECKING
;IS DISABLED. WAITS FOR CHANNELS AND DEVICES THAT
;MAY MODIFY MEMORY (THE EPT ESPECIALLY) TO COMPLETE

WATEPT::
   IFN KLFLG,<			;FOR THE KL ONLY
	CALL DTEINA		;WAIT FOR DTE TO ABATE
   >				;END OF IFN KLFLG
	MOVX T1,^D500000
	SOJG T1,.
	RET			;HACK FOR NOW.

;ROUTINE TO REVERSE EFFECT OF WATEPT. USED BY DIAG TO
;TURN SYSTEM ON AGAIN
;This routine is similar to MTRON. However, it does not clear the
;interval counter when turning it on. It also does not clear the
;time base when turning that back on.

UNWEPT::
   IFN KLFLG,<			;IF ON THE KL
	CALL DTICON		;SUPPRESS "CONTINUED" MESSAGE
	CALL DTEACT		;REACTIVATE DTES
	CONO TIM,TIMDON+TIMITO+TIMTMS ;TURN ON TIMER, BUT DON'T CLEAR
	CONO MTR,MTRLOD+MTRTBN+MTRAMN+PIBITS+TIMCHN ;AND TURN ON MTR
   >				;END OF IFN KLFLG CONDITIONAL
   IFN KCFLG,<
	WRINT TIMDON+TIMITO+TIMTMS
	WRTMB TMBLPI+TMBLTB+TMBBON+TIMCHN
	WRACT ACTLOD+ACTAON+PIBITS
   >				;END OF IFN KCFLG
	RET			;AND DONE

;ROUTINE TO CHECK IF A RESIDENT MONITOR PAGE IS MOVABLE.
;CALLED FROM PAGEM
;	T1/ PAGE NUMBER
;RETURNS:	+1 NOT MOVABLE
;		+2 MOVABLE

RMPCHK::
   IFN KLFLG,<			;FOR THE KL NEED TO CHECK COMM REGION
	CAIL T1,COMBUF/PGSIZ	;WITHIN THE COMM REGION?
	CAILE T1,<ENDRGN-1>/PGSIZ ;?
	RETSKP			;NO. GOOD THEN
	RETBAD()		;YES IT IS. CAN'T MOVE IT
   >				;END OF IFN KLFLG

;* * * *
;Not clear what's needed here
; * * * *
IFN KCFLG,<RETSKP>		;DONE

;SET SWAPPER SPECIAL PAGE TO CURRENT PAGE TABLE
; T1/ PTN,,PN
; or
; T1/ 0,,SPTN
;	CALL SETSPG
; RETURN +1 ALWAYS, PTN MAPPED INTO CSWPGA

SETSPG::EA.ENT			;RUN IN SECTION 1
	PUSH P,T1
	TLNE T1,-1		;PTN in LH or RH?
	HLRZ T1,T1		;GET PTN
	LOAD T1,STGADR,SPT(T1)	;GET ADDRESS
SETSP1:	CAMLE T1,NHIPG		;LEGAL PAGE?
	BUG.(HLT,PTNIC1,APRSRV,SOFT,<SWPIN - Page table not in core>,,<

Cause:	A routine has been called to map a page table into a special
	page used only by the swapping routines. The caller is expected
	to provide an identifier for a page that is in memory. When a
	page is in memory, the page table that points to it must be
	in memory. The BUGHLT indicates that the storage address for
	the page table is not a valid core page. This can indicate that the
	page is not in memory or that its memory address is larger
	than the physical memory on the machine. The most likely
	cause is corruption of the monitor's data base.
>)
	IOR T1,IMMPTR		;CONSTRUCT PRIVATE PTR
	MOVEM T1,MMAP+CSWPG	;PUT IN MON MAP
	HRRZS T1
	HLL T1,@CST0X+T1	;CHECK AGE
	TXNN T1,PSASM		;NOW ASSIGNED?
	CALL AGESN		;NO, SET AGE
	CLRPT CSWPGA
	POP P,T1
	RET

;GIVEN CORE PAGE NUMBER IN 1, SETUP CSWPG

SETSP0::IOR T1,IMMPTR		;CONSTRUCT PTR
	MOVEM T1,MMAP+CSWPG	;PUT IN MON MAP
	CLRPT CSWPGA
	RET

RELSPG::SETZM MMAP+CSWPG
	CLRPT CSWPGA
	RET

;ZERO CORE PAGE GIVEN IN 1

SWPZPG::EA.ENT			;RUN IN SECTION 1
;	PUSH P,@CST0X+T1	;Save CST entry
	MOVX T2,<PSASM!CSWRB>	;SET LEGAL AGE FOR LOCAL REF
	IORM T2,@CST0X+T1
	MOVE T2,IMMPTR
	STOR T1,STGADR,T2	;CONSTRUCT PRIVATE PTR
	MOVEM T2,MMAP+CSWPG	;PUT IN MON MAP
	CLRPT CSWPGA
	MOVE T2,[XWD CSWPGA,CSWPGA+1]
	SETZM CSWPGA		;CLEAR FIRST LOCATION
	BLT T2,CSWPGA+PGSIZ-1	;ZERO THE PAGE
	SETZM MMAP+CSWPG
	CLRPT CSWPGA
;	POP P,@CST0X+T1		;Restore the CST entry
	RET

;SETUP TEMP MAPPING UNDER SCHED CONTEXT
; T1/ SPTN OF DESIRED PAGE
;	CALL SFITPG
; RETURNS +1 ALWAYS, PAGE MAPPED AT FITPGA

SFITPG::JUMPE T1,[SETZM MMAP+FITPG ;CLEAR SLOT IF 0 GIVEN
		JRST SFITP1]
	PUSH P,SHRPTR		;CONSTRUCT SHARE PTR
	STOR T1,SPTX,0(P)
	POP P,MMAP+FITPG	;PUT IN MON MAP
SFITP1:	CLRPT FITPGA
	RET

;SETUP TEMP MAPPING UNDER SCHED CONTEXT
; T1/ SPTN OF DESIRED PAGE
;	CALL SFITPG
; RETURNS +1 ALWAYS, PAGE MAPPED AT PRLPGA

SPRLPG::JUMPE T1,[SETZM MMAP+PRLPG ;CLEAR SLOT IF 0 GIVEN
		JRST SPRLP1]
	PUSH P,SHRPTR		;CONSTRUCT SHARE POINTER
	STOR T1,SPTX,0(P)
	POP P,MMAP+PRLPG
SPRLP1:	CLRPT PRLPGA
	RET

;SET SWAPPER SPECIAL PAGE TO GIVEN PTN
; 6/ SPTX OF DESIRED PAGE
;	CALL SETSP6
; RETURN +1 ALWAYS, PAGE MAPPED INTO CSWPG,
; 6/ PHYSICAL ADDRESS OF PAGE

SETSP6::PUSH P,1
	LOAD 6,STGADR,SPT(6)	;GET ADR AND RETURN IT IN 6
	MOVE 1,6
	JRST SETSP1		;JOIN STANDARD CASE
	SUBTTL Page Fail Handler (Hard Error Codes and Unusual Cases)

   IFN KCFLG,<
PFAID::JRST 0(T2)
PGMPE0::RETSKP
MBERRB:	RET
SYRMAP:	RETSKP
PFERRB:	RET
   >				;END OF IFN KCFLG

;DIAGNOSE PAGE FAIL WITH FAIL CODE
; 1/ PAGE FAIL WORD
;	JSP T2,PFAID		;JSP USED BECAUSE NO STACK SETUP HERE
; RETURN +1 IF PROGRAM TO BE CONTINUED

;Here on a page fail where the code indicates "hard" failure. Called
;by

;	1. PIPTRP (PAGEM) when page fail code is 36 or 37 (AR or ARX parity
;error) and page fail occurred when processing an interrupt
;	2. PGRTH (PAGEM) when page fail code is 20 or 22 (undefined) or 25
;(page table parity error)
;	3. KIPFS when page fault occurred in scheduler context

   IFN KLFLG,<
PFAID::	LOAD T1,TWCOD,T1	;GET PAGE FAIL CODE
	CAIL T1,PECOD0		;MPE GROUP?
	JRST PFCDPE		;YES

;Page fail code is not AR or ARX parity error. We expect some sort of
;hard error code here. BUGHLT if that is not the case.
;Otherwise transfer according to the vector below

	CAIL T1,KLCOD0		;KL PAGING CODE?
	JRST PFCDX		;YES, NOT EXPECTED HERE
	HRRZ T1,PFCODT-PFCOD0(T1) ;GET DISPATCH ADDRESS
	JRST 0(T1)		;AND GO THERE

;Transfer vector for page fail codes 20 to 27

PFCOD0==20			;FIRST SPECIAL TRAP CODE
KLCOD0==30			;LOWER BOUND OF CODES FOR KL PAGING
PECOD0==36			;MPE GROUP
PFCODT:	PFCD20			;NXM
	PFCD21			;PROPRIETARY VIOLATION
	PFCD22			;REFILL ERROR
	PFCD23			;ADDRESS BREAK
	PFCDX			;ILLEGAL INDIRECT
	PFCD25			;PAGE TABLE PARITY ERROR
	PFCDX			;UNKNOWN
	PFCD27			;ILLEGAL ADDRESS

;Didn't expect this page fail. BUGHLT

PFCDX::	BUG.(HLT,UNPGF2,APRSRV,HARD,<Unknown page failure type>,,<

Cause:	A page fault has occurred and the page fail word indicates
	a "hard" error. The monitor has read the type of failure from
	the page fail word and one of the following is true:

	1. The hardware is never supposed to generate the code.
	2. The code is valid, but the scheduler is running, and this
	code should never be generated from scheduler context.
>)

;Page fail code is 20. BUGHLT on KL. Complain and continue on KS

PFCD20::JRST PFCDX		;ILLEGAL ON OTHER THAN SM10

;Page fail code is 21 (proprietary violation).

PFCD21:	BUG.(HLT,PVTRP,APRSRV,HARD,<Proprietary violation trap>,,<

Cause:	A page fault occurred indicating a proprietary violation while
	the monitor was running in scheduler context. An instruction in 
	a public page attempted to reference a concealed page. Since TOPS-20  
	uses only concealed mode, this BUGHLT should never happen.
>)

;Page fail code is 22 (refill error). This is not supposed to happen
;in TOPS-20 paging.

PFCD22::BUG.(CHK,RFILPF,APRSRV,HARD,<Refill error page fail>,,<

Cause:	A page fault occurred indicating a refill error. This condition
	is indicated by a "hard" failure code of 22 in the page fail
	word and should occur only under KI-style paging.
	TOPS-20 does not use this style of paging. The monitor will retry
	the instruction.
>)
	JRST 0(T2)		;TRY AGAIN

;Page fail code is 27 (illegal address). Scheduler referenced a
;section greater than 37

PFCD27::BUG.(HLT,ILPSEC,APRSRV,SOFT,<Illegal section number>,<<UPTPFO,PC>,<UPTPFW,PFW>>,<

Cause:	While running in scheduler context, the monitor made a reference to an
	address whose section number exceeded 37.

Data:	PC - PC when instruction was executed
	PFW - page fail word
>)
	HRRZS UPTPFO		;CLEAR SECTION
;	JRST PFCD23

;ADDRESS COMPARE - MAY BE SETUP WITH DATAO APR,[ADDRESS]
;Page fail code is 23 (address compare). Address break is set on
;the location in the page fail word
;note -- address break in user context goes to ADRCMP in PAGEM

PFCD23::MOVX T1,PC%AFI		;(CAN PUT BREAKPOINT HERE)
	IORM T1,UPTPFL		;INHIBIT TRAP ONCE SO PGM CAN CONTINUE
	JRST 0(T2)		;CONTINUE

;Page fail code is 25 (page table parity error). Hardware failure.

PFCD25::AOSLE PTPARC		;Should we forge ahead?
	BUG.(HLT,PTMPE,APRSRV,HARD,<Page table parity error>,,<

Cause:	The monitor encountered multiple page table parity errors.

>)
	CALL CLRALL		;Clear all of pager, including KEPT entries
	BUG. (CHK,PTPTE1,APRSRV,HARD,<Page table parity error>,<<UPTPFW,PFW>>,<

Cause:	A page table entry has bad parity. The monitor will clear
	the entry and try again. If it fails repeatedly, PTMPE
	will result.

Data:	PFW - Page fail word
>,,<DB%NND>)			;[7.1210]
	JRST 0(T2)		;And try again

;Here when page fail code is 36 or 37, indicating parity error.

PFCDPE:	HRRZ T1,UPTPFO		;FIND TRAP ADDRESS
	CONSZ APR,APNXM		;NXM CAUSED THIS?
	JRST PFNXM		;YES
	CONSO PI,PIPION		;PI ON?
	JRST [	CAIGE T1,PGRI6	;NO -- CHECK FOR LEGAL PARITY ERRORS
		CAIGE T1,PGRI2A	;THE ONLY LEGAL TIMES ARE DURING CORE SCAN IN PGRINI
		JRST PFCDP1	;NOT LEGAL. QUIT
		JRST PFNXM]	;TREAT AS NXM (SKIP INSTRUCTION)

;PI system is on. Let memory scan finish

	MOVX T1,1B17		;GET A LARGE NUMBER
	CONSZ APR,APMPE		;SWEEP DONE?
	SOJG T1,.-1		;WAIT A WHILE FOR IT TO COMPLETE
	PIOFF			;TURN OFF PI SYSTEM NOW
PFCDP1:	MOVEM P,MEMAP		;SAVE OLD STACK JUST IN CASE
	MOVE P,[IOWD NMEMPP,MEMPP] ;SET UP A STACK
	CALL PGMPE0		;GO HANDLE AR/ARX TRAP
	 JFCL			;DON'T CARE IF IT WAS HARD OR NOT
	BUG.(HLT,SKDMPE,APRSRV,HARD,<MPE in scheduler or PI context>,,<

Cause:	A page fault occurred indicating an AR or ARX parity error
	while the monitor was processing an interrupt or running
	the scheduler. This BUGHLT occurs regardless of whether the
	error is repeated when the reference is retried or not.
	The monitor has printed a description of the problem on the CTY.
	A SYSERR block has been created and will be placed in the
	SYSERR file when the monitor is rebooted.
>)

;Here on a NXM. This also causes an AR/ARX parity error. Normally we
;don't get here because NXM causes an interrupt, wich leads to an
;APRNX1 BUGHLT.

PFNXM::	CONOAPR APFCLR+APSBER+APMPE ;CLEAR SPURIOUS FLAGS
	CONSZ PI,PIPION		;PI SYSTEM ON?
	BUG.(HLT,APRNX2,APRSRV,HARD,<NXM detected by APR>,,<

Cause:	A page fault occurred, indicating that the processor
	attempted to access a memory that did not respond within
	a preset time. The monitor is presently processing an
	interrupt or running in the scheduler and the interrupt
	system is turned on. Since non-existent memory also
	produces an APR interrupt, which results in an APRNX1 BUGHLT,
	this BUGHLT does not normally occur.

Action:	See APRNX1. Note, however, that the occurrence of this BUGHLT
	instead of APRNX1 may indicate a failure in the interrupt
	system.
>) ;YES
	AOS UPTPFO		;FAKE COMPLETION OF INSTRUCTION
	JRST 0(T2)		;CONTINUE, ASSUME PGM WILL CHECK FOR NXM

;PARITY ERROR TRAP IN PROCESS CONTEXT - HERE FROM DISPATCH AT PGRTRP
;RETURNS +1, NOT RECOVERABLE; RETURNS +2, RECOVERABLE

;Here from PGRTRP or PFAID when page fail code indicated AR or ARX parity error
;From PGRTRP, in user context. From PFAID, in scheduler or interrupt context.

;LOCAL FLAGS IN F

PFCPF0==1B18			;ON WHEN EXECUTING TEST REFERENCE
PFCPF1==1B19			;ON IF LAST TEST REFERENCE FAILED
PFCPF2==1B20			;ON IF PI SYSTEM ON AT ENTRY
PFCPF3==1B21			;ON IF TESTING AN EPT WORD
PFCPF4==1B22			;ON IF TESTING A UPT WORD

;Also in F:
;PT%CCH means cache was on
;PT%ESW means ???

;This code retries with and without cache, creates a SYSERR block and
;prints a message on the CTY
;On a nonrecoverable error in the memory this routine calls BADCPG, which
;will BUGHLT if the page is critical.

PGMPE0::SKIPE T1,DIAGAR		;AR/ARX INTERCEPT SET?
	JRST [	JE UMODF,UPTPFL,.+1 ;USER MODE?
		AOS UPTPFO	;YES. ASSUME NO INTERVENTION
		SKIPL T1	;AN ADDRESS GIVEN?
		MOVEM T1,UPTPFO	;YES. STORE NEW ADDRESS
		RETSKP]		;AND RETURN TO THE USER
	CONSZ APR,APNXM		;NXM CAUSED THIS?
	JRST PGNXM0		;YES
	PUSH P,F		;INIT LOCAL FLAG REG

;Save the state of the PI's.

	SETZ F,
	CONSO PI,PIPION		;NORMAL SYSTEM OPERATION (PI ON)?
	JRST [	CONOAPR APFCLR+APSBER+APIOPF+APMPE+APCDPE+APAPE
		JRST PFCP3]	;NO, CLEAR APR BITS, NO INTERRUPT
	TXO F,PFCPF2		;REMEMBER TO RESTORE PI

;Allow memory parity error interrupt to occur

	MOVX T1,1B17		;GET A LARGE NUMBER
	CONSZ APR,APMPE!APSBER	;AN APR INT PENDING?
	SOJG T1,.-1		;YES. WAIT FOR IT

;Don't allow loading of the cache

PFCP3:	MOVE T1,CONOPG
	TXZ T1,PGCLDE		;SET CACHE NO LOAD
	CONO PAG,0(T1)
	MOVEM P,MEMAP		;[7447] Save current stack pointer
	MOVE P,[IOWD NMEMPP,MEMPP] ;[7447] And set up APR stack

;Save current page fail information

	PUSH P,UPTPFN		;[7447] Save old and new trap PC
	PUSH P,UPTPFO		;[7447]
	PUSH P,UPTPFL		;[7447]

;Get SYSERR block and store data

	MOVEI T1,PT%LEN
	MOVEI T2,PT%SIZ
	CALL ALCSEB		;ASSIGN SYSERR BUFFER
	 BUG.(HLT,NOSEB2,APRSRV,SOFT,<PGMPE-No SYSERR buffer available>,,<

Cause:	An AR or ARX parity error has occurred, and the monitor
	is creating a SYSERR block. The BUGHLT indicates that no
	free space is available for the SYSERR block. UPTPFW
	contains the page fail word.
>)
	MOVEI Q2,SEBDAT(T1)	;Q2 HOLDS PTR TO DATA BLOCK
	HRL Q2,T1		;LH HOLDS ORIGINAL PTR
	PIOFF			;PROCEED WITH PI OFF
	;..
	;..

;Set up UPT so that page faults will go to special routine, which will
;determine if fault occurred while testing memory.

	MOVE T1,UPTPFW
	MOVEM T1,PT%PFW(Q2)	;REPORT IT
	MOVE T3,[PFCPTP]	;BUILD TEMPORARY PF TRAP DISPATCH
	XSFM T2			;GET FLAGS
	TXNE T1,TWUSR		;USER REFERENCE?
	TXO T2,PCU		;YES, SET PREVIOUS CONTEXT
	MOVEM T3,UPTPFN		;TRAPS WILL GO TO SPECIAL PLACE HEREIN
	HRRI T3,.+2
	XJRSTF T2		;SET PCU NOW
	TXZ T1,EXFLBT		;CLEAR EXTRANEOUS BITS
	CALL PRV1XC		;DO REFERENCE IN SECTION 1
	 MAP T1,0(T1)
	MOVEM T1,PT%PMA(Q2)	;SAVE FOR REPORT
	SETZM PT%TRY(Q2)	;CLEAR REPORTED RETRY COUNT
	DATAO PAG,SETBK7	;SET TO REFERENCE AC BLOCK 7
	UMOVE T1,BK7PFD		;GET BAD DATA
	DATAO PAG,SETMON	;RESTORE NORMAL AC BLOCK
	MOVEM T1,PT%BDW(Q2)	;SAVE BAD DATA FOR REPORT
	MOVE T1,FORKX		;SAVE USER INFO
	HRLOM T1,PT%JOB(Q2)

; THE KL10 EBOX CAN MAKE REQUESTS TO THE MBOX ON AN EPT OR UPT
; RELATIVE BASIS.  IF A PARITY ERROR OCCURS ON SUCH A REFERENCE
; THE PAGE FAIL WORD DOES NOT SHOW WHICH KIND OF REFERENCE WAS
; OCCURING.  IF PHYSICAL PAGE ZERO IS REFERENCED WE WILL CHECK
; WORDS IN THE EPT AND UPT FOR ERRORS.  IF ERRORS ARE PRESENT
; A BUGHLT WILL OCCUR.

	SETZM PT%EPD(Q2)	; ZERO OUT DATA CELLS
	SETZM PT%EPA(Q2)
	SETZM PT%UPD(Q2)
	SETZM PT%UPA(Q2)
	LOAD T1,VPGNO,PT%PFW(Q2) ; GET THE PAGE NUMBER...IS IT ZERO?
	JUMPN T1,PGMPE1		; NO SO IT CANT BE UPT OR EPT RELATIVE
	LOAD T1,PGWD,PT%PFW(Q2) ; GET THE LINE NUMBER IN THE PAGE
	TXO F,PFCPF3		; FLAG THAT WE ARE TOUCHING EPT WORD
	MOVE T2,KIEPT(T1)	; GET THE EPT OFFSET WORD
	TXZ F,PFCPF3		; RESET THE FLAG
	MOVEM T2,PT%EPD(Q2)	; SAVE THE EPT WORD
	MAP T2,KIEPT(T1)	; GET PHYSICAL ADDRESS OF THE EPT WORD
	MOVEM T2,PT%EPA(Q2)	; AND SAVE IT
	TXO F,PFCPF4		; FLAG THAT WE ARE TOUCHING UPT WORD
	MOVE T2,HWPTA(T1)	; GET THE UPT OFFSET WORD
	TXZ F,PFCPF4		; RESET THE FLAG
	MOVEM T2,PT%UPD(Q2)	; SAVE THE UPT DATA WORD
	MAP T2,HWPTA(T1)	; GET THE PHYSICAL ADDRESS
	MOVEM T2,PT%UPA(Q2)	; SAVE THE PHYSICAL ADDRESS
PGMPE1:

	;..
	;..

;Flush cache and turn it off

	MOVE Q1,CONOPG
	TXZN Q1,PGCLKE+PGCLDE	;CACHE ON?
	JRST PFCP4		;NO
	TXO F,PT%CCH		;YES, NOTE
	CCHUA			;UNLOAD IT
	CONSO APR,APSWPD	;WAIT FOR COMPLETION
	JRST .-1
	CONOAPR APFCLR+APSWPD	;CLEAR FLAG
	CONSZ APR,APMPE		;ERROR ON WRITE TO CORE?
	JRST [	TXO F,PT%ESW	;YES. REMEMBER THAT
		RDERA PI%ER2+MPISEB ;AND SAVE ERA AS WELL FOR SBUS CODE
		JRST .+1]
	CONO PAG,0(Q1)		;TURN CACHE OFF

;BEGIN RETRY ALGORITHM
;Retry with cache off.

PFCP4:	CALL PFCPRT		;RETRY REFERENCE WITHOUT CACHE
	 JRST PFCPH		;RETRIES FAILED, HARD IN CORE

	MOVEM T1,PT%GDW(Q2)	;SAVE GOOD DATA
	MOVEM T3,PT%TRY(Q2)	;AND SAVE RETRY COUNT

;If cache was on previously, turn it back on and retry the reference

	TXNN F,PT%CCH		;WERE USING CACHE?
	JRST PFCP2		;NO
	CONO PAG,PGCLKE(Q1)	;YES, TURN IT BACK ON
	CALL PFCPRT		;RETRY REFERENCE WITH CACHE
	 JRST PFCPHH		;RETRIES FAILED, HARD IN CACHE
	;..
	;..

;Here when error is recoverable. Either the memory retry succeeded and
;cache was off originally or both retries succeeded and cache was on
;Queue the SYSERR block and restore the context to continue

PFCP2:	HLLM F,PT%TRY(Q2)	;SAVE FLAGS
	CALL PFCPLG		;LOG INFO
	POP P,UPTPFL		;RESTORE PAGE FAIL VARIABLES
	POP P,UPTPFO
	POP P,UPTPFN
	MOVEI T1,ARBUG-BUGBUG	;GET PROPER INDEX FOR MESSAGE
	CALL GENBLK		;DO STATUS REPORT
	MOVE P,MEMAP		;RESTORE ORIGINAL STACK POINTER
	CONO PAG,@CONOPG	;RESTORE CACHE STATE
	TXNE F,PFCPF2		;RESTORE PI
	PION
	POP P,F
	RETSKP			;RETURN RECOVERABLE

;ROUTINE TO EXECUTE A PXCT IN SECTION 1 AND RETURN TO CURRENT SECTION
;Executes the instruction after the call.

;Returns: +2 always

PRV1XC:	EA.ENT			;ENTER SECTION 1
	MOVE CX,@0(P)		;GET INSTRUCTION TO DO
				; NOTE THIS IS DONE SINCE AN
				; XCTU @0(P) WOULD EXECUTE THE
				; TARGET INST IN THE SECTION OF THE
				; CALLING ROUTINE RATHER THAN
				; THE SECTION OF THE CURRENT PC
				; BOO HIS!
	XCTU CX			;DO IT IN SECTION 1
	RETSKP			;AND DONE

;Here if BUGHLT and want to type out MB parity error block
;	T2/ SYSERR BLOCK
;PIOFF, Secondary protocol

MBERRB:	SAVEQ
	MOVEI Q1,SEBDAT(T2)

;DO TYPEOUT OF PROCESSOR INFORMATION

	MOVEI T1,[SIXBIT '$$PARITY ERROR DETECTED BY /']
	TMNN APMPE,PI%CN2(Q1)
	MOVEI T1,[SIXBIT '$$SBUS ERROR DETECTED BY /']
	JSR BUGMSG
	MOVEI T1,[SIXBIT 'APR/']
	TMNE ER%CHN,PI%ER2(Q1)
	MOVEI T1,[SIXBIT 'CHANNEL/']
	JSR BUGMSG
	MOVEI T1,[SIXBIT ', ERA = /']
	JSR BUGMSG
	MOVE T1,PI%ER2(Q1)
	CALL BUGWPT
	MOVE T1,PI%SB2(Q1)		;GET SDBIAG WORD
	ADDI T1,0(Q1)			;ADD IN START IF BLOCK
	CALL PRISBS			;DO SBUS DIAGS AS WELL
	MOVEI T1,[SIXBIT '$$   LOC   CONTENTS$$/']
	JSR BUGMSG
	HRLI Q1,-PI%NB2		;SCAN BLOCK OF BAD ADDRESSES
	; ..

	; ..
;Now look at bad word and report on each of them

MBERR2: SKIPN T1,PI%BAD(Q1)	;HAVE AN ADDRESS?
	RET			;NO. ALL DONE THEN
	ANDX T1,<PHCPNO+PGWD>	;JUST USE ADDRESS BITS
	CALL BUGOP8
	MOVEI T1," "
	JSR BUGTYO
	MOVE T1,PI%DA2(Q1)	;GET BAD DATA
	CALL BUGWPT
	MOVEI T1," "
	JSR BUGTYO
	JN PI%FAT,PI%BAD(Q1),MBERR3 ;IF HARD NO GOOD DATA
	MOVE T1,PI%MDA(Q1)
	CALL BUGWPT
MBERR3:	MOVEI T1,[SIXBIT '$/']
	JSR BUGMSG
	AOBJN Q1,MBERR2		;DO ALL ADDRESSES
	RET

;HERE IF BADCPG WANTS TO BUGHLT. DO FORCE TYPE OUT OF AR/ARX INFO
;	T2/ SYSERR BLOCK

PFERRB:	SAVEQ
	MOVEI Q2,SEBDAT(T2)	;SAVE BLOCK ADDRESS
	MOVEI T1,[SIXBIT '$$AR OR ARX PARITY ERROR$PFW= /']
	JSR BUGMSG
	MOVE T1,PT%PFW(Q2)	;PF WORD
	CALL BUGWPT
	MOVEI T1,[SIXBIT ' MAP WORD= /']
	JSR BUGMSG
	MOVE T1,PT%PMA(Q2)	;MAP WORD
	CALL BUGWPT
	MOVEI T1,[SIXBIT '$BAD DATA= /']
	JSR BUGMSG
	MOVE T1,PT%BDW(Q2)
	CALLRET BUGWPT



;HERE IF ERROR REPEATABLE ON DIRECT REFERENCES TO CORE
;Queue the SYSERR entry, disable the page, and print a message on the CTY

PFCPH:	TXO F,PT%HRD		;NOTE HARD ERROR
	HLLM F,PT%TRY(Q2)	;SAVE FLAGS FOR REPORT

;Queue the SYSERR entry

	CALL PFCPLG		;LOG ERROR INFO
	LOAD T2,TWVADR,PT%PFW(Q2) ;SETUP TO REFERENCE BAD WORD AGAIN
	TXO F,PFCPF0		;NOTE CONTROLLED REFERENCE
;	CALL PRV1XC		;REF IT
;	 SETZM 0(T2)		;ZERO THE BAD WORD
	TXZ F,PFCPF0+PFCPF1
	POP P,UPTPFL		;RESTORE PAGE FAIL VARIABLES
	POP P,UPTPFO
	POP P,UPTPFN

	MOVEI T1,ARBUG-BUGBUG	;GET PROPER INDEX
	CALL GENBLK		;DO STATUS
	LOAD T1,PHCPNO,PT%PMA(Q2) ;GET PHYS PAGE NUMBER
	TXNE F,PFCPF2		;NON-PI CODE?
	MOVE P,MEMAP		;NO. RESTORE INCOMING STACK
	CONO PAG,@CONOPG	;RESTORE CACHE STATE
	NOSKD1
	TXNE F,PFCPF2		;RESTORE PI
	PION
	POP P,F

;Turn the page offline. This routine may BUGHLT if page is critical

	CALL BADCPG		;MARK CORE PAGE BAD
	OKSKD1			;ALLOW SCHEDULING
	RET			;AND DONE


;HERE IF ERROR REPEATABLE ONLY ON REFERENCES THROUGH CACHE
;Turn off the cache and continue

CCHEMX==3			;MAX CACHE ERRORS ALLOWED

PFCPHH:	CONO PAG,0(Q1)		;TURN CACHE OFF
	TXO F,PT%CCF+PT%HRD	;NOTE HARD CACHE ERROR
	AOS T1,CCHECT		;COUNT HARD CACHE ERRORS
	CAIGE T1,CCHEMX		;REACHED MAX?
	JRST PFCP2		;NO, CONTINUE
	BUG.(CHK,HARDCE,APRSRV,HARD,<Hard cache errors--cache deselected>,,<

Cause:	The hardware has detected an AR or ARX parity error that occurs
	only when an address is referenced through the cache. An attempt
	to reference the same address from memory with the cache turned
	off has succeeded. This has happened more than the allowable
	maximum number of times. The monitor will turn off the cache and
	proceed.
	
	The monitor has printed a description of the problem on the
	CTY and created a SYSERR block, which will be written into
	the SYSERR file.

Action:	The monitor will continue to run without the cache.
	However, when the front end reloads the monitor at some future
	time, the front end will enable the cache. Change its configuration
	file in order to avoid this until the cache is fixed.
>,,<DB%NND>)			;[7.1210]
	MOVEM Q1,CONOPG		;SET CACHE OFF
	JRST PFCP2		;CONTINUE

;LOCAL ROUTINE TO LOG ERROR INFORMATION

PFCPLG:	CONOAPR APFCLR+APNXM+APMPE ;CLEAR RESIDUAL FLAGS
	HLRZ T1,Q2		;GET PTR TO SYSERR BLK
	MOVE T2,[-NPFCPT,,PFCPT]
	CALL SEBCPY		;PUT IN CODE, ETC.
	 JFCL
	HLRZ T1,Q2
	CALLRET QUESEB		;QUEUE IT AND RETURN


;LOCAL RETRY ROUTINE
;RETURN +1: HARD FAILURE
;RETURN +2: RETRY SUCCEEDED,
;  T1/ GOOD DATA
;  T3/ NUMBER OF TRY WHICH WORKED (FIRST TRY = 1)
;  Q2/ ADDRESS OF SYSERR BLOCK

;This routine tries to reference data that previously caused an AR or ARX
;parity error. Caller has enabled or disabled cache. UPTPFN has been set up
;so that an error will call PFCPTP below. This routine sets the flag
;PFCPF0 in F to indicate it is retrying an error

PFCPRT:	MOVEI T3,1		;INIT RETRY COUNT
PFCPL1:
	LOAD T2,TWVADR,PT%PFW(Q2) ;GET VA OF ORIGINAL TRAP
	TXO F,PFCPF0		;NOTE TEST REFERENCE
	CALL PRV1XC		;DO THE REFERENCE
	 MOVE T1,0(T2)		;IN PROPER SECTION
	TXZ F,PFCPF0
	TXZN F,PFCPF1		;ANOTHER ERROR?
	RETSKP			;NO, RETURN SUCCESS
	CAIGE T3,4		;REACHED RETRY LIMIT?
	AOJA T3,PFCPL1		;NO
	RET			;YES, RETURN FAILURE

;PAGE FAIL TRAPS TO HERE WHILE PROCESSING MPE TRAPS
;PGMPE0 set UPTPFN to point here

PFCPTP:	TXNN F,PFCPF0		;DOING TEST REFERENCE?
	 BUG.(HLT,UNXMPE,APRSRV,HARD,<PFCDPE - Unexpected parity error trap>,<<T1,PFW>,<T2,PADR>>,<

Cause:	The monitor was processing an AR or ARX parity error when
	a second error occurred. The monitor retries the reference
	that caused the original error and is prepared to handle
	a second error. However, the BUGHLT indicates that the
	error occurred during the processing but not during the retry.

Data:	PFW - Page fail word
	PADR - Address of page fail
>) ; NO
	LOAD T1,TWCOD,UPTPFW	;YES, CHECK CODE
	CAIGE T1,PECOD0		;ANOTHER PARITY ERROR?
	BUG.(HLT,MPEUTP,APRSRV,HARD,<PFCDPE-Unknown trap on test reference>,,<

Cause:	The monitor was processing an AR or ARX parity error when a
	second error occurred. The monitor retries the reference that
	caused the original error and is prepared to handle a second
	error. However, the BUGHLT indicates that the second error
	(caused by the retry) was not an AR or ARX parity error and
	thus was not expected.
>)
	TXO F,PFCPF1		;YES, NOTE REFERENCE FAILED
	AOS UPTPFO		;SKIP FAILING INSTRUCTION
	XJRSTF UPTPFL		;RETURN

;HERE IF NXM CAUSED TRAP
;Jumped to from PGMPE0 if APNXM is set in CONI APR word.

PGNXM0:	CONOAPR APFCLR+APMPE	;CLEAR RESIDUAL FLAGS
	CONSZ PI,PIPION		;PI SYSTEM ON?
	BUG.(HLT,PRONX2,APRSRV,HARD,<NXM detected by processor>,,<

Cause:	A page fault occurred indicating that the processor
	attempted to access a memory that did not respond within
	a preset time. The monitor is presently running in
	process context. The interrupt system is on. Since
	non-existent memory also produces an APR interrupt,
	which results in an APRNX1 BUGHLT,
	this BUGHLT does not normally occur.

Action:	See APRNX1. Note, however, that the occurrence of this BUGHLT
	instead of APRNX1 may indicate a failure in the interrupt
	system.
>)
	AOS UPTPFO		;BYPASS FAILING INSTRUCTION
	RET

   >				;END OF IFN KLFLG
	SUBTTL KA floating point simulation

;SIMULATION ROUTINES FOR LONG-MODE FLOATING POINT ARITHMETIC
; (KA10-STYLE DOUBLE PRECISION)

	SWAPCD

;HERE WITH INSTRUCTION IN KIMUUO AND PREVIOUS CONTEXT SET UP

SDFN::	EA.ENT
	CALL GTARGS
	LSHC T2,11		;EXPONENT TO T2 (ISN'T CHANGED)
	SETCM T1,T1		;ONE'S COMPLEMENT THE HIGH WORD
	MOVN T3,T3		;TWO'S COMPLEMENT THE LOW WORD.
	SKIPN T3		;SKIP UNLESS LOW WORD IS ZERO
	ADDI T1,1		;TWO'S COMPLEMENT THE HIGH WORD
	LSHC T2,-11		;RESTORE OLD BITS 0-8
	XCTU [MOVEM T1,0(Q1)]	;HIGH PART TO AC
	XCTU [MOVEM T3,@KIMUEF]	;LOW PART TO E
	RET

;SUBROUTINE FOR ARGUMENT FETCH AND PREPARATION (EXTRACT EXPONENT, SIGN EXTEND)

GTARGS:	LDB Q1,[POINT 4,KIMUU1,30] ;GET AC FIELD OF INSTR
	XCTU [MOVE T1,0(Q1)]	;GET AC ARG
	XCTU [MOVE T3,@KIMUEF]	;GET (E)
	SETZB T2,T4		;CLEAR LOW PARTS
	RET

SFLGET:	XCTU [MOVE T2,@KIMUEF]	;FETCH C(E).
SFLGT1:	LDB Q1,[POINT 4,KIMUU1,30] ;GET AC FIELD OF INSTR
	XCTU [MOVE Q3,(Q1)]	;FETCH C(AC)
SFLGT2:	LDB Q2,[POINT 9,Q3,8]	;EXPONENT AND SIGN OF C(AC)
	LDB T1,[POINT 9,T2,8]	;EXPONENT AND SIGN OF C(E)
	TRNE Q2,400
	XORI Q2,777		;ONES COMPLEMENT OF NEGATIVE EXPONENT
	TRNE T1,400
	XORI T1,777
	SKIPL Q3		;SKIP IF C(AC) ARE NEGATIVE
	TLZA Q3,777000		;POSITIVE. EXTEND SIGN BIT
	TLO Q3,777000		;NEGATIVE. EXTEND SIGN
	SKIPL T2		;SKIP IF C(E) ARE NEGATIVE
	TLZA T2,777000		;POSITIVE. EXTEND SIGN BIT
	TLO T2,777000		;NEGATIVE. EXTEND SIGN
	RET

;SUBROUTINE FOR ADD/SUBTRACT TYPE OPERATIONS.  DENORMALIZE SMALLER ARGUMENT
SFAT3A:	CAML Q2,T1		;DECIDE WHICH EXPONENT IS LARGER
	JRST SFAT3B		;AND DO PRENORMALIZE (DENORMALIZE)
	EXCH Q2,T1		;INTERCHANGE OPERANDS
	EXCH Q3,T2		;SMALLER OPERAND INTO T1/T2/T3=0
SFAT3B:	SUB T1,Q2		;T1=SHIFT FACTOR (0 OR NEGATIVE)
	MOVEI T3,0		;FOR PEOPLE WHO WANT DOUBLE LENGTH
	CAMGE T1,[-100]		;ARE WE GOING TO LOSE ALL SIGNIFIGANCE?
	TDZA T2,T2		;YES.  T2=0 SKIP THE SHIFT
	ASHC T2,(T1)
	TRZ T3,177		;KA10 MAKES A 54 BIT RESULT
	ADD T2,Q3		;DOUBLE LENGTH RESULT TO T2/T3
	SKIPL T2		;POSITIVE OR NEGATIVE RESULT
	SKIPA Q3,[TLNN T2,1000]
	MOVE Q3,[TLNE T2,1000]
	XCT Q3			;SKIP IF ADD OVERFLOWED
	JRST SFAT3C		;NO OVERFLOW
	ASHC T2,-1		;ADD PRODUCED AN HIGH ORDER BIT.
	ADDI Q2,1		;SHIFT RESULT DOWN AND BUMP EXPONENT
SFAT3C:	TLZ T3,400000		;CLEAR SIGN BIT IN LOW WORD (SET BY ASHC)
	RET

SUFA::	EA.ENT
	CALL SFLGET		;FETCH AND SETUP ARGUMENTS
	CALL SFAT3A		;PRENORMALIZE AND DO THE ADD.
	CAIG Q2,377		;DID EXPONENT OVERFLOW?
	JRST SUFA1		;NO.
	MOVSI Q3,440200		;SET AROV, FOV, AND TRAP1
	IORM Q3,-1(P)		;STORE WHERE THEY'LL BE RESTORED.
SUFA1:	SKIPN T2		;SKIP IF RESULT NON ZERO.
	JUMPE T3,STORA1		;HIGH PART IS 0.  RETURN 0 IF LOW PART IS 0
	DPB Q2,[POINT 8,T2,8]	;STORE EXPONENT
	SKIPGE T2		;SKIP IF RESULT IS POSITIVE
	TLC T2,377000		;ONES COMPLEMENT TO EXPONENT
	MOVE T3,T2		;COPY RESULT TO T3 FOR STORA1
	JRST STORA1

SFADL::	EA.ENT
	CALL SFLGET		;FETCH AND PREPARE ARGUMENTS
	JRST SFADL0

SFSBL::	EA.ENT
	CALL SFLGET		;FETCH AND PREPARE ARGUMENTS
	MOVN T2,T2		;NEGATE C(E)
SFADL0:	CALL SFAT3A		;PRENORMALIZE AND DO ADD
;POSTNORMALIZE.  Q2= EXPONENT, T2--T3 ARE FRACTION
SFLNRM:	SKIPN T2		;Q2=EXPONENT. T2--T3 ARE FRACTION
	JUMPE T3,SFLSTR		;JUMP IF RESULT IS ZERO.  STORE RESULT
	SKIPL T2		;POSTNORMALIZE BY SHIFTING LEFT
	SKIPA T1,[TLNE T2,400]	;SKIP IF POSITIVE NUMBER IS UNNORMALIZED
	MOVE T1,[TLNN T2,400]	;SKIP IF NEGATIVE NUMBER IS UNNORMALIZED
SFLNR2:	XCT T1			;SKIP IF UNNORMALIZED
	JRST SFLNR3		;NORMALIZE COMPLETE
	ASHC T2,1		;SHIFT TO NORMALIZE
	SOJA Q2,SFLNR2		;DECREMENT EXPONENT. LOOP UNTIL DONE

SFLNR3:	JUMPGE T2,SFLN3A	;JUMP IF POSITIVE
	TDNE T2,[777,,-1]	;NEGATIVE.  SKIP IF NO SIGNIFICANCE
	JRST SFLN3A
	ASHC T2,-1		;GET THAT BIT BACK HERE
	ADDI Q2,1
SFLN3A:	TLZ T3,400000		;CLEAR SIGN BIT OF LOW WORD
	LSH T3,-10		;LEAVE ROOM IN LOW WORD FOR EXPONENT
	CAIGE Q2,400		;SKIP IF OVERFLOW
	JUMPGE Q2,SFLNR6	;JUMP UNLESS UNDERFLOW
	MOVSI T1,440200		;AROV, FOV, TRAP 1
	CAIL Q2,433		;DOES EXPONENT EXCEED 128+27?
	JRST SFLNR4		;YES.  STORE ZERO IN LOW WORD
	JUMPG Q2,SFLNR5
	TRNE Q2,200		;SOMETIMES THE KA10 FORGETS AN UNDERFLOW
	TLO T1,100		;SET FLOATING UNDERFLOW TOO.
SFLNR4:	MOVEI T3,0		;AND CLEAR LOW WORD.
SFLNR5:	IORM T1,-1(P)		;STORE FLAGS FOR USER.
SFLNR6:	HRREI Q3,-33(Q2)	;COMPUTE EXPONENT OF LOW PART
	SKIPGE Q3
	MOVEI T3,0		;ZERO LOW PART, IF EXPONENT TOO SMALL
	ANDI Q2,377		;TRUNCATE EXPONENT
	SKIPE T3		;SKIP IF LOW FRACTION IS ZERO
	DPB Q3,[POINT 9,T3,8]	;STORE LOW EXPONENT. CLEAR SIGN BIT.
	ROT Q2,-11		;SHIFT EXPONENT TO RIGHT PLACE
	XOR T2,Q2		;ONES COMPLEMENT OF EXP, IF NEGATIVE
SFLSTR:	XCTU [MOVEM T2,(Q1)]	;STORE DOUBLEWORD RESULT IN C(AC)
STORA1:	ADDI Q1,1		;AND IN C(AC+1 MOD 20)
	ANDI Q1,17
	XCTU [MOVEM T3,(Q1)]
	RET

SFMPL::	EA.ENT
	CALL SFLGET		;FETCH AND PREPARE ARGUMENTS
	MUL T2,Q3		;DOUBLE WORD PRODUCT TO T2/T3
	ADD Q2,T1		;Q2=EXPONENT OF RESULT
	SUBI Q2,200		;ACCOUNT FOR EXCESS 200 IN EXPONENTS
	ASHC T2,10		;RESULT OF MULTIPLY IS TOO FAR RIGHT BY 8
				;PLACES (NOT 9 SINCE BIT 0 OF T3 IS SIGN)
	TLZ T3,400000		;FLUSH SIGNBIT
	JRST SFLNRM		;DO POSTNORMALIZE

SFDVL::	EA.ENT
	LDB Q1,[POINT 4,KIMUU1,30] ;GET AC FIELD OF INSTR
	XCTU [MOVE T2,(Q1)]	;FETCH C(AC)
	MOVEI T3,1(Q1)
	ANDI T3,17
	XCTU [MOVE T3,(T3)]	;FETCH C(AC+1)
	SKIPN T2		;IF DIVIDING ZERO
	JUMPE T3,SFLSTR		; WITHOUT FURTHER ADO, STORE ZERO
	XCTU [MOVE Q3,@KIMUEF]	;FETCH C(E).
	LSH T3,10		;FLUSH EXPONENT FROM LOW WORD
	TLZ T3,400000		;FLUSH SIGNBIT FROM LOW WORD
	CALL SFLGT2		;SETUP EXPONENTS, ETC
SFDVL1:	MOVEI T4,0		;ASSUME BOTH ARGUMENTS ARE POSITIVE
	JUMPGE T2,SFDVL2	;JUMP IF DIVIDEND IS POSITIVE
	SETCA T2,		;DIVIDEND IS NEGATIVE.  TAKE TWOS COMPLEMENT
	MOVN T3,T3		;OF THE DOUBLE WORD (THIS SHOULD BE DMOVN
	SKIPN T3		;EXCEPT, WE HAVE TO RUN THIS ON THE KA10 TO
	ADDI T2,1		;VERIFY IT).
	MOVSI T4,600000		;QUOTIENT AND REMAINDER ARE NEGATIVE
SFDVL2:	JUMPGE Q3,SFDVL3	;JUMP IF DIVISOR IS POSITIVE
	MOVN Q3,Q3
	TLC T4,400000		;COMPLEMENT SIGN OF QUOTIENT
SFDVL3:	CAMGE T2,Q3		;IS QUOTIENT GREATER THAN 1.0?
	JRST SFDVL4		;NO.
	ASHC T2,-1		;YES.  TRY A 1 BIT SHIFT
	CAML T2,Q3		;DID THAT FIX IT?
	JRST SFDVLX		;NO. WE HAVE A NO-DIVIDE CONDITION
	ADDI T1,1		;ADJUST EXPONENT OF DIVIDEND
SFDVL4:	TLNN Q3,1000		;ONLY CRETINS DIVIDE BY "SETZ"
	JRST SFDVL6
	LSH Q3,-1		;BUT TO KEEP THEM HAPPY...
	ADDI Q2,1
SFDVL6:	SUBM T1,Q2		;Q2=EXPONENT OF QUOTIENT
	ADDI Q2,200		;MAKE EXPONENT INTO EXCESS 200.
	LSH Q3,10		;SCALE DIVISOR TO ALLOW ONLY 27 DIVIDE STEPS
	DIV T2,Q3		;T2=QUOTIENT, T3=REMAINDER
	JUMPE T2,SFDVL9		;IF QUOTIENT IS ZERO, DON'T NORMALIZE
SFDVL8:	TLNE T2,400		;NOW, NORMALIZE THE QUOTIENT
	JRST SFDVL9
	LSH T2,1		;BEFORE COMPUTING OVERFLOW CONDITION
	SOJA Q2,SFDVL8

SFDVL9:	CAIGE Q2,400		;OVERFLOW?
	JUMPGE Q2,SFDVL7	;NO.  JUMP UNLESS UNDERFLOW
	MOVSI Q3,440200		;AROV, FOV, TRAP 1
	JUMPGE Q2,SFDVL5
	TRNE Q2,200		;SOMETIMES THE KA10 FORGETS FXU
	TLO Q3,100		;FXU
SFDVL5:	IORM Q3,-1(P)
	ANDI Q2,377
SFDVL7:	SKIPE T2		;AVOID STORING EXPONENT IN A ZERO FRACTION
	DPB Q2,[POINT 9,T2,8]	;STUFF EXPONENT
	TLNE T4,400000		;SHOULD QUOTIENT BE NEGATIVE?
	MOVN T2,T2		;YES.
	SUBI T1,33		;CALCULATE EXPONENT OF REMAINDER
	SKIPGE T1		;IF UNDERFLOW, SET REMAINDER TO ZERO
	MOVEI T3,0
	JUMPE T3,SFLSTR		;IF ZERO REMAINDER, STORE ZERO
	LSH T3,-10		;MAKE ROOM FOR EXPONENT
	DPB T1,[POINT 8,T3,8]	;STUFF EXPONENT
	TLNE T4,200000		;SHOULD WE NEGATE REMAINDER?
	MOVN T3,T3
	JRST SFLSTR		;STORE AC, AC+1


SFDVLX:	MOVSI T3,440240		;AROV, FOV, NO DIVIDE, TRAP1
	IORM T3,-1(P)
	RET
	SUBTTL Gfloat to Integer Conversion Simulation Routines

   IFN KLFLG,<
.DGFXR:				;GFLT TO DOUBLE INTEGER ROUNDED
	MOVX T4,GFLT%2		;SET THE DOUBLE AC FLAG
	CALL DGFXR0		;GO TO COMMON CODE
	JUMPG T3,DGFXR1		;IF SHIFT POSITIVE THEN SHIFT LEFT
	CAMG T3,[-^D70]		;SHIFT INSTS ARE MOD 256 SO REDUCE
	MOVNI T3,^D70		;EXPONENT IF ITS TOO LARGE
	ASHC T1,1(T3)		;SHIFT ROUNDING BIT INTO RIGHTMOST OF T2
	DADD T1,[EXP 0,1]	;ROUND
	ASHC T1,-1		;SHIFT ROUNDING BIT OUT
	RET			;RETURN TO CALLER

DGFXR1:	CAILE T3,^D11		;CHECK EXPONENT SIZE
	JRST DGFXR3		;TOO BIG THEN OVERFLOW
DGFXR2:	ASHC T1,(T3)		;SHIFT LEFT NO ROUNDING
	RET			;RETURN TO CALLER

DGFXR3:	CAIN T3,^D12		;CHECK FOR LARGEST NEGATIVE INTEGER
	IFL. T1
	  CAMN T1,[777740000000]
	  JUMPE T2,DGFXR2 	;LET THAT ONE THROUGH
	ENDIF.
DGFXR4:	TXO T4,GFLT%O		;SET THE OVERFLOW FLAG
	RET			;AND RETURN TO CALLER

DGFXR0:				;COMMON CODE FOR DGFIXR AND DFIXR
	LDB T3,[POINT 11,T1,11]	;GET THE EXPONENT
	TLNE T1,(1B0)		;PROPAGATE SIGN THROUGH EXPONENT BITS
	TLOA T1,777700		;NEGATIVE SET TO ONES
	TLZA T1,777700		;POSITIVE SET TO ZEROES
	TRC T3,3777		;UNCOMPLEMENT EXPONENT IF NEGATIVE
	SUBI T3,2000+^D59	;GET SHIFT VALUE TO ALIGN INTEGER PART
	RET			;RETURN TO CALLER

.GFXR:				;GFLOAT TO SINGLE INTEGER ROUNDED
	SETZ T4,		;RESET FLAG AC
	CALL DGFXR0		;GO TO COMMON CODE
	JUMPG T3,DFXR1		;IF SHIFT COUNT POSITIVE GO SHIFT LEFT
	CAMG T3,[-^D70]		;SHIFT INSTS ARE MOD 256 SO REDUCE
	MOVNI T3,^D70		;NEW EXPONENT IF IT WAS TOO LARGE
	ASHC T1,1(T3)		;SHIFT ROUNDING BIT INTO T2
	DADD T1,[EXP 0,1]	;ROUND
	ASHC T1,-1		;SHIFT ROUNDING BIT OUT
	JRST DFXR3		;GO CONVERT TO SINGLE INTEGER

DFXR1:	CAILE T3,^D11		;CHECK EXPONENT SIZE
	JRST DGFXR4		;GO DO OVERFLOW STUFF
DFXR2:	ASHC T1,(T3)		;SHIFT LEFT NO ROUNDING NEEDED
DFXR3:	CAME T1,[-1]		;HIGH WORD MUST BE ALL SIGN BITS
	JUMPN T1,DGFXR4		;IF IT ISNT THEN OVERFLOW
	MOVE T1,T2		;GET WORD INTO CORRECT AC
	RET			;RETURN TO CALLER

.GFX:				;GFLOAT TO SINGLE INTEGER
	SETZ T4,		;RESET FLAG AC
	PUSH P,T1		;SAVE ORIGINAL SIGN
	SKIPGE T1		;IS NUMBER POSITIVE?
	DMOVN T1,T1		;NO...GET ABSOLUTE VALUE
	LDB T3,[POINT 11,T1,11]	;GET THE EXPONENT
	TLZ T1,777700		;CLEAR EXPONENT FROM NUMBE
	SUBI T3,2000+^D59	;GET SHIFT AMOUNT TO ALIGN INTEGER PART
	CAMG T3,[-^D70]		;SHIFT INSTS ARE MOD 256 SO REDUCE
	MOVNI T3,^D70		;EXPONENT IF ITS LARGE
	CAILE T3,^D11		;CHECK EXPONENT SIZE
	JRST GFX2		;TOO BIG...OVERFLOW
	ASHC T1,(T3)		;SHIFT FRACTION OFF
	SKIPGE 0(P)		;CHECK ORIGINAL SIGN
	DMOVN T1,T1		;IF NEGATIVE COMPLEMENT RESULT
	TLNE T1,(1B0)		;COPY HIGH SIGN INTO LOW WORD
	TLO T2,(1B0)
	CAME T1,[-1]		;HIGH WORD MUST BE ALL SIGN  BITS
	JUMPN T1,GFX2		;ELSE OVERFLOW
	MOVE T1,T2		;PUT RESULT INTO PROPER AC FOR RETURN
GFX1:	ADJSP P,-1		;FIX STACK
	RET			;AND RETURN TO CALLER

GFX2:	TXO T4,GFLT%O		;HERE ON OVERFLOW...SET THE FLAG
	JRST GFX1		;AND RETURN TO USER

.DGFX:				;GFLOAT TO DOUBLE INTEGER
	MOVX T4,GFLT%2		;SET THE TWO ACS FLAG
	PUSH P,T1		;SAVE THE ORIGINAL SIGN
	JUMPGE T1,DGFX1		;IS NUMBER POSITIVE?
	DMOVN T1,T1		;NO...SO GET ABSOLUTE VALUE
	CAMN T1,[210740000000]	;CHECK FOR -2^70
	JUMPE T2,DGFX5		;IT IS SPECIAL SO HANDLE IT
DGFX1:	LDB T3,[POINT 11,T1,11]	;GET THE EXPONENT
	TLZ T1,777700		;CLEAR THE EXPONENT FIELD
	SUBI T3,2000+^D59	;GET SHIFT AMOUNT TO ALIGN INTEGER PART
	CAMG T3,[-^D70]		;SHIFT INSTS ARE MOD 256
	MOVNI T3,^D70		;REDUCE EXPONENT IF IT IS LARGE
	CAILE T3,^D11		;CHECK EXPONENT SIZE
	JRST DGFX4		;TOO BIG SO OVERFLOW
	ASHC T1,(T3)		;SHIFT FRACTION OFF
	SKIPGE 0(P)		;CHECK ORIGINAL SIGN
	DMOVN T1,T1		;IF NEGATIVE THEN COMPLEMENT
	TLNE T1,(1B0)		;COPY HIGH SIGN INTO LOW WORD
	TLO T2,(1B0)
DGFX2:	ADJSP P,-1		;FIX UP THE STACK
	RET			;AND RETURN TO CALLER

DGFX4:	TXO T4,GFLT%O		;SET THE OVERFLOW FLAG
	JRST DGFX2		;AND RETURN

DGFX5:	MOVSI T1,(1B0)		;-2^70 SPECIAL CASE
	MOVE T2,T1
	JRST DGFX2		;AND GO RETURN
  >				;END OF IFN KLFLG
	SUBTTL METER JSYS

;METER JSYS FOR KL ONLY

.METER::MCENT			;DO ENTRY STUFF
   IFE KLFLG,<
	MOVEI T1,METRX1
	ITERR>			;IF NOT A KL, ERROR
   IFN KLFLG,<			;FOR THE KL
	SKIPLE T1		;CHECK FOR VALID FUNCTION
	CAILE T1,METMFC		;STILL?
	ITERR (ARGX02)		;NO.
	XCT MTRTBL-1(T1)	;DO FUNCTION
	XCTU [DMOVEM T1,2]	;RETURN DATA
	MRETNG			;AND DONE

;FUNCTION TABLE

MTRTBL:	RDEACT T1		;GET EBOX TICKS
	RDMACT T1		;GET MBOX TICKS
METMFC==.-MTRTBL		;MAX FUNCTION
   >				;END OF IFN KLFLG CONDITIONAL

	RESCD
	SUBTTL End of APRSRV

	TNXEND
	END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     