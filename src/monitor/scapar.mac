; Edit= 8810 to SCAPAR.MAC on 24-Mar-88 by RASPUZZI
;Increase the size of the SCA ring buffer.
; UPD ID= 8613, RIP:<7.MONITOR>SCAPAR.MAC.8,  11-Feb-88 18:29:07 by GSCOTT
;TCO 7.1218 - Update copyright date.
; UPD ID= 182, RIP:<7.MONITOR>SCAPAR.MAC.7,  21-Oct-87 17:19:04 by RASPUZZI
;TCO 7.1076 - Add CLUINI to initialization table and also, make CLUPRI
;             be priority for CLUDGR when sending messages.
; UPD ID= 165, RIP:<7.MONITOR>SCAPAR.MAC.6,  19-Oct-87 17:16:33 by LOMARTIRE
;TCO 7.1072 - Put EQSINI in SYSAP initialization table (INITAB)
; UPD ID= 119, RIP:<7.MONITOR>SCAPAR.MAC.5,  21-Sep-87 15:50:48 by RASPUZZI
;TCO 7.1060 - Correct idosyncrosy in PHYKLP by making C%MUDA be 1 less.
; UPD ID= 90, RIP:<7.MONITOR>SCAPAR.MAC.4,  21-Aug-87 17:31:41 by MCCOLLUM
;TCO 7.1043 - SCSJSY is now in XCDSEC, Fix up references to SCSJSY symbols.
; UPD ID= 77, RIP:<7.MONITOR>SCAPAR.MAC.3,  12-Aug-87 14:50:52 by MCCOLLUM
;TCO 7.1037 - Fix up for SCAMPI's move to XCDSEC. Change CIOFF macro, etc.
; UPD ID= 16, RIP:<7.MONITOR>SCAPAR.MAC.2,   3-Jun-87 10:55:25 by RASPUZZI
;TCO 7.1009 - Add C%MUDA.
; UPD ID= 2281, SNARK:<6.1.MONITOR>SCAPAR.MAC.120,  25-Jun-85 15:06:49 by GRANT
;TCO 6.1.1473 - Add PKMAI and PKTYP
; UPD ID= 2179, SNARK:<6.1.MONITOR>SCAPAR.MAC.119,   5-Jun-85 11:01:26 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 1595, SNARK:<6.1.MONITOR>SCAPAR.MAC.118,   6-Mar-85 07:21:54 by HAUDEL
;TCO 6.1.1232 - Make connection management symbols reference Monsym.
; UPD ID= 1517, SNARK:<6.1.MONITOR>SCAPAR.MAC.117,  13-Feb-85 12:59:53 by LOMARTIRE
;TCO 6.1.1196 - Fix calculation of C%STIM
; UPD ID= 1454, SNARK:<6.1.MONITOR>SCAPAR.MAC.116,   1-Feb-85 14:20:51 by LOMARTIRE
;Add new symbols to describe the priority used by each SYSAP
; UPD ID= 1060, SNARK:<6.1.MONITOR>SCAPAR.MAC.115,  13-Nov-84 09:06:49 by LOMARTIRE
;Define new priority symbols KLPHI, KLPMED, KLPLOW, KLPDEG
;These replace KLPPR0, KLPPR1, KLPPR2, KLPPR3
;Remove special .MPxxx definitions used in SCAMPI
; UPD ID= 4998, SNARK:<6.MONITOR>SCAPAR.MAC.114,  24-Oct-84 20:03:28 by GRANT
;Add SCAVER
; UPD ID= 4956, SNARK:<6.MONITOR>SCAPAR.MAC.113,  18-Oct-84 14:49:18 by GRANT
;Add .RDNNM to Configuration Data Returned.
;Add .SBNNM to System Block and fix .SBHWV.
;Fix .SRNNM definition.
; UPD ID= 4869, SNARK:<6.MONITOR>SCAPAR.MAC.112,  24-Sep-84 16:14:44 by GRANT
;Add .PKxxx for READ-COUNTERS packet
; UPD ID= 4832, SNARK:<6.MONITOR>SCAPAR.MAC.111,  17-Sep-84 11:21:50 by PURRETTA
;Update copyright notice
; UPD ID= 4694, SNARK:<6.MONITOR>SCAPAR.MAC.110,  15-Aug-84 16:53:24 by CDUNN
;Add vector for .SSRPS (SCSRPS) to function table.  
;
; UPD ID= 4672, SNARK:<6.MONITOR>SCAPAR.MAC.109,  10-Aug-84 17:13:38 by CDUNN
;Temporarily add IDPAO and IDPBO MSKSTRs for getting data from RIDSTS. Someday
;these definitions should be moved from PHYKLP.
;
; UPD ID= 4657, SNARK:<6.MONITOR>SCAPAR.MAC.108,   7-Aug-84 16:15:30 by CDUNN
;Change documentation of .SSPBC callback
;
;Add definition of SCSTXN/SCSBXN entry. Also update the table of contents 
;
; UPD ID= 4592, SNARK:<6.MONITOR>SCAPAR.MAC.106,  26-Jul-84 22:26:06 by CDUNN
;Remove SINNCO. Remove "delete previous entry" flag from (.METYP). Also, bump
;C%PBCL by one so the data gets transfered.
;
; UPD ID= 4578, SNARK:<6.MONITOR>SCAPAR.MAC.105,  23-Jul-84 09:26:27 by GRANT
;Change defintions of PS.NRB, PS.NRA, and PS.NRE to include the error bit
;
; UPD ID= 4500, SNARK:<6.MONITOR>SCAPAR.MAC.104,  12-Jul-84 19:55:47 by LOMARTIRE
;Rearrange and improve documentation of callbacks.
;Remove .SSCBD, .SSMNT, and .SSNWO and add .SSDDG callbacks.
;Update table of contents.
;
; UPD ID= 4452, SNARK:<6.MONITOR>SCAPAR.MAC.103,  12-Jul-84 08:41:08 by HALL
;Add PPD byte type 6 to the list, and define the maximum value
;
; UPD ID= 4427, SNARK:<6.MONITOR>SCAPAR.MAC.102,   3-Jul-84 14:28:59 by LOMARTIRE
;Remove obsolete and unwanted DEFSTRs from connect and system blocks.
;Fix definitions of SC.RCD data block.
;Remove name SBDESW since it refers to a two word entity.
;
; UPD ID= 4416, SNARK:<6.MONITOR>SCAPAR.MAC.101,   2-Jul-84 10:44:10 by GRANT
; Add PS.CLO, PS.AKA, PS.NKA, PS.NOA, PS.AKB, PS.NKB, and PS.NOB
;
; UPD ID= 4411, SNARK:<6.MONITOR>SCAPAR.MAC.100,   2-Jul-84 07:16:57 by GRANT
;Add SBNTC, SBOKO, and SBWFI to system block
;
; UPD ID= 4383, SNARK:<6.MONITOR>SCAPAR.MAC.99,  25-Jun-84 09:21:17 by LOMARTIRE
;Various changes to ring buffer definitions
;
; UPD ID= 4320, SNARK:<6.MONITOR>SCAPAR.MAC.98,  11-Jun-84 10:47:03 by LOMARTIRE
;Fix definitions of SC.CSP data block
;
; UPD ID= 4315, SNARK:<6.MONITOR>SCAPAR.MAC.97,  11-Jun-84 09:56:24 by HAUDEL
;ADD CDNPW,HDNPW. CHANGE TWO COMMENTS.
; UPD ID= 4288, SNARK:<6.MONITOR>SCAPAR.MAC.96,   4-Jun-84 11:06:26 by HAUDEL
;Add defintions for the Map Descriptor Block, error codes in the Status
;field, and the IDREC Port Functionality word.
; UPD ID= 4287, SNARK:<6.MONITOR>SCAPAR.MAC.95,   2-Jun-84 13:12:22 by HALL
;Add a few bits to the connection block flags word
; UPD ID= 4283, SNARK:<6.MONITOR>SCAPAR.MAC.94,   1-Jun-84 12:20:57 by LOMARTIRE
;Rename CBDSBI to CBDNOD, CDSBI to CDNOD, remove .SBSBI and update pictures.
;
; UPD ID= 4246, SNARK:<6.MONITOR>SCAPAR.MAC.93,  25-May-84 13:47:37 by HALL
;Add 2 words to the connection block
; UPD ID= 4198, SNARK:<6.MONITOR>SCAPAR.MAC.92,   9-May-84 13:18:40 by LOMARTIRE
;Make .CMNxx codes reflect the spec's design for rejection/disconnection 
;reason codes.  Remove .UCxxx and .RJNOM reason codes.
;Add .CMNDS and .CMNRV reason codes and redefine values of others to conform
;to spec.  Update table of contents.
; UPD ID= 4181, SNARK:<6.MONITOR>SCAPAR.MAC.91,   8-May-84 14:03:52 by CDUNN
;Add maximum packet size symbols. (C%MXDP and C%MXMP)
;
; UPD ID= 4153, SNARK:<6.MONITOR>SCAPAR.MAC.90,  30-Apr-84 15:07:16 by HAUDEL
;Add PS.IBN (Invalid Buffer Name) error definition.
;
; UPD ID= 4148, SNARK:<6.MONITOR>SCAPAR.MAC.89,  30-Apr-84 11:24:48 by HAUDEL
;Add .PKBNM definition for the Close Buffer command.
;
; UPD ID= 4137, SNARK:<6.MONITOR>SCAPAR.MAC.88,  25-Apr-84 13:05:18 by LOMARTIRE
;Remove all .SCFxx error codes as they are replaced by SCSxxx error codes
;
; UPD ID= 4109, SNARK:<6.MONITOR>SCAPAR.MAC.87,  23-Apr-84 18:36:14 by CDUNN
;Add definition of packet header sizes in both words and bytes
;
; UPD ID= 4086, SNARK:<6.MONITOR>SCAPAR.MAC.86,  17-Apr-84 08:32:38 by LOMARTIRE
;Rearrange connect block and update picture.
;Remove work queue header since it is no longer used.
;Add comments to each ring buffer feature routine picture.
;
; UPD ID= 4053, SNARK:<6.MONITOR>SCAPAR.MAC.85,   5-Apr-84 16:05:38 by LOMARTIRE
;Make common symbols between SCAPAR and MONSYM refer to the MONSYM ones.
;This includes the connection state definitions, and the MD%ILL symbol.
;
; UPD ID= 3993, SNARK:<6.MONITOR>SCAPAR.MAC.84,  28-Mar-84 10:02:45 by MCLEAN
;PUT BH.PRE BACK AGAIN IT GOT LOST
;
; UPD ID= 3991, SNARK:<6.MONITOR>SCAPAR.MAC.83,  28-Mar-84 01:13:01 by CDUNN
;Add functions .SSGLN and .SSRBS to the SCS% function handler table
;
; UPD ID= 3980, SNARK:<6.MONITOR>SCAPAR.MAC.82,  27-Mar-84 07:31:19 by GRANT
;Add PF.CPE and .PKUCD
;
; UPD ID= 3952, SNARK:<6.MONITOR>SCAPAR.MAC.80,  21-Mar-84 12:44:00 by LOMARTIRE
;Add documentation of feature specific data for the following ring entries:
; SYSAP to SCA, SCA to SYSAP, PI transitions, Packet transactions
;Add CBSWRD structure name to refer to the entire .CBSTS word
;Update table of contents
;
; UPD ID= 3939, SNARK:<6.MONITOR>SCAPAR.MAC.79,  18-Mar-84 09:10:44 by HALL
;Squeeze CBNPO to a half word. Put CBRCNT in other half.
;
; UPD ID= 3919, SNARK:<6.MONITOR>SCAPAR.MAC.78,  13-Mar-84 17:26:19 by HALL
;Add new bit in connection block
;
; UPD ID= 3909, SNARK:<6.MONITOR>SCAPAR.MAC.77,  12-Mar-84 16:27:02 by LOMARTIRE
;Add definitions for new ring buffer
;
; UPD ID= 3905, SNARK:<6.MONITOR>SCAPAR.MAC.76,  12-Mar-84 15:48:04 by HAUDEL
;
; UPD ID= 3876, SNARK:<6.MONITOR>SCAPAR.MAC.75,   7-Mar-84 19:33:05 by CDUNN
;Add .JBUFF to the queue header blocks (for packets only).
;
; UPD ID= 3860, SNARK:<6.MONITOR>SCAPAR.MAC.74,   6-Mar-84 13:53:27 by GRANT
;New PCB format.  Add DEFSTRs SRMDG and SRMMG.
;
; UPD ID= 3842, SNARK:<6.MONITOR>SCAPAR.MAC.73,   3-Mar-84 16:35:48 by HALL
;Updated block states to match corporate spec
;ADD .SBOBB to system block
;Add .CBBUF, .CBNWQ, and CBEXPR to connection block
;
; UPD ID= 3789, SNARK:<6.MONITOR>SCAPAR.MAC.72,  28-Feb-84 15:23:56 by HAUDEL
;Change Performance Counter for new format.
;
; UPD ID= 3756, SNARK:<6.MONITOR>SCAPAR.MAC.71,  25-Feb-84 16:55:46 by HALL
;Fix length of system block (it wasn't updated when .SBSST was added)
;Add bit SBFOFL to be set when node is reported offline
;
; UPD ID= 3752, SNARK:<6.MONITOR>SCAPAR.MAC.70,  25-Feb-84 07:58:58 by HALL
;Add bit for v.c. closed
;New connection states
;
; UPD ID= 3718, SNARK:<6.MONITOR>SCAPAR.MAC.69,  21-Feb-84 13:25:58 by LOMARTIRE
;Modify the structure names for the working queue header
;
; UPD ID= 3715, SNARK:<6.MONITOR>SCAPAR.MAC.68,  21-Feb-84 13:03:08 by CDUNN
;Remove old C%xxxx definitions. Also add word length definitions for process
;names and connection data.
;
; UPD ID= 3703, SNARK:<6.MONITOR>SCAPAR.MAC.67,  20-Feb-84 10:08:38 by HAUDEL
;Correct Performance Counter Parameter.
;
; UPD ID= 3685, SNARK:<6.MONITOR>SCAPAR.MAC.66,  11-Feb-84 05:52:59 by GRANT
;Add field definitions for contents of PCB error words
;
; UPD ID= 3682, SNARK:<6.MONITOR>SCAPAR.MAC.65,  10-Feb-84 14:38:27 by LOMARTIRE
;Clean up structure definitions for system block.
;Remove all unwanted structures so that the full word is always used.
;
; UPD ID= 3672, SNARK:<6.MONITOR>SCAPAR.MAC.64,   8-Feb-84 12:18:17 by LOMARTIRE
;Add some structure definitions for message header locations
;
; UPD ID= 3620, SNARK:<6.MONITOR>SCAPAR.MAC.63,   1-Feb-84 13:05:25 by GRANT
;Add SRMBZ field to .SRRSV
;
; UPD ID= 3619, SNARK:<6.MONITOR>SCAPAR.MAC.62,   1-Feb-84 12:53:32 by GRANT
;Not enough 11-land in previous edit
;
; UPD ID= 3618, SNARK:<6.MONITOR>SCAPAR.MAC.61,   1-Feb-84 11:48:18 by GRANT
;Add SRVRS field to .SRRSV offset in START datagram
;
; UPD ID= 3599, SNARK:<6.MONITOR>SCAPAR.MAC.60,  31-Jan-84 12:23:48 by LOMARTIRE
;Add warnings about MSKSTR changes which could cause interlock problems
; These definitions will be marked as "*** Not to be changed ***"
;
; UPD ID= 3588, SNARK:<6.MONITOR>SCAPAR.MAC.59,  30-Jan-84 07:21:08 by GRANT
;Add KLPPR0, KLPPR1, KLPPR2, and KLPPR3 - symbols for packet sending priority
;
; UPD ID= 3586, SNARK:<6.MONITOR>SCAPAR.MAC.58,  29-Jan-84 06:52:50 by GRANT
;DEFSTR PKSRB for the entire software response bits field
;
; UPD ID= 3572, SNARK:<6.MONITOR>SCAPAR.MAC.57,  28-Jan-84 01:36:58 by MCLEAN
;ALSO FIX A LEFT OVER REFERENCE TO CBDGB
;REMOVE ALL P1 REFERENCES
;
; UPD ID= 3491, SNARK:<6.MONITOR>SCAPAR.MAC.56,  20-Jan-84 11:10:20 by CDUNN
;More TCO 6.1127 - Fix monument for PPD header. Also add a word to the
;SCA work queue entry to support buffer deferal.
;
; UPD ID= 3462, SNARK:<6.MONITOR>SCAPAR.MAC.55,  16-Jan-84 11:48:13 by GRANT
;Add .SRNNM to START packet definition
;
; UPD ID= 3441, SNARK:<6.MONITOR>SCAPAR.MAC.54,  12-Jan-84 10:15:21 by HAUDEL
;Add some performance counter definitions.
;
; UPD ID= 3439, SNARK:<6.MONITOR>SCAPAR.MAC.53,  12-Jan-84 08:12:25 by GRANT
;Add .SRRSV to START packet definition
;
; UPD ID= 3436, SNARK:<6.MONITOR>SCAPAR.MAC.52,  11-Jan-84 16:47:55 by GRANT
;Add PP.ERP - PPD byte 5 (error packet)
;
; UPD ID= 3371, SNARK:<6.MONITOR>SCAPAR.MAC.51,  27-Dec-83 08:11:57 by GRANT
;Add DEFSTRs for software fields in .PKVRT
;
; UPD ID= 3323, SNARK:<6.MONITOR>SCAPAR.MAC.50,  14-Dec-83 17:33:35 by MOSER
;TCO 6.1562 - START RUNNING THE MSCP SERVER SYSAP
;
; UPD ID= 3314, SNARK:<6.MONITOR>SCAPAR.MAC.49,  14-Dec-83 06:08:35 by GRANT
;Move VC.xxx to MONSYM
;
; UPD ID= 3302, SNARK:<6.MONITOR>SCAPAR.MAC.48,  13-Dec-83 13:16:32 by CDUNN
;More TCO 6.1127 - Fix the SC.MAP descriptor block definitions
;
; UPD ID= 3293, SNARK:<6.MONITOR>SCAPAR.MAC.47,  12-Dec-83 11:05:38 by HAUDEL
;Change field width of SETCNT's PORT field to 10(octal).
;
; UPD ID= 3290, SNARK:<6.MONITOR>SCAPAR.MAC.46,  11-Dec-83 20:20:57 by GRANT
;System Block - add .SBSST and eliminate .SBPST;  define states VC.CLO, VC.STS,
;VC.STR, and VC.OPN for .SBVCS.
;Add PS.PAE, PS.PBE, PS.NRA, PS.NRB, PS.NRE, CK.PBA, and CK.PAA.
;
; UPD ID= 3280, SNARK:<6.MONITOR>SCAPAR.MAC.45,   8-Dec-83 13:51:08 by CDUNN
;More TCO 6.1127 - Fix C%SYMX, again...
;
; UPD ID= 3265, SNARK:<6.MONITOR>SCAPAR.MAC.44,   6-Dec-83 14:58:47 by CDUNN
;More TCO 6.1127 - Fix engineer brain damage. Fix SECMSK to be in the left
;half, not the right half.
;
; UPD ID= 3254, SNARK:<6.MONITOR>SCAPAR.MAC.43,   5-Dec-83 19:15:54 by CDUNN
;More TCO 6.1127 - Fix C%SYMX. Add support for maintainance data sends at JSYS
;level.
;
; UPD ID= 3235, SNARK:<6.MONITOR>SCAPAR.MAC.42,  30-Nov-83 15:26:47 by HAUDEL
;Change/Remove bits for Start Remote System
;
; UPD ID= 3184, SNARK:<6.MONITOR>SCAPAR.MAC.41,  17-Nov-83 16:17:36 by CDUNN
;More TCO 6.1127 - Remove unused definitions before they get used again. Also
;add C%FLGM to define mask for all SCA flags
;
; UPD ID= 2940, SNARK:<6.MONITOR>SCAPAR.MAC.40,  27-Sep-83 09:45:29 by GRANT
;Move KLIPA CDB offsets to PHYPAR
;
; UPD ID= 2875, SNARK:<6.MONITOR>SCAPAR.MAC.39,   2-Sep-83 11:27:49 by CDUNN
;More TCO 6.1127 - Add definition of C%DBIU for number of scratch datagrams
;to keep around...
;
; UPD ID= 2828, SNARK:<6.MONITOR>SCAPAR.MAC.38,  11-Aug-83 15:36:16 by CDUNN
;More TCO 6.1127 - Buffer parameter diddles and fixes to support maintainance
;mode packet sends
;
; UPD ID= 2751, SNARK:<6.MONITOR>SCAPAR.MAC.37,  22-Jul-83 16:42:09 by CDUNN
;More TCO 6.1127 - Add support definitions for the SCAMPI/SCSJSY cleanup.
;
; UPD ID= 2556, SNARK:<6.MONITOR>SCAPAR.MAC.36,   3-Jun-83 17:14:15 by CDUNN
;More TCO 6.1127 - Put the PPD byte definitions where they belong
;
; UPD ID= 2532, SNARK:<6.MONITOR>SCAPAR.MAC.35,  26-May-83 18:08:02 by CDUNN
;More TCO 6.1127 - Add page data block definition for buffer managment.
;
; UPD ID= 2460, SNARK:<6.MONITOR>SCAPAR.MAC.34,  12-May-83 17:14:16 by CDUNN
;More TCO 6.1127 - Add CBFKIL to the CB flags.
;
; UPD ID= 2457, SNARK:<6.MONITOR>SCAPAR.MAC.33,  11-May-83 12:40:54 by CDUNN
;More TCO 6.1127 - Add support definitions for interface bible changes of
;previous edit.
;
; UPD ID= 2421, SNARK:<6.MONITOR>SCAPAR.MAC.32,   4-May-83 13:51:13 by CDUNN
;More TCO 6.1127 - Change interface bible to return message/datagram length
;in packet header rather than in Q1. Update $CALTB to reflect changes in
;SCA callbacks.
;
; UPD ID= 2350, SNARK:<6.MONITOR>SCAPAR.MAC.31,  26-Apr-83 21:51:55 by CDUNN
;More TCO 6.1127 - Add .RGLEN to ring buffer and some random constants.
;
; UPD ID= 2324, SNARK:<6.MONITOR>SCAPAR.MAC.30,  22-Apr-83 01:40:44 by CDUNN
;More TCO 6.1127 - Add byte count to SCA/PPD interface bible on datagrams/msg
;return to SCA.
;
; UPD ID= 2255, SNARK:<6.MONITOR>SCAPAR.MAC.29,  12-Apr-83 23:17:22 by CDUNN
;More TCO 6.1127 - Remove IFNDEF for FTMSCP
;
; UPD ID= 2252, SNARK:<6.MONITOR>SCAPAR.MAC.28,  12-Apr-83 20:07:14 by CDUNN
;More TCP 6.1127 - Fix CIOn and CIOFF to preserve the state of the PI so
;PHYSIO does not get upset.
;
; UPD ID= 2199, SNARK:<6.MONITOR>SCAPAR.MAC.27,   8-Apr-83 05:15:31 by WACHS
;More TCO 6.1127 - Add performance counter definitions
;
; UPD ID= 2197, SNARK:<6.MONITOR>SCAPAR.MAC.26,   8-Apr-83 04:41:04 by CDUNN
;More TCO 6.1127 - Add .RGSBA to the definition of the SCA ring buffer. Also
;add definitions for idle chatter support. Note that this involves words added
;to the end of the system block. Add buffer address and callers PC to SCA 
;ring buffer. Also fix CION and CIOFF to no do anything if already in PI 5 
;code.
;
; UPD ID= 2163, SNARK:<6.MONITOR>SCAPAR.MAC.25,   4-Apr-83 21:22:08 by CDUNN
;More TCO 6.1127 - Change default to no PI debug
;
; UPD ID= 2156, SNARK:<6.MONITOR>SCAPAR.MAC.24,   4-Apr-83 18:05:27 by CDUNN
;More TCO 6.1127 - Add new performance counter setting definitions
;
; UPD ID= 2153, SNARK:<6.MONITOR>SCAPAR.MAC.23,   4-Apr-83 16:26:21 by CDUNN
;More TCO 6.1127 - Add defintions for idle chatter
;
; UPD ID= 2137, SNARK:<6.MONITOR>SCAPAR.MAC.22,   3-Apr-83 20:36:14 by CDUNN
;More TCO 6.1127 -
;1. Change connection state codes such that zero is no longer valid.
;2. Add ring buffer to CIOFF and CIOFF to aid in finding lost ones. Place
;under special debugging switch PIDBG.
;
; UPD ID= 2120, SNARK:<6.MONITOR>SCAPAR.MAC.21,  29-Mar-83 18:42:48 by CDUNN
;More TCO 6.1127 - Change $SKIP to be a macro and not an OPDEF so does not
;show up in DDT.
;
; UPD ID= 2114, SNARK:<6.MONITOR>SCAPAR.MAC.20,  29-Mar-83 05:50:22 by CDUNN
;More TCO 6.1127 - Fix CION and CIOFF to nest such that only the last CION 
;really turns on channel 5.
;
; UPD ID= 2091, SNARK:<6.MONITOR>SCAPAR.MAC.19,  28-Mar-83 09:57:58 by GRANT
;Move MAXNDS to PROLOG
;
; UPD ID= 2089, SNARK:<6.MONITOR>SCAPAR.MAC.18,  28-Mar-83 02:10:33 by CDUNN
;More TCO 6.1127 - Add LOCPRT to interface bible. Also fix block state
;codes such that there is no block state zero. Make zero the clear state
;Also add performance counter definitions
;
; UPD ID= 2065, SNARK:<6.MONITOR>SCAPAR.MAC.17,  23-Mar-83 01:21:11 by CDUNN
;More TCO 6.1127 - Add C%OVHD, length of SCA header in bytes
;
; UPD ID= 2063, SNARK:<6.MONITOR>SCAPAR.MAC.16,  23-Mar-83 00:30:22 by CDUNN
;More TCO 6.1127 - Fix CB to remove .CBDGB and add .CBCDD. Also make pretty
;picture agree with reality...
;
; UPD ID= 2060, SNARK:<6.MONITOR>SCAPAR.MAC.15,  22-Mar-83 08:17:25 by WACHS
;More TCO 6.1127 - KLIPA error reporting
;
; UPD ID= 2056, SNARK:<6.MONITOR>SCAPAR.MAC.14,  22-Mar-83 00:50:12 by CDUNN
;More TCO 6.1127 - Fix event block lengths.
;
; UPD ID= 1982, SNARK:<6.MONITOR>SCAPAR.MAC.13,  11-Mar-83 22:47:09 by CDUNN
;More TCO 6.1127 - Fix definition of .STLST so SNDTAB and RECTAB are the
;correct length
;
; UPD ID= 1976, SNARK:<6.MONITOR>SCAPAR.MAC.12,  11-Mar-83 00:57:02 by CDUNN
;More TCO 6.1127 - Add callback for DMA transfer complete. Also some support
;definitions for DMA code...

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1984, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


	SUBTTL	SCAPAR - Parameters for SCA

	SEARCH MONSYM,MACSYM,PROLOG,PHYPAR

	UNIVERSAL SCAPAR

;SCAPAR - Systems Communications Architecture Parameters
;
;
; Note:
; Some abbreviations appear EVERYWHERE in this module. They are:
;
; CB  - Connection block
; SB  - System block
; PB  - Port Control Block
; SBI - System block index
; CID - Source connect ID
; PPD - Physical port driver
; BQ  - Buffer deferal request queue

	Subttl	Table of Contents

;		     Table of Contents for SCAPAR
;
;				  Section		      Page
;
;
;    1. Mask definitions
;        1.1    Connect ID format  . . . . . . . . . . . . . .   3
;    2. Block formats  . . . . . . . . . . . . . . . . . . . .   4
;        2.1    System block . . . . . . . . . . . . . . . . .   5
;        2.2    Buffer header, buffer descriptor . . . . . . .   7
;        2.3    Queue pointer address blocks . . . . . . . . .   9
;        2.4    Configuration data block . . . . . . . . . . .  10
;        2.5    System wide maintainance data wait queue . . .  11
;        2.6    Connection state data  . . . . . . . . . . . .  12
;        2.7    JSYS packet buffer "invisible data area" . . .  13
;        2.8    JSYS Buffer list descriptor block  . . . . . .  14
;        2.9    Named buffer list block  . . . . . . . . . . .  15
;        2.10   Map descriptor block . . . . . . . . . . . . .  16
;        2.11   Common queue header  . . . . . . . . . . . . .  17
;        2.12   Event code block header  . . . . . . . . . . .  18
;        2.13   DMA queue header . . . . . . . . . . . . . . .  19
;        2.14   SCA ring buffer entry  . . . . . . . . . . . .  20
;            2.14.1   Feature data (SYSSCA)  . . . . . . . . .  21
;            2.14.2   Feature data (SCASYS)  . . . . . . . . .  22
;            2.14.3   Feature data (BUFMAN)  . . . . . . . . .  23
;            2.14.4   Feature data (PKTEVT)  . . . . . . . . .  24
;            2.14.5   Feature data (PITRAN)  . . . . . . . . .  25
;            2.14.6   Feature data (PORTQU)  . . . . . . . . .  26
;            2.14.7   Feature data (INTLOK)  . . . . . . . . .  27
;    3. OPDEFs . . . . . . . . . . . . . . . . . . . . . . . .  28
;    4. Macros . . . . . . . . . . . . . . . . . . . . . . . .  29
;        4.1    ASCI8 (Generate word aligned 8-Bit ASCII)  . .  30
;        4.2    $SCOFF (Get SCA disconnect interlock)  . . . .  31
;        4.3    $SYSAP (SYSAP initilization address table) . .  32
;        4.4    $CALTB (Dispatch table for SCA to JSYS calls)   33
;        4.5    $DISPA (Dispatch table generator)  . . . . . .  34
;        4.6    $BUILD,$SET,$EOB - Build pre-formed data block  35
;        4.7    $SCSFC . . . . . . . . . . . . . . . . . . . .  36
;    5. Function codes returned by SCA.  . . . . . . . . . . .  37
;    6. Connection states  . . . . . . . . . . . . . . . . . .  39
;    7. Connection block states  . . . . . . . . . . . . . . .  40
;    8. SCA message types and lengths  . . . . . . . . . . . .  41
;    9. Message formats
;        9.1    PPD packet definitions . . . . . . . . . . . .  42
;        9.2    Message header . . . . . . . . . . . . . . . .  43
;        9.3    Connect and Accept requests  . . . . . . . . .  44
;   10. SCA/PPD Flags  . . . . . . . . . . . . . . . . . . . .  45
;   11. Queue of Outstanding Requests  . . . . . . . . . . . .  46
;   12. Random cruft for PHYMSC  . . . . . . . . . . . . . . .  47
	SUBTTL	Mask definitions -- Connect ID format

; The following data structure defines the fields within a connect ID.
;There are two fields within the ID. The first field in the ID are bits 
;settable by the SYSAP. This comes in handy for connection management, etc...
;The second field is the address of the connection block. 
;
	MSKSTR (SID,<>,<770000,,0>) ;Define the field for the SYSAP ID
	MSKSTR (UBITS,<>,<7777,,760000>) ;Mask for the uniqueness bits
	MSKSTR (INDEX,<>,<0,,17760>) ;Mask for CID table index

	C%RMBU==^D13		;Number of bits needed to right justify the
				;  uniqueness bits

	SUBTTL	Mask definitions -- Random masks

	M%IBIT==17		;Mask of bits to ignore from the wire

; Masks for bit swapping in outgoing and incoming messages

	MSKSTR (M%AMII,<>,<377B31>) ;Incoming, input byte A, MSB
	MSKSTR (M%ALII,<>,<377B23>) ;Incoming, input byte A, LSB
	MSKSTR (M%BMII,<>,<377B15>) ;Incoming, input byte B, MSB
	MSKSTR (M%BLII,<>,<377B7>)  ;Incoming, input byte B, LSB
	SUBTTL	Block formats

	SUBTTL	Block formats -- Connection block

; 	 +=======================================================+
; .CBANB !             Address of next connect block             !
;	 !-------------------------------------------------------!
; .CBAPB !           Address of previous connect block           !
;	 !-------------------------------------------------------!
; .CBSBA !                 System block address                  !
;	 !-------------------------------------------------------!
; .CBSBI !  Destination node number  !     Expected response     !
;	 !-------------------------------------------------------!
; .CBSTS !    Connect block state    !     Connection state      !
;	 !-------------------------------------------------------!
; .CBFLG !                         Flags                         !
;	 !-------------------------------------------------------!
; .CBSCI !                   Source connect ID                   !
;	 !-------------------------------------------------------!
; .CBDCI !                Destination connect ID                 !
;	 !-------------------------------------------------------!
; .CBADR !                SYSAP callback address                 !
;	 !-------------------------------------------------------!
; .CBBUF !  Message buffers to queue ! Datagram buffers to queue !
;	 !-------------------------------------------------------!
; .CBNWQ !               Next entry on work queue                !
;	 !-------------------------------------------------------!
; .CBSPN \							 \
;        \                  Source process name                  \
;	 \							 \
;	 !-------------------------------------------------------!
; .CBDPN \							 \
;	 \               Destination process name                \
;	 \							 \
;	 !-------------------------------------------------------!
; .CBDTA \							 \
;	 \              User supplied connect data               \
;	 \							 \
;	 !-------------------------------------------------------!
; .CBREA !  Dest. disconnect reason  ! Source disconnect reason  !
;	 !-------------------------------------------------------!
; .CBMCD !    Minimum send credit    !  Minimum receive credit   !
;	 !-------------------------------------------------------!
; .CBSCD !                      Send credit                      !
;	 !-------------------------------------------------------!
; .CBRCD !                    Receive credit                     !
;	 !-------------------------------------------------------!
; .CBPRC !                Pending receive credit                 !
;	 !-------------------------------------------------------!
; .CBRQC !                    Requeue credit                     !
;	 !-------------------------------------------------------!
; .CBRTC !		      Return credit			 !
;	 !-------------------------------------------------------!
; .CBNPO ! Packets on port command Q !  Reaping postponed count  !
;	 !-------------------------------------------------------!
; .CBDGR !     Number of datagram buffers on hardware queue      !
;	 !-------------------------------------------------------!
; .CBCDD !              Number of dropped datagrams              !
;	 !-------------------------------------------------------!
; .CBLCK !           Interlock word for connect state            !
;	 !-------------------------------------------------------!
; .CBPND !     Interlock word for credit_request in progress	 !
;	 !-------------------------------------------------------!
; .CBJNB !     Address of next connection block for this fork	 !
;	 !-------------------------------------------------------!
; .CBJPB !   Address of previous connection block for this fork  !
;	 !-------------------------------------------------------!
; .CBMGJ !     Number of JSYS message receive buffers queued	 !
;	 !-------------------------------------------------------!
; .CBDGJ !	     Number of JSYS DG buffers queued		 !
;	 !-------------------------------------------------------!
; .CBFRK !  Job number of owner job  ! Fork number of owner fork !
;	 !-------------------------------------------------------!
; .CBTMQ !  Pointer to top of message avilable queue (for JSYS)  !
;	 !-------------------------------------------------------!
; .CBBMQ !  Pointer to bot of message avilable queue (for JSYS)  !
;	 !-------------------------------------------------------!
; .CBTDQ !  Pointer to top of datagram avilable queue (for JSYS) !
;	 !-------------------------------------------------------!
; .CBBDQ !  Pointer to bot of datagram avilable queue (for JSYS) !
;	 !-------------------------------------------------------!
; .CBTXQ !     Pointer to top of the DMA xfer complete queue     !
;	 !-------------------------------------------------------!
; .CBBXQ !     Pointer to bot of the DMA xfer complete queue     !
;	 !-------------------------------------------------------!
; .CBTEQ !          Pointer to top of the event queue            !
;	 !-------------------------------------------------------!
; .CBBEQ !	    Pointer to bot of the event queue            !
;	 !-------------------------------------------------------!
; .CBTBQ !       Pointer to first buffer descriptor block	 !
;	 !-------------------------------------------------------!
; .CBBBQ !       Pointer to  last buffer descriptor block	 !
;	 !-------------------------------------------------------!
; .CBPS0 !  PSI channel for messages ! PSI channel for datagrams !
;	 !-------------------------------------------------------!
; .CBPS1 !    PSI channel for DMA    !  PSI channel for events   !
;        +=======================================================+

	.CBANB==:0		;Address of next connection block

	.CBAPB==:.CBANB+1	;Address of previous connection block

	.CBSBA==:.CBAPB+1	;System block address

	.CBSBI==:.CBSBA+1	;Destination node number,,expected response
		MSKSTR (CBDNOD,<.CBSBI>,<-1,,0>) ;Dest system block index
		MSKSTR (CBEXPR,<.CBSBI>,<0,,-1>) ;Expected response

	.CBSTS==:.CBSBI+1	;Status info
		MSKSTR (CBBKST,<.CBSTS>,<-1,,0>) ;Block state
		MSKSTR (CBCNST,<.CBSTS>,<0,,-1>) ;Connection state

	.CBFLG==:.CBSTS+1	;Flags
		MSKSTR (CBFNNC,<.CBFLG>,<400000,,0>) ;Needs credit notify
		MSKSTR (CBFJSY,<.CBFLG>,<200000,,0>) ;CB is for JSYS conn
		MSKSTR (CBFABT,<.CBFLG>,<100000,,0>) ;CB has been aborted
		MSKSTR (CBFRAP,<.CBFLG>,<040000,,0>) ;CB is to be reaped
		MSKSTR (CBFDCL,<.CBFLG>,<020000,,0>) ;This was DC listener
		MSKSTR (CBFKIL,<.CBFLG>,<010000,,0>) ;Fork has been killed
		MSKSTR (CBFMDC,<.CBFLG>,<004000,,0>) ;Maint data CB
		MSKSTR (CBFCVC,<.CBFLG>,<002000,,0>) ;V.C. was closed
		MSKSTR (CBFSOB,<.CBFLG>,<001000,,0>) ;Stuck on buffers
		MSKSTR (CBFPTC,<.CBFLG>,<000400,,0>) ;Protocol completed
		MSKSTR (CBFERR,<.CBFLG>,<000200,,0>) ;SC.ERR deferred
		MSKSTR (CBFDIS,<.CBFLG>,<000100,,0>) ;SC.DIS deferred
		MSKSTR (CBFDRQ,<.CBFLG>,<000040,,0>) ;SC.DRQ deferred
		MSKSTR (CBFSNM,<.CBFLG>,<000020,,0>) ;SC.SNM deferred
		MSKSTR (CBFDEF,<.CBFLG>,<000360,,0>) ;All deferred bits

	.CBSCI==:.CBFLG+1	;Source connect ID
		MSKSTR (CBSCID,<.CBSCI>,<-1>)    ;Source connect ID

	.CBDCI==:.CBSCI+1	;Destination connect ID
		MSKSTR (CBDCID,<.CBDCI>,<-1>)    ;Destination connect ID

	.CBADR==:.CBDCI+1	;Address at which to call SYSAP on connect cond

	.CBBUF==:.CBADR+1	;Buffer requests
		MSKSTR (CBIMB,<.CBBUF>,<-1,,0>) ;Number of message buffers to queue
		MSKSTR (CBIDB,<.CBBUF>,<0,,-1>) ;Number of datagram buffers to queue

	.CBNWQ==:.CBBUF+1	;Next entry on work queue

	.CBSPN==:.CBNWQ+1	;Source process name

	.CBDPN==:.CBSPN+4	;Destination process name

	.CBDTA==:.CBDPN+4	;Caller-supplied connection data

	.CBREA==:.CBDTA+4	;Disconnect/reject reasons
		MSKSTR (CBDDRE,<.CBREA>,<-1,,0>) ;Dest disconnect reasons
		MSKSTR (CBSDRE,<.CBREA>,<0,,-1>) ;Source disconnect reasons

	.CBMCD==:.CBREA+1	;Threshold credit info
		MSKSTR (CBMNSC,<.CBMCD>,<-1,,0>) ;Minimum send credit
		MSKSTR (CBMNRC,<.CBMCD>,<0,,-1>) ;Minimum receive credit

	.CBSCD==:.CBMCD+1	;Send credit

	.CBRCD==:.CBSCD+1	;Receive credit

	.CBPRC==:.CBRCD+1	;Pending receive credit

	.CBRQC==:.CBPRC+1	;Requeue credit

	.CBRTC==:.CBRQC+1	;Return credit

	.CBNPO==:.CBRTC+1	;Num of packets (msg or dg) still on port cmd Q
		MSKSTR (CBNPO,<.CBNPO>,<-1,,0>) ;Number of packets on command queue
		MSKSTR (CBRCNT,<.CBNPO>,<0,,-1>) ;Number of times reaping postponed

	.CBDGR==:.CBNPO+1	;Number of DG buffers on hardware queue

	.CBCDD==:.CBDGR+1	;Number of dropped datagrams
		MSKSTR (CBCDD,<.CBCDD>,<-1>)

	.CBLCK==:.CBCDD+1	;Interlock for connect state

	.CBPND==:.CBLCK+1	;Flag word for credit_request in progress

	.CBJNB==:.CBPND+1	;Addr of next CB in the job list
		MSKSTR (CPJNB,<.CBJNB>,<-1>)

	.CBJPB==:.CBJNB+1	;Addr of previous CB in the job list
		MSKSTR (CPJPB,<.CBJPB>,<-1>)

	.CBMGJ==:.CBJPB+1	;Number of JSYS message receive buffers queued
		MSKSTR (CBMGJ,<.CBMGJ>,<-1>)

	.CBDGJ==:.CBMGJ+1	;Number of DG buffers in user space
		MSKSTR (CBDGJ,<.CBDGJ>,<-1>)

	.CBFRK==:.CBDGJ+1	;Job number,,fork number of who owns connection
		MSKSTR (CBFORK,<.CBFRK>,<0,,-1>) ;Fork of connect owner
		MSKSTR (CBJOB,<.CBFRK>,<-1,,0>)  ;Job  of connect owner

	.CBTMQ==:.CBFRK+1	;Pointer to first buffer on message pending Q
		MSKSTR (CBTMQ,<.CBTMQ>,<-1>)

	.CBBMQ==:.CBTMQ+1	;Pointer to bottom of message available queue
		MSKSTR (CBBMQ,<.CBBMQ>,<-1>)

	.CBTDQ==:.CBBMQ+1	;Pointer to top of datagram available queue
		MSKSTR (CBTDQ,<.CBTDQ>,<-1>)

	.CBBDQ==:.CBTDQ+1	;Pointer to bottom of datagram availab queue
		MSKSTR (CBBDQ,<.CBBDQ>,<-1>)

	.CBTXQ==:.CBBDQ+1	;Pointer to top of DMA xfer queue
		MSKSTR (CBTXQ,<.CBTXQ>,<-1>)

	.CBBXQ==:.CBTXQ+1	;Pointer to bot of DMA xfer queue
		MSKSTR (CBBXQ,<.CBBXQ>,<-1>)

	.CBTEQ==:.CBBXQ+1	;Top of event queue
		MSKSTR (CBTEQ,<.CBTEQ>,<-1>)

	.CBBEQ==:.CBTEQ+1	;Bot of event queue
		MSKSTR (CBBEQ,<.CBBEQ>,<-1>)

	.CBTBQ==:.CBBEQ+1	;Pointer to first buffer list desrciptor block
		MSKSTR (CBTBQ,<.CBTBQ>,<-1>)

	.CBBBQ==:.CBTBQ+1	;Pointer to last buffer list desctiptor block
		MSKSTR (CBBBQ,<.CBBBQ>,<-1>)

	.CBPS0==:.CBBBQ+1	;First word of PSI channels for the connection
		MSKSTR (CBPMG,<.CBPS0>,<-1,,0>) ;PSI for messages
		MSKSTR (CBPDG,<.CBPS0>,<0,,-1>) ;PSI for datagrams

	.CBPS1==:.CBPS0+1	;Second word of PSI channels for connection
		MSKSTR (CBPDA,<.CBPS1>,<-1,,0>) ;PSI for dta transfer
		MSKSTR (CBPEV,<.CBPS1>,<0,,-1>) ;PSI for events

	.CBLEN==:.CBPS1+1	;Length of the connection block

IF2 <IFL <C%MGSZ-.CBLEN>,<PRINTX ?SCAPAR: Connection block to long for a message buffer>>
	SUBTTL	Block formats -- System block

;        !=======================================================!
; .SBANB !             Address of next system block              !
;        !-------------------------------------------------------!
; .SBAPB !	Address of associated port control block	 !
;        !-------------------------------------------------------!
; .SBACD !	Address of associated channel data block	 !
;        !-------------------------------------------------------!
; .SBVCS !    Closing/opening bits   !    Dest vir cir state     !
;        !-------------------------------------------------------!
; .SBDSP !      Channel number       !     Destination port      !
;        !-------------------------------------------------------!
; .SBDRQ !             Datagram return queue header              !
;        !-------------------------------------------------------!
; .SBLMB !              Local message buffer header              !
;        !-------------------------------------------------------!
; .SBFCB !           Pointer to first connection block           !
;        !-------------------------------------------------------!
; .SBLCB !	     Pointer to last connection block            !
;        !-------------------------------------------------------!
; .SBTWQ !		 FLINK for SCA work queue		 !
;        !-------------------------------------------------------!
; .SQBWQ !		 BLINK for SCA work queue		 !
;        !-------------------------------------------------------!
; .SBCLC !	       Count of locked connections		 !
;        !-------------------------------------------------------!
; .SBQOR !      Pointer to queue of outstanding requests         !
;        !-------------------------------------------------------!
; .SBDSS \							 \
;	 \                  Destination system                   \
;        !-------------------------------------------------------!
; .SBMMS !   Max mess size (bytes)   !    Max DG size (Bytes)    !
;        !-------------------------------------------------------!
; .SBDST !               Destination software type               !
;        !-------------------------------------------------------!
; .SBDSV !             Destination software version              !
;        !-------------------------------------------------------!
; .SBDSE !           Destination software edit level             !
;        !-------------------------------------------------------!
; .SBDHT !               Destination harware type                !
;        !-------------------------------------------------------!
; .SBDHV \             Destination hardware version              \
;        \                                                       \
;        \                                                       \
;        !-------------------------------------------------------!
; .SBNNM \                Destination port name                  \
;        \                                                       \
;        !-------------------------------------------------------!
; .SBDPC !            Destination port characteristics           ! 
;        !-------------------------------------------------------! 
; .SBDCR !          Destination Port Code Revision Level         !
;        !-------------------------------------------------------!
; .SBDPF !             Destination Port Functionality            !
;        !-------------------------------------------------------!
; .SBDPS !                Destination Port State                 !
;        !-------------------------------------------------------!
; .SBTIM !	 TODCLK at last message from this remote	 !
;        !-------------------------------------------------------!
; .SBFLG !			Flags				 !
;        !-------------------------------------------------------!
; .SBSST !		  Start Sequence Timer			 !
;	 !-------------------------------------------------------!
; .SBOBB !            Out bound buffer for system block		 !
;        !=======================================================!
;
	KDBCID==:KDBDDP+PRTMXU	;Controller ID (8 8-bit bytes)
	KDBIAC==:KDBCID+2	;Saved ACs for use during initing a node

;Note that the system block for a node starts immediately after the KDB
	.SBANB==:KDBIAC+10	;Addr of next system block

	.SBAPB==:.SBANB+1	;Address of associated port control block

	.SBACD==:.SBAPB+1	;Address of associated channel data block

	.SBVCS==:.SBACD+1	;Destiation virtual circuit state
		MSKSTR (SBNTC,<.SBVCS>,<1B0>)	;Need to close VC
		MSKSTR (SBOKO,<.SBVCS>,<1B1>)	;OK to open VC
		MSKSTR (SBWFI,<.SBVCS>,<1B2>)	;Waiting for a new IDREC
		MSKSTR (SBVCST,<.SBVCS>,<0,,-1>) ;Virtual circuit state
				;(symbols for states in MONSYM)

	.SBDSP==:.SBVCS+1	;Channel number,,Destination port
		MSKSTR (SBCHN,<.SBDSP>,<-1,,0>) ;Channel number
		MSKSTR (SBDPA,<.SBDSP>,<0,,-1>) ;Destination port address

	.SBDRQ==:.SBDSP+1	;Datagram return queue header
		MSKSTR (SBDRQH,<.SBDRQ>,<-1>)	;Datagram return queue header

	.SBLMB==:.SBDRQ+1	;Local message buffer header
		MSKSTR (SBLMBH,<.SBLMB>,<-1>)    ;Local message buffer header

	.SBFCB==:.SBLMB+1	;Pointer to first connection block

	.SBLCB==:.SBFCB+1	;Pointer to last coonection block

	.SBTWQ==:.SBLCB+1	;FLINK for SCA work queue for this SB

	.SBBWQ==:.SBTWQ+1	;BLINK for SCA work queue for this SB

	.SBCLC==:.SBBWQ+1	;Count of locked connections

	.SBQOR==:.SBCLC+1	;Pointer to queue of outstanding requests

	.SBDSS==:.SBQOR+1	;Destination system

	.SBMMS==:.SBDSS+2	;Maximum message sizes
		MSKSTR (SBMXMG,<.SBMMS>,<-1,,0>) ;Maximum message size
		MSKSTR (SBMXDG,<.SBMMS>,<0,,-1>) ;Maximum datagram size

	.SBDST==:.SBMMS+1	;Destination software type
		MSKSTR (SBDTSW,<.SBDST>,<-1>) ;Destination software type

	.SBDSV==:.SBDST+1	;Destination software version
		MSKSTR (SBDVSW,<.SBDSV>,<-1>) ;Destination software version

	.SBDSE==:.SBDSV+1	;Destination software edit level

	.SBDHT==:.SBDSE+2	;Destination hardware type
		MSKSTR (SBDTHW,<.SBDHT>,<-1>) ;Destination hardware type

	.SBDHV==:.SBDHT+1	;Destination hardvare version
		MSKSTR (SBDVHW,<.SBDHV>,<-1>) ;Destination hardware version

	.SBNNM==:.SBDHV+3	;Destination port name

	.SBDPC==:.SBNNM+2	;Destination port characteristics

	.SBDCR==:.SBDPC+1	;Destination Port Characteristics (from IDREC)

	.SBDPF==:.SBDCR+1	;Destination Port Code Revision Level

	.SBDPS==:.SBDPF+1	;Destination Port Functionality
		MSKSTR (SBDPS,<.SBDPS>,<000000,,070000>) ;Port State
		MSKSTR (SBDRP,<.SBDPS>,<000000,,007760>) ;Resetting Node
	.SBTIM==:.SBDPS+1	;TODCLK at last received message

	.SBFLG==:.SBTIM+1	;Flags
		MSKSTR (SBFLG,<.SBFLG>,<-1>) ;Mask for full flags field
			MSKSTR (SBFTMG,<.SBFLG>,<400000,,000000>);Timed message
			MSKSTR (SBFOVC,<.SBFLG>,<200000,,000000>);VC needs open
			MSKSTR (SBFOFL,<.SBFLG>,<40000,,000000>);Node offline

	.SBSST==:.SBFLG+1	;VC start sequence timer
		MSKSTR (SBSST,<.SBSST>,<-1>)

	.SBOBB==:.SBSST+1	;Out bound buffer for system block
		MSKSTR (SBOBB,<.SBOBB>,<-1>)

	.SBLEN==:.SBOBB+1	;Length of the system block
;	PCB

.PBIWD==0			;Offset for interlock word
.PBFLI==1			;Offset for FLINK
.PBBLI==2			;Offset for BLINK

.PBBDT==0			;Buffer descriptor table addr
.PBMQE==1			;Message queue entry length
.PBDQE==2			;Datagram queue entry length
;WORD 3 IS RESERVED
.PBQ3I==4			;Queue 3 interlock
.PBQ3F==5			;Queue 3 FLINK
.PBQ3B==6			;Queue 3 BLINK
.PBQ2I==7			;Queue 2 interlock
.PBQ2F==10			;Queue 2 FLINK
.PBQ2B==11			;Queue 2 BLINK
.PBQ1I==12			;Queue 1 interlock
.PBQ1F==13			;Queue 1 FLINK
.PBQ1B==14			;Queue 1 BLINK
.PBQ0I==15			;Queue 0 interlock
.PBQ0F==16			;Queue 0 FLINK
.PBQ0B==17			;Queue 0 BLINK
MAXQUE==3			;Highest QUEUE
.PBRQI==20			;Response QUEUE interlock
.PBRQF==21			;Response QUEUE FLINK
.PBRQB==22			;Response QUEUE BLINK
.PBMFI==23			;Message FREE queue INTERLOCK
.PBMFF==24			;Message FREE QUEUE FLINK
.PBMFB==25			;Message FREE QUEUE BLINK
.PBDFI==26			;Datagram FREE querue INTERLOCK
.PBDFF==27			;Datagram FREE QUEUE FLINK
.PBDFB==30			;Datagram FREE QUEUE BLINK
.PBQND==31			;End of queue structure in PCB
;WORDS 31-34 ARE RESERVED
.PBER0==35			;Error word 0 (QUEUE INFORMATION)
	DEFSTR (E0CMD,.PBER0,0,1)	;ERROR WHILE READING A COMMAND
	DEFSTR (E0QUE,.PBER0,2,2)	;COMMAND QUEUE THAT HAD THE ERROR -
					;(VALID ONLY IF E1CMD IS ON)
	DEFSTR (E0RES,.PBER0,3,1)	;ERROR WHILE BUILDING A RESPONSE
	DEFSTR (E0MBZ,.PBER0,11,5)	;MUST BE ZERO
	DEFSTR (E0FLI,.PBER0,35,24)	;FLINK OF ENTRY IN ERROR
.PBER1==36			;Error word 1 (API FUNCTION WORD)
.PBER2==37			;Error word 2 (REGISTER DATA)
.PBER3==40			;Error word 3 (CHANNEL LOGOUT WORD 1)
.PBER4==41			;Error word 4 (CHANNEL LOGOUT WORD 2)
.PBPBA==42			;PCB base address
.PBPIA==43			;PI level
.PBRS5==44			;Reserved
.PBCCW==45			;Channel control word
;WORD 46 IS RESERVED
L.PCB==47			;Length of port control block
	SUBTTL	Block formats -- Buffer header, buffer descriptor

;                          Buffer header descriptor
;
;          +================+==========================+==+==+==+
;          |00<---------->15|16<------------------->|32|33|34|35|
; .BHKEY   |      KEY       |            MBZ        |P |V |E |W |     0
;          +----------------+--------------------------+--+--+--+
;          |00<------->11|12<-------------------------------->35|
; .BHBSA   |     MBZ     | FIRST BUFFER SEGMENT DESCRIPTOR ADDR |--+  1
;          +-------------+--------------------------------------+  |
;          |00<---------------------------------------------->35|  |
; .BHLEN   |                    LENGTH                          |  |  2
;          +----------------------------------------------------+  |
;          |                   RESERVED                         |  |  3
;          +----------------------------------------------------+  |
;                                 V                                |
;                                 V                                |
;                                 V                                |
;                        BUFFER SEGMENT DESCRIPTOR  # 1            |
;          +-------+-------+-------+----------------------------+  |
;          |00<->05|06<->07|08<->11|12<---------------------->35|<-+
; .BSADR   |  MBZ  |  MODE |  MBZ  | BUFFER SEGMENT  BASE  ADDR |     0
;          |-------+-------+--+----+----------------------------+
;          |00<------------>11|12<--------------------------->35|
; .BSNXT   |        MBZ       | NEXT BUFFER SEGMENT DESCRIPTOR  |--+  1
;          |------------------+---------------------------------+  |
;          |00<---------------------------------------------->35|  |
; .BSLEN   |                    SEGMENT LENGTH                  |  |  2
;          |----------------------------------------------------+  |
;          |                   RESERVED                         |  |  3
;          +====================================================+  |
;                                 V                                |
;                                 V                                |
;                                 V                                |
;                        BUFFER SEGMENT DESCRIPTOR # n             |
;          +=======+=======+=======+============================+  |
;          |00<->05|06<->07|08<->11|12<---------------------->35|<-+
; .BSADR   |  MBZ  |  MODE |  MBZ  | BUFFER SEGMENT  BASE  ADDR |     0
;          +-------+-------+-------+----------------------------+  
;          |00<------------>11|12<--------------------------->35|
; .BSNXT   |        MBZ       | NEXT BUFFER SEGMENT DESCRIPTOR  |     1
;          |------------------+---------------------------------+
;          |00<---------------------------------------------->35|
; .BSLEN   |                    SEGMENT LENGTH                  |     2
;          |----------------------------------------------------+
;          |                    RESERVED                        |     3
;          +====================================================+
;
BHDNUM==140			;****Number of buffer header descriptor's******

;In the buffer name
BHPIDX==^D31			;Index into buffer descriptor table
BHSIDX==^D16

;In the BHD/BSD
.BHKEY==0			;Key
	BHPKEY==^D15		;Position
	BHSKEY==^D16		;Size
	BH.PRE==1B32		;Preserve Valid bit
	BH.VAL==1B33		;Valid bit
	BH.ERR==1B34		;Error bit
	BH.WRT==1B35		;Writable
.BHBSA==.BHKEY+1		;Addr of buffer segment descriptor
.BHLEN==.BHBSA+1		;Length (in nibbles) of entire transfer
L.BHD==4			;Length of a buffer header descriptor
   BHDSHF==2			;Shift to produce L.BHD from index

.BSADR==0			;Address of segment/mode of segment
	BSPMOD==7		;Position
	BSSMOD==2		;Size of field
	BS.ICM==0B7		;Industry-compatable mode
	BS.CDM==1B7		;Core-dump mode
	BS.HDM==2B7		;High-density mode
	BS.ASM==3B7		;7-bit ASCII mode (not available on KLIPA)
.BSNXT==.BSADR+1		;Pointer to next segment descriptor
.BSLEN==.BSNXT+1		;Length (nibbles) of this segment
CDNPW==12			;Core dump nibbles per word for BHD/BSD
HDNPW==11			;High density nibbles per word for BHD/BSD
L.BSD==4			;Length of a buffer segment descriptor
	SUBTTL	Block formats -- Queue pointer address blocks

; The following is the definition of the block used to pass the addresses of
;queues between routines in SCSJSY. See SCSDEQ in SCSJSY.MAC.
;
; And now, a word from our sponsor:
;	The purpose of these blocks is to make it possible for one routine
;to dequeue any type packet from any of the fork and connection queues it is
;on. When deleteing datagrams, events, DMA notifications, or messages from the
;fork and connection queues, the same routine is called. The only information
;that changes between these types of packets, is the addresses of the list
;head and tail pointers. Hence passing the address of one a block like this
;to SCSDEQ tells it all it needs to know...
;
; This is alot cleaner and no more expensive than a hard coded routine for
;each packet type...
;
;	 !=======================================================!
; .TOPCQ !            Addr of connect Q head pointer             !
;	 !-------------------------------------------------------!
; .BOTCQ !            Addr of connect Q tail pointer             !
;	 !-------------------------------------------------------!
; .TOPFQ !              Addr of fork Q head pointer              !
;	 !-------------------------------------------------------!
; .BOTFQ !              Addr of fork Q tail pointer              !
;	 !-------------------------------------------------------!
; .JBBUF !		Count of these JSYS buffers		 !
;	 !=======================================================!
;
	.TOPCQ==0
	.BOTCQ==.TOPCQ+1
	.TOPFQ==.BOTCQ+1
	.BOTFQ==.TOPFQ+1
	.JBUFF==.BOTFQ+1	;Note, this field is null for the event and DMA
				;  queues

	QLEN==.JBUFF+1
	SUBTTL	Block formats -- Configuration data block

; He we find the format of the data returned by a call to SC.RCD.
;
;        +=======================================================+
; .RDSTS !   Virtual circuit state   !        Port number        !
;        !-------------------------------------------------------!
; .RDSYS \							 \
;        \      System address (6 8-bit bytes, word aligned)     \
;	 \							 \
;        !-------------------------------------------------------!
; .RDMDG !           Maximum destination datagram size           !
;        !-------------------------------------------------------!
; .RDMMS !           Maximum destination message size            !
;        !-------------------------------------------------------!
; .RDDST !               Destination software type               !
;	 !-------------------------------------------------------!
; .RDDSV !             Destination software version              !
;	 !-------------------------------------------------------!
; .RDDSI \                                                       \
;        \           Destination software incarnation            \
;	 !-------------------------------------------------------!
; .RDDHT !               Destination hardware type               !
;	 !-------------------------------------------------------!
; .RDDHV \             Destination hardware version              \
;        \                                                       \
;        \                                                       \
;	 !-------------------------------------------------------!
; .RDNNM \               Destination port name                   \
;        \                                                       \
;	 !-------------------------------------------------------!
; .RDPCH !            Destination Port Characteristics           ! 
;        !-------------------------------------------------------! 
; .RDPRL !          Destination Port Code Revision Level         !
;        !-------------------------------------------------------!
; .RDPFC !             Destination Port Functionality            !
;        !-------------------------------------------------------!
; .RDPST !                Destination Port State                 !
;	 +=======================================================+

	.RDSTS==0		;Virtual circuit state and port number
	.RDSYS==.RDSTS+1	;System address
	.RDMDG==.RDSYS+2	;Maximum size datagram destination accepts
	.RDMMS==.RDMDG+1	;Maximum size message destination accepts
	.RDDST==.RDMMS+1	;Destination software type
	.RDDSV==.RDDST+1	;Destination software version
	.RDDSI==.RDDSV+1	;Destination software incarnation
	.RDDHT==.RDDSI+2	;Destination hardware type
	.RDDHV==.RDDHT+1	;Destination hardware version
	.RDNNM==.RDDHV+3	;Destination port name
	.RDPCH==.RDNNM+2	;Destination port characteristics
	.RDPRL==.RDPCH+1	;Destination port code revision level
	.RDPFC==.RDPRL+1	;Destination port functionality
	.RDPST==.RDPFC+1	;Destination port state

	.RDLEN==.RDPST+1	;Define the length of all this

	MSKSTR (RDVCST,<.RDSTS>,<-1,,0>) ;Virtual circuit state
	MSKSTR (RDPORT,<.RDSTS>,<0,,-1>) ;Port number
	MSKSTR (RDMDG,<.RDMDG>,<-1>)	 ;Max destination datagram size
	MSKSTR (RDMMS,<.RDMMS>,<-1>)	 ;Max destination message size
	MSKSTR (RDDST,<.RDDST>,<-1>) 	 ;Dest software type
	MSKSTR (RDDSV,<.RDDSV>,<-1>)	 ;Dest software version
	MSKSTR (RDDHT,<.RDDHT>,<-1>) 	 ;Dest hardware type
	MSKSTR (RDDHV,<.RDDHV>,<-1>) 	 ;Dest hardware version

	SUBTTL	Block formats -- System wide maintainance data wait queue

; This queue's sole purpose in life is to associate a buffer name with a
;connect block address. When a maint transfer is requested, a phoney CB
;is created and linked onto the SB lists of the target system. This CB
;allows the JSYS code to use the normal notification mechanism when the
;request completes.
;
; Note that there is a CB for every transfer regardless of the fact that this
;will result in many CBs for the transfers of one fork.
;
;	 !=======================================================!
; .MQNXT !              Address of next queue entry              !
;	 !-------------------------------------------------------!
; .MQBUF !                      Buffer name                      !
;	 !-------------------------------------------------------!
; .MQCBA !                 Connect block address                 !
;	 !=======================================================!
;
	.MQNXT==0		;Address of next entry
	.MQBUF==.MQNXT+1	;Buffer name for maint data transfer
	.MQCBA==.MQBUF+1	;Address of CB for this transfer

	.MQLEN==.MQCBA+1	;Length of this block
	SUBTTL	Block formats -- Connection state data

; Here we find the format of the data returned by a call to the connection
;state update stuff.
;
;	 !=======================================================!
; .CDCST !                   Connection state                    !
;	 !-------------------------------------------------------!
; .CDDCI !                Destination Connect ID                 !
;	 !-------------------------------------------------------!
; .CDDPN \							 \
;        \               Destination process name                \
;	 \							 \
;	 !-------------------------------------------------------!
; .CDNOD !                   Destination node                    !
;	 !-------------------------------------------------------!
; .CDREA ! Source disconnect reasons !  Dest disconnect reasons  !
;	 !=======================================================!
;
	.CDCST==0		;Connection state
	.CDDCI==.CDCST+1	;Destination connect ID
	.CDDPN==.CDDCI+1	;Destination process name
	.CDNOD==.CDDPN+4	;Node number
	.CDREA==.CDNOD+1	;Disconnect reasons

	.CDLEN==.CDREA+1	;Length of this block

	MSKSTR (CDCST,<.CDCST>,<-1>) ;Connection state
	MSKSTR (CDDCI,<.CDDCI>,<-1>) ;Destination connect ID
	MSKSTR (CDNOD,<.CDNOD>,<-1>) ;Destination node number
	MSKSTR (CDSREA,<.CDREA>,<-1,,0>) ;Source disconnect reasons
	MSKSTR (CDDREA,<.CDREA>,<0,,-1>) ;Destination disconnect reasons

	SUBTTL	Block formats -- JSYS packet buffer "invisible data area"

; The following is the format of the "invisible data area" appearing before
;every SCA provided buffer.
;
;	 !=======================================================!
;-C%BINV \                                                       \
;	 \                       Reserved                        \
;	 \                                                       \
;	 !-------------------------------------------------------!
; .JHFLG !	 		  Flags	 			 !
;	 !-------------------------------------------------------!
; .JHAUB !      Address of user buffer data was copied from      !
;	 !-------------------------------------------------------!
; Word 0 \                                                       \
;	 \                  Port driver header                   \
;	 \                                                       \
;	 !-------------------------------------------------------!
;	 \                                                       \
;	 \                      SCA header                       \
;	 \                                                       \
;	 !-------------------------------------------------------!
;	 \                                                       \
;	 \                      Packet text                      \
;	 \                                                       \
;	 !=======================================================!
;
; Note that word zero is the word pointed to whenever an address for this
;buffer is passed. C%BINV is the size of the invisible data area, and
;.JHAUB is the JSYS' pointer to the user buffer associated with this monitor
;buffer.
;
	.JHAUB==-1		;Address of user buffer
	.JHFLG==-2		;Flags
		MSKSTR (JH%DGB,<.JHFLG>,<400000,,0>) ;Datagram buffer flag
	SUBTTL	Block formats -- JSYS Buffer list descriptor block

; The following box describes the format of the buffer list descriptor blocks
;used by the JSYS code to maintain a list of buffers queued by the user. 
;
;	 !=======================================================!
; .BDNXT !                  Address of next BSD                  !
;	 !-------------------------------------------------------!
; .BDPRE !                Address of previous BSD                !
;	 !-------------------------------------------------------!
; .BDFFD !      Address of first free entry within this BSD      !
;	 !-------------------------------------------------------!
; .BDLFD !      Address of last free entry within this BSD       !
;	 !-------------------------------------------------------!
; .BDFMG !	   Address of first message buffer entry	 !
;	 !-------------------------------------------------------!
; .BDLMG !	   Address of last message buffer entry		 !
;	 !-------------------------------------------------------!
; .BDFDG !        Address of first datagram buffer entry	 !
;	 !-------------------------------------------------------!
; .BDLDG !        Address of last datagram buffer entry          !
;	 !-------------------------------------------------------!
; .BDBDB \                                                       \
;	 \                                                       \
;	 \               Buffer descriptor blocks                \
;	 \                                                       \
;	 \                                                       \
;	 !=======================================================!
;
	.BDNXT==0		;Address of next buffer segment descrip block
		MSKSTR (BDNXT,<.BDNXT>,<-1>)

	.BDPRE==.BDNXT+1	;Address of previous buffer segment desc block
		MSKSTR (BDPRE,<.BDPRE>,<-1>)

	.BDFFD==.BDPRE+1	;Address of first free block
		MSKSTR (BDFFD,<.BDFFD>,<-1>)

	.BDLFD==.BDFFD+1	;Address of last free block
		MSKSTR (BDLFD,<.BDFFD>,<-1>)

	.BDFMG==.BDLFD+1	;Address of first message buffer block
		MSKSTR (BDFMG,<.BDFMG>,<-1>)

	.BDLMG==.BDFMG+1	;Address of the last message buffer block
		MSKSTR (BDLMG,<.BDLMG>,<-1>)

	.BDFDG==.BDLMG+1	;Addr of first datagram buffer block
		MSKSTR (BDFLD,<.BDFLD>,<-1>)

	.BDLDG==.BDFDG+1	;Addr of last datagram buffer block
		MSKSTR (BDLLD,<.BDLLD>,<-1>)

	.BDBDB==.BDLDG+1	;Offset to first buffer descriptor block

;Note: List BLINKs must all be the same number of words from the list FLINK if
;SCSLUB is going to work. This offset (in words) between ALL list FLINKs to the
;list BLINKs is here defined.
;
	.BDF2B==1		;Offset from list FLINKs to list BLINKs

; Buffer descriptor block
;
;	 !=======================================================!
; .BBNXT !	            Next block in list			 !
;	 !-------------------------------------------------------!
; .BBUVA !                 User virtual address                  !
;	 !=======================================================!
;
	.BBNXT==0		;Next block in list
		MSKSTR (BBNXT,<.BBNXT>,<-1>)

	.BBUVA==.BBNXT+1	;User virtual address
		MSKSTR (BBUVA,<.BBUVA>,<-1>)

	.BBLEN==.BBUVA+1	;Length of an entry

	C%NBSD==<C%DGSZ-.BDBDB>/<.BBLEN+1>
	SUBTTL	Block formats -- Named buffer list block

; The following is the format of an entry on the SCS% JSYS named buffer list.
;The list is used to keep track of the buffer names associated with a fork.
;Since they are only associated with a fork (and not a CB) the list pointers
;are only kept in the PSB (SCSTXN/SCSBXN). Resident free space is used for the
;entries.
;
;	 !=======================================================!
; .XNNXT !                 Address of next entry                 !
;	 !-------------------------------------------------------!
; .XNPRV !               Address of previous entry               !
;	 !-------------------------------------------------------!
; .XNNAM !                      Buffer name                      !
;	 !-------------------------------------------------------!
; .XNSTK !     Address of datagram buffer containing page stack	 !
;	 !=======================================================!
;
; Note:
;Many routines depend on .XNNXT being word zero of the entry.
;
	.XNNXT==0		;Address of next entry
		MSKSTR (XNNXT,<.XNNXT>,<-1>)
	.XNPRV==.XNNXT+1	;Address of previous entry
		MSKSTR (XNPRV,<.XNPRV>,<-1>)
	.XNNAM==.XNPRV+1	;Buffer name
		MSKSTR (XNNAM,<.XNNAM>,<-1>)
	.XNSTK==.XNNAM+1	;Page stack address
		MSKSTR (XNSTK,<.XNSTK>,<-1>)

	.XNLEN==.XNSTK+1	;Length of an entry
	SUBTTL	Block formats -- Map descriptor block

; The following is the format of the descriptor block handed to SC.MAP
;as an arg...
;
;
;	 !=======================================================!
; .MDNXT !    Address of next buffer in chain or zero if none    !
;	 !-------------------------------------------------------!
; .MDFLG !			   Flags			 !
;	 !-------------------------------------------------------!
; .MDSSD !               Length of buffer segment 0              !
;	 !-------------------------------------------------------!
;	 !            Physical address of the segment 0          !
;	 !-------------------------------------------------------!
; 	 \                                                       \
;	 \                                                       \
;	 \                segment descriptor pairs               \
;	 \                                                       \
;	 \                                                       \
;	 !-------------------------------------------------------!
;	 !               Length of buffer segment #n             !
;	 !-------------------------------------------------------!
; 	 !            Physical address of the segment #n         !
;	 !-------------------------------------------------------!
;	 !         		     0				 !
;	 !=======================================================!
;
	.MDNXT==0		;Link to next descriptor block
	.MDFLG==.MDNXT+1	;Flags word
		MSKSTR (MD%FLG,<>,<17B35>) ;Mask of defined flag values
		MSKSTR (MD%DMD,<>,<SQ%DMD>) ;Mask for mode value
			 MD%DIC==SQ%DIC	;Industry compatable mode
			 MD%DCD==SQ%DCD	;Core dump mode (Unsupported)
			 MD%DHD==SQ%DHD	;High density mode
			 MD%ILL==SQ%ILL	;The dissallowed value
;THE FOLLOWING TWO DEFINITIONS ARE DEFINED IN MONSYM. ENTERED HERE
;FOR REFERENCE.
;		SQ%CVD==:1B32	;DO NOT CLEAR VALID BIT
;		SQ%WRT==:1B33	;ALLOW WRITING OF BUFFER
	.MDSSD==.MDFLG+1	;START OF SEGMENT DESCRIPTORS
	.MDLSD==2		;LENGTH OF SEGMENT DESCRIPTORS

	.MDLEN==0		;First word of desc block, length of segment
	.MDADR==1		;Address of segment
	SUBTTL	Block formats -- Common queue header

; The following defines the portion of the queue entry header that is common
;to all queues (message, datagram, DMA, and event queues).
;
; 	 !=======================================================!
; .MEANC !       Pointer to next entry for this connection       !
; 	 !-------------------------------------------------------!
; .MEAPC !     Pointer to previous entry for this connection	 !
; 	 !-------------------------------------------------------!
; .MEANF !	     Pointer to next entry for this fork	 !
; 	 !-------------------------------------------------------!
; .MEAPF !         Pointer to previous entry for this fork	 !
;	 !-------------------------------------------------------!
; .MEFRK !      Length of packet    !         Fork number	 !
;	 !-------------------------------------------------------!
; .METYP !	     Flags	    !	    Entry type code	 !
;	 !-------------------------------------------------------!
; .MECID !			Connect ID			 !
; 	 !=======================================================!
;
	.MEANC==0		;Offset to the pointer to next entry word
	.MEAPC==.MEANC+1	;Address of previous entry for this connection
	.MEANF==.MEAPC+1	;Addr of next entry for this fork
	.MEAPF==.MEANF+1	;Addr of previous entry for this fork
	.MEFRK==.MEAPF+1	;Target fork number
		MSKSTR (MEFRK,<.MEFRK>,<0,,-1>)	;Mask for target fork number
		MSKSTR (MELEN,<.MEFRK>,<-1,,0>)	;Mask for packet length

	.METYP==.MEFRK+1	;Flags and block type
		MSKSTR (MEFLG,<.METYP>,<-1,,0>) ;Mask for flag bits

		MSKSTR (METYP,<.METYP>,<0,,-1>)	;Mask for entry type code
			.ETMSG==1 ;Entry type - Message buffer
			.ETDG==2  ;Entry type - Datagram buffer
			.ETEVT==3 ;Entry type - Event block
			.ETDMA==4 ;Entry type - DMA completion notice
			;Warning, if you change an event type code, be sure to 
			;change PSIXCT in SCSJSY as well...

	.MECID==.METYP+1	;CID this entry is for
		MSKSTR (MECID,<.MECID>,<-1>) ;Mask for CID
	SUBTTL	Block formats -- Event code block header

; The following is the definition of the event queue header appended to the end
;of the common queue header.
;
;	 !=======================================================!
;	 \							 \
;	 \	     Fork and connection list pointers,		 \
;	 \	and target fork words identical to those used	 \
;	 \         for JSYS message and datagram queues		 \
;	 \							 \
;	 !-------------------------------------------------------!
; .EBCOD !      Length of block      !        Event code         !
;	 !-------------------------------------------------------!
; .EBDAT \                                                       \
;	 \                      Event data                       \
;	 \                                                       \
;	 !=======================================================!
;
	.EBCOD==.MECID+1	;LH = Length of block (including this word)
				;RH = Event code 
		MSKSTR (EBLEN,<.EBCOD>,<-1,,0>)	;Mask for length of block
		MSKSTR (EBCOD,<.EBCOD>,<0,,-1>)	;Mask for event code

	.EBDAT==.EBCOD+1	;Start of code dependant data area of block
	SUBTTL	Block formats -- DMA queue header

; The following defines the header appended to the common header for use
;on the DMA queue.
;
;	 !=======================================================!
; .DMNAM !		   32 bit buffer name			 !
;	 !=======================================================!
;
	.DMNAM==.MECID+1	;Name of buffer whos operation completed

	.DMLEN==.DMNAM+1	;Length of this block

	SUBTTL	Block formats -- SCA ring buffer entry

;The following is the format of an SCA ring buffer entry:
;
;         +=======================================================+
; .REHED  !                Entry header (-77,,-77)                !
;         !-------------------------------------------------------!
; .REECL  !        Event code         !      Length of entry      !
;         !-------------------------------------------------------!
; .REJRL  !                 Jacket routine label                  !
;         !-------------------------------------------------------!
; .REFRL  !                 Feature routine label                 !
;         !-------------------------------------------------------!
; .REPCC  !            PC of caller to feature routine            !
;         !-------------------------------------------------------!
; .RETOD  !                        TODCLK                         !
;         !-------------------------------------------------------!
; .REFEA  \                                                       \  
;         \                 Feature specific data                 \  
;         \                                                       \
;         !-------------------------------------------------------!
; .RESTR  !            Address of start of this entry             !
;         +=======================================================+
;
; The symbols given are not offsets into the entire ring buffer. They are 
;offsets into a particular ring buffer entry. The pointer to the current
;ring buffer position is stored in RNGADR and the address of the most recent
;ring buffer entry is stored in RNGCUR.  The top of the ring buffer is 
;stored in RNGTOP and the bottom address is in RNGBOT.  The total number
;of entries written is in RNGNUM and the total size of the ring buffer is
;in RNGSIZ.
;
; The format of the feature specific data for each defined ring buffer 
;entry type follows.

	.REHED==:0		;Start of ring buffer entry
		MSKSTR(RNGHED,.REHED,<-1>)
		RNG%HC==:<-77,,-77>  ;Ring header constant value

	.REECL==:.REHED+1	;Event code and length of entry
		MSKSTR(RNGEVC,.REECL,<-1,,0>) ;Event code
		MSKSTR(RNGLEN,.REECL,<0,,-1>) ;Length of entry

	.REJRL==:.REECL+1	;Lable of jacket routine

	.REFRL==:.REJRL+1	;Label of feature routine

	.REPCC==:.REFRL+1	;PC of caller to feature routine

	.RETOD==:.REPCC+1	;Time of day of entry

	.REFEA==:.RETOD+1	;Start of feature data

;Note:  The following symbol is defined as an offset from the start of
;	the next buffer entry.  So, if T1 contains the address of the 
;	start of the next buffer entry:
;
;		.RESTR(T1) is the address of the start of the previous entry

	.RESTR==:-1		;Start of this entry

;Adjusted for TOPS-20 development
	RBFLEN==:60		;[8810] Ring buffer size in pages

;Below are the structure names which control which event will be recorded
;in the ring buffer.  RNGSW controls which events are recorded.

	MSKSTR(RSYSCA,RNGSW,<1B0>) ;Record SYSAP to SCA events
	MSKSTR(RSCASY,RNGSW,<1B1>) ;Record SCA to SYSAP events (callbacks)
	MSKSTR(RBUFMG,RNGSW,<1B2>) ;Record buffer management events
	MSKSTR(RPACKT,RNGSW,<1B3>) ;Record packet events (outgoing and incoming)
	MSKSTR(RPITRN,RNGSW,<1B4>) ;Record PI transitions
	MSKSTR(RPRTQU,RNGSW,<1B5>) ;Record port queue events
	MSKSTR(RINTLK,RNGSW,<1B6>) ;Record interlocks

;Following are the valid event codes for the events which can be recorded:

	SYSSCA==1		;SYSAP to SCA events
	SCASYS==2		;SCA to SYSAP
	BUFMAN==3		;Buffer manipulation
	PKTEVT==4		;Packet transaction
	PITRAN==5		;PI transition
	PORTQU==6		;Port queue manipulation
	INTLOK==7		;Interlocks

	EN%CLO==1		;Smallest valid event code
	EN%CHI==7		;Largest valid event code

	SUBTTL	Block formats -- SCA ring buffer entry -- Feature data (SYSSCA)

; Below is the format of the feature specific data
;for the SYSAP to SCA ring buffer entry.
;
;	  +=======================================================+
; .RESNN  !                      Node number                      !
;	  !-------------------------------------------------------!
; .RESCB  !                 Connect block address                 !
;	  !-------------------------------------------------------!
; .RESST  !          .CBSTS (Block state,,Connect state)          !
;	  !-------------------------------------------------------!
; .RESFL  !                        .CBFLG                         !
;	  !-------------------------------------------------------!
; .RESSI  !              .CBSCI (Source connect ID)               !
;	  !-------------------------------------------------------!
; .RESDI  !            .CBDCI (Destination connect ID)            !
;	  +=======================================================+

	.RESNN==:.REFEA		;Node number

	.RESCB==:.RESNN+1	;Connect block address

	.RESST==:.RESCB+1	;Connect block state word

	.RESFL==:.RESST+1	;Connect block flag word

	.RESSI==:.RESFL+1	;Source connect ID

	.RESDI==:.RESSI+1	;Destination connect ID

	SUBTTL	Block formats -- SCA ring buffer entry -- Feature data (SCASYS)

; Below is the format of the feature specific data
;for the SCA to SYSAP (callback) ring buffer entry.
;
;  	  +=======================================================+
; .RECNN  !                      Node number                      !
;	  !-------------------------------------------------------!
; .RECCB  !                 Connect block address                 !
;	  !-------------------------------------------------------!
; .RECCR  !                 Callback reason code                  !
;	  +=======================================================+

	.RECNN==:.REFEA		;Node number

	.RECCB==:.RECNN+1	;Connect block address

	.RECCR==:.RECCB+1	;Callback reason code

	SUBTTL	Block formats -- SCA ring buffer entry -- Feature data (BUFMAN)

; Below is the format of the feature specific data
;for the buffer manipulation ring buffer entry.
;
;  	  +=======================================================+
; .REBCT  !    # of Buffers, or refused count, or -1 if returned  !
;         !-------------------------------------------------------!
; .REBAD  !     Address of 1st buffer or -1 if can't allocate     !
;         !-------------------------------------------------------!
; .REBMC  !    FQCNT (number of buffers on message free queue)    !
;         !-------------------------------------------------------!
; .REBMT  !     TOPFQ (pointer to top of message free queue)      !
;         !-------------------------------------------------------!
; .REBMB  !    BOTFQ (pointer to bottom of message free queue)    !
;	  !-------------------------------------------------------!
; .REBDC  !   DFQCNT (number of buffers on datagram free queue)   !
;         !-------------------------------------------------------!
; .REBDT  !    TOPDFQ (pointer to top of datagram free queue)     !
;	  !-------------------------------------------------------!
; .REBDB  !   BOTDFQ (pointer to bottom of datagram free queue)   !
;         +=======================================================+
;
; The .REBCT word can contain one of three values.  If the buffer is being
;returned, it will contain a -1.  If the buffer is being created or allocated
;and it has been obtained successfully, .REBCT will contain the number of
;buffers.  If the allocation was not successfull, then .REBCT will contain 
;the number of refused requests (RMRCNT for messages, RDRCNT for datagrams).
;Also, on an unsuccessfull allocation attempt, the .REBAD word will contain 
;-1 since no buffer was allocated.  Otherwise, this word will always contain 
;a buffer address.  It will be either the address of a newly created/allocated
;buffer chain or the address of a buffer just returned.

	.REBCT==:.REFEA		;Buffer count

	.REBAD==:.REBCT+1	;Buffer address

	.REBMC==:.REBAD+1	;Count of buffers on message free queue

	.REBMT==:.REBMC+1	;Pointer to top of message free queue

	.REBMB==:.REBMT+1	;Pointer to bottom of message free queue

	.REBDC==:.REBMB+1	;Count of buffers on datagram free queue

	.REBDT==:.REBDC+1	;Pointer to top of datagram free queue

	.REBDB==:.REBDT+1	;Pointer to bottom of datagram free queue

	SUBTTL	Block formats -- SCA ring buffer entry -- Feature data (PKTEVT)

; Below is the format of the feature specific data
;for the packet transaction ring buffer entry.
;
; 	  +=======================================================+
; .REPNN  !                      Node number                      !
;	  !-------------------------------------------------------!
; .REPCB  !                 Connect block address                 !
;	  !-------------------------------------------------------!
; .REPAD  !                    Packet address                     !
;	  !-------------------------------------------------------!
; .REPFL  !                         Flags                         !
;	  !-------------------------------------------------------!
; .REPMP  !     Message priority      !       Packet length       !
;	  !-------------------------------------------------------!
; .REPTY  !             MH$TYP (credit,,message type)             !
;	  !-------------------------------------------------------!
; .REPSI  !              MH$SCI (Source connect ID)               !
;	  !-------------------------------------------------------!
; .REPDI  !            MH$DCI (Destination connect ID)            !
;	  +=======================================================+
;
; The flags word will contain the PPD flag bits (F.RTB, F.SPM, F.RSP).
;It tells you whether the packet was locally or remotely generated (F.RSP)
;which indicates which connect ID is the one from the local system.  The 
;mode of the packet is indicated by F.SPM.
;
; The message priority is the priority of the packet and ranges from a high
;priority of 0 to a low of 3.

	.REPNN==:.REFEA		;Node number

	.REPCB==:.REPNN+1	;Connect block address

	.REPAD==:.REPCB+1	;Packet address

	.REPFL==:.REPAD+1	;Packet flags

	.REPMP==:.REPFL+1	;Message priority,,packet length

	.REPTY==:.REPMP+1	;MH$TYP word from packet header

	.REPSI==:.REPTY+1	;MH$SCI word from packet header

	.REPDI==:.REPSI+1	;MH$DCI word from packet header

	SUBTTL	Block formats -- SCA ring buffer entry -- Feature data (PITRAN)

; Below is the format of the feature specific data
;for the PI transition ring buffer entry.
;
; 	  +=======================================================+
; .REPIC  !                        CHNCTL                         !
;	  !-------------------------------------------------------!
; .REPIF  !                        PIFLAG                         !
;	  +=======================================================+

	.REPIC==:.REFEA		;Value of CHNCTL

	.REPIF==:.REPIC+1	;Value of PIFLAG

	SUBTTL	Block formats -- SCA ring buffer entry -- Feature data (PORTQU)

; Below is the format of the feature specific data
;for the port queue manipulation ring buffer entry.
;
;	  +=======================================================+
; .REPQN  !                      Node number                      !
;	  !-------------------------------------------------------!
; .REPQF  !           Flags           !       Buffer count        !
;	  !-------------------------------------------------------!
; .REPQB  !                    Buffer address                     !
;	  +=======================================================+
;
; The .REPQF word contains flags in the left half.  If the RPQFLK bit is 
;lit, then a buffer was linked to the port queue.  Otherwise, a buffer 
;was unlinked from the port queue.  If the RPQFMG flag is lit, then the 
;buffer was a message buffer.  Otherwise, it was a datagram buffer.
;If the buffer is being unlinked from the port queue, and it fails, the 
;.REPQM word will be -1.

	.REPQN==:.REFEA		;Node number

	.REPQF==:.REPQN+1	;Flags,,buffer count
		MSKSTR(RPQFLK,.REPQF,<400000,,0>)  ;Link to port queue
		MSKSTR(RPQFMG,.REPQF,<200000,,0>)  ;Message free queue used

	.REPQB==:.REPQF+1	;Buffer address

	SUBTTL	Block formats -- SCA ring buffer entry -- Feature data (INTLOK)

; Below is the format of the feature specific data
;for the interlock ring buffer entry.
;
;	  +=======================================================+
; .REICB  !                 Connect block address                 !
;	  !-------------------------------------------------------!
; .REICL  !           Connect block lock value (.CBLCK)           !
;	  !-------------------------------------------------------!
; .REIFL  !             Connect block flags (.CBFLG)              !
;	  !-------------------------------------------------------!
; .REISL  !    Count of locked connect blocks on system block     !
;	  +=======================================================+

	.REICB==:.REFEA		;Connect block address

	.REICL==:.REICB+1	;Connect block lock value

	.REIFL==:.REICL+1	;Connect block flags word

	.REISL==:.REIFL+1	;Count of locked connect blocks for s.b.
				; when node goes off-line.

	SUBTTL	OPDEFs

	DEFINE $SKIP,<CAIA>	;Define the fastest SKIP_ALWAYS...
	DEFINE CIOFF,<CALL SC.PFF> ;[7.1037]Do this to turn off the CI channel
	DEFINE CION,<CALL SC.PON>  ;Do this to turn the CI channel back on

	OPDEF XCTB17 [XCT 17,]	;PXCT for getting EVERYTHING from user context

	SUBTTL	Random constants

	KLPCHN==7		;The KLIPA is always on channel 7

;All random constants used localy by SCA are defined here...

	PGSIZ==1000		;Length of a page

	C%BINV==^D11		;Size of invisible space before all buffers


	C%MGSZ==^D52		;Size of message buffer (words)
	C%MGPG==PGSIZ/<C%MGSZ+C%BINV> ;The number of message buffers in a page
	C%DGSZ==^D158		;Size of datagram buffers (words)
	C%DGPG==PGSIZ/<C%DGSZ+C%BINV> ;Number of datagram buffers in a page

;Interval for SCA clock (Clock granularity: 100ms)
;Calculated as:
;<Num of seconds to timeout * num of millisec in one sec> + rounding factor
;----------------------------------------------------------------------------
;		       number of cycles before timeout
;
	C%STIM==<<5*1000>+<C%SBLL-1>>/C%SBLL 

	C%OVHD==^D12		;Overhead byte count for application msg/dg
	C%OVHW==^D3		;Overhead word count for application msg/dg
	C%PPDL==2		;Length in bytes of PPD field
	C%MXBF==^D100		;Max num in 1 Q req for JSYS buffers
	C%RAPT==^D10*^D1000	;Min tim increment bewteen CB reaping runs
	C%ALMT==^D60*^D1000	;Min time increment for memory allocator runs
	C%PHAD==77,,777777	;Physical memory address mask from MAP instr
	C%PHYZ==777700,,0	;Bits to zero in physical addresses
	C%NEPW==^D5		;# of index entries per word, list index ptrs
	C%OBPP=^D12		;# of overhead bytes in application packet
	C%MRBL==^D50		;Length of list pointer tables
	C%CIDL==<PGSIZ/2>	;Length of table for connect ID's
	C%SYMX==^D16		;Highest CI node number

	C%SBLL==<C%SYMX>	;Length of the system block address list
				;Note: If this value changes, SQ%SBL 
				;in MONSYM must also be changed

	C%IND==<1B1>		;Indirect address bit for noninstruction format
	C%DTAL==^D16		;Number of bytes in connection data

	C%DTLW==^D4		;Length of connection data in words
				;Note: If this value changes, SQ%CDT 
				;in MONSYM must also be changed

	C%PNMN==^D16		;Maximum number of bytes in a process name
	C%PNLW==^D4		;Length of process name in words
	C%CDMN==^D16		;Maximum number of bytes in connect data
	C%SDTL==^D16		;Send data length (In bytes)
	C%STRL==<<<C%PNMN+3>/4>*2>+<<C%DTAL+3>/4> ;Word Len past three strings
	C%BYTM==<C%MGSZ+3>*4	;Size of max message in bytes
	C%WORM==C%MGSZ		;Size of max message in words
	C%BYTD==<C%DGSZ+3>*4	;Size of max datagram in bytes
	C%WORD==C%DGSZ		;Size of max datagram in words
	C%JDGL==1000		;Length of datagram buffers for JSYS (in words)
	C%NPSI==<0,,-1>		;The "null" PSI channel (for the JSYS)
	FWMASK==-1		;Keep the $BUILD macro happy
	SECMSK==777740,,0	;These should always be off in a section number
	.ICLST==^D35		;Highest valid PSI channel value

; **** Temporary ****
;These symbols are reproduced here since the currently apear only in PHYKLP.

	MSKSTR (IDPAO,<RIDSTS>,<1B1>) ;Path A status
	MSKSTR (IDPBO,<RIDSTS>,<1B2>) ;Path B status

; Lengths of event queue blocks (for the JSYS)
;
	C%VCCL==.EBCOD+2	;VC broken
	C%CTLL==.EBCOD+5	;Connect to listen 
	C%CRAL==.EBCOD+5	;Connection accept 
	C%CRRL==.EBCOD+2	;Connection reject 
	C%MSCL==.EBCOD+2	;Message/datagram send complete 
	C%LCLL==.EBCOD+2	;Little credit left 
	C%NCOL==.EBCOD+2	;Net topology change
	C%OSDL==.EBCOD+1	;OK to send data 
	C%RIDL==.EBCOD+1	;Remote initiated disconnect 
	C%PBCL==.EBCOD+2	;Port broke connection
	C%CIAL==.EBCOD+3	;Credit is available
	C%MDCL==.EBCOD+2	;Maint data xfer complete

; These constants tweek the buffer managment parameters. They control threshold
;and other factors that could VERY significantly effect SCA performance.
;
	C%MBPS==C%MGPG		;Number of message buffers per SB for 
	C%MBCR==^D2		;Number of message buffers to queue before
				;sending a credit request about them

	C%MGTR==<C%SBLL*2>+^D10	;Threshold for message buffers, if we have less
				;  than this at allocate time, call job 0
	C%DGTR==C%SBLL+^D20	;Threshold for DG buffers, fewer than this at
				;  allocate time and we call job 0 for more
	C%DBPS==C%DGPG*2	;Number of datagram buffers per SB for thresh


	C%LGRQ==3		;A buffer request larger than this is a large
				; request and will not be honored if it puts us
				; under threshold

; The following are symbols which tweek the initial values for idle chatter.
;
	C%TMGT==^D5*^D1000	;Make the initial timeout period be 5 seconds
	SUBTTL	Macros

	SUBTTL	Macros -- $LDCID (Load a CB address)

; This macro is the result of much pain over the obtaining of connect block
;address from a given connect ID.
;

	DEFINE $LDCID(AC,ADDR),<

	LOAD AC,INDEX,ADDR	;Get the index from the CID source
	ADD AC,CIDTAB		;Add the base address of the CB address table
	MOVE AC,(AC)		;Now get the address of the CB

>;End $LDCID definition
	SUBTTL	Macros -- ASCI8 (Generate word aligned 8-Bit ASCII)

; This macro will generate word aligned 8-Bit ASCII. Simply feed it the string
;and out comes 8 bit ASCII, four bytes per word...
;
DEFINE ASCI8(STRNG),<

	..CNT.==3		;Init the counter
	..STR.==0		;Init the string

IRPC STRNG,<

	..CHR.=="STRNG"		;Get the current character
	..CHR.==..CHR._<^D8*..CNT.+4> ;Shift it into the right place
	..STR.==..STR.!..CHR.	;Add it to the current
	..CNT.==..CNT.-1	;Decrement the four word block counter

IFL ..CNT.,<
	EXP ..STR.		;Generate a word of what is left
	..CNT.==3		;Init the four char chunk counter
	..STR.==0		;Init the string
>;End IFL ..CNT.

>;End IPRC STRNG

IFN ..STR.,	EXP ..STR.	;If there are characters left over, output them

>;End ASCI8 definition	
	SUBTTL	Macros -- $SCOFF (Get SCA disconnect interlock)

; This macro interlocks the completion of SCA disconnect processing. If this
;lock is set then interrupt level will defer the sending of the second half of 
;the disconnect protocol.
;
	DEFINE $SCOFF,<
;	CALL SC.OFF		;Turn off disconnect processing
>;End of $SCOFF definition

	SUBTTL	Macros -- $SCON (Release SCA disconnect processing)

; This macro release the interlock on SCA disconnect processing.
;
	DEFINE $SCON,<
;	CALL SC.ON		;Release the disconnect interlock
>;End of $SCON definition
	SUBTTL	Macros -- $SYSAP (SYSAP initilization address table)

; This macro generates the table of addresses that SCA uses to init all of
;the SYSAPs...
;
	DEFINE $SYSAP,<

	XWD MSEC1,CFSINI##	;Init the Common file system
	XWD MSEC1,MSCINI##	;Init MSCP
	XWD MSEC1,MSSINI	;Init the MSCP server
	XWD XCDSEC,SCSINI	;[7.1043]Init the SCS% JSYS SYSAP
	XWD XCDSEC,CLUINI	;[7.1076] Init CLUDGR SYSYAP
   IFN CLEQIN,<			;[7.1072] If cluster ENQ code present
	XWD XCDSEC,EQSINI	;[7.1072] Init the ENQSRV SYSAP
   >				;[7.1072]

>;End $SYSAP definition
	SUBTTL	Macros -- $CALTB (Dispatch table for SCA to JSYS calls)

; This macro defines the dispatch table to handle calls from SCA to the SYSAP
;know as the SCS% JSYS...
;
	DEFINE $CALTB,<

	$BUILD (.SSAFT+1)	;Size of the block

	$SET (.SSDGR,,<XCDSEC,,SINDGR>)	;[7.1043]Datagram received
	$SET (.SSMGR,,<XCDSEC,,SINMGR>)	;[7.1043]Message received
	$SET (.SSPBC,,<XCDSEC,,SINPBC>)	;[7.1043]Port broke connection
	$SET (.SSCTL,,<XCDSEC,,SINCTL>)	;[7.1043]Connect to listen
	$SET (.SSCRA,,<XCDSEC,,SINCRA>)	;[7.1043]Connect response available
	$SET (.SSMSC,,<XCDSEC,,SINPSC>)	;[7.1043]Message/datagram send complete
	$SET (.SSDDG,,<MSEC1,,R>) 	;Datagram dropped
	$SET (.SSLCL,,<XCDSEC,,SINLCL>)	;[7.1043]Little credit left
	$SET (.SSNCO,,<MSEC1,,R>)	;Node came online
	$SET (.SSOSD,,<XCDSEC,,SINOSD>)	;[7.1043]OK to send data
	$SET (.SSRID,,<XCDSEC,,SINRID>)	;[7.1043]Remote initiated disconnect
	$SET (.SSCIA,,<XCDSEC,,SINCIA>)	;[7.1043]Credit is available
	$SET (.SSDMA,,<XCDSEC,,SINDMA>)	;[7.1043]DMA complete

	$EOB

>; End $CALTB definition
	SUBTTL	Macros -- $DISPA (Dispatch table generator)

; This macro defines the order for the message/datagram dispatch table.
;When a message is received, one simply indexes into this routine to find the
;address of the routine to handle said message. Care must be taken here to
;be sure that this table is in the correct order. The table is built in the 
;order that entries appear here. The offsets are given to make sure that
;things happen in the right order.
;
	DEFINE $DISPA,<

	...FOO==0		;Init the order checker variable

	$ENT (.STORQ,SC.ORQ)	;Connect request
	$ENT (.STORS,SC.ORS)	;Connect response
	$ENT (.STARQ,SC.ARQ)	;Accept request
	$ENT (.STARS,SC.ARS)	;Accept response
	$ENT (.STRRQ,SC.RRQ)	;Reject request
	$ENT (.STRRS,SC.RRS)	;Reject resonse
	$ENT (.STDRQ,SC.DRQ)	;Disconnect request
	$ENT (.STDRS,SC.DRS)	;Disconnect response
	$ENT (.STCRQ,SC.CRQ)	;Credit request
	$ENT (.STCRS,SC.CRS)	;Credit response
	$ENT (.STAMG,SC.AMG)	;Application message
	$ENT (.STADG,SC.ADG)	;Application datagram

>; End $DISPA definition

	SUBTTL	Macros -- $ENT (Entry in $DISPA)

; This routine defines one entry in $DISPA. 
;
	DEFINE $ENT(OFFSET,ADDR),<

IFN ...FOO,<
IFN <OFFSET-...FOO-1>,<IF2 <PRINTX Dispatch table out of order! (OFFSET)>>
>;End IFN ...FOO

	...FOO==OFFSET		;Get the current value of OFFSET

	XWD XCDSEC,ADDR		;[7.1037]Section six address of a handler routine

>; End $ENT definition
	SUBTTL Macros -- $BUILD,$SET,$EOB - Build pre-formed data blocks

;Many thanks to the Galaxy folks from whom this is directly stolen.../CD
; Start off a structure, argument is the size of the structure.

;..STR0 - Process instance of structure usage, single structure case.
DEFINE ..STR0 (OP,AC,STR,Y)<
	IFNDEF STR,<PRINTX STR IS NOT DEFINED
	  OP (<AC>,Y,FWMASK)>	;;RESERVE A WORD, ASSUME WORD MASK
	IFDEF STR,<
	IFNDEF %'STR,<
	  OP (<AC>,Y,STR)>	;;ASSUME NO OTHER LOCN
	IFDEF %'STR,<
	  %'STR (OP,<AC>,Y,STR)>>> ;;DO IT

;Put right-justified value into field specified by MASK
DEFINE	FLD(VALUE,MASK),<<<<VALUE>B<POS(<MASK>)>>&<MASK>>>

	DEFINE $BUILD(SIZE)<
	  IFDEF ..BSIZ,<PRINTX ?Missing $EOB after a $BUILD>
	  ..BSIZ==0			;;Start counter
	  ..BLOC==.			;;Remember our starting address
	  REPEAT SIZE,<			;;For each word in the block
		BLD0.(\..BSIZ,0)	;;Zero out it's accumulator
		..BSIZ==..BSIZ+1>	;;And step to next
	>;End of $BUILD definition

; For each value installed somewhere in the structure, set it into the block
; 	Arguments are word offset,field in word (optional) and value to set.

	DEFINE $SET(OFFSET,STR,VALUE),<
	  IFNDEF ..BSIZ,<PRINTX ?$SET without previous $BUILD>
	  IFNB <STR>,<..STR0 (..SET,<VALUE>,STR,OFFSET)>
	  IFB  <STR>,<..STR0 (..SET,<VALUE>,FWMASK,OFFSET)>
	> ; End of $SET definition

	DEFINE ..SET (VALUE,LOC,MSK) <
	  IFGE <<<LOC>&777777>-..BSIZ>,<
		PRINTX ?WORD offset greater than $BUILD size parameter>
	  SET0. (\<LOC>,MSK,<VALUE>)
	> ;End ..SET definition

; After all values are declared, the block must be closed to do its actual
;	creation.

	DEFINE $EOB,<
	  IFNDEF ..BSIZ,<PRINTX ?$EOB without previous $BUILD>
	  IFN <.-..BLOC>,<PRINTX ?Address change between $BUILD and $EOB>
;	  XLIST			;;Don't show the block
	  ..T==0
	  REPEAT ..BSIZ,<
	    BLD0.(\..T,1)		;;Store each word
	    ..T==..T+1 >
	  PURGE ..BSIZ,..T,..BLOC	;;Remove symbols
;	  LIST
	>; End of $EOB definition

	DEFINE BLD0.(N,WHAT),<
	  IFE WHAT,<..T'N==0>
	  IFN WHAT,<EXP ..T'N
		    PURGE ..T'N>
	> ;END OF BLD0. DEFINITION

	DEFINE SET0.(LOC,MSK,VALUE),<
	IFN <<..T'LOC>&MSK>,<PRINTX ?Initial field not zero in $SET>
	  ..TVAL==<VALUE>
	  ..TMSK==<MSK>
	  ..T'LOC==..T'LOC!<FLD(..TVAL,..TMSK)>
	  PURGE ..TVAL,..TMSK
	>;End of SET0. definition
	SUBTTL	Macros -- $SCSFC
; $SCSFC
;   This macro defines each of the SCS% JSYS function codes and the routines
;that handle these functions. For the most part, function code handlers simply
;massage the callers data into the right format for the internal monitor
;routines.
;
	DEFINE $SCSFC,<

	$BUILD (.SSLST+1)

	$SET (.SSCON,<>,<XCDSEC,,SCSCON>) ;[7.1043]
	$SET (.SSLIS,<>,<XCDSEC,,SCSLIS>) ;[7.1043]
	$SET (.SSDIS,<>,<XCDSEC,,SCSDIS>) ;[7.1043]
	$SET (.SSREJ,<>,<XCDSEC,,SCSREJ>) ;[7.1043]
	$SET (.SSSDG,<>,<XCDSEC,,SCSSDG>) ;[7.1043]
	$SET (.SSQRD,<>,<XCDSEC,,SCSQRD>) ;[7.1043]
	$SET (.SSSMG,<>,<XCDSEC,,SCSSMG>) ;[7.1043]
	$SET (.SSQRM,<>,<XCDSEC,,SCSQRM>) ;[7.1043]
	$SET (.SSCSP,<>,<XCDSEC,,SCSCSP>) ;[7.1043]
	$SET (.SSRCD,<>,<XCDSEC,,SCSRCD>) ;[7.1043]
	$SET (.SSSTS,<>,<XCDSEC,,SCSSTS>) ;[7.1043]
	$SET (.SSRMG,<>,<XCDSEC,,SCSRMG>) ;[7.1043]
	$SET (.SSMAP,<>,<XCDSEC,,SCSMAP>) ;[7.1043]
	$SET (.SSUMP,<>,<XCDSEC,,SCSUMP>) ;[7.1043]
	$SET (.SSSND,<>,<XCDSEC,,SCSSND>) ;[7.1043]
	$SET (.SSREQ,<>,<XCDSEC,,SCSREQ>) ;[7.1043]
	$SET (.SSAIC,<>,<XCDSEC,,SCSAIC>) ;[7.1043]
	$SET (.SSRPC,<>,<XCDSEC,,SCSRPC>) ;[7.1043]
	$SET (.SSRDG,<>,<XCDSEC,,SCSRDG>) ;[7.1043]
	$SET (.SSCRD,<>,<XCDSEC,,SCSCRD>) ;[7.1043]
	$SET (.SSCRM,<>,<XCDSEC,,SCSCRM>) ;[7.1043]
	$SET (.SSACC,<>,<XCDSEC,,SCSACC>) ;[7.1043]
	$SET (.SSGDE,<>,<XCDSEC,,SCSGDE>) ;[7.1043]
	$SET (.SSEVT,<>,<XCDSEC,,SCSEVT>) ;[7.1043]
	$SET (.SSGLN,<>,<XCDSEC,,SCSGLN>) ;[7.1043]
	$SET (.SSRBS,<>,<XCDSEC,,SCSRBS>) ;[7.1043]
	$SET (.SSRPS,<>,<XCDSEC,,SCSRPS>) ;[7.1043]

	$SET (.SSMDR,<>,<MSEC1,,UJSYS>)
	$SET (.SSMDS,<>,<MSEC1,,UJSYS>)
	$SET (.SSSRS,<>,<MSEC1,,UJSYS>)
	$SET (.SSRRS,<>,<MSEC1,,UJSYS>)

	$EOB

>; End $SCSFN definitions
	SUBTTL	Function codes returned by SCA.
;
; The following is the set of defined function codes returned to 
;monitor modules which have invoked SCA. 
;
; Format of returned information:
;	T1/	Function code
;	T2/	Function code dependant additional data
;	T3/	Function code dependant additional data
;	T4/	Function code dependant additional data
;
; Where T2, T3 and T4 contains information that will change from function to 
;function code.
;


;Datagram received. SCA is indicating that the CI has filled one of the buffers
;queued for datagram reception with a datagram. 
;	T1/	.SSDGR
;	T2/	Connect ID
;	T3/	Address of datagram buffer
;	T4/	<FLAGS>B6 ! <Addr of routine to return buffer>B35
;		(See F.RTB and friends for flag definitions)
;
; .MHPKL word of datagram buffer/
;		Length of the packet (Bytes for industry compatable, words
;					for high density)

	.SSDGR==:0

;Message received. SCA is indicateing that you have received a message from the
;CI.
;	T1/	.SSMGR
;	T2/	Connect ID
;	T3/	Address of message buffer
;	T4/	<FLAGS>B6 ! <Addr of routine to return buffer>B35
;		(See F.RTB and friends for flag definitions)
;
; .MHPKL word of msg buffer/
;		Length of the packet (Bytes for industry compatable, words
;					for high density)

	.SSMGR==:1

;Port broke connection. The port hardware detected a fatal error for the
;port virtual circuit on which you had a connection. Thus it broke your
;connection.
;	T1/	.SSPBC
;	T2/	Connect ID or -1 if no CID is to be returned
;	T3/	Node number of port to which connection was lost
;	T4/	Unused

	.SSPBC==:2

;Connection to listen. The listen for either anyone, or a particular process 
;name has had a connection request from a remote node.
;	T1/	.SSCTL
;	T2/	Connect ID
;	T3/	Pointer to connection data from remote system
;		(The pointer to the connection data is only guaranteed 
;                valid for the duration of the callback.)
;	T4/	Unused

	.SSCTL==:3

;Connection response available. The system to which you sent a connect message 
;has responded.
;	T1/	.SSCRA
;	T2/	Connect ID
;	T3/	-1 for accepted, 0 for rejected connection
;	T4/	Reject code (If rejected), pointer to connect data if accepted
;		(The pointer to the connection data is only guaranteed 
;                valid for the duration of the callback.)

	.SSCRA==:4

;Message/datagram Send complete. The message/datagram which you requested be 
;sent, has been. The "buffer address" is the address of the buffer you gave 
;SCA to send.
;	T1/	.SSMSC
;	T2/	Connect ID
;	T3/	Address of buffer
;	T4/	Unused
;
	.SSMSC==:5

;Datagram dropped. A datagram was received and there were no buffers
;queued to place it.  The buffer is relinked to the port's datagram 
;free queue.
;	T1/	.SSDDG
;	T2/	Connect ID
;	T3/	Unused
;	T4/	Unused
;
	.SSDDG==:6

;Little credit left. You have just received a message that put you under
;receive credit threshold. It is suggested that you queue at least some buffers
;if you expect to get more messages. Note that you will receive one of these
;calls every time you receieve a message after which you are under threshold.
;	T1/	.SSLCL
;	T2/	Connect ID
;	T3/	Number of credits needed to get you over threshold
;	T4/	Unused
;	
	.SSLCL==7

;Node came online. You requested to be told of nodes coming online.
;It happened and now your being told.
;
;	T1/	.SSNCO
;	T2/	SBI of system that has come online
;	T3/	Unused
;	T4/	Unused
;
	.SSNCO==10

;OK to send data. The connection has been completed to a remote system and is
;now in the OPEN state. Messages and datagram may be sent...
;
;	T1/	.SSOSD
;	T2/	Connect ID
;	T3/	Unused
;	T4/	Unused
;
	.SSOSD==11

;Remote initiated disconnect. The host at the other end of your connection
;doesn't want to talk to you anymore and has completed an orderly shutdown of
;your connection.
;
;	T1/	.SSRID
;	T2/	Connect ID
;	T3/	Disconnect reason code
;	T4/	Unused
;
	.SSRID==12

;Credit is available. Your message send failed for lack of credit. There is
;now more credit available for your send...
;
;	T1/	.SSCIA
;	T2/	Connect ID
;	T3/	Current send credit
;	T4/	Current receive credit
;
	.SSCIA==13

;DMA operation complete. The DMA operation you requested has been completed.
;Note that you will NOT be told about the completion of passive requests. I.E.
;you will not be notified when a request/send data done by a remote completes.
;
;	T1/	.SSDMA
;	T2/	Connect ID of connection DMA was cone for
;	T3/	32 bit buffer name of DMA buffer
;	T4/	Unused
;
	.SSDMA==14

	.SSAFT==.SSDMA		;Last defined code
	SUBTTL Connection states

; Warning: SC.ABT and SC.CLK assume the connection states to be grouped this
;way. If you add a new state be sure to change SC.ABT and SC.CLK to deal with
;the change.

repeat 0,<
	.CSDRE==1		;Disconnect recieved
	.CSDSE==.CSDRE+1	;Disconnect sent
	.CSDAK==.CSDSE+1	;Disconnect acknowledge
	.CSDMC==.CSDAK+1	;Disconnect match

	.CSCLO==.CSDMC+1	;Closed - by command
	.CSCNM==.CSCLO+1	;Closed - no match
	.CSCRJ==.CSCNM+1	;Closed - rejection
	.CSCNR==.CSCRJ+1	;Closed - no resources
	.CSCVC==.CSCNR+1	;Closed - Port virtual circuit error

	.CSLIS==.CSCVC+1	;Listening

	.CSCSE==.CSLIS+1	;Connect sent
	.CSCAK==.CSCSE+1	;Connect acknowledge
	.CSCRE==.CSCAK+1	;Connect recieved

	.CSOPN==.CSCRE+1	;Connection open
>

;States of a connection. Names in all caps are from corporate spec.

	.CSCLO==SQ%CLO		;Closed (CLOSED) 
	.CSLIS==SQ%LIS		;Listening (LISTENING)
	.CSCSE==SQ%CSE		;Connect request was sent (CONNECT_SENT)
	.CSCRE==SQ%CRE		;Connect request was received (CONNECT_REC)
	.CSCAK==SQ%CAK		;Connect response was received (CONNECT_ACK)
	.CSACS==SQ%ACS		;Accept request was sent (ACCEPT_SENT)	
	.CSRJS==SQ%RJS		;Reject request was sent (REJECT_SENT)
	.CSOPN==SQ%OPN		;Connection is open (OPEN)
	.CSDSE==SQ%DSE		;Disconnect request was sent (DISCONNECT_SENT)
	.CSDRE==SQ%DRE		;Disconnect request received (DISCONNECT_REC)
	.CSDAK==SQ%DAK		;Disconnect response received (DISCONNECT_ACK)	
	.CSDMC==SQ%DMC		;Waiting for disconnect response (DISCONNECT_MATCH)
MXCNST==SQ%HIS			;Highest value for a connect state

	SUBTTL	Connection block states

	.BSFRE==:1		;Free
	.BSALL==:2		;Allocate
	.BSCNP==:3		;Connect pending
	.BSACP==:4		;Accept pending
	.BSRPN==:5		;Reject pending
	.BSCRP==:6		;Credit pending
	.BSDPN==:7		;Disconnect pending

repeat 0,<
	.BSCNP==:1		;Connect pending
	.BSACP==:2		;Accept pending
	.BSALL==:3		;Allocate
	.BSCRP==:4		;Credit pending
	.BSRPN==:5		;Reject pending
	.BSDCP==:6		;Disconnect credit pending
	.BSDPN==:7		;Disconnect pending
>

	SUBTTL	SCA message types and lengths

	.STORQ==0		;Connect request
		.LNORQ==^D64
	.STORS==1		;Connect response
		.LNORS==^D16
	.STARQ==2		;Accept request
		.LNARQ==^D64
	.STARS==3		;Accept response
		.LNARS==^D16
	.STRRQ==4		;Reject request
		.LNRRQ==^D16
	.STRRS==5		;Reject response
		.LNRRS==^D12
	.STDRQ==6		;Disconnect request
		.LNDRQ==^D16
	.STDRS==7		;Disconnect response
		.LNDRS==^D12
	.STCRQ==10		;Credit request
		.LNCRQ==^D12
	.STCRS==11		;Credit response
		.LNCRS==^D12

	.STAMG==12		;Application message
	.STADG==13		;Application datagram

	.STLST==.STADG+1	;Highest expected message type number

	SUBTTL	Connection managment symbols

	.CMCMT==CM%CMT		;A match was found for the CONNECT_REQUEST
	.CMCNM==CM%CNM		;No match was found for the CONNECT_REQUEST
	.CMNRE==CM%NRE		;No resources to process CONNECT_REQUEST
	.CMNDS==CM%NDS		;Connection has been broken
	.CMNRV==CM%NRV		;Reserved

	SUBTTL	Message formats -- PPD packet definitions

;The general format of a datagram or message is:
;      
;          +-----------------------------------------------+
; .PKFLI   !                    FLINK                      ! 0
;          +-----------------------------------------------+
; .PKBLI   !                    BLINK                      ! 1
;          +-----------------------------------------------+
; .PKRSV   !            Reserved for software              ! 2
;          +---------+---------+---------+---------+-------+
; .PKSTS   !00<--->07!08<--->15!16<--->23!24<--->31!32<->35!
;          ! Status  !  Flags  !  Opcode !  Port   !  MBZ  ! 3
;          +---------+---------+---------+---------+-------+
; .PKLEN   !00<------------->15!16<--------------------->35!
;          !	  PPD byte     !    Length of text data    ! 4
;          !-----------------------------------------------+
;          !                                               ! 5
;          !                                               !
;          !                                               !
;          !                   Text                        !
;          !                                               !
;          !                                               !  Queue
;          !                                               ! Length
;          !                                               !   - 1
;          +-----------------------------------------------+


;Offsets in packet
;
.PKFLI==0			;FLINK
.PKBLI==.PKFLI+1		;BLINK
.PKRSV==.PKBLI+1		;Reserved to software
.PKVRT==.PKRSV			;Virtual address of the packet
	DEFSTR (PKSRB,.PKRSV,5,6)	;The software response bits
	  DEFSTR (PKDRV,.PKRSV,0,1) 	;Return packet tof KLIPA drvier
	  DEFSTR (PKSCA,.PKRSV,1,1)	;Return packet to SCA
	DEFSTR (PKVRT,.PKRSV,35,30)	;Virtual address

.PKSTS==.PKRSV+1		;Status/opcode/flags/node no.

;Bits in status, flags word
;
	PKSSTS==^D8		;Status size
	PKPSTS==7		;Position
	PKSFLG==^D8		;Flags size
	PKPFLG==^D15		;Flags position
	PKSOP==^D8		;Opcode size
	PKPOP==^D23		;Opcode position
	PKSNOD==^D8		;Node no. size
	PKPNOD==^D31		;Node no. position

;Status
;
	DEFSTR (.PKSFD,.PKSTS,7,7)	;STATUS FIELD LESS THE ERROR BIT.
	PS.ERR==1B0		;Composite error bit
	PS.PAE==1B1		;Path A error
	PS.PBE==1B2		;Path B error
	PS.NRA==304		;NO RESPONSE ON PATH A
	PS.NRB==244		;NO RESPONSE ON PATH B
	PS.NRE==344		;NO RESPONSE ON EITHER PATH
	PS.IBN==2		;INVALID BUFFER NAME

;	Status bits when PS.ERR is off

	PS.CLO==1B1		;CLOSED THE PATH
	PS.AKA==1B2		;PACKET WAS ACKED ON PATH A
	PS.NKA==1B3		;PACKET WAS NAKED AT LEAST ONCE ON PATH A
	PS.NOA==1B4		;PACKET GOT NO RESPONSE AT LEAST ONCE ON PATH A
	PS.AKB==1B5		;PACKET WAS ACKED ON PATH B
	PS.NKB==1B6		;PACKET WAS NAKED AT LEAST ONCE ON PATH B
	PS.NOB==1B7		;PACKET GOT NO RESPONSE AT LEAST ONCE ON PATH B
;Flags
;
	PF.SIZ==1B8		;(Data) 0 if 512 bytes, 1 if 576
	PF.FMT==1B8		;(DG/MSG) 0 if ind compat, 1 if high density
	PF.FRC==1B8		;(Reset remote system)  force reset
	PF.DSA==1B8		;(Start remote system)use default starting addr
	PF.CPE==1B12		;CNTRD generated by port (CRAM parity error)
	PF.PTH==3B14		;0=Auto, 1=Path 0, 2=Path 1
	PF.PT0==1B14		;1=Use path 0
	PF.PT1==2B14		;1=Use path 1
	PF.RSP==1B15		;=1 If always generate response

;Length and PPD byte
;
.PKLEN==.PKSTS+1		;Length of datagram/message
	PKSPPD==^D16		;PPD byte size
	PKPPPD==^D15		;PPD byte position

;Block data service
;
.PKXID==4			;Transaction ID (2 words)
.PKXLN==6			;Transaction length
.PKSNM==7			;Sender name
.PKSOF==10			;Sender offset
.PKRNM==11			;Receiver name
.PKROF==12			;Receiver offset

;Register read
;
.PKREG==.PKLEN			;Register to read
	PKSREG==^D8		;Size
	PKPREG==^D23		;Position
	PKSDTA==^D8		;Data returned (register contents)
	PKPDTA==^D7		;Position
	.RGNOD==14		;Our node number


;ID received
	.PKMID==.PKLEN+2	;Maintenance ID
	.PKTYP==6		;PORT TYPE
	PKPID==^D31		;Position
	PKSID==6		;Size
		ID.HSC==4	;HSC 50
		ID.JUP==5	;Jupiter
		ID.KL==6	;KL10
	DEFSTR (PKTYP,.PKTYP,PKPID,PKSID)
	.PKCOD==7		;Code Revision Level
	.PKFUN==10		;Port functionality
	.PKPST==11		;(Destination) port state
	PKPPST==^D22		;Postion
	PKSPST==2		;Size
	PS.ENB==2		;Port is enabled

	DEFSTR (PKPRST,.PKPST,23,3)	;State and Maintenance fields
	DEFSTR (PKMAI,.PKPST,23,1)	;MAINTENANCE FIELD ONLY
	DEFSTR (PKPRND,.PKPST,31,8)	;Resetting Node
	PS.UMS==1			;Unintialized/Maintenance State.

				;PORT FUNCTIONALITY BIT DEFINITIONS
	PKSMD==1B17		;SUPPORTS RECEIPT OF A SNTMDAT
	PKRMD==1B19		;SUPPORTS RECEIPT OF A MDATREQ

;Start remote system
;
	.PKSAD==6		;Start address if not using default


;START/START ACKNOWLEGE block
;
	.SRSSY==.PKLEN+1	;Sending system
	.SRRSV==.SRSSY+1	;Reserved
		DEFSTR (SRMBZ,.SRRSV,7,8) ;MBZ
		DEFSTR (SRVRS,.SRRSV,15,8) ;PROTOCOL VERSION
		SCAVER==1	;CURRENT SCA VERSION
	.SRMMS==.SRRSV+1	;Max message/dg sizes
		DEFSTR (SRMMG,.SRMMS,15,16) ;MAXIMUM MESSAGE SIZE (BYTES)
		DEFSTR (SRMDG,.SRMMS,31,16) ;MAXIMUM DATAGRAM SIZE (BYTES)
	.SRSWT==.SRMMS+1	;Software type
	.SRSWV==.SRSWT+1	;Software version
	.SRSWI==.SRSWV+1	;Software incarnation
	.SRHWT==.SRSWI+2	;Hardware type
	.SRHWV==.SRHWT+1	;Hardware version
	.SRNNM==.SRHWV+3	;Node name
	.SRTOD==.SRNNM+2	;Time of day (in vax notation)


	SR.LEN==^D52		;Length of a START or ACK message
;	SR.LEN==^D60	;******* In base level 2, when time of day gets added
	SR.ALN==4		;Length of an ACK


;SETCKT
;
.PKCKT==.PKMID			;Word with flags
	CK.LST==1B0		;Load CST, NR, NS
	CK.CST==1B1		;1=VC open,  0=VC closed
	CK.LPT==1B4		;Load path status
	CK.PBA==1B5		;PATH B ALLOWED
	CK.PAA==1B6		;PATH A ALLOWED
	CK.PGD==3B6		;Both paths good

;Set performance counters
;
PNTMSK==777777,,0		;Mask to clear, enable all possible values
	.PKMSK==6		;Mask for enables/clears, target node
	.PKPND==7		;Target node (set)
	PKSCND==10		;Target node - size
	PKPCND==^D31		;Target node - position
	
;Read performance counters
;
	.PKPDA==.PKXID+2	;Start of data returned in packet
	.PKUCD==.PKPDA		;U-CODE VERSION
	.PKPAA==.PKUCD+1	;PATH A ACKS
	.PKPAN==.PKPAA+1	;PATH A NACKS
	.PKANR==.PKPAN+1	;PATH A NO-RESPONSES
	.PKPBA==.PKANR+1	;PATH B ACKS
	.PKPBN==.PKPBA+1	;PATH B NACKS
	.PKBNR==.PKPBN+1	;PATH B NO-RESPONSES
	.PKDGD==.PKBNR+1	;DATAGRAMS DISCARDED
	.PKPXM==.PKDGD+1	;PACKETS TRANSMITTED
	.PKPRC==.PKPXM+1	;PACKETS RECEIVED
	.PKDPT==.PKPRC+1	;DESIGNATED PORT WORD
	.PKCRC==.PKDPT+1	;PACKETS RECEIVED WITH CRC ERRORS
	.PKEW1==.PKCRC+1	;ERROR WORD 1
	.PKEW2==.PKEW1+1	;ERROR WORD 2
	.PKEW3==.PKEW2+1	;ERROR WORD 3
	.PKEW4==.PKEW3+1	;ERROR WORD 4
	.PKEW5==.PKEW4+1	;ERROR WORD 5
	.PKEW6==.PKEW5+1	;ERROR WORD 6
	.PKPDD==.PKEW6-<.PKUCD-1>  ;LENGTH OF RETURNED DATA
	.PKTGT==.PKPDA+.PKPDD-1	;End of data returned in packet
	
;PPD types
;
PP.STA==0			;START
PP.STK==1			;STACK
PP.ACK==2			;ACK a STACK
PP.DG==3			;DATAGRAM
PP.MSG==4			;MESSAGE
PP.ERP==5			;Error packet
PP.SHT==6			;Shutdown
PP.MAX==PP.SHT		;Highest-numbered known PPD byte


;Close Buffer command (205) definitions

;This command uses the following offsets from the format of the
;datagram or message command ; .PKFLI (FLINK), .PKBLI (BLINK), 
;.PKRSV (RESERVED FOR SOFTWARE, and .PKSTS (STATUS,FLAGS,OPCODE,PORT).

.PKBNM==.PKSTS+1		;Buffer Name

	SUBTTL Message formats -- Message header

; General header:
;    This header appears on SCA messages. Not all fields are valid for
;every message type, but when they do appear they are in this format.
;
; **** Note ****
; The application message and application datagram do not include the  last 
;word listed here. I.E. the status and min credit word. Hence when dealing with
;a message or datagram this word is NOT a part of the header but is the first 
;word of the message/datagram text...
;
;         !=======================================================!
; .MHTYP  !          Credit           !       Message type        !
;         !-------------------------------------------------------!
; .MHDCI  !                Destination connect ID                 !
;         !-------------------------------------------------------!
; .MHSCI  !                   Source connect ID                   !
;         !-------------------------------------------------------!
; .MHSTS  !          Status           !      Minimum credit       !
;         !-------------------------------------------------------!
;         \                                                       \
;         \                Message dependant words                \
;         \                                                       \
;         !=======================================================!
;
	.MHTYP==.PKLEN+1	;Message type and credit
		MSKSTR (MH$CDT,<.MHTYP>,<-1,,0>) ;Credit field
		MSKSTR (MH$MSG,<.MHTYP>,<0,,-1>) ;Message type field
		MSKSTR (MH$TYP,<.MHTYP>,<-1>) ;Entire .MHTYP word

	.MHDCI==.MHTYP+1	;Destination connect ID
		MSKSTR (MH$DCI,<.MHDCI>,<-1>) ;Destination connect ID mask

	.MHSCI==.MHDCI+1	;Source connect ID
		MSKSTR (MH$SCI,<.MHSCI>,<-1>)

	.MHSTS==.MHSCI+1	;Status and min receive credit
		MSKSTR (MH$STS,<.MHSTS>,<-1,,0>) ;Status info
		MSKSTR (MH$MCR,<.MHSTS>,<0,,-1>) ;Minimum receive credit
		MSKSTR (MH$SMC,<.MHSTS>,<-1>) ;Entire .MHSTS word

	.MHLEN==.MHSTS+1	;Length of the message header

	.MHPKL==.MHSCI		;Word where packet length is returned to SYSAP
		MSKSTR (MH$PKL,<.MHPKL>,<-1>) ;Entire .MHPKL word

	.MHUDA==.MHSCI+1	;Start of user data in appl mess and datagrams

	.MHLNW==<.MHSCI-.PKLEN>	;Length of application packet header in words
	.MHLNB==<<.MHSCI-.MHTYP+1>*4> ;Length of appl packet header in bytes

;Maximum number of words used for user data is
;<MSG BUFFER - START of USER DATA>
	C%MUDA==<<C%MGSZ-.MHUDA>-1> ;[7.1009][7.1060] One less for PHYKLP

; Size of largest message we can handle (in bytes) is
;<MSG BUFFER - PORT OVERHEAD> * 4 (words to bytes convert) + SIZE OF PPD BYTE

	C%MXMP==<<C%MGSZ-<.PKLEN+1>>*4>+2

; Size of largest datagram we can handle (in bytes) is
;<DG BUFFER - PORT OVERHEAD> * 4 (words to bytes convert) + SIZE OF PPD BYTE

	C%MXDP==<<C%DGSZ-<.PKLEN+1>>*4>+2
	SUBTTL Message formats -- Connect and Accept requests

; The following is the definition of the datagram type dependant part of
;the connect request datagram.
;
;         !=======================================================!
;         \                                                       \
;         \             Message header defined above              \
;         \                                                       \
;         !-------------------------------------------------------!
;  .MGDPN \                                                       \
;         \               Destination process name                \
;         \                                                       \
;         !-------------------------------------------------------!
;  .MGSPN \                                                       \
;         \                  Source process name                  \
;         \                                                       \
;         !-------------------------------------------------------!
;  .MGSDT \                                                       \
;         \                       Send data                       \
;         \                                                       \
;         !=======================================================!
;
	.MGDPN==.MHSTS+1	;First word of destination process name
	.MGSPN==.MGDPN+<C%PNMN/4> ;First word of source process name
	.MGSDT==.MGSPN+<C%PNMN/4> ;First data word in message

	.MSCRQ==.MGSDT+<C%SDTL/4> ;Size of the connect request datagram
	SUBTTL	SCA/PPD Flags

; The following are the flags that are passed between SCA and the PPD. Some
;of these flags are also passed to SCA from the SYSAP, these are marked.
;

	F.RTB==<1B0>		;1 - return message send buffer to SCA
				;0 - return message send buffer to free Q

	F.SPM==F.RTB_<-1>	;1 - Send mess/datagram in high den mode
				;0 - Send mess/datagram in industry compat mode

	F.RSP==F.SPM_<-1>	;1 - Packet was generated locally
				;0 - Packet came from CI (remotely generated)

	C%FLGM==<F.RTB!F.SPM!F.RSP> ;Mask for all flag bits

	SUBTTL	Message priorities

; The following are the priorities used for sending messages generated by SCA.
;
;	Priorities are as follows:
;	0 - Highest priority
;	3 - Lowest priority
;

	KLPHI==0		;Priority 0 - High
	KLPMED==1		;Priority 1 - Medium
	KLPLOW==2		;Priority 2 - Low
	KLPDRG==3		;Priority 3 - Dregs

; The following are the priorities used by each of the SYSAPs

	CFSPRI==KLPHI		;Priority used by CFSSRV
	MSCPRI==KLPMED		;Priority used by PHYMSC
	MVRPRI==KLPMED		;Priority used by PHYMVR
	SCSPRI==KLPLOW		;Priority used by SCSJSY
	CIDPRI==KLPLOW		;Priority used by CIDLL
	IPCPRI==KLPLOW		;Priority used by IPCIDV
	CLUPRI==KLPLOW		;[7.1076] Priority used by CLUDGR

	SUBTTL	Queue of Outstanding Requests
QORLNK==0			;LH=PREVIOUS QOR ENTRY, RH=NEXT
QORIRB==1			;RH=POINTER TO IORB
QORUNI==1			;LH=UNIT FOR TRANSFER
QORCRF==2			;COMMAND REFERENCE NUMBER
QORBHD==3			;BUFFER HEADER DESCRIPTOR
QORLEN==4			;SIZE OF A QOR ENTRY
	SUBTTL	Random cruft for PHYMSC


;before csstyp in PHYPAR
PRTMXU==30			;Max number of units on any CI node
MAXPRT==1			;Maximum number of CI ports
				;****** This must be 6 when we go to Jupiter's


DGLEN==^D96			;LENGTH OF A DATAGRAM BUFFER
	SUBTTL	End of SCAPAR

	END
