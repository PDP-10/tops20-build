; UPD ID= 8667, RIP:<7.MONITOR>FILMSC.MAC.5,  25-Feb-88 08:30:14 by RASPUZZI
;TCO 7.1241 - Prevent ILMNRFs out of TTYCL1.
; UPD ID= 8517, RIP:<7.MONITOR>FILMSC.MAC.4,   9-Feb-88 15:36:02 by GSCOTT
;TCO 7.1218 - Update copyright date.
; UPD ID= 313, RIP:<7.MONITOR>FILMSC.MAC.3,  25-Nov-87 13:48:23 by WADDINGTON
;TCO 7.1149 - Don't do TTHNGU when closing a file if the TTY is not an
; RSX20F line.
; *** Edit 7435 to FILMSC.MAC by GSCOTT on 3-Apr-87, for SPR #21488
; Enable control of DTR on RSX20F lines by MTOPR functions .MOHUP and .MOUHU
; and raise and lower DTR when a TTY is opened and closed if it's not CTRLTT 
; *** Edit 7372 to FILMSC.MAC by RASPUZZI on 3-Oct-86
; TTPINI is now in GLOBS. We don't need it in EXTN. 
; *** Edit 7273 to FILMSC.MAC by MCCOLLUM on 25-Mar-86, for SPR #19864
; Return error in NILLKP if the file name or extension contains wild cards 
; UPD ID= 2246, SNARK:<6.1.MONITOR>FILMSC.MAC.33,  19-Jun-85 20:47:09 by MELOHN
;TCO 6.1.1455 - .MOCTM - return 1 if tty is cterm, 2 if tty is VMS CTERM
; UPD ID= 2228, SNARK:<6.1.MONITOR>FILMSC.MAC.32,  17-Jun-85 14:45:27 by MOSER
;TCO 6.1.1448 - PREVENT ILMNRF WHEN .TTDES+NNN ND RECHECK
; UPD ID= 2074, SNARK:<6.1.MONITOR>FILMSC.MAC.31,   3-Jun-85 14:35:27 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 1787, SNARK:<6.1.MONITOR>FILMSC.MAC.30,  23-Apr-85 12:46:25 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1728, SNARK:<6.1.MONITOR>FILMSC.MAC.29,   8-Apr-85 14:29:52 by MCCOLLUM
;TCO 6.1.1238 - Fix BUG. documentation
; UPD ID= 1620, SNARK:<6.1.MONITOR>FILMSC.MAC.28,  12-Mar-85 14:17:56 by LOMARTIRE
;More TCO 6.1.1145 - Use the correct mask value
; UPD ID= 1436, SNARK:<6.1.MONITOR>FILMSC.MAC.27,  31-Jan-85 15:40:00 by LOMARTIRE
;TCO 6.1.1145 - Handle case of fork controlling terminal switch after wakeup
; UPD ID= 4691, SNARK:<6.MONITOR>FILMSC.MAC.24,  15-Aug-84 11:20:10 by MELOHN
; TCO 6.2173 - Merge with M61: 6.1 changes under FTNSPSRV
; UPD ID= 4540, SNARK:<6.MONITOR>FILMSC.MAC.23,  15-Jul-84 10:42:48 by PURRETTA
;Update copyright notice.  Remove brackets in comments.
; UPD ID= 4347, SNARK:<6.MONITOR>FILMSC.MAC.22,  15-Jun-84 13:53:03 by LOMARTIRE
;TCO 6.2100 - Remove TCO 6.1792 and instead fix up case of close of 
; multiply opened TTYnnn:.  Add routine TTYSCN to test for another 
; opened TTYxxx: when closing one.
; UPD ID= 652, SNARK:<6.1.MONITOR>FILMSC.MAC.12,   2-Jul-84 15:01:10 by MCINTEE
;Add new MTOPR functions - .MOTXT, .MOCTM
; UPD ID= 593, SNARK:<6.1.MONITOR>FILMSC.MAC.11,   4-Jun-84 14:42:46 by MCINTEE
;Merge from M60:
; UPD ID= 4270, SNARK:<6.MONITOR>FILMSC.MAC.21,  30-May-84 21:20:37 by MOSER
;TCO 6.2060 - MAKE TTY MTOPR FASTER
; UPD ID= 573, SNARK:<6.1.MONITOR>FILMSC.MAC.10,  29-May-84 10:26:23 by MCINTEE
;Remove references to newly nonexistent CTERM MTOPRs
; UPD ID= 543, SNARK:<6.1.MONITOR>FILMSC.MAC.9,  23-May-84 07:49:04 by MCINTEE
;Merge from M60:
; UPD ID= 4155, SNARK:<6.MONITOR>FILMSC.MAC.20,  30-Apr-84 16:40:03 by LOMARTIRE
;TCO 6.2031 - Make TCO 6.1526 use fork controlling terminal for TTY: if one
; UPD ID= 357, SNARK:<6.1.MONITOR>FILMSC.MAC.8,  27-Feb-84 09:14:01 by MCINTEE
;More TCO 6.1959 - Allow failure return from TTERED.
;TCO 6.1959 - Add new MTOPR% functions .MOTCE, .MORTC. Two char esc seq.
;Replace removed edit - Return OPNX9 when trying to open a TTY that is open
;Merge from M60:
; UPD ID= 3765, SNARK:<6.MONITOR>FILMSC.MAC.19,  27-Feb-84 08:57:17 by MCINTEE
;More TCO 6.1959 - Allow failure return from TTERED.
; UPD ID= 3613, SNARK:<6.MONITOR>FILMSC.MAC.18,   1-Feb-84 08:51:14 by MCINTEE
;TCO 6.1959 - Add new MTOPR% functions .MOTCE, .MORTC. Two char esc seq.
; UPD ID= 3469, SNARK:<6.MONITOR>FILMSC.MAC.17,  16-Jan-84 15:05:36 by LOMARTIRE
;Replace removed edit - Return OPNX9 when trying to open a TTY that is open
; UPD ID= 290, SNARK:<6.1.MONITOR>FILMSC.MAC.7,  13-Jan-84 15:32:18 by MCINTEE
;Merge from M60:
; UPD ID= 3317, SNARK:<6.MONITOR>FILMSC.MAC.16,  14-Dec-83 14:35:34 by PRATT
;TCO 6.1796 - Add .MOSTF and .MORTF MTOPR functions.
; UPD ID= 267, SNARK:<6.1.MONITOR>FILMSC.MAC.6,   5-Dec-83 09:26:25 by MCINTEE
;Merge from M60:
; UPD ID= 3223, SNARK:<6.MONITOR>FILMSC.MAC.15,  28-Nov-83 14:55:41 by LOMARTIRE
;Add missing edit history and improve previous edit (TCO 6.1834)
; UPD ID= 3082, SNARK:<6.MONITOR>FILMSC.MAC.14,  26-Oct-83 09:07:50 by LOMARTIRE
;TCO 6.1834 - Allow opening of PTY after TTY end has been assigned to job
; UPD ID= 215, SNARK:<6.1.MONITOR>FILMSC.MAC.5,  10-Oct-83 14:01:46 by MCINTEE
;UPDATE from M60: 
; UPD ID= 2961, SNARK:<6.MONITOR>FILMSC.MAC.13,  30-Sep-83 13:35:29 by PURRETTA
;Temporarily remove last edit.
; UPD ID= 2932, SNARK:<6.MONITOR>FILMSC.MAC.12,  26-Sep-83 13:20:21 by LOMARTIRE
;TCO 6.1792 - Return OPNX9 when trying to open a TTY that is already open
; UPD ID= 188, SNARK:<6.1.MONITOR>FILMSC.MAC.4,   4-Aug-83 07:51:47 by MCINTEE
;TCO 6.1689 - Move fork tables to extended section
;	Reference FKJOB via DEFSTR
;TCO 6.1526 - Replace version 4 code which checked device name and set DEV 
; to controlling terminal when JFN was for TTY
; UPD ID= 1092, SNARK:<6.MONITOR>FILMSC.MAC.9,  18-Aug-82 10:47:30 by MCINTEE
;TCO 6.1219 - Extend STRDTB for RLJFD
; UPD ID= 1060, SNARK:<6.MONITOR>FILMSC.MAC.8,   9-Aug-82 15:50:18 by PAETZOLD
;TCO 6.1219 - Extend TTYDTB, PTYDTB, and NILDTB for RLJFD
; UPD ID= 890, SNARK:<6.MONITOR>FILMSC.MAC.7,   9-Jun-82 22:55:20 by MURPHY
;TCO 6.1147 - Move bugdefs from BUGS.MAC to here and put them in-line.
; UPD ID= 751, SNARK:<6.MONITOR>FILMSC.MAC.6,  15-May-82 10:19:55 by MILLER
;TCO 6.1066. ADD CALL TO TTPINI SO RSP LINES WORK
; UPD ID= 654, SNARK:<6.MONITOR>FILMSC.MAC.5,  20-Apr-82 12:13:03 by MILLER
;TCO 6.1098. Reinstate code in TTYCLZ that does "free DOBE"
; UPD ID= 1873, SNARK:<6.MONITOR>FILMSC.MAC.10,  23-Feb-83 17:40:19 by LOMARTIRE
;TCO 6.1526 - Replace version 4 code which checked device name and set DEV
; to controlling terminal when JFN was for TTY
; UPD ID= 361, SNARK:<6.MONITOR>FILMSC.MAC.4,  29-Jan-82 14:05:19 by WALLACE
;TCO 5.1709 - Make check at TTYOUT for universal form of terminal designator
;  (i.e. 600000+.DVTTY,,terminal number) and continue at TTYOUX
; UPD ID= 360, SNARK:<6.MONITOR>FILMSC.MAC.3,  29-Jan-82 13:47:04 by MILLER
;TCO 5.1678. TTYASN now checks that caller has access to the TTY
;<6.MONITOR>FILMSC.MAC.2, 16-Oct-81 18:01:23, EDIT BY MURPHY
;TCO 6.1030 - Node names in filespecs; etc.
;Revise DTB format; get rid of double skips on NLUKD, etc.
; UPD ID= 142, SNARK:<5.MONITOR>FILMSC.MAC.9,   3-Sep-81 11:10:00 by DONAHUE
;TCO 5.1486 - Prevent TTYBLO from looping with a large byte count
; UPD ID= 2152, SNARK:<5.MONITOR>FILMSC.MAC.8,   8-Jun-81 17:36:15 by MURPHY
;PREVENT CLEAR OF TTY OUTBUF WHEN CLOSING IF TTY ASSIGNED
; UPD ID= 1863, SNARK:<5.MONITOR>FILMSC.MAC.7,  21-Apr-81 18:28:18 by MURPHY
;ADD .MOPCS, .MOPCR FUNCTIONS
;TCO 5.1242 - Fix TTYCLZ to not block NOINT with DEVLKK locked.
; UPD ID= 961, SNARK:<5.MONITOR>FILMSC.MAC.5,  25-Aug-80 16:25:50 by ENGEL
;TCO 5.1136 - ADD DEVLKK
; UPD ID= 686, SNARK:<5.MONITOR>FILMSC.MAC.4,  23-Jun-80 14:58:17 by SANICHARA
;TCO 5.1074 - The fork enabling a PTY for INTs must be the owner of the JFN
; UPD ID= 654, SNARK:<5.MONITOR>FILMSC.MAC.3,  16-Jun-80 17:00:10 by OSMAN
;tco 5.1050 - Make jfn on TTY: use fork's controlling terminal
; UPD ID= 434, SNARK:<5.MONITOR>FILMSC.MAC.2,  13-Apr-80 15:13:20 by OSMAN
; UPD ID= 426, SNARK:<4.1.MONITOR>FILMSC.MAC.2,  13-Apr-80 14:34:48 by OSMAN
;tco 4.1.1142 - Use RSCAN data if input from fork's controlling terminal
; UPD ID= 426, SNARK:<4.1.MONITOR>FILMSC.MAC.46,   9-Apr-80 16:22:31 by OSMAN
;Clean up TTYIN code.  Get rid of moby literal
;<4.MONITOR>FILMSC.MAC.45, 26-Oct-79 14:51:15, EDIT BY ZIMA
;TCO 4.2557 - Change for new calling sequence to TTSSPD for ACJ rejection
; handling; returns nonskip on error, skip on "success".  At TTMSSP+3.
;<4.MONITOR>FILMSC.MAC.44, 24-Oct-79 12:38:55, EDIT BY MURPHY
;HANDLE FAILURE FROM TTSTI
;<OSMAN.MON>FILMSC.MAC.1, 10-Sep-79 15:29:37, EDIT BY OSMAN
;TCO 4.2412 - Move definition of BUGHLTs, BUGCHKs, and BUGINFs to BUGS.MAC
;<4.MONITOR>FILMSC.MAC.41, 13-Aug-79 17:07:13, EDIT BY DBELL
;TCO 4.2393 - MAKE GNJFN OF NUL:<*>FOO.BAR TERMINATE
;<4.MONITOR>FILMSC.MAC.40,  9-Aug-79 13:43:05, EDIT BY TOMCZAK
;TTYCLZ - wait for output buffers to empty before closing a TTY
;<4.MONITOR>FILMSC.MAC.39, 12-May-79 13:04:22, EDIT BY MILLER
;<4.MONITOR>FILMSC.MAC.38, 12-May-79 12:49:24, EDIT BY MILLER
;ADD CODE FOR GDSTS
;<4.MONITOR>FILMSC.MAC.37, 20-Mar-79 17:18:34, EDIT BY HALL
;TTYIN - BE NOINT UNTIL FREE SPACE IS RETURNED WHEN USING THE
;RESCAN BUFFER
;<4.MONITOR>FILMSC.MAC.36,  4-Mar-79 17:11:09, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.MONITOR>FILMSC.MAC.35, 30-Jan-79 12:11:49, Edit by MCLEAN
;FIX TTMTOP TO RETSKP IF NO CONTROLLING TERMINAL
;<4.MONITOR>FILMSC.MAC.34, 13-Dec-78 15:45:09, Edit by MCLEAN
;REMOVE AN INSTRUCTION IN TTYOUB
;<4.MONITOR>FILMSC.MAC.33, 11-Dec-78 22:58:59, Edit by MCLEAN
;ADD .MOTPS
;<4.MONITOR>FILMSC.MAC.31, 11-Dec-78 13:34:50, Edit by MCLEAN
;CHANGE REGISTER FROM B TO D AT TTYOUY+A FEW
;<4.MONITOR>FILMSC.MAC.30,  6-Nov-78 12:46:58, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.29,  5-Nov-78 16:22:34, Edit by MCLEAN
;FIX TTYOUB FOR LAST CHARACTER CHECK
;<2MCLEAN>FILMSC.MAC.28, 11-Oct-78 00:11:32, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.27, 10-Oct-78 23:57:47, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.26,  9-Oct-78 23:42:00, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.25,  8-Oct-78 21:42:37, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.24,  8-Oct-78 15:06:51, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.23,  5-Oct-78 11:57:21, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.22,  3-Oct-78 23:40:35, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.21,  3-Oct-78 23:20:19, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.20,  3-Oct-78 00:59:16, Edit by MCLEAN
;<2MCLEAN>FILMSC.MAC.19,  3-Oct-78 00:57:45, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.17, 27-Aug-78 10:02:16, EDIT BY MILLER
;<4.MONITOR>FILMSC.MAC.16, 27-Aug-78 09:58:00, EDIT BY MILLER
;ADD CHKBCH
;<4.MONITOR>FILMSC.MAC.15, 15-Aug-78 09:29:09, Edit by ENGEL
;MAKE TTMVER UNLOCK IF BLOCK WRONG SIZE
;<4.MONITOR>FILMSC.MAC.14, 14-Aug-78 08:34:36, EDIT BY OSMAN
;MAKE TLOCK SKIP IF SUCCESS
;<4.MONITOR>FILMSC.MAC.13, 10-Aug-78 16:35:53, EDIT BY OSMAN
;ADD READ/SET LINE COUNTER, LINE COUNTER MAXIMUM FUNCTIONS
;<4.MONITOR>FILMSC.MAC.12, 26-Jul-78 18:43:01, EDIT BY MILLER
;ADD READ XOFF BIT FUNCTION
;<4.MONITOR>FILMSC.MAC.11, 23-Jul-78 15:05:24, EDIT BY MILLER
;FIX TYPEO
;<4.MONITOR>FILMSC.MAC.10, 23-Jul-78 14:49:39, EDIT BY MILLER
;TCO 1951. ADD MTOPR CODE FOR XON/XOFF
;<4.MONITOR>FILMSC.MAC.9, 14-Jul-78 12:53:03, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.8, 14-Jul-78 12:48:27, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.7, 14-Jul-78 12:48:01, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.6, 14-Jul-78 01:52:08, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.5, 14-Jul-78 01:30:27, Edit by MCLEAN
;<4.MONITOR>FILMSC.MAC.4, 14-Jul-78 01:12:47, Edit by MCLEAN
;ADD CHECK FOR OPENED TO MTOPR
;<3A.MONITOR>FILMSC.MAC.4, 17-May-78 11:10:53, EDIT BY MILLER
;FIX UP HANDLING OF RSCNBP TO AVOID SYSTEM CRASHES. CURRENT RSCAN
; CODE IS STILL WRONG AND FULL OF RACES
;<4.MONITOR>FILMSC.MAC.2,  9-Mar-78 09:37:53, Edit by ENGEL
;ADD MTOPR FUNCTIONS FOR 128-CHARACTER MASK

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


	SEARCH PROLOG
	TTITLE FILMSC		;MISC - TTY, PTY, STRING AND NIL
	SWAPCD

IFE FTNSPSRV,<SEARCH TTYDEF>	;remove this when MTOPR symbols live in MONSYM

;SPECIAL EXTERNALS IN TTYSRV USED BY THIS CODE

	EXTN <TTXSET,TTRXOB,TTGSTS>

;SPECIAL AC DEFINITIONS USED HEREIN

DEFAC (U,Q1)			;UNIT NUMBER
DEFAC (IOS,Q2)			;DEVICE STATUS FLAGS
DEFAC (STS,P1)			;SEE GTJFN FOR FUNCTIONS
DEFAC (JFN,P2)
DEFAC (DEV,P4)
DEFAC (F1,P5)

	SUBTTL NUL DEVICE FUNCTIONS

NILDTB::NILDTL			;LENGTH
	DTBDSP (NILSET)
	DTBDSP (NILLKP)		;NAME LOOKUP
	DTBDSP (NILLKP)		;EXT LOOKUP
	DTBDSP (NILVLK)		;VER LOOKUP
	DTBBAD			;PROTECTION INSERTION
	DTBSKP			;ACCOUNT INSERTION
	DTBBAD			;STATUS INSERTION
	DTBDSP (NILOPN)		;OPEN
	DTBDSP (NILSQI)		;INPUT
	DTBDSP (NILSQO)		;OUTPUT
	DTBSKP			;CLOSF
	DTBSKP			;RENAME
	DTBSKP			;DELETE
	DTBBAD (DUMPX6)		;DUMPI
	DTBBAD (DUMPX6)		;DUMPO
	DTBSKP			;MOUNT
	DTBSKP			;DISMOUNT
	DTBSKP			;INIT DIRECTORY
	DTBSKP			;MTOPR
	DTBBAD			;DEVICE STATUS READ
	DTBBAD			;DEVICE STATUS SET
	DTBSKP			; RECORD OUT
	DTBDSP (RFTADN)		; READ TAD
	DTBDSP (SFTADN)		; SET TAD
	DTBDSP (BIOINP)		;SET JFN FOR INPUT
	DTBDSP (BIOOUT)		;SET JFN FOR OUTPUT
	DTBBAD (GJFX49)		;CHECK ATTRIBUTE
	DTBSKP			;RELEASE JFN
	NILDTL==:.-NILDTB	;GLOBAL LENGTH OF DISPATCH TABLE

NILOPN:	TQCE <RNDF>		;WANT APPEND?
	TQO <WRTF>		;YES. LIGHT WRITE BIT THEN
	SETZB A,B
	CAIN JFN,377777
	RET			;ALL DONE FOR THIS GUY
	TQNN <READF>		;IS IT READ?
	HRLOI A,377777		;NO. DO OUTPUT
	MOVEM A,FILCNT(JFN)	;STORE COUNT
	SETZB A,FILBYT(JFN)	;RETURN ZEROS
	RETSKP			;AND RETURN SUCCESSFULLY

NILSQO:	SETZB A,B
	CAIN JFN,377777
	 RET
	TQNN <READF>		;IS IT READ?
	HRLOI A,377777		;NO, SET UP LARGE COUNT
	MOVEM A,FILCNT(JFN)
	SETZB A,FILBYT(JFN)
	RET

NILSQI:	TQO <EOFF>		;GENERATE EOF ON INPUT
	RET

NILSET:	TQO <NNAMF,NVERF>	;SET FLAGS
	HRRZ A,FILDDN(JFN)	;USE DIRECTORY NUMBER AS COUNTER
	TQNN <STEPF>		;STEPPING?
	RETSKP			;NO, GIVE OK RETURN
	SOSL A			;FIRST TIME?
	RETBAD (GNJFX1)		;NO, SAY NO MORE DIRECTORIES
	HRRM A,FILDDN(JFN)	;YES, STORE FLAG BACK
	RETSKP			;AND GIVE OK RETURN

NILLKP:	TQNN <STEPF>		;[7273]STEPPING
	RETSKP			;NO, GIVE OK RETURN
	RETBAD (GNJFX1)		;NO MORE NAMES

NILVLK:	CAME A,[-2]		;FIRST TIME?
	TQNN <STEPF>		;OR NOT STEPPING
	RETSKP			;THEN SAY OK
	RETBAD (GNJFX1)		;NO MORE VERSIONS
	SUBTTL STRING DEVICE FUNCTIONS

STRDTB::STRDTL			;LENGTH
	DTBBAD (GJFX32)		;DIR SET
	REPEAT BIND-DLUKD-1,<
	  DTBBAD (DESX9)>
	DTBDSP (STRIN)
	DTBDSP (STROUT)
	REPEAT DELD-BOUTD,<
	  DTBBAD (DESX9)>
	DTBBAD (DUMPX6)		;DUMPI
	DTBBAD (DUMPX6)		;DUMPO
	DTBBAD (DESX9)		;MOUNT
	DTBBAD (DESX9)		;DISMOUNT
	DTBBAD (DESX9)		;INITIALIZE DIR
	DTBBAD (MTOX1)		; MTOPR
	DTBBAD (DESX9)		;GET DEV STATUS
	DTBBAD (DESX9)		;SET DEV STATUS
	DTBSKP			;RECORD OUT
	DTBDSP (RFTADN)		; READ TAD
	DTBDSP (SFTADN)		; SET TAD
	DTBDSP (BIOINP)		;SET JFN FOR INPUT
	DTBDSP (BIOOUT)		;SET JFN FOR OUTPUT
	DTBBAD (GJFX49)		;CHECK ATTRIBUTE
	DTBSKP			;RLJFD - RELEASE JFN
	STRDTL==:.-STRDTB	;GLOBAL LENGTH OF DISPATCH TABLE

STRIN:	XCTBU [ILDB A,JFN]
	RET

STROUT:	XCTBU [IDPB A,JFN]
	RET

;DECREMENT BYTE POINTER
; A/ BYTE PTR
;	CALL DBP
; RETURNS +1, CLOBBERS B AND C

DBP::
	MOVNI T2,1		;ADJUST BY -1
	ADJBP T2,T1
	MOVEM T2,T1		;RETURN RESULT
	RET			;AND DONE
	SUBTTL PTY DEVICE FUNCTIONS

;DEVICE DEPENDENT ROUTINES. TO DO CERTAIN FUNCTIONS, THE RH OF DEV
;CONTAINS THE NAME OF A TABLE SUCH AS PTYDTB, AND A ROUTINE IS CALLED
;VIA 'CALL @FOO(DEV)', WHERE FOO IS A SYMBOL FOR AN OFFSET INTO THE
;TABLE. THE SYMBOLS ARE DEFINED IN PROLOG. IN THE COMMENTS BELOW,
;THE OFFSET IS INDICATED ALONG WITH THE PURPOSE OF THE ROUTINE

PTYDTB::PTYDTL			;LENGTH
	DTBDSP (PTYSET)		;DLUKD - DIRECTORY SETUP
	DTBBAD (DESX9)		;INLUKD - NAME LOOKUP
	DTBBAD (DESX9)		;ELUKD - EXTENSION LOOKUP
	DTBBAD (DESX9)		;VLUKD - VERSION LOOKUP
	DTBBAD (DESX9)		;PULKD - PROTECTION INSERTION
	DTBBAD (DESX9)		;ALUKD - ACCOUNT INSERTION
	DTBBAD (DESX9)		;SLUKD - STATUS INSERTION
	DTBDSP (PTYOPN)		;OPEND - OPEN FILE
	DTBDSP (PTYIN)		;BIND - BYTE INPUT
	DTBDSP (PTYOUT)		;BOUTD - BYTE OUTPUT
	DTBDSP (PTYCLZ)		;CLOSD - CLOSE FILE
	DTBBAD (DESX9)		;REND - RENAME
	DTBBAD (DESX9)		;DELD - DELETE FILE
	DTBBAD (DUMPX6)		;DMPID - DUMP MODE INPUT
	DTBBAD (DUMPX6)		;DMPOD - DUMP MODE OUTPUT
	DTBBAD (DESX9)		;MNTD - MOUNT DEVICE
	DTBBAD (DESX9)		;DSMD - DISMOUNT DEVICE
	DTBBAD (DESX9)		;INDD - INITIALIZE DIRECTORY OF DEVICE
	DTBDSP (PTMTOP)		;MTPD - DO MTAPE OPERATION
	DTBBAD (DESX9)		;GDSTD - GET DEVICE STATUS
	DTBBAD (DESX9)		;SDSTD - SET DEVICE STATUS
	DTBSKP			;RECOUT - FORCE RECORD OUT (SOUTR)
	DTBDSP (RFTADN)		;RFTADD - READ FILE TIME AND DATE
	DTBDSP (SFTADN)		;SFTADD - SET FILE TIME AND DATE
	DTBDSP (BIOINP)		;SET JFN FOR INPUT
	DTBDSP (BIOOUT)		;SET JFN FOR OUTPUT
	DTBBAD (GJFX49)		;CHECK ATTRIBUTE
	DTBSKP			;RELEASE JFN
	PTYDTL==:.-PTYDTB	;GLOBAL LENGTH OF DISPATCH TABLE

	DEFSTR (PTYFRK,PTYSTS(U),35,18) ;FORK INDEX OF OWNER
	DEFSTR (PTYCHN,PTYSTS(U),17,6) ;PSI CHANNEL NUMBER

;BITS IN AC 'IOS' - SEE DEFAC AT BEGINNING OF MODULE

FLG(POPEN,L,IOS,400000)		;PTY IS OPEN
FLG(PIIEN,L,IOS,200000)		;INPUT INTERRUPT ENABLED
FLG(POIEN,L,IOS,100000)		;OUTPUT INTERRUPT ENABLED
FLG(PIIEV,L,IOS,040000)		;INPUT EVENT OCCURRED
FLG(POIEV,L,IOS,020000)		;OUTPUT EVENT OCCURRED
FLG(PTBAT,L,IOS,010000)		;PTY IS BEING CONTROLED BY BATCH
;FUNCTION DLUKD FOR PTY - DIRECTORY SETUP

PTYSET:	TQO <NNAMF,NVERF>	;SAY NO NAME, VERSION, ETC
	RETBAD (GJFX32)

;OPEND FUNCTION FOR PTY - OPEN FILE

;ACCEPTS:
;	JFN/ JOB FILE NUMBER
;	DEV/ (UNIT NUMBER,,DISPATCH ADDRESS)

;CALL PTYOPN

;RETURNS +1: FAILURE
; 	 +2: SUCCESS

PTYOPN:	STKVAR <PTYOLN,ODEV>
	CALL CHKAPD		;FIX APPEND BIT
	HLRZ U,DEV		;GET UNIT NUMBER
	MOVE IOS,PTYSTS(U)
	TQOE <POPEN>		;ALREADY OPEN?
	RETBAD OPNX9		;YES
	HLRZ T2,DEV		;T2/ PTY NUMBER
	CALL PTYTTY		;GET CORRESPONDING TELETYPE NUMBER
	MOVEM T2,PTYOLN		;SAVE LINE NUMBER
	CALL STADYN		;IS LINE ALREADY ACTIVE?
	IFSKP.			;YES
	  MOVE B,PTYOLN		;GET LINE NUMBER
	  MOVEI A,.TTDES(B)  	;FORM TERMINAL DESIGNATOR
	  MOVEM DEV,ODEV	;SAVE DEV
	  CALL CHKDES		;GET INDEX INTO DEVICE TABLES
	   JFCL
	  MOVE DEV,ODEV		;RESTORE DEV
	  HLRZ A,DEVUNT(B)	;SEE WHO LAST ASSIGNED TTY
	  CAMN A,JOBNO		;THIS JOB?
	  JRST PTYOP2		;YES, SET PERM BIT FOR TTY
	  RETBAD (OPNX7)	;NO, INDICATE ASSIGNED TO ANOTHER JOB
	ENDIF.
	MOVE T2,PTYOLN		;T2/ LINE NUMBER
	CALL TTYASC		;ASSIGN DYNAMIC DATA FOR LINE
	 RETBAD			;FAILED
	MOVE T2,PTYOLN		;T2/ LINE NUMBER
	MOVEI T1,-1		;T1/ JOB NUMBER
	CALL STCJOB		;INDICATE NO CONTROLLING JOB FOR TERMINAL
PTYOP2:	MOVE T2,PTYOLN		;T2/ LINE NUMBER
	CALL STADYN		;POINT TO DYNAMIC DATA
	 JRST PTYOP1		;SHOULDN'T HAPPEN
	CALL STPRM		;MAKE THE DATA PERMANENT UNTIL PTY IS CLOSED
	MOVX IOS,POPEN		;SET THAT PTY IS NOW OPEN
	HRR IOS,FORKX		;REMEMBER FORK DOING OPEN
PTYRET:	MOVEM IOS,PTYSTS(U)
	RETSKP

PTYOP1:	BUG.(CHK,TTNAC1,FILMSC,HARD,<Line not active at PTYOPN>,,<

Cause:	STADYN was called to get the address of the dynamic data block for
	a TTY line that corresponds to PTY. This BUG means STADYN returned
	+1, indicating that there is no dynamic data block assigned for
	that line. This should never happen.

>)
	RETBAD (TTYX01)

;FUNCTION BIND FOR PTY - BYTE INPUT

;ACCEPTS:
;	DEV/ (UNIT,,DISPATCH ADDRESS)

;	CALL PTYIN

;RETURNS +1: ALWAYS,
;		T1/ A CHARACTER

;GETS A CHARACTER FROM THE ASSOCIATED TERMINAL'S OUTPUT BUFFER TO
;SERVE AS INPUT ON THE PTY.  BLOCKS IF NECESSARY. ALWAYS RETURNS WITH
;CHARACTER

PTYIN:	HLRZ 2,DEV
	CALL PTYTTY		;GET INTERNAL LINE NUMBER
	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA AND PREVENT
				; DEALLOCATION
	 JRST [	CALL ULKTTY	;NOT FULLY ACTIVE. ALLOW DEALLOCATION
		TQO <ERRF>	;INDICATE ERROR
		RET]
	CALL TTSTO		;GET CHAR FROM LINE, BLOCK IF NONE
	 JRST PTYIN		;TRY AGAIN
	CALL ULKTTY		;ALLOW DEALLOCATION
	RET

;FUNCTION BOUTD FOR PTY - BOUT OUTPUT

;ACCEPTS:
;	T1/ A CHARACTER
;	DEV/ (UNIT,,DISPATCH ADDRESS)

;	CALL PTYOUT

;RETURNS +1: ALWAYS

;FOR THE ASSOCIATED TERMINAL, SIMULATES REMOVING THE SPECIFIED
;CHARACTER FROM TTBBUF AND PLACING IT IN THE LINE'S INPUT BUFFER
;(ISSUING AN INTERRUPT IF NECESSARY, ECHOING, ETC.)

PTYOUT:	HLRZ 2,DEV		;GET PTY NUMBER
	CALL PTYTTY		;CONVERT TO INTERNAL LINE NUMBER
	CALL TTSTI		;PUT CHAR INTO LINE
	 JRST [	TQO <BLKF>	;FAILED
		HRLZ T1,T1	;LEAVE ERR CODE IN LH
		RET]
	RET

;FUNCTION CLOSD FOR PTY - CLOSE FILE

;ACCEPTS:
;	DEV/ (UNIT,,DISPATCH ADDRESS)

;	CALL PTYCLZ

;RETURNS +1: FAILURE
;	 +2: SUCCESS

;ON FAILURE, IF BLOCKING IS NECESSARY, BLKF IS SET AND T1 CONTAINS
;(LINE NUMBER,,ADDRESS OF TEST ROUTINE)

PTYCLZ:	STKVAR <PTYCLN>
	HLRZ 2,DEV
	CALL PTYTTY		;GET LINE NUMBER
	MOVEM T2,PTYCLN		;SAVE LINE NUMBER
	CALL LCKTTY		;POINT TO DYNAMIC DATA
	 JRST [	CALL ULKTTY	;NOT ACTIVE
		JRST PTYCL1]	;SKIP DEALLOCATION AND DETACH
	CALL CLRPRM		;CLEAR PERMANENT BIT SO DEASSIGN WILL HAPPEN
	CALL ULKTTY		;ALLOW DEALLOCATION
	MOVE T2,PTYCLN		;T2/ LINE NUMBER
	CALL GTCJOB		;GET OWNING JOB
	 JRST PTYCL1		;LINE NOT ACTIVE. DON'T DETACH OR DEALLOCATE
	CAIN T3,-1		;ANY JOB?
	JRST PTYCL2		;NO. GO DEALLOCATE DATA

;A JOB EXISTS ON THIS LINE. GO DETACH IT. THIS WILL CAUSE THE TERMINAL
;DATA BLOCK TO BE DEASSIGNED

	NOSKED
	CALL NTYCOF		;CAUSE CARRIER OFF ACTION
	OKSKED
	JRST PTYCL1

;NO JOB EXISTS ON THIS LINE.  DEASSIGN TERMINAL'S DATA BASE
;AND INDICATE THAT THE PTY IS CLOSED

PTYCL2:	NOSKED			;NO INTERFERENCE UNTIL TTY AND PTY AGREE
	MOVE T2,PTYCLN		;T2/ LINE NUMBER
	CALL TTYDEA		;DEALLOCATE THE DYNAMIC DATA
	 JRST [	OKSKED
		JRST PTYCL4]	;FAILED.
	HLRZ U,DEV		;GET PTY NUMBER
	SETZM PTYSTS(U)		;INDICATE PTY CLOSED
	OKSKED
	RETSKP

;TERMINAL SIDE IS NOT ACTIVE. INDICATE PTY IS CLOSED

PTYCL1:	HLRZ U,DEV		;GET PTY NUMBER
	SETZ IOS,		;CLEAR OPEN BIT AND ALL OTHERS
	JRST PTYRET

;UNABLE TO DEASSIGN. RETURN TO CALLER, WHICH WILL WAIT

PTYCL4:	TXZN T1,1B0		;FAILURE OR WAIT?
	RETBAD			;FAILURE. RETURN ERROR CODE
	HRL T1,T2		;WAIT. T1/(LINE NUMBER,,ROUTINE ADDRESS)
	TQO BLKF		;INDICATE WAIT NECESSARY
	RETBAD			;TAKE FAILURE RETURN
;FUNCTION MTPD FOR PTY - MTOPR

;ACCEPTS:
;	USER T2/ FUNCTION CODE
;	USER T3/ ARGUMENT OR ADDRESS OF ARGUMENT BLOCK
;	DEV/ (PTY NUMBER,,PTYDTB)

;	CALL PTMTOP

;RETURNS +1: FAILURE
;	 +2: SUCCESS

PTMTOP:	TQNN <OPNF>		;CHECK FOR OPENED
	RETBAD (CLSX1)		;NOT OPENED ERROR
	HLRZ U,DEV		;GET PTY NUMBER
	UMOVE 2,2		;GET FUNCTION CODE FROM USER
	MOVEI 3,0(2)		;MTOPR OP CODE
	CAIN 3,.MOAPI		;ASSIGN PTY INTERRUPT CHANNEL?
	JRST PTENAI		;ENABLE INTERRUPTS
	CAIN 3,.MOPIH		;PTY HUNGRY?
	JRST PTSTIH		;TEST INPUT HUNGRY
	CAIE 3,.MOBAT		;SET BATCH BIT?
	RETBAD (MTOX1)		;ILLEGAL FUNCTION
	MOVX T1,PTBAT		;INITIALIZE BATCH BIT TO 0
	ANDCAM T1,PTYSTS(U)
	XCTU [SKIPE 3]		;SETTING THE BATCH BIT?
	IORM T1,PTYSTS(U)	;YES, PTY IS A BATCH PTY
	RETSKP

;MTOPR FUNCTION .MOPIH - SEE IF PTY IS HUNGRY

;RETURNS +2: ALWAYS
;	USER T2/ 0 FOR NOT HUNGRY
;		 -1 FOR HUNGRY

PTSTIH:	MOVE T2,U		;T2/ PTY NUMBER
	CALL PTYTTY		;CONVERT TO INTERNAL LINE NUMBER
	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA, PREVENT DEALLOCATION
	 JRST [	CALL ULKTTY	;NOT ACTIVE. ALLOW DEALLOCATION
		SETZ T1,	;ASSUME NOT HUNGRY
		SKIPN T2	;UNLESS LINE IS NOT ACTIVE AT ALL
		SETO T1,	;THEN MAKE IT HUNGRY
		JRST PTSTI1]
	CALL TTSTIH		;TEST INPUT HUNGRY ON TTY
	CALL ULKTTY		;ALLOW DEALLOCATION
PTSTI1:	UMOVEM 1,2		;RETURN ANSWER TO USER
	RETSKP

;MTOPR FUNCTION .MOAPI - ASSIGN INTERRUPT CHANNELS

PTENAI:	NOINT
	LOCK JFNLCK		;LOCK THE JFN
	CALL REAJFN		;CHECK AND REASSIGN THE JFN IF NECESSARY
	 JFCL
	UNLOCK JFNLCK		;RELEASE THE LOCK
	OKINT
	MOVE 3,FORKX		;GET THIS FORK'S INDEX
	HRRM 3,PTYSTS(U)	;REASSIGN FORK
	LDB 3,[POINT 6,2,17]	;GET CHANNEL ASSIGNMENT
	SKIPL 3			;IS THE CHANNEL NON-NEGATIVE?
	CAIL 3,<^D36-1>		;IS IT < 35?
	RETBAD (MTOX18)		;BAD VALUE. INPUT HAS TO BE <=34
				;SO OUTPUT CAN BE <=35
	STOR 3,PTYCHN		;REMEMBER IT
	MOVX 3,PIIEN		;INPUT INTERRUPT ENABLED FLAG
	ANDCAM 3,PTYSTS(U)
	TLNE 2,(MO%WFI)		;SET IT ACCORDING TO B0 OF ARG
	IORM 3,PTYSTS(U)
	MOVX 3,POIEN		;OUTPUT INTERRUPT ENABLED FLAG
	ANDCAM 3,PTYSTS(U)
	TLNE 2,(MO%OIR)		;SET IT ACCORDING TO B1 OF ARG
	IORM 3,PTYSTS(U)
	CALL PTTINT		;SEE IF INTERRUPT NOW POSSIBLE
	RETSKP

;ROUTINE CALLED FROM SCHEDULER TO SEE IF JOB IS A BATCH JOB
;	T1/ CONTROLLING TERMINAL NUMBER

CHKBCH::CALL CHKPTY		;SEE IF A PTY
	 RET			;NO. ERGO NOT BATCH
	MOVX T2,PTBAT		;GET BATCH BIT
	TDNN T2,PTYSTS(T1)	;IS THIS A BATCH PTY?
	RET			;NO
	RETSKP			;IS BATCH

;PTYINI - ROUTINE CALLED FROM OPENF TO INITIALIZE THE PTY PARAMETERS

;ACCEPTS:
;	DEV/ UNIT,,CODE

;	CALL PTYINI

;RETURNS +1: ALWAYS

;INITIALIZES VALUES FOR THE TERMINAL ASSOCIATED WITH THE GIVEN PTY
;THIS IS DONE BEFORE THE JOB IS CREATED ON THE LINE SO THAT THE OWNER
;OF THE PTY CAN CONTROL THE LINE.  OPENING THE PTY HAS CAUSED THE
;ASSOCIATED TERMINAL TO HAVE PERMANENT DYNAMIC DATA, WHICH WILL
;BE DEALLOCATED WHEN THE PTY IS CLOSED

PTYINI::HLRZ B,DEV		;GET PTY UNIT
	CALL PTYTTY		;CONVERT TO LINE NUMBER
	MOVEI A,.TTDES(B)	;GET DESIGNATOR (400000+N)
	MOVE B,NORMTF		;GET NORMAL SETTING
	SFMOD			;SET MODES
	STPAR			;AND THESE AS WELL
	MOVEI B,.TTIDL		;SET IT TO BE "IDEAL" TERMINAL
	STTYP			;SET THE TYPE
	DMOVE B,TTICB1		;DEFAULT CONTROL ACTIONS
	SFCOC
	HRLI A,(TL%CRO+TL%COR+TL%SAB+TL%STA) ;BREAK ALL LINKS AND SET REFUSE
	MOVEI B,-1		;ALL REMOTES
	TLINK			;GO DO IT
	 JFCL
	RET			;AND DONE

;GET FORK OF OWNER OF PTY
; 1/ TTY NUMBER
;	CALL PTYGFK
; RETURN +1: NO PTY FOR THAT TTY
; RETURN +2: SUCCESS,
;		T1/ FORKX OF OWNER

PTYGFK::CALL CHKPTY		;GET PTY NUMBER
	 RETBAD			;NO
	PUSH P,U		;YES. SAVE AC
	MOVE U,T1		;PUT PTY NUMBER IN NECESSARY AC
	LOAD 1,PTYFRK		;GET FORK (USES AC U)
	POP P,U			;RESTORE U
	RETSKP

;ROUTINE TO SEE IF A PTY IS A BATCH PTY
;ACCEPTS IN T1/	TTY NUMBER
;	CALL PTYGBB
;RETURNS +1:	NOT A PTY
;	 +2:	0 = NOT BATCH
;		-1 = BATCH PTY

PTYGBB::CALL CHKPTY		;GET PTY NUMBER
	 RETBAD			;NO. RETURN FAILURE
	MOVE T2,PTYSTS(T1)	;YES, GET STATUS WORD
	TXNN T2,PTBAT		;BATCH BIT ON?
	TDZA T1,T1		;NO
	SETO T1,		;YES
	RETSKP			;RETURN

;CHECK IF ACCESS TO TTY IS OK BECAUSE IT IS CONTROLLED BY PTY OF
; THIS JOB.
; 1/ TTY #
; RETURNS +1, 1/ 0= FALSE
;	-1 = TRUE (ACCESS OK)

PTCHKA::CALL CHKPTY		;GET PTY NUMBER
	 JRST PTCHK1		;NOT A PTY
	MOVX T2,POPEN
	TDNN T2,PTYSTS(T1)	;PTY IS OPEN?
	JRST PTCHK1		;NO
	HRRZ T2,PTYSTS(T1)	;OWNING FORK
	LOAD T2,FKJO%,(T2)	;OWNING JOB
	CAME T2,JOBNO		;IS OWNING JOB SAME AS THIS JOB?
PTCHK1:	TDZA 1,1		;NO, RETURN FALSE
	SETO 1,			;RETURN TRUE
	RET

;FIND JOB NUMBER OF JOB CONTROLLING PTY
; 1/ TTY NUMBER
; RETURN +1: 1/ JOB NUMBER, OR -1 IF NOT PTY OR PTY NOT OPENED

PTGETJ::CALL CHKPTY		;GET PTY NUMBER
	 JRST PTGJ1		;NOT A PTY
	MOVX T2,POPEN
	TDNN T2,PTYSTS(T1)	;PTY OPEN?
	JRST PTGJ1		;NO
	HRRZ T2,PTYSTS(T1)	;GET CONTROLLING FORK
	LOAD T1,FKJO%,(T2)	;GET JOB NUMBER
	RET

PTGJ1:	SETO T1,		;INDICATE NOT A PTY OR NOT OPEN
	RET

	RESCD

;FOLLOWING CODE RESIDENT BECAUSE CALLED FROM TTYSRV AT PI LEVEL

;ACCEPTS:
;	T1/ PTY NUMBER

;CALLED WHEN LINE IS GOING INTO INPUT WAIT

PTYFIN::PUSH P,IOS
	PUSH P,U
	MOVE U,T1		;GET PTY NUMBER IN CORRECT AC
	MOVX IOS,PIIEV		;INPUT EVENT FLAG
	JRST PTYF1

;ACCEPTS:
;	T1/ PTY NUMBER

;CALLED WHEN STARTING OUTPUT TO A LINE

PTYFOU::PUSH P,IOS
	PUSH P,U
	MOVE U,T1
	MOVX IOS,POIEV		;OUTPUT EVENT FLAG
PTYF1:	IORB IOS,PTYSTS(U)	;SET APPROPRIATE FLAG
	CALL PTTINT		;SEE IF INTERRUPT NOW POSSIBLE
	POP P,U
	POP P,IOS
	RET

;INITIATE INTERRUPT IF POSSIBLE

;ACCEPTS:
;	U/ PTY NUMBER

PTTINT:	PUSH P,1
	PUSH P,2
	SETCM 3,PTYSTS(U)	;GET COMPLEMENTED FLAGS
	TXNN 3,PIIEV+PIIEN	;SEE IF INPUT ENABLE AND EVENT BOTH SET
	JRST [	MOVX IOS,PIIEV	;YES, CLEAR EVENT
		ANDCAB IOS,PTYSTS(U)
		LOAD 1,PTYCHN	;DESIGNATED CHANNEL
		MOVEI 2,0(IOS)	;DESIGNATED FORK
		CALL PSIRQ	;REQUEST INTERRUPT
		JRST .+1]
	SETCM 3,PTYSTS(U)	;GET COMPLEMENTED FLAGS
	TXNN 3,POIEV+POIEN	;SEE IF OUTPUT ENABLE AND EVENT BOTH SET
	JRST [	MOVX IOS,POIEV	;YES, CLEAR EVENT
		ANDCAB IOS,PTYSTS(U)
		LOAD 1,PTYCHN	;ON DESIGNATED CHANNEL +1
		ADDI 1,1
		MOVEI 2,0(IOS)	;TO DESIGNATED FORK
		CALL PSIRQ	;REQUEST INTERRUPT
		JRST .+1]
	POP P,2
	POP P,1
	RET

;SKIP IF PTY OPEN
;GIVEN TTY LINE NUMBER IN 2

PTYSKO::PUSH P,IOS
	PUSH P,T1
	MOVE T1,T2
	CALL TTYPTY
	MOVE IOS,PTYSTS(T1)
	TQNE <POPEN>		;OPEN?
	JRST [	POP P,T1	;YES. TAKE SUCCESS RETURN
		POP P,IOS
		RETSKP]
	POP P,T1		;NO. TAKE FAILURE RETURN
	POP P,IOS
	RET
	SUBTTL RESCAN JSYS

	SWAPCD
.RSCAN::MCENT
	TLNE 1,-1		;BITS IN L.H.?
	JRST RSC0		;YES, ASSUME BYTE POINTER
	CAIL A,RFNLEN		;LEGAL FUNCTION?
	RETERR RSCNX2		;NO, "RSCAN FUNCTION CODE OUT OF RANGE"
	JRST @RFNTAB(1)		;IN RANGE, DO IT.

;DISPATCH TABLE FOR RSCAN FUNCTIONS

RFNTAB:	IFIW!REINIT		;0 MEANS MAKE BUFFER AVAILABLE FOR INPUT
	IFIW!RECNT		;1 MEANS COUNT CHARACTERS LEFT TO READ
RFNLEN==.-RFNTAB

RECNT:	MOVEI 1,0		;START WITH COUNT OF 0
	SKIPN 2,RSCNPT		;READING FROM RESCAN BUFFER?
	JRST RSC5		;NO, RETURN COUNT OF 0
	JRST RSC4		;YES, GO COUNT REMAINING CHARS

REINIT:	SKIPN 2,RSCNBP		;REINITIALIZE THE POINTER
	JRST RSC5		;NO BYTE POINTER, RETURN 0
	HRLI 2,(POINT 7,0,34)	;SET UP BYTE POINTER
	MOVEM 2,RSCNPT
	SKIPA			;SKIP ADDI FIRST TIME
RSC6:	ADDI 1,1		;COUNT A CHAR
RSC4:	ILDB 3,2		;GET NEXT CHAR
	JUMPN 3,RSC6		;END YET?
RSC5:	UMOVEM 1,1		;YES, RETURN COUNT TO USER
	SMRETN

RSC0:	NOSKED			;SETTING UP A NEW BUFFER
	NOINT			;THIS TOO
	SETZM RSCNPT		;ZERO PREVIOUS POINTER
	MOVE T2,RSCNBP		;GET PREVIOUS BUFFER
	SETZM RSCNBP		;NONE HERE NOW
	OKSKED
	JUMPE T2,RSC1		;IF NO BUFFER, GO ON
	MOVEI T1,JSBFRE		;YES, RELEASE ITS SPACE
	CALL RELFRE
RSC1:	OKINT
	UMOVE Q3,1		;GET STRING POINTER
	TLC Q3,-1		;LH = -1?
	TLCN Q3,-1
	HRLI Q3,(POINT 7,0)	;YES, MAKE IT A VALID STRING POINTER
	MOVEI T4,RSCMXC		;SET UP MAX COUNT
	MOVEI T2,^D11		;START WITH ENOUGH CHARACTERS FR HEADER
	MOVE T3,Q3		;GET STARTING POINTER
RSC2:	XCTBU [ILDB T1,T3]	;GET A CHARACTER
	SOJLE T4,[RETERR (RSCNX1)]
	SKIPE T1		;FOUND THE NULL YET?
	AOJA T2,RSC2		;NO, COUNT UP THIS CHARACTER
	MOVEI P3,-^D10(T2)	;GET COUNT OF CHARACTERS IN STRING
	IDIVI T2,5		;GET WORDS FOR BUFFER SPACE
	NOINT			;GUARD AGAINST DATA BASE LOSSAGE
	CALL ASGJFR		;GET SPACE FOR BUFFER
	 RETERR ()		;NOT ENOUGH ROOM
	HRRZM T1,RSCNBP		;SAVE THE POINTER TO THE BUFFER
	HRLI T1,(POINT 7,0,34)	;SET UP A POINTER TO IT
RSC3:	XCTBU [ILDB T2,Q3]	;GET NEXT CHARACTER
	IDPB T2,T1		;STORE IT IN THE BUFFER
	SKIPE T2		;FOUND THE NULL YET?
	SOJG P3,RSC3		;NO, LOOP BACK FOR REST
	MOVEI T2,0		;END WITH A NULL
	DPB T2,T1
	UMOVEM Q3,1		;STORE THE UPDATED STRING POINTER
	SMRETN			;DONE
;	TTY DEVICE FUNCTIONS

;DEVICE DEPENDENT ROUTINES. TO DO CERTAIN FUNCTIONS, THE RH OF DEV
;CONTAINS THE NAME OF A TABLE SUCH AS TTYDTB, AND A ROUTINE IS CALLED
;VIA 'CALL @FOO(DEV)', WHERE FOO IS A SYMBOL FOR AN OFFSET INTO THE
;TABLE. THE SYMBOLS ARE DEFINED IN PROLOG. IN THE COMMENTS BELOW,
;THE OFFSET IS INDICATED ALONG WITH THE PURPOSE OF THE ROUTINE

TTYDTB::TTYDTL			;LENGTH
	DTBDSP (TTYSET)		;DLUKD - DIRECTORY SETUP
  REPEAT OPEND-DLUKD-1,<DTBBAD (DESX9)>
	DTBDSP (TTYOPN)		;OPEND - OPEN FILE
	DTBDSP (TTYIN)		;BIND - BYTE INPUT
	DTBDSP (TTYOUT)		;BOUTD - BYTE OUTPUT
	DTBDSP (TTYCLZ)		;CLOSD - CLOSE FILE
	DTBBAD (DESX9)		;REND - RENAME
	DTBBAD (DESX9)		;DELD - DELETE FILE
	DTBBAD (DUMPX6)		;DMPID - DUMP MODE INPUT
	DTBBAD (DUMPX6)		;DMPOD - DUMP MODE OUTPUT
	DTBBAD (DESX9)		;MNTD - MOUNT DEVICE
	DTBBAD (DESX9)		;DSMD - DISMOUNT DEVICE
	DTBBAD (DESX9)		;INDD - INITIALIZE DIRECTORY OF DEVICE
	DTBDSP (TTMTOP)		;MTPD - DO MTAPE OPERATION
	DTBDSP (TTGDST)		;GDSTD - GET DEVICE STATUS
	DTBBAD (DESX9)		;SDSTD - SET DEVICE STATUS
	DTBSKP			;RECOUT - FORCE RECORD OUT (SOUTR)
	DTBDSP (RFTADN)		;RFTADD - READ FILE TIME AND DATE
	DTBDSP (SFTADN)		;SFTADD - SET FILE TIME AND DATE
	DTBDSP (BIOINP)		;SET JFN FOR INPUT
	DTBDSP (BIOOUT)		;SET JFN FOR OUTPUT
	DTBBAD (GJFX49)		;CHECK ATTRIBUTE
	DTBSKP			;RELEASE JFN
	TTYDTL==:.-TTYDTB	;GLOBAL LENGTH OF DISPATCH TABLE

;DLUKD FUNCTION FOR TTY - DIRECTORY SETUP

TTYSET::TQO <NVERF,NNAMF>
	RETBAD (GJFX32)

;OPEND FUNCTION FOR TTY - OPEN FILE

;ACCEPTS:
;	JFN/ JOB FILE NUMBER
;	DEV/ (UNIT NUMBER,,DISPATCH ADDRESS)

;	CALL TTYOPN

;RETURNS +1: FAILURE
;	 +2: SUCCESS

TTYOPN::STKVAR <TTYOPX>
	CALL CHKAPD		;FIX APPEND BIT
TTYOP1:	CALL CKJFTT		;SEE IF JFN IS FOR 'TTY:'
	 RETSKP			;YES. THIS ALWAYS SUCCEEDS
	CALL LCKDVL		;LOCK THE DEVICE TABLES
	CALL FNDUNT		;GET INDEX INTO DEVICE TABLE FOR THIS UNIT
	MOVEM A,TTYOPX		;SAVE INDEX INTO DEVICE TABLES
	HRRZ B,A		;GET INTO CORRECT AC
	CALL DEVAV		;IS THIS DEVICE AVAILABLE TO US?
	 RETBAD (OPNX7,<UNLOKK DEVLKK
			OKINT>) ;NO. RETURN NOT AVAILABLE
	HLRZ B,DEV		; Get tty line number
	CALL TTYASO		;ASSIGN TERMINAL IF POSSIBLE
	 JRST TTYOP2		;ERROR. GO SEE WHAT TO DO
	HRRZ A,TTYOPX		;GET INDEX INTO DEVICE TABLES
	MOVE B,JOBNO		;NO. STORE JOB NUMBER IN DEVUNT
	HLRE C,DEVUNT(A)	;GET CURRENT OWNER
	HRLM B,DEVUNT(A)
	MOVX B,DV%OPN		;AND INDICATE OPEN IN DEVCHR
	IORM B,DEVCHR(A)
	IFL. C			;IF PREVIOUSLY UNOWNED
	 HLRZ B,DEV		;GET LINE NUMBER AGAIN
	 CALL TTPINI		;INIT TERMINAL PARAMETERS
	ENDIF.			;AND GO ON
TTYOP3:	UNLOKK DEVLKK		;UNLOCK DEVICE TABLES
	OKINT
	HLRZ T2,DEV		;[7435] Get internal line number
	CAME T2,CTRLTT		;[7435] Unless its the controlling terminal
	CALL TTUHUP		;[7435] (T2/) Raise DTR for dialing out
	TQO <SIZF>
	RETSKP

;FAILED. SEE IF GIVING UP OR WAITING

TTYOP2:
	UNLOKK DEVLKK		;UNLOCK DEVICE TABLES
	OKINT
	TXZN T1,1B0		;WAITING?
	RETBAD			;NO. FAIL
	HRL T1,T2		;GET LINE NUMBER
	MDISMS			;WAIT
	JRST TTYOP1		; AND GO TRY AGAIN
;BIND FUNCTION FOR TTY - BYTE INPUT

;ACCEPTS:
;	DEV/ (UNIT,,DISPATCH ADDRESS)
;	JFN/ JFN OR -1 OR 400000+LINE NUMBER

;	CALL TTYIN

;RETURNS +1: ALWAYS,
;		T1/ THE CHARACTER

;GETS ONE INPUT CHARACTER FOR THE LINE. IF NONE IS AVAILABLE, BLOCKS.

;THERE'S A BUG IN THE FOLLOWING CODE.  IF JFN CONTAINS -1, CODE
;KNOWS TO CHECK RSCAN BUFFER.  HOWEVER, NOTICE HOW WHEN JFN CONTAINS
;REAL JFN FOR "TTY", RSCAN BUFFER ISN'T CHECKED!

TTYIN::	CAIE JFN,-1		;CONTROLLING TTY?
	JRST [	CAIGE JFN,400000;NO, REAL JFN?
		JRST TTYIN2	;YES
		JRST TTYIN0]	;NO, TERMINAL DESIGNATOR
	MOVE A,JOBNO		;SET UP LINE NUMBER
	HLL DEV,JOBPT(A)
	HLRZ B,JOBPT(A)		;GET LINE NUMBER
	CAIE B,-1		;NOW ATTACHED?
TTYIN1:	CALL CKBJFN		;HAS A BKJFN BEEN DONE?
	 SKIPA			;NO.
	JRST TTYINX		;YES. GO USE THAT CHARACTER INSTEAD OF RSCAN
	SKIPN RSCNPT		;RESCAN PTR SET?
	JRST TTYINX		;NO
	ILDB A,RSCNPT		;YES, GET CHAR FROM RESCAN BUFFER
	JUMPN A,R		;USE IT UNLESS IT'S NULL
	NOINT			;NO INTERRUPTS WHILE RELEASING FREE SPACE
	NOSKED			;OWN SYSTEM
	SETZM RSCNPT		;FLUSH POINTER
	MOVE B,RSCNBP		;GET CURRENT RSCAN BUFFER POINTER
	SETZM RSCNBP		;NO POINTER NOW
	OKSKED
	MOVEI A,JSBFRE		;RELEASE THE OLD BUFFER
	SKIPE B			;IF NO BUFFER, ALL DONE
	CALL RELFRE		;RELEASE IT
	OKINT			;OK NOW THAT FREE SPACE RETURNED
	JRST TTYINX		;REPARSE DONE, GO GET REAL CHARACTER

; Here after an input block has occurred to re-verify the JFN and DEV

TTYIN3:	CAIL JFN,400000		;JFN OR 400000+LINE NUMBER?
	JRST TTYIN		;TTY DESIGNATOR
	HLRZ B,FILDDN(JFN)	;GET POINTER TO DEVICE NAME
	MOVE B,1(B)		;GET DEVICE STRING
	TRZ B,377		;FLUSH POSSIBLE GARBAGE
	CAMN B,[ASCIZ /TTY/]	;IS THIS THE CONTROLLING TTY?
	IFNSK.
	  HRRZ A,FORKN		;GET NUMBER OF THIS FORK
	  LOAD A,FRKTTY,(A)	;GET FORK CONTROLLING TERMINAL
	  TRZ A,.TTDES		;GET POSSIBLE TERMINAL NUMBER
	  CAIN A,-1-.TTDES	;DID ONE EXIST?
	  HRRZ A,CTRLTT		;NO, USE JOB CONTROLLING TERMINAL
	  HRL DEV,A		;PLACE IN DEV
	  JRST TTYIN		;Try again
	ENDIF.
	TRZ B,77400		;Keep only the device name
	CAME B,[ASCIZ /TTY/]	;Is this a terminal JFN?
	IFSKP.			;Yes
	  HRRZ A,FORKN		;Get the number of this fork
	  LOAD A,FRKTTY,(A)	;Get fork controlling terminal
	  TRZ A,.TTDES		;Get possible terminal number
	  CAIN A,-1-.TTDES	;Did one exist?
	  ANSKP.		;Yes
	    LOAD T2,STR,(JFN)	;Get terminal number of JFN
	    CAMN T1,T2		;Is JFN for the fork controlling TTY?
	    HRL DEV,A		;Yes, place correct line number in DEV
	ENDIF.			;
	JRST TTYIN		;Try again

;Here when we know JFN contains a real JFN.

TTYIN2:	LDB B,[POINT 4,STS,35]	;Get mode of open
	JUMPE B,[LDB B,PBYTSZ	;IF ZERO, USE NORMAL FOR THE TERMINAL
		CAIE B,8	;WAS OPENED WITH BYTE SIZE OF 8?
		JRST TTYINX	;NO. ALLOW TRANSLATION
		JRST TTYINB]	;YES. ASSUME BINARY
	CAIE B,10		;OPENED IN BINARY MODE
TTYINX:	SKIPA D,[TCI]		;CALL INPUT ROUTINE THAT ALLOWS TRANSLATION
TTYINB:	MOVEI D,TCIB		;CALL INPUT ROUTINE FOR BINARY INPUT
	HLRZ 2,DEV		;GET INTERNAL LINE NUMBER
	CAIN 2,-1		;LINE NUMBER AVAILABLE?
	CALL TTYATW		;NO, WAIT FOR ATTACH
	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA, PREVENT DEALLOCATION
	JRST [	CALL ULKTTY	;NOT ACTIVE. ERROR
		TQO ERRF	;INDICATE FAILURE TO CALLER
		RET]
	CALL 0(D)
	 JRST TTYIN3		;Blocked. Go try again (TTYSRV UNLOCKED DATA)
	CALL ULKTTY		;ALLOW DEALLOCATION
	CAIL JFN,400000		;JFN OR 400000+LINE NUMBER?
	 RET			;TERMINAL DESIGNATOR
	HLLZ B,FILBYT(JFN)	;JFN. GET BYTE SIZE FROM OPENF
	TLZ B,770000		;POINT TO END OF AC
	HRRI B,A		;FORM BYTE POINTER TO GET CHARACTER
	LDB A,B			;GET THE NUMBER OF BITS ASKED FOR
	RET			;RETURN CHARACTER OF CORRECT SIZE

;Come here when 400000+n is given

TTYIN0:	HRRZ A,FORKN
	LOAD A,FRKTTY,(A)	;GET OUR CONTROLLING TERMINAL
	CAIE A,-1		;DO WE NOT HAVE ONE?
	CAME A,JFN		;OR WE HAVE ONE BUT JFN DOESN'T MATCH?
	JRST TTYINX		;NO RESCAN, SINCE RANDOM TERMINAL DESIGNATOR
	MOVEI B,-.TTDES(JFN)	;READING FROM OUR PROCESS CTTY, SO
	JRST TTYIN1		;GO CHECK RESCAN DATA

;BOUTD FUNCTION FOR TTY - BOUT OUTPUT

;ACCEPTS:
;	T1/ CHARACTER
;	DEV/ (UNIT,,DISPATCH ADDRESS)

;	CALL TTYOUT

;RETURNS +1: ALWAYS

;OUTPUTS ONE CHARACTER TO THE SPECIFIED TERMINAL.

TTYOUT::HLRZ B,JFN		;Get left half of designator
	CAIN B,600000+.DVTTY	;If universal device designator specifies
	 JRST TTYOUX		;  terminal, then terminal number in LH(DEV)
	CAIL JFN,400000		;JFN OR 400000 + LINE NUMBER?
	 JRST TTYOUX		;400000 + LINE NUMBER
	HLLZ B,FILBYT(JFN)	;GET BYTE SIZE FROM OPENF
	TLZ B,770000		;POINT TO END OF AC
	HRRI B,A		;CREATE BYTE POINTER TO CHARACTER IN AC
	LDB A,B			;GET AS MANY BITS AS OPENED FOR
	LDB B,[POINT 4,STS,35]	;GET MODE IN WHICH OPENED
	JUMPE B,[LDB B,PBYTSZ	;IF NORMAL MODE, GET BTYE SIZE OPENED FOR
		CAIE B,8	;OPENED FOR 8-BIT BYTES?
		JRST TTYOUX	;NO. ALLOW TRANSLATION
		JRST TTYOUB]	;YES. BINARY OUTPUT
	CAIE B,10		;NOT NORMAL MODE. BINARY?
TTYOUX:	SKIPA D,[TCO]		;CALL ROUTINE THAT ALLOWS TRANSLATION
TTYOUB:	MOVEI D,TCOB		;CALL ROUTINE FOR BINARY OUTPUT
	HLRZ B,DEV		;GET LINE NUMBER
	CAIN 2,-1		;LINE NUMBER AVAILABLE?
	CALL TTYATW		;NO, WAIT FOR ATTACH
	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA, PREVENT DEALLOCATION
	JRST [	CALL ULKTTY	;NOT ACTIVE. ERROR
		TQO ERRF	;INDICATE ERROR TO CALLER
		RET]
	CALL 0(D)		;CALL OUTPUT ROUTINE IN TTYSRV
	CALLRET ULKTTY		;ALLOW DEALLOCATION

;SOUT FUNCTION FOR TTY - SOUT OUTPUT

;ACCEPTS:
;	DEV/ (UNIT,,DISPATCH ADDRESS)

;	CALL TTYBLO

;RETURNS +1 BLOCK OR ERROR
;RETURNS +2 FINISHED

;OUTPUTS STRING TO THE SPECIFIED TERMINAL.

TTYBLO::HLRZ B,DEV		;GET LINE NUMBER
	CAIN 2,-1		;LINE NUMBER AVAILABLE?
	CALL TTYATW		;NO, WAIT FOR ATTACH
	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA, PREVENT DEALLOCATION
	JRST [	CALL ULKTTY	;NOT ACTIVE. ERROR
		TQO ERRF	;INDICATE ERROR TO CALLER
		RET]
	MOVSI Q3,-1000		;SET UP A COUNTER
TTYOLP:	XCTBUU [ILDB A,2]	;GET A BYTE
	XCTU [SKIPN 3]		;CHECK FOR NO CHARACTERS
	JUMPE A,TTYOLX		;FINISHED

	CAIL JFN,400000		;JFN OR 400000 + LINE NUMBER?
	 JRST TTYOUY		;400000 + LINE NUMBER
	HLLZ D,FILBYT(JFN)	;GET BYTE SIZE FROM OPENF
	TLZ D,770000		;POINT TO END OF AC
	HRRI D,A		;CREATE BYTE POINTER TO CHARACTER IN AC
	LDB A,D			;GET AS MANY BITS AS OPENED FOR
	LDB D,[POINT 4,STS,35]	;GET MODE IN WHICH OPENED
	JUMPE D,[LDB D,PBYTSZ	;IF NORMAL MODE, GET BTYE SIZE OPENED FOR
		CAIE D,8	;OPENED FOR 8-BIT BYTES?
		JRST TTYOUY	;NO. ALLOW TRANSLATION
		JRST TTYOUZ]	;YES. BINARY OUTPUT
	CAIE D,10		;NOT NORMAL MODE. BINARY?
TTYOUY:	SKIPA D,[TCO]		;CALL ROUTINE THAT ALLOWS TRANSLATION
TTYOUZ:	MOVEI D,TCOB		;CALL ROUTINE FOR BINARY OUTPUT
	PUSH P,A		;SAVE CHARACTER FOR DONE CHECK
	CALL 0(D)		;CALL OUTPUT ROUTINE IN TTYSRV
	TQZN <BLKF>		;CHECK FOR BLOCKED AND CLEAR
	TQNE <ERRF>		;ERROR?
	JRST [	POP P,A		;UNLOCK AND RETURN ERROR/BLOCKED
		JRST ULKTTY]
	EXCH B,0(P)		;SET CHARACTER FOR DONE CHECK
	CALL SIONXT		;CHECK FOR END OF STRING
	JRST [	POP P,B		;RESTORE DYNAMIC ADDRESS
		AOBJN Q3,TTYOLP	;HAVE WE DONE THIS 1000 TIMES?
		CALL ULKTTY	;YES, TAKE A BREAK
		JRST TTYBLO]	;AND CONTINUE
	POP P,B			;RESTORE DYNAMIC ADDRESS
TTYOLX:	AOS 0(P)		;GIVE SKIP RETURN
	CALLRET ULKTTY		;ALLOW DEALLOCATION

;TTYATW - WAIT UNTIL JOB HAS A CONTROLLING TERMINAL

;	CALL TTYATW

;RETURNS +1: ALWAYS
;		DEV/ (CONTROLLING TERMINAL,,UNCHANGED)
;		T2/ CONTROLLING TERMINAL

;PRESERVES T1

TTYATW:	PUSH P,A
	MOVE A,JOBNO
	MOVEI A,JOBPT(A)	;CONSTRUCT PTR TO JOBPT
	CALL DISGE		;DISMISS UNTIL IT'S POSITIVE
	HLL DEV,0(A)		;GET NEW CONTROLLING TTY NUMBER
	POP P,A
	HLRZ 2,DEV		;GET LINE NUMBER
	CAIN 2,-1		;BE SURE WE HAVE ONE
	JRST TTYATW		;STILL DETACHED
	RET

;GDSTD - GET DEVICE DEPNEDENT STATUS

TTGDST::HLRE T2,DEV		;GET TTY NUMBER
	JUMPL T2,RFALSE		;IF DETACHED, GIVE UP NOW
	CALL LCKTTY		;LOCK THE TTY
	 JRST [	CALL ULKTTY	;ERROR
		CALLRET RFALSE]	;AND DONE FOR NOW
	CALL TTGSTS		;GET STATUS IN T1
	CALL ULKTTY		;UNLOCK THE TTY
	RET			;AND DONE
;CLOSD FUNCTION FOR TTY - CLOSE FILE

;ACCEPTS:
;	DEV/ (UNIT NUMBER,,DISPATCH ADDRESS)

;	CALL TTYCLZ

;RETURNS +1: FAILURE
;	 +2: SUCCESS

TTYCLZ::STKVAR <TTYCLX,TTFLX>
TTYCL3:	MOVEM T1,TTFLX		;Save flags for later
	CALL CKJFTT		;SEE IF JFN FOR 'TTY:'
	 RETSKP			;YES. THIS ALWAYS SUCCEEDS
	CALL LCKDVL		;LOCK THE DEVICE LOCK, GO NOINT
	CALL FNDUNT		;GET POINTER TO DEVICE TABLES
	MOVEM T1,TTYCLX		;SAVE IT
	HRRZ T2,T1		;T2/ POINTER TO DEVICE TABLES
	CALL DEVAV		;SEE IF DEVICE AVAILABLE TO THIS JOB
	 JRST TTYCL4		;NO. RETURN FAILURE
	HLRZ T2,DEV		;YES. T2/ LINE NUMBER
	CALL GTCJOB		;GET CONTROLLING JOB FOR THIS TERMINAL
	 JRST TTYCL4		;NONE. SHOULDN'T HAPPEN
	CAME T3,JOBNO		;IS IT THIS JOB?
	JRST TTYCL4		;NO. SHOULDN'T HAPPEN
	HLRZ T1,DEV		;Create a terminal designator
	ADDI T1,.TTDES
	MOVE T2,TTFLX		;Get the flags
	TXNN T2,CZ%ABT		;See if this is an abort close
	IFSKP.
	  TQNE <WRTF>		;Yes - opened for write?
	  CFOBF			;Yes - clear output
	  TQNE <READF>	;Opened for read?
	  CFIBF			;Yes - clear input
	ELSE.
	  TQNN <WRTF>		;If not opened for output
	  IFSKP.
	    SOBE		;See if output buffer is empty
	    IFNSK.
	      UNLOKK DEVLKK	;Output to wait for, release our lock
	      OKINT		;and undo DEVLKK NOINT
	      HLL T1,DEV	;Load TTOBET argument
	      HRRI T1,TTOBET	;and scheduler test to do DOBE stuff
	      TQO <BLKF>	;Inform caller we should block
	      RET		;and return to caller
	    ENDIF.
	  ENDIF.
	ENDIF.

	CALL TTYSCN		;[7435] (JFN/) Check for other open JFNs
	 JRST TTYCL1		;[7435] Other open JFN exists - no deallocation
	HLRZ T2,DEV		;[7435] Load the internal line number
	CAMN T2,CTRLTT		;[7.1149][7435] If not the controlling tty...
	IFSKP.			;[7.1149]
	  LOAD T1,TTSTY,(T2)	;[7.1149]Get tty type
	  CAIN T1,TT.FE		;[7.1149]If not RSX20F line, don't hangup
	  CALL TTHNGU		;[7.1149][7435] (T2/) Hang up that terminal
	ENDIF.			;[7.1149]
	MOVE T1,TTYCLX		;GET INDEX TO DEVICE TABLES
	JN DV%ASN,DEVCHR(T1),TTYCL1 ;IF ALSO ASSIGNED, DON'T DEALLOCATE DATA
	CALL TTYDEA		;[7435] (T2/) Deallocate dynamic data
	 JRST TTYCL2		;FAILED. GO WAIT IF NECESSARY
	MOVE T1,TTYCLX		;POINT TO DEVICE TABLES
	HRROS DEVUNT(T1)	;INDICATE NO JOB OWNS THE DEVICE
TTYCL1:	MOVE T1,TTYCLX		;[7.1241] Set up pointer into device tables
	SETZRO DV%OPN,DEVCHR(T1) ;INDICATE NO LONGER OPEN
	UNLOKK DEVLKK		;UNLOCK THE DEVICE LOCK
	OKINT			;LCKDVL DID A NOINT
	RETSKP			;SUCCESS

;TTYDEA FAILED. IF BIT 0 IS SET, AC 1 HAS ADDRESS OF SCHEDULER TEST

TTYCL2:	UNLOKK DEVLKK		;UNLOCK THE DEVICE LOCK
	OKINT			;LCKDVL DID A NOINT
	TXZN T1,1B0		;IS THIS A TEST ROUTINE?
	RETBAD			;NO. RETURN FAILURE
	HRL T1,T2		;T1/ (LINE NUMBER,,ROUTINE ADDRESS)
	TQO BLKF		;INDICATE BLOCK
	RETBAD

;DEVICE IS NOT AVAILABLE TO THIS JOB

TTYCL4:	UNLOKK DEVLKK		;UNLOCK THE DEVICE LOCK
	OKINT			;LCKDVL DID A NOINT
	RETBAD (DEVX2)

	SUBTTL	TTYSCN - Search All Open JFNs for Certain TTY

; This routine will search all JFN blocks looking for all open JFNs which 
;refer to a particular TTY.
;
;	Usage:    CALL TTYSCN
;
;	Accepts:  JFN/  Adjusted JFN for TTY to be closed
;
;	Returns:  +1  There is another open JFN for this TTY
;		  +2  There are no other open JFNs for this TTY
;
; This is used by TTYCLZ so that if there are multiple JFNs on TTYxxx, 
;then only the last close will deallocate the dynamic data block.  
;Only when there are no other open JFNs for a TTY is 
;it valid to deallocate the dynamic data.  Otherwise, a security problem 
;results where it is possible to acquire a permenant JFN on a TTY and spy 
;on it's controlling job.

TTYSCN:	SAVEAC <T1,T2,T3,T4,U>	;Get some working ACs
	MOVE T1,MAXJFN		;Start looking at highest JFN
	IMULI T1,MLJFN		;Adjust JFN value to offset into JFN block
	DO.
	  SUBI T1,MLJFN		;Move to next JFN
	  JUMPE T1,ENDLP.	;Stop if at JFN0
	  CAMN T1,JFN		;Is this the same as the one being searched?
	  LOOP.			; Yes, continue with next one
	  LOAD T2,FLDSB,(T1)	;Get pointer to device name
	  JUMPE T2,TOP.		;If none exists, continue with next one
	  HRRZ T2,(T2)		;Get length of device name string for this JFN
	  LOAD T4,FLDSB,(JFN)	;Get pointer to device for JFN to be matched
	  HRRZ T3,(T4)		;Get length of name for JFN to match
	  CAME T2,T3		;Are they the same length?
	  LOOP.			; No, continue with next JFN
	  MOVE T2,FILSTS(T1)	;Get status of this JFN
	  TLNN T2,(OPNF)	;Is the JFN open?
	  LOOP.			; No, continue with next JFN
	  LOAD T2,FLDSB,(T1)	;Get back pointer to name for this JFN
	  ADD T2,T3		;Offset into device name block for this JFN
	  ADD T4,T3		;Offset into device name block for JFN to match
	  DO.
	    SOSG T3		;Decrement count of words to look at
	    RET			;No more so match was found - return 
	    SOS T2		;Move to next word of this JFN name
	    SOS T4		;Move to next word of JFN to match name
	    MOVE U,(T2)		;Get name word for this JFN
	    CAME U,(T4)		;Check it against the same word of JFN to match
	    EXIT.		;They are not the same, exit and try next JFN
	    LOOP.		;They are the same, test next word
	  ENDDO.
	  LOOP.			;Try next JFN
	ENDDO.
	RETSKP			;No match was found, return indicating this
	SUBTTL	MTOPR Functions for TTYs

;MTPD FUNCTION FOR TTY - MTOPR

TTMTOP:	TQNN <OPNF>		;CHECK TO SEE IF OPENED
	RETBAD (CLSX1)		;NO ERROR
	HLRE 2,DEV		;GET LINE NUMBER
	JUMPL T2,RSKP		;RETURN IF NOT CONTROLLING TERMINAL
	XCTU [HRRZ 3,2]		;GET MTOPR OP CODE
	CAIL T3,.MOPIH		;TOO SMALL?
	CAILE T3,.MOUHU		;[7435] or too big?
	RETBAD (MTOX1)		;ERROR
	CALLRET @TTMTFC-.MOPIH(T3) ;DO IT

;MTOPR DISPATCH TABLE

TTMTFC:	DTBDSP (TTMHNG)		;25 - .MOPIH - TEST INPUT HUNGRY 
	DTBDSP (TTMSSP)		;26 - .MOSPD - SET LINE SPEED
	DTBDSP (TTMRSP)		;27 - .MORSP - READ LINE SPEED
	DTBDSP (TTMRWD)		;30 - .MORLW - READ LINE WIDTH
	DTBDSP (TTMSWD)		;31 - .MOSLW - SET LINE WIDTH
	DTBDSP (TTMRLN)		;32 - .MORLL - READ LINE LENGTH
	DTBDSP (TTMSLN)		;33 - .MOSLL - SET LINE LENGTH
	DTBDSP (TTMSNT)		;34 - .MOSNT - SET TTY MSG STATUS
	DTBDSP (TTMRNT)		;35 - .MORNT - READ TTY MSG STATUS
	DTBDSP (TTMSIG)		;36 - .MOSIG - SET "IGNORE INPUT" BIT
	DTBDSP (TTMRBM)		;37 - .MORBM - READ THE WAKE UP MASK
	DTBDSP (TTMSBM)		;40 - .MOSBM - SET THE WAKE UP MASK
	DTBDSP (TTMRFW)		;41 - .MORFW - READ THE FIELD WIDTH
	DTBDSP (TTMSFW)		;42 - .MOSFW - SET THE FIELD WIDTH
	DTBDSP (TTXXX)		;43 - .MOXOF - SET/CLEAR XON/XOFF PROCESSING
	DTBDSP (TTXXXR)		;44 - .MORXO - READ BIT SETTING
	DTBDSP (TTMSLC)		;45 - .MOSLC - SET LINE COUNTER
	DTBDSP (TTMRLC)		;46 - .MORLC - READ LINE COUNTER
	DTBDSP (TTMSLM)		;47 - .MOSLM - SET LINE MAXIMUM
	DTBDSP (TTMRLM)		;50 - .MORLM - READ LINE MAXIMUM
	DTBDSP (TTLIPS)		;51 - .MOTPS - SET PSI FOR SPECIFIC LINE
	DTBDSP (TTPCS)		;52 - .MOPCS - SET PAGE PAUSE CHARACTER
	DTBDSP (TTPCR)		;53 - .MOPCR - READ PAGE PAUSE CHARACTER
	DTBDSP (TTMRTF)		;54 - .MORTF - READ TERMINAL FLAGS
	DTBDSP (TTMNTF)		;55 - .MOSTF - SET/CLEAR SOME TERMINAL FLAGS
	DTBDSP (TTEST)		;56 - .MOTCE - SET TWO CHARACTER ESCAPE SEQUENCE
	DTBDSP (TTREA)		;57 - .MORTC - READ TWO CHARACTER ESCAPE SEQUENCE
IFE FTNSPSRV,<
	DTBDSP (TTCTM)		;60 - .MOCTM - IS THIS A CTERM TTY ?
	DTBDSP (TTRTX)		;61 - .MOTXT - REMOTE TEXTI
>; END FTNSPSRV
IFN FTNSPSRV,<			;[7435]
	DTBBAD	(DESX9)		;[7435] 60 - .MOCTM - is this a CTERM TTY?
	DTBBAD	(DESX9)		;[7435] 61 - .MOTXT - Remote TEXTI
>;[7435] END OF IFN FTNSPSRV
	DTBDSP	(TTMHUP)	;[7435] 62 - .MOHUP - Hangup remote line
	DTBDSP	(TTMUHU)	;[7435] 63 - .MOUHU - Unhangup (raise DTR) 

;[7435] Function .MOHUP of MTOPR - Hangup line (drop DTR)

TTMHUP:	CALL TTMLOK		;[7435] (T2/) Check access to this terminal
	 RETBAD (MTOX7)		;[7435] Can't do it
	CALL TTHNGU		;[7435] (T2/) Call routine to hangup the line
	RETSKP			;[7435] Success return

;[7435] Function .MOUHU of MTOPR - Unhangup line (raise DTR)

TTMUHU:	CALL TTMLOK		;[7435] (T2/) Check access to this terminal
	 RETBAD (MTOX7)		;[7435] Can't do it
	CALL TTUHUP		;[7435] (T2/) Call routine to unhangup the line
	RETSKP			;[7435] Success return

;FUNCTION .MOPIH OF MTOPR - SEE IF LINE IS HUNGRY

;RETURNS +2: ALWAYS
;		T1/ 0 IF NOT HUNGY
;		   -1 IF HUNGRY

TTMHNG:	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA, PREVENT ALLOCATION
	 JRST [	CALL ULKTTY	;NOT ACTIVE. ALLOW DEALLOCATION
		SETZ T1,	;ASSUME NOT HUNGRY
		SKIPN T2	;UNLESS LINE IS NOT ACTIVE AT ALL
		SETO T1,	;THEN MAKE IT HUNGRY
		JRST TTMHN1]
	CALL TTSTIH		;SEE IF HUNGRY
	CALL ULKTTY		;ALLOW DEALLOCATION
TTMHN1:	UMOVEM T1,2		;STORE RESULT
	RETSKP			;AND DONE

;FUNCTION .MOSPD OF MTOPR - SET TERMINAL SPEED

;ACCEPTS:
;	T2/ LINE NUMBER
;	T3/ (INPUT SPEED,,OUTPUT SPEED)

TTMSSP::CALL TTMLOK		;CHECK FOR ACCESS TO THIS TTY
	 RETBAD (MTOX7)		;CAN'T DO IT
	CALL TTSSPD		;GO SET SPEED
	 RETBAD()		;FAILED (ACJ rejection)
	RETSKP			;AND DONE

;FUNCTION .MORSP OF MTOPR - GET LINE SPEED

TTMRSP::CALL TTRSPD		;GO READ SPEED
	RETSKP			;DONE


;TTSIG - SET "IGNORE INPUT" BIT FOR A LINE
;MUST BE WHEEL OR OPERATOR TO DO THIS

TTMSIG::MOVX T1,SC%OPR!SC%WHL	;MUST BE WHEEL OR OPERATOR TO DO THIS
	TDNN T1,CAPENB		;IS IT?
	RETBAD (MTOX7)		;CAN'T DO IT
	UMOVE T1,T3		;GET NEW SETTING
	CALL TTSSIG		;GO SET BIT IN LINE'S STATIC DATABASE
	RETSKP			;DONE, RETURN SUCCESS

;LOCAL ROUTINE TO VERIFY ACCESS TO TTY
;CHECKS IF TTY IS "ACTIVE" OR IF CALLER IS WHEEL OR OPERATOR.
;IF TTY IS ACTIVE, THEN THIS PROCESS MUST HAVE IT ASSIGNED OR
;OPENED.

TTMLOK:	SAVET			;SAVE ALL REGS
	MOVX T1,SC%WHL!SC%OPR	;SEE IF WHEEL OR OPERATOR
	TDNE T1,CAPENB		;IS IT?
	RETSKP			;YES. ALLOW ACCESS THEN
	CALL LCKTTY		;NO. SEE IF ACTIVE
	 CALLRET ULKTTY		;NO. UNLOCK IT AND GIVE ERROR RETURN
	CALL ULKTTY		;YES. UNLOCK IT
	RETSKP			;AND ALLOW ACCESS
;ROUTINE TO LOCK DYNAMIC DATA
;SKIPS IFF SUCCESS.

TLOCK::	CALL LCKTTY		;GET ADDRESS OF DYNAMIC DATA, PREVENT DEALLOCATION
	 JRST [	CALL ULKTTY	;NOT ACTIVE. ALLOW DEALLOCATION
		RETBAD (TTYX01)] ;INDICATE NOT ACTIVE
	RETSKP

;FUNCTION .MOSLW OF MTOPR - SET LINE WIDTH

TTMSWD::CALL TLOCK
	 RETBAD
	UMOVE T1,3		;GET WIDTH TO SET
	CALL TTSWID		;GO SET IT
	JRST [	CALL ULKTTY	;ALLOW DEALLOCATION
		RETBAD (MTOX19)] ;RETURN INVALID WIDTH
	CALL ULKTTY		;ALLOW DEALLOCATION
	RETSKP			;AND DONE

;FUNCTION .MORLW - READ LINE WIDTH

TTMRWD::CALL TLOCK
	 RETBAD
	CALL TTRWID		;GO READ WIDTH
	JRST TTMTST		;GO RETURN TO USER

;FUNCTION .MOSLL OF MTOPR - SET LINE LENGTH

TTMSLN::UMOVE T1,3		;GET LENGTH
	CALL TLOCK
	 RETBAD
	CALL TTSLEN		;GO SET IT
	 JRST [	CALL ULKTTY	;ALLOW DEALLOCATION
		RETBAD (MTOX20)] ;RETURN INVALID LENGTH
	CALL ULKTTY		;SUCCESS. ALLOW DEALLOCATION
	RETSKP			;AND DONE

;FUNCTION .MORLL OF MTOPR - READ LINE LENGTH

TTMRLN::CALL TLOCK
	 RETBAD
	CALL TTRLEN		;GO GET IT
TTMTST:	UMOVEM T1,3		;STORE RESULT
	CALL ULKTTY		;ALLOW DEALLOCATION
	RETSKP			;AND DONE

;SET LINE COUNTER - .MOSLC

TTMSLC:	CALL TLOCK		;LOCK THE DATA
	 RETBAD
	UMOVE A,C		;GET NEW VALUE
	CALL TTSLC		;SET IT
	CALLRET TTMTST		;DONE

;READ LINE COUNTER - .MORLC

TTMRLC::CALL TLOCK		;LOCK TTY DATA
	 RETBAD
	CALL TTRLC		;GET THE COUNTER
	UMOVEM A,C		;STORE IN USER'S AC
	CALLRET TTMTST

;SET LINE COUNTER MAXIMUM - .MOSLM

TTMSLM:	CALL TLOCK
	 RETBAD
	UMOVE A,C		;GET VALUE BEING SET
	CALL TTSLM		;SET IT
	CALLRET TTMTST

;READ MAXIMUM - .MORLM

TTMRLM::CALL TLOCK
	 RETBAD
	CALL TTRLM		;READ MAXIMUM
	UMOVEM A,C		;GIVE TO USER
	CALLRET TTMTST

;FUNCTION .MOSNT OF MTOPR

TTMSNT::CALL TTMLOK		;VERIFY ACCESS TO TTY
	 RETBAD (MTOX7)		;CAN'T DO IT
	UMOVE C,C		;GET USER'S ARG
	CALL TTSNTS		;GO SET TTY NO MSG
	RETSKP			;DONE

;FUNCTION .MORNT OF MTOPR

TTMRNT::CALL TTRNTS		;GO READ TTY MSG STATUS
	UMOVEM C,C		;AND GIVE TO USER
	RETSKP			;DONE


;FUNCTION .MOSTF OF MTOPR

TTMNTF:	CALL TTMLOK		;VERIFY ACCESS TO TTY
	 RETBAD (MTOX7)		;CAN'T DO IT
	UMOVE C,C		;GET USER'S ARG
	CALL TTSNTF		;GO SET CERTAIN TERMINAL FLAGS
	RETSKP			;DONE

;FUNCTION .MORTF OF MTOPR

TTMRTF: CALL TTRNTF		;GO READ TTY MSG STATUS
	UMOVEM C,C		;AND GIVE TO USER
	RETSKP			;DONE


;MTOPR% function .MOTCE - set up the two character escape sequence
;CALL TTEST with:
;	T2/ line number
;	User AC3/ two character escape sequence, right justified
;Returns +1 on error with error in T1
;Returns +2 on success
TTEST:	CALL TTMLOK		;Check access rights
	 RETBAD (MTOX7)		;Failed.
	UMOVE T1,3		;Get user argument
	SETZ T3,		;Action routine index (PSI)
	CALL TTESET		;(T1,T2,T3) Go do it.
	 RETBAD (MTOX21)	;Failed
	RETSKP


;MTOPR% function .MORTC - read the two character escape sequence
;CALL TTREA with
;	T2/ line number
;Returns +2 always with:
;	User AC3/ two ASCII character escape sequence, right justified
TTREA:	CALL TTERED		;(T2/T1) Go do it.
	 RETBAD   		;Failure.
	UMOVEM T1,3		;Give to user.
	RETSKP

IFE FTNSPSRV,<
;MTOPR% function .MOCTM - is this a CTERM TTY ?
;CALL TTCTM with
;	T2/ line number
;returns +2 always with
;	User AC3/ 1 if this is a CTERM TTY, 2 if VMS CTERM, 0 otherwise.
TTCTM:	SETZ T3,		;Initialize result
	CALL TLOCK 		;(T2/T2) Lock TDB.
	IFSKP.
	  LOAD T1,TLTYP,(T2)	;Ok. Is it a 
	  CAIN T1,TT.CTH	; CTERM TTY ?
	    CALL CTHTID		;(T2/T3) Yes, found out which kind
       	  CALL ULKTTY		;(T2) Unlock TTY.
	ENDIF.
       	UMOVEM T3,3      	;Give answer
	RETSKP			;Done.

;MTOPR% function .MOTXT - remote TEXTI%
;CALL TTRTX with
;	T2/ line number
;	User AC3/  flags,,length
;returns +1 on failure with error in T1
;returns +2 on succes
TTRTX:	SETZ T3,		;Initialize result
	CALL TTMLOK 		;(T2/T2) Verify access rights
	 RETBAD (MTOX7)		;Failed.
	CALL TLOCK		;(T2/T2) Get TDB
	 RETBAD (TTYX01)	;Failed.
	LOAD T1,TLTYP,(T2)	;Get TTY type
	CAIE T1,TT.CTH		;CTERM ?
	RETBAD (TTYX01,<CALL ULKTTY>) ;No.
	CALL CTHTXT		;(T2/T2) Yes. Do work.
	 RETBAD (,<CALLRET ULKTTY>) ;Failed.
       	CALL ULKTTY		;(T2) Unlock TTY.
	RETSKP			;Done.
>; END OF FTNSPSRV

;SET/CLEAR XON/XOFF PROCESSING

TTXXX:	CALL TLOCK
	 RETBAD
	UMOVE T3,3		;GET NEW SETTING
	CALL TTXSET		;SET IT
	CALL ULKTTY		;UNLOCK TTY
	RETSKP			;AND DONE

;READ SETTING OF XOFF BIT

TTXXXR:	CALL TLOCK
	 RETBAD
	CALL TTRXOB		;READ XOFF BIT
	UMOVEM T1,3		;RETURN VALUE
	CALL ULKTTY
	RETSKP			;AND DONE

;SET PAGE PAUSE CHARACTER

TTPCS::	CALL TLOCK
	 RETBAD
	UMOVE T1,3
	CALL TTPPCS
	CALL ULKTTY		;UNLOCK TTY
	RETSKP			;AND DONE

;READ PAGE PAUSE CHARACTER

TTPCR::	CALL TLOCK
	 RETBAD
	CALL TTPPCR
	UMOVEM T1,3
	CALL ULKTTY		;UNLOCK TTY
	RETSKP			;AND DONE

; SET PSI FOR NON-CONTROLLING TERMINAL I/O

TTLIPS:	CALLRET TTYNPS		;DO NON CONTROLLING TERMINAL PSI ENABLE

;ROUTINE CALLED BY NILOPN,PTYOPN ,AND TTYOPN TO SET WRTF
;IF APPEND REQUESTED

CHKAPD:	TQZE <RNDF>		;WANT APPEND?
	TQO <WRTF>		;YES. BUT ALWAYS FAKE APPEND
	RET			;AND DONE

 SUBTTL TERMINAL WAKE-UP AND FIELD WIDTH SUPPORT

;TTMRBM - READ BREAK MASK

TTMRBM::CALL TTMVER		;GO VERIFY BLOCK AND LINE
	RET			;ERROR - RETURN
	STKVAR <<TTMSK1,4>>
	XMOVEI T1,TTMSK1	;POINT TO WHERE WE WANT MASK TO GO
	CALL TTRBM		;GET MASK INTO TTMSK
	UMOVE T1,T3		;GET USER AREA POINTER
	DMOVE T3,TTMSK1		;GET FIRST TWO WORDS
	XCTU [	DMOVEM T3,1(T1)]	;PUT IN USER AREA
	DMOVE T3,2+TTMSK1	;GET LAST TWO WORDS
	XCTU [	DMOVEM T3,3(T1)]	;PUT IN USER AREA
	CALL ULKTTY		;UNLOCK THE DYNAMIC DATA
	RETSKP
;  TTMSBM - SET THE BREAK MASK

TTMSBM:	CALL TTMVER		;GO VERIFY BLOCK AND LINE
	RET			;ERROR - RETURN
	STKVAR <<TTMSK2,4>>
	XCTU [	DMOVE T3,1(T1)]	;GET FROM USER AREA
	DMOVEM T3,TTMSK2	;SET FIRST TWO WORDS
	XCTU [	DMOVE T3,3(T1)]	;GET FROM USER AREA
	DMOVEM T3,2+TTMSK2	;SET LAST TWO WORDS
	XMOVEI T1,TTMSK2	;POINT TO WHERE IS
	CALL TTSBM		;SET MASK INTO TTMSK
	CALL ULKTTY		;UNLOCK THE DYNAMIC DATA
	RETSKP


; TTMVER - VERIFY LINE NUMBER IS CORRECT AND BLOCK IS DEFINED PROPERLY

;ACCEPTS:	T2/LINE NUMBER

;RETURNS:	+1,ERROR
;		+2,WITH	T1/USER CONTEXT ADDRESS OF 4 WORD BLOCK
;			T2/DYNAMIC DATA ADDRESS
;			T3/CLOBBERED

TTMVER::CALL TLOCK
	 RETBAD
	UMOVE T1,T3		;GET ADDRESS OF USER BLOCK
	UMOVE T3,(T1)		;GET ARGUMENT LENGTH
	CAIN T3,T4		;MUST BE LENGTH OF FOUR
	RETSKP			;YES, RIGHT LENGTH - RETURN
	CALL ULKTTY		;UNLOCK THE DYNAMIC DATA
	CAIG T3,T4		;IS IT LESS THAN FOUR
	RETBAD (MTOX13)		;YES - THEN TELL USER
	RETBAD (MTOX8)		;NO - MUST BE TO LONG

;TTMRFW - READ THE FIELD WIDTH

TTMRFW::CALL TLOCK
	 RETBAD
	CALL TTRFW		;GO GET THE FIELD WIDTH
	UMOVEM T1,T3		;GIVE TO USER
	CALL ULKTTY		;UNLOCK DYNAMIC DATA
	RETSKP

;TTMSFW - SET THE FIELD WIDTH

TTMSFW::CALL TLOCK
	 RETBAD
	UMOVE T1,T3		;GET FIELD WIDTH FROM USER
	CALL TTSFW		;GO SET THE FIELD WIDTH
	CALL ULKTTY		;UNLOCK DYNAMIC DATA
	RETSKP

 SUBTTL  TTYASN
;TTYASN - ASSIGN TERMINAL AS CONTROLLING TERMINAL FOR A JOB

;ACCEPTS:
;	T1/ JOB NUMBER
;	T2/ INTERNAL LINE NUMBER

;	CALL TTYASN

;RETURNS +1: FAILURE
;	 +2: SUCCESS

TTYASN::
	SE1CAL
	STKVAR <TTYALN,TTYASX>
	MOVEM T2,TTYALN		;SAVE LINE NUMBER
	CALL LCKDVL		;LOCK THE DEVICE TABLES
	MOVEI T1,.TTDES(T2)	;T1/ DEVICE DESIGNATOR
	CALL CHKDES		;GET INDEX INTO DEVICE TABLES
	 RETBAD(,<UNLOKK DEVLKK ;INVALID DESIGNATOR. SHOULDN'T HAPPEN
		OKINT>)
	MOVEM B,TTYASX		;SAVE INDEX INTO DEVICE TABLES
	HLRZ T2,DEVUNT(B)	;GET OWNING JOB
	CAME T2,JOBNO		;US?
	CAIN T2,-1		;OR NO ONE
	SKIPA B,TTYALN		;YES. GO ON
	RETBAD(DESX2,<UNLOKK DEVLKK
		OKINT>)
	CALL TTYASC		;GO ASSIGN TERMINAL IF POSSIBLE
	 RETBAD(,<UNLOKK DEVLKK ;FAILED
		OKINT>)
	HRRZ A,TTYASX		;GET INDEX INTO DEVICE TABLES
	MOVE B,JOBNO		;GET THIS JOB NUMBER
	HLRE C,DEVUNT(A)	;GET PREVIOUS OWNER
	HRLM B,DEVUNT(A)	;MARK THIS IT OWNS THE TERMINAL
	MOVX B,DV%ASN		;INDICATE ASSIGNED
	IORM B,DEVCHR(A)
	IFL. C			;IF PREVIOUSLY UNOWNED
	 MOVE B,TTYALN		;GET LINE NUMBER
	 CALL TTPINI		;INIT DEVICE
	ENDIF.			;AND GO ON
	UNLOKK DEVLKK
	OKINT
	RETSKP

;TTYDAS - DEASSIGN TERMINAL

;ACCEPTS:
;	T2/ INTERNAL LINE NUMBER

;	CALL TTYDAS

;RETURNS +1: FAILED,
;		T1/ ERROR CODE
;			OR
;		    1B0 + ADDRESS OF SCHEDULER TEST ROUTINE FOR MDISMS
;	 +2: SUCCEEDED

;CALLER MUST HAVE LOCKED THE DEVICE LOCK

TTYDAS::STKVAR <TTYDLN,TTYDAX>
	MOVEM T2,TTYDLN		;SAVE LINE NUMBER
TTYDA3:	MOVEI T1,.TTDES(T2)	;T1/ DEVICE DESIGNATOR FOR TERMINAL
	CALL CHKDES		;GET INDEX TO DEVICE TABLES
	 RETBAD			;INVALID DESIGNATOR. SHOULDN'T HAPPEN
	MOVEM T2,TTYDAX		;SAVE INDEX TO DEVICE TABLES
	JN DV%OPN,DEVCHR(T2),TTYDA1 ;DON'T DEALLOCATE IF ALSO OPEN
	HLRZ T2,DEV		;T2/ LINE NUMBER
	CALL TTYDEA		;DEALLOCATE DYNAMIC DATA
	 RETBAD			;FAILED. GO WAIT IF NECESSARY
TTYDA5:	MOVE T2,TTYDAX		;GET INDEX TO DEVICE TABLES
	HRROS DEVUNT(T2)	;INDICATE NO JOB OWNS THIS DEVICE
TTYDA1:	SETZRO DV%ASN,DEVCHR(T2) ;INDICATE NO LONGER ASSIGNED
	RETSKP

;FAILED TO DEASSIGN DYNAMIC DATA. RETURN FAILURE TO CALLER WITHOUT
;CHANGING DEVICE TABLES

	TNXEND
	END

