; UPD ID= 8599, RIP:<7.MONITOR>PROLOG.MAC.8,  11-Feb-88 16:57:54 by GSCOTT
;TCO 7.1218 - Update copyright date.
; UPD ID= 293, RIP:<7.MONITOR>PROLOG.MAC.7,  12-Nov-87 16:55:10 by GSCOTT
;TCO 7.1133 - DOBL0K no longer used.
; UPD ID= 255, RIP:<7.MONITOR>PROLOG.MAC.6,   4-Nov-87 16:44:28 by MCCOLLUM
;TCO 7.1112 - Add STBS MSKSTR and fix up descriptions of STPS.
; UPD ID= 208, RIP:<7.MONITOR>PROLOG.MAC.5,  23-Oct-87 15:37:09 by GSCOTT
;TCO 7.1081 - Add config word for BUG macro, remove repeat 0ed BUG macro,
;             and add DOBLOK/DOBL0K.
; UPD ID= 135, RIP:<7.MONITOR>PROLOG.MAC.4,  23-Sep-87 15:47:05 by MCCOLLUM
;TCO 7.1063 - Adjust STRSTS and STRJB sizes in word SDBSTS. Add MSKSTR
;             STOFS for the MS%OFS bit. Add MSKSTR STRTMR for SDBTMR word.
; UPD ID= 52, RIP:<7.MONITOR>PROLOG.MAC.3,  27-Jul-87 16:14:39 by MCCOLLUM
;TCO 7.1024 - Add the XENT macro
; *** Edit 7384 to PROLOG.MAC by MCCOLLUM on 15-Oct-86, for SPR #21288
; Add ASGF2 to FILST1. This bit should ALWAYS shadow the state of ASGF in
; FILSTS 
; *** Edit 7357 to PROLOG.MAC by RASPUZZI on 22-Aug-86
; Remove routine GAPRID since the processor serial number is already in APRSER
; and make all CALLs to GAPRID refer to that resident location. 
; *** Edit 7247 to PROLOG.MAC by LOMARTIRE on 19-Feb-86
; Implement OFN caching 
;Edit 7247 - Add OFNCSH, OFNMGB, and OFNLAC for OFN caching
; Edit 7172 to PROLOG.MAC by MCCOLLUM on 25-Oct-85, for SPR #20513
; Set FB%NDL for non-directory files on <ROOT-DIRECTORY> 
; UPD ID= 2008, SNARK:<6.1.MONITOR>PROLOG.MAC.199,  24-May-85 13:41:36 by MCCOLLUM
;TCO 6.1.1406 - Update Copyrights
; UPD ID= 1964, SNARK:<6.1.MONITOR>PROLOG.MAC.198,  13-May-85 10:10:07 by GRANT
;TCO 6.1.1377 - Remove CILD
; UPD ID= 1752, SNARK:<6.1.MONITOR>PROLOG.MAC.197,  14-Apr-85 15:44:35 by LEACHE
;TCO 6.1.1321 Add BOOT parameter flag definitions
; UPD ID= 1674, SNARK:<6.1.MONITOR>PROLOG.MAC.196,  25-Mar-85 08:25:16 by GRANT
;TCO 6.1.1284 - Add bits for CIFRKF
; UPD ID= 1646, SNARK:<6.1.MONITOR>PROLOG.MAC.195,  18-Mar-85 12:09:49 by PALMIERI
;tco 6.1.1231 - Add MCBDBG for DTESRV
; UPD ID= 1611, SNARK:<6.1.MONITOR>PROLOG.MAC.194,  11-Mar-85 09:49:03 by GRANT
;TCO 6.1.1245 - add offsets for Cluster Cease block
; UPD ID= 1441, SNARK:<6.1.MONITOR>PROLOG.MAC.193,  31-Jan-85 16:15:37 by MOSER
;TCO 6.1.1166 - *PERFORMANCE* - OFN MANAGEMENT
; UPD ID= 1367, SNARK:<6.1.MONITOR>PROLOG.MAC.192,  21-Jan-85 10:04:35 by MAYO
;TCO 6.1.1147 - define K0WRN for ARCF%
; UPD ID= 1217, SNARK:<6.1.MONITOR>PROLOG.MAC.191,  18-Dec-84 12:43:19 by LEACHE
;Fix comments
; UPD ID= 1103, SNARK:<6.1.MONITOR>PROLOG.MAC.190,  19-Nov-84 16:07:02 by LEACHE
;Add STKHWD
; UPD ID= 1064, SNARK:<6.1.MONITOR>PROLOG.MAC.189,  13-Nov-84 09:32:41 by LEACHE
;Add JSSTDL
; UPD ID= 1012, SNARK:<6.1.MONITOR>PROLOG.MAC.188,   9-Nov-84 11:42:25 by PAETZOLD
;TCO 6.1.1037 - Add CALLX macro
; UPD ID= 1006, SNARK:<6.1.MONITOR>PROLOG.MAC.187,   7-Nov-84 21:10:32 by PAETZOLD
;TCO 6.1.1036 - A global functionality to XRENT and XNENT
; UPD ID= 967, SNARK:<6.1.MONITOR>PROLOG.MAC.186,   6-Nov-84 10:47:51 by LEACHE
;Add JSSTMR
; UPD ID= 965, SNARK:<6.1.MONITOR>PROLOG.MAC.185,   6-Nov-84 10:38:36 by GLINDELL
;Suppress DDT typeout of junk symbols generated by TOpsectCD macros
; UPD ID= 959, SNARK:<6.1.MONITOR>PROLOG.MAC.184,   5-Nov-84 19:40:46 by PRATT
;TCO 6.1.1032 - Make TTYSRV compile independently:
;  Put NLTYPS and TT.xxx defs under FTNSPSRV control
; UPD ID= 954, SNARK:<6.1.MONITOR>PROLOG.MAC.183,   5-Nov-84 16:11:58 by LEACHE
;Add definitions for JSB-stack offsets
; UPD ID= 5001, SNARK:<6.MONITOR>PROLOG.MAC.182,  24-Oct-84 20:11:08 by GLINDELL
;Put in TSTMS0 in the section transfer macros, and EA.ENT's in XCALL..
; UPD ID= 4971, SNARK:<6.MONITOR>PROLOG.MAC.181,  22-Oct-84 11:31:12 by LEACHE
;Add definitions for extended JSB
; UPD ID= 4959, SNARK:<6.MONITOR>PROLOG.MAC.180,  18-Oct-84 15:46:02 by LEACHE
;TCO 6.2254 Add history buffers to swappable freespace pools
; UPD ID= 4928, SNARK:<6.MONITOR>PROLOG.MAC.179,  15-Oct-84 12:47:53 by MOSER
;TCO 6.2245 - ADD FKGL% AND FKOGL IN FKSWP
; UPD ID= 4921, SNARK:<6.MONITOR>PROLOG.MAC.178,  11-Oct-84 10:49:25 by GLINDELL
;TCO 6.1.1021 - change ST%xxx to SY%xxx because of conflict with SERCOD
; UPD ID= 4918, SNARK:<6.MONITOR>PROLOG.MAC.177,  10-Oct-84 17:36:53 by GLINDELL
;TCO 6.1.1021 - 6.1 address space
;	1. BUG. macro changed for 6.1 (IFE FTNSPSRV)
;	2. Many macros added that aid in putting code in XCDSEC
; UPD ID= 4769, SNARK:<6.MONITOR>PROLOG.MAC.175,  29-Aug-84 13:56:07 by TGRADY
;TCO 6.2201 (QAR 706198) - Add local job index to USAGE record DEFSTR's (UQLJI)
; UPD ID= 4703, SNARK:<6.MONITOR>PROLOG.MAC.174,  16-Aug-84 21:39:27 by PAETZOLD
;TCO 6.1733 - No more NVTs.
; UPD ID= 4653, SNARK:<6.MONITOR>PROLOG.MAC.173,   7-Aug-84 16:09:26 by PAETZOLD
;TCO 6.1.1010 - Add IPLDSW.
; UPD ID= 4538, SNARK:<6.MONITOR>PROLOG.MAC.171,  14-Jul-84 18:14:19 by PURRETTA
;Update copyright notice
; UPD ID= 4486, SNARK:<6.MONITOR>PROLOG.MAC.170,  12-Jul-84 16:04:41 by MOSER
;TCO 6.2125 - ADD FKKL% IN FKSWP - FORK BEING KILLED
; UPD ID= 4377, SNARK:<6.MONITOR>PROLOG.MAC.169,  22-Jun-84 16:29:30 by TBOYLE
;Consolidate APR word definitions, APRNM was defined wrong.
; UPD ID= 4334, SNARK:<6.MONITOR>PROLOG.MAC.168,  13-Jun-84 21:41:47 by MOSER
;TCO 6.2037 - FIX LOKK AND UNLOKK
; UPD ID= 4218, SNARK:<6.MONITOR>PROLOG.MAC.167,  14-May-84 18:54:13 by WEISBACH
;~6.0 - Add LAT terminal type TT.LAH
; UPD ID= 4172, SNARK:<6.MONITOR>PROLOG.MAC.166,   2-May-84 13:57:46 by TBOYLE
;More TCO 6.2017 FKSPL should be in FKSWP.. Funny things happen to FKINT.
; UPD ID= 4149, SNARK:<6.MONITOR>PROLOG.MAC.165,  30-Apr-84 12:24:38 by TBOYLE
;More TCO 6.2017 FKSPL bit in FKINT for inferior has spliced.
; UPD ID= 4123, SNARK:<6.MONITOR>PROLOG.MAC.164,  25-Apr-84 09:42:06 by PALMIERI
;Put FTHMMEM and FTRTST under global debug switch
; UPD ID= 3954, SNARK:<6.MONITOR>PROLOG.MAC.162,  21-Mar-84 12:57:09 by LOMARTIRE
;Add SCADBG and SCARNG to debugging switches
; UPD ID= 3902, SNARK:<6.MONITOR>PROLOG.MAC.161,  12-Mar-84 08:02:18 by MCINTEE
;Add FTTRACE,FTMINTRACE,FTDEBUG,FTPARANOID,FTCORBUG,FTLSTCOR to debugging switches
; UPD ID= 3889, SNARK:<6.MONITOR>PROLOG.MAC.160,  11-Mar-84 10:25:10 by GRANT
;Add KLPDBG to debugging switches
; UPD ID= 3870, SNARK:<6.MONITOR>PROLOG.MAC.159,   7-Mar-84 14:30:57 by PURRETTA
;Update copyright
; UPD ID= 3833, SNARK:<6.MONITOR>PROLOG.MAC.158,  29-Feb-84 19:05:16 by LEACHE
;TCO 6.1969 add BUTLEN and BUTFLG
; UPD ID= 3747, SNARK:<6.MONITOR>PROLOG.MAC.157,  24-Feb-84 17:05:08 by LEACHE
;Add BUTLLM, BUTULM and BUTCOD to special BOOT definitions
; UPD ID= 3723, SNARK:<6.MONITOR>PROLOG.MAC.156,  22-Feb-84 11:15:37 by MOSER
;TCO 6.1562 - ADD PSIOP, IO PAGE STATE
; UPD ID= 3705, SNARK:<6.MONITOR>PROLOG.MAC.154,  20-Feb-84 22:50:35 by GROSSMAN
;TCO 6.1975 - PURGE junk symbols generated by BUG.
; UPD ID= 3704, SNARK:<6.MONITOR>PROLOG.MAC.153,  20-Feb-84 10:16:01 by LEACHE
;Add BUTERR to BOOT special locations
; UPD ID= 3646, SNARK:<6.MONITOR>PROLOG.MAC.152,   2-Feb-84 14:34:46 by MURPHY
;Ditto.
; UPD ID= 3644, SNARK:<6.MONITOR>PROLOG.MAC.151,   2-Feb-84 12:52:37 by MURPHY
;Flush PHYPZS.
; UPD ID= 3641, SNARK:<6.MONITOR>PROLOG.MAC.150,   2-Feb-84 11:53:58 by MURPHY
;Put definitions of BOOT special locations here so both BOOT and monitor see them.
; UPD ID= 3636, SNARK:<6.MONITOR>PROLOG.MAC.149,   1-Feb-84 22:10:01 by MURPHY
;TCO 6.1525 - Remove SYVAR psect.
; UPD ID= 3466, SNARK:<6.MONITOR>PROLOG.MAC.148,  16-Jan-84 13:47:01 by HAUDEL
;More TCO 6.1798 - Keep me changes
; UPD ID= 3444, SNARK:<6.MONITOR>PROLOG.MAC.147,  12-Jan-84 14:19:30 by PAETZOLD
;TCO 6.1929 - Change FKJOBN to FKJBN
; UPD ID= 3358, SNARK:<6.MONITOR>PROLOG.MAC.146,  22-Dec-83 09:39:57 by HALL
;Define PHYCHN here
; UPD ID= 3345, SNARK:<6.MONITOR>PROLOG.MAC.145,  19-Dec-83 15:35:43 by LEACHE
;TCO 6.1641 Adjust freespace offsets
; UPD ID= 3229, SNARK:<6.MONITOR>PROLOG.MAC.144,  29-Nov-83 10:57:37 by GLINDELL
;TCO 6.1.1004 - Define FLFCO and FLSES for DECnet-36
; UPD ID= 3219, SNARK:<6.MONITOR>PROLOG.MAC.143,  28-Nov-83 09:47:00 by LEACHE
;Move DECnet swappable freespace out of section zero
; UPD ID= 3176, SNARK:<6.MONITOR>PROLOG.MAC.142,  16-Nov-83 21:28:36 by PAETZOLD
;More TCO 6.1867 - Fix typo
; UPD ID= 3165, SNARK:<6.MONITOR>PROLOG.MAC.141,  16-Nov-83 15:00:02 by PRATT
;TCO 6.1868 - Define ERNOP.  
; UPD ID= 3163, SNARK:<6.MONITOR>PROLOG.MAC.140,  16-Nov-83 14:16:31 by PAETZOLD
;TCO 6.1867 - Add SAVEAC for P1
; UPD ID= 3102, SNARK:<6.MONITOR>PROLOG.MAC.139,   7-Nov-83 09:30:33 by MILLER
;TCO 6.1094. Define PGPTR
; UPD ID= 3041, SNARK:<6.MONITOR>PROLOG.MAC.138,  18-Oct-83 18:16:45 by MILLER
;TCO 6.1094.  Define CF%NUL
; UPD ID= 2915, SNARK:<6.MONITOR>PROLOG.MAC.137,  21-Sep-83 08:26:18 by LEACHE
;Correct spelling of FSPACC 
; UPD ID= 2890, SNARK:<6.MONITOR>PROLOG.MAC.136,  12-Sep-83 15:37:36 by HALL
;TCO 6.1798 - Add support (possibly temporary) for "keep me" bit in hardware
;		 page table
;	Move here from APRSRV the "valid translation" bit of page fail word
;	  and MAP instruction and call it TWVALD
;	Add definition of PTKEEP to access bits for map entries
;	Add definition of TWKEEP for page fail word and returned bit in
;	 MAP instruction
;	Add definition of DATAO PAG bit for clearing kept entries
; UPD ID= 2862, SNARK:<6.MONITOR>PROLOG.MAC.135,  23-Aug-83 15:08:45 by LOMARTIRE
;TCO 6.1692 - Change macro name from LCKINI to INILCK so routine is usable
; UPD ID= 2805, SNARK:<6.MONITOR>PROLOG.MAC.134,   9-Aug-83 11:39:38 by MURPHY
;More 6.1525 - Add psects, macros, etc. for section 0 code. RESCD(SEC0), SZCOD
; UPD ID= 2798, SNARK:<6.MONITOR>PROLOG.MAC.133,   4-Aug-83 00:30:52 by LEACHE
;TCO 6.1641 Move swappable freespace out of section zero
; UPD ID= 2764, SNARK:<6.MONITOR>PROLOG.MAC.132,  25-Jul-83 12:31:09 by MURPHY
;Revise previously unused symbols for PC and flags on stack.
; UPD ID= 2707, SNARK:<6.MONITOR>PROLOG.MAC.131,  19-Jul-83 11:45:54 by MCINTEE
;Typo in previous edit's comment.
; UPD ID= 2706, SNARK:<6.MONITOR>PROLOG.MAC.130,  19-Jul-83 11:33:07 by MCINTEE
;TCO 6.1740 - BUG. macro workaround for MACRO bug.
; UPD ID= 2682, SNARK:<6.MONITOR>PROLOG.MAC.129,   6-Jul-83 15:28:55 by PURRETTA
;Add copyright statement into TTITLE macro.
; UPD ID= 2622, SNARK:<6.MONITOR>PROLOG.MAC.128,  21-Jun-83 16:44:28 by MURPHY
;Note that NOSKD1 and OKSKD1 now obsolete - NOSKED and OKSKED include
; check for scheduler context.
; UPD ID= 2590, SNARK:<6.MONITOR>PROLOG.MAC.127,  20-Jun-83 08:54:51 by HALL
;TCO 6.1689 - Move the fork tables
;	Add DEFSTRs for fork tables. Don't use FKGLSP yet
; UPD ID= 2481, SNARK:<6.MONITOR>PROLOG.MAC.126,  17-May-83 17:47:34 by MURPHY
;Add SECSIZ for section size.
; UPD ID= 2409, SNARK:<6.MONITOR>PROLOG.MAC.125,   3-May-83 16:10:18 by COBB
;TCO 6.1639 - ?s in PRINTX messages...
; UPD ID= 2360, SNARK:<6.MONITOR>PROLOG.MAC.124,  27-Apr-83 14:08:26 by MOSER
;TCO 6.1609 - ADD .DVCFG
; UPD ID= 2347, SNARK:<6.MONITOR>PROLOG.MAC.123,  26-Apr-83 13:14:23 by MCINTEE
;Remove FLRLS,FLILK,FLOLK
; UPD ID= 2289, SNARK:<6.MONITOR>PROLOG.MAC.122,  16-Apr-83 19:15:54 by PAETZOLD
;TCO 6.1557 - TCP Merge
; UPD ID= 2248, SNARK:<6.MONITOR>PROLOG.MAC.121,  12-Apr-83 14:56:19 by MCINTEE
;~6.0 markers for FILNND definitions.
; UPD ID= 2242, SNARK:<6.MONITOR>PROLOG.MAC.120,  12-Apr-83 13:14:12 by MCINTEE
;Remove IFNDEF FTNSPSRV
; UPD ID= 2227, SNARK:<6.MONITOR>PROLOG.MAC.119,   8-Apr-83 17:56:37 by MURPHY
;TCO 6.1525 - Implement RSE, NRE, etc. for extended storage.
; UPD ID= 2177, SNARK:<6.MONITOR>PROLOG.MAC.118,   6-Apr-83 07:22:40 by FLEMMING
; UPD ID= 2131, SNARK:<6.MONITOR>PROLOG.MAC.117,   2-Apr-83 22:48:39 by LEACHE
;TC0 6.1247 Add more password encryption definitions
; UPD ID= 2095, SNARK:<6.MONITOR>PROLOG.MAC.116,  28-Mar-83 16:43:19 by MILLER
;TCO 6.1094. Mre CFS defs
; UPD ID= 2094, SNARK:<6.MONITOR>PROLOG.MAC.115,  28-Mar-83 15:51:51 by MILLER
;TCO 6.1094. Add more CFS defs
; UPD ID= 2092, SNARK:<6.MONITOR>PROLOG.MAC.114,  28-Mar-83 09:58:06 by GRANT
;Move MAXNDS here from SCAPAR
; UPD ID= 2077, SNARK:<6.MONITOR>PROLOG.MAC.113,  24-Mar-83 13:56:48 by MURPHY
;Further fixes to GLOBS handling.
; UPD ID= 2068, SNARK:<6.MONITOR>PROLOG.MAC.112,  23-Mar-83 17:19:13 by MURPHY
;Make GLOBS separate assembly.
; UPD ID= 2042, SNARK:<6.MONITOR>PROLOG.MAC.111,  20-Mar-83 16:40:32 by MILLER
;TCO 6.1094. Add defs for CFSSRV
; UPD ID= 1961, SNARK:<6.MONITOR>PROLOG.MAC.110,  10-Mar-83 15:06:09 by MURPHY
;Handle second PSB page same as first.
; UPD ID= 1912, SNARK:<6.MONITOR>PROLOG.MAC.109,   3-Mar-83 11:48:08 by CDUNN
;More TCO 6.1127 - Add PSISC% in FKINT. Indicates SCS% work queue has entries
;for this fork.
; UPD ID= 1891, SNARK:<6.MONITOR>PROLOG.MAC.108,   1-Mar-83 13:36:21 by MILLER
;TCO 6.1530. Define SPTMR
; UPD ID= 1885, SNARK:<6.MONITOR>PROLOG.MAC.107,  28-Feb-83 19:40:03 by PAETZOLD
;TCO 6.1529 - Remove TCO 6.1515
; UPD ID= 1878, SNARK:<6.MONITOR>PROLOG.MAC.106,  27-Feb-83 21:41:23 by MURPHY
;TCO 6.1525 - Add TSTMS0 macro to test for section 0.
;More 6.1514 - Clean up defs of ITERR, etc.  Flush XJRST.
; UPD ID= 1857, SNARK:<6.MONITOR>PROLOG.MAC.105,  22-Feb-83 13:05:48 by MILLER
;TCO 6.1520. Add defs for new per OFN word
; UPD ID= 1834, SNARK:<6.MONITOR>PROLOG.MAC.104,  20-Feb-83 20:07:12 by MURPHY
;TCO 6.1514 - Don't store error code in user AC if ERJMP/ERCAL
;   Create ITERX macro--like ITERR but assumes LSTERR already setup.
;More 6.1294 - Do it a different way.
; UPD ID= 1832, SNARK:<6.MONITOR>PROLOG.MAC.103,  18-Feb-83 20:20:47 by MILLER
;TCO 6.1094. Define SPTNA
; UPD ID= 1829, SNARK:<6.MONITOR>PROLOG.MAC.102,  18-Feb-83 16:52:55 by PAETZOLD
;TCO 6.1515 -  PH2DSW switch for debuging PH2PIMs
; UPD ID= 1811, SNARK:<6.MONITOR>PROLOG.MAC.101,  15-Feb-83 15:53:52 by MURPHY
;Clean up BUG. definitions.
; UPD ID= 1786, SNARK:<6.MONITOR>PROLOG.MAC.100,  10-Feb-83 15:42:41 by CHALL
;FIX TYPO IN ..UDPB MACRO ("POINTER" FOR "POINTR")
; UPD ID= 1728, SNARK:<6.MONITOR>PROLOG.MAC.99,   1-Feb-83 08:06:41 by MCINTEE
;Default FTNSPSRV to be 1
; UPD ID= 1725, SNARK:<6.MONITOR>PROLOG.MAC.98,  31-Jan-83 09:34:11 by MCINTEE
;CTERM LINE TYPES FOR 6.1
; UPD ID= 1717, SNARK:<6.MONITOR>PROLOG.MAC.97,  28-Jan-83 13:20:05 by GRANT
;TCO 6.1481 - add bit definitions to the DECnet circuit data base
; UPD ID= 1716, SNARK:<6.MONITOR>PROLOG.MAC.96,  28-Jan-83 13:15:22 by MURPHY
;TCO 6.1475 - Define macro to set PCS as appropriate for type of CPU.
; UPD ID= 1684, SNARK:<6.MONITOR>PROLOG.MAC.95,  20-Jan-83 08:31:05 by GRANT
;TCO 6.1469 - add definitions for DNASTA
; UPD ID= 1673, SNARK:<6.MONITOR>PROLOG.MAC.94,  17-Jan-83 08:09:21 by MCINTEE
;CHANGE DEFINITIONS OF SCWAK% AND SCBLK%
; UPD ID= 1651, SNARK:<6.MONITOR>PROLOG.MAC.93,  14-Jan-83 08:01:19 by HALL
;TCO 6.1463 - Split PAGEM into three parts
;	Move some definitions here from PAGEM
; UPD ID= 1601, SNARK:<6.MONITOR>PROLOG.MAC.92,  29-Dec-82 13:37:53 by DONAHUE
;TCO 6.1414 - Add TRPSTK
; UPD ID= 1512, SNARK:<6.MONITOR>PROLOG.MAC.91,   5-Dec-82 15:01:12 by PAETZOLD
;TCO 6.1402 - Change symbol LOCAL to LLCAL
;Delete old old edit history
; UPD ID= 1472, SNARK:<6.MONITOR>PROLOG.MAC.90,  23-Nov-82 07:19:11 by MILLER
;tco 6.1094. Add def on SPTSR
; UPD ID= 1445, SNARK:<6.MONITOR>PROLOG.MAC.89,  15-Nov-82 15:53:11 by MILLER
;TCO 6.1094. Fix CFSULK definition
; UPD ID= 1414, SNARK:<6.MONITOR>PROLOG.MAC.88,   5-Nov-82 09:49:26 by MILLER
;TCO 6.1094. Define OFNDU0
; UPD ID= 1374, SNARK:<6.MONITOR>PROLOG.MAC.87,  25-Oct-82 11:42:40 by GRANT
;TCO 6.1326 - add debugging switch for swappable free space - SWPHSW
; UPD ID= 1293, SNARK:<6.MONITOR>PROLOG.MAC.85,   7-Oct-82 13:47:34 by MILLER
;TCO 6.1094. Define SPTFR
; UPD ID= 1291, SNARK:<6.MONITOR>PROLOG.MAC.84,   7-Oct-82 13:32:24 by NICHOLS
;Fix USRSAV again, .FPAC get redefined in some modules, so test for
; standard AC save routines with literal numbers.
; UPD ID= 1284, SNARK:<6.MONITOR>PROLOG.MAC.83,   5-Oct-82 22:21:56 by NICHOLS
;Fix USRSAV macro to avoid conflict with DEFAC
; UPD ID= 1264, SNARK:<6.MONITOR>PROLOG.MAC.82,   1-Oct-82 08:44:48 by NEUSTAEDTER
;TCO 6.1294 - Add recovery address to BUG. and CONCK$
; UPD ID= 1254, SNARK:<6.MONITOR>PROLOG.MAC.81,  28-Sep-82 09:07:02 by LEACHE
;More TCO 6.1273 Change MS%EXL to MS%EXC
; UPD ID= 1249, SNARK:<6.MONITOR>PROLOG.MAC.80,  27-Sep-82 22:42:19 by MILLER
; UPD ID= 1232, SNARK:<6.MONITOR>PROLOG.MAC.79,  24-Sep-82 12:10:57 by LEACHE
;TCO 16.1273 Remove MI%ASG, MI%MXB; add MS%CRD, MS%IDX, and MS%EXL
; UPD ID= 1229, SNARK:<6.MONITOR>PROLOG.MAC.78,  24-Sep-82 11:26:59 by MILLER
;TCO 6.1094. Temp rearrangement of SPTO2 fields
; UPD ID= 1205, SNARK:<6.MONITOR>PROLOG.MAC.77,  21-Sep-82 13:20:15 by MILLER
;tco 6.1094. Add SPTDSF
; UPD ID= 1195, SNARK:<6.MONITOR>PROLOG.MAC.76,  17-Sep-82 13:50:46 by MILLER
;TCO 6.1271. Define DEBUG conditional, CKSPFL
; UPD ID= 1190, SNARK:<6.MONITOR>PROLOG.MAC.75,  16-Sep-82 10:35:45 by MILLER
;TCO 6.1000. Define JRSTCI
; UPD ID= 1181, SNARK:<6.MONITOR>PROLOG.MAC.74,  14-Sep-82 14:25:53 by LEACHE
;TCO 6.1247 - Increase field width of DRPEV
; UPD ID= 1161, SNARK:<6.MONITOR>PROLOG.MAC.73,  10-Sep-82 14:05:29 by MCINTEE
;More TCO 6.1030 - Add FLILK, FLOLK to JFN block
; UPD ID= 1138, SNARK:<6.MONITOR>PROLOG.MAC.72,   3-Sep-82 12:08:57 by LEACHE
;More tco 6.1247
; UPD ID= 1136, SNARK:<6.MONITOR>PROLOG.MAC.71,   2-Sep-82 20:02:05 by MILLER
;tco 6.1094. Add STEXL to SDBSTS
; UPD ID= 1134, SNARK:<6.MONITOR>PROLOG.MAC.70,   2-Sep-82 19:48:43 by LEACHE
;TCO 6.1247 - Add definitions for password encryption
; UPD ID= 1114, SNARK:<6.MONITOR>PROLOG.MAC.69,  25-Aug-82 15:16:46 by MCINTEE
;more TCO 6.1226 - Add in rest of symbols for asynchronous IO in JFN block
; UPD ID= 1094, SNARK:<6.MONITOR>PROLOG.MAC.68,  19-Aug-82 10:00:49 by MCINTEE
;TCO 6.1230 - new directory symbols for remote aliases
;TCO 6.1226 - new file status bit for asynchronous IO
; UPD ID= 1019, SNARK:<6.MONITOR>PROLOG.MAC.64,  30-Jul-82 11:24:54 by WALLACE
;TCO 6.1104 - Add more library link control flags and add symbols
;  for Known Library List and Known Library Block
; UPD ID= 999, SNARK:<6.MONITOR>PROLOG.MAC.63,  21-Jul-82 09:10:48 by WALLACE
;TCO 6.1104 and TCO 6.1105 - Remove conditional assembly of Dynamic
;  Linking and CTS symbols
; UPD ID= 967, SNARK:<6.MONITOR>PROLOG.MAC.62,  29-Jun-82 13:40:05 by HALL
;TCO 6.1000 - Support the 2080
;	Temporarily limit page fail address to 23 bits
; UPD ID= 959, SNARK:<6.MONITOR>PROLOG.MAC.61,  24-Jun-82 13:39:56 by HALL
;TCO 6.1000 - Support the 2080
;	Change macro for LDPAC and STPAC to supply number of last AC
; UPD ID= 951, SNARK:<6.MONITOR>PROLOG.MAC.60,  18-Jun-82 13:50:54 by MURPHY
;Final 6.1147 - Eliminate SEARCH BUGS from TTITLE.
; UPD ID= 950, SNARK:<6.MONITOR>PROLOG.MAC.59,  18-Jun-82 13:24:46 by MILLER
;TCO 6.1094. Add CFS lock/unlock macros
; UPD ID= 920, SNARK:<6.MONITOR>PROLOG.MAC.58,  10-Jun-82 15:31:00 by HALL
;TCO 6.1000 - Support the 2080
;	Add offset names for WRCTX
; UPD ID= 913, SNARK:<6.MONITOR>PROLOG.MAC.57,   9-Jun-82 23:58:05 by MURPHY
;More 6.1147 - put PRINTX in BUG for now.
; UPD ID= 880, SNARK:<6.MONITOR>PROLOG.MAC.56,   9-Jun-82 14:39:38 by HALL
;TCO 6.1000 - Support the 2080
;	Add defstr's for address break locations in PSB
; UPD ID= 874, SNARK:<6.MONITOR>PROLOG.MAC.55,   8-Jun-82 10:50:13 by MCINTEE
;More 6.1030 - FLLNK in JFN block
; UPD ID= 834, SNARK:<6.MONITOR>PROLOG.MAC.54,   4-Jun-82 16:12:08 by HALL
;TCO 6.1000 - Support the 2080
;	Correct some bit definitions for KC address break
; UPD ID= 832, SNARK:<6.MONITOR>PROLOG.MAC.53,   4-Jun-82 15:59:16 by MURPHY
;More 6.1147
; UPD ID= 829, SNARK:<6.MONITOR>PROLOG.MAC.52,   3-Jun-82 23:33:51 by PAETZOLD
;TCO 6.1155 - put XBLTMU and XBLTUM back in
; UPD ID= 828, SNARK:<6.MONITOR>PROLOG.MAC.51,   3-Jun-82 22:36:43 by PAETZOLD
;More 6.1147 - Fix up bug macros.
; UPD ID= 821, SNARK:<6.MONITOR>PROLOG.MAC.50,   3-Jun-82 13:10:17 by HALL
;TCO 6.1000 - Support the 2080
;	Get rid of XBLTMU and XBLTUM
;	Add some comments to the previous context stuff
; UPD ID= 814, SNARK:<6.MONITOR>PROLOG.MAC.49,   2-Jun-82 17:34:52 by MURPHY
;DITTO
; UPD ID= 808, SNARK:<6.MONITOR>PROLOG.MAC.48,   1-Jun-82 19:13:13 by MURPHY
;More 6.1147 - Fix up bug macros.
; UPD ID= 801, SNARK:<6.MONITOR>PROLOG.MAC.47,   1-Jun-82 10:57:11 by MURPHY
;TCO 6.1147 - Move bug defs from BUGS.MAC to modules in which used.
; UPD ID= 791, SNARK:<6.MONITOR>PROLOG.MAC.46,  26-May-82 19:41:39 by WALLACE
;TCO 6.1104 and 6.1105 Add Dynamically Linked Libraries and Canonical
;    Terminal Support
;  Add Macro definitions for FTDYN and FTCTS
;  Add Miscellaneous Symbols TDBSIZ, the size of a terminal data base and
;    CTSCSZ, the size of the area reserved for CTS usage
;  Add CTS State Block and Vector State Block Symbols
;  Add flags for Dynamic Linking Routines
; UPD ID= 774, SNARK:<6.MONITOR>PROLOG.MAC.45,  20-May-82 16:27:11 by HALL
;TCO 6.1000 - Support the 2080
;	Change definition of STPAC to allow indexing
; UPD ID= 770, SNARK:<6.MONITOR>PROLOG.MAC.44,  19-May-82 16:52:45 by HALL
;TCO 6.1000 - Support the 2080
;	Add LDPAC. and STPAC. macros
;TCO 6.1000 - Support the 2080
;	Move IMCFLG here to be with other bits
;	Rearrange some more
; UPD ID= 740, SNARK:<6.MONITOR>PROLOG.MAC.42,  13-May-82 06:53:47 by HALL
;TCO 6.1000 - Support the 2080
;	Remove redundant definition of DATAO PAG bits
;	Rearrange things according to function
; UPD ID= 710, SNARK:<6.MONITOR>PROLOG.MAC.41,   9-May-82 13:46:22 by HALL
;TCO 6.1000 - Support the 2080. Define field in flags word that mu be zero
; UPD ID= 697, SNARK:<6.MONITOR>PROLOG.MAC.40,   6-May-82 15:09:31 by HALL
;TCO 6.1000- Support the 2080
;	Add XJRST
;	Move flag word fields here from APRSRV and clean things up a bit
;	Add RDTRAX, WRTRAX, LDPAC, STPAC
; UPD ID= 679, SNARK:<6.MONITOR>PROLOG.MAC.39,   3-May-82 15:35:47 by MCINTEE
;TCO 6.1030 - New bit in FKINT, PSIDP%, for DAP% jsys
; UPD ID= 662, SNARK:<6.MONITOR>PROLOG.MAC.38,  27-Apr-82 09:48:39 by MILLER
;TCO 6.1038. Add correct definition of CSWRB for both KL and KC
; UPD ID= 658, SNARK:<6.MONITOR>PROLOG.MAC.37,  23-Apr-82 13:50:52 by HALL
;TCO 6.1000 - move a few bits
; UPD ID= 640, SNARK:<6.MONITOR>PROLOG.MAC.36,  14-Apr-82 09:51:00 by HALL
;TCO 6.1000 - Support the 2080
;	Add more page fail data
; UPD ID= 633, SNARK:<6.MONITOR>PROLOG.MAC.35,  12-Apr-82 15:32:32 by MILLER
;TCO 6.1089. Add defs for CFS in SPTO2
; UPD ID= 630, SNARK:<6.MONITOR>PROLOG.MAC.34,  12-Apr-82 10:53:04 by HALL
;TCO 6.1000 - Add page fail code for 2080
; UPD ID= 621, SNARK:<6.MONITOR>PROLOG.MAC.33,   9-Apr-82 17:42:33 by MURPHY
;More 6.1074 - Make BUGS.MAC separate assembly.
; UPD ID= 616, SNARK:<6.MONITOR>PROLOG.MAC.32,   9-Apr-82 10:19:14 by MURPHY
;Make UMOVE definition processor-dependent.
; UPD ID= 607, SNARK:<6.MONITOR>PROLOG.MAC.31,   7-Apr-82 16:25:58 by HALL
;TCO 6.1000 - Support the 2080
;	Add definition of super section pointer for KL compatible mode
;	Add bits for the MAP instruction
; UPD ID= 604, SNARK:<6.MONITOR>PROLOG.MAC.30,   7-Apr-82 10:03:49 by HALL
;TCO 6.1000 - Support the 2080
;	Add definition of SZPI for the KL
; UPD ID= 577, SNARK:<6.MONITOR>PROLOG.MAC.29,   2-Apr-82 12:18:09 by HALL
;TCO 6.1000 - Support the 2080
;For KC, update WREBR bits
;Remove PICHON and PICHOF from processor-dependent definitions
; UPD ID= 557, SNARK:<6.MONITOR>PROLOG.MAC.28,  24-Mar-82 16:51:52 by MURPHY
;TCO 6.1074 - Revise build procedures.
; UPD ID= 474, SNARK:<6.MONITOR>PROLOG.MAC.27,  13-Mar-82 10:31:51 by MILLER
;TCO 6.1066. ADD TT.RSP
; UPD ID= 451, SNARK:<6.MONITOR>PROLOG.MAC.26,  10-Mar-82 14:58:13 by HALL
;TCO 6.1000 - Support the 2080
;Rearrange the WRPI bits and macros
; UPD ID= 438, SNARK:<6.MONITOR>PROLOG.MAC.25,   6-Mar-82 11:49:33 by HALL
;TCO 6.1000 - Support the 2080
;Move paging bits from here to PROKL and PROKC
; UPD ID= 357, SNARK:<6.MONITOR>PROLOG.MAC.24,  28-Jan-82 08:39:45 by GRANT
;Turn on RESHSW
; UPD ID= 304, SNARK:<6.MONITOR>PROLOG.MAC.23,  15-Jan-82 15:22:05 by GRANT
;TCO 5.1679 - change LOKK macro to store FORKX on fast lock
; UPD ID= 273, SNARK:<6.MONITOR>PROLOG.MAC.22,   5-Jan-82 09:08:21 by GRANT
;TCO 5.1649 - Add NSPNUL
; UPD ID= 211, SNARK:<6.MONITOR>PROLOG.MAC.20,  17-Nov-81 21:29:25 by MILLER
;TCO 6.1038. Add CSWRB definition
; UPD ID= 178, SNARK:<6.MONITOR>PROLOG.MAC.19,  31-Oct-81 14:43:16 by PAETZOLD
;More TCO 6.1010 - CHANGE CST3 FIELDS
; UPD ID= 170, SNARK:<6.MONITOR>PROLOG.MAC.18,  26-Oct-81 20:46:39 by PAETZOLD
;More TCO 5.1596
; UPD ID= 168, SNARK:<6.MONITOR>PROLOG.MAC.17,  26-Oct-81 00:10:23 by PAETZOLD
;TCO 5.1596 - Put DEBUG switch stuff under NDG's
; UPD ID= 91, SNARK:<6.MONITOR>PROLOG.MAC.16,   5-Oct-81 11:36:10 by MURPHY
;NODE NAME PARSING, NFT DEVICE
;REVISE DTB FORMAT; GET RID OF DOUBLE SKIPS ON NLUKD, ETC.
; UPD ID= 90, SNARK:<6.MONITOR>PROLOG.MAC.15,   4-Oct-81 23:52:02 by PAETZOLD
;TCO 5.1554 - ADD SPTDSW DEBUGINGG SWITCH
; UPD ID= 76, SNARK:<6.MONITOR>PROLOG.MAC.14,  17-Sep-81 01:49:39 by PAETZOLD
;TCO 6.1010 - Move CSTs to CSTSEC - Change CST field definitions
; UPD ID= 43, SNARK:<6.MONITOR>PROLOG.MAC.13,   5-Aug-81 12:19:38 by MURPHY
; UPD ID= 42, SNARK:<6.MONITOR>PROLOG.MAC.12,   5-Aug-81 12:17:21 by MURPHY
;TCO 5.1428 - BSOVRD IN FKSWP
; UPD ID= 26, SNARK:<6.MONITOR>PROLOG.MAC.11,  15-Jul-81 11:54:01 by MURPHY
;DEBUG SWITCH CZQDBG
; UPD ID= 1, SNARK:<6.MONITOR>PROLOG.MAC.10,   9-Jul-81 17:18:11 by MURPHY
;TCO 5.1396 - BSSPQ IN FKSWP
; UPD ID= 1841, SNARK:<6.MONITOR>PROLOG.MAC.9,  17-Apr-81 14:57:52 by MURPHY
;Change BUGCHK and BUGINF calls to PUSHJ
; UPD ID= 1788, SNARK:<6.MONITOR>PROLOG.MAC.8,   5-Apr-81 14:47:54 by GRANT
;Add DN20SW - debugging switch for a 2nd DN20
; UPD ID= 1666, SNARK:<6.MONITOR>PROLOG.MAC.7,  11-Mar-81 17:11:25 by MURPHY
;MOVE ENTSKD TO SCHED
; UPD ID= 1659, SNARK:<6.MONITOR>PROLOG.MAC.6,  10-Mar-81 12:41:36 by HALL
;TCO 6.1000 - move DATAI/DATAO PAG bits back here because PAGEM needs
; them (Have to fix this later)
; UPD ID= 1613, SNARK:<6.MONITOR>PROLOG.MAC.4,  28-Feb-81 11:22:01 by HALL
;TCO 6.1000 - SUPPORT THE 2080
;	MOVE DATA DEFINITIONS FOR CONI/CONO PAG AND DATAI/DATAO PAG TO
;	INDIVIDUAL FILES (PROKL,PROKS,PROKC)
; UPD ID= 1612, SNARK:<5.MONITOR>PROLOG.MAC.41,  27-Feb-81 18:27:09 by MURPHY
;EA.ENT, S0.ENT
; UPD ID= 1604, SNARK:<5.MONITOR>PROLOG.MAC.40,  27-Feb-81 09:53:56 by FLEMMING
;TCO 5.1265 - define a mask for page/section pointer access bits
; UPD ID= 1590, SNARK:<5.MONITOR>PROLOG.MAC.39,  26-Feb-81 17:41:58 by MURPHY
;BUG(NULL)
; UPD ID= 1558, SNARK:<5.MONITOR>PROLOG.MAC.38,  13-Feb-81 15:54:41 by MURPHY
;MORE OF%RDU
; UPD ID= 1540, SNARK:<5.MONITOR>PROLOG.MAC.37,   9-Feb-81 13:03:54 by HALL
;TYPO IN PREVIOUS EDIT
; UPD ID= 1538, SNARK:<5.MONITOR>PROLOG.MAC.36,   9-Feb-81 12:53:44 by HALL
;TCO 5.1180 - ADD SEC0SW DEBUGGING SWITCH
; UPD ID= 1537, SNARK:<5.MONITOR>PROLOG.MAC.35,   9-Feb-81 12:24:15 by MURPHY
;SUPPORT FOR OF%RDU
; UPD ID= 1491, SNARK:<5.MONITOR>PROLOG.MAC.34,  26-Jan-81 11:56:18 by MURPHY
;PUT SALL BACK IN TTITLE
; UPD ID= 1484, SNARK:<5.MONITOR>PROLOG.MAC.33,  24-Jan-81 22:39:18 by GRANT
; UPD ID= 1483, SNARK:<5.MONITOR>PROLOG.MAC.32,  24-Jan-81 22:22:07 by GRANT
;REMOVE RESFSW AND ADD RESBSW AND RESHSW
; UPD ID= 1476, SNARK:<5.MONITOR>PROLOG.MAC.31,  22-Jan-81 12:19:39 by MURPHY
;MOVE BLCALL AND FRIENDS TO MACSYM
; UPD ID= 1462, SNARK:<5.MONITOR>PROLOG.MAC.29,  21-Jan-81 11:06:52 by GRANT
;TCO 5.1230 - ADD DEBUGGING SWITCHES
; UPD ID= 1460, SNARK:<5.MONITOR>PROLOG.MAC.28,  20-Jan-81 17:36:54 by MURPHY
;FIX BLCALL, BLSUBR
; UPD ID= 1227, SNARK:<5.MONITOR>PROLOG.MAC.27,   4-Nov-80 11:27:18 by GRANT
;TCO 5.1188 - EXPAND RESIDENT FREE SPACE HEADER, CREATE TRAILER
; UPD ID= 1180, SNARK:<5.MONITOR>PROLOG.MAC.26,  20-Oct-80 17:58:26 by MURPHY
;BLCALL, BLSUBR MACROS
; UPD ID= 1094, SNARK:<5.MONITOR>PROLOG.MAC.25,   1-Oct-80 15:46:06 by MURPHY
;DITTO
; UPD ID= 1076, SNARK:<5.MONITOR>PROLOG.MAC.24,   1-Oct-80 10:37:29 by MURPHY
;FANCIER SAVEAC MACRO
;REMOVE REPEAT 0 AROUND STKFLG AND STKPC
;<5.MONITOR>PROLOG.MAC.23, 18-Sep-80 16:28:33, EDIT BY ENGEL
;GET RID OF LOKGNM
; UPD ID= 969, SNARK:<5.MONITOR>PROLOG.MAC.22,  25-Aug-80 16:30:19 by ENGEL
;TCO 5.1136 - ADD DEVLKK
; UPD ID= 950, SNARK:<5.MONITOR>PROLOG.MAC.21,  22-Aug-80 15:52:54 by ENGEL
; UPD ID= 949, SNARK:<5.MONITOR>PROLOG.MAC.19,  22-Aug-80 15:50:59 by ENGEL
;FIX LOCK BUG
; UPD ID= 937, SNARK:<5.MONITOR>PROLOG.MAC.17,  20-Aug-80 15:16:15 by ENGEL
;TCO #5.1136 - CHANGE ALL LOCKS TO CONFORM TO THE NEW LOCK SCHEME
; UPD ID= 887, SNARK:<5.MONITOR>PROLOG.MAC.16,  13-Aug-80 13:38:56 by ENGEL
; UPD ID= 885, SNARK:<5.MONITOR>PROLOG.MAC.15,  13-Aug-80 13:34:23 by ENGEL
;ADD THE BASIC LOCKING MACRO'S
; UPD ID= 881, SNARK:<5.MONITOR>PROLOG.MAC.14,  12-Aug-80 18:56:00 by MURPHY
;TTITLE
; UPD ID= 798, SNARK:<5.MONITOR>PROLOG.MAC.13,  24-Jul-80 15:03:03 by LYONS
;TCO 5.1062  move MI%ASG and other bits in HOMFLG over to prevent overlap
;with MS%??? bits of the MSTR% JSYS
; UPD ID= 784, SNARK:<5.MONITOR>PROLOG.MAC.12,  23-Jul-80 11:49:16 by HALL
;ADD COMMENTS TO RSI MACRO DEFINITION
; UPD ID= 763, SNARK:<5.MONITOR>PROLOG.MAC.11,  18-Jul-80 15:20:40 by MURPHY
;Add DEFSTR for JBTTY and JBTFK in JOBPT
; UPD ID= 716, SNARK:<5.MONITOR>PROLOG.MAC.10,   1-Jul-80 09:44:51 by HALL
;IN RESIDENT FREE SPACE, REMOVE RSREL, MAKE POOL NUMBER BE 18 BITS
; UPD ID= 680, SNARK:<5.MONITOR>PROLOG.MAC.9,  19-Jun-80 22:11:36 by MURPHY
;BUG macro again
; UPD ID= 676, SNARK:<5.MONITOR>PROLOG.MAC.8,  18-Jun-80 22:36:24 by MURPHY
;Clean up listing output from BUG macro a bit.
; UPD ID= 651, SNARK:<5.MONITOR>PROLOG.MAC.7,  16-Jun-80 15:55:18 by MURPHY
;IMPROVE COMMENTS ON SE1CAL, ETC.
; UPD ID= 561, SNARK:<5.MONITOR>PROLOG.MAC.6,  27-May-80 15:05:50 by ENGEL
;ADD LCSDTE
; UPD ID= 559, SNARK:<5.MONITOR>PROLOG.MAC.5,  27-May-80 13:05:07 by ENGEL
; UPD ID= 507, SNARK:<5.MONITOR>PROLOG.MAC.4,   5-May-80 14:32:12 by ENGEL
;ADD ICCS DEFNITIONS
; UPD ID= 438, SNARK:<5.MONITOR>PROLOG.MAC.3,  13-Apr-80 15:13:34 by OSMAN
;Add FRKTTY
; UPD ID= 422, SNARK:<5.MONITOR>PROLOG.MAC.2,  11-Apr-80 13:51:28 by HALL
;ADD DEFINITION OF RSI MACRO FOR RESIDENT DATA THAT ISN'T ZEROED
; UPD ID= 334, SNARK:<4.1.MONITOR>PROLOG.MAC.127,  14-Mar-80 11:16:30 by OSMAN
;tco 4.1.1110 - Prevent false alphabetical order warning in DEFBUG
; UPD ID= 284, SNARK:<4.1.MONITOR>PROLOG.MAC.126,  20-Feb-80 17:55:44 by MURPHY
;CHANGE NAME OF FIELD TO FKMNQ
; UPD ID= 80, SNARK:<4.1.MONITOR>PROLOG.MAC.125,   3-Dec-79 10:52:11 by OSMAN
;Add alphabetical order checking for bugs
;<4.1.MONITOR>PROLOG.MAC.124, 12-Nov-79 16:30:03, EDIT BY OSMAN
;tco 4.1.1017 - Search MACSYM before MONSYM
;<4.1.MONITOR>PROLOG.MAC.123,  8-Nov-79 17:35:04, EDIT BY MURPHY
;CHANGE DEF OF CHKINT

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.

DEFINE CPYRT <.CPYRT 1988>


	UNIVERSAL PROLOG
	SALL
	SEARCH MACSYM,MONSYM


;FORM OF OPDEF TO DO INTERNAL

DEFINE GOPDEF (NAM,VAL)<
	OPDEF NAM [<VAL>]
	INTERN NAM>

;FORM OF OPDEF TO DO .NODDT'D INTERNAL

DEFINE GSOPDEF (NAM,VAL)<
	OPDEF NAM [VAL]
	INTERN NAM
	.NODDT NAM>

;DEFINE GLOBAL SYMBOL IF NOT ALREADY DEFINED AND LIST VALUE

DEFINE NDG (SYM,VAL)<
   IFNDEF SYM,<
	SYM==:VAL>>

;DEFINE SYMBOL IF NOT ALREADY DEFINED AND LIST VALUE

DEFINE ND (SYM,VAL)<
   IFNDEF SYM,<
	SYM==VAL>>


;ABBREVIATION FOR IFN ??FLG,<>

DEFINE IFKL (ARG)<
   IFN KLFLG,<
	ARG>>
DEFINE IFSM (ARG)<
   IFN SMFLG,<
	ARG>>

JSBFSZ==:100			; INITIAL SIZE OF JSB FREE AREA

ND RVCF,0			;T=RVC/MLKBK SUPPORTED


;DEBUG SWITCHES

NDG DEBUG,0			;THE MASTER SWITCH

;IF THE MASTER SWITCH IS OFF, ALL SWITCHES ARE OFF

IFE DEBUG,<

FSPDBG==:0			;Swappable freespace debugging
FSPACC==:0			;Swappable freespace block accounting
RESBSW==:0			;RESIDENT FREE SPACE RING BUFFER
RESHSW==:0			;RESIDENT FREE SPACE EXTRA HEADER AND TRAILER
SWPHSW==:0			;SWAPPABLE FREE SPACE HEADER WORD
DTESW==:0			;DTE DRIVER
SKEDSW==:0			;SCHEDULER
SEC0SW==:0			;CHECK FOR CODE IN SECTION 0
DN20SW==:0			;CHECK FOR A 2ND DN20
MCBDBG==:0			;Extra debug checks in DTESRV
SPTDSW==:0			;SPTLKB LOCKER TRACE FACILITY
CZQDBG==:0			;TRACE LOGICAL LINK CLOSES FROM NVT CODE
CKSPFL==:0
IPFDSW==:0			;IP FREE SPACE RING BUFFER
IPQDSW==:0			;TCP/IP Q MANIPULATION RING BUFFER
IPPDSW==:0			;IP PACKET PRINTER
IPLDSW==:0			;IP BUFFER LOCK MANIPULATION RING BUFFER
KLPDBG==:0			;KLIPA DRIVER (PHYKLP.MAC)
SCARNG==:0			;SCA ring buffer recording
SCADBG==:0			;SCA debugging features
FTTRACE==:0			;DECNET-36 - NON-ZERO TO ENABLE TRACES
FTMINTRACE==:0			;DECNET-36 - MINI TRACE (SUBSET OF ABOVE)
FTDEBUG==:0			;DECNET-36 - ASSEMBLE WITH DEBUGGING STUFF
FTPARANOID==:0			;DECNET-36 - DO EXTRA CAREFUL CHECKING
FTCORBUG==:0			;DECNET-36 - FTPARANOID FOR CORE MANAGER
FTLSTCOR==:0			;DECNET-36 - TRY TO TRACE LOST CORE
FTHMMEM==:0			;DECNET-36 - Memory request map
FTRTST==:0			;DECNET-36 - Router message looper
>				; END OF IFE DEBUG

;IF THE MASTER SWITCH IS ON, THE FOLLOWING SWITCH VALUES ARE IN USE

IFN DEBUG,<

NDG FSPDBG,1
NDG FSPACC,1
NDG RESBSW,1
NDG RESHSW,1
NDG SWPHSW,1
NDG DTESW,1
NDG SKEDSW,1
NDG SEC0SW,1
NDG DN20SW,1
NDG MCBDBG,1			;Extra debug checks in DTESRV (DECnet-36)
NDG CZQDBG,1
NDG SPTDSW,1
NDG CKSPFL,1
NDG IPFDSW,0			;IP FREE SPACE RING BUFFER
NDG IPQDSW,0			;TCP/IP Q MANIPULATION RING BUFFER
NDG IPPDSW,0			;IP PACKET PRINTER
NDG IPLDSW,0			;IP BUFFER LOCK MANIPULATION RING BUFFER
NDG KLPDBG,1			;KLIPA DRIVER (PHYKLP.MAC)
NDG SCARNG,1			;SCA ring buffer recording
NDG SCADBG,1			;SCA debugging features
NDG FTTRACE,0			;DECNET-36 - NON-ZERO TO ENABLE TRACES
NDG FTMINTRACE,0		;DECNET-36 - MINI TRACE (SUBSET OF ABOVE)
NDG FTDEBUG,1			;DECNET-36 - ASSEMBLE WITH DEBUGGING STUFF
NDG FTPARANOID,1		;DECNET-36 - DO EXTRA CAREFUL CHECKING
NDG FTCORBUG,0			;DECNET-36 - FTPARANOID FOR CORE MANAGER
NDG FTLSTCOR,1			;DECNET-36 - TRY TO TRACE LOST CORE
NDG FTHMMEM,1			;DECNET-36 - Memory request map
NDG FTRTST,1			;DECNET-36 - Router message looper
>
	SUBTTL Processor-specific instructions

   IFN KLFLG,<
GOPDEF APRID,<BLKI 0,0>
GOPDEF WRFIL,<BLKO 0,0>
GOPDEF RDERA,<BLKI 4,0>
GOPDEF SBDIAG,<BLKO 4,0>
GOPDEF CLRPT,<BLKO 10,0>
GOPDEF CCHIA,<DATAI 14,0>	;INVALIDATE ALL (SWPIA)
GOPDEF CCHVA,<BLKO 14,0>	;VALIDATE ALL (SWPVA)
GOPDEF CCHUA,<DATAO 14,0>	;UNLOAD ALL (SWPUA)
GOPDEF CCHIO,<CONI 14,0>	;INVALIDATE ONE PAGE (SWPIO)
GOPDEF CCHVO,<CONSZ 14,0>	;VALIDATE ONE PAGE (SWPVO)
GOPDEF CCHUO,<CONSO 14,0>	;UNLOAD ONE PAGE (SWPUO)
GOPDEF RDPERF,<BLKI 20,0>
GOPDEF WRPAE,<BLKO 20,0>
GOPDEF RDMACT,<BLKI 24,0>
GOPDEF RDEACT,<DATAI 24,0>
GOPDEF SZPI,<CONSZ PI,0>	;SKIP IF PI BITS OFF (KC instruction)
   >				;END OF IFN KLFLG

   IFN KCFLG,<
GOPDEF APR0,<700000,,0>
GOPDEF APR1,<701000,,0>
GOPDEF APR2,<702000,,0>
GOPDEF UMOVE,<704000,,0>	;MOVE FROM PREVIOUS CONTEXT
GOPDEF UMOVEM,<705000,,0>	;MOVEM TO PREVIOUS CONTEXT
GOPDEF PMOVE,<706000,,0>	;MOVE FROM PHYSICAL ADDRESS
GOPDEF PMOVEM,<707000,,0>	;MOVEM TO PHYSICAL ADDRESS
GOPDEF RINGB,<710000,,0>	;RING DOORBELL, DON'T WAIT
GOPDEF JRSTCI,<JRST 1,>		;JRSTCI -- Flush IBOX
GOPDEF RINGBW,<711000,,0>	;RING DOORBELL AND WAIT
GOPDEF SNBSY,<712000,,0>	;SKIP IF BUSY IS NOT SET
GOPDEF LDPAC,<716000,,0>	;LOAD PREVIOUS CONTEXT AC'S
GOPDEF STPAC,<717000,,0>	;STORE PREVIOUS CONTEXT AC'S
GOPDEF INSQHI,<720000,,0>	;INSERT AT HEAD, INTERLOCKED
GOPDEF INSQTI,<721000,,0>	;INSERT AT TAIL, INTERLOCKED
GOPDEF REMQHI,<722000,,0>	;REMOVE FROM HEAD, INTERLOCKED
GOPDEF REMQTI,<723000,,0>	;REMOVE FROM TAIL, INTERLOCKED
GOPDEF RDTRAX,<732000,,0>	;READ TRACKS BUFFER
GOPDEF WRTRAX,<733000,,0>	;WRITE TRACKS BUFFER

;APR INSTRUCTIONS

GOPDEF APRID,<APR0 0,0>		;GET THE SERIAL NUMBER, ETC.
GOPDEF WRAPR,<APR0 4,0>		;SET PROCESSOR CONDITIONS
GOPDEF RDAPR,<APR0 5,0>		;READ PROCESSOR CONDITIONS
GOPDEF SZAPR,<APR0 6,0>		;SKIP IF PROCESSOR CONDITIONS ARE 0
GOPDEF SOAPR,<APR0 7,0>		;SKIP IF ANY PROCESSOR CONDITION IS NON-0
GOPDEF WRPI,<APR0 14,0>		;SET PRIORITY INTERRUPT SYSTEM
GOPDEF RDPI,<APR0 15,0>		;READ PRIORITY INTERRUPT SYSTEM
GOPDEF SZPI,<APR0 16,0>		;SKIP IF INTERRUPT CONDITIONS 0
GOPDEF SOPI,<APR0 17,0>		;SKIP IF INTERRUPT CONDITIONS NON-0
GOPDEF SETCU,<APR1 0,0>		;SET "CST UPDATE NEEDED"
GOPDEF RDCTX,<APR1 1,0>		;READ USER CONTEXT (5 WORDS)
GOPDEF CLRPT,<APR1 2,0>		;CLEAR SINGLE PAGE TABLE ENTRY
GOPDEF WRCTX,<APR1 3,0>		;SET USER CONTEXT
GOPDEF WREBR,<APR1 4,0>		;SET EXEC MODE CONTEXT
GOPDEF RDEBR,<APR1 5,0>		;READ EXEC MODE CONTEXT
GOPDEF WRIOP,<APR1 6,0>		;SET IO PAGE ADDRESS
GOPDEF RDIOP,<APR1 7,0>		;READ IO PAGE ADDRESS
GOPDEF RDUBR,<APR1 10,0>	;WRITE USER BASE REGISTER
GOPDEF SWPIA,<APR1 11,0>	;INVALIDATE ALL CACHE
GOPDEF SWPUA,<APR1 13,0>	;UNLOAD AND INVALIDATE ALL CACHE
GOPDEF RDSPB,<APR2 0,0>		;READ SPT BASE REGISTER
GOPDEF RDCSB,<APR2 1,0>		;READ CST BASE REGISTER
GOPDEF RDPUR,<APR2 2,0>		;READ PROCESS USE REGISTER
GOPDEF RDCSTM,<APR2 3,0>	;READ CST MASK REGISTER
GOPDEF RDTMB,<APR2 4,0>		;READ TIME BASE
GOPDEF RDINT,<APR2 5,0>		;READ THE INTERVAL TIMER
GOPDEF RDTIME,<APR2 6,0>	;READ TIME BASE
GOPDEF RDURTM,<APR2 7,0>	;READ USER RUN TIME
GOPDEF WRSPB,<APR2 10,0>	;WRITE SPT BASE REGISTER
GOPDEF WRCSB,<APR2 11,0>	;WRITE CST BASE REGISTER
GOPDEF WRPUR,<APR2 12,0>	;WRITE PROCESS USE REGISTER
GOPDEF WRCSTM,<APR2 13,0>	;WRITE CST MASK REGISTER
GOPDEF WRTMB,<APR2 14,0>	;WRITE TIME BASE
GOPDEF WRINT,<APR2 15,0>	;WRITE INTERVAL TIMER
GOPDEF WRACT,<APR2 16,0>	;WRITE USER ACCOUNTING INFORMATION
GOPDEF RDACT,<APR2 17,0>	;READ USER ACCOUNTING INFORMATION

GOPDEF XJRST,<JRST 15,0>	;JUMP TO C(E)
   >				;END OF IFN KCFLG

   IFN SMFLG,<

;PROCESSOR INSTRUCTIONS

GOPDEF CLRPT,<BLKO 10,0>	;CLEAR PAGE TABLE ENTRY FOR EFF ADR
GOPDEF APRID,<BLKI 0,0>		;GET PROCESSOR SERIAL NUMBER, ETC.

; OPDEF:S FOR SM10 UNIBUS ADAPTER

GOPDEF TIOE,<710000,,0>		;TEST IO NO MOD SKIP IF EQUAL
GOPDEF TIOEB,<720000,,0>	;TEST IO BYTE NO MOD SKIP IF EQUAL
GOPDEF TION,<711000,,0>		;TEST IO NO MOD SKIP IF NOT EQUAL
GOPDEF TIONB,<721000,,0>	;TEST IO BYTE NO MOD SKIP IF NOT EQUAL
GOPDEF RDIO,<712000,,0>		;READ I/O
GOPDEF RDIOB,<722000,,0>	;READ I/O BYTE
GOPDEF WRIO,<713000,,0>		;WRITE I/O
GOPDEF WRIOB,<723000,,0>	;WRITE I/O BYTE
GOPDEF BSIO,<714000,,0>		;BIT SET I/O
GOPDEF BSIOB,<724000,,0>	;BIT SET I/O BYTE
GOPDEF BCIO,<715000,,0>		;BIT CLEAR I/O
GOPDEF BCIOB,<725000,,0>	;BIT CLEAR I/O BYTE
GOPDEF WRSPB,<702400,,0>	;WRITE SPT BASE REGISTER
GOPDEF RDSPB,<702000,,0>	;READ SPT BASE REGISTER
GOPDEF WRCSB,<702440,,0>	;WRITE CORE STATUS TABLE BASE EGISTER
GOPDEF RDCSB,<702040,,0>	;READ CORE STATUS TABLE BASE REGISTER
GOPDEF WRPUR,<702500,,0>	;WRITE PROCESS USE REGISTER
GOPDEF RDPUR,<702100,,0>	;READ PROCESS USE REGISTER
GOPDEF WRCSTM,<702540,,0>	;WRITE CST MASK REGISTER
GOPDEF RDCSTM,<702140,,0>	;READ CST MASK REGISTER
GOPDEF WRTIME,<702600,,0>	;WRITE TIME BASE
GOPDEF RDTIME,<702200,,0>	;READ TIME BASE
GOPDEF WRINT,<702640,,0>	;WRITE INTERVAL TIMER
GOPDEF RDINT,<702240,,0>	;READ INTERVAL TIMER
GOPDEF RDHSB,<702300,,0>	;READ HALT STATUS BLOCK ADDRESS
GOPDEF WRHSB,<702700,,0>	;WRITE HALT STATUS BLOCK ADDRESS
   >				;END OF IFN SMFLG

	SUBTTL Data for APR instructions

APR==:0				;DEVICE CODE FOR APR

IFN KLFLG,<

;BITS FOR DATAO APR (ADDRESS BREAK)

ABIF==:1B9			;INSTRUCTION FETCH
ABDR==:1B10			;DATA READ
ABDW==:1B11			;DATA WRITE
ABUM==:1B12			;USER MODE (PC, NOT VMA)

;HARDWARE/FIRMWARE REGISTERS

HWRACB==:6			;AC BLOCK FOR PAGING VARIABLES

SPTBR==:3			;SPT BASE REG
CSTBR==:2			;CST BASE REG
CSTMSK==:0			;CST UPDATE MASK
CSTDAT==:1			;CST UPDATE DATA

   >				;END OF IFN KLFLG
	SUBTTL Data for WRPI/RDPI and CONO/CONI PI

   IFN KLFLG,<
PI==:4				;DEVICE CODE FOR PI
   >				;END OF IFN KLFLG

PICPIR==:1B22			;CLEAR PROGRAM PI REQUEST
PICLPI==:1B23			;CLEAR PI SYSTEM
PISPIR==:1B24			;SET PROGRAM PI REQUEST
PICHON==:1B25			;TURN CHANNELS ON
PICHOF==:1B26			;TURN CHANNELS OFF
PIPIOF==:1B27			;TURN PI SYSTEM OFF
PIPION==:1B28			;TURN PI SYSTEM ON

PIPIRM==:177B17			;PROGRAM REQUEST ACTIVE CHANNELS
PIPIIP==:177B27			;PI IN PROGRESS CHANNELS
PICHNM==:177B35			;CHANNEL MASK

;PI CONTROL DEFINITIONS

GOPDEF PIOFF,<CONO PI,PIPIOF>
GOPDEF PION,<CONO PI,PIPION>
DEFINE ISB (CHN)<
	CONO PI,PISPIR+1B<28+CHN>>

DEFINE CLSB (CHN)<
	CONO PI,PICPIR+1B<28+CHN>>

DEFINE UNBRK (DEV)<
	JRST DEV'CHR##>

DEFINE CHNOFF (CHN)<
	CONO PI,PICHOF+1B<28+CHN>
   >

DEFINE CHNON (CHN)<
	CONO PI,PICHON+1B<28+CHN>>


;PI CHANNEL ASSIGNMENTS FOR ALL DEVICES

PHYCHN==:5			;PHYSIO CHANNEL
DSKCHN==:5			;DISK
DRMCHN==:4			;DRUM
DLSCHN==:6			;KL CHANNEL FOR TTY PI
IMPCHN==:6			;CHANNEL FOR IMP DEVICES
MTACHN==:5			;MAG TAPE FLAGS CHANNEL
 MTDCHN==:1			;MAG TAPE DATA CHANNEL
DTACHN==:5			;DECTAPE CONTROL
 DTDCHN==:2			;DECTAPE DATA
PTPCHN==:6			;PAPER TAPE PUNCH
PTRCHN==:5			;PAPER TAPE READER
PLTCHN==:6			;PLOTTER
LPTCHN==:6			; LINE PRINTER PI CHANNEL
VBCCHN==:6			;VB10C DISPLAY
DLXCHN==:6			;DL10 SERVICE ROUTINE

APRCHN==:3			;APR PI CHANNEL
SCDCHN==:7			;SCHEDULER PI CHANNEL
   IFN SMFLG,<
UNBCHN==:56			;UNIBUS ADAPTER 2 PIA'S (11 DEVICES ARE BACKWARDS)
UNBPI5==6B35			;PI LEVEL OF BR5,BR4
UNBPI7==5B32			;PI LEVEL OF BR6,BR7
				;PI7 ON 11 IS HIGH THEREFORE IT IS 5 HERE
				;PI5 ON 11 IS LOW THEREFORE IT IS 7 HERE
   >				;END OF IFN SMFLG

	SUBTTL Data from APRID instruction

; APRID WORD DEFINITIONS

DEFSTR APRMO,,8,9		;APR MICROCODE OPTIONS FIELD
DEFSTR APRMVR,,17,9		;APR MICROCODE VERSION FIELD
DEFSTR APRHO,,23,6		;APR HARDWARE OPTIONS FIELD
DEFSTR APRNM,,35,12		;APR SERIAL NUMBER FIELD

    IFN KLFLG,<
KLB==:1B3			;[7357] Model B flag
PMOV==:1B4			;[7357] PMOVE/M present bit
MCA25==:1B23			;MCA25 HARDWARE 
   >				;END OF IFN KLFLG

	SUBTTL Data for WREBR/RDEBR and CONO/CONI PAG

   IFN KLFLG,<
PGCLKE==:1B18			;CACHE LOOK ENABLE
PGCLDE==:1B19			;CACHE LOAD ENABLE

PGKLMD==:1B21			;KL20 PAGING MODE
PGTPEN==:1B22			;TRAP ENABLE
PGEBRM==:<MASKB 23,35>		;EXEC BASE REGISTER
   >				;END OF IFN KLFLG

   IFN KCFLG,<

PGLCHE==:1B0			;LOAD CACHE ENABLE FROM BIT PGENCH
PGENCH==:1B1			;ENABLE CACHE IF BIT PGLCHE IS ON
PG20MD==:1B3			;TOPS-20 PAGING MODE
PGENPG==:1B4			;ENABLE PAGING
PGLTPE==:1B7			;LOAD TRAP ENABLE BIT FROM PGENTP
PGENTP==:1B8			;ENABLE TRAP PROCESSING
PGEBRM==:<MASKB 20,35>		;EXEC BASE REGISTER

;Bit 11 in WREBR will cause the microcode to trap if an XJRSTF is done in EXEC mode
;when PAB=CAB=0. This feature is temporary and will not ship with the monitor.

   >				;END OF IFN KCFLG

   IFN SMFLG,<

PGCLKE==:1B18			;CACHE LOOK ENABLE
PGCLDE==:1B19			;CACHE LOAD ENABLE

PGKLMD==:1B21			;KL20 PAGING MODE
PGTPEN==:1B22			;TRAP ENABLE
PGEBRM==:<MASKB 23,35>		;EXEC BASE REGISTER
   >				;END OF IFN SMFLG


	SUBTTL Data for WRCTX/RDCTX/RDUBR and DATAO/DATAI PAG

   IFN KLFLG,<
PGLACB==:1B0			;LOAD AC BLOCKS
PGLPCS==:1B1			;LOAD PCS
PGLUBR==:1B2			;LOAD UBR
PGCLKP==:1B3			;DO NOT CLEAR "KEPT" ENTRIES
PGCACB==:<MASKB 6,8>		;CURRENT AC BLOCK
PGPACB==:<MASKB 9,11>		;PREVIOUS AC BLOCK
PGNSAC==:1B18			;NO STORE ACCOUNTING REGISTERS
PGUBRM==:<MASKB 23,35>		;USER BASE REGISTER
MSKSTR PAGUBA,KIPGWD,PGUBRM

;MACRO TO SET PCS PER ADDRESS IN AC

DEFINE SETPCS (AC)<
	LOAD CX,VMADR,AC
	TXO CX,PGLPCS		;SAY LOAD PCS
	DATAO PAG,CX>		;DO IT
   >				;END OF IFN KLFLG

   IFN KCFLG,<
;Offset 0
WRCTFG==:0			;OFFSET FOR FLAGS
PGLACB==:1B0			;LOAD AC BLOCKS
PGLPCS==:1B1			;LOAD PCS
PGLUBR==:1B2			;LOAD UBR
PGCLKP==:1B3			;CLEAR PAGING RAM INCLUDING "KEPT" PAGES
PGNSAC==:1B4			;DON'T STORE ACCOUNTING REGISTERS
PGLVME==:1B5			;LOAD VMMODE ENABLE FROM BIT PGENVM
PGENVM==:1B6			;ENABLE VM MODE IF BIT PGLVME IS SET
PGINAB==:1B7			;INHIBIT ADDRESS BREAK ON NEXT INSTRUCTION
PGLABC==:1B8			;LOAD ADDRESS BREAK CONDITIONS FROM WORDS 2-4
PGLABE==:1B9			;LOAD ADDRESS BREAK FROM BIT PGENAB
PGENAB==:1B10			;ENABLE ADDRESS BREAK IF ON AND PGLABE IS ON
				;DISABLE ADDR BR IF OFF AND PGLABE IS ON
PGUBRM==:<MASKB 20,35>		;USER BASE REGISTER
MSKSTR PAGUBA,KIPGWD,PGUBRM	;WHERE TO STORE UPT ADDRESS FOR SWITCHING PROCESSES

;Offset 1
WRCTAC==:1			;OFFSET FOR AC BLOCKS AND PCS
PGCACB==:<MASKB 18,20>		;CURRENT AC BLOCK
PGPACB==:<MASKB 21,23>		;PREVIOUS AC BLOCK
PGPCS==:<MASKB 24,35>		;PREVIOUS CONTEXT SECTION

;Offset 2
WRCTAB==:2			;OFFSET FOR ADDRESS BREAK FLAGS
PGABPC==:1B10			;BREAK ON PC FETCH
PGABRD==:1B11			;BREAK ON READ
PGABWR==:1B12			;BREAK ON WRITE
PGAUSR==:1B13			;BREAK ON USER VIRTUAL REFERENCE
PGABCP==:1B14			;BREAK ON CPU REFERENCE
PGABPT==:1B15			;BREAK ON PORT REFERENCE
PGABPH==:1B16			;BREAK ON PHYSICAL REFERENCE
PGABIS==:1B17			;IGNORE SECTION (BREAK ON BITS 18-35)

;Offset 3
WRCTLO==:3			;OFFSET FOR LOWER BOUND BREAK ADDRESS
PGABLO==:<MASKB 6,35>		;LOWER BOUND FOR ADDRESS

;Offset 4
WRCTUP==:4			;OFFSET FOR UPPER BOUND ADDRESS
PGABHI==:<MASKB 6,35>		;UPPER BOUND FOR ADDRESS

;MACRO TO SET PCS PER ADDRESS IN AC

DEFINE SETPCS (AC)<
	PUSH P,P5
	PUSH P,P6
	LOAD P6,VSECNO,AC	;GET SECTION NUMBER
	MOVX P5,PGLPCS		;SET BIT FOR LOAD PCS
	WRCTX P5
	POP P,P6
	POP P,P5>

   >				;END OF IFN KCFLG


   IFN SMFLG,<
PGLACB==:1B0			;LOAD AC BLOCKS
PGLPCS==:1B1			;LOAD PCS
PGLUBR==:1B2			;LOAD UBR
PGCACB==:<MASKB 6,8>		;CURRENT AC BLOCK
PGPACB==:<MASKB 9,11>		;PREVIOUS AC BLOCK
PGNSAC==:1B18			;NO STORE ACCOUNTING REGISTERS
PGUBRM==:<MASKB 23,35>		;USER BASE REGISTER
MSKSTR PAGUBA,KIPGWD,PGUBRM

DEFINE SETPCS (AC)<>		;IRRELEVANT IF NO EXT ADR
   >				;END OF IFN SMFLG

	SUBTTL Paging Data

;IN CST0

   IFN KLFLG,<
AGEMSK==:<MASKB 0,8>		;AGE AND CODE FIELD
MSKSTR CSTAGE,@CST0X,AGEMSK
PSASM==:<FLD(770,AGEMSK)>	;MASK TO TEST FOR ASSIGNED PAGE
DEFSTR XGAGE,@CST0X,14,6	;AGE AT LAST XGC (LOW BITS ONLY)
MSKSTR CSWRB,@CST0X,<1B18>	;CST write bit
DEFSTR CFXRD,@CST0X,32,14	;FORK WHICH INITIATED READ
  CFXRM==:CFXRD			;MASK FOR FIELD IN HARDWARE
  CFXNUL==:.RTJST(CFXRD,CFXRD)	;NULL VALUE
PSTFLD==:<MASKB 33,34>		;MASK FOR SPECIAL PAGE STATE FIELD
MSKSTR CSTPST,@CST0X,PSTFLD	;SPECIAL PAGE STATE
CORMB==:1B35			;MODIFIED BIT IN CST0

CSTSAV==:XGAGE+PSTFLD+CORMB	;BITS TO PRESERVE (CST MASK)
   >				;END OF IFN KLFLG

   IFN KCFLG,<
AGEMSK==:<MASKB 0,8>		;AGE AND CODE FIELD
MSKSTR CSTAGE,@CST0X,AGEMSK
PSASM==:<FLD(770,AGEMSK)>	;MASK TO TEST FOR ASSIGNED PAGE
DEFSTR XGAGE,@CST0X,14,6	;AGE AT LAST XGC (LOW BITS ONLY)
DEFSTR CFXRD,@CST0X,31,17	;FORK WHICH INITIATED READ
  CFXRM==:CFXRD			;MASK FOR FIELD IN HARDWARE
  CFXNUL==:.RTJST(CFXRD,CFXRD)	;NULL VALUE
PSTFLD==:<MASKB 32,33>		;MASK FOR SPECIAL PAGE STATE FIELD
MSKSTR CSTPST,@CST0X,PSTFLD	;SPECIAL PAGE STATE
MSKSTR CSWRB,@CST0X,<1B34>	;CST write bit
CORMB==:1B35			;MODIFIED BIT IN CST0

   >				;END OF IFN KCFLG

;SPECIAL PAGE STATE CODES (CSTPST)

PSTAVL==.MCPSA			;AVAILABLE FOR RPLQ WHEN FREED
PSTSPM==.MCPSS			;PLACE ON SPMQ WHEN FREED
PSTOFL==.MCPSO			;OFFLINE - ACTION AS PSTSPM
PSTERR==.MCPSE			;OFFLINE DUE TO ERROR - ACTION AS PSTSPM

;PAGE STATE CODES (CSTAGE)

PSRPQ==:0			;ON REPLACABLE QUEUE
PSDEL==:1			;DELETED (ON DELETED QUEUE)
PSRDN==:2			;READ COMPLETED
PSIOP==:3			;IO PAGE (USUALLY ILLEGAL)
PSWIP==:4			;WRITE IN PROGRESS
PSRIP==:6			;READ IN PROGRESS
PSSPQ==:7			;PAGE ON SPECIAL MEMORY QUEUE
PSASN==:10			;PAGE ASSIGNED TO PROCESS IF .GE. PSASN

;AGE FIELD VALUES

LGATOP==1000			;LEGAL AGE "TOP"
LGABOT==100			;LEGAL AGE "BOTTOM"
AGEWRP==LGATOP-LGABOT		;WRAPAROUND OFFSET FOR AGE

;IN CST1

PLKV==:1B11			;PAGE LOCK VALUE IN CST1
PLKMSK==:<MASKB 0,11>		;LOCK COUNT FIELD
MSKSTR PLKCNT,@CST1X,PLKMSK

;IN CST3

DWRBIT==:1B0			;WRITE BIT IN CST3
SWPERR==:1B1			;SWAP ERROR BIT IN CST3
DSKSWB==:1B2			;SWAP TO DISK REQUESTED
DEFSTR CSTOFK,@CST3X,14,12	;OWNING FORK INDEX IN CST
DEFSTR CSTLDA,@CST3X,35,21	;LOCAL DISK ADDRESS FOR PHYSIO
OFNUL==:7777			;NULL VALUE FOR CSTOFK (NO OWNING FORK)

;IN TOP (OFN) PART OF SPTH

FILUB==:1B0			;'UNRESTRICTED' BIT (ASOFN CALL ONLY)
FILWB==:1B1			;'FILE WRITE' BIT IN SPTH AND ASOFN ARG
THAWB==:1B2			;'THAWED' BIT """
FILNB==:1B3			;'FILE NEW' BIT """
SPTLKB==:1B4			;LH OF SPTH(OFN), XB IN USE BY DDMP
OFNWRB==:1B5			;OFN HAS BEEN MODIFIED
 OFNDU0==:1B5			;used on call to ASGOFN only
OFNBAT==:1B6			;XB CONTAINS A BAD BLOCK
 OFNPTT==:1B6			;OFN IS PTT OF LONG FILE ASGOFN ONLY
OFNERR==:1B7			;ERROR IN FILE (E.G. MPE)
OFNDMO==:1B8			;THIS OFN IS ON A DISMOUNTED STRUCTURE
OFNDUD==:1B9			;THIS OFN NOT TO BE SWAPPED TO DISK
OFN2XB==:1B10			;[7247] Second level XB
OFNLAC==:1B11			;[7247] Lost access to this cached OFN

;[7247] Note: No more spare bits in SPTH

;IN SPT

DEFSTR (ALOCX,SPT,11,12)	;INDEX INTO ALLOCATION TABLES (OFN PART ONLY)
DEFSTR SPTSHC,SPT,11,12		;SHARE COUNT IN SPT ENTRY (BOTTOM PART ONLY)
USHR==:1B11			;ONE UNIT OF SHARE COUNT IN SPT
MAXSHC==:.RTJST(SPTSHC,SPTSHC)	;MAX SHARE COUNT VALUE
MAXSC0==:MAXSHC-1000		;MAX SHARE COUNT FOR NEW INDIRECT PTR

;IN SPTO

OFSHR==:1B17			;ONE UNIT OF OFN SHARE ENTRY
DEFSTR OFNSHC,SPTO,17,18	;SHARE COUNT FOR AN OFN
STX==:777777			;STRUCTURE INDEX IS RH OF SPTO
MSKSTR (STRX,SPTO,STX)		;DEFINE LOADABLE FIELD

;IN SPTO2

DEFSTR OFOPC,SPTO2,17,18	;COUNT OF NORMAL OPENS (NOT READ-UNRESTRICTED)
DEFSTR SPTFO,SPTO2,18,1		;Force out in progress
DEFSTR SPTCDO,SPTO2,19,1	;XB checksum already verifed
DEFSTR SPTSFD,SPTO2,20,1	;XB needs checksum done on next swap in
DEFSTR SPTDSF,SPTO2,21,1	;Need DDMP to verify the XB
DEFSTR SPTFR,SPTO2,23,2		;Signal from CFS to do force-out
 DEFSTR SPTSR,SPTO2,22,1	;sub-field of above
DEFSTR SPTNA,SPTO2,24,1		;If set, don't preallocate pages for this OFN
DEFSTR SPTMR,SPTO2,25,1		;Preallocation meter bit
DEFSTR OFNCSH,SPTO2,26,1	;[7247] OFN cached bit
DEFSTR OFNMGB,SPTO2,27,1	;[7247] Garbage collection pass 1 bit
DEFSTR SPTST,SPTO2,35,2		;OFN state (for CFS)
	.SPSRD==:1		;Read-only
	.SPSWR==:2		;Read/write

;Defs for SPTD word

DEFSTR SPTCT,,11,12		;Count field in this word
;TRAP STATUS (PAGE FAIL) WORD

;DEFS FOR OFN HASHING

DEFSTR OFNHS,OFNHST,35,18	;FIRST OFN IN TABLE OR 0 IF NONE
DEFSTR OFNNXT,OFNHSE,35,18	;LINK TO NEXT OFN OR 0 IF NONE
				;SAME DEF AS OFNHS IN OFNHSE TABLE
DEFSTR OFNPRV,OFNHSE,17,18	;PREVIOUS OFN IN THIS CHAIN OR PTR

   IFN KLFLG,<
TWUSR==:1B0			;USER MODE REFERENCE
TWHPFF==:1B1			;'HARD' FAILURE
TWCOD==:<MASKB 1,5>		;FAIL CODE IF HARD FAILURE
TWVALD==:1B2			;VALID TRANSLATION EXISTS (IF TWHPFF OFF)
TWWRT==:1B5			;WRITE REFERENCE (IF TWHPFF OFF)
TWKEEP==:1B8			;ENTRY WILL BE KEPT IN HARDWARE PAGE TABLE ON
				; PAGER CLEAR
TWVADR==:<MASKB 13,35>		;VIRTUAL ADDRESS
   >				;END OF IFN KLFLG

   IFN KCFLG,<
;Bits in page fail code word
;Bits 1,3,4,5 reflect information in the translation buffer for the
;entry to which this virtual address maps. If bit 10 is off, the data does
;not correspond to this virtual address.

TWHPFF==:1B0			;'HARD' FAILURE
				;BIT 1 - KEEP ME
TWUSR==:1B2			;USER MODE REFERENCE
				;BIT 3 - TRANSLATION BUFFER HAS A VALID ENTRY
				;BIT 4 - CST UPDATED NEEDED
				;BIT 5 - WRITABLE
TWWRT==:1B6			;WRITE REFERENCE
				;BIT 7 - ADDRESS BREAK
				;BIT 8 - WRITE FAILURE
TWPHY==:1B9			;PHYSICAL REFERENCE
				;BIT 10 - THIS VMA VALID IN TRANSLATION BUFFER
DEFSTR TWLEV,,20,3		;LEVEL AT WHICH REFILL STOPPED
LVPPTR==:3			;LEVEL NUMBER FOR PAGE POINTER
TWCOD==:<MASKB 21,35>		;FAIL CODE

;Hard page fail codes -- temporary because they aren't defined in hardware yet
PFCNXM==:20

;Virtual address in page fail VMA word
; * * * *
;TEMPORARILY SAME AS KL. PAGE FAULT HANDLER ASSUMES THAT VMA AND TWWRT DON'T
;OVERLAP. MUST BE FIXED WHEN WE SUPPORT FULL EXTENDED ADDRESSING
; * * * *

TWVADR==:<MASKB 13,35>		;VIRTUAL ADDRESS
;TWVADR==:<MASKB 6,35>		;VIRTUAL ADDRESS
   >				;END OF IFN KCFLG

;Fields in section map entries and page map entries

PTRCOD==:<MASKB 0,2>		;CODE FIELD IN PAGE POINTER
IMMCOD==:1			;IMMEDIATE POINTER
SHRCOD==:2			;SHARE POINTER
INDCOD==:3			;INDIRECT POINTER
   IFN KCFLG,<
KLPTR==:FLD(4,PTRCOD)		;SUPER SECTION POINTER FOR KL COMPATIBLE MODE
   >				;END OF IFN KCFLG

;Access bits

PTACB==:<MASKB 3,8>		;ACCESS BITS (BOTH HARDWARE AND SOFTWARE)

   IFN KLFLG,<
PTPUB==:1B3			;PUBLIC BIT
PTWR==:1B4			;WRITE ACCESS
PTKEEP==:1B5			;KEEP THIS PAGE IN HARDWARE PAGE TABLE
PTCACH==:1B6			;CACHE BIT
PTCPY==:1B7			;COPY-ON-WRITE (SOFTWARE ONLY)
PTSECM==:1B8			;SECTION IS MAPPED
PTLOK==:1B9			;PAGE IS LOCKED (IMMEDIATE PTR ONLY)
   >				;END OF IFN KLFLG

   IFN KCFLG,<
PTCPY==:1B3			;COPY-ON-WRITE (SOFTWARE ONLY)
PTWR==:1B4			;WRITE ACCESS
PTSECM==:1B5			;SECTION IS MAPPED (SOFTWARE ONLY)
PTLOK==:1B6			;PAGE IS LOCKED
PTKEEP==:1B7			;"KEEP ME" IN THE PAGER
   >				;END OF IFN KCFLG

;BITS IN MAP WORD

STGADM==:<MASKB 12,35>		;MASK FOR STORAGE ADDRESSES (IMMEDIATE POINTERS
				; OR SPT ENTRIES)
MSKSTR STGADR,,STGADM		;STORAGE ADDRESS FIELD IN PTR OR SPT
SPTM==:<MASKB 18,35>		;MASK FOR SPT INDICES
MSKSTR SPTX,,SPTM		;SPT INDEX IN SHARE OR INDIRECT PTR
DEFSTR IPPGN,,17,9		;WHERE TO FIND PAGE NUMBER IN INDIRECT POINTER

;Bits in a storage address that indicate the medium

NCORTM==:<MASKB 12,17>		;NOT-CORE TEST MASK IN STORAGE ADR
UAAB==:1B17			;UNASSIGNED BIT IN STORAGE ADR
UAACB==:1B17+1B35		;UNASSIGNED AND COPY
DRMAB==:2B17			;DRUM BIT IN STORAGE ADR
DRMOB==:1B17			;DRUM OVERFLOW (WITH DRMAB) IN STG ADR
DSKAB==:1B14			;DSK BIT IN STORAGE ADR
DSKNB==:1B15			;WITH DSKAB, NEWLY ASSIGNED ADDRESS

;VIRTUAL ADDRESSES

VMADR==:37777777		;VIRTUAL MEMORY ADDRESS
VPGNO==:37777000		;PAGE NUMBER
LPGNO==:777000			;LOCAL PAGE NUMBER (WITHIN SECTION)
VSECNO==:37B17			;SECTION NUMBER

;PHYSICAL CORE ADDRESS
PGWD==:777			;WORD WITHIN PAGE

   IFN KLFLG,<
PHCPNO==:<MASKB 14,26>		;PHYSICAL CORE PAGE NUMBER
   >				;END OF IFN KLFLG

   IFN KCFLG,<
PHCPNO==:<MASKB 11,26>		;PHYSICAL CORE PAGE NUMBER
   >				;END OF IFN KCFLG


;Bits for the MAP instruction. To test for valid translation, do the
;following:

REPEAT 0,<
	TXNN AC,MPHPFF		;HARD FAILURE?
	TXNN AC,MPVALD		;NO. IS TRANSLATION POSSIBLE?
	FAILURE
	SUCCESS
>				;END OF REPEAT 0

   IFN KCFLG,<
MPHPFF==:1B0			;'HARD' FAILURE
				;BIT 1 - KEEP ME
				;BIT 2 - UNDEFINED
MPVALD==:1B3			;TRANSLATION CAN BE MADE FOR THIS ADDRESS
				;BIT 4 - CST UPDATED NEEDED
				;BIT 5 - WRITABLE
				;BIT 6 - MODIFIED
				;BIT 7 - UNDEFINED
				;BIT 8 - SECOND "KEEP ME" BIT
MPUSER==:1B9			;USER ADDRESS
				;BIT 10 - THIS VMA VALID IN TRANSLATION BUFFER
   >				;END OF IFN KCFLG

	MAXIND==1000		;MAXIMUM INDIRECT POINTERS ALLOWED
				; BEFORE MONITOR GIVES UP


;Lower core locations used by BOOT and the monitor.

;AUTOMATIC RELOAD AND SWPMON LOAD STORAGE

BUTRXB==:151			;XB OF ROOT DIR ON SPECIFIED STR
BUTMUN==:152			;MAX. UNIT ON SPECIFIED STR
BUTDRT==:153			;LOGICAL/ PHYSICAL MAPPING OF SPEC STR
BUTCMD==:163			;ASCIZ MONITOR FILE NAME
BUTPGS==:202			;VBSTRT,,VBEND
BUTEPT==:203			;VBEPT
BUTPHY==:204			;# OF PAGES TO MAP,,# OF FIRST PHYSICAL PAGE
BUTVIR==:205			;VIRTUAL ADDRESS OF FIRST PAGE TO MAP
BOOTFL==:206			;0 - NORMAL BOOTSTRAP, +N - SPECIAL BOOT
BUTSTA==:207			;START ADDRESS FOR SWPMON LOAD
;The previous definitions are pertinent only when loading old monitors.
;(I.E., doing a 2-pass load of monitor)

;These definitions are for the single-pass loading of V6 and later monitors
BUTCOD==:200			;Contains unique code to identify this .EXE
				; file as a TOPS-20 monitor
  BTCOD==:707707,,707077	;The code
BUTLEN==:201			;Length of BOOT communications area
				; including this word
BUTFLG==:202			;Flags passed to BOOT
BUTLLM==:203			;Lower limit of BOOT load interval
BUTULM==:204			;Upper limit of BOOT load interval
BUTERR==:205			;Last BOOT error
  BTLEN==:5			;Length of BOOT communications area

	SUBTTL Definitions for the KC

;Bit definitions for RINGB and RINGBW

   IFN KCFLG,<
CNBOT==:1B18			;Do console boot
CNPRT==:1B20			;Interrupt console

>				;END IFN KCFLG

	SUBTTL Definitions for the KL

   IFN KLFLG,<
;FRONT END DEFINITIONS FOR THE KL-20 CONFIGURATION

;PROTOCOL DEVICE VECTOR OFFSETS

DTVSD==:0			;HERE IS STRING DATA
DTVACK==:1			;LINE BUFFER EMPTY (OR ACKNOWLEDGE)
DTVTLS==:2			;STATUS
DTVTLA==:3			;SET LINE ALLOCATION
DTVSER==:4			;RETURN SYSERR INFORMATION
DTVRLD==:5			;RELOAD ENTRY

;UNIVERSAL COMMUNICATIONS DEFINITIONS

KPALIV==:5			;OFFSET FOR KEEP ALIVE COUNTER

;INTERFACE TO DTEQ

DTBYTM==:1B18			;BIT TO FORCE BYTE MODE TO DTEQ

;THE FRONT END PSEUDO DEVICES

.FECTY==:1			;THE CTY ON THE DL11-C
.FEDL1==:2			;THE DL11C (OR E) ON THE MASTER -11
.FEDH1==:3			;THE DH11 LINES 1 TO WHATEVER
.FEDLS==:4			;THE DATA LINE SCANNER
.FELPT==:5			;THE LINE PRINTER
.FECDR==:6			;THE CARD READER
.FEFE==:10			;THE SOFTWARE FRONT END DEVICE

;THE FRONT END FUNCTION CODES

.DFLCI==1			;LINE COUNT IS
.DFHSD==:3			;HERE IS STRING DATA
.DFHLC==:4			;HERE ARE LINE CHARACTERS
.DFRDS==:5			;REQUEST DEVICE STATUS
.DFSDO==:6			;SPECIAL DEVICE OPERATION
	.DFLPC==1		;LOAD PAGE COUNTER
.DFSTS==:7			;HERE IS DEVICE STATUS
.DFESD==:10			;ERROR ON DEVICE
.DFRTD==:11			;REQUEST TIME OF DAY
.DFHTD==:12			;HERE IS TIME OF DAY
.DFFDO==:13			;FLUSH OUTPUT (SENT TO 11 ONLY)
.DFSTA==:14			;SEND TO ALL (SENT TO 11 ONLY)
.DFLDU==:15			;A LINE DIALED UP (FROM 11 ONLY)
.DFLHU==:16			;A LINE HUNG UP OR LOGGED OUT
.DFLBE==:17			;LINE BUFFER BECAME EMPTY
.DFXOF==:20			;XOF COMMAND TO THE FE
.DFXON==:21			;XON COMMAND TO THE FE
.DFSPD==:22			;SET TTY LINE SPEED
.DFHLA==:23			;HERE IS LINE ALLOCATION
.DFHRW==:24			;HERE IS -11 RELOAD WORD
.DFACK==:25			;GO ACK ALL DEVICES AND UNITS
.DFTOL==:26			;TURN OFF/ON LINE
	.DFTLO==:0		;TURN IT OFF
	.DFTOO==:1		;TURN IT ON
.DFEDR==:27			;ENABLE/DISABLE DATASETS
.DFLTR==:30			;LOAD TRANSLATION RAM
.DFLVF==:31			;LOAD VFU
.DFMSG==:32			;SUPPRESS SYSTEM MESSAGES TO TTY
.DFKLS==:33			;SEND KLINIK DATA TO THE -11
.DFXEN==:34			;ENABLE XON (SENT TO 11 ONLY)
.DFBKW==:35			;BREAK-THROUGH WRITE
.DFDBN==:36			;DEBUG MODE ON
.DFDBF==:37			;DEBUG MODE OFF

;DEFINE THE DTE DEVICES

DTE0==:200
DTE1==:204
DTE2==:210
DTE3==:214

;UNIVERSAL COMM REGION DEFINITIONS

COMRGN==:^D8			;SIZE OF A "TO" PROCESSOR BLOCK
COMDAT==:^D16			;SIZE OF OWNING PROCESSOR BLOCK

   REPEAT 0,<			;DEFS ARE NOW IN NSPSRV
;DEFINITIONS FOR MCB MESSAGES

MSHDR==:4			;SIZE OF MESSAGE HEADER
DEFSTR (MSLNK,0,35,36)	;LINK WORD
DEFSTR (MSDTE,1,2,3)		;DTE # OR ALL ONES FOR LOCAL CONNECITON
DEFSTR (MSSEG,1,17,12)		;SEG # OF MESSAGE
DEFSTR (MSLLA,1,33,16)		;LL ADDRESS
DEFSTR (MSTOM,1,35,2)		;TYPE OF THIS MESSAGE
	MSCTL==0		;CONTROL MESSAGE
	MSLSI==1		;LS/INT MESSAGE
	MSDAT==2		;DATA MESSAGE
DEFSTR (MSCNT,2,35,12)		;# OF BYTES IN MESSAGE
DEFSTR (MSDTC,2,23,12)		;# OF BYTES EXCLUDING NSP OVERHEAD BYTES
DEFSTR (MSMFL,2,11,12)		;MESSAGE FLAGS
MSBPTR==3			;BYTE POINTER TO DATA PART OF MESSAGE
   >				;END OF REPEAT 0

;DTE CONI/CONO BIT DEFINITIONS

DTEPRV==:1B20			;RESTRICTED/PRIVILEGED BIT
DTEPF==:1B21			;POWER FAIL IN -11
DTEEDB==:1B22			;TO -11 DOORBELL
DTECER==:1B23			;CLEAR -11 RELOAD BUTTON
DTESER==:1B24			;THE ELECTRONIC FINGER
DTETDB==:1B26			;TO -10 DOORBELL
DTEEER==:1B27			;TO -11 ERROR
DTEEDN==:1B29			;TO -11 DONE
DTETDN==:1B30			;TO -10 DONE
DTETER==:1B31			;TO -10 ERROR
DTEPIE==:1B31			;ENABLE PI'S
DTEPI0==:1B32			;ENABLE PI 0

;MONITOR PROTOCOL COMMANDS

DTEEMP==:11B27			;ENTER MONITOR PROTOCOL
DTEEPP==:12B27			;ENTER PRIMARY PROTOCOL
DTEMNO==:4000			;OUTPUT CHARACTER
   >				;END OF IFN KLFLG

	SUBTTL Definitions for the KS

IFN SMFLG,<

; EXTERNAL PAGE DEFINITIONS FOR UNIBUS ADAPTER

UBAEXP==:1763000		;ADDRESS OF UNIBUS ADAPTER (FIRST ADDRESS)
UB1EXP==:3763000		;ADDRESS OF UNIBUS ADAPTER (SECOND ADDRESS)
UB4EXP==:4763000		;UBA 4 (**NOT SHIPPED)
UNBSTW==:763100			;BASIC UNIBUS STATUS REGISTER ADDRESS (MINUS UNIT NUMBER)
UNBSTS==:100			;ADDRESS OF STATUS WORD (FIRST UNIBUS ADAPTER)

; BIT DEFINITIONS FOR STATUS WORD
UNBTMO==:1B18			;NON EX DEVICE (TIMEOUT)
UNBBME==:1B19			;BAD MEMORY
UNBBPE==:1B20			;SM10 BUS PARITY
UNBNED==:1B21			;NON EX CPU DEVICE
UNBACL==:1B26			;AC OR DC LOW (POWER FAIL ON UNIBUS)
UNBENI==:1B27			;ENABLE INTERNAL INTERRUPT
UNBDTR==:1B28			;DISABLE TRANSFER ON UNCORRECTABLE DATA
UBINIT==:1B29			;UNIBUS INIT

UBAMUL==:4000			;MULTIPLIER FOR UNIBUS ADDRESSES / PAGE RAM
UBAPGS==:100			;NUMBER OF MAPPING REGISTERS
MXUBWN==:100			;MAX MAPPING REGISTER
MXSMCH==:3			;MAX UNIBUS ADAPTER (ONLY ONE LEGAL FOR NOW)
UNBPAR=100000			;UNIBUS ADAPT PARITY BIT
UNBRPW==:400000			;READ/PAUSE/WRITE
UNBD18==:200000			;DISABLE 18 BIT MODE TRANSFER (16 BIT TRANSFERS)
UNB36B==:100000			;36 BIT MODE TRANSFERS
UNBVBT==:40000			;VALID TRANSFER BIT

;PHYSICAL CORE DEFINITIONS FOR SM10 CTY AND KLINIK SERVICE
; AND PHYSICAL CORE LOCATIONS FOR OTHER FRONT-END FUNCTIONS

TIMWD1==:27
RLWORD==:31			;RELOAD WORD
DEFSTR KSRLD,RLWORD,4,1		;RELOAD REQUEST
DEFSTR KPACT,RLWORD,5,1		;KEEP ALIVE ACTIVE
DEFSTR KLACT,RLWORD,6,1		;KLINIK ACTIVE
DEFSTR PAREN,RLWORD,7,1		;PARITY ERROR DETECT ENABLED
DEFSTR CRMPAR,RLWORD,8,1	;CRAM PAR ERR DETECT ENABLED
DEFSTR DRMPAR,RLWORD,9,1	;DRAM PAR ERR DETECT ENABLED
DEFSTR CASHEN,RLWORD,10,1	;CACHE ENABLED
DEFSTR MILSEN,RLWORD,11,1	;1MSEC ENABLED
DEFSTR KPALIV,RLWORD,28,8	;KEEP ALIVE WORD
DEFSTR PWRFAL,RLWORD,33,1	;POWER FAIL
DEFSTR FORREL,RLWORD,34,1	;FORCED RELOAD
DEFSTR KEPFAL,RLWORD,35,1	;KEEP ALIVE FAILURE


CTYIWD==:32			;CTY INPUT WORD
DEFSTR CTYICH,CTYIWD,35,8	;CTY INPUT CHARACTER
DEFSTR CTYIVL,CTYIWD,27,1	;INPUT VALID BIT

CTYOWD=33			;CTY OUTPUT WORD
DEFSTR CTYOCH,CTYOWD,35,8	;CTY OUTPUT CHARACTER
DEFSTR CTYOVL,CTYOWD,27,1	;OUTPUT VALID FLAG

KLIIWD==:34			;KLINIK INPUT WORD
DEFSTR KLIICH,KLIIWD,35,8	;KLINIK INPUT CHARACTER
DEFSTR KLIIVL,KLIIWD,27,1	;KLINIK INPUT VALID
KLICHR==:1B27			;KLINIK CHARACTER
KLIINI==:2B27			;KLINIK INITED
KLICAR==:3B27			;CARRIER LOST


KLIOWD==:35			;KLINIK OUTPUT WORD
DEFSTR KLIOCH,KLIOWD,35,8	;KLINIK OUTPUT CHARACTER
DEFSTR KLIOVL,KLIOWD,27,1	;KLINIK OUTPUT VALID
KLOCHR==:1B27			;KLINIK CHARACTER AVAILABLE
KLIHUP==:2B27			;KLINIK HANGUP REQUEST

; DZ11 DEFINITIONS

DZUBAD==:3763000		;ADDRESS OF UNIBUS ADAPTER
DZ110V==:340			;INTERRUPT VECTOR ADDRESS FOR FIRST DZ11
DZ11BA==:3760010		;BASE ADDRESS FOR FIRST DZ11
DZUBN==:3			;UNIBUS ADAPTER NUMBER FOR DZ33'S
DZMNV==:10			;SIZE OF EXTERNAL PAGE ADDRESSES
DZMAX==:4			;MAX NUMBER OF DZ11'S THAT ARE LEGAL

DZCTLN==:1			;CTY LINE NUMBER FOR CTYTCR

;CSR BIT DEFINITIONS

DZTRDY==:1B20			;TRANSMIT READY
DZTIEN==:1B21			;TRANSMIT INTERRUPT ENABLE
DZSILO==:1B22			;SILO ALARM
DZSIEN==:1B23			;SILO ALARM ENABLE
DZTXLN==:7B27			;TRANSMIT LINE NUMBER
DZRRDY==:1B28			;RECEIVE READY
DZRIEN==:1B29			;RECIEVE INTERRUPT ENABLE
DZMSCN==:1B30			;MASTER SCAN ENABLE
DZCLR==:1B31			;CLEAR (RESET)

;RECEIVER BUFFER DEFINITIONS

DZRDVL==:1B20			;DATA VALID
DZROVR==:1B21			;OVER RUN
DZRFRM==:1B22			;FRAME ERROR
DZRPAR==:1B23			;PARITY ERROR
DZRLIN==:7B27			;LINE NUMBER

;LINE PARAMETER DEFINITIONS

DZ1RXO==:1B23			;RECEIVE ON
DZ1FRQ==:4B27			;LINE FREQUENCY
DZ1OPA==:1B28			;ODD PARITY
DZ1PEN==:1B29			;PARITY ENABLE
DZ1STP==:0			;STOPCODE
DZ2STP==:1B30			;STOPCODE 2 BITS
DZ1CHL==:3B32			;CHARACTER LENGTH
   DZ8BIT==:30			;8BIT CHARACTER DEFINITION
DZ1LNO==:7B35			;LINE NUMBER

;DZ11 OFFSET INTO DEVICE DEFINITIONS

DZCSR==:0			;CONTROL AND STATUS
DZRBUF==:2			;RECEIVER BUFFER
DZLPR==:2			;LINE PARAMETER REGISTER
DZTCR==:4			;TRANSMIT CONTROL
DZDTR==:5			;DATA TERM READY FLAGS (HIGH BYTE OF TCR
DZRNG==:6			;RING INDICATOR
DZCAR==:7			;CARRIER
DZTBUF==:6			;TRANSMITTER BUFFER
DZBRK==:7			;BREAK (HIGH OF TBUF)


;KMC11 DEFINITIONS

	KMCADR==:3760540	;ADDRESS OF KMC11
	KMCUBN==:3		;UNIBUS NUMBER TO USE FOR KMC11
	KMCVEC==:000540		;VECTOR OF KMC11


;RH11 DEFINITIONS

RH11CA==:1776700		;FIRST ADDRESS OF RH11
RH21CA==:3772440		;SECOND RH11
RH11IV==:254			;INTERRUPT VECTOR ADDRESS
RH21IV==:224			;INTERRUPT VECTOR ADDRESS OF 2ND RH

RH11UB==:1			;UNIBUS NUMBER FOR FIRST RH11
RH21UB==:3			;UNIBUS NUMBER FOR SECOND RH11

;

;LP20 DEFINITIONS

LPTUBN==:3			;UNIBUS NUMBER TO USE FOR LINEPRINTER
LP11CA==:3775400		;EXTERNAL PAGE ADDRESS OF FIRST LP20
LP11IV==:754
LPEXPE==:20			;SIZE OF EXTERNAL PAGE ADDRESSES


; OFFSETS INTO THE EXTERNAL PAGE REGISTERS

LPCSRA==:0			;CONTROL AND STATUS REGISTER A
LPCSRB==:2			;CONTROL AND STATUS REGISTER B
LPBSAD==:4			;BUS ADDRESS REGISTER (CURRENT ADDRESS)
LPBCTR==:6			;BYTE COUNT REGISTER (2'S COMPLEMENT)
LPPCTR==:10			;PAGE COUNTER
LPRAMD==:12			;RAM DATA REGISTER
LPCBUF==:14			;(BYTE) CHARACTER BUFFER REGISTER
LPCCTR==:15			;(BYTE) COLUMN COUNT REGISTER
LPTDAT==:16			;(BYTE) PRINTER DATA REGISTER
LPCKSM==:17			;(BYTE) CHECKSUM REGISTER

;WORD BIT DEFINITIONS IN LPCSRA

LPWDON==:000200			;LP DONE
LPWIEN==:000100			;LP INTERRUPT ENABLE
LPWA17==:40			;B17 OF PDP-11 ADDRESS (EXTENDED)
LPWA16==:20			;B16
LPWDVU==:000010			;LOAD DAVFU
LPWTM==:000004			;TEST MODE
LPWPEN==:000002			;PARITY ENABLE
LPWGO==:000001			;GO
LPWERR==:<200>B<35-8>		;ERROR (COMPOSITE)
LPWPZR==:<100>B<35-8>		;PAGE COUNTER REACHED 0
LPWCI==:<40>B<35-8>		;UNDEFINED CHARACTER INTERRUPT
LPWDR==:<20>B<35-8>		;DAVFU READY
LPWOL==:<10>B<35-8>		;ON LINE
LPWDH==:<4>B<35-8>		;DELIMITER HOLD
LPWRSE==:<2>B<35-8>		;RESET ERROR
LPWINT==:<1>B<35-8>		;LP INITIALIZE


;BYTE BIT DEFINITIONS IN LPCSRA

LP1DON==:000200			;LP DONE
LP1IEN==:000100			;LP INTERRUPT ENABLE
LP1A17==:40			;B17 OF PDP-11 ADDRESS (EXTENDED)
LP1A16==:20			;B16
LP1DVU==:000010			;LOAD DAVFU
LP1TM==:000004			;TEST MODE
LP1PEN==:000002			;PARITY ENABLE
LP1GO==:000001			;GO

;BYTE BIT DEFINITIONS IN LPCSRA+1 (-11 LPCSRA BITS 15,14,13,12,11,10,9,8)

LP1ERR==:200			;ERROR (COMPOSITE)
LP1PZR==:100			;PAGE COUNTER REACHED 0
LP1CI==:40			;UNDEFINED CHARACTER INTERRUPT
LP1DR==:20			;DAVFU READY
LP1OL==:10			;ON LINE
LP1DH==:4			;DELIMITER HOLD
LP1RSE==:2			;RESET ERROR
LP1INT==:1			;LP INITIALIZE

;WORD LPCSRB BIT DEFINITIONS

LPWOFL==:000200			;OFF LINE
LPWDVN==:000100			;DAVFU NOT READY
LPWPER==:000040			;LINE PRINTER PARITY ERROR
LPWMPE==:000020			;MEMORY PARITY ERROR
LPWRPE==:000010			;RAM PARITY ERROR
LPWSYE==:000004			;MASTER SYNC ERROR
LPWDME==:000002			;DEMAND TIME-OUT ERROR
LPWGOE==:000001			;GO ERROR
LPWVDT==:200B<35-8>		;VALID DATA
LPWPNR==:40B<35-8>		;PRINTER NOT READY
LPWDPE==:20B<35-8>		;LINE PRINTER DATA PARITY ERROR
LPWOVF==:10B<35-8>		;OPTICAL VFU

;BYTE LPCSRB BIT DEFINITIONS

LP1OFL==:000200			;OFF LINE
LP1DVN==:000100			;DAVFU NOT READY
LP1PER==:000040			;LINE PRINTER PARITY ERROR
LP1MPE==:000020			;MEMORY PARITY ERROR
LP1RPE==:000010			;RAM PARITY ERROR
LP1SYE==:000004			;MASTER SYNC ERROR
LP1DME==:000002			;DEMAND TIME-OUT ERROR
LP1GOE==:000001			;GO ERROR

;BYTE LPCSRB+1 BIT DEFS

LP1VDT==:200			;VALID DATA
LP1PNR==:40			;PRINTER NOT READY
LP1DPE==:20			;LINE PRINTER DATA PARITY ERROR
LP1OVF==:10			;OPTICAL VFU

;
;DEFINITIONS FOR THE CD11
;
CD11BA==:3777160		;BASE ADDRESS
CDRIVT==:230/4			;INTERRUPT VECTOR LOCATION
CDST==:0			;STATUS AND CONTROL REGISTER
CDCC==:2			;COLUMN COUNT REGISTER
CDBA==:4			;BASE ADDRESS
CDDB==:6			;DATA BUFFER REGISTER


;STATUS REGISTER DEFINITIONS

CDERR1==:100000			;ERROR
CDRDK==:040000			;READER CHCK
CREOF==:020000			;END OF FILE
CDOFL==:010000			;OFF LINE
CDDER==:004000			;DATA ERROR
CDDLT==:002000			;DATA LATE
CDNXM==:001000			;NONEX MEM
CDPWR==:000400			;POWER CLEAR
CDRDY==:000200			;READY
CDIEN==:000100			;INTERRUPT ENABLE
CDTOL==:000010			;TRANSITION TO ON LINE
CDHCK==:000004			;HOPPER CHECK
CDDPK==:000002			;DATA PACKING
CDRED==:000001			;READ

;DEFINITIONS FOR CDDB
CDBRCK==:040000			;READ (PHOTO CHECK)
CDBPCK==:020000			;PICK CHECK
CDBSCK==:010000			;STACK CHECK


>		;END IFN KSFLG
	SUBTTL

;GENERAL PARAMETERS AND MACROS

SECSIZ==:1000000		;SECTION SIZE
PGSIZ==:1000			;PAGE SIZE
PGSFT==:^D9			;SHIFT FOR PAGE/ADDRESS CONVERSION

; GTJFN FIELD LENGTHS

MAXLC==:^D39
MAXLW==:8
MAXSHT==:6			; MAX CHARACTERS IF G1%NLN IS ON
MAXEXT==:3			; MAX CHARACTERS IN EXTENSION


NUACB==:120			;NUMBER WORDS FOR AC STACK
NTERMI==:^D36			;NUMBER OF TERMINAL INTERRUPTS
NPILEV==:3			;NUMBER OF PSEUDO-INTERRUPT LEVELS

GSOPDEF ADJBP,<IBP>	;ADJBP = IBP WITH AC FIELD

;AC DEFINITIONS
;THESE ARE USED EXCLUSIVELY UNLESS SPECIFICALLY REDEFINED AT
;THE BEGINNING OF A MODULE

P=:17				;UNIVERSAL STACK
CX=:16				;CALL/RETURN TEMPORARY
 .SAC==:16			;SCRATCH - USED BY MACSYM MACROS
F=:0				;GENERAL FLAG REGISTER - PRESERVED

T1=:1				;GENERAL TEMPORARY
T2=:2
T3=:3
T4=:4
Q1=:5				;SECOND SET OF PRESERVED
Q2=:6
Q3=:7
P1=:10				;PRESERVED AC'S (NOT UNIVERSALLY OBSERVED NOW)
P2=:11
P3=:12
P4=:13
P5=:14
P6=:15
A==:1				;ALTERNATE DEFINITION FOR TEMPORARIES
B==:2				; FOR COMPATIBILITY WITH OLD CONVENTION UNTIL CHANGED
C==:3
D==:4

NSAC==:15			;HIGHEST PRESERVED AC

;IF AN ALTERNATE DEFINITION FOR AN AC IS USED IN A MODULE, THE
;FOLLOWING MACRO MUST BE USED TO DEFINE IT.  THE NEW DEFINITION
;MUST BE MADE IN TERMS OF ONE OF THE GLOBAL DEFINITIONS ABOVE.  THE
;DEFINITION PROCESS PURGES THE OLD NAME THUS PREVENTING MULTIPLE
;NAMES FOR ONE AC.

DEFINE DEFAC (NEW,OLD)<
   IF1,<
	IFG OLD-15,<PRINTX ?**INVALID REDEFINITION OF AC OLD**>
	IFL OLD-1,<PRINTX ?**INVALID REDEFINITION OF AC OLD**>
	NEW=OLD
	PURGE OLD,OLD
	DEFINE OLD<%'OLD'%>>>

;OPDEFS

GOPDEF JSYS,<104B8>

;CALLING CONVENTIONS FOR LOCAL SUBROUTINES.
; SUBROUTINES ARE CALLED WITH 'CALL' WHICH IS A PSEUDONUM FOR PUSHJ P,.
; RETURN +1 IS EFFECTED BY 'RET' WHICH IS A PSEUDONUM FOR POPJ P,.
; RETURN +2 IS EFFECTED BY 'RETSKP' WHICH IS A JRST TO AN AOS, RET.

GOPDEF CALL,<PUSHJ P,0>
GOPDEF RET,<POPJ P,0>

DEFINE RETSKP <JRST RSKP>

;'CALLRET' IS AN ABBREVIATION FOR THE COMMON SEQUENCE
;	CALL ...
;	RET
;	RETSKP		;(OPTIONALLY)
;CODE WHICH USES 'CALLRET' MAY NOT ASSUME THAT IT ASSEMBLES INTO
;A SINGLE INSTRUCTION, I.E. THAT IT MAY BE SKIPPED OVER.

GSOPDEF CALLRET,<JRST>

;DECLARE LIST OF SYMBOLS EXTERNAL. (EQUIVALENT TO EXTERN BUT
;USES ANGLEBRACKET FORMAT LIKE OTHER IRP MACROS)

DEFINE EXTN (SYMS)<
	IRP SYMS,<
	EXTERN SYMS>>

;FACILITY TO SAVE ALL ACS, OR P1-P4, OR Q1-Q3, OR Q1-Q3 AND P1-P6
;PUTS DUMMY RETURN ON STACK FOR AUTOMATIC RESTORE ON RETURN

DEFINE ACSAV <JSP CX,ACSAV0>
DEFINE SAVEP <JSP CX,SAVP>
DEFINE SAVEQ <JSP CX,SAVQ>
DEFINE SAVEPQ <JSP CX,SAVPQ>
DEFINE SAVET <JSP CX,SAVT>


;This macro is used by SAVEAC in MACSYM to identify the common
;routines available for various sets of ACs to save.  These routines
;are defined in APRSRV for all monitor modules.

DEFINE USRSAV,<

;;	      Routine,AC List

	SPCSAV(.SAV11,<1>)
	SPCSAV(.SAV22,<2>)
	SPCSAV(.SAV33,<3>)
	SPCSAV(.SAV44,<4>)
	SPCSAV(.SAV12,<1,2>)
	SPCSAV(.SAV13,<1,2,3>)
	SPCSAV(.SAV34,<3,4>)
	SPCSAV(.SAV24,<2,3,4>)
	SPCSAV(SAVT,<1,2,3,4>)
	SPCSAV(.SAV1,<5>)
	SPCSAV(.SAV2,<5,6>)
	SPCSAV(.SAV3,<5,6,7>)
	SPCSAV(.SAV4,<5,6,7,<^D8>>)
	SPCSAV(SAVP,<<^D8>,<^D9>,<^D10>,<^D11>,<^D12>,<^D13>>)
	SPCSAV(SAVPQ,<5,6,7,<^D8>,<^D9>,<^D10>,<^D11>,<^D12>,<^D13>>)
	SPCSAV(.SAVP1,<<^D8>>)
>;END OF DEFINE USRSAV
;SYMBOLS FOR REFERRING TO FLAGS AND/OR PC ON THE STACK

STKPC.==:<Z 0>		;NORMAL CALL, USED AS MOVE T1,STKPC.(P)

JSYFL.==:<Z 0>		;JSYS CONTEXT, USED AS MOVE T1,JSYFL.(P)
JSYPC.==:<Z -1>		;JSYS CONTEXT, USED AS MOVE T1,JSYPC.(P)

;THE FOLLOWING OPCODES ARE USED TO REFERENCE DATA IN THE 'PREVIOUS
;CONTEXT'.  THE PREVIOUS CONTEXT IS THE USER ADDRESS SPACE IF
;THE JSYS CALL WAS EXECUTED BY A USER PROGRAM, OR THE
;MONITOR ADDRESS SPACE IF IT WAS EXECUTED BY THE MONITOR.
;WHEN WRITING JSYS CODE HOWEVER, IT IS CONVENIENT TO THINK OF THE
;CURRENT CONTEXT AS 'MONITOR' AND THE PREVIOUS CONTEXT AS
;'USER'.  THESE TERMS SHOULD BE UNDERSTOOD IN THIS WAY IN THE
;FOLLOWING DISCUSSION AND IN THE OPDEF'S.

;Single-address instructions like MOVE and MOVEM:

;XCTU IS THE GENERAL CASE AND IS USED FOR ALL ORDINARY (ONE-ADDRESS)
;INSTRUCTIONS.
;XCTUU IS USED TO BOTH COMPUTE EFFECTIVE ADDRS IN USER AND FETCH
;FROM USER, I.E. - XCTUU [MOVE T1,@T1] INDIRECTS THROUGH USER'S AC

GOPDEF XCTU,<XCT 4,0>		;DATA ONLY IS IN PREVIOUS CONTEXT
GOPDEF XCTUU,<XCT 14,0>		;"E" AND DATA FROM PREV. CONTEXT

;'UMOVEX' IS A GROUP OF INSTRUCTIONS LIKE 'MOVEX' WHERE THE DATA
;REFERENCE IS FORCED TO 'USER' SPACE.  THEY ARE DEFINED IN TERMS
;OF 'XCTXX'. ON THE KC, THESE ARE INSTRUCTIONS.

  IFN KLFLG!SMFLG,<

 DEFINE UMOVE (A,L)<
	XCTU [MOVE A,L]>	;GET DATA FROM USER

 DEFINE UMOVEM (A,L)<
	XCTU [MOVEM A,L]>	;STORE DATA IN USER
  >

;UMOVEI AND UMOVES ARE NOT DEFINED.
	;..

;BLT:

	;..
;XBLTMU and XBLTUM have been replaced by the macros LDPAC. and STPAC.
;This reflects the restrictions in the KC on user-to-monitor and
;monitor-to-user BLT. XLBTUU is used for user-to-user BLT.

;The following macros copy data from the monitor's memory to previous context
;AC's. A special instruction on the KC provides this function. It does not
;require the AC argument. This macro copies all 16 AC's.

;NOTE: On the KL, a microcode bug causes PCS to be applied to E, even though E
;is a monitor address!!!

   IFN KLFLG,<
	DEFINE LDPAC.(AC,E),<
	MOVSI AC,E		;AC/ (MONITOR START ADDRESS,,USER AC 0)
	XCT 4,[BLT AC,17]	;COPY FROM MONITOR MEMORY TO USER AC'S
	  >
   >

   IFN KCFLG,<
	DEFINE LDPAC.(AC,E),<
	LDPAC 17,E>		;COPY FROM MONITOR MEMORY TO USER AC'S
   >

;The following macros copy data from previous context AC's to the monitor's
;memory. A special instruction on the KC provides this function. It does not
;require the AC argument. This macro copies all 16 AC's.

;NOTE: On the KL, a microcode bug causes PCS to be applied to E, even though E
;is a monitor address!!!

   IFN KLFLG,<
	DEFINE STPAC.(AC,E),<
	MOVEI AC,E		;AC/ (USER AC 0,,MONITOR START ADDRESS)
	XCT 1,[BLT AC,17+E]>	;COPY FROM USER AC'S TO MONITOR MEMORY
   >

   IFN KCFLG,<
	DEFINE STPAC.(AC,E),<
	STPAC 17,E>		;COPY FROM USER AC'S TO MONITOR MEMORY
   >

GOPDEF XBLTUU,<XCT 5,0>		;DATA FROM AND TO PREVIOUS CONTEXT
;TEMPORARY *****************

GOPDEF XBLTMU,<XCT 4,0>		;DATA FROM PREVIOUS CONTEXT
GOPDEF XBLTUM,<XCT 1,0>		;DATA TO PREVIOUS CONTEXT
	;..

;Byte instructions:

	;..
;XCTBU IS USED WITH BYTE INSTRUCTIONS WHERE POINTER IS IN MONITOR,
;DATA IN USER.  XCTBUU IS BYTE INSTRUCTION WITH POINTER AND DATA
;IN USER.

;The following table shows which operations are performed in previous/user
;context (indicated by "U") and which are performed in current/monitor
;context (indicated by "M").

;				      XCT 1  XCT 3   XCT 7   XCT 17
;Compute address of byte pointer	M	M	M	U
;Fetch byte pointer			M	M	U	U
;Compute address of byte		M	U	U	U
;Fetch byte				U	U	U	U

GOPDEF XCTBMU,<XCT 1,0>		;DATA IN PREVIOUS CONTEXT
GOPDEF XCTBU,<XCT 3,0>		;POINTER EA, DATA IN PREVIOUS
GOPDEF XCTBUU,<XCT 7,0>		;POINTER,POINTER E AND DATA IN PREVIOUS

;XPSHUM AND XPOPMU ARE THE ONLY CASES OF PUSH AND POP CURRENTLY USED.
;XPSHUM MEANS PUSH USER-TO-MONITOR, XPOPMU MEANS POP MONITOR-TO-USER, ETC.

GSOPDEF XPSHUM,<XCT 4,0>	;STACK IN PREVIOUS CONTEXT
GSOPDEF XPOPMU,<XCT 4,0>	;STACK IN PREVIOUS CONTEXT


;THE FOLLOWING IS USED IN PLACE OF THE LOAD AND STOR MACROS WHEN
;PREVIOUS CONTEXT IS TO BE REFERENCED.  LOAD AND STORE CANNOT
;BE USED DIRECTLY UNDER XCTU BECAUSE THEY MAY ASSEMBLE BYTE
;INSTRUCTIONS WHICH REQUIRE DIFFERENT XCT BITS.

DEFINE ULOAD (AC,STR,Y)<
	..STR0 (..ULDB,AC,STR,Y)>

   DEFINE ..ULDB (AC,LOC,MSK)<
	..TSIZ (..PST,MSK)
	.CASE ..PST,<<
	  XCTU [MOVE AC,LOC]>,<
	  XCTU [HRRZ AC,LOC]>,<
	  XCTU [HLRZ AC,LOC]>,<
	  XCTBMU [LDB AC,[POINTR (LOC,MSK)]]>>>

DEFINE USTOR (AC,STR,Y)<
	..STR0 (..UDPB,AC,STR,Y)>

   DEFINE ..UDPB (AC,LOC,MSK)<
	..TSIZ (..PST,MSK)
	.CASE ..PST,<<
	  XCTU [MOVEM AC,LOC]>,<
	  XCTU [HRRM AC,LOC]>,<
	  XCTU [HRLM AC,LOC]>,<
	  XCTBMU [DPB AC,[POINTR (LOC,MSK)]]>>>

;THE FOLLOWING MACRO IS USED TO DEFINE FLAG BITS USING
;THE STRUCTURE FACILITY.  MSKSTR OR DEFSTR COULD BE USED DIRECTLY, THIS
;MACRO IS HERE FOR HISTORICAL REASONS.  THE FLAGS SO DEFINED
;ARE SET/TESTED WITH TQ??.

DEFINE FLG(FL,LR,REG,BIT)<
	IFIDN <LR><L>,<FL==<BIT>B17>
	IFIDN <LR><R>,<FL==BIT>
	MSKSTR (FL,REG,FL)>

;SAME AS ABOVE BUT MAKE FLAG GLOBAL

DEFINE GFLG(FL,LR,REG,BIT)<
	IFIDN <LR><L>,<FL==:<BIT>B17>
	IFIDN <LR><R>,<FL==:BIT>
	MSKSTR (FL,REG,FL)>

;RESIDENT STORAGE ALLOCATION MACRO

DEFINE RS (T,N)<
	.PSECT RSVAR
	IFB <N>,<
T::	BLOCK 1>
	IFNB <N>,<
T::	BLOCK N>
	.ENDPS RSVAR
>
  REPEAT 0,<

;RESIDENT STORAGE IN EXTENDED SECTION

DEFINE RSE (T,N)<
	.PSECT ERVAR
	IFB <N>,<
T::	BLOCK 1>
	IFNB <N>,<
T::	BLOCK N>
	.ENDPS ERVAR
>
  >

;RSI MACRO - THIS MACRO ALLOCATES STORAGE IN THE RSDAT PSECT, A RESIDENT,
;WRITE-ENABLED PSECT THAT IS NOT ZEROED AT SYSTEM STARTUP.
;ARGUMENTS ARE:
;	NAME - LABEL ASSOCIATED WITH THE FIRST LOCATION
;	LIST - A LIST OF THE INITIAL CONTENTS, ONE ENTRY PER WORD
;	TOTAL - TOTAL NUMBER OF WORDS ALLOCATED
;IF TOTAL IS NOT BLANK, IT MUST BE LARGE ENOUGH TO INCLUDE ALL WORDS
;IN THE LIST. IF TOTAL EXCEEDS THE NUMBER OF INITIAL VALUES, THE
;REMAINING SPACE IS ALLOCATED BUT NOT INITIALIZED.

DEFINE RSI (NAME,LIST,TOTAL),<
	.PSECT RSDAT
NAME::	IRP LIST,<
	LIST
	>
	IFNB <TOTAL>,<
	IFG <<TOTAL>-<.-NAME>>,<BLOCK <TOTAL>-<.-NAME>>
	IFG <.-NAME-<TOTAL>>,<IF2,<PRINTX %DEFINITION OF NAME EXCEEDS WORD COUNT
>>
	>			;END OF IFNB

	.ENDPS
>				;END OF RSI DEFINITION
;SWAPPABLE STORAGE

DEFINE NR (T,N)<
	.PSECT NRVAR
	IFB <N>,<
T::	BLOCK 1>
	IFNB <N>,<
T::	BLOCK N>
	.ENDPS NRVAR
>
  REPEAT 0,<

;SWAPPABLE STORAGE IN EXTENDED SECTION

DEFINE NRE (T,N)<
	.PSECT ENVAR
	IFB <N>,<
T::	BLOCK 1>
	IFNB <N>,<
T::	BLOCK N>
	.ENDPS ENVAR
>
  >

  REPEAT 0,<
;SWAPPABLE STORAGE ASSIGNED PAGE-AT-A-TIME

DEFINE NRP(T,N)<
	.PSECT NPVAR
	IFB <N>,<
T::	BLOCK PGSIZ>
	IFNB <N>,<
T::	BLOCK N>
	.ENDPS NPVAR
>
  >

  REPEAT 0,<
DEFINE NRPE(T,N)<
	.PSECT EPVAR
	IFB <N>,<
T::	BLOCK PGSIZ>
	IFNB <N>,<
T::	BLOCK N>
	.ENDPS EPVAR
>
  >

;SWAPPABLE, RESIDENT CODE

;Define symbol values that define the current psect (for MACRO and macros)

PRESCD==:1
PSWAPCD==:2
PXRESCD==:3
PXSWAPCD==:4

DEFINE SWAPCD<
	.ENDPS
	.PSECT NRCOD
	CURPSX==PSWAPCD
>

DEFINE RESDT,<
	.ENDPS
	.PSECT RSDAT
>

DEFINE RESCD($TYPE)<
	.ENDPS
	CURPSX==PRESCD
   IFB <$TYPE><
	.PSECT RSCOD
   >
   IFIDN <$TYPE><INIT><
	.PSECT INCOD
   >
   IFIDN <$TYPE><SEC0><
	.PSECT SZCOD
   >
>

;Assemble code in extended resident code
DEFINE XRESCD <
	.ENDPS
	.PSECT XRCOD
	CURPSX==PXRESCD
>

;Assemble code in extended swappable code
DEFINE XSWAPCD <
	.ENDPS
	.PSECT XNCOD
	CURPSX==PXSWAPCD
>

;PSEUDO-TITLE FOR ALL REGULAR MODULES


DEFINE TTITLE (TT,NN,XTT)<
	SALL
	.DIRECT FLBLST
OURTTL==SIXBIT /TT/		;;Remember module name for BUG macro
	TITLE TT'XTT
IFB <NN>,<ENTRY $'TT
	$'TT==:0>
IFNB <NN>,<ENTRY $'NN
	$'NN==:0>
	SEARCH MONSYM,MACSYM
	CPYRT			;;COPYRIGHT STATEMENT
	.XCMSY			;;XCREF JUNK SYMBOLS
	.PSECT RSCOD
	CURPSX==PRESCD
   IF2,<
	SEARCH GLOBS		;;PASS 2 ONLY FOR THIS
	GGLOBS			;;EXTERN ALL NEEDED SYMBOLS
	PURGE GGLOBS		;;GET RID OF BIG MACRO DEF
   >
	DEFINE TNXEND <
	XLIST
L'TT'....:	LIT
	LIST
>>

;MAKE SYMBOLS EXTERN IF NOT ALREADY DEFINED

DEFINE EXT (SYM)<
   IF2,<
	IRP SYM,<
	IFNDEF SYM,<EXTERN SYM
	SUPPRE SYM>>>>




;HANDLE THE CASE OF ERJMP TO NEXT INSTRUCTION WITHIN A LITERAL

DEFINE ERNOP. (%TAG),<
	ERJMP %TAG
%TAG:!
>



;PAGEM BITS

;IN DST

BWRBIT==:1B11			;WRITTEN (CHANGED) FROM HOME COPY IN DST


;FLAGS IN TRPDSP

TRPIRF==:1B0			;DO INTERRUPT REQUEST
TRPSTK==:1B1			;ADJUST STACK


; SECTION DEFINITIONS

BTMXSZ==077777			;SIZE OF EXTENDED BITMAPS

;IN ALLOCATION OFN TABLES

DEFSTR (ALCWD,ALOC1,35,36)	;ALLOCATION WORD
DEFSTR (ADIRN,ALOC1,17,18)	;DIRECTORY NUMBER (LH)
DEFSTR (ODIRC,ALOC1,35,18)	;OFN DIRECTORY COUNT
DEFSTR (PGLFT,ALOC2,35,36)	;COUNT OF PAGES LEFT (MAYBE NEG)
 DEFSTR (PGPTR,ALOC2,35,36)	;Field when CFS is used - points to
				; CFS data base entry
;IN OFNLEN TABLE

DEFSTR (OFNBSZ,OFNLEN,5,6)	;OFN FILE BYTE SIZE
DEFSTR (OFNBC,OFNLEN,35,30)	;OFN FILE BYTE COUNT



PTRW==:PM%RD+PM%WT		;NORMAL ACCESS, MONITOR CALL

;PC FLAGS

EXFLBT==:<MASKB 0,12>		;FLAGS BITS FOR ALL
FPD==:1B4			;FIRST PART DONE
UMODF==:1B5			;USER MODE FLAG
UIOF==:1B6			;USER IO MODE
PCU==:1B6			;PREVIOUS CONTEXT USER
IMCFLG==:1B14			;INTERNAL MONITOR CALL FLAG (X FIELD OF PC)
QUOTAB==:1B15			;PC "BACKED UP" BECAUSE OF OVER QUOTA
   IFN KCFLG,<
EXMBZ==:<MASKB 13,17>		;FLAG WORD BITS THAT MUST BE ZERO ON XJRSTF
EXCAB==:<MASKB 18,20>		;CURRENT AC BLOCK
EXPAB==:<MASKB 21,23>		;PREVIOUS AC BLOCK
EXPCS==:<MASKB 24,35>		;PREVIOUS CONTEXT SECTION
   >				;END OF IFN KCFLG
   IFN KLFLG,<
EXPCS==:<MASKB 31,35>		;XSFM PUTS PREVIOUS CONTEXT SECTION HERE
   >

;PC WORD

PCX==:77B5			;MBZ BITS IN PC WORD
EXPCBT==:<MASKB 13,35>		;23 BIT PC ADDRESS
EXSCBT==:<MASKB 13,17>		;SECTION BITS OF PC


;PAGER-RELATED STORAGE FORMAT DEFINITIONS


;BAT BLOCK DEFINITIONS
;THE BAT BLOCK IS ONE SECTOR IN LENGTH.  IT CONSISTS OF 4 WORDS OF
;HEADER, FOLLOWED BY DATA, TWO WORDS PER ENTRY, INDICATING WHERE THE
;BAD SPOTS ON THE DISK ARE.  WORD ^D126 CONTAINS A SPECIAL CODE, AND
;WORD ^D127 CONTAINS THE SECTOR NUMBER OF THE BAT BLOCK

BATBL1==2			;SECTOR NO. OF FIRST BAT BLOCK

;HEADER

BATNAM==0			;OFFSET OF SIXBIT /BAT/
BATFRE==1			;WORD WITH FREE BLOCKS LEFT
DEFSTR BATFR,BATFRE,17,18	;FIELD WITH FREE COUNT
DEFSTR BTFR2,BATFRE+HBLEN,17,18	;IN THE SECONDARY BLOCK
DEFSTR BTHCT,2,17,9		;NUMBER OF PAIRS ADDED BY MAPPER
DEFSTR BTMCT,3,35,36		;COUNT OF PAIRS ADDED BY MONITOR
DEFSTR BTMC2,HBLEN+3,35,36	;IN SECONDARY BLOCK

;DATA PAIRS

DEFSTR BATNB,0,8,9		;COUNT OF BAD BLOCKS IN PAIR
PUBCNT==22			;RIGHT-MOST BIT OF UNARY UNIT FIELD
DEFSTR BTKNM,0,20,3		;MASSBUS CONTROLLER #
DEFSTR BADT,0,21,1		;TYPE FIELD IN BAT PAIR
DEFSTR ADD18,1,35,18		;OLD STYLE DISK ADDRESS OF STARTING SECTOR
DEFSTR ADD27,1,35,27		;NEW STYLE ADDRESS OF STARTING SECTOR

;SPECIAL WORDS AT END OF BAT BLOCK

BATCOD==^D126			;OFFSET FOR UNLIKELY CODE 606060
BATBLK==^D127			;OFFSET FOR SECTOR NUMBER
;VARIABLES USED IN MOUNTING STRUCTURES

HB%PUB==:1B0			;PUBLIC STR
HB%1OK==:1B1			;FIRST HOME BLOCK OK
HB%2OK==:1B2			;SECOND HOME BLOCK OK
HB%HBM==:1B3			;HOME BLOCKS MATCH
HB%MUN==:1B4			;MULTIPLE LOGICAL UNITS IN STR
HB%WLK==:1B5			;THIS UNIT IS WRITE-LOCKED

;INTERNAL BITS RELATING TO STRUCTURES. NOT NECESSARILY FOUND IN THE
;SAME WORD

MI%MSG==:1B11			;"TYPE CTY MESSAGES" FLAG FOR STR MOUNTING
				; ROUTINES CALLED BOTH FROM MSTR AND AT STARTUP
;MI%LIM==:1B5			;STRUCTURE IS LIMITED IN GROWTH
				; DEFINED AS MS%LIM IN MONSYM
;MI%ASG==:1B9			;DISK ASSIGNMENTS ARE PROHIBITED (BIT TABLE IS BAD)
				;NOW IN MONSYM AS MS%ASG
;MI%MXB==:1B10			;BIT TABLE TOO BIG FOR MONITOR ADDRESS SPACE
				;NOW IN MONSYM AS MS%MXB


;BOOT parameter flags for homeblock cell HOMBTF
BT%RPM==:1B0			;Read parameters - if not set, BOOT ignores
				; remaining flags in HOMBTF
BT%HOD==:1B1			;0 = proceed on dump errors (default)
				;1 = halt on dump errors

;Defs for CIFRKF - The CI Fork Flag Word

MSKSTR CIBUF,CIFRKF,1B1		;NEED TO CREATE BUFFERS
MSKSTR CIREP,CIFRKF,1B2		;NEED TO REAP CONNECT BLOCKS

;Defs for CFS

; Offsets in a queued Cluster Cease Information Block

	CCNXT==:0		;Address of next queued block
	CCNOD==:1		;Remote Node number
	CCTIM==:2		;Remote shutdown time
	CCNAM1==:3		;ASCIZ of remote
	CCNAM2==:4		; node name
	CCLEN==:5		;Length of this block

;File open modes

.CFOPT==:0			;Open thawed (full sharing)
.CFOPF==:1			;Open frozen
.CFOPR==:2			;Restricted
.CFOPP==:3			;Promiscuous (unrestricted)
.CFOLE==:4			;DUD

;functions for CFSDAU

.CFAGT==:0 			;Get and lock current allocation
.CFAST==:1			;Store allocation
.CFARL==:2			;Release allocation table
.CFARM==:3			;remove entry
.CFAUP==:4			;Undo hold bit
.CFAFD==:5			;Find, but don't create

;Access bits for CFSDAU

CF%HLD==:1B0			;Hold (write access)
CF%PRM==:1B1			;Make this entry "permanent"
CF%NUL==:1B2			;for CFSDAU, indicates a temporary entry

;STORAGE DEFINITIONS FOR SYSTEM FORK DATA BASE

DEFSTR HIBFL,JOBNAM,0,1		;FLAG USED BY .HIBER JSYS
DEFSTR DIAFL,JOBNAM,1,1		;FLAG SAYING JOB HAS .DIAG
				; RESOURCES
DEFSTR FKPGX,FKPGS,35,36
DEFSTR FKPSB,FKPGS(FX),35,18
DEFSTR FKPS%,FKPGS,35,18
DEFSTR FKUPT,FKPGS(FX),17,18
DEFSTR FKUP%,FKPGS,17,18

DEFSTR FKPTX,FKPGST,35,36
DEFSTR FKPTR,FKPGST,35,18	;TEST ROUTINE
DEFSTR FKPTD,FKPGST,17,18	;TEST DATA

DEFSTR FKQTM,FKQ1(FX),35,36

DEFSTR FKQ2X,FKQ2,35,36		;ALL BITS
DEFSTR FKNTC,FKQ2,0,1		;NET TOPOLOGY CHANGE INT ENABLED
DEFSTR PIBMP,FKQ2(FX),1,1	;PI BOOST FLAG
DEFSTR FKFLG,FKQ2(FX),5,4	;FORK FLAGS
DEFSTR FKMNQ,FKQ2(FX),11,6	;MIN Q FOR FORK
DEFSTR FKQN,FKQ2(FX),17,6	;QUEUE LEVEL NUMBER
DEFSTR FKWTL,FKQ2(FX),35,18	;WAITLIST ADR FOR BLOCKED FORK

DEFSTR FKBET,FKPT(FX),17,17	;BALSET ENTRY TIME
 FKBETH==:1B<^L<.RTJST(FKBET,FKBET)>>   ;HIGH BIT OF RIGHT JUSTIFIED FKBET

DEFSTR FKSWX,FKSWP,35,36	;ALL BITS
DEFSTR FKWSL,FKSWP(FX),0,1	;WORKING SET IS LOADED
DEFSTR FKWS%,FKSWP,0,1		;WORKING SET IS LOADED
DEFSTR FKBLK,FKSWP(FX),1,1	;FORK BLOCKED
DEFSTR FKBL%,FKSWP,1,1		;FORK BLOCKED
DEFSTR FKIBS,FKSWP(FX),2,1	;FORK IN BALSET
DEFSTR FKIB%,FKSWP,2,1		;FORK IN BALSET
DEFSTR BSWTB,FKSWP(FX),3,1	;IN BALSET WAIT
DEFSTR BSWT%,FKSWP,3,1		;IN BALSET WAIT
DEFSTR BSNSK,FKSWP(FX),4,1	;NOSKED
DEFSTR BSNS%,FKSWP,4,1		;NOSKED
DEFSTR BSCRSK,FKSWP(FX),5,1	;IN CRITICAL SECTION
DEFSTR BSCR%,FKSWP,5,1		;IN CRITICAL SECTION
DEFSTR FKIBH,FKSWP(FX),6,1	;IBS HOLD, SET ON BALSET ENTRY
DEFSTR FKIH%,FKSWP,6,1		;IBS HOLD, SET ON BALSET ENTRY
DEFSTR FKBSHF,FKSWP(FX),7,1	;IN BALSET HOLD (IN AJBALS ONLY)
DEFSTR FKBS%,FKSWP,7,1		;IN BALSET HOLD (IN AJBALS ONLY)
DEFSTR BSSPQ,FKSWP(FX),8,1	;SPECIAL QUEUE (SYSTEM FORK)
DEFSTR BSSP%,FKSWP,8,1		;SPECIAL QUEUE (SYSTEM FORK)
DEFSTR BSOVRD,FKSWP(FX),9,1	;OVERRIDE HIGH PRIORITY
DEFSTR BSOV%,FKSWP,9,1		;OVERRIDE HIGH PRIORITY
DEFSTR BSNST,FKSWP(FX),10,1	;LAST BLOCK WAS LONG
DEFSTR BSNT%,FKSWP,10,1		;LAST BLOCK WAS LONG
DEFSTR SCWAK%,FKSWP,11,1	;SCJSYS IS WAKING
DEFSTR SCBLK%,FKSWP,12,1	;SCJSYS IS BLOCKED
DEFSTR FKSPL,FKSWP,13,1		;Inferior has spliced.
DEFSTR FKKIL,FKSWP(FX),14,1	;FORK IS BEING KILLED
DEFSTR FKKL%,FKSWP,14,1		;FORK IS BEING KILLED
DEFSTR FKOGL,FKSWP(FX),15,1	;FORK IS ON GOLST
DEFSTR FKGL%,FKSWP,15,1
				;B16-17 AVAILABLE
DEFSTR FKHST,FKSWP(FX),35,18	;HISTORY

;DEFSTR FKGOLN,FKGLSP(FX),35,18	;GOLST POSITION
DEFSTR FKGOLN,FKBSPW(FX),17,18	;GOLST POSITION
   FHV1==:1			;BLOCK PRIORITY VALUES IN FKGOLN
   FHV2==:2
   FHV3==:3
   FHV4==:4
   FHV5==:5
   FHV6==:6
   FHV7==:7

;DEFSTR FKBLP,FKBSPW(FX),35,36	;LIST OF FORKS IN BALSET HOLD
DEFSTR FKBLP,FKBSPW(FX),35,18	;LIST OF FORKS IN BALSET HOLD

DEFSTR FKJOX,FKJOB,35,36	;WHOLE WORD
DEFSTR FKJSB,FKJOB(FX),35,18	;JSB PAGE (WITH FX)
DEFSTR FKJS%,FKJOB,35,18	;  	   W/O
DEFSTR FKJBN,FKJOB(FX),17,18	;JOB NUMBER
DEFSTR FKJO%,FKJOB,17,18	;          W/O FX

DEFSTR FKNRX,FKNR,35,36		;WHOLE WORD
DEFSTR FKXAGE,FKNR(FX),8,9	;AGE AT LAST XGC
DEFSTR FKAGE,FKNR(FX),17,9	;CURRENT AGE
DEFSTR FKWSS,FKNR(FX),35,18	;WORKING SET SIZE

DEFSTR FKWSX,FKWSP,35,36	;WHOLE WORD
DEFSTR FKCSIZ,FKWSP(FX),35,18	;CURRENT SIZE (NUMBER ASSIGNED PAGES)
DEFSTR FKNWCE,FKWSP(FX),17,18	;NUMBER ENTRIES IN WS CACHE

DEFSTR FKCNX,FKCNO,35,36	;WHOLE WORD
DEFSTR FKPS2,FKCNO(FX),17,18	;SECOND PSB PAGE
DEFSTR FKJPT,FKCNO(FX),35,18	;Page table for extended JSB
DEFSTR FKJP%,FKCNO,35,18	;W/O FX
DEFSTR FKCNN,FKCNO(FX),35,18	;CORE NUMBER

DEFSTR FKIBX,FKINTB,35,36	;WORD

;FIELDS IN FKINT

DEFSTR FKINX,FKINT,35,36	;ALL BITS
DEFSTR FKPS0,FKINT, 0,1		;FKPSI0
DEFSTR FKPS1,FKINT, 1,1		;FKPSI1
DEFSTR FKNWF,FKINT, 2,1		;NEWFK%
DEFSTR FKNWJ,FKINT, 3,1		;NEWJB%
DEFSTR FKIIF,FKINT, 4,1		;PSIIF%
DEFSTR FKIT1,FKINT, 5,1		;PSIT1%
DEFSTR FKIT2,FKINT, 6,1		;PSIT2%
DEFSTR FKSUS,FKINT, 7,1		;SUSFK%
DEFSTR FKIWT,FKINT, 8,1		;PSIWT%
DEFSTR FKILO,FKINT, 9,1		;PSILO%
DEFSTR FKFR1,FKINT,10,1		;FRZB1%
DEFSTR FKFR2,FKINT,11,1		;FRZB2%
DEFSTR FKFRJ,FKINT,12,1		;JTFRZ%
DEFSTR FKFRA,FKINT,13,1		;ABFRZ%
DEFSTR FKEFR,FKINT,11,2		;FRZBB%
DEFSTR FKFRZ,FKINT,13,4		;FRZBA%
DEFSTR FKICO,FKINT,14,1		;PSICO%
DEFSTR FKITL,FKINT,15,1		;PSITL%
DEFSTR FKIJT,FKINT,16,1		;PSIJT%
DEFSTR FKABK,FKINT,17,1		;ADRBK%
DEFSTR FKPRI,FKINT,18,1		;PSIPRI
DEFSTR FKIDP,FKINT,19,1 	;PSIDP%
DEFSTR FKISC,FKINT,20,1		;PSISC%
DEFSTR TRMCD,FKINT,35,9		;TERM CODE BITS

FKPSI0==:1B0			;INTERRUPT ATTENTION
FKPSI1==:1B1			;IN PSI HANDLER OR INT DEFERRED
NEWFK%==:1B2			;INITIATE NEW FORK - PI FLAG
NEWJB%==:1B3			;INITIATE NEW JOB - PI FLAG
PSIIF%==:1B4			;CHANNEL INTERRUPT REQUESTED IN FKINTB
PSIT1%==:1B5			;TERMINAL CODE INTERRUPT, PHASE 1
PSIT2%==:1B6			;TERMINAL CODE INTERRUPT, PHASE 2
SUSFK%==:1B7			;SUSPEND FORK REQUEST
PSIWT%==:1B8			;JOB WAS IN WAIT STATUS
PSILO%==:1B9			;LOGOUT JOB REQUEST
FRZB1%==:1B10			;DIRECT FREEZE HAS BEEN DONE
FRZB2%==:1B11			;INDIRECT FREEZE HAS BEEN DONE
FRZBB%==:FRZB1%+FRZB2%		;BOTH BITS FOR EXTERNAL REFS
JTFRZ%==:1B12			;JSYS TRAP FREEZE
ABFRZ%==:1B13			;ADDRESS BREAK FREEZE
FRZBA%==:ABFRZ%+JTFRZ%+FRZBB%	;ALL TYPES OF FREEZES
PSICO%==:1B14			;CARRIER OFF ACTION REQUEST
PSITL%==:1B15			;TIME LIMIT EXCEEDED INTERRUPT
PSIJT%==:1B16			;JSYS TRAP REQUEST
ADRBK%==:1B17			;ADDRESS BREAK REQUEST

DEFSTR (TRMCOD,,35,9)		; FIELD IN FKINT OR PIMSK FOR TERM
;DEFS IN RH OF WORD

PSIPRI==:1B18			;PRIORITY WORD SET.
PSIDP%==:1B19			;DAP% jsys attention
PSISC%==:1B20			;SCS% JSYS work queue enries for this fork
UNUSED==MASKB(21,26)		;UNUSED FKINT BITS

DEFSTR FKSTX,FKSTAT,35,36	;FULL WORD MASK
DEFSTR FKSTR,FKSTAT,35,18	;TEST ROUTINE
DEFSTR FKSTD,FKSTAT,17,18	;ADDITIONAL DATA

DEFSTR FKST2,FKSTA2,35,36	;EXTRA ADDITIONAL DATA WORD FOR SCHED TEST
DEFSTR FK2DT,@FKSTA2(FX),35,36	;TEST WORD CONTENTS (CFS)

DEFSTR FKNB%,FKNBW,35,36	;BALANCE SET WAIT

DEFSTR FKJTN,FKJTQ,35,18	;"NEXT-ENTRY" POINTERS FOR JSYS TRAP QUEUE
DEFSTR FKJTP,FKJTQ,17,18	;"PREVIOUS-ENTRY" POINTERS....

DEFSTR FKTIM,FKTIME,35,36	;WAIT TIME ON QUEUE (SCHED)

;STRUCTURES IN JOB DATA BASE

DEFSTR JBTFK,JOBPT,35,18	;TOP FORK
DEFSTR JBTTY,JOBPT,17,18	;CONTROLLING TTY

; TIMER block defns

DEFSTR JOBRTP,JOBRTL,35,23	; Ptr to runtime limit block
DEFSTR TIMCNT,JOBRTL,12,13	; # of TIMER clocks in use by job

;STORAGE DEFINITIONS FOR THE PSB

DEFSTR ABFLG,ADRBRK,5,6		;FLAG BITS IN ADDRESS BREAK WORD
DEFSTR ABLOW,ADRBRK,35,30	;LOWER BOUND ADDRESS
DEFSTR ABUPP,ADRBUP,35,30	;UPPER BOUND ADDRESS

;STORAGE DEFINITIONS FOR THE JSB

DEFSTR JSMTR,JSMTA1,35,18	;DEFAULT RECORD SIZE (HARDWARE BYTES)
DEFSTR JSMTM,JSMTA1,17,3	;DEFAULT MODE FOR TRANSFER'S (IRMXXX)
DEFSTR JSMTD,JSMTA1,14,4	;DEFAULT DENSITY
DEFSTR JSMTP,JSMTA1,10,1	;DEFAULT PARITY

MSKSTR (JSDFS,JBFLAG,SP%DFS)	;SPOOLING IS DEFERRED
MSKSTR (JSBAT,JBFLAG,SP%BAT)	;JOB IS BEING CONTROLLED BY BATCH
MSKSTR (JSELO,JBFLAG,SP%ELO)	;JOB EXECUTED LGOUT JSYS
MSKSTR (JSFLO,JBFLAG,SP%FLO)	;JOB FORCED TO LOGOUT BY TOP FK ERROR
MSKSTR (JSOLO,JBFLAG,SP%OLO)	;JOB LOGGED OUT BY OTHER JOB

DEFSTR JBMX,JBFLAG,18,1		;JOB HAS BEEN IN THE MINI-EXEC
DEFSTR JBT20,JBFLAG,19,1	;JOB IS AT TOPS20 COMMAND LEVEL

;FIELDS IN JOBBIT

LOGIOB==:1B0			;JOB BEING CREATED OR DESTROYED

;BITS IN PSBIT

DEFSTR (PSXSIR,PSBITS,0,1)	;EXTENDED ADDRESSING SIR WAS DONE
DEFSTR (PSUTPS,PSBITS,1,1)	;THIS FORK HAS USED .MOTPS MTOPR FUNCTION

;DEFINITIONS FOR JFN AREA IN JSB

;JFN0,0				; FIRST JFN
;FILTMP,0			; Lh -0 ptr to temp string block for default
;				; Rh -0 point to temp string block
DEFSTR FLTSD,FILTMP,17,18	; LH
DEFSTR FLTSB,FILTMP,35,18	; RH
;FILBFI,0  			;NEW IO - BP TO CURRENT INPUT BUFFER
;FILBYT				; Byte pointers to current window
DEFSTR FLBPO,FILBYT,5,6	; "P" field of file byte pointer
DEFSTR FLBSZ,FILBYT,11,6	; "S" field of file byte pointer
;FILBFO 			;NEW IO - BP TO CURRENT OUTPUT BUFFER
;FILPRT,0			; Pointer to protection string or protection #
;FILBNI,0 			;NEW IO - INPUT BYTE NUMBER OF CURRENT BYTE
;FILBYN				; Byte number of current byte
;FILBNO  			;NEW IO - OUTPUT BYTE NUMBER OF CURRENT BYTE
;FILACT,1			; Pointer to account string or account number
;FILLEN				; Total length of file in bytes
;FILBCI,0			;NEW IO - BYTES REMAINING IN CURRENT INPUT BUFFER
;FILCNT				; Bytes remaining in current buffer
;FILBCO  			;NEW IO - BYTES REMAINING IN CURRENT OUTPUT BUFFER
;FILLCK				; File lock word
;FILSKT,0			;ARPANET CONNECTION NUMBER,,UNUSED
;FILOPT,0			; Byte pointer to store string in gtjfn
;FILWND				; Lh - current page number
;				; Rh - location of current window
DEFSTR FLPGN,FILWND,17,18	; LH
DEFSTR FLWPG,FILWND,35,18	; RH
;FILSTS				; Lh - file status bits
;				; RH - STATUS, AND MODE IN BITS 32-35
MSKSTR FLMOD,FILSTS,17B35	; Mode of openf
MSKSTR FILNO,FILST1,1B0		;NEW OUTPUT
MSKSTR ASGF2,FILST1,1B1		;[7384]SHADOW BIT FOR ASGF
;FILDEV				; Device dependent  information
DEFSTR STR,FILDEV,17,18		;STRUCTURE NUMBER IN JFN BLOCK
DEFSTR FLDTB,FILDEV,35,18	;DISPATCH TABLE ADDRESS
;FILATB,0			; FOR ATS, POINTER TO DATA NOT IN JOB SPACE
;FILLLB,0			; FOR DECNET, POINTER TO LL BLOCK
;FILNLP,0			;~6.0 For DECnet-36, link parameters and quotas
DEFSTR FLFCO,FILNLP,2,3		;~6.0   Flow control option
DEFSTR FLSES,FILNLP,35,18	;~6.0   Segment size
;FILMTP,0			;FOR MT ,HOLD PROTECTION WORD
;FILOFN				; Lh - ofn for this file
;				; Rh - ofn of long file pt table
DEFSTR FLPTN,FILOFN,17,18	; LH
DEFSTR FLPTT,FILOFN,35,18	; RH
;FILLNM,0			; LH - POINTER TO RDTXT BUFFER
;				; RH - POINTER TO LOGICAL NAME CHAIN
DEFSTR FLTXT,FILLNM,17,18	; LH
DEFSTR FLLNC,FILLNM,35,18	; RH
;FILLFW				; LH - COUNT OF PAGES MAPPED
;				; Rh - location of page table table
DEFSTR FLMPC,FILLFW,17,18	; LH
DEFSTR FLTTW,FILLFW,35,18	; RH
;FILDDN				; Lh - pointer to device string block
;				; Rh - directory number
DEFSTR FLDSB,FILDDN,17,18	; LH
DEFSTR FLDNO,FILDDN,35,18	; RH
;FILDNM				; LH - DIR NAME STRING
;				; RH - POINTER TO ATTRIBUTE LIST (FILATL)
DEFSTR FLDIR,FILDNM,17,18	; POINTER TO DIRECTORY STRING IN JFN BLOCK
DEFSTR FLATL,FILDNM,35,18	; POINTER TO THE ATTRIBUTE LIST
;	PFXMSK==:777		;UP TO 512 POSSIBLE PREFIXES
;	NOATRF==:1B18		;THIS ATTRIBUTE DOES NOT HAVE A VALUE
;	.PFACT==:1		;ACCOUNT STRING ATTRIBUTE
;	.PFPRT==:2		;PROTECTION ATTRIBUTE
;	.PFCOP==:3		;SPOOLED FILE COPIES
;	.PFFRM==:4		;SPOOLED FILE FORMS
;	.PFALC==:5		;PREALLOCATE FILE SPACE
;	.PFBLK==:6		;MAGTAPE BLOCK LENGTH
;	.PFEXP==:7		;MAGTAPE EXPIRATION DATE
;	.PFFMT==:10		;MAGTAPE RECORD FORMAT
;	.PFPOS==:11		;MAGTAPE POSITION
;	.PFRLN==:12		;MAGTAPE RECORD LENGTH
;	.PFUDT==:13		;NETWORK USER I.D.
;	.PFPWD==:14		;NETWORK ASCII PASSWORD
;	.PFBPW==:15		;NETWORK BINARY PASSWORD
;	.PFACN==:16		;NETWORK ACCOUNT STRING
;	.PFOPT==:17		;NETWORK OPTDATA FIELD
;	.PFBOP==:20		;NETWORK BINARY OPTDATA
;	.PFACC==:21		;MAGTAPE ACCESS
;	.PFEXP==:22		;MAGTAPE EXPIRATION DATE
;	.PFOFL==:23		; OFFLINE file attribute
;
;FILNEN				; Lh - pointer to file name string block
;				; Rh - pointer to extension string block
DEFSTR FLNSB,FILNEN,17,18	; LH
DEFSTR FLESB,FILNEN,35,18	; RH
;FILVER				; Lh - fork number of originator of this jfn
;				; Rh - version number
DEFSTR ORG,FILVER,17,18		;FORK ORIGINATOR OF FILE
DEFSTR FLVNO,FILVER,35,18	; RH
;FILBFO,0			;FOR DECNET, OUPTU BUFFER POINTER
;FILMS1				; LH- DIRECTORY WILD MASK
;				; RH- NAME WILD MASK
DEFSTR FLDMS,FILMS1,17,18	;WILD MASK FOR DIRECTORY
DEFSTR FLNMS,FILMS1,35,18	;WILD MASK FOR NAME
;FILIDX,0			; RH - INDEX INTO DEVICE TABLES FOR THE
;				;	ORIGINAL DEVICE GTJFN'ED.  I.E.
;				;	DOES NOT CHANGE DURING SPOOLING
DEFSTR FLDVX,FILIDX,35,18	; RH
;FILBFI,0			;FOR DECNET, POINTER TO INPUT BUFFER
;FILMS2				; LH- EXTENSION WILD MASK
DEFSTR FLEMS,FILMS2,17,18	;WILD MASK FOR EXTENSION
;FILBCT,0			;FOR DECNET, POINTER TO COUNTS
;FILFDB				; ADDRESS OF THE FDB IN THE DIRECTORY
;FILCOD				;C(LH) := STRUCTURE UNIQUE CODE
DEFSTR FLUC,FILCOD,17,18	;STRUCTURE UNIQUE CODE IN JFN BLOCK
DEFSTR FLP0,FILCOD,35,18	;PT0 OFN IF A LONG FILE
;FILNND				;~6.0
DEFSTR FLLNK,FILNND,17,18	;~6.0 link index
DEFSTR FLNOD,FILNND,35,18	;~6.0 PTR TO NODE NAME STRING

;END OF JFN BLOCK DEFINITION

DEFSTR LNMCNT,0,17,18		;DEPTH COUNT FOR LOGICAL NAMES
DEFSTR LNMIDX,0,18,1		;INDEX INTO LN TABLES
DEFSTR LNMSTP,0,35,17		;STEP COUNTER AT TIME OF CHAINING
DEFSTR LNMLNK,1,17,18		;LINK TO NEXT CHAIN BLOCK
DEFSTR LNMPNT,1,35,18		;POINTER TO LOGICAL NAME STRING

DEFSTR PRFXS,0,35,9		;SIZE OF ATTRIBUTE STRING BLOCK
DEFSTR PRFXV,0,26,9		;VALUE OF ATTRIBUTE PREFIX
DEFSTR PRFXL,0,17,18		;LINK TO NEXT ATTRIBUTE ON CHAIN

; Actual TIMER block

DEFSTR TIMLNK,0,35,36		; Link to next block (Q)
DEFSTR TIMTIM,1,35,36		; Time word (when clock should go off)
DEFSTR TIMFRK,2,35,18		; System fork handle to be PSI'd
DEFSTR TIMJOB,2,17,12		; Job # that set the clock
DEFSTR TIMCHN,2,5,6		; Channel for PSI
DEFSTR TIMKNL,3,35,36		; Back link to previous clock
TIMBSZ==:4			; Get a 4 word block for timer

;STRUCTURE OF ADDRESSES ON PHYSICAL DRUM

MSKSTR DRSEC,,000077		;DRUM SECTOR FIELD
MSKSTR DRTRK,,777700		;DRUM TRACK FIELD

;STANDARD ENTRY SEQUENCE FOR NORMAL (NON-HIGH SPEED) MONITOR CALLS

DEFINE MCENT<>

;PROCEDURE TO ESTABLISH NORMAL JSYS CONTEXT WHEN ENTERING MONITOR
;THROUGH SOME WAY OTHER THAN NORMAL JSYS

DEFINE MCENTR <JSP CX,MENT0>

;RETURN FROM NORMAL JSYS CONTEXT.  SKIP (SUCCESS) CASE.
; SEE ERROR RETURNS FOR NOSKIP CASES.

DEFINE SMRETN <JRST SKMRTN>

;RETURN GOOD FROM NEW CONVENTION JSYS (ITRAP IS BAD RETURN)

DEFINE MRETNG <JRST MRETN>

;INTERNAL MONITOR CALL - DOES NOT CHANGE PREVIOUS CONTEXT.  ADDRESS
;SHOULD BE JSYS ENTRY POINT, E.G. .GTJFN.
;	IMCALL ADDRESS,SECTION

DEFINE IMCALL (ADR,SEC)<
	JSP CX,IMCLL0
	IFB <SEC>,<ADR>
	IFNB <SEC>,<SEC,,ADR>
   >

DEFINE GTOKM	(FUN,ARGS,EXTRA,BLKADR) <
	SKIPGE CX,GTOKPR+FUN	;SEE IF NEED TO VERIFY IT
	SKIPA			;YES. DO VERIFICATION CODE THEN
	TXNN CX,SF%DOK		;IF DEFAULT, NEED TO VERIFY
	CALL [	JUMPGE CX,[MOVEI T1,GOKER2 ;IF DENY
			   RETSKP] ;INDICATE SUCH
		ADJSP P,4	;ALLOCATE STACK
		DMOVEM T1,-3(P)		;SAVE TEMPS
		DMOVEM T3,-1(P)
		PUSH P,[0]
		..GOKN==1
		IRP ARGS,<
		..GOKN=..GOKN+1
		PUSH P,ARGS>
		MOVEI T3,..GOKN
		MOVEI T1,FUN
		MOVEI T2,1-..GOKN(P)
		IFB <BLKADR>,<SETZ T4,>
		IFNB <BLKADR>,<MOVEI T4,BLKADR>
		CALL GETOKM		;CALL MONITOR ROUTINE
		 JRST [	MOVE T2,-2-..GOKN(P) ;RESTORE T2
			DMOVE T3,-1-..GOKN(P)
			ADJSP P,-..GOKN-4	;RESET STACK
			RETSKP] ;;INDICATE ERROR
		DMOVE T1,-3-..GOKN(P)	;RESTORE AC'S
		DMOVE T3,-1-..GOKN(P)
		ADJSP P,-..GOKN-4	;RESET STACK
		RET]		;;GOOD RETURN
	 SKIPA		;;GOOD RETURN
	IFNB <EXTRA>,<JRST EXTRA> ;;IF USER ERROR RETURN, DO IT
	IFB <EXTRA>,<ITERR ()>
>  ;END GTOKM MACRO

;MONITOR ERROR CONDITIONS.  ALL TAKE ERROR CODE AS ARGUMENT.
;IF NO ARGUMENT GIVEN, ERROR CODE ASSUMED TO ALREADY BE IN A.
;IF 'EXTRA' APPEARS AS AN ARGUMENT, THEN EXTRA CODE CAN BE
;SPECIFIED WHICH WILL BE EXECUTED BEFORE THE ERROR CODE IS LOADED

;INSTRUCTION TRAP ERROR

DEFINE ITERR (ERN,EXTRA)<
   IFNB <EXTRA>,<
	JRST [	EXTRA
     IFNB <ERN>,<MOVEI T1,ERN>
		JSP T2,ITRAP1]>
   IFB <EXTRA>,<
     IFNB <ERN>,<
	JSP T2,[MOVEI T1,ERN
		JRST ITRAP1]>
     IFB <ERN>,<
	JSP T2,ITRAP1>>>

;INSTRUCTION TRAP IF LSTERR ALREADY STORED

DEFINE ITERX <JSP T2,ITRAP>

;JSYS ERROR RETURN. STORE ERROR CODE IN LSTERR AND RETURN IT IN
;AC1

DEFINE RETERR (ERN,EXTRA)<
	IFNB <ERN'EXTRA>,<
	JRST [	EXTRA
	   IFNB <ERN>,<MOVEI T1,ERN>
		JRST MRETNE]>
	IFB <ERN'EXTRA>,<
	JRST MRETNE>>


;JSYS ERROR RETURN.  STORE ERROR CODE IN LSTERR BUT DO NOT
;RETURN IT IN AN AC

DEFINE EMRETN (ERN,EXTRA)<
	IFNB <ERN'EXTRA>,<
	JRST [	EXTRA
	   IFNB <ERN>,<MOVEI T1,ERN>
		JRST EMRET0]>
	IFB <ERN'EXTRA>,<
	JRST EMRET0>>

;ERRJMP - LOAD ERROR CODE THEN JUMP

DEFINE ERRJMP (ERN,JMP)<
	JRST [	MOVEI T1,ERN
		JRST JMP]>

;LOCAL CALL ERROR RETURN

DEFINE RETBAD (ERN,EXTRA)<
	IFNB <ERN'EXTRA>,<
	JRST [	EXTRA
	   IFNB <ERN>,<MOVEI T1,ERN>
		RET]>
	IFB <ERN'EXTRA>,<
	RET>>

;
; DTB RETURN AND DISPATCH MACROS

DEFINE DTBSKP<	IFIW!RSKP>

DEFINE DTBBAD (A)<
    IFNB <A>,<
	IFIW![MOVEI T1,A
		RET]>
    IFB <A>,<
	 IFIW!R>
>

DEFINE DTBDSP (ROU) <IFIW!ROU>

;JSYS ERROR RETURN - UNLOCK JFN, RETURN ERROR CODE IN AC1 AND LSTERR

DEFINE ERUNLK(ERRORN,EXTRA)<
	JRST [	EXTRA
		IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
		JRST ERUNLD]>

; STANDARD ENTRY MACROS FOR SECTION MANIPULATION

;MACRO TO CAUSE SUBROUTINE TO RUN IN EXTENDED SECTION
;Causes automatic return to section of caller on return.

DEFINE EA.ENT <
	JSP CX,$EAENT>

;MACRO TO CAUSE ROUTINE TO RUN IN SECTION 0
;Causes automatic return to section of caller on return.

DEFINE S0.ENT <
	JSP CX,$S0ENT>

;TEST FOR RUNNING IN SECTION 0.  BUGCHK IF SO AND GET INTO SEC 1.

DEFINE TSTMS0 <
   IFN SEC0SW,<		;;NULL UNLESS DEBUG SWITCH ENABLED
	JSP CX,$TSMS0>>

;The following macros are OBSOLETE.  Any new uses should be avoided.

; ENTER SECTION 1 AND PRESERVE FLAGS

DEFINE SE1ENT <CALL SECALL>

;SE1CAL IS THE SAME AS SE1ENT EXCEPT THAT
;IT ASSUMES THAT THERE IS A RETURN PC ON THE STACK THAT NEEDS
;TO BE CLEARED OF THE FLAGS BITS SO IT WILL RETURN WITHOUT
;A SECTION GREATER THAN 27 BUGCHECK.

DEFINE SE1CAL <CALL SECALE>

; ENTER SECTION 0

; ENTER SECTION 0 IS USED TO GET FROM A NON-ZERO SECTION INTO
; SECTION 0 IT ASSUMES THAT THERE IS A STACK.

DEFINE SE0ENT <CALL SE0CAL>

;SCHEDULING CONTROL MACROS
;May be used in code which runs in scheduler or jsys context.

DEFINE NOSKED <JSP CX,NOSKD0>

DEFINE OKSKED <JSP CX,OKSKD0>

;NOSKED AND OKSKED FOR CODE POSSIBLY BEING RUN UNDER SCHEDULER
;*OBSOLETE*  - use NOSKED, OKSKED instead.

DEFINE NOSKD1 <JSP CX,NOSK11>
DEFINE OKSKD1 <JSP CX,OKSK11>

;CRITICAL SECTION - LIKE NOSKED BUT DOES NOT PREVENT RUNNING OTHER
;FORKS IF PAGE FAULT

DEFINE CSKED  <JSP CX,CRSKD0>

DEFINE ECSKED  <JSP CX,ECSKD0>

;FLAG WAITING FORK NOW UNBLOCKED

DEFINE FSKED <AOS QSKED>

;VARIOUS CALLS TO SCHEDULER

;NORMAL DISMISS

DEFINE MDISMS <JSP CX,EDMS0>

;DISMISS AND HOLD IN BALSET FOR SPECIFIED TIME-- USED FOR BLOCKS
;WHICH ARE EXPECTED TO BE SHORT
; HT = TIME IN MILLISECONDS

DEFINE HDISMS (HT)<
   IFNB <HT>,<
	MOVEI 2,HT>
	JSP CX,EDMSH>

;PAGE FAULT DISMISS

DEFINE PDISMS <JSP CX,SCHEDP>

;PAGE FAULT DISMISS PLUS OKSKED

DEFINE RDISMS <JSP CX,SCHEDR>

;WAIT 100 MS IN BALSET, RETURN .-1

DEFINE CBLK0 <JSP CX,BLOCK0>

;WAIT 100 MS NOT IN BALSET, RETURN .-1

DEFINE CBLK1 <JSP CX,BLOCK1>

;JUST LIKE CBLK1 BUT GO ECSKED FIRST

DEFINE CBLKE <JSP CX,BLOCKE>

;PSI CONTROL

DEFINE NOINT <AOS INTDF>

DEFINE OKINT <XCT INTDFF>

;LET PSI SEE INTERRUPT REQUESTS

DEFINE CHKINT<
	CALL CKINT0>

DEFINE TSTINT <SKIPE PSIBW>

;STANDARD LOCK

DEFINE LOCK(LCK,FAIL)<
	AOSE LCK
	IFB <FAIL>,<
	  CBLK1	>
	IFNB <FAIL>,<
	  FAIL>>

DEFINE UNLOCK(LCK)<
	SETOM LCK>

;CFS LOCK

DEFINE CFSLOK<
	NOSKD1
	AOS SCAILK>

DEFINE CFSULK<
	CALL CFSULL>

;SYSTEM LOCKS

;New system locks should be added to this list.  The format is as follows:

;	LK Name,Check,Access,Address

;	where Name = name of lock
;	      Check = kind of checking before granting lock (FAST or SLOW)
;	      Access = whether or not lock used across LCS (LOCAL or GLOBAL)
;	      Address = address of first word of 4-word lock block


DEFINE LK(NAML,SLOWF,GLOBF,ADDR),<	;This definition of LK assigns
IFN<GLOBF>,<IFE<SLOWF>,<PRINTX ?ERROR IN LOCK DEFINITION. LOCK CAN'T BE FAST AND GLOBAL>>
LOKIDX==LOKIDX+1
NAML==:LOKIDX!SLOWF!GLOBF		; global values to the lock
>

DEFINE ALLOKS <

LK DEVLKK,SLOW,LLCAL,DEVL0K
;LK BTLKK,FAST,LLCAL,BTL0K
;LK DMPLKK,FAST,LLCAL,DMPL0K
;LK FELKK,FAST,LLCAL,FEL0K
;LK IDVLKK,FAST,LLCAL,IDVL0K
;LK NCPLKK,FAST,LLCAL,NCPL0K
;LK OUTLKK,FAST,LLCAL,OUTL0K
;LK NODLKK,FAST,LLCAL,NODL0K
;LK LLLLKK,FAST,LLCAL,LLLL0K
;LK STRLKK,SLOW,LLCAL,STRL0K
;LK LPTLKK,FAST,LLCAL,0
;LK MTALKK,FAST,LLCAL,0
;LK CDPLKK,FAST,LLCAL,CDPL0K
;LK CDRLKK,FAST,LLCAL,CDRL0K
;LK MTALKK,FAST,LLCAL,0
;LK PLTLKK,FAST,LLCAL,0
;LK PTPLKK,FAST,LLCAL,PTPL0K
;LK PTRLKK,FAST,LLCAL,PTRL0K
;LK FGLKK,FAST,LLCAL,FGL0K
;LK SNPLKK,FAST,LLCAL,SNPL0K
;LK USGLKK,FAST,LLCAL,USGL0K
;LK ACTLKK,FAST,LLCAL,ACTL0K
;LK ASCLKK,FAST,LLCAL,ASCL0K
;LK GOKLKK,FAST,LLCAL,GOKL0K
;LK TIMLKK,FAST,LLCAL,TIML0K
;LK CRJLKK,FAST,LLCAL,CRJL0K
;LK LDTLKK,FAST,LLCAL,LDTL0K
;LK JSTLKK,FAST,LLCAL,JSTL0K
;LK DRCLKK,FAST,LLCAL,DRCL0K
;LK JFNLKK,FAST,LLCAL,JFNL0K
;LK FILLKK,FAST,LLCAL,FILL0K
LK ENQLKK,SLOW,GLLBAL,ENQL0K
LK PIDLKK,SLOW,GLLBAL,PIDL0K
;LK JSFLKK,FAST,LLCAL,JSFL0K
;LK JBCLKK,FAST,LLCAL,JBCL0K
;LK SFRLKK,FAST,LLCAL,SFRL0K
;LK JFRLKK,FAST,LLCAL,JFRL0K
>
;STANDARD LOCK


FAST==0
SLOW==1B0
LLCAL==0
GLLBAL==1B1
LOKIDX==0				;Count of locks


	ALLOKS				;Assign locks

DEFINE LK(NAML,SLOWF,GLOBF,ADDR),<
	ADDR>				;This redefinition sets up a
					; pointer to the lock block

;LOCK BLOCK DEFINITIONS

LOKWRD==0				;-1 if unlocked
LOKFRK==1				;Fork with lock
LOKCNT==2				;Count of times locked
LOKPHI==3				;Index of previous highest lock held
LOKFLG==4				;Flags defining lock
LOKHLD==5				;State of global lock
					;LOKHLD HAS TWO USES, LOCK CACHING WHEN
					;THE LOCK IS NOT HELD AND STATE WORD
					;WHEN LOCK IS BEING REQUESTED GLOBALLY.
LOKWAT==6				;LOCK TIMEOUT FOR GLOBAL REQUEST
LOKFRE==7				;SCHEDULER TEST WORD. GOES FROM 0 TO -1
					;WHEN REMOTE LOCKER FREES THE LOCK
LOKLEN==10				;Length of lock blocks


DEFINE INILCK(NAML,IDX),<			;Initialize lock blocks
	PUSH P,T1
	PUSH P,T2
	IFNB <IDX>,<MOVE T2,IDX>
	HRRZ T1,[NAML]
	MOVE T1,LCKTAB(T1)		;Get address of lock block
	IFNB <IDX>,<ADD T1,T2>
	SETOM LOKWRD(T1)		;Initialize lock
	SETOM LOKFRK(T1)		; And fork
	SETZM LOKCNT(T1)		; And count of times locked
	SETZM LOKHLD(T1)		;TURN OFF QUICK LOCKING
	MOVE T2,[NAML]			;Get flags and index
	MOVEM T2,LOKFLG(T1)		; and store
	POP P,T2
	POP P,T1>


DEFINE LOKK(NAML,FAIL,IDX,%LA,%LB,%LC,%LX,%LY,%LZ),<
IFNB <NAML>,<
    IFGE NAML,<
%LA:	PUSH P,T1
	PUSH P,T2
	IFNB <IDX>,<MOVE T1,IDX
		    ADD T1,LCKTAB+<777777&NAML>
	>			;END OF IFNB
	IFB <IDX>,<MOVE T1,LCKTAB+<777777&NAML>>
	CSKED
	AOSE (T1)
	IFB <FAIL>,<CBLKE>
	IFNB <FAIL>,<
	IFNSK.
	   ECSKED
	   POP P,T2
	   POP P,T1
	   SKIPA
	   JRST %LA		;THIS LINE IS FOR FAIL CODE THAT
				; BELIEVES THIS IS THE LOCK PC
	   FAIL
	   JRST %LX
	ENDIF.
	>			;END OF IFNB
	MOVEI T1,777777&NAML	;GET NAME OF LOCK
	MOVE T1,LCKTAB(T1)	;GET IT'S DATA BASE
	MOVE T2,FORKX		;GET CURRENT FORK
	MOVEM T2,LOKFRK(T1)	;SAVE IT IN DATA BASE
	POP P,T2
	POP P,T1
%LX:
    >				;END OF IFGE
    IFL NAML,<
%LB:	PUSH P,T1
	PUSH P,T2
	IFB <IDX>,<SETZ T2,>
	IFNB <IDX>,<MOVE T2,IDX>
	MOVE T1,[NAML]
	CALL GETLOK
	 IFB <FAIL>,<CBLK1>
	 IFNB <FAIL>,<
	 IFNSK.
	    POP P,T2
	    POP P,T1
	    SKIPA
	    JRST %LB		;THIS LINE IS FOR FAIL CODE THAT
				; BELIEVES THIS IS THE LOCK PC
	    FAIL
	    JRST %LY
	 ENDIF.
	 >			;END OF IFNB
	POP P,T2
	POP P,T1
%LY:
    >				;END OF IFL
>				;END OF IFNB
IFB <NAML>,<
%LC:	PUSH P,T1
	PUSH P,T2
	SETZ T2,
	MOVE T1,IDX
	CALL LOKTYP
	 IFB <FAIL>,<CBLK1>
	 IFNB <FAIL>,<
	 IFNSK.
	    POP P,T2
	    POP P,T1
	    SKIPA
	    JRST %LC		;THIS LINE IS FOR FAIL CODE THAT
				; BELIEVES THIS IS THE LOCK PC
	    FAIL
	    JRST %LZ
	 ENDIF.
	>			;END OF IFNB
	POP P,T2
	POP P,T1
%LZ:
>>				;END OF IFB, END OF LOKK


DEFINE UNLOKK(NAML,IDX),<
IFNB <NAML>,<
    IFGE NAML,<
	PUSH P,T1
	IFNB <IDX>,<	MOVE T1,IDX
			ADD T1,LCKTAB+<777777&NAML>
>
	IFB <IDX>,<MOVE T1,LCKTAB+<777777&NAML>>
	SETOM (T1)
	ECSKED
	POP P,T1>
    IFL NAML,<
	PUSH P,T1
	PUSH P,T2
	IFB <IDX>,<SETZ T2,>
	IFNB <IDX>,<MOVE T2,IDX>
	MOVE T1,[NAML]
	CALL RELLOK
	POP P,T2
	POP P,T1>>
IFB <NAML>,<
	PUSH P,T1
	PUSH P,T2
	SETO T2,
	MOVE T1,IDX
	CALL ULKTYP
	POP P,T2
	POP P,T1>>

;JSBVAR - JSB VARIABLE FACILITY

;USES REGISTER P6 AS BASE POINTER TO VARIABLES ASSIGNED IN THE JSB
;ALLOWS VARIABLES TO BE USED WITHIN LOWER LEVEL ROUTINES
;AND AFTER OTHER THINGS HAVE BEEN PUSHED ON STACK.
;N.B. USES P6 AS FRAME POINTER - MUST NOT BE CHANGED WHILE
;VARIABLES IN USE.


DEFINE JSBVAR (VARS,ERET)<
	..TRR==10		;;REMEMBER CURRENT RADIX
	RADIX 8
	..NV==0			;;INIT COUNT OF JSB WORDS
	IRP VARS,<
	  .TRV1 (VARS)>		;;PROCESS LIST
	JSP CX,.JSSET##		;;ALLOCATE JSB SPACE, SETUP P6
    IFB <ERET>,< ..NV+1,,0 >
    IFNB <ERET>,< ..NV+1,,ERET >
	RADIX ..TRR		;;RESTORE RADIX
	PURGE ..TRR,..NV>	;;CLEAN UP
;USAGE FILE / QUEUE DEFINTIONS

;USAGE QUEUE FOR JOB 0

DEFSTR (UQFCN,0,8,9)		;FUNCTION
DEFSTR (UQLJI,0,17,9)		;Local Job Index
DEFSTR (UQLEN,0,35,18)		;LENGTH
DEFSTR (UQLNK,1,35,36)		;LINK TO NEXT OR 0

UQDAT==:2			;OFFSET TO DATA

CKPSIZ==:PGSIZ/10		;ALLOW 8 JOBS/PAGE
				;IE 64 WORDS
;FIELDS FOR THE SIR JSYS AND CHNTAB

MSKSTR (SIVER,,SI%VER)		;VERSION OF SIR (IN T1)
MSKSTR (SILEV,,SI%LEV)		;LEVEL NUMBER (IN CHNTAB)
MSKSTR (SIADR,,SI%ADR)		;ADDRESS OF INTERRUPT ROUTINE (IN CHNTAB)


; Bit definitions in sts (also filsts)

GFLG(OPNF,L,STS,400000)		; File is open
GFLG(READF,L,STS,200000)	; File is ok to read
GFLG(WRTF,L,STS,100000)		; File is ok to write
GFLG(XCTF,L,STS,040000)		; File is ok to execute
GFLG(RNDF,L,STS,020000)		; File is ok to reset pointer (i.e. not append)
GFLG(NONXF,L,STS,010000)	; NON-EXISTENT FILE, DELETE FDB ON RLJFN
GFLG(NWTF,L,STS,004000)		; NO-WAIT ON DUMPI/O
GFLG(LONGF,L,STS,002000)	; File is a long file
GFLG(EOFF,L,STS,001000)		; End of file if read attempted
GFLG(ERRF,L,STS,000400)		; Bytes read may be erroneous
GFLG(NAMEF,L,STS,000200)	; Name is associated with this jfn
GFLG(ASTF,L,STS,000100)		; A * was typed in
GFLG(ASGF,L,STS,000040)		; Jfn is being assigned
GFLG(BLKF,L,STS,000040)		; SERVICE ROUTINE WANTS TO BLOCK
				; SHARES A BIT POSITON WITH ASGF
GFLG(HLTF,L,STS,000020)		; Halt if i-o error
GFLG(WNDF,L,STS,000010)		; A window page has been set up
GFLG(ENDF,L,STS,000004)		; File is past end of maximum length
GFLG(TRNSF,L,STS,000004)	; BIT TIME-SHARED WITH ENDF TO SAY
				; THE JFN IS IN A TRANSITIONAL STATE
				; AND MAY NOT BE ACCESSED
GFLG(SIZF,L,STS,000002)		; Illegal to change size of byte
GFLG(FRKF,L,STS,000001)		; File is restricted to fork in lh(filver)

;NOTE: THIS WORD CONTAINS ALL THE BITS THAT ARE KNOWN TO BE DOCUMENTED FOR
;THE GTSTS JSYS.  ALL OTHER BITS ARE DISCARDED BEFORE RETURNING THE FILE'S
;STATUS.  THEREFORE, WHEN A NEW BIT IS ADDED TO THE STATUS WORD AND IS
;TO BE DOCUMENTED, IT MUST BE ADDED TO THIS WORD

DOCSTS==:OPNF!READF!WRTF!XCTF!RNDF!LONGF!EOFF!ERRF!NAMEF!ASTF!ASGF!HLTF!FRKF!1B18!17B35

MSKSTR(PASLSN,STS,1B18)		;SET TO SKIP LINE NUMBER CHECKING ON ASCII FILES
MSKSTR(SKIPBY,STS,1B19)		;SET BY BYTINA TO REMEMBER IT HAS TO DISCARD
				;  A BYTE ON THE NEXT CALL
GFLG(XQTAF,R,STS,1B20)		;QUOTA EXCEEDED FLAG
GFLG(FILDUD,R,STS,40000)	;SUPPRESS DDMP ACTION IF SET
GFLG(FILINP,R,STS,20000)	;DIRECTION OF I/O IS INPUT
GFLG(FILOUP,R,STS,10000)	;DIRECTION OF I/O IS OUTPUT
GFLG(HLDF,R,STS,4000)		;HOLD IN BALANCE SET IF SET
GFLG(RECF,R,STS,2000)		;END-OF-RECORD SEEN
GFLG(ACRLFF,R,STS,1000)		;ADD CRLF'S AFTER RECORDS ON INPUT

	;Note:  keep CR stuff contiguous - see CRSTUF, DCRSTF (see IO.MAC too)
GFLG(CRNXT,R,STS,400)		;RETURN CR NEXT
GFLG(LFNXT,R,STS,200)		;RETURN LF NEXT
GFLG(FROSTF,R,STS,100)		;Record has been frosted
	GFLG(CRSTUF,R,STS,CRNXT!LFNXT!FROSTF)	;composite CR status field
GFLG(JFNUB,R,STS,40)		;OPEN UNRESTRICTED
GFLG(NSPNUL,R,STS,20)		;NSP NULL RECORD INDICATOR
MSKSTR(IOMODE,STS,17B35)	;MODE FILE IS OPENNED IN - MUST MATCH FLMOD


; In flags

GFLG(OUTPF,L,F,400000)		; Bit 0 for output use
GFLG(NEWNF,L,F,200000)		; Bit 1 new file name only
GFLG(OLDNF,L,F,100000)		; Bit 2 old file only
GFLG(PONFF,L,F,040000)		; Bit 3 print "old file"/"new file" etc.
GFLG(CFRMF,L,F,020000)		; Bit 4 confirmation required
GFLG(TMPFF,L,F,010000)		; Bit 5 temporary file
GFLG(RTYPF,L,F,004000)		; Bit 6 retype whole file name when complete
GFLG(NACCF,L,F,002000)		; Bit 7 no access to other forks
GFLG(IGDLF,L,F,001000)		; Bit 8 ignore deleted bit in files
GFLG(JFNF,L,F,000400)		; Bit 9 use jfn given in e+11
GFLG(JFNAF,L,F,000200)		; Bit 10 use alternate if jfn in e+11 na
GFLG(ASTAF,L,F,000100)		; Asterisk allowed
GFLG(OSTRF,L,F,000040)		; Output stars allowed
GFLG(RLHFF,L,F,000020)		; RETURN LEFT HALF FLAGS
GFLG(PHYOF,L,F,000010)		; PHYSICAL (NOT LOGICAL) ONLY DEVICE FIELD
GFLG(JFNRD,L,F,000004)		;RETURN BUFFER SPECIFIED
GFLG(FILF,L,F,000002)		; If short form, 2 has xwd infile,outfile
GFLG(SHTF,L,F,000001)		; Dummy bit to cause 1 to be taken as flags

; Flags in rh of f used by gtjfn

GFLG(DEVF,R,F,400000)		; Device is specified
GFLG(DIRF,R,F,200000)		; Directory specified
GFLG(NAMF,R,F,100000)		; Name specified
GFLG(EXTF,R,F,040000)		; Extension specified
GFLG(VERF,R,F,020000)		; Version specified
GFLG(PRTF,R,F,010000)		; Protection specified
GFLG(ACTF,R,F,004000)		; Account specified
GFLG(DEVTF,R,F,002000)		; Device was typed in
GFLG(DIRTF,R,F,001000)		; Directory was typed in
GFLG(NAMTF,R,F,000400)		; Name was typed in
GFLG(EXTTF,R,F,000200)		; Extension was typed in
GFLG(VERTF,R,F,000100)		; Version was typed in
GFLG(ACTTF,R,F,000040)		; Account was typed in
GFLG(PRTTF,R,F,000020)		; Protection was typed in
GFLG(TMPTF,R,F,000010)		; Temporary flag was set by type in
GFLG(NODEF,R,F,000004)		; Node name was specified
GFLG(NNAMF,R,F,000002)		; No name device
GFLG(NVERF,R,F,000001)		; No versions etc.

; Flags in rh of F1 used locally

GFLG(MTCHF,R,F1,400000)		; Match seen during lookup ooerations
GFLG(AMBGF,R,F1,200000)		; More than one match seen during operations
GFLG(OCTF,R,F1,100000)		; Octal number is being collected
GFLG(NEGF,R,F1,040000)		; Minus sign was typed
GFLG(UNLKF,R,F1,020000)		; Used by directory to remember to unlock
GFLG(STRF,R,F1,010000)		; String input exists
GFLG(NREC,R,F1,004000)		; Don't perform recognition
GFLG(NREC1,R,F1,002000)		; Used by lookup routines as for norec
GFLG(DIRXF,R,F1,001000)		; Directory was stepped
GFLG(NAMXF,R,F1,000400)		; Name was stepped
GFLG(DIRFF,R,F1,000200)		; Directory is being specified
GFLG(EXTFF,R,F1,000100)		; Extension is being specified
GFLG(PRTFF,R,F1,000040)		; Protection is being specified
GFLG(ACTFF,R,F1,000020)		; Account is being specified
GFLG(NUMFF,R,F1,000010)		; Number is being collected
GFLG(KEYFF,R,F1,000004)		; Looking for t, p, a
GFLG(NEWF,R,F1,000002)		; A new file name was created
GFLG(NEWVF,R,F1,000001)		; A new version of an existing file was created

;FLAGS USED IN LOGNAM ONLY

GFLG(PFXFF,R,F1,000001)		; ENTERING A PREFIX FIELD
GFLG(ATRFF,R,F1,000002)		; ENTERING AN ATTRIBUTE VALUE

; Flags in lh of f1 (scan control)

GFLG(GNJFF,L,F1,400000)		; A GNJFN IS BEING DONE
GFLG(STRSF,L,F1,200000)		; SCAN ALL STRUCTURES
GFLG(DIRSF,L,F1,100000)		; Scan directories <*>
GFLG(NAMSF,L,F1,040000)		; Scan names (^*.)
GFLG(EXTSF,L,F1,020000)		; Scan extensions (^.*)
GFLG(VERSF,L,F1,010000)		; Scan versions (;*)
GFLG(RVERF,L,F1,004000)		; Most recent version specified
GFLG(HVERF,L,F1,002000)		; New version specified
GFLG(LVERF,L,F1,001000)		; Lowest version specified
GFLG(FXPRT,L,F1,000400)		; ;P SPECIFIED
GFLG(FXACT,L,F1,000200)		; Account specified with *'s
GFLG(FXTMP,L,F1,000100)		; ;t specified with *'s
GFLG(EXTXF,L,F1,000040)		; Extension was stepped
GFLG(IGIVF,L,F1,000020)		; Ignore fact file is invisible
GFLG(TCONF,L,F1,000010)		; SAW CONFIRMING TERMINATOR
GFLG(DFSTF,L,F1,000004)		; * in default string
GFLG(STARF,L,F1,000002)		; Set by *
GFLG(STEPF,L,F1,000001)		; Step flag



;FLAGS IN DEVCHR

DV%OPN==:1B5			; FILE OPEN ON DEVICE

;FLAGS IN JOBNAM

JWAKEF==:1B0			;WAKEUP SIGNAL TO THIBR

;FLAGS IN REMFGS

GCF1==:1B0		;FULL GC DONE SINCE LAST REMBSJ/REMBSF

;BITS IN STARTF (SYSTEM STARTUP FLAG WORD)

MI%RFS==:1B0		;REFRESH BEING DONE
MI%RCN==:1B1		;RECONSTRUCTION OF ROOT-DIRECTORY
MI%HMB==:1B2		;HOME BLOCKS WERE REWRITTEN
MI%BTB==:1B3		;BIT TABLE BEING REBUILT
MI%XTB==:1B4		;INDEX TABLE MUST BE REBUILT

;PROCEDURE FOR DEFINING BLOCKS OF NAMED ITEMS

DEFINE DOPC (MAC,IVAL)<
   DEFINE MAC (NAM,SIZ)<
	NAM=:..PC
	..PC=..PC+SIZ>
   DEFINE S'MAC (NAM,SIZ)<
	NAM==:..PC
	..PC=..PC+SIZ>
   ..PC==IVAL
>

; Jsys Trap Block definitions

	DOPC (JTB,0)		;

JTBTL==:<1000+^D35>/^D36	; Length of JSYS trap bit tables
SJTB  JTBMN,1			; RH: forkn of immediate monitor
SJTB  JTBAL,JTBTL		; Bit table of all JSYSes being trapped
SJTB  JTBIM,JTBTL		; Bit table of JSYSes trapped by im. mon.
SJTB  JTBSIZ,0			; Length of Jsys Trap Block

; The length of the JTBs is 31 words, hence there are 33 blocks in 2 pages
; with one word left over, the first word of the JTB page is used as a
; free storage bit table. The actual number of blocks needed is, worst case,
; one per fork (NUFKS) so the number of page needed and the bit table should
; be based on the following calculations.
; NJTBS=<NUFKS*JTBSIZ+1000>/1000	;number of JTB pages needed

DEFSTR JTIMP,JTBMN,35,18	; immed mon pointer (forkn of im. mon.)
DEFSTR JTMCN,JTMNW,17,6		; monitor's channel to send PSI
DEFSTR JTMNI,JTMNW,35,18	; forkn of the monitor we interrupted
DEFSTR JTJNO,KIMUU1+1,35,18	; Jsys number for last USER jsys
DEFSTR JTFRK,JTTFK,35,18	; Trapped forkn; set by trapped fork

; Device dispatch indices

	DOPC (DTB,0)

SDTB DTBLN,1			; Length of DTB
SDTB DLUKD,1			; Directory setup routine
SDTB NLUKD,1			; Name lookup
SDTB ELUKD,1			; Extension lookup
SDTB VLUKD,1			; Version lookup
SDTB PLUKD,1			; Protection insertion
SDTB ALUKD,1			; Account insertion
SDTB SLUKD,1			; Status insertion (temporary permanent etc)
SDTB OPEND,1			; Open file
SDTB BIND,1			; Byte input
SDTB BOUTD,1			; Byte output
SDTB CLOSD,1			; Close file
SDTB REND,1			; Rename
SDTB DELD,1			; Delete file
SDTB DMPID,1			; Dump mode input
SDTB DMPOD,1			; Dump mode output
SDTB MNTD,1			; Mount device
SDTB DSMD,1			; Dismount device
SDTB INDD,1			; Initialize directory of device
SDTB MTPD,1			; Do mtape operation
SDTB GDSTD,1			; Get device status
SDTB SDSTD,1			; Set device status
SDTB RECOUT,1			; FORCE RECORD OUT, (SOUTR JSYS)
SDTB RFTADD,1			; READ FILE TIME AND DATE
SDTB SFTADD,1			; SET FILE TIME AND DATE
SDTB JFNID,1			; SET JFN FOR INPUT
SDTB JFNOD,1			; SET JFN FOR OUTPUT
SDTB ATRD,1			; CHECK ATTRIBUTE
SDTB RLJFD,1			; RELEASE JFN
SDTB DTBLEN,0			;LENGTH DTB

;STANDARD CALL TO UNLOCK MAPPED DIRECTORY

DEFINE ULKDIR <CALL ULKMD0>

;DIRECTORY RELATED DEFINITIONS
DRMXSZ==500			;NUMBER OF PAGES FOR EXTENDED
MXDRNM==100			;NUMBER OF PAGES FOR IDXTAB
.IDXLN==2			;NUMBER OF ELEMENTS PER ENTRY IN INDEX
.PPNLN==1			;NUMBER OF WORDS/ENTRY IN PPN EXTENSION TO IDXTAB

;NOTE: CHECKD CONTAINS A COPY OF THESE DEFINITIONS; WHEN CHANGING
;THEM HERE, CHANGE THEM IN CHECKD ALSO

;DIRECTORY HEADER (FOR PAGE 0; FIRST 3 WORDS ARE REPEATED ON
;SUBSEQUENT PAGES)

DEFSTR DRTYP,0,17,18		;BLOCK TYPE OF DIRECTORY (.TYDIR)
DEFSTR DRVER,0,23,6		;VERSION # OF DIRECTORY
DEFSTR DRHLN,0,35,12		;LENGTH OF HEADER AREA
DEFSTR DRRPN,1,17,18		;RELATIVE PAGE # WITHIN DIRECTORY
DEFSTR DRNUM,1,35,18		;DIRECTORY NUMBER
DEFSTR DRFFB,.DRFFB,35,36	;FIRST FREE BLOCK ON THIS PAGE
DEFSTR DRSBT,3,35,36		;ADDRESS OF BOTTOM OF SYMBOL TABLE
DEFSTR DRSTP,4,35,36		;ADDRESS OF TOP OF SYMBOL TABLE
DEFSTR DRFTP,5,35,36		;ADDRESS OF LAST USED WORD + 1
DEFSTR DRFBT,6,35,36		;POINTER TO FREE POOL BIT TABLE
DEFSTR DRDPW,7,35,36		;DEFAULT FILE PROTECTION
DEFSTR DRPRT,10,35,36		;DEFAULT DIRECTORY PROTECTION
	DEFSTR DRPOW,10,23,6	;OWNER FIELD
	DEFSTR DRPGP,10,29,6	;GROUP FIELD
	DEFSTR DRPWL,10,35,6	;WORLD FIELD
DEFSTR DRDBK,11,35,36		;BACKUP SPECIFICATION
DEFSTR DRLIQ,12,35,36		;LOGIN DISK QUOTA
DEFSTR DRLOQ,13,35,36		;LOGGED OUT QUOTA
DEFSTR DRDCA,14,35,36		;CURRENT DIR ALLOCATION
DEFSTR DRNAM,15,35,36		;POINTER TO NAME STRING
DEFSTR DRPSW,16,35,36		;POINTER TO PASSWORD STRING
DEFSTR DRPRV,17,35,36		;PRIVILEGE BITS
DEFSTR DRMOD,20,35,36		;MODE BITS
DEFSTR DRDAT,21,35,36		;TIME AND DATE OF LAST LOGIN
DEFSTR DRUGP,22,35,36		;USER GROUPS
DEFSTR DRDGP,23,35,36		;DIRECTORY GROUPS
DEFSTR DRUDT,24,35,36		;LAST UPDATE TIME OF DIR
DEFSTR DRSDC,25,35,18		;COUNT OF SUBDIRECTORIES
DEFSTR DRSDM,25,17,18		;MAXIMUM NUMBER OF SUBDIRECTORIES
DEFSTR DRCUG,26,35,36		;CRDIR ALLOWED SPECIFYING THESE USER GRPS
DEFSTR DRACT,27,35,36		;POINTER TO DIRECTORY DEFAULT ACCOUNT
DEFSTR DRDNE,30,35,36		; Default online expiration date/interval
DEFSTR DRDFE,31,35,36		; Default offline expiration date/interval
DEFSTR DRRNA,32,35,36		;Pointer to remote alias list
;DEFSTR $$$$$,33,17,18		;Reserved for DEC
DEFSTR DRPEV,33,35,18		;Password encryption version
				; 0 = unencrypted
DEFSTR DRPDT,34,35,36		;Creation date/time of password
DEFSTR DRPED,35,35,36		;Expiration date/time of password 0 = none set
DEFSTR DRPUD,36,35,36		;Password use data
  DEFSTR DRPCU,36,17,18		;Current password use count
  DEFSTR DRPMU,36,35,18		;Maximum password use count 0 = none set
DEFSTR DRPPN,37,35,36		;TOPS-10 project-programmer number

	.DIHL0==:100		;LENGTH OF DIR PAGE 0 HEADER (+ SPARES)
	.DIHL1==:3		;LENGTH OF HEADER FOR DIR PAGES 1 & UP
	.DRFFB==:2		;OFFSET OF FIRST FREE BLOCK POINTER

;GENERAL FORMAT FOR ALL BLOCKS

DEFSTR BLKTYP,0,17,18		;TYPE CODE FOR STANDARD FORMAT BLOCKS
				;NMTYP, EXTYP, ACTYP, SYMTY, DRTYP,
				;UNTYP, FBTYP, AND FRTYP
DEFSTR BLKVER,0,23,6		;VERSION NUMBER OF BLOCK
DEFSTR BLKLEN,0,35,12		;LENGTH OF STANDARD FORMAT BLOCK

;SYMBOL TABLE

;	SYMBOL TABLE HEADER

DEFSTR SYMTY,0,17,18		;SYMBOL TABLE TYPE CODE (.TYSYM)
DEFSTR SYMDN,0,35,18		;DIR NUMBER OF SYMBOL TABLE

;	SYMBOL TABLE ENTRIES

	SY%ET==:7B2		;SYMBOL TABLE ENTRY TYPE MASK
	.SYMAD==:0		;POSITION OF ADDRESSES IN SYMBOL TABLE
	.SYMVL==:1		;POSITION OF SYMBOL HASH VALUE WORD
	.SYMLN==:2		;# OF WORDS IN A SYMBOL TABLE ENTRY
DEFSTR SYMET,.SYMAD,2,3		;SYMBOL TABLE ENTRY TYPE
DEFSTR SYMAD,.SYMAD,35,33	;ADDRESS OF BLOCK IN DIR FOR THIS SYM
DEFSTR SYMVL,.SYMVL,35,36	;FIRST 5 CHARACTERS OF NAME OR ACCOUNT
	.ETNAM==:0		;ENTRY TYPE OF NAME
	.ETUNS==:2		;ENTRY TYPE OF USER NAME
	.ETACT==:4		;ENTRY TYPE OF ACCOUNT

;NAME BLOCK

DEFSTR NMTYP,0,17,18		;NAME BLOCK TYPE CODE (.TYNAM)
DEFSTR NMLEN,0,35,12		;LENGTH OF NAME BLOCK
DEFSTR NMVAL,1,35,36		;FIRST 5 CHARACTERS OF NAME STRING

;EXTENSION BLOCK

DEFSTR EXTYP,0,17,18		;EXTENSION BLOCK TYPE CODE (.TYEXT)
DEFSTR EXLEN,0,35,12		;LENGTH OF EXTENSION BLOCK

;ACCOUNT STRING BLOCK

DEFSTR ACTYP,0,17,18		;ACCOUNT STRING BLOCK TYPE CODE (.TYACT)
DEFSTR ACLEN,0,35,12		;LENGTH OF ACCOUNT BLOCK
DEFSTR ACSHR,1,35,36		;SHARE COUNT OF ACCOUNT STRING
	.ACVAL==2		;START OF ACCOUNT STRING
DEFSTR ACVAL,.ACVAL,35,36	;FIRST 5 CHARACTERS OF ACCOUNT STRING

;USER NAME STRING BLOCK

DEFSTR UNTYP,0,17,18		;USER STRING BLOCK TYPE CODE (.TYUNS)
DEFSTR UNLEN,0,35,12		;LENGTH OF USER NAME BLOCK
DEFSTR UNSHR,1,35,36		;SHARE COUNT OF USER NAME STRING
DEFSTR UNVAL,2,35,36		;FIRST 5 CHARS OF USER NAME STRING

;FREE POOL BLOCK

	.FRNFB==:1		;OFFSET OF NEXT FREE BLOCK POINTER
	.FRHLN==:2		;LENGTH OF FREE BLOCK HEADER
DEFSTR FRTYP,0,17,18		;FREE BLOCK TYPE CODE (.TYFRE)
DEFSTR FRVER,0,23,6		;VERSION # OF FREE BLOCK
DEFSTR FRLEN,0,35,12		;LENGTH OF THIS FREE BLOCK
DEFSTR FRNFB,.FRNFB,35,36	;POINTER TO NEXT FREE BLOCK

;FDB DEFINITIONS (OTHERS IN MONSYM)

DEFSTR FBTYP,.FBHDR,17,18	;FDB TYPE CODE (.TYFDB)
DEFSTR FBVER,.FBHDR,23,6	;VERSION # OF FDB (0 := PRE-V2)
DEFSTR FBLEN,.FBHDR,35,12	;LENGTH OF FDB
DEFSTR FBFLG,.FBCTL,35,36	;FLAGS
	MSKSTR (FBTMP,.FBCTL,FB%TMP)
	MSKSTR (FBPRM,.FBCTL,FB%PRM)
	MSKSTR (FBNEX,.FBCTL,FB%NEX)
	MSKSTR (FBDEL,.FBCTL,FB%DEL)
	MSKSTR (FBNXF,.FBCTL,FB%NXF)
	MSKSTR (FBLNG,.FBCTL,FB%LNG)
	MSKSTR (FBSHT,.FBCTL,FB%SHT)
	MSKSTR (FBDIR,.FBCTL,FB%DIR)
	MSKSTR (FBNOD,.FBCTL,FB%NOD)
	MSKSTR (FBARC,.FBCTL,FB%ARC)
	MSKSTR (FBINV,.FBCTL,FB%INV)
	MSKSTR (FBOFF,.FBCTL,FB%OFF)
	MSKSTR (FBNDL,.FBCTL,FB%NDL)
DEFSTR FBEXL,.FBEXL,35,33	;LINK TO NEXT EXTENSION FDB
DEFSTR FBADR,.FBADR,35,36	;DISK ADDRESS OF INDEX BLOCK
DEFSTR FBPRT,.FBPRT,35,36	;PROTECTION OF THE FILE
DEFSTR FBCRE,.FBCRE,35,36	;TIME AND DATE OF LAST WRITE
DEFSTR FBLW0,.FBUSE,17,18	;VER #0 LAST WRITER DIR #
DEFSTR FBAT0,.FBUSE,35,18	;VER #0 AUTHOR DIR #
DEFSTR FBAUT,.FBAUT,35,36	;POINTER TO AUTHOR STRING
DEFSTR FBLWR,.FBLWR,35,36	;POINTER TO LAST WRITER STRING
DEFSTR FBGEN,.FBGEN,17,18	;GENERATION # OF FILE
DEFSTR FBDRN,.FBDRN,35,18	;DIR NUMBER (IF THIS IS A DIR FILE)
DEFSTR FBACT,.FBACT,35,36	;ACCOUNT # OR POINTER TO ACCOUNT BLOCK
DEFSTR FBGNR,.FBBYV,5,6		;GENERATION RETENTION COUNT
DEFSTR FBBSZ,.FBBYV,11,6	;BYTE SIZE OF DATA IN FILE
DEFSTR FBMOD,.FBBYV,17,4	;MODE OF LAST WRITE TO FILE
DEFSTR FBNPG,.FBBYV,35,18	;# OF PAGES IN FILE
DEFSTR FBSIZ,.FBSIZ,35,36	;# OF BYTES IN THE FILE
DEFSTR FBCRV,.FBCRV,35,36	;CREATION TIME AND DATE OF FILE
DEFSTR FBWRT,.FBWRT,35,36	;DATE AND TIME OF LAST USER WRITE
DEFSTR FBREF,.FBREF,35,36	;TIME AND DATE OF LAST NON-WRITE ACCESS
DEFSTR FBNWR,.FBCNT,17,18	;# OF WRITES TO FILE
DEFSTR FBNRF,.FBCNT,35,18	;# OF REFERENCES TO FILE
DEFSTR FBBK0,.FBBK0,35,36	;BACKUP WORD 0
DEFSTR FBBK1,.FBBK1,35,36	;BACKUP WORD 1
DEFSTR FBBK2,.FBBK2,35,36	;BACKUP WORD 2
DEFSTR FBBBT,.FBBBT,35,36	; Tape system flag bits
	MSKSTR (K0RAR,.FBBBT,AR%RAR)
	MSKSTR (K0RIV,.FBBBT,AR%RIV)
	MSKSTR (K0NDL,.FBBBT,AR%NDL)
	MSKSTR (K0NAR,.FBBBT,AR%NAR)
	MSKSTR (K0EXM,.FBBBT,AR%EXM)
	MSKSTR (K01ST,.FBBBT,AR%1ST)
	MSKSTR (K0WRN,.FBBBT,AR%WRN)
	MSKSTR (K0RFL,.FBBBT,AR%RFL)
	MSKSTR (K0RSN,.FBBBT,AR%RSN)
	MSKSTR (ARPSZ,.FBBBT,AR%PSZ) ; # pages in RH
DEFSTR FBNET,.FBNET,35,36	; Online expiration
DEFSTR FBUSW,.FBUSW,35,36	;USER SETTABLE WORD
DEFSTR FBGNL,.FBGNL,35,33	;LINK TO NEXT GENERATION
DEFSTR FBNAM,.FBNAM,35,36	;POINTER TO NAME STRING
DEFSTR FBEXT,.FBEXT,35,36	;POINTER TO EXTENSION STRING
DEFSTR FBTDT,.FBTDT,35,36	; Tape write date & time
DEFSTR FBFET,.FBFET,35,36	; Offline expiration tad/interval
DEFSTR ARTP1,.FBTP1,35,36	; Tape 1 for archive/virtual disk
DEFSTR TFN1,.FBSS1,35,18	; Tape 1 tape file #
DEFSTR TSN1,.FBSS1,17,18	; Tape 1 saveset #
DEFSTR ARTP2,.FBTP2,35,36	; Tape 2 for archive/virtual disk
DEFSTR TFN2,.FBSS2,35,18	; Tape 2 tape file #
DEFSTR TSN2,.FBSS2,17,18	; Tape 2 saveset #

	.FBLN0==:30		;MINIMUM LENGTH OF AN FDB

;structure definition for remote alias list block
BEGSTR RN
	FIELD TYP,18	;block type
	FIELD VER,6	;header length
	FIELD LEN,12	;length of block field
	WORD NXT 	;offset for next pointer
	WORD NOD	;offset for node pointer
	WORD USR	;offset for user pointer
	WORD PAS	;offset for password pointer
	WORD ACC	;offset for account pointer
ENDSTR SIZ		;size of block is RN.SIZ

;BLOCK TYPE CODES - FOUND IN LEFT HALF OF WORD 0 OF THE BLOCK

	.TYNAM==:400001		;BLOCK TYPE OF NAME STRING
	.TYEXT==:400002		;BLOCK TYPE OF EXTENSION STRING
	.TYACT==:400003		;BLOCK TYPE OF ACCOUNT STRING
	.TYUNS==:400004		;BLOCK TYPE OF USER NAME STRING
	.TYFDB==:400100		;BLOCK TYPE OF FDB
	.TYLAC==:400200		;BLOCK TYPE OF LEGAL ACCOUNT LIST
	.TYDIR==:400300		;BLOCK TYPE OF DIRECTORY BLOCK
	.TYSYM==:400400		;BLOCK TYPE OF SYMBOL TABLE
	.TYFRE==:400500		;BLOCK TYPE OF BLOCK ON THE FREE LIST
	.TYFBT==:400600		;BLOCK TYPE OF FREE STORAGE BIT TABLE
	.TYGDB==:400700		;BLOCK TYPE OF GROUP DESCRIPTOR BLOCK
	.TYRNA==:401000		;BLOCK TYPE OF REMOTE ALIAS LIST BLOCK

; DIRECTORY CACHE ENTRIES
DCDIRN==:0			;DIRECTORY NUMBER
DCSTRN==:1			;STRUCTURE NUMBER
DCSHRC==:2			;SHARE COUNT
DCSOFN==:3			;SHARED OFN
DCSTIM==:4			;TIME OF ENTRY
DCSIZE==:5			;SIZE OF CACHE

;ENTRIES IN THE INDEX TABLE

DEFSTR IDXFB,0,35,18		;POINTER TO FDB FOR THIS DIRECTORY
DEFSTR IDXSD,0,17,18		;SUPERIOR DIRECTORY
DEFSTR IDXIB,1,35,30		;DISK ADDRESS OF INDEX BLOCK OF DIR
	IDXFLP==5		;BIT POSITION OF IDXFL IN DEFSTR
DEFSTR IDXFG,1,IDXFLP,6		;FLAGS
	IDX%IV==:1		;THIS IDX ENTRY IS INVALID
MSKSTR (IDXIV,1,<<IDX%IV>B<IDXFLP>>)

; INDEX TABLE FIELDS IN THE PSB

DEFSTR (CURUC,STRINF,17,18)	;UNIQUE CODE OF CURRENTLY MAPPED INDEX FILE
DEFSTR (IDXFLG,STRINF,18,1)	;0 IF NO INDEX FILE MAPPED, ELSE 1
DEFSTR (CURSTR,STRINF,35,17)	;STR # OF CURRENTLY MAPPED INDEX FILE

DEFSTR DIRLA,0,35,33		;ADDRESS POINTED TO BY DIRLOC

;THESE DEFINITIONS APPLY TO DROFN, WHICH IS SET UP WHENEVER A DIRECTORY
;IS MAPPED

DEFSTR (DRLFDB,DROFN,17,18)	;ADR OF LAST FDB CHECKED BY FDBCHK
DEFSTR (DRROF,DROFN,18,1)	;SET IF UNMAPD SHOULD RELEASE OFN
DEFSTR (DIROFN,DROFN,35,17)	;OFN OF CURRENTLY MAPPED DIR

; JSB FIELDS RELATED TO STRUCTURES

;THESE DEFSTRS RELATE TO THE 3-WORD BLOCKS CONTAINED IN JSSTR IN THE JSB.
;EACH BLOCK CONTAINS THE STRUCTURE UNIQUE CODE TO WHICH IT APPLIES.

DEFSTR (JSSDM,JSSTRF,0,1)	;STRUCTURE IS DISMOUNTED
DEFSTR (JSMCI,JSSTRF,1,1)	;MOUNT COUNT HAS BEEN INCREMENTED FOR THIS STR
DEFSTR (JSXCL,JSSTRF,2,1)	;STRUCTURE IS MOUNTED EXCLUSIVE BY THIS JOB
JSFRST==:777777			;VALUE IN STRUCTURE NUMBER FIELD WHEN SLOT
				; IS FREE
MSKSTR (JSSTN,JSSTRF,JSFRST)	;STRUCTURE UNIQUE CODE
DEFSTR (JSGRP,JSGRPS,35,36)	;AOBJN POINTER TO USER GROUPS
DEFSTR (JSFMT,JSFKMT,35,36)	;WORD OF BITS REFERRING TO FORKS WHICH
				; HAVE MOUNTED THIS STRUCTURE
DEFSTR (JSADN,JSADIR,35,18)	;"ACCESS'ED" DIRECTORY # FOR THIS STRUCTURE

;THESE DEFSTRS RELATE TO THE CONNECTED STRUCTURE AND DIRECTORY FOR THE JOB

DEFSTR (JSUC,JSBSDN,17,18)	;CONNECTED STRUCTURE UNIQUE CODE
DEFSTR (JSDIR,JSBSDN,35,18)	;CONNECTED DIRECTORY NUMBER
DEFSTR (JSCDS,JSBCDS,35,18)	;POINTER TO CONNECTED DIR NAME STRING
DEFSTR (JSCDF,JSBCDS,0,1)	;0=NO VALID STRING POINTER IN JSCDS
				;1=STRING POINTER IN JSCDS IS VALID

; PSB FIELDS RELATED TO STRUCTURES

DEFSTR (STRFLG,STRWRD,17,18)	;FLAG FOR STRUCTURE INFORMATION
	ST%IMC==:400000		;IGNORE MOUNT COUNT FOR STRUCTURE USE
DEFSTR (NOSTR,STRWRD,35,18)	;NUMBER OF STRUCTURES FOR WHICH PROCESS
				; HAS INCREMENTED MOUNT COUNT.  THIS
				; NUMBER MAY NOT BE ACCURATE AS IT IS
				; NOT DECREMENTED WHEN A DRIVE IS
				; REMOVED FROM THE SYSTEM, AND THE FORK
				; HAS NOT DECREMENTED IT. THE COUNT IS
				; USED AT KSELF TIME TO SEE IF IT IS
				; NECESSARY TO GO THRU EXTRA STRUCTURE
				; CODE.

;NODE NAME STUFF

CPN==6			;NUMBER OF CHARACTERS ALLOWED IN NODE NAME
WPN==CPN/5+1		;WORDS NEEDED FOR LONGEST NODE NAME IN ASCIZ

;DEFINITIONS OF DECNET QUOTA WORD

DEFSTR (DCMAX,DCNCNT,17,18)	;MAX LINKS THIS JOB CAN HAVE
DEFSTR (DCCUR,DCNCNT,35,18)	;CURRENT COUNT OF OPEN LINKS

;DEFINITIONS FOR ATS QUOTA WORD

DEFSTR (JSAMX,JSATCT,17,18)	;MAXIMUM HTN'S THIS JOB CAN HAVE
DEFSTR (JSANO,JSATCT,35,18)	;NUMBER OF HTN'S THIS JOB HAS NOW

;BITS PASSED BETWEEN ATS ROUTINES TO INDICATE STATUS - CODE IN ATSSRV
;SETS THEM, CODE IN FILATS READS THEM

MI%SCH==1B0			;STATUS CHANGED
MI%DHT==1B1			;DEASSIGNING THIS HTN

; STRUCTURE DATA BLOCK DEFINITIONS

	DEFSTR (STRNAM,SDBNAM,35,36)	;NAME OF STRUCTURE IN SIXBIT
DEFSTR (STRNUM,SDBNUM,35,36)	;NUMBER OF UNITS IN STRUCTURE
DEFSTR (STRSIZ,SDBSIZ,35,36)	;SIZE IN SECTORS OF EACH UNIT IN STRUCTURE
DEFSTR (STRSTS,SDBSTS,26,27)	;[7.1063]STRUCTURE STATUS
	;NOTE: ALL SDBSTS FLAGS ARE DEFINED IN MONSYM
	MSKSTR (STPS,SDBSTS,MS%PS) 	;[7.1112]Structure is the Login Structure
	MSKSTR (STDIS,SDBSTS,MS%DIS)	;STRUCTURE IS BEING DISMOUNTED
	MSKSTR (STDOM,SDBSTS,MS%DOM)	;STRUCTURE IS DOMESTIC
	MSKSTR (STNRS,SDBSTS,MS%NRS)	;STRUCTURE IS NOT REGULATED
	MSKSTR (STCRD,SDBSTS,MS%CRD)	;CREATING ROOT-DIRECTORY ON THIS STR
	MSKSTR (STIDX,SDBSTS,MS%IDX)	;INDEX TABLE FILE OFN HAS BEEN SET UP
	MSKSTR (STEXL,SDBSTS,MS%EXC)	;If set, not part of CFS
	MSKSTR (STOFS,SDBSTS,MS%OFS)	;[7.1063]Structure is offline
	MSKSTR (STBS,SDBSTS,MS%BS) 	;[7.1112]Structure is the boot structure
DEFSTR (STRJB,SDBSTS,35,9)	;[7.1063]NUMBER OF INITING JOB
DEFSTR (STRRDO,SDBIDX,17,18)	;OFN OF ROOT-DIRECTORY FOR THIS STRUCTURE
DEFSTR (STRIDX,SDBIDX,35,18)	;FIELD WHICH HOLDS HANDLE OF INDEX TABLE
DEFSTR (STRLDN,SDBLDN,35,36)	;LAST DIRECTORY NUMBER ON THIS STRUCTURE
DEFSTR (STRRXB,SDBRXB,35,36)	;INDEX BLOCK ADDRESS OF ROOT-DIRECTORY
DEFSTR (STRBXB,SDBBXB,35,36)	;INDEX BLOCK ADDRESS OF BACKUP ROOT-DIRECTORY
DEFSTR (STRNSS,SDBNSS,35,36)	;NUMBER OF SWAPPING SECTORS PER UNIT
DEFSTR (STRFSS,SDBFSS,35,36)	;FIRST SWAPPING SECTOR PER UNIT
DEFSTR (STRBTB,SDBBTB,35,36)	;OFN OF BIT TABLE FILE
DEFSTR (STRFC,SDBFRC,35,36)	;COUNT OF FREE PAGES ON STRUCTURE
DEFSTR (STRLCA,SDBLCA,35,36)	;LAST CYLINDER ASSIGNED BY DSKASN
DEFSTR (STRCYL,SDBCYL,35,36)	;TOTAL CYLINDERS IN STRUCTURE
DEFSTR (STRB0,SDBBT0,35,36)	;LENGTH OF TOP HALF OF BIT TABLE
DEFSTR (STRB1,SDBBT1,35,36)	;LENGTH OF BOTTON HALF OF BIT TABLE
DEFSTR (STRTYP,SDBTYP,35,36)	;ADDRESS OF DSKSIZ TABLE FOR THIS TYPE DISK
DEFSTR (STRTMR,SDBTMR,35,36)	;[7.1063]Time stamp word for offline structures
DEFSTR (STRUDB,SDBUDB,35,36)	;FLAGS,,ADDRESS OF UDB FOR FIRST UNIT IN STR
DEFSTR (STRUC,SDBFLK,17,18)	;UNIQUE CODE IN SDB
	STRNS==:6		;LENGTH OF THE STR NUMBER FIELD
DEFSTR (STRUS,SDBFLK,17,STRNS)	;FIELD WITHIN STRUC TO HOLD STR NUMBER
DEFSTR (STRLK,SDBFLK,35,18)	;FILE LOCK COUNT
DEFSTR (STRMC,SDBCNT,17,18)	;MOUNT COUNT
DEFSTR (STROF,SDBCNT,35,18)	;OPEN FILE COUNT
DEFSTR (STRMI,SDBPUC,35,36)	;MEDIA IDENTIFICATION FIELD



;BITS FOR CALLING DIRCHK TO CHECK IF THE SPECIFIED ACCESS TO A DIRECTORY IS LEGAL

DC%RD==:DP%RD_<^D30-1>		;ACCESS FILES ACCORDING TO THEIR PROTECTION
DC%CN==:DP%CN_<^D30-1>		;CONNECT TO THE DIRECTORY
DC%CF==:DP%CF_<^D30-1>		;CREATE FILES

;BITS FOR CALLING ACCCHK TO CHECK IF THE SPECIFIED ACCESS TO A FILE IS LEGAL

FC%DIR==:FP%DIR_<^D30-1>	;LIST THE FILE SPEC VIA 'DIR' COMMAND
FC%APP==:FP%APP_<^D30-1>	;APPEND
FC%EX==:FP%EX_<^D30-1>		;EXECUTE
FC%WR==:FP%WR_<^D30-1>		;WRITE
FC%RD==:FP%RD_<^D30-1>		;READ

FC%MSK==:FC%DIR!FC%APP!FC%EX!FC%WR!FC%RD	;MASK OF ALL ACCESS BITS

;BIT DEFINITIONS FOR FE STATUS WORD

.DVFNX==:1B35			;NON-EX DEVICE
.DVFOL==:1B34			;OFF LINE
.DVFHE==:1B33			;HARDWARE ERROR
.DVFSE==:1B32			;SOFTEARE CONDITION
.DVFIP==:1B31			;I/O IN PROGRESS
.DVFEF==:1B30			;END OF FILE
.DVFLG==:1B29			;ERROR LOGGING INFO FOLLOWS
.DVFFE==:1B28			;DEVICE HAS A FATAL UNRECOVERABLE
				; ERROR
.DVCFG==1B24			;CONFIGURATION CHANGE

;SECOND STATUS WORD DEFINITONS
.DDRCK==:1B35			;READ CHECK
.DDPCK==:1B34			;PICK CHECK
.DDSCK==:1B33			;STACK CHECK
.DDHEM==:1B32			;HOPPER EMPTY
.DDSFL==:1B31			;STACKER FULL

 ;FREE SPACE DEFINITIONS


	;Format for swappable free space pool descriptors
	;WARNING:  These offsets cannot be redefined without changing the
	;FSPPL. macro.
FSPPFL==0			;Flags
  FS.CHK==1B0			;Pool integrity checking should be performed
  FS.INI==1B1			;Pool has been initialized
  FS.CNT==1B2			;User sees count word (temporary bit)
FSPLOK==1			;Pool lock
FSPORG==2			;Origin address of free space
FSPEND==3			;Ending address of free space
FSPCNT==4			;Count of space remaining in pool
FSPSML==5			;Smallest balance of free space achieved
FSPBAP==6			;Pointer to block accounting area
FSPMTB==7			;Minimum total block size
FSPFFB==10			;Pointer to first free block (dummy block)
FSPRFB==11			;Randomized pointer to first free block
FSPHDS==12			;Size of block header
FSPTRS==13			;Size of block trailer (if any)
FSPHTS==14			;Combined size of header and trailer
FSPBCS==15			;Block-check size
				;(Smaller of header or trailer size)
				;(FSPHDS+FSPTRS + minimum user size)
FSPHBP==16			;Pointer to history (ring) buffer origin
FSPHBX==17			;Max # history records,,index to current record
  FSPDSS==20			;Size of descriptor

	;Offsets for history records
FSPHST==0			;Transaction type:
				;-1 = assign
				; 0 = deassign
FSPHPC==1			;PC of caller
FSPHJF==2			;Job,,fork of caller
FSPHBA==3			;Block address
FSPHBS==4			;Block size

FSPHRS==5			;History record size
FSPHRC==^D200			;# of history records per pool

	;Offsets for block accounting area
FSPREQ==0			;Block of words for request size counts
  FSPBSC==100			;Size of previous
FSPFIL==FSPREQ+FSPBSC		;Block of words for filled requests by size
FSPTRV==FSPFIL+FSPBSC		;Block of words for list traversal sizes
  FSPCBS==FSPBSC*3		;Combined size of all count blocks

	;Format for swappable free space block header
	;WARNING:  These offsets cannot be changed without changing the
	;initialization routine FSPINI.

JSBBHS==3			;Block header size of JSB pool
JSBBTS==0			;Block trailer size of JSB pool
FSPBHS==3			;Block header size (minimum)
FSPBTS==0			;Block trailer size
IFN FSPDBG,
 <
 FSPBHS==7			;Header and trailer for debugging
 FSPBTS==7			;...
 >
FSPDHS==3			;Dummy header size for all pools

;Offsets within header/trailer
FSPAPC==-7			;PC of last caller who assigned the block
FSPAJF==-6			;Job,,fork of last requestor who assigned
FSPDPC==-5			;PC of last caller who deassigned the block
FSPDJF==-4			;Job,,fork of last requestor who deassigned
FSPFLG==-3			;flags,,Unique code
  FSPUCD==707707		;Unique code
  FSP.AS==1B0			;Block is assigned
  FSP.BD==1B1			;Block header/trailer do not match
FSPSIZ==-2			;Size of this block (user block + header + trailer)
FSPNXT==-1			;Pointer to next block
				;Note:  Once a block is allocated to the user,
				;the block pointer is SOSed such that the first
				;word of the user block is the same word which
				;formerly held the "next" pointer.  I.e., the 
				;user block is allowed to overlay the header by
				;1 word.



FSPTBL==:7			;Length of free-pool index table

;Offsets for the JSB stack-descriptor

	JSSTCN==:0		;Size of stack in words
	JSSTCC==:1		;Current count of records in use
	JSSTMR==:2		;Maximum records available
	JSSTAD==:3		;Pointer to stack

	  JSSTDL==:4		;Length of descriptor

;Offsets for JSB stack records

	JSSTCD==:0		;Datum code
	JSSTFK==:1		;Fork #
	JSSTDT==:2		;Data

	 JSRSZ==:3		;Size of stack record


	JSSTSZ==:JSRSZ*^D10	;Size of initial stack

;CODE DEFINITIONS FOR THE JSB FREE SPACE STACK. THESE
;CODES IDENTIFY THE TYPE OF ENTRY ON THE STACK

STKCD1==:1			;TYPE 1 FOR ASGJFR STRINGS
STKCD2==:2			;TYPE 2 FOR ASGPAG STRINGS
STKCD3==:3			;TYPE 3 FOR TTY LOCKS
STKCD4==:4			;TYPE 4 FOR SWAP FREE STRINGS
  STKHWD==:STKCD4		;Codes .LE. STKHWD are handled
				; as right-justified halfword values
				; those greater than STKHWD are
				; handled as fullword values


;SYSERR DEFINITIONS

;FORMAT OF SEBCPY WORD

SEBOFS==:<MASKB 2,8>		;OFFSET
SEBTYP==:<MASKB 9,11>		;TYPE
SEBDPT==:<MASKB 13,35>		;DATA POINTER

;MACRO TO BUILD POINTER WORD AT ASSEMBLY TIME
; SEBPTR OFFSET,DATATYPE,ADDRESS

DEFINE SEBPTR (AA,BB,CC)<
	1B0+FLD(AA,SEBOFS)+FLD(BB,SEBTYP)+<Z CC>>

;DATA TYPES - SEBCPY WORD

SBTWD==:0			;FULL WORD
SBTSTR==:1			;STRING
SBTEVC==:2			;EVENT CODE IMMEDIATE
SBTFNA==:3			;FUNCTION ADDRESS FOR JOB 0 PROCESSING


;POSSIBLE LINE TYPES FOR TELETYPE SERVICE

   IFN FTNSPSRV,<

TT.FE==0			;ON THE RSX20F FRONT END
TT.MCB==1			;ON THE MCB NETWORK
TT.PTY==2			;PSEUDO-TERMINAL
TT.D10==3			;ON THE DC10
TT.DZ==4			;ON THE SM10
TT.RSP==5			;2080 CONSOLE LINES
TT.TVT==6			;ARPANET TVTs

NLTYPS==7			;NUMBER OF TYPES

   >;END OF IFN FTNSPSRV

   IFE FTNSPSRV,<

TT.FE==0			;ON THE RSX20F FRONT END
TT.MCB==1			;ON THE MCB NETWORK
TT.PTY==2			;PSEUDO-TERMINAL
TT.TVT==3			;ARPANET TVTs
TT.CTH==4			;CTERM HOST LINES
TT.LAH==5     			;LAT HOST TERMINAL TYPES

NLTYPS==6

   >;END OF IFE FTNSPSRV



;FIELD FOR CONTROLLING TERMINAL

DEFSTR (FRKTTY,CTTAB,35,18)

;DEFINITIONS FOR RESIDENT FREE POOL ALLOCATION

;DEFINE SPECIAL RESIDENT FREE SPACE VALUES

	RS%SE0==:1B0		;SPACE MUST BE IN SECTION 0 (USED BY ASGRES)
	RS%GRO==:1B0		;THE RELEASING IS REALLY A "GROWING" (USED BY RELRES)
	RESFLG==:101010		;FLAG PUT IN TRAILER WORD OF BLOCK


;FORMAT OF A RESIDENT FREE SPACE HEADER

RSHLEN==1			;LENGTH OF HEADER FOR EACH BLOCK
	DEFSTR (RSPOO,0,17,18)	;POOL NUMBER FOR THIS BLOCK
	DEFSTR (RSSIZ,0,35,18)	;SIZE OF BLOCK IN 4-WORD CHUNKS

IFN RESHSW,<			;SECOND HEADER WORD FOR DEBUGGING
RSHLEN==2
	DEFSTR (RSINU,1,0,1)	;"BLOCK IN USE" FLAG
	DEFSTR (RSCAL,1,35,35)	;PC OF CALLER TO ASGRES
>

;FORMAT OF A RESIDENT FREE SPACE TRAILER

RSTLEN==0			;LENGTH OF TRAILER FOR EACH BLOCK

IFN RESHSW,<			;MAKE IT BIGGER FOR DEBUGGING
RSTLEN==1
	DEFSTR (RSFLG,0,17,18)	;THE TRAILER FLAG
	DEFSTR (RSHED,0,35,18)	;THE ADDRESS OF THE HEADER
>


;ICCS DEFINITIONS
FLINK==:0			;FORWARD POINTER
BLINK==:1			;BACKWARD POINTER
QINTL==:2			;INTERLOCK WORD
QLNGTH==:3			;LENGTH OF THE QUEUE ENTRY

; DEFINITIONS FOR ACCOUNT VALIDATION
; THESE THREE DEFINITIONS ARE COMMON TO ALL ACCOUNT DATA BLOCKS

DEFSTR (BKTYP,0,17,18)		;DATA BLOCK TYPE
DEFSTR (BKLEN,0,35,18)		;BLOCK LENGTH
DEFSTR (XPDAT,1,35,35)		;EXPIRATION DATE

; ACCOUNT HEADER

DEFSTR (ACCLS,2,8,9)		;CLASS FOR THIS ACCOUNT
DEFSTR (DATASZ,2,35,27)		;TOTAL LENGTH OF ACCOUNT DATA BLOCK
DEFSTR (ACPTR,3,35,36)		;POINTER TO CHAINED ACCOUNT BLOCK
DEFSTR (ACNAM,4,35,36)		;ACCOUNT STRING NAME

; USER NAME

DEFSTR (USRNM,2,35,36)		;USER NAME STRING

; USER GROUP

DEFSTR (USRGP,2,35,36)		;USER GROUP NUMBER


; SXSTR IS COMMON TO ALL DIRECTORY-TYPE BLOCKS

DEFSTR (SXSTR,2,35,36)		;SIXBIT STRUCTURE NAME

; DIRECTORY NAME

DEFSTR (DIRNM,3,35,36)		;DIRECTORY NAME STRING

; DIRECTORY GROUP

DEFSTR (DIRGP,3,35,36)		;DIRECTORY GROUP NUMBER

; ALL DIRECTORIES


; DATA BLOCK TYPES

	.TYHSH==:577001		;HASH TABLE
	.TYACC==:577002		;ACCOUNT HEADER
	.TYUNM==:577003		;USER NAME
	.TYUGP==:577004		;USER GROUP
	.TYALU==:577005		;ALL USERS
	.TYDNM==:577006		;DIRECTORY NAME
	.TYDGP==:577007		;DIRECTORY GROUP
	.TYALD==:577010		;ALL DIRECTORIES
	.TYNUL==:577011		;NULL BLOCK
	.TYWUS==:577012		;WILD USER NAME STRING


;Macros for defining BUGs
;General format for in-line bug macro call is:
;	BUG. (TYP,TAG,MODULE,WORD,STR,LOCS,HELP,CONTIN)
;
;TYP -	Flavor, HLT, CHK, or INF
;
;TAG -	Name of BUG
;
;MODULE -
;	Name of module in which BUG occurs.
;
;WORD -	Flavor of BUG.  For instance, HARD for hardware-caused, SOFT for
;	software-caused.
;
;STR -	Short descriptive string describing cause of BUG, which gets printed
;	on CTY when BUG occurs.
;
;LOC -	List of locations whose contents should be displayed when the BUG
;	occurs.  Each location must be followed by a comma and then a one-word
;	descriptor of what the datum represents, for instance UNIT or CHN.
;	Each pair of locations and descriptors must be in angle brackets,
;	and the angle-bracketed pairs must be separated by commas with the
;	entire LOC argument in angle brackets.
;
;HELP -	General documentation for the BUG
;
;CONTIN - Optional continuation address after BUGCHK or BUGINF is
;	logged.  Assumed to be in same section with call.
;
;FLAGS - [7.1081] Optional flags for this BUG (only if TYP is CHK or INF)
;	 Should contain DB%NND if BUG is not normally dumpable when we are
;	 dumping all BUGCHKs or BUGINFs.  (DB%NND defined in MONSYM).

BUGMXR==:4			;[7.1081] Maximum additional data arguments

DEFINE BUG. (TYP,TAG,MOD,WORD,STR,LOCS,HELP,CONTIN,FLAGS)< ;;[7.1081]
   IF2,<..NRGS==0
	IRP LOCS,<
	  .CKLC1 (LOCS)
	  ..NRGS=..NRGS+1>	;;COUNT DATA ITEMS
    IFG ..NRGS-BUGMXR,<
	  PRINTX %TOO MANY LOCATIONS IN DEFINITION OF BUG'TYP TAG>>
    CONCK$ (TYP,TAG,,,<LOCS>,<STR>,SAME,CONTIN,FLAGS) ;;[7.1081] 
    >

DEFINE .CKLC1 (LOCS)<
	.CKLC2 (LOCS)>

DEFINE .CKLC2 (LADR,LNAM)<
   IFB <LNAM>,<PRINTX % Data item LADR in BUG'TYP TAG has no descriptor.>
    >

;This is the macro that does the work of actually assembling
;something for the occurrance of BUG.

DEFINE CONCK$ (TYP,TAG,MOD,WORD,ODATA,STR,LOCS,CONTIN,FLAGS,%STR,%FLG)<	;;[7.1081] 

  IF2,<
   IFDIF <LOCS><SAME>,<		;;NOT NEEDED IF LOCAL DEFINITION
     IFDIF <ODATA>,<LOCS>,<
	PRINTX %Optional data in TAG disagrees with definition of TAG>

;;Make listing include info about BUG:
	LALL
	  ;BUG'TYP TAG, STR
	       SALL
   >>
IF1,<SYN TAG,TAGSAV    		;;SAVE THE MACRO DEFINITION
PURGE TAG			;;KILL OFF MACRO IN BLANK PSECT
SYN TAGSAV,TAG			;;REDEFINE MACRO IN CORRECT PSECT
PURGE TAGSAV>			;;GET RID OF DUMMY SYMBOL

IFDIF <TYP><HLT>,<		;;[7.1081] If it isn't a BUGHLT
	.PSECT RSDAT		;;[7.1081] Get to writable section 0/1
%FLG:	IFB <FLAGS>,<EXP 0>	;;[7.1081] If no FLAGS, assume dumpable
	IFNB <FLAGS>,<EXP FLAGS> ;;[7.1081] If FLAGS specified, use it
	.ENDPS			;;[7.1081] Get out of RSDAT
>				;;[7.1081] End if IFDIF <TYP><HLT>

IFB <CONTIN>,<
	XCT [
	TAG:: 			;;DEFINE LOCATION
	  IFIDN <TYP><HLT>,<
	     IFE <<CURPSX-PXRESCD>*<CURPSX-PXSWAPCD>>,<
		 JSR @XBUGHLT>
	     IFN <<CURPSX-PXRESCD>*<CURPSX-PXSWAPCD>>,<
		 JSR BUGHLT>
	  >
	  IFDIF <TYP><HLT>,<
	     IFE <<CURPSX-PXRESCD>*<CURPSX-PXSWAPCD>>,<
		 PUSHJ P,@XBGC'TYP>
	     IFN <<CURPSX-PXRESCD>*<CURPSX-PXSWAPCD>>,<
		 PUSHJ P,BGC'TYP>
	  EXP %FLG		;;[7.1081] Point to flags word
	  >
	  DOLOC0 <ODATA>	;;ASSEMBLE OPTIONAL DATA
		SIXBIT /TAG/
	  ]
>
IFNB <CONTIN>,<
	JRST [
	       XCT [
	       TAG:: 			;;DEFINE LOCATION
	         IFIDN <TYP><HLT>,<
		   IFE <<CURPSX-PXRESCD>*<CURPSX-PXSWAPCD>>,<
		       JSR @XBUGHLT>
		   IFN <<CURPSX-PXRESCD>*<CURPSX-PXSWAPCD>>,<
		       JSR BUGHLT>
		 >
	         IFDIF <TYP><HLT>,<
		   IFE <<CURPSX-PXRESCD>*<CURPSX-PXSWAPCD>>,<
		       PUSHJ P,@XBGC'TYP>
		   IFN <<CURPSX-PXRESCD>*<CURPSX-PXSWAPCD>>,<
		       PUSHJ P,BGC'TYP>
		 EXP %FLG		;;[7.1081] Point to flags word
		 >
	         DOLOC0 <ODATA>	;;ASSEMBLE OPTIONAL DATA
	               SIXBIT /TAG/
	         ]
	       JRST CONTIN ]		;;CONTINUATION ADDRESS

>
IFDIF <TYP><HLT>,<IF2,<		;;[7.1081] If not a HLT and on pass 2 
	.XCREF %FLG		;;[7.1081] Uncref the flag symbol
	PURGE %FLG		;;[7.1081] Purge the flag symbol
>>				;;[7.1081] End of IFDIF <TYP><HLT>,IF2,
	XLIST
	.PSECT BGSTR
%STR:!	ASCIZ \STR\
	.ENDPS BGSTR
	.PSECT BGPTR
  IFE FTNSPSRV,<
  IF1,<	0			;;BE CAREFUL OF RECURSIVE MACRO ON PASS 1
	0
	%ST1=MSEC1		;;Make sure MSEC1, SYMSEC and XCDSEC are
	%ST1=SYMSEC		;; searched as externals.
	%ST1=XCDSEC
	PURGE %ST1>
  IF2,< IFE <<CURPSX-PXRESCD>*<CURPSX-PXSWAPCD>>,<
	XWD XCDSEC,TAG>
	IFN <<CURPSX-PXRESCD>*<CURPSX-PXSWAPCD>>,<
	XWD MSEC1,TAG>
	XWD SYMSEC,%STR
	.XCREF %STR
	PURGE %STR>
  >;;End IFE FTNSPSRV
  IFN FTNSPSRV,<
  IF1,<	0>			;;BE CAREFUL OF RECURSIVE MACRO ON PASS 1
  IF2,<	XWD TAG,%STR
	.XCREF %STR
	PURGE %STR>
  >;;End IFN FTNSPSRV
	.ENDPS BGPTR
	LIST
>

DEFINE DOLOC0 (LOCS)<
	IRP LOCS,<DOLOC2 LOCS>>

DEFINE DOLOC2 (FOO)<
	DOLOC1 (FOO)>

DEFINE DOLOC1 (LOCADR,LOCNAM)<
	Z LOCADR
   >
;End of macros for defining BUGs

; NSP INTERNAL INTERFACE FUNCTION VECTOR OFFSETS

.NSCRT==:0			;CREATE AN INTERNAL LOGICAL LINK
	.NSSZW==:0		;ARGUMENT BLOCK SIZE
	.NSSTR==:1		;ADDRESS OF NAME STRING TO PARSE
	.NSHST==:1		;ADDRESS OF HOST NAME STRING
	.NSOBJ==:2		;ADDRESS OF OBJECT NAME STRING
	.NSDSC==:3		;ADDRESS OF DESCRIPTOR STRING
	.NSODC==:4		;COUNT OF BYTES IN OPTIONAL DATA STRING
	.NSOPD==:5		;ADDRESS OF OPTIONAL DATA STRING (8 BIT BYTES)
	.NSTSN==:6		;ADDRESS OF TASK NAME STRING
	.NSUSR==:7		;ADDRESS OF USER STRING
	.NSPWC==:10		;COUNT OF BYTES IN PASSWORD STRING
	.NSPSW==:11		;ADDRESS OF PASSWORD STRING (8 BIT BYTES)
	.NSCHG==:12		;ADDRESS OF ACCOUNT STRING
	.NSMQI==:13		;MAXIMUM INPUT TO QUEUE ON LINK
	.NSMQO==:14		;MAXIMUM OUTPUT TO QUEUE ON LINK

	NS%SHT==:1B0		;SHORT FORM CALL
	NS%RD==:1B1		;READ ACCESS WANTED
	NS%WRT==:1B2		;WRITE ACCESS WANTED
	NS%LOK==:1B3		;LOCK THE LOGICAL LINK ON RETURNING TO DRIVER
.NSCLZ==:1			;CLOSE AN INTERNAL LINK
.NSOUT==:2			;OUTPUT TO AN INTERNAL LINK
	NS%BLK==:1B0		;BLOCK UNTIL ALL DATA SENT
	NS%EOM==:1B1		;THIS BUFFERFUL IS AN ENTIRE NSP MESSAGE
.NSINB==:3			;PROVIDE INPUT BUFFER
.NSRIN==:4			;READ INTERRUPT MESSAGE
.NSSIN==:5			;SEND INTERRUPT MESSAGE
.NSTRN==:6			;TRUNCATE CURRENT MESSAGE
.NSRLS==:7			;READ LINK STATUS
.NSRHN==:10			;READ HOST NAME
.NSRTN==:11			;READ TASK NAME
.NSRDA==:12			;READ OPTIONAL DATA
.NSRSS==:13			;READ LINK SEGMENT SIZE
.NSRON==:14			;READ OBJECT NAME

; DRIVER FUNCTION VECTOR OFFSETS

.NSHDR==:0			;COUNT OF WORDS IN VECTOR
.NSCND==:1			;CONNECT DISPOSITION RECEIVED
.NSBFR==:2			;NSP NEEDS A BUFFER
	NS%TRN==:1B0		;TRUNCATE MESSAGES IF TOO BIG FOR BUFFER
.NSDAT==:3			;INPUT DATA NOW AVAILABLE
	NS%MSG==:1B1		;COMPLETE MESSAGE RECEIVED (END-OF-MESSAGE SEEN)
	NS%ABT==:1B2		;LINK ABORTED. NO DATA IS PRESENT IN BUFFER.
.NSOOK==:4			;OK TO SEND OUTPUT NOW
	.NSOMO==:1		;OUTPUT MAY NOW BE SENT
	.NSIMI==:2		;INTERRUPT MESSAGE MAY NOW BE SENT
.NSINT==:5			;INTERRUPT MESSAGE RECEIVED
.NSOBE==:6			;OUTPUT BUFFER IS NOW EMPTY
.NSDIS==:7			;DISCONNECT RECEIVED



;MCBDTE (FOR NSP) DEFINITIONS

INIRCV==1B0			;NODE INIT RECEIVED
FRKRUN==1B1			;FLAG IN MCBDTE TO SAY NETWORK IS INITED
NTSHUT==1B2			;IF SET, NSP IS IN "SHUTDOWN" STATE
NOTMCB==1B3			;NEIGHBOR IS NOT AN MCB
REQVER==1B4			;LINE REQUIRES VERIFICATION
INISNT==1B5			;NODE INIT SENT
LCSDTE==1B6			;THIS DTE IS ACTUALLY AN LCS SLOT
ACTIVE==1B7			;CIRCUIT IS ACTIVE
ENABLD==1B8			;CIRCUIT IS ENABLED
STRTIN==1B9			;CIRCUIT IS STARTING
DEFSTR (NAMCN,,17,3)		;COUNT OF BYTES IN NODE NAME

;DNASTA DEFINITIONS

MSKSTR SCSTA,DNASTA,3B1		;NODE STATE
MSKSTR LNSTA,DNASTA,1B2		;LINE STATE

MAXNDS==17			;Maximum number of nodes on a CI port

; NSP INTERNAL LINK ERROR CODES

NSPX1==:1			;DUPLICATE DRIVER VECTOR/CORRELATION CODE PAIR
NSPX2==:2			;NO SUCH LINK (INVALID NSP IDENTIFIER)
NSPX3==:3			;LINK NOT IN RUN STATE
NSPX4==:4			;PREVIOUS BUFFER STILL BEING PROCESSED
NSPX5==:5			;SUPERFLUOUS BUFFER - NO REQUEST OUTSTANDING
NSPX6==:6			;INT MSG UNAVAILABLE DUE TO FLOW CTL FAILURE

;MEMORY ERROR SAVE AREA DEFINTIONS

;DEFINITIONS FOR ERROR BLOCK

SBSLNK==:0			;OFFSET FOR LINK WORD
SBSERA==:1			;ERROR REG
SBSTYP==:2			;TYPE WORD AS FOLLOWS
 DEFSTR (SBSCN,SBSTYP,17,18)	;CONTROLLER NUMBER
 DEFSTR (SBSTP,SBSTYP,35,18)	;TYPE OF THIS ENTRY

;FOLLOWING ENTRIES ARE "TYPE" DEPENDENT.

;.PMMER DEFINTIONS

ERRSIZ==:11			;LENGTH OF A CER ENTRY
SBSEAD==:4			;OFFSET FOR ERROR ADDRESS
SBSSER==:5			;OFFSET FOR FIRST SERIAL NUMBER
DEFSTR (SBSSY,3,5,6)		;SYNDROME OF ERROR
DEFSTR (SBSBN,3,9,4)		;4-BIT BLOCK NUMBER
DEFSTR (SBSSB,3,15,6)		;SPARE BIT NUMBER
DEFSTR (SBHEB,3,16,1)		;HARD ERROR, NEEDS RECORDING

	SUBTTL Definitions for extended code

;Transfer to RESCD
DEFINE TORESCD (%LBL) <
	TSTMS0
	XJRST .+1
	XWD MSEC1,%LBL
	RESCD
%LBL:!
>

;Transfer to SWAPCD
DEFINE TOSWAPCD (%LBL) <
	TSTMS0
	XJRST .+1
	XWD MSEC1,%LBL
	SWAPCD
%LBL:!
>

;Transfer to extended resident code
DEFINE TOXRESCD (%LBL) <
	TSTMS0
	XJRST .+1
	%LBL
	XRESCD
%LBL:!
>

;Transfer to extended swappable code
DEFINE TOXSWAPCD (%LBL) <
	TSTMS0
	XJRST .+1
	%LBL
	XSWAPCD
%LBL:!
>

;Call a subroutine in another section from any non-zero section
DEFINE CALLX ($SECNR, $ADDR) <
	IFB <$SECNR>,<CALL @[$ADDR]>
	IFNB <$SECNR>,<CALL @[$SECNR,,$ADDR]>
>

;Call a subroutine in another section from MSEC1
DEFINE XCALL ($SECNR, $ADDR) <
	EA.ENT
	IFB <$SECNR>,<CALL @[$ADDR]>
	IFNB <$SECNR>,<CALL @[$SECNR,,$ADDR]>
>

;JSP to another section
DEFINE XJSP (AC, $SECNR, $ADDR) <
	EA.ENT
	IFB <$SECNR>,<JSP AC,@[$ADDR]>
	IFNB <$SECNR>,<JSP AC,@[$SECNR,,$ADDR]>
>

;CALLRET to another section
DEFINE XCALLRET ($SECNR, $ADDR) <
	EA.ENT
	IFB <$SECNR>,<XJRST [$ADDR]>
	IFNB <$SECNR>,<XJRST [$SECNR,,$ADDR]>
>

;Execute one or more instructions in section 1
DEFINE S1XCT (A) <
  IFE CURPSX-PXRESCD,<
	TORESCD
	A
	TOXRESCD
  >
  IFE CURPSX-PXSWAPCD,<
	TOSWAPCD
	A
	TOXSWAPCD
  >
  IFN <<CURPSX-PXRESCD>*<CURPSX-PXSWAPCD>>,<
	A
  >
>

;Define an entry point in extended resident code
DEFINE XRENT ($NAME,G) <
	RESCD
IFB <G>,<$NAME: XCALLRET (,X'$NAME)>
IFNB <G>,<$NAME:: XCALLRET (,X'$NAME)>
	XRESCD
X'$NAME:
.IF $NAME,INTERNAL,<INTERNAL X'$NAME>
>

;Define an entry point in extended swappable code
DEFINE XNENT ($NAME,G) <
	SWAPCD
IFB <G>,<$NAME: XCALLRET (,X'$NAME)>
IFNB <G>,<$NAME:: XCALLRET (,X'$NAME)>
	XSWAPCD
X'$NAME:
.IF $NAME,INTERNAL,<INTERNAL X'$NAME>
>

;[7.1024]
;XENT references an extended section symbol created by XRENT or XNENT
DEFINE XENT($ADDR) <X'$ADDR>

;Force an expression to go polish so LINK will resolve it with 30-bit
; addresses instead of MACRO with 18-bit relocation.
DEFINE XADDR. ($ADDR) <<$ADDR+<RSKP-RSKP>>>

	SUBTTL Symbol table definitions

	.UNDFD==0		;Undefined symbol table type
	.R50D==1		;Radix-50 defined symbol table
	.R50U==2		;Radix-50 undefined symbol table
	.STLEN==0		;Offset of length word in subtable
	.STDAT==0		;   "    " data type "  "     "
	.STPTR==1		;   "    " address   "  "     "
	SY%TYP==77B5		;Type field mask
	SY%LEN==^-SY%TYP	;Length field mask

	SUBTTL Definitions for Canonical Terminal Support (CTS)

;Initialize flags for Dynamic Libraries and Canonical Terminal Support

IFNDEF DYNFLG,<DYNFLG==:0>	;If DYNFLG not defined say no Dynamic Libraries
IFNDEF CTSFLG,<CTSFLG==:0>	;If CTSFLG not defined say no Canonical
				;  Terminal Support
IFN CTSFLG,<DYNFLG==:1>		;Use of CTS implies use of Dynamic Libraries


;Conditional Assembly Macros for Dynamic Libraries and Canonical Terminal
;  Support
DEFINE	FTDYN <IFN DYNFLG,>	;Assemble if Dynamic Libraries allowed
DEFINE	FTCTS <IFN CTSFLG,>	;Assemble code if Canonical Terminal
				;  Support allowed

;Flags for Library Linking Routines
LK%NAM==:1B0			;Pointer to Library Name is given in AC's if
				;  else in User LTV
LK%PPC==:1B1			;Pointer is to Previous Context (applicable
				;  if LK%NAM is set)
LK%LTM==:1B2			;Local Transfer Vector in Monitor Address Space
				;  if set, else in User Address Space
LK%TLN==:1B3			;Terminal Line Number is given in AC's
LK%IML==:1B4			;Ignore Any Previously Mapped Library


;CTS State Block
.CTVCD==:1			;Pointer to Vector Directory
.CTBTL==:2			;Pointer to Bound Terminal List
.CTLID==:3			;Two word fork lock ID
.CTKLL==:5			;Pointer to Known Library List
CTSBLN==:.CTKLL+1		;Length of CTS State Block


;Vector State Block
.VSFGS==:1			;Flags
	VS%LIB==:1B0		;Library is Present
	VS%LVA==:1B1		;Local Transfer Vector at .VSLVA
.VSTVA==:2			;Address of Transfer Vector
.VSLVA==:3			;Address (within Monitor) of Local Transfer
				;  Vector
VSBLN==:.VSLVA+1		;Length of Vector State Block


;Known Library Block
.KLNXT==:1			;Pointer to next Known Library Block
.KLFGS==:2			;Flags
	KL%CTS==:1B0		;Library is a CTS Library
.KLDIR==:3			;Structure Number,,Directory Number
.KLFDB==:4			;Address of FDB
.KLSHR==:5			;Line Number,,Share Count
.KLLDB==:6			;User Address of Library Descriptor Block
.KLTVA==:7			;User Address of Library Transfer Vector
KLBLN==:.KLTVA+1		;Length of Known Library Block

DEFSTR KLSTR,.KLDIR,17,18	;Structure Number
DEFSTR KLDIR,.KLDIR,35,18	;Directory Number
DEFSTR KLTLN,.KLSHR,17,18	;Terminal Line Number
DEFSTR KLSHR,.KLSHR,35,18	;Share Count


;Miscellaneous Symbols
TDBSIZ==1			;Number of pages to be mapped for a terminal
				;  data base
CTSCSZ==1000			;Number of pages in CTS section area
	SUBTTL		STORAGE DEFINITIONS FOR ATSSRV

;THIS CLUMSY SET OF DEFINITIONS IS NECESSARY TO MAKE MACRO COOPERATE.
;THE END RESULT IS A MASK THAT REPRESENTS 30 OR MORE BITS OF ADDRESS
;AND A VALUE THAT REPRESENTS -1 IN THE MASK.  THE SIZE OF THE ADDRESS
;CAN BE CHANGED BY ALTERING THE ARGUMENTS FOR THE MASKB MACRO, AND NO
;CODE NEED BE CHANGED

ADRMSK==MASKB(6,35)
ADRSHF==^D35-POS(ADRMSK)
ADRNEG==-ADRSHF
ADRVAL==ADRMSK_ADRNEG


;DATA FOR AN APPLICATION TERMINAL

;EACH ACTIVE APPLICATIONS TERMINAL HAS THIS DATA BASE. FOR A GIVEN
;HTN, THE ROUTINE GTATDB PROVIDES THE ADDRESS OF THIS BLOCK OF DATA

	DEFSTR (ATLEN,0,35,18)	;LENGTH OF THIS BLOCK IN WORDS
	MSKSTR (ATJFN,1,ADRMSK)	;ADDRESS OF JFN DATA

;POINTERS TO PIPES

	MSKSTR (ATDAP,2,ADRMSK)	;ADDRESS OF DATA PIPE DATA
	MSKSTR (ATCOP,3,ADRMSK)	;ADDRESS OF CONTROL PIPE DATA

;STATUS WORDS

		.ATMST==:4
	DEFSTR (ATMST,.ATMST,35,36)	;MONITOR STATUS BITS
		AT%SCH==:1B0	;STATUS CHANGED SINCE LAST REPORT
		MSKSTR (ATSCH,.ATMST,AT%SCH)
		AT%NIO==:177B7	;TERMINAL NOT AVAILABLE FOR I/O IF ANY BIT SET
		MSKSTR (ATNIO,.ATMST,AT%NIO)
		AT%BZY==:1B1	;HTN IS BUSY - NRM NEGOTIATIONS UNDERWAY
		MSKSTR (ATBZY,.ATMST,AT%BZY)
		AT%ABR==:1B2	;HTN IS IN ABORT MODE
		MSKSTR (ATABR,.ATMST,AT%ABR)
		AT%NRH==:1B3	;REMOTE NRM RELEASED HTN
		MSKSTR (ATNRH,.ATMST,AT%NRH)
		AT%GTD==:1B4	;GET THE TERMINAL (ATS TO NRM)
		MSKSTR (ATGTD,.ATMST,AT%GTD)
		AT%RLD==:1B5	;RELEASE THE TERMINAL (ATS TO NRM)
		MSKSTR (ATRLD,.ATMST,AT%RLD)
		AT%URH==:1B6	;USER RELEASED HTN (WITH OR WITHOUT ABORT)
		MSKSTR (ATURH,.ATMST,AT%URH)
		AT%UAH==:1B7	;USER RELEASED HTN WITH ABORT
		MSKSTR (ATUAH,.ATMST,AT%UAH)
		AT%RIP==:1B8	;RELEASE OF HTN IS IN PROGRESS
		MSKSTR (ATRIP,.ATMST,AT%RIP)
		AT%EOM==:1B13	;INPUT INCLUDES END-OF-MESSAGE
		MSKSTR (ATEOM,.ATMST,AT%EOM)
		AT%XOF==:7B17	;TERMINAL IS XOFF'D IF ANY BIT SET
		MSKSTR (ATXOF,.ATMST,AT%XOF)
		AT%XMC==:1B15	;XOFF'D BECAUSE MCB SENT XOFF
		MSKSTR (ATXMC,.ATMST,AT%XMC)
		AT%XQU==:1B16	;XOFF'D BECAUSE ATS COULDN'T QUEUE MESSAGE
		MSKSTR (ATXQU,.ATMST,AT%XQU)
		AT%XFR==:1B17	;XOFF'D BECAUSE NO FREE SPACE FOR MESSAGE
		MSKSTR (ATXFR,.ATMST,AT%XFR)
		DEFSTR (ATSTR,.ATMST,35,18) ;STATE FOR NRM PROCESSING
		.ATUST==:5
	DEFSTR (ATUST,.ATUST,35,36) ;USER STATUS BITS
		MSKSTR (ATOPN,.ATUST,AT%OPN) ;HTN IS OPEN AND USABLE
		MSKSTR (ATTCL,.ATUST,AT%TCL) ;NRM CLOSED TERMINAL VIA STATUS-REPORT
		MSKSTR (ATDHT,.ATUST,AT%DHT) ;DEASSIGNING HTN
		MSKSTR (ATTXF,.ATUST,AT%TXF) ;TERMINAL IS XOFF'D
		MSKSTR (ATUND,.ATUST,AT%UND) ;DEVICE REQUESTED IS UNDEFINED
		MSKSTR (ATNAV,.ATUST,AT%NAV) ;DEVICE REQUESTED IS NOT AVAILBLE
		MSKSTR (ATOFL,.ATUST,AT%OFL) ;DEVICE REQUESTED IS OFFLINE
		MSKSTR (ATFUL,.ATUST,AT%FUL) ;SERVER IS FULL
		MSKSTR (ATUNS,.ATUST,AT%UNS) ;DEVICE TYPE IS UNSUPPORTED
		MSKSTR (ATREJ,.ATUST,AT%REJ) ;NODE NRM REJECTED THE REQUEST
		MSKSTR (ATMIE,.ATUST,AT%MIE) ;MONITOR INTERNAL ERROR
		MSKSTR (ATSTF,.ATUST,AT%STF) ;VT62 STARTUP FAILED
		MSKSTR (ATCRJ,.ATUST,AT%CRJ) ;CONNECTION WAS REJECTED
		MSKSTR (ATNDP,.ATUST,AT%NDP) ;DATA PIPE IS NOT OPEN
		MSKSTR (ATSER,.ATUST,AT%SER) ;STATUS REORT ERROR CODE (SEE BELOW)

;IDENTIFIERS FOR TERMINALS (BOUNDARY NODE'S, HOST NODE'S, USER'S)

	DEFSTR (ATBTN,6,17,18)	;BOUNDARY TERMINAL NUMBER
	DEFSTR (ATHTN,6,35,18)	;HOST TERMINAL NUMBER
	DEFSTR (ATUTN,7,35,36)	;USER TERMINAL NUMBER

;FIELDS FOR I/O

	DEFSTR (ATICT,10,17,18)	;COUNT OF INPUT DATA
	DEFSTR (ATOCT,10,35,18)	;BYTES NEEDED FOR OUTPUT
	MSKSTR (ATIAD,11,ADRMSK) ;ADDRESS OF FIRST INPUT BUFFER
	DEFSTR (ATIBP,12,35,36)	;BYTE POINTER TO INPUT

;LINKS TO OTHER TERMINALS

	MSKSTR (ATLJF,13,ADRMSK) ;ADDRESS OF NEXT TERMINAL BLOCK FOR JFN
	MSKSTR (ATLDP,14,ADRMSK) ;ADDRESS OF NEXT TERMINAL BLOCK FOR DATA PIPE
	MSKSTR (ATLBP,15,ADRMSK) ;ADDRESS OF NEXT TERMINAL BLOCK FOR BACKGROUND PROCESS

;NAME OF THE DEVICE

	DEFSTR (ATDEV,16,35,36)	;ADDRESS OF FREE SPACE CONTAINING DEVICE NAME
		.ATLCK==:17	;LOCK WORD
	DEFSTR (ATSIX,20,35,36) ;DEVICE NAME IN SIXBIT
	ATSIZ==:21		;SIZE OF BLOCK

;DATA FOR A PIPE

;EACH OPEN (OR BEING OPENED) LOGICAL LINK TO EITHER A DIALOGUE MANAGER
;(A DATA PIPE) OR A RESOURCE MANAGER (A CONTROL PIPE) HAS THIS DATA
;BASE. THE DATA PIPES ARE CHAINED TOGETHER STARTING AT THE CELL
;ATDPHD; THE CONTROL PIPES ARE CHAINED TOGETHER STARTING AT ATCPHD.
;IN BOTH CASES, OFFSET APLPS POINTS TO THE NEXT ENTRY IN THE CHAIN.

;NOTE: THESE BLOCKS TEMPORARILY CONTAIN OFFSET .APADR, WHICH IS THE
;ADDRESS OF NSP'S DATA FOR THE PIPE. IT CAN BE REMOVED BEFORE SHIPMENT
;TO SAVE SPACE

	DEFSTR (APLEN,0,35,18)	;LENGTH OF THIS BLOCK IN WORDS
	DEFSTR (APTYP,1,2,3)	;TYPE OF LINK
		.APDAP==:0	;DATA PIPE
		.APCOP==:1	;CONTROL PIPE
	DEFSTR (APSTS,1,17,15)	;STATUS
		AP%NBP==:177B9	;NEED ACTION BY THE BACKGROUND PROCESS
		MSKSTR (APNBP,1,AP%NBP)
		AP%NIB==:1B3	;NEED INPUT BUFFER
		MSKSTR (APNIB,1,AP%NIB)
		AP%NRI==:1B4	;NEED TO READ INTERRUPT MESSAGE
		MSKSTR (APNRI,1,AP%NRI)
		AP%NOD==:1B5	;NEED TO READ OPTIONAL DATA
		MSKSTR (APNOD,1,AP%NOD)
		AP%NIO==:37B10	;PIPE IS NOT FULLY OPEN IF ANY BIT SET
		MSKSTR (APNIO,1,AP%NIO)
		AP%NCL==:1B6	;NEED TO CLOSE THIS PIPE
		MSKSTR (APNCL,1,AP%NCL)
		AP%NAB==:7B9	;NEED TO ABORT PIPE IF ANY BIT SET
		MSKSTR (APNAB,1,AP%NAB)
		AP%CLR==:1B7	;CLOSED BY REMOTE PROCESS
		MSKSTR (APCLR,1,AP%CLR)
		AP%CRJ==:1B8	;CONNECT-REJECT RECEIVED
		MSKSTR (APCRJ,1,AP%CRJ)
		AP%PER==:1B9	;PROTOCOL ERROR OCCURRED
		MSKSTR (APPER,1,AP%PER)
		AP%WCC==:1B10	;WAITING FOR CONNECT-CONFIRM
		MSKSTR (APWCC,1,AP%WCC)
		AP%EOM==:1B14	;EXTRA MESSAGE HAS END-OF-MESSAGE
		MSKSTR (APEOM,1,AP%EOM)
		AP%OTO==:1B15	;LIMITED TO ONE TERMINAL
		MSKSTR (APOTO,1,AP%OTO)
		AP%NRO==:1B16	;NSP REFUSED OUTPUT ON THIS LINK
		MSKSTR (APNRO,1,AP%NRO)
		AP%TXF==:1B17	;A TERMINAL WAS XOFF'D BECAUSE QUEUE WAS FULL
		MSKSTR (APTXF,1,AP%TXF)
	DEFSTR (APNIR,1,23,6)	;NO. TIMES TRIED TO READ INTERRUPT MESSAGE
	DEFSTR (APNOT,1,35,12)	;NUMBER TERMINALS ASSIGNED TO THE LINK
	DEFSTR (APNSP,2,35,36)	;NSP'S IDENTIFIER FOR THE LINK
	MSKSTR (APOAD,3,ADRMSK) ;ADDRESS OF FIRST OUTPUT MESSAGE
	MSKSTR (APLPS,4,ADRMSK) ;ADDRESS OF NEXT LINK BLOCK FOR SYSTEM
	MSKSTR (APLBP,5,ADRMSK) ;ADDRESS OF NEXT LINK BLOCK FOR BACKGROUND PROCESS
	DEFSTR (APSIX,6,35,36)	;NODE NAME IN SIXBIT
		.APADR==:7	;* * *NSP'S ADDRESS OF DATA
	DEFSTR (APREA,10,35,18)	;REASON CODE FOR CONNECT-REJECT
		CPSIZ==:11	;SIZE OF A CONTROL PIPE'S DATA

;THE FOLLOWING OFFSETS ARE USED FOR DATA PIPES ONLY

	MSKSTR (APLAT,11,ADRMSK) ;ADDRESS OF FIRST TERMINAL BLOCK
	DEFSTR (APOBJ,12,17,18)	;OBJECT NUMBER OF REMOTE TASK
	DEFSTR (APBUL,12,35,18)	;BULA (REMOTE END'S ID FOR THE LINK)
	DEFSTR (APJOB,13,17,18)	;JOB THAT CREATED THIS PIPE
	DEFSTR (APJFN,13,35,18)	;JFN THAT CREATED THIS PIPE

;LOCATIONS FOR OUTPUT

	MSKSTR (APXAD,14,ADRMSK) ;ADDRESS OF FIRST XOFF'D OUTPUT MESSAGE
	DEFSTR (APOCT,15,17,18)	;NUMBER OF OUTPUT MESSAGES QUEUED
	DEFSTR (APOBS,15,35,18)	;SIZE OF OUTPUT BUFFER (WITHOUT HEADER)

;LOCATIONS FOR THE 'SECOND INPUT MESSAGE'

	MSKSTR (APSIA,16,ADRMSK) ;ADDRESS OF SECOND INPUT MESSAGE
	DEFSTR (APSIB,17,35,36)	;BYTE POINTER FOR SECOND MESSAGE
	DEFSTR (APSIT,20,17,18)	;TERMINAL FOR SECOND MESSAGE
	DEFSTR (APSIC,20,35,18)	;COUNT FOR SECOND MESSAGE

;LOCATIONS FOR ACCUMULATING AN INPUT MESSAGE BEFORE COPYING IT TO A
;TERMINAL

	MSKSTR (APIAD,21,ADRMSK) ;ADDRESS OF FIRST INPUT BUFFER
	MSKSTR (APIAL,22,ADRMSK) ;ADDRESS OF LAST INPUT BUFFER
	DEFSTR (APINO,23,5,6)	;CURRENT NO. OF BUFFERS IN INPUT MESSAGE
	DEFSTR (APICT,23,17,12)	;NO. OF BYTES IN CURRENT INPUT MESSAGE
	DEFSTR (APIHT,23,35,18)	;HTN OF INPUT MESSAGE BEING COLLECTED
	DEFSTR (APIBP,24,35,36) ;BYTE POINTER FOR INPUT MESSAGE
		DPSIZ==:25	;;SIZE OF A DATA PIPE'S DATA

;NOTES ON PIPE STATUS:
;	AP%NBP=ALL BITS THAT REQUIRE ACTION BY THE BACKGROUND PROCESS
;	AP%NIO=ALL BITS THAT MAKE THE PIPE UNAVAILABLE FOR I/O
;	AP%NAB=ALL BITS THAT CAUSE A PIPE TO BE ABORTED BY THE BACKGROUND
;		PROCESS

;DATA FOR A JFN

	DEFSTR (AJLEN,0,35,18)	;LENGTH OF THIS BLOCK
	DEFSTR (AJMOD,1,5,6)	;MODE
	DEFSTR (AJFLG,1,17,12)	;FLAGS
	DEFSTR (AJCDA,2,17,18)	;CHANNEL FOR DATA ARRIVAL INTERRUPT
	DEFSTR (AJCST,2,35,18)	;CHANNEL FOR STATUS ARRIVAL INTERRUPT
	MSKSTR (AJLAT,3,ADRMSK) ;ADDRESS OF FIRST TERMINAL ON JFN
	MSKSTR (AJLIN,4,ADRMSK)	;ADDRESS OF NEXT TERMINAL WITH INPUT
	DEFSTR (AJPRO,5,17,18)	;PROCESS
	DEFSTR (AJJFN,5,35,18)	;JFN
		.AJSLK==:6	;LOCK ON STRUCTURE FOR THIS JFN
		.AJCHG==:7	;NUMBER OF TERMINALS WITH CHANGED STATUS
		.AJICT==:10	;NUMBER OF TERMINALS WITH INPUT
	MSKSTR (AJMSK,11,ADRMSK) ;FIRST WORD OF TERMINAL MASK
		AJSIZ==:12	;SIZE OF JFN BLOCK

;NOTE: MASK WORDS ARE CONTIGUOUS AND CONTAIN ONE BIT POSITION PER
;HTN

;DATA FROM THE DATA PIPE THAT HAS BEEN RECEIVED AT OUR END.
;INTERRUPT MESSAGES ARE QUEUED FOR THE BACKGROUND PROCESS IN THIS FORM.
;DATA MESSAGES ARE QUEUED FIRST ON THE PIPE, THEN ON THE TERMINAL.

	DEFSTR (DILEN,0,35,18)	;LENGTH OF THIS BLOCK IN WORDS
	DEFSTR (DIBYT,1,35,18)	;NUMBER OF BYTES IN MESSAGE
	MSKSTR (DILNK,2,ADRMSK)	;ADDRESS OF NEXT BLOCK IN QUEUE
		DIDAT==:3	;FIRST WORD CONTAINING DATA

REPEAT 0,<
!-------------------------------------------------------!
!                           !      Length in words      !
!-------------------------------------------------------!
!                           !      Number of bytes      !
!-------------------------------------------------------!
!            Address of next block on chain             !
!-------------------------------------------------------!
!   data    !   data    !    ...     !   data    !      !
+-------------------------------------------------------+
>

;OUTPUT MESSAGE FOR DATA PIPE QUEUED TO BE SENT

	DEFSTR (DOLEN,0,35,18)	;LENGTH OF THIS BLOCK IN WORDS
	DEFSTR (DOEOM,1,0,1)	;SET IF END-OF-MESSAGE
	DEFSTR (DOREL,1,1,1)	;NSP HAS RELEASED THIS BUFFER
	DEFSTR (DOQUE,1,2,1)	;ATS HAS QUEUED THIS BUFFER
	DEFSTR (DOSEG,1,17,9)	;SEGMENT NUMBER
		DOMAX==:FLD(777,DOSEG) ;MAXIMUM SEGMENT NUMBER
	DEFSTR (DOBYT,1,35,18)	;NUMBER OF BYTES IN THIS SEGMENT
	MSKSTR (DONMS,2,ADRMSK)	;ADDRESS OF NEXT MESSAGE FOR THIS LINK
	MSKSTR (DONSG,3,ADRMSK)	;ADDRESS OF NEXT SEGMENT FOR THIS MESSAGE
		DODAT==:4	;FIRST WORD CONTAINING DATA

REPEAT 0,<
+-------------------------------------------------------+
!                           !      Length in words      !
!-------------------------------------------------------!
!!!!          ! Segment No. !      Number of bytes      !
!-------------------------------------------------------!
!                Address of next message                !
!-------------------------------------------------------!
!                Address of next segment                !
!-------------------------------------------------------!
!                         Data                          !
!-------------------------------------------------------!
\                                                       \
\                                                       \
!-------------------------------------------------------!
!                         Data                          !
+-------------------------------------------------------+
>
;OUTPUT FOR CONTROL PIPE QUEUED TO BE SENT
;INPUT FROM CONTROL PIPE QUEUED FOR THE BACKGROUND PROCESS

	DEFSTR (COLEN,0,35,18)	;LENGTH OF THIS BLOCK IN WORDS
	DEFSTR (COREL,1,1,1)	;NSP HAS RELEASED THIS BUFFER
	DEFSTR (COQUE,1,2,1)	;ATS HAS QUEUED THIS BUFFER
	DEFSTR (COBYT,1,35,18)	;NUMBER OF BYTES IN MESSAGE
	MSKSTR (COLNK,2,ADRMSK)	;ADDRESS OF NEXT MESSAGE ON THE CHAIN
	MSKSTR (COPIP,3,ADRMSK)	;ADDRESS OF CONTROL PIPE DATA
		CODAT==:4	;FIRST WORD CONTAINING DATA


repeat 0,<
+-------------------------------------------------------+
!                           !      Length in words      !
!-------------------------------------------------------!
!!!!                        !      Number of bytes      !
!-------------------------------------------------------!
!            Address of next block on chain             !
!-------------------------------------------------------!
!             Address of control pipe data              !
!-------------------------------------------------------!
!   data    !   data    !    data    !   data    !      !
!-------------------------------------------------------!
\                                                       \
\                                                       \
!-------------------------------------------------------!
!    data   !   data    !    data    !   data    !      !
+-------------------------------------------------------+
>

REPEAT 0,<
;DATA FROM CONTROL PIPE QUEUED FOR BACKGROUND PROCESS
;NOT USED

	DEFSTR (CIBYT,0,17,18)	;NUMBER OF BYTES IN MESSAGE
	DEFSTR (CILEN,0,35,18)	;LENGTH OF THIS BLOCK IN WORDS
	MSKSTR (CILNK,1,ADRMSK)	;ADDRESS OF NEXT BLOCK IN QUEUE
		CIDAT==:2	;FIRST WORD CONTAINING DATA
>

;DATA BY LINK TYPE

ILSIZE==:0
	DEFSTR (ILBSZ,ILSIZE,17,18) ;SIZE OF INPUT BUFFER IN WORDS
	DEFSTR (ILDSZ,ILSIZE,35,18) ;SIZE OF DATA BLOCK FOR THIS TYPE
ILNSPV==:1
	MSKSTR (ILVEC,ILNSPV,ADRMSK) ;ADDRESS OF VECTOR FOR NSP
ILMISC==:2
	DEFSTR (ILOUT,ILMISC,17,9) ;MAXIMUM NUMBER OF BUFFERED OUTPUT MESSAGES
	DEFSTR (ILSEG,ILMISC,35,18) ;SEGMENT SIZE FOR OUTPUT (WORDS)
ILOBJT==:3

;STORAGE FOR READING OPTIONAL DATA WHEN DATA PIPE IS CONNECTED

ATODWD==:6			;NUMBER OF WORDS NEEDED FOR OPTIONAL DATA
				; (16 BYTES PLUS A HEADER WORD)
	DEFSTR (ADLEN,0,35,18)	;NUMBER OF WORDS IN BLOCK
	DEFSTR (ADBYT,1,35,18)	;NUMBER OF BYTES IN OPTIONAL DATA
		ADDAT==:2	;OFFSET FOR START OF OPTIONAL DATA

;STORAGE FOR READING INTERRUPT MESSAGE

ATIMWD==:4			;WORDS NEEDED FOR INTERRUPT MESSAGE -
				; HEADER PLUS 16 8-BIT BYTES

;STORAGE FOR SAVING DEVICE NAME WITH TERMINAL DATA

ATDVWD==:4			;LENGTH OF FREE SPACE FOR TERMINAL NAME-
				; HEADER PLUS 6 8-BIT BYTES
	DEFSTR (AVLEN,0,35,18)	;NUMBER OF WORDS IN BLOCK
	DEFSTR (AVBYT,1,35,18)	;NUMBER OF BYTES IN DEVICE NAME
		AVDAT==:2	;OFFSET FOR FIRST BYTE

;STORAGE FOR READING HOST NAME

ATHNWD==:3			;LENGTH OF FREE SPACE FOR HOST NAME -
				; HEADER PLUS 6 ASCII CHARACTERS AND NULL
	DEFSTR (AHLEN,0,35,18)	;NUMBER OF WORDS IN BLOCK
		AHDAT==:1	;OFFSET OF FIRST WORD OF NAME



	END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     