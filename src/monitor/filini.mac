; UPD ID= 8516, RIP:<7.MONITOR>FILINI.MAC.6,   9-Feb-88 15:35:56 by GSCOTT
;TCO 7.1218 - Update copyright date.
; UPD ID= 8412, RIP:<7.MONITOR>FILINI.MAC.5,   4-Feb-88 12:06:38 by GSCOTT
;TCO 7.1210 - Set BADBAK, BADIDX, BADXT2, FILBAK, FILBOT, FILCCD, FILFEF,
; FILHOM, FILJB1, FIXBAD, FIXBDB, and NOBTB normally not dumpable.
; UPD ID= 256, RIP:<7.MONITOR>FILINI.MAC.4,   4-Nov-87 16:44:49 by MCCOLLUM
;TCO 7.1112 - Fix JBFINI to use LGSIDX. Make INISTR global
; UPD ID= 125, RIP:<7.MONITOR>FILINI.MAC.3,  23-Sep-87 15:43:58 by MCCOLLUM
;TCO 7.1063 - Use STRJB DEFSTR in FRESTR
; Edit 7172 to FILINI.MAC by MCCOLLUM on 25-Oct-85, for SPR #20513
; Set FB%NDL for non-directory files on <ROOT-DIRECTORY> 
; Edit 7170 to FILINI.MAC by MCCOLLUM on 22-Oct-85
; Clear initing fork number in SDBSTS in routine FRESTR. 
; UPD ID= 2073, SNARK:<6.1.MONITOR>FILINI.MAC.27,   3-Jun-85 14:34:56 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 1950, SNARK:<6.1.MONITOR>FILINI.MAC.26,   9-May-85 17:20:52 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1877, SNARK:<6.1.MONITOR>FILINI.MAC.25,   4-May-85 12:15:55 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1845, SNARK:<6.1.MONITOR>FILINI.MAC.24,  30-Apr-85 12:04:18 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1715, SNARK:<6.1.MONITOR>FILINI.MAC.23,   5-Apr-85 14:08:09 by MCCOLLUM
;TCO 6.1.1238 - Fix BUG. documentation
; UPD ID= 4796, SNARK:<6.MONITOR>FILINI.MAC.22,  11-Sep-84 10:25:18 by GRANT
;Minor fixes to UPD 4226.  In FILRFS, make temporary MXDIRN one bigger and
;reset MXDIRN to its real value when refresh is complete.
; UPD ID= 4778, SNARK:<6.MONITOR>FILINI.MAC.21,  30-Aug-84 12:35:31 by TBOYLE
;TCO 6.2208 (QAR 706004) Output msg if idxtab being reset for PPN support.
; UPD ID= 4539, SNARK:<6.MONITOR>FILINI.MAC.20,  15-Jul-84 10:31:18 by PURRETTA
;Update copyright notice
; UPD ID= 4307, SNARK:<6.MONITOR>FILINI.MAC.19,   7-Jun-84 16:59:06 by MOSER
;TCO 6.2059 - REMOVE CROCK WHERE JOBS WERE STARTED WITH ALL CAPABILITIES
; UPD ID= 4226, SNARK:<6.MONITOR>FILINI.MAC.18,  16-May-84 16:13:17 by GRANT
;Make 143$G work by temporarily declaring MXDIRN only as large as needed during
;initial directory creaation.  JSB free space is used during the refresh
;procedure and the addition of the PPNs has made it impossible to fit everything
;in a page if the real MXDIRN were used.
;In FILINI, remove runtime checks for EXADDR.
;In FILCR2, ERJMP after the CRDIR%.
;Add some ^Ls.
; UPD ID= 3827, SNARK:<6.MONITOR>FILINI.MAC.17,  29-Feb-84 18:16:06 by PAETZOLD
;TCO 6.1733 - Do not call NETINI anymore.  Delete old edit history.
; UPD ID= 2553, SNARK:<6.MONITOR>FILINI.MAC.16,   2-Jun-83 22:45:36 by MURPHY
;Take out spurious SE0ENT in code which creates FE filesystem.
; UPD ID= 2176, SNARK:<6.MONITOR>FILINI.MAC.15,   6-Apr-83 07:18:14 by FLEMMING
; UPD ID= 1594, SNARK:<6.MONITOR>FILINI.MAC.14,  29-Dec-82 10:33:05 by DONAHUE
;TCO 6.1172 - SET AR%EXM IN BACKUP-ROOT-DIRECTORY AND INDEX-TABLE
; UPD ID= 1234, SNARK:<6.MONITOR>FILINI.MAC.13,  24-Sep-82 12:20:10 by LEACHE
;TCO 6.1273 ADD MS%ASG
; UPD ID= 924, SNARK:<6.MONITOR>FILINI.MAC.12,  11-Jun-82 17:53:36 by MURPHY
;TCO 6.1030 - Node names in filespecs; etc.
;Revise DTB format; get rid of double skips on NLUKD, etc.
; UPD ID= 840, SNARK:<6.MONITOR>FILINI.MAC.11,   4-Jun-82 22:02:58 by MURPHY
;TCO 6.1147 - Move bugdefs from BUGS.MAC to here and put them in-line.
; UPD ID= 575, SNARK:<6.MONITOR>FILINI.MAC.10,   1-Apr-82 21:36:43 by MURPHY
;TCO 6.1074 - Revise build procedures, eliminate EXADF, PROKL, etc.
; UPD ID= 137, SNARK:<6.MONITOR>FILINI.MAC.9,  19-Oct-81 15:52:36 by COBB
;TCO 6.1029 - CHANGE SE1CAL TO EA.ENT
; UPD ID= 69, SNARK:<5.MONITOR>FILINI.MAC.8,  23-Jul-81 14:08:18 by GRANT
;TCO 5.1431 - give PS:<OPERATOR> IPCF when creating the directory
; UPD ID= 2055, SNARK:<5.MONITOR>FILINI.MAC.7,  21-May-81 08:50:42 by LEACHE
;TCO 5.1338 - Add <SYSTEM-ERROR> to CRDTAB
; UPD ID= 1526, SNARK:<5.MONITOR>FILINI.MAC.6,   6-Feb-81 12:47:11 by ZIMA
;TCO 5.1258 - remove call to DMPINI in FILINI.
; UPD ID= 1004, SNARK:<5.MONITOR>FILINI.MAC.5,  11-Sep-80 18:03:27 by GRANT
;Change MONX01 to MONX02 in MAKIDX routine
; UPD ID= 659, SNARK:<5.MONITOR>FILINI.MAC.2,  16-Jun-80 17:23:07 by KONEN
;TCO 5.1063 -
;When mounting public structure, use structure name, rather than PS for alias

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


	SEARCH MONSYM,PROLOG
	TTITLE FILINI
	SWAPCD

;LOCAL ITEMS IN STG.MAC

PSNUM==:0			;STRUCTURE NUMBER (OFFSET IN STRTAB) FOR
				;THE PUBLIC STRUCTURE

EXTN <INIDEV>

ROOTDN==:1			;ROOT-DIRECTORY DIRECTORY NUMBER
SYSTDN==:2			;SYSTEM DIRECTORY NUMBER
SUBSDN==:3			;SUBSYS DIRECTORY NUMBER
ACNTDN==:4			;ACCOUNTS DIRECTORY NUMBER
OPERDN==:5			;OPERATOR DIRECTORY NUMBER
SPOLDN==:6			;SPOOL DIRECTORY NUMBER
NSYSDN==:7			;<NEW-SYSTEM>
NSUBDN==:10			;<NEW-SUBSYS>

NRESDN==:17			;NUMBER OF RESERVED DIR NUMBERS FOR DEC

;SPECIAL AC DEFINITIONS USED HEREIN

DEFAC (STS,P1)
DEFAC (JFN,P2)			;SEE GTJFN FOR FUNCTIONS
DEFAC (DEV,P4)
DEFAC (F1,P5)

RS BKOFN,1			;OFN OF BACKUP FILE DURING RECONSTRUCTION

; Initialize file stuff
;CALLED BY MEXEC WHEN A JOB IS STARTED.  INITIALIZES THE JSB

JBFINI::MOVEI A,JSFREE		; Origin of free area in jsb
	HRLOM A,JSBFRE		; To header
	MOVEI A,IJSFRE
	HRRZM A,JSFREE		; One big block free
	MOVEM A,JSBFRE+2
	SETOM JSBFRE+1
	MOVE A,[XWD JSFREE+IJSFRE,JSFREE]
	MOVEM A,JSBFRE+4
	MOVEI A,MAXLW+1
	MOVEM A,JSBFRE+3
	MOVE A,[XWD JBCOR,JBCOR+1]
	SETZM JBCOR
	BLT A,JBCOR+3
	UNLOCK JBCLCK
	UNLOCK JSFLCK		; INIT DEALL STACK LOCK
	UNLOCK JSSTLK		;INITIALIZE JSB STRUCTURE LOCK
	MOVEI C,FREJP		; Start with frejp page
IJFRLP:	MOVE A,C
	LSH A,9
	PUSH P,C
	CALL RELPAG
	POP P,C
	CAIGE C,JSLST-1
	AOJA C,IJFRLP
	SETOM PRIMRY		; Primary io to controlling tty
	SETOM JFNLCK		; Unlock jfnlck
	SETOM LNMLCK		; UNLOCK LOGICAL NAME LOCK
	MOVEI A,1
	MOVEM A,MAXJFN
	MOVE A,LGSIDX		;[7.1112]Get number of Login Structure
	MOVE A,STRTAB(A)	;[7.1112]Get SDB address
	LOAD A,STRUC,(A)	;GET ITS UNIQUE STRUCTURE CODE
	STOR A,JSUC		;SAVE AS CONNECTED STRUCTURE CODE
	MOVEI A,SYSTDN		;GET DIRECTORY NUMBER FOR <SYSTEM>
	STOR A,JSDIR		;MAKE THIS THE CONNECTED DIRECTORY
	MOVE A,[[3
		 ASCIZ "OPERATOR"],,USRNAM]
	BLT A,USRNAM+2		;INIT USER NAME STRING
	MOVE A,[[3
		 ASCIZ "OPERATOR"],,ACCTSL]
	BLT A,ACCTSR+1		;INIT ACCT STRING
	SETZRO JSCDF		;MARK THAT THERE IS NO DIR STRING
	MOVE B,JOBNO
	SETZM JOBDIR(B)		;INDICATE NOT YET LOGGED IN

; SET INITIAL JOB CAPABILITIES CURRENTLY THESE ARE:

	MOVE T1,JOBCAP		;GET NORMAL STARTUP CAPABILITIES
	MOVEM T1,CAPMSK		;SAVE 'EM
	MOVEM T1,CAPENB
	; ..
	; ..

;INITIALIZE THE 3-WORD BLOCKS IN THE JSB FOR STRUCTURES.  THIS CODE MERELY
;SETS THE STRUCTURE NUMBER TO -1 TO INDICATE THE SLOT IS FREE.  GTSTOF
;INITIALIZES THE REST OF THE BLOCK WHEN IT IS ASSIGNED.

	MOVSI T1,-STRN
	HRRI T1,JSSTRT		;T1/(-COUNT,,ADDRESS OF WORD 0 OF BLOCK)
JBFIN1:	MOVX T2,JSFRST
	STOR T2,JSSTN,(T1)	;INITIALIZE STRUCTURE NUMBER TO -1
	ADDI T1,JSSTMX-1	;GO TO NEXT BLOCK OF WORDS
	AOBJN T1,JBFIN1		;..
	RET

JOBCAP:	SC%CTC!SC%GTB!SC%LOG!SC%SCT ;NORMAL STARTUP CAPS

;INITBT - BITTABLE INITILIZATION

;	CALL BTINIT

;RETURNS +1 ALWAYS
;R4 - INDEX INTO MMAP FOR BITTABLE ENTRIES FOR NON/EXTENDED BITTABLES
;
;THIS ROUTINE INITALIZES THE ADDRESSES FOR THE BITTABLE
;
	RESCD
INITBT::
	SETOM EXADDR		;SET LARGE DIRECTORY
	SKIPN EXADFL		;CHECK TO SEE IF EXAD MACHINE
	SETZM EXADDR		;NO PROTECT FROM ATTEMPT TO USE NONZERO SECTIONS
	MOVNI T4,<BTBMAX+777>/1000 ;NON EXTENDED
	HRLZS T4
	MOVEI T1,BTB		;FIND BASE OF BITTABLE FOR NON EX
	SKIPE EXADDR		;WHICH
	MOVE T1,[BTSEC,,0]	;EXTENDED
	MOVEM T1,BTBORA		;SET ORIGIN
	LSH T1,-PGSFT		;MAKE PAGE ADDRESS
	MOVEM T1,BTSTRT		;SAVE START
	HRR T4,T1		;SET PAGE NUMBER FOR RETURN
	ADDI T1,<BTBMAX-1>/1000	;SET END PAGE NUMBER
	MOVEM T1,BTEND		;SET END OF BITMAP
	MOVEI T1,BTBMAX		;BITTABLE MAX FOR NON/EXTENDED
	SKIPGE EXADDR
	MOVEI T1,BTMXSZ		;EXTENDED
	MOVEM T1,BTBSIZ		;SET SIZE
	RET
	SWAPCD
;FILINI - File system initialization

;	CALL FILINI

;RETURNS +1: ALWAYS

;THIS CODE IS CALLED BY JBI0 IN MEXEC AS PART OF SYSTEM STARTUP
;IF THE MONITOR WAS STARTED AT SYSGO1, STARTF IS 0
;IF IT WAS STARTED AT SYSLOD, STARTF HAS SOME COMBINATION OF THE FOLLOWING BITS SET:
;	MI%RFS IF THE USER REQUESTED REFRESHING THE FILE SYSTEM
;	MI%RCN IF THE USER DID NOT REQUEST REFRESH
;	MI%HMB IF THE HOME BLOCKS WERE REWRITTEN
;IF THE SYSTEM WAS STARTED AT SYSGO1, OR IF IT WAS STARTED AT SYSLOD,
;BUT ALL QUESTIONS WERE ANSWERED 'NO', STARTF IS 0

FILINI::STKVAR <FILINZ>
	UNLOCK DIRCLK		;INIT DIRECTORY CACHE LOCK
	CALL DEVINI		;INIT DEVICE TABLES
	MOVE T1,[DIRRDM]	;GET MASK
	MOVEM T1,DIRRDU		;SET DIRECTORY READ TIME UPDATE MASK
	MOVEI T1,<MXDRNM*PGSIZ>/.IDXLN	;MAX LARGE DIRECTORY NUMBER
	MOVEM T1,MXDIRN		;SET UP MAX DIRECTORY NUMBER
	MOVE A,[DRSECN,,0]	;DIRECT SECTION (SEC DRSECN)
	MOVEM A,DIRORA		;INITIALIZE THE BASE ADDRESS WORD
	MOVEI A,DRMXSZ		;INITIALIZE NUMBER
	MOVEM A,NDIRPG		; OF DIRECTORY PAGES
	MOVE A,[<DRMXSZ+^D35>/^D36+1]
	MOVEM A,FBTSIZ
	MOVE A,[IDXSEC,,0]	;SET IDX SECTION
	MOVEM A,IDXORA		;SET UP BASE OF INDEX TABLE
	UNLOCK LDTLCK		;INITIALIZE THE DIRECTORY LOCK TABLE
	SETZM FILINZ		;ASSUME NO NEED TO FIX FRONT END FILE SYSTEM
	SKIPN B,STARTF		;ZERO IF STARTED AT SYSGO1
	JRST FILIN1		;DIDN'T START AT SYSLOD. DO USUAL STARTUP

;STARTED THE MONITOR AT SYSLOD.  SEE WHAT THEY WANT TO DO

	TXNE B,MI%RFS		;DO WE WANT A FULL REFRESH?
	JRST FILRFS		;YES. GO DO IT
	TXNE B,MI%HMB		;NO. WERE THE HOME BLOCKS REWRITTEN?
	SETOM FILINZ		;YES. INDICATE POINTER TO FRONT END FILE SYSTEM
				; HAS BEEN CLOBBERED
	; ..
	; ..

;NOT REFRESHING. SEE IF RECONSTRUCTING ROOT-DIRECTORY

	HRROI A,[ASCIZ /RECONSTRUCT ROOT-DIRECTORY? /]
	PSOUT
	CALL YESNO		;SEE IF RECONSTRUCTING
	JUMPN A, [	MOVEI A,PSNUM	;YES. A/STRUCTURE NUMBER FOR PS
			CALL FILREC	;GO DO RECONSTRUCTION
			 BUG.(HLT,BADREC,FILINI,hard,<FILINI - Reconstruction of ROOT-DIRECTORY failed>,,<

Cause:	One of the following failures occurred during attempted reconstruction
	of the root directory during system startup:  could not
	get OFN for backup root-directory; could not get OFN for the root-
	directory; could not assign a page in the job data area to build the
	backup index block; or the backup root-directory is clobbered.

>)
			HRROI A,RCDMSG	;GET POINTER TO ADVISORY MESSAGE
			PSOUT		;INFORM USER EVERYTHING OK SO FAR
			MOVX B,MI%BTB	;INDICATE REBUILD BIT TABLE
			IORM B,STARTF	; FOR MEXEC TO SEE LATER
			JRST FILIN1]	;THEN PROCEED NORMALLY

;IF EXPANDING A STRUCTURE WITHOUT REFRESHING, ANSWER TO NEXT QUESTION
;SHOULD BE YES

	MOVX A,MI%RCN		;NOT RECONSTRUCTING. CLEAR THE BIT
	ANDCAM A,STARTF		; IN STARTF (SET BY FSSINI)
	HRROI A,[ASCIZ/REBUILD BIT TABLE? /]
	PSOUT			;ASK ABOUT BIT TABLE
	CALL YESNO		;GET THE ANSWER
	JUMPN A,[MOVX B,MI%BTB	;INDICATE REBUILD BIT TABLE
		IORM B,STARTF	; FOR MEXEC TO SEE LATER
		JRST FILIN1]	;THEN PROCEED NORMALLY

;USER DIDN'T WANT TO REFRESH, RECONSTRUCT, OR REBUILD. ASSUME NORMAL STARTUP

	SETZM STARTF		;ACT AS IF NOTHING HAD HAPPENED
	HRROI A,[ASCIZ /NORMAL STARTUP ASSUMED.
/]
	PSOUT
	; ..
	; ..

; Make directory and index known to system

FILIN1:
	MOVEI A,PSNUM		;A/STRUCTURE NUMBER FOR PS
	CALL SETRDO		;SET UP ROOT-DIRECTORY OFN
	 BUG.(HLT,IBOFNF,FILINI,SOFT,<FILINI - ASOFN failure for root directory IB>,,<

Cause:	During normal system startup, the call to SETRDO failed
	to set an OFN for the PS: root directory.  SETRDO fails if there is
	no SDB for the structure, or if ASROFN fails to assign an OFN.
>)
	MOVEI A,PSNUM		;A/STRUCTURE NUMBER FOR PS
	SKIPN B,STRTAB(A)	;GET SDB ADDRESS FOR THIS STRUCTURE
	JRST FILERR		;PS MUST BE DEFINED
	CALL INISTR		;GO SET UP DEVNAM, ETC.
	MOVEI T1,PSNUM		;T1/STRUCTURE NUMBER FOR PS
	CALL MNTBTB		;GET AN OFN ON THE BIT TABLE FILE
	 JRST [	BUG.(CHK,NOBTB,FILINI,HARD,<FILINI - Unable to open bit table file>,,<

Cause:	During normal system startup, the call to MNTBTB to get an OFN for
	the bit table of PS: failed. MNTBTB fails if it cannot get a JFN
	for the bit table or if it cannot get an OFN for the index block.

Action:	TOPS-20 will attempt to initialize a private copy of the bit table
	using CRTBTB. If this also fails, a BTBCR1 BUGHLT will result.
>,,<DB%NND>)			;[7.1210] 
		MOVX T4,SF%BTE!SF%CDE ;FAILED. INDICATE BIT TABLE ERRORS
		IORM T4,FACTSW	;SO THAT SYSJOB WON'T START
		MOVEI T1,PSNUM	;T1/STRUCTURE NUMBER FOR PS
		CALL CRTBTB	;INITIALIZE A PRIVATE COPY OF THE BIT
				; TABLE SO WE CAN RUN
		 BUG.(HLT,BTBCR1,FILINI,SOFT,<FILINI - No bit table file and unable to create one>,,<

Cause:	MNTBTB failed, so the system restart logic called CRTBTB to
	create a new bit table.  CRTBTB failed too, so the BTBCR1 BUGHLT
	happened.  CRTBTB will fail if INIBTB fails.  This can happen if
	DSKASA fails to assign a disk page, or if SWPASN fails to assign
	swapping space.
>)
		MOVEI T1,PSNUM	;GET STRUCTURE NUMBER FOR PS
		HRRZ T2,STRTAB(T1) ;POINT TO ITS SDB
		MOVX T4,MS%ASG	;FORBID ASSIGNING PAGES UNTIL CHECKD CAN
		IORM T4,SDBSTS(T2) ; RUN AND REBUILD THE BIT TABLE
		ADDI T1,DVXST0	;POINT TO THIS STRUCTURE IN DEVICE TABLES
		MOVX T4,D1%INI	;CLEAR THE 'INI' BIT ON THE ASSUMPTION
		ANDCAM T4,DEVCH1(T1) ; THAT CHECKD WILL REBUILD THE BIT TABLE
		JRST .+1]
	; ..
	; ..

	MOVEI T1,PSNUM		;T1/STRUCTURE NUMBER FOR PS
	CALL FNDIDX		;GET OFN FOR INDEX TABLE
	 JRST [	MOVEI T1,PSNUM	;FAILED.T1/ STRUCTURE NUMBER FOR PS
		CALL MAKIDX	;NOT THERE, MAKE A NEW ONE
		 BUG.(HLT,BADXT1,FILINI,SOFT,<Index table missing and can not be created>,,<

Cause:	During system startup, MAKIDX failed to recreate the index
	table file.  This will occur, for instance, if one of the following
	conditions exist: ASGJFR fails to get free space, STRST fails to create
	a filespec; GTJFN fails to create the file; OPENF fails to open it.
>)
		BUG.(CHK,BADXT2,FILINI,HARD,<Index table missing and was created>,,<

Cause:	During system startup, FNDIDX failed to get an OFN for the index
	table file so MAKIDX has been called to create a new one.

>,,<DB%NND>)			;[7.1210] 
		JRST FILI1A]
	MOVE T1,MXDIRN		;NUMBER OF ENTRIES IN IDXTAB
	LSH T1,-PGSFT+1		;PAGE WHERE IDXTAB EXTENSION BEGINS
	MOVEI T2,PSNUM		;STR NUMBER FOR PS
	MOVE T2,STRTAB(T2)	;SRB
	LOAD T2,STRIDX,(T2)	;OFN FOR IDXTAB
	HRL T1,T2		;IDENT
	CALL MRPACS		;GET PAGE ACCESSABILITY
	JUMPE T1,FILI1A		;JUMP IF PPN EXTENSION MUST BE CREATED
	TLNE T1,(1B5)		;PAGE EXIST?
	JRST FILIN2		;PPN EXTENSION EXISTS, PROCEED
FILI1A:	MOVX A,MI%XTB		;INDICATE NEEDS TO BE INITIALIZED LATER
	IORM A,STARTF
	MOVX A,SF%BTE		;FORCE CHECKD TO BE RUN BEFORE
	IORM A,FACTSW		; SYSTEM COMES UP FOR TIME-SHARING
	TMSG <
[INDEX-TABLE BEING INITIALIZED FOR PPN SUPPORT]
>
	JRST FILIN2		;PROCEED TO COMMON CODE
;FILRFS - HERE WHEN REFRESHING FILE SYSTEM

FILRFS:	SE1ENT

;Make 143$G work by temporarily declaring MXDIRN only as large as needed during
;initial directory creaation.  JSB free space is used during the refresh
;procedure and the addition of the PPNs has made it impossible to fit everything
;in a page if the real MXDIRN were used.
;
	MOVEI T1,CRDTBL+1	;DECLARE MAX DIR ONLY AS LARGE AS WE NEED
	MOVEM T1,MXDIRN		; IT DURING REFRESH SO JSB CAN HANDLE THINGS
;
	MOVEI A,PSNUM		;A/STRUCTURE NUMBER
	SKIPN B,STRTAB(A)	;B/ADDRESS OF SDB
	JRST FILERR		;PS MUST BE DEFINED
	CALL INISTR		;SET UP DEVNAM, INDICATE BEING INITED
	MOVEI A,PSNUM		;A/STRUCTURE NUMBER
	CALL CRTBTB		;INITIALIZE A BIT TABLE IN CORE
	 BUG.(HLT,BTBCRT,FILINI,SOFT,<FILINI - Could not initialize bit table for public structure>,,<

Cause:	During special system startup in which PS: was being refreshed,
	CRTBTB failed to build a new bit table.  See CRTBT1 for more detail
	on why CRTBTB fails.
>)

;CREATE INDEX BLOCK FOR PRIMARY COPY OF ROOT-DIRECTORY

	MOVE A,DIDSCI		;GET INITIAL INDEX BLOCK ADR FOR ROOT
	MOVEI B,PSNUM		;B/STRUCTURE NUMBER
	CALL NEWIB		;GET THE INDEX BLOCK FOR THE ROOT DIR
	 BUG.(HLT,NEWROT,FILINI,SOFT,<FILRFS - NEWIB failure for ROOT-DIRECTORY>,,<

Cause:	This is identical to NEWBAK, except it is for the
	primary root directory rather than the backup root directory.
>)
	MOVE C,STRTAB+PSNUM	;GET ADDRESS OF SDB
	STOR A,STRRDO,(C)	;REMEMBER THE OFN OF THE ROOT-DIR INDEX BLOCK

;CREATE INDEX BLOCK FOR BACKUP COPY OF ROOT-DIRECTORY

	MOVE A,DIDSCJ		;GET AN OFN FOR BACKUP FILE ALSO
	MOVEI B,PSNUM		;B/STRUCTURE NUMBER
	CALL NEWIB		;SO BACKUP FILE STARTS IN A KNOWN SPOT
	 BUG.(HLT,NEWBAK,FILINI,SOFT,<FILRFS - NEWIB failure for BACKUP ROOT-DIR>,,<

Cause:	This BUGHLT happens when NEWIB fails to assign a backup
	index block for the  PS: root directory.  This will happen if DSKASA
	fails to assign a disk address, or if ASROFN fails to assign an
	OFN.
>)
	MOVEM A,BKOFN		;SAVE ITS OFN
	; ..
	; ..

;SET UP THE INDEX TABLE FOR ROOT-DIRECTORY. THIS CODE MAKES A TEMPORARY
;COPY OF IDXTAB IN JSB FREE SPACE IN ORDER TO CREATE THE FIRST FEW
;DIRECTORIES ON THE SYSTEM.  IDXORA POINTS TO THAT FREE SPACE TEMPORARILY.

	PUSH P,IDXORA		;SAVE THE OLD IDXTAB ORIGIN
	CALL ASGPAG		;GET PAGE TO PUT TEMPORARY IDXTAB INTO
	 BUG.(HLT,IDXNOS,FILINI,SOFT,<FILINI - Could not assign free space for IDXTAB>,,<

Cause:	During a refresh start (PS: is being built), if the call
	to ASGPAG for getting buffer space for the index table fails, this
	BUGHLT happens.  ASGPAG will fail if JBCOR has no 1-bits left in
	it, meaning that there are no free pages left in free space.
>)
	MOVEM A,IDXORA		;SAVE THE ADDRESS FOUND

;PUT AN ENTRY FOR ROOT-DIRECTORY IN THE TEMPORARY IDXTAB, AND INITIALIZE
;THE DIRECTORY

	MOVEI A,ROOTDN		;NOW SET UP THE INDEX TABLE 
	MOVEI B,0		;DONT HAVE AN FDB ADDRESS YET
	MOVE C,DIDSCI		;GET DISK ADR OF INDEX BLOCK
	MOVEI D,ROOTDN		;SETUP SUPERIOR AS ROOT DIRECTORY
	CALL SETIDX		;SETUP THE INDEX TABLE FOR THE ROOT DIR
	 BUG.(HLT,FILRID,FILINI,SOFT,<FILINW - Index table already set up for root dir>,,<

Cause:	This BUGHLT will occur if, during a refresh in the FILRFS routine
	during system startup, the SETIDX call fails.  That call is trying to
	set up the index table for the root directory for PS:.  SETIDX fails if
	it is passed a directory number that is out of range, or if the index
	table is already set up but at a different spot than that requested in
	the current call.
>)
	MOVEI A,ROOTDN		;NOW INITIALIZE THE DIRECTORY FILE
	MOVEI B,PSNUM		;ASSUME THE PUBLIC STRUCTURE
	CALL DIRINI		; TO LOOK LIKE A DIRECTORY (SETS UP HEADER)
INIROT:	 BUG.(HLT,FILIRD,FILINI,SOFT,<FILINW - Could not initialize the ROOT DIRECTORY>,,<

Cause:	This will occur during special system startup if FILRFS,
	while trying to build PS:, gets a failure return from DIRINI, which
	is trying to initialize the root directory.  DIRINI will fail if its
	call to MAPDIR fails, or if the SETZM which first touches the directory
	fails.  MAPDIR will fail if either the structure or directory number
	is out of range, or if MAPIDX fails to map in the index table.

Action:	Use EDDT to determine exactly what is failing and why.
>)
	; ..
	; ..

;CREATE A FEW SPECIAL DIRECTORIES

	MOVEI A,PSNUM		;A/STRUCTURE NUMBER FOR PS
	CALL FILCRD		;GO CREATE ALL THE DIRECTORIES
	MOVE A,BKOFN		;A/OFN OF BACKUP FILE
	CALL RELOFN		;RELEASE OFN OF BACKUP FILE
	SETZM BKOFN
	MOVEI A,PSNUM		;A/STRUCTURE NUMBER FOR PS

;CREATE A BIT TABLE FILE AND COPY THE TEMPORARY ONE INTO IT.  

	CALL WRTBTB		;GO CREATE BIT TABLE FILE
	 JRST [	CAIE T1,MSTRX6	;DID HOME BLOCK WRITE FAIL?
		 BUG.(HLT,FILBTB,FILINI,SOFT,<Unable to write bit table file>,,<

Cause:	This BUGHLT will occur when FILRFS is refreshing PS:.
	FILRFS calls WRTBTB to write the bit table, and WRTBTB fails
	for a reason other than MSTRX6 (home blocks are bad).  WRTBTB
	will fail for several reasons including: GETBTB failed to get
	a JFN on the bit table file: the OPENF failed: CHFDB, GTFDB, or
	MODHOM failed.

Action:	Use EDDT to specifically determine what is failing.
>)
		BUG.(CHK,FILHOM,FILINI,HARD,<Unable to rewrite home blocks in WRTBTB>,,<

Cause:	FILRFS is attempting to refresh PS:. WRTBTB is called to write the
	bit table. This BUGCHK indicates that WRTBTB failed because the
	home blocks are bad.

Action:	The home blocks must be repaired.
>,,<DB%NND>)			;[7.1210]
		JRST .+1]	;THIS ISN'T FATAL UNLESS OLD STYLE HOME BLOCKS

;CREATE A PERMANENT IDXTAB FILE AND MAKE IDXORA POINT TO THE STANDARD
;PLACE IN THE MONITOR MAP.  RELEASE THE JSB FREE SPACE

	MOVEI A,PSNUM		;GET NUMBER OF THE PUBLIC STRUCTURE
	CALL MAKIDX		;GO CREATE INDEX FILE
	 JRST IDXBAD		;COULD NOT SET UP INDEX TABLE FILE
	MOVX T1,MI%XTB		;INDICATE INDEX TABLE MUST BE INITIALIZED
	IORM T1,STARTF		; FOR COMMON CODE TO SEE LATER
	MOVEI A,JSBFRE		;RELEASE THE IDXTAB PAGE
	MOVE A,IDXORA		;GET THE ADDRESS
	CALL RELPAG		;RELEASE FREE PAGE
	POP P,IDXORA		;RESTORE THE IDXTABLE ADDRESS
	; ..
	; ..

;CREATE THE FRONT END FILE SYSTEM

	;SE0ENT
	MOVEI A,PSNUM		;GET NUMBER OF PUBLIC STRUCTURE
	SKIPGE T2,FEFSIZ	;SEE IF FE FILE SYSTEM SIZE WAS GIVEN
	JRST [	MOVEI T1,PSNUM	;NO. T1/STRUCTURE NUMBER FOR PS
		CALL GTFESZ	;GET THE SIZE FROM THE HOME BLOCKS
		 BUG.(HLT,NOFEFS,FILINI,SOFT,<FILINI - Unable to get size of front end file system>,,<

Cause:	This BUGHLT occurs if GTFESZ fails to get the size of
	the front end file system.  This only happens if ASGPAG fails.
>)
		MOVE T2,T1	;T2/NUMBER PAGES IN FE FILE SYSTEM
		JRST .+1]
	MOVEI T1,PSNUM		;T1/STRUCTURE NUMBER
	CALL FEFSYS		;CREATE A FRONT END FILE SYSTEM
	 BUG.(CHK,FILFEF,FILINI,HARD,<Could not create front end file system>,,<

Cause:	FEFSYS failed to create a front end file system. FEFSYS will fail
	for several reasons. For example, ASGPAG can fail or the count of
	front end pages in the home blocks can be negative.

Action:	Rebuild the front end file system by hand.
>,,<DB%NND>)			;[7.1210]

;CREATE BOOTSTRAP.BIN

	MOVEI T1,PSNUM		;GET NUMBER OF PUBLIC STRUCTURE
	SKIPGE T2,BOTSIZ	;SEE IF BOOTSTRAP.BIN WAS GIVEN
	JRST [	MOVEI T1,PSNUM	;NO. T1/STRUCTURE NUMBER FOR PS
		CALL GTBTSZ	;GET THE SIZE FROM THE HOME BLOCKS
		BUG.(HLT,NOBTBN,FILINI,SOFT,<FILINI - Unable to get size of BOOTSTRAP.BIN FILE>,,<

Cause:	This BUGHLT should never occur.  The routine that must fail for this
	BUGHLT to occur should never be called, since BOTSIZ will be 0
	on a normal startup, or some non-negative number if the FSIDIA
	routine asked the typist for a number.
>)
		MOVE T2,T1	;T2/NUMBER OF PAGES IN BOOTSTRAP.BIN
		JRST .+1]
	CALL BOTSYS		;CREATE A BOOTSTRAP.BIN FILE
	BUG.(CHK,FILBOT,FILINI,HARD,<Could not create BOOTSTRAP.BIN file>,,<

Cause:	BOTSYS failed to create a BOOTSTART.BIN file during a PS: refresh.
	See the documentation for FILFEF for possible reasons for this
	failure.
>,,<DB%NND>)			;[7.1210]
	; ..
	; ..

;UPDATE THE DISK FOR ROOT-DIRECTORY

	MOVE T1,STRTAB+PSNUM	;GET SDB FOR PS
	LOAD T1,STRRDO,(T1)	;GET OFN ON <ROOT-DIRECTORY>
	HRLZS T1		;OFN,,0
	MOVEI T2,1000		;ALL PAGES
	CALL UPDPGS		;UPDATE ON DISK
	MOVE T1,STRTAB+PSNUM	;GET SDB AGAIN
	LOAD T1,STRRDO,(T1)	; OFN
	CALL UPDOFN		;UPDATE OFN ALSO

;Initialization is done;  set up the real MXDIRN.  See comments at FILRFS.

	MOVEI T1,<MXDRNM*PGSIZ>/.IDXLN	;MAX LARGE DIRECTORY NUMBER
	MOVEM T1,MXDIRN		;SET UP MAX DIRECTORY NUMBER
	;..
;HERE FOR NORMAL STARTUP OR WHEN INITIALIZATION IS COMPLETE

	;..
FILIN2:	SKIPN B,STRTAB+PSNUM	;GET SDB ADDRESS FOR PS
	JRST FILERR		;PS MUST BE DEFINED
	MOVEI A,ROOTDN		;NOW CHECK ROOT-DIR
	LOAD C,STRUC,(B)	;GET UNIQUE CODE
	HRL A,C			;A/UNIQUE CODE,,DIRECTORY
	CALL SETDIR		;MAP IN ROOT-DIR AND LOCK IT
	 BUG.(HLT,FILMAP,FILINI,SOFT,<FILIN2 - Could not map in ROOT-DIRECTORY>,,<

Cause:	During standard system startup, SETDIR failed to map in the
	root directory for consistency checking.  SETDIR will fail if CNVSTR
	fails to convert structure number data or if MAPDIR fails to map in
	the directory, or if DR0CHK finds a directory header inconsistency.

Action:	Use EDDT to figure out exactly which reason is the cause.
>)
	CALL BLKSCN		;MAKE SURE IT IS VALID
	 BUG.(HLT,BADROT,FILINI,HARD,<FILIN2 - ROOT-DIRECTORY is invalid>,,<

Cause:	When the system was coming up, BLKSCN was called to check the
	consistency of the root directory.  This error means that
	BLKSCN found that the root directory had an unrecognizable type,
	the last block did not have the expected length, or some block
	had an incorrect format.

Action:	Use EDDT to break after BLKSCN and examine the error code in AC1.
	This code will sometimes indicate what is wrong with the root
	directory.  If other BUGCHKs or BUGINFs occur with this BUGHLT, they
	also can provide helpful information.

	If the system can be brought up using another structure as PS:,
	the bad structure can sometimes be fixed with various tools such
	as FILDDT.  If this restoration fails, the pack can be started
	afresh and pertinent DUMPER backup tapes can be used to restore the
	structure.
>)
	CALL USTDIR		;UPDATE AND UNLOCK THE DIR
	MOVE B,STARTF		;GET STARTUP FLAGS
	TXZE B,MI%XTB		;DO WE NEED TO INIT INDEX TABLE?
	JRST [	MOVEI A,PSNUM	;YES. A/ NUMBER OF PS
		CALL IDXINI	;INITIALIZE IT
		 JRST IDXBAD
		JRST .+1]

	CALL ISDIRT		;INIT SPECIAL DIR TABLE
	CALL INIDEV		;INITIALIZE DEVICE DRIVERS
	CALL ENQINI		;INITIALIZE THE ENQ/DEQ DATA BASE
	CALL SNPINI		;INITIALIZE THE SNOOP DATA BASE

	MOVX T3,MI%BTB		;DON'T CHECK BIT TABLE IF REBUILDING
	TDNE T3,STARTF
	JRST FILIN3
	; ..
	; ..
	MOVE T1,STRTAB+PSNUM	;GET POINTER TO SDB FOR PS
	MOVX T3,MS%ASG		;IF ASSIGNMENTS ARE PROHIBITED, BIT TABLE
	TDNE T3,SDBSTS(T1)	; DOESN'T EXIST. DON'T TRY TO CHECK IT
	JRST FILIN3		;OR CHECK THE ROOT-DIRECT ORY BACKUP
	MOVEI T1,PSNUM		;T1/STRUCTURE NUMBER
	MOVX T2,MI%MSG		;T2/REQUEST MESSAGES ON CONSOLE
	CALL CHKBT		;CHECK CONSISTENCY OF BIT TABLE AND FIX IT
	 JRST [	MOVX T3,SF%BTE	;FAILED. INDICATE BIT TABLE ERRORS ON PS
		IORM T3,FACTSW	; FOR MEXEC TO SEE LATER
		JRST .+1] 	; AND THEN PROCEED NORMALLY
	MOVX T3,MI%RCN		;DON'T CHECK THE BACKUP IF RECONSTRUCTING
	TDNN T3,STARTF		; (FILREC DELETED IT)
	JRST [	MOVEI T1,PSNUM	;T1/STRUCTURE NUMBER FOR PS
		CALL CHKBAK	;CHECK BACKUP OF ROOT-DIRECTORY
		 BUG.(CHK,BADBAK,FILINI,HARD,<FILIN2 - Backup copy of ROOT DIRECTORY is not good>,,<

Cause:	The backup copy of the root directory is bad.

Action:	Re-create the backup copy of the root directory.
>,,<DB%NND>)			;[7.1210]
		JRST .+1]
FILIN3:
	SKIPE FILINZ		;DID WE REWRITE HOME BLOCKS?
	JRST [	MOVEI A,PSNUM	;A/STRUCTURE NUMBER FOR PS
		CALL FIXFES	;YES. PUT POINTER TO FE FILE SYSTEM BACK IN
		 BUG.(CHK,FIXBAD,FILINI,HARD,<Could not re-write home blocks to point to FE file system>,,<

Cause:	FIXFES has failed to re-write the pointer to the front-end file
	system during startup. FIXFES can fail if it cannot get free space
	or the front-end file system file is bad.
>,,<DB%NND>)			;[7.1210]
		JRST .+1]	; HOME BLOCKS
	SKIPE FILINZ		;DID WE REWRITE HOME BLOCKS?
	JRST [	MOVEI A,PSNUM	;A/STRUCTURE NUMBER FOR PS
		CALL FIXBOT	;YES -- PUT POINTER TO BOOT FILE BACK
		BUG.(CHK,FIXBDB,FILINI,HARD,<Could not re-write home blocks to point to BOOTSTRAP.BIN>,,<

Cause:	FIXBOT failed to re-write the pointer to the BOOTSTRAP.BIN file
	into the home blocks during system startup. FIXFES can fail if it
	cannot get free space or if it cannot get a JFN for BOOTSTRAP.BIN.
>,,<DB%NND>)			;[7.1210] 
		JRST .+1]
	MOVEI A,PSNUM		;A/STRUCTURE NUMBER FOR PS
	SKIPN STRTAB(A)		;IS THERE AN ENTRY FOR PS?
	JRST FILERR		;PS MUST BE DEFINED
	CALL FRESTR		;GO CLEAR SLOT IN DEVNAM, ETC.
	RET

FILERR:	BUG.(HLT,STZERO,FILINI,HARD,<FILINI - STRTAB entry for PS is 0>,,<

Cause:	This will happen if the code that is supposed to set up
	the STRTAB entry for PS: was never executed.  If this happens,
	some data has been corrupted.

>)
	RET

IDXBAD:	 BUG.(HLT,BADXTB,FILINI,SOFT,<FILIN2 - Could not initialize index table>,,<

Cause:	This can happen either because IDXINI failed during normal
	system startup, or because MAKIDX failed during a special startup
	while PS: was being created.
>)

;ROUTINE TO CREATE ALL THE STANDARD DIRECTORIES

;ACCEPTS:
;	T1/STRUCTURE NUMBER

;	CALL FILCRD

;RETURNS +1:	ALWAYS

;CALLED DURING REFRESH ONLY

BLKSIZ==<.CDPPN+1>+<MAXLW+2>	;SPACE FOR CRDIR BLOCK+DEV:<DIR> STRING

FILCRD::SAVEQ			;PRESERVE SOME ACCUMULATORS
	MOVEM A,Q3		;SAVE STRUCTURE NUMBER
	NOINT			;NO INTERRUPTIONS WITH SPACE ASSIGNED
	MOVEI B,BLKSIZ		;ASSIGN SPACE FOR CRDIR BLOCK AND DIR STRING
	CALL ASGJFR		;USE JSB FREE SPACE
	 JRST [	BUG.(CHK,FILJB1,FILINI,HARD,<FILCRD - No room to create standard system directories>,,<

Cause:	FILCRD could not create the standard system directories during a
	refresh of PS: because it could not get JSB free space for use
	during CRDIR calls.
>,,<DB%NND>)			;[7.1210]
		OKINT		;PERMIT INTERRUPTS AGAIN
		RET ]		;RETURN
	MOVEI Q2,1(A)		;SAVE ADDRESS OF CRDIR BLOCK
	MOVSI Q1,-CRDTBL	;SET UP AOBJN COUNTER
FILCR1:	HRROI A,[ASCIZ/DEC-20/]	;GET DEFAULT PASSWORD
	MOVEM A,.CDPSW(Q2)	;SET UP PARAMETER BLOCK FOR CRDIR
	MOVX A,SC%OPR!SC%IPC	;MAKE THE DIR BE OPERATOR AND IPCF
	MOVEM A,.CDPRV(Q2)	;ONLY FOR DIR'S THAT ARE NOT FILES-ONLY
	MOVX A,MD%FO		;SET UP FOR FILES-ONLY DIRECTORIES
	MOVEM A,.CDMOD(Q2)	;ONLY SET ID CD%MOD IS SET
	HRLZI A,377777		;SET INFINITY FOR THOSE DIRS
	MOVEM A,.CDLIQ(Q2)	; WITH QUOTAS
	MOVEM A,.CDLOQ(Q2)	; ...
	HRROI A,.CDDGP+1(Q2)	;GET DESTINATION FOR COMPLETE STRING
	MOVE B,Q3		;GET STRUCTURE NUMBER
	HRRO C,CRDTAB(Q1)	;GET POINTER TO DIRECTORY NAME
	CALL STRST		;FORM COMPLETE DIRECTORY STRING (INCLUDING STR)
	 JRST [	BUG.(CHK,FILCCD,FILINI,HARD,<Could not create directory>,,<

Cause:	FILCRD failed to create one of the standard system directories
	during a PS: refresh because STRST failed to form a complete
	directory string. STRTS will fail if STRCNV cannot create a unique
	code from the structure number or if a DEVST fails to convert the
	structure number to a string.
>,,<DB%NND>)			;[7.1210]
		JRST FILCR3 ]	;GO ON TO NEXT DIRECTORY
	MOVEI A,1(Q1)		;GET DIRECTORY NUMBER BEING SET
	MOVEM A,.CDNUM(Q2)
	MOVE B,STRTAB(Q3)	;GET ADDRESS OF SDB FOR THIS STRUCTURE
	; ..
	; ..
	CAIE A,ROOTDN		;CREATING ROOT-DIRECTORY ?
	JRST FILCR2		;NO, GO ON
	SETONE STCRD,(B)	;YES, NOTE ROOT-DIRECTORY BEING CREATED
FILCR2:	MOVEI A,SYSDPT		;GET PROTECTION OF SYSTEM AND SUBSYS
	MOVEM A,.CDDPT(Q2)	;SET UP PROTECTION WORD
	MOVEI A,SYSFPT		;GET FILE PROTECTION OF SYSTEM AND SUBSYS
	MOVEM A,.CDFPT(Q2)
	SETZM .CDRET(Q2)	;SET RETENTION COUNT TO 0
	MOVE A,CRDPTB(Q1)	;GET PPN
	MOVEM A,.CDPPN(Q2)	;STORE IT
	HRROI A,.CDDGP+1(Q2)	;GET POINTER TO DIRECTORY NAME
	HLLZ B,CRDTAB(Q1)	;GET FLAGS FOR THIS DIR
	HRR B,Q2		;GET ADDRESS OF PARAMETER BLOCK
	CRDIR			;CREATE THE DIR
	 ERJMP .+1
	HRRZ A,A		;GET THE DIRECTORY NUMBER
	CAIN A,ROOTDN		;WAS ROOT-DIR JUST CREATED?
	JRST [	MOVE B,STRTAB(Q3) ;GET ADDRESS OF SDB
		SETZRO STCRD,(B) ;ROOT-DIRECTORY NO LONGER BEING CREATED
		MOVE A,Q3	;GET STRUCTURE NUMBER
		CALL CREBAK	;GO CREATE BACKUP FILE
		 BUG.(CHK,FILBAK,FILINI,HARD,<FILCRD - Could not create backup of ROOT-DIRECTORY>,,<

Cause:	CREBAK failed to create the backup copy of the root directory
	during a refresh of PS:.
>,,<DB%NND>)			;[7.1210] 
		JRST .+1]
FILCR3:	AOBJN Q1,FILCR1		;LOOP BACK UNTIL ALL DIR'S ARE CREATED
	MOVEI A,JSBFRE		;NOW RETURN THE SPACE TO THE JSB
	MOVEI B,-1(Q2)		;GET ADDRESS OF FREE BLOCK
	CALL RELFRE		;RELEASE THE SPACE AND RETURN
	OKINT			;PERMIT INTERRUPTS AGAIN
	RET			;RETURN

DEFINE DIRDEF,<
	X CD%MOD!CD%NUM!CD%LIQ!CD%LOQ!CD%PPN+[ASCIZ/<ROOT-DIRECTORY>/],<1,,1>
	X CD%RET!CD%FPT!CD%DPT!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ!CD%PPN+[ASCIZ/<SYSTEM>/],<3,,4>
	X CD%FPT!CD%DPT!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ!CD%PPN+[ASCIZ/<SUBSYS>/],<1,,4>
	X CD%RET!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ!CD%PPN+[ASCIZ/<ACCOUNTS>/],<1,,7>
	X CD%PSW!CD%PRV!CD%NUM!CD%PPN+[ASCIZ/<OPERATOR>/],<1,,2>
	X CD%RET!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ!CD%PPN+[ASCIZ/<SPOOL>/],<3,,3>
	X CD%RET!CD%FPT!CD%DPT!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ!CD%PPN+[ASCIZ/<NEW-SYSTEM>/],<3,,5>
	X CD%FPT!CD%DPT!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ!CD%PPN+[ASCIZ/<NEW-SUBSYS>/],<1,,5>
	X CD%FPT!CD%DPT!CD%MOD!CD%NUM!CD%LIQ!CD%LOQ!CD%RET!CD%PPN+[ASCIZ/<SYSTEM-ERROR>/],<2,,7>
>

	DEFINE X(A,B),<A>
CRDTAB:	DIRDEF
CRDTBL==.-CRDTAB
	DEFINE X(A,B),<B>
CRDPTB::DIRDEF
HSDPPN==:.-CRDPTB

;ROUTINE TO CREATE THE BACKUP FILE TO HOLD A COPY OF THE ROOT-DIR
;ACCEPTS IN A/	STRUCTURE NUMBER
;	CALL CREBAK
;RETURNS +1:	FAILED
;	 +2:	OK

;CALLED DURING REFRESH ONLY

CREBAK:	ASUBR <CREBKS,CREBKJ,CREBLK>
	MOVEI B,^D15		;GET ENOUGH SPACE FOR NAME OF BACKUP FILE
	CALL ASGJFR		;GO ASSIGN JSB FREE SPACE
	 RETBAD			;FAILED
	MOVEM A,CREBLK		;SAVE ADDRESS OF BLOCK
	HRROI A,1(A)		;FORM POINTER TO WHERE NAME WILL GO
	MOVE B,CREBKS		;GET STRUCTURE NUMBER
	HRROI C,[ASCIZ/<ROOT-DIRECTORY>BACKUP-COPY-OF-ROOT-DIRECTORY.IMAGE;P770000/]
	CALL STRST		;FORM COMPLETE FILE NAME
	 JRST CREBK1		;FAILED, GO RELEASE SPACE AND RETURN
	MOVX A,GJ%NEW+GJ%PHY+GJ%SHT
	HRRZ B,CREBLK		;GET ADDRESS OF FREE BLOCK
	HRROI B,1(B)		;FORM POINTER TO FILE NAME
	GTJFN			;CREATE BACKUP FILE
	 JRST CREBK1		;FAILED, RELEASE SPACE AND RETURN
	MOVEM A,CREBKJ		;SAVE JFN
	HRRZ JFN,A		;NOW MAP IN FDB
	IMULI JFN,MLJFN
	MOVE STS,FILSTS(JFN)
	HRRI DEV,DSKDTB
	HRL DEV,CREBKS		;GET STRUCTURE NUMBER
	EA.ENT
	CALL GETFDB
	 JRST [	MOVE A,CREBKJ	;COULD NOT GET FDB
		RLJFN		;RELEASE JFN
		 JFCL
		JRST CREBK1 ]	;GO RELEASE SPACE AND RETURN
	MOVE B,CREBKS		;GET STRUCTURE NUMBER
	MOVE B,STRTAB(B)	;GET ADDRESS OF SDB
	LOAD B,STRBXB,(B)	;GET ADDRESS OF INDEX BLOCK
	STOR B,FBADR,(A)	;PLUNK IN THE DISK ADR (MAGIC)
	SETZRO FBNXF,(A)	;FILE NOW EXISTS
	SETONE <FBNOD,FBNDL>,(A) ;[7172]THIS FILE IS NOT TO BE DUMPED
				;[7172]AND 'NEVER DELETE'
	CALL USTDIR		;UNLOCK DIR
	MOVE A,CREBKJ		;GET BACK JFN
	RLJFN			;RELEASE THE JFN
	 JFCL
	MOVEI A,JSBFRE		;GET FREE HEADER
	MOVE B,CREBLK		;GET ADDRESS OF FREE BLOCK
	CALL RELFRE		;RELEASE FREE BLOCK
	RETSKP			;GIVE OK RETURN

; HERE ON ERRORS TO RELEASE SPACE AND GIVE FAIL RETURN

CREBK1:	MOVEI A,JSBFRE		;GET FREE HEADER
	MOVE B,CREBLK		;GET ADDRESS OF FREE BLOCK
	CALLRET RELFRE		;RELEASE SPACE AND GIVE FAIL RETURN
;INISTR - INITIALIZE STRUCTURE

;ACCEPTS:
;	A/STRUCTURE NUMBER
;	B/START OF SDB

;RETURNS +1: ALWAYS

;CALLED WHEN A STRUCTURE IS MOUNTED BUT IS NOT YET GENERALLY AVAILABLE.
;THE CALLING FORK IS GIVEN CONTROL OF THE STRUCTURE UNTIL FRESTR
;IS CALLED. THE RIGHT HALF OF SDBSTS HOLDS THE FORK NUMBER
;ALSO, CLEARS D1%NIU IN DVCH1 TO INDICATE SLOT HAS A REAL STRUCTURE

INISTR::			;[7.1112]
	SAVET
	HRRZ A,A		;GET STRUCTURE NUMBER
	MOVEI C,DVXST0		;GET START OF STRUCTURES IN DEVXXX
	ADD C,A			;GET DEVXXX INDEX FOR THIS UNIT
	MOVE D,SDBNAM(B)	;GET STRUCTURE NAME FROM SDB
	MOVEM D,DEVNAM(C)	; AND STORE IN DEVNAM
	MOVX D,D1%INI		;INDICATE STRUCTURE BEING INITED
	IORM D,DEVCH1(C)
	MOVX D,D1%NIU		;CLEAR INDICATOR THAT SLOT IS NOT IN
	ANDCAM D,DEVCH1(C)	; USE
	MOVE D,FORKX		;GET CURRENT FORK
	STOR D,STRJB,(B)	;INDICATE IT IS THE INITING FORK
				; AND THUS THE ONLY LEGAL USER WHILE
				; D1%INI IS SET
	RET


;FRESTR - FREE A STRUCTURE

;ACCEPTS:
;	T1/STRUCTURE NUMBER

;	CALL FRESTR

;RETURNS +1: ALWAYS

;MAKES A STRUCTURE AVAILABLE FOR GENERAL USE

FRESTR::
	SAVET
	HRRZ A,A
	MOVEI C,DVXST0
	ADD C,A
	MOVX D,D1%INI		;INDICATE NOT BEING INITIALIZED
	ANDCAM D,DEVCH1(C)
	MOVE D,STRTAB(A)	;[7170]GET SDB ADDRESS
	SETZRO STRJB,(D)	;[7.1063]Clear initing fork number
	HRROS DEVUNT(C)		;INDICATE AVAILABLE TO ALL JOBS
	RET
;SET UP OFN OF ROOT-DIRECTORY FOR A STRUCTURE
;
; CALL:
;	ACCEPTS IN T1/	STRUCTURE #
;		CALL SETRDO
; RETURNS: +1	 ERROR
;	   +2	SUCCESS

;CALLED DURING NORMAL STARTUP ONLY

SETRDO::STKVAR <STRDOS>		;ALLOCATE SPACE FOR SDB ADDRESS
	MOVE T2,T1		;COPY STRUCTURE NUMBER
	SKIPN T1,STRTAB(T2)	;IS THERE AN SDB FOR THIS STRUCTURE ?
	RET			;NO, ERROR
	MOVEM T1,STRDOS		;YES, SAVE ADDRESS OF SDB
	LOAD T1,STRRXB,(T1)	;GET DISK ADDRESS OF XB FOR ROOT-DIRECTORY
	TXO T1,FILWB+THAWB	;GET ACCESS BITS
	CALL ASROFN		;GET AN OFN FOR THE ROOT-DIRECTORY
	 RET			;ERROR, RETURN
	MOVE T2,STRDOS		;GET BACK ADDRESS OF SDB
	STOR T1,STRRDO,(T2)	;STORE OFN FOR ROOT-DIRECTORY IN SDB
	RETSKP			;RETURN SUCCESS
;INIT SPECIAL DIRECTORY TABLE WITH ACTUAL DIRNUMS.
;	CALL ISDIRT
; RETURNS +1 ALWAYS

;CALLED FROM COMMON CODE

ISDIRT:	SAVEQ
	MOVNI Q1,NSDIR0		;GET NEG OF LENGTH OF INITIAL TABLE
	MOVSI Q1,0(Q1)		;SETUP AS AOBJN PTR
	SETZM NSDIRT		;INIT COUNT OF ENTRIES IN RUNTIME TABLE
ISDIR1:	HRRZ B,SDIRT0(Q1)	;GET LOC OF DIR NAME STRING
	HRLI B,(POINT 7,0)
	ILDB A,B		;COUNT CHARS IN NAME
	JUMPN A,.-1		;SCANNING UNTIL NULL
	HRRZ A,SDIRT0(Q1)	;CONSTRUCT LOOKUP PTR FOR CALL
	MOVEI A,-1(A)		;RH OF LOOKUP PTR IS ADR-1
	SUBM A,B		;COMPUTE NEG # OF WORDS IN NAME STRING
	HRLI A,1(B)		;LH OF LOOKUP PTR IS -(NWORDS-1)
	MOVE Q2,A		;SAVE A
	MOVEI A,PSNUM		;THIS FEATURE IS FOR PS ONLY
	CALL STRCNV		;GET UNIQUE CODE
	 JRST ISDIR2		;FAILED, SKIP THIS ONE
	HRRZ B,A		;GET UNIQUE CODE
	MOVE A,Q2		;GET BACK ADDRESS OF STRING BLOCK
	CALL DIRLKX		;LOOKUP THIS DIRECTORY THE USUAL WAY
	 JRST ISDIR2		;FAILED, IGNORE IT
	MOVM B,NSDIRT		;GET INDEX TO NEXT FREE ENTRY IN SDIRTB
	HRLM A,SDIRTB(B)	;SUCCESS, SAVE DIRNUM IN TABLE
	HRRZ A,SDIRT0(Q1)
	HRRM A,SDIRTB(B)	;SAVE STRING ADR IN TABLE
	SOS NSDIRT		;UPDATE NEG COUNT OF ENTRIES IN TABLE
ISDIR2:	AOBJN Q1,ISDIR1		;DO ALL DIRS
	RET
;FILREC - RECONSTRUCT ROOT-DIRECTORY

;ACCEPTS:
;	A/STRUCTURE NUMBER

;	CALL FILREC

;RETURNS +1:ALWAYS

;ROUTINE TO RECONSTRUCT THE ROOT-DIRECTORY
;THIS IS DONE BY COPYING THE INDEX BLOCK OF THE BACKUP ROOT-DIR
;INTO THE INDEX BLOCK FOR THE ROOT-DIRECTORY
;AFTER COPYING THE BACKUP INDEX BLOCK, THE ROOT-DIR SHOULD BE INTACT
;THE BACKUP INDEX BLOCK IS ZEROED

;NOTE: A NEW BACKUP FILE IS NOT MADE HERE; THE NEXT CALL TO CPYBAK 
;WILL CREATE IT. THIS EXITS WITHOUT AN OFN FOR ROOT-DIRECTORY. THE CALLER MUST
;ASSIGN THE OFN

FILREC::STKVAR <STRN02,FILRER,FILREB,FILREO>
	MOVEM A,STRN02		;SAVE STRUCTURE NUMBER
	MOVE A,STRTAB(A)	;GET ADDRESS OF SDB
	LOAD A,STRBXB,(A)	;GET ADDRESS OF XB FOR BACKUP FILE
	TLO A,(FILWB+THAWB)	;OPEN FOR WRITE AND THAWED
	MOVE B,STRN02		;B/STRUCTURE NUMBER
	CALL ASROFN		;GET AN OFN FOR BACKUP FILE
	 RETBAD ()		;FAILED, RETURN
	MOVEM A,BKOFN		;SAVE THE OFN FOR THE BACKUP FILE
	MOVE A,DIDSCI		;GET ADR OF ROOT-DIR
	TLO A,(FILWB+FILNB+THAWB)
	MOVE B,STRN02		;B/STRUCTURE NUMBER
	CALL ASROFN		;GET AN OFN FOR ROOT-DIR
	 JRST FLRER1		;FAILED, GO RELEASE BACKUP FILE OFN AND RETURN
	MOVEM A,FILREO		;SAVE THE OFN
	MOVE B,STRN02		;GET STRUCTURE NUMBER
	MOVE B,STRTAB(B)	;GET ADDRESS OF SDB
	STOR A,STRRDO,(B)	;SAVE OFN OF ROOT-DIRECTORY
	CALL ASGPAG		;GET A PAGE TO MAP ROOT-DIR INTO
	 JRST FLRER2		;FAILED, RELEASE OFN'S AND RETURN ERROR
	MOVEM A,FILRER		;SAVE ADDRESS
	MOVE B,A		;NOW MAP IN THE IB OF THE ROOT
	TLO B,(PTRW)		;READ WRITE
	MOVE A,FILREO		;GET THE OFN
	CALL SETMPG
	CALL ASGPAG		;NOW GET A PAGE FOR THE BACKUP IB
	 JRST FLRER3		;FAILED, CLEAN UP AND RETURN ERROR
	MOVEM A,FILREB		;SAVE ADDRESS OF PAGE
	MOVE B,A		;MAP IN IB OF BACKUP FILE
	TLO B,(PTRW)
	MOVE A,BKOFN		;GET OFN
	CALL SETMPG		;MAP IN IB
	MOVE A,FILREB		;SEE IF THERE IS A BACKUP FILE
	SKIPN 0(A)		;PAGE 0 MUST BE THERE
	JRST FLRER4		;NO PAGE 0, CLEAN UP AND RETURN ERROR
	HRL A,FILREB		;GET SOURCE ADR
	HRR A,FILRER		;GET DESTINATION ADR
	MOVEI B,777(A)		;GET FINAL ADR
	BLT A,0(B)		;COPY BACKUP IB TO ROOT-DIR IB
	HRRZ A,FILREB
	SETZM 0(A)		;ZERO FIRST WORD
	HRL A,FILREB		;NOW ZERO BACKUP IB
	MOVEI B,777(A)		;GET FINAL ADR
	HRRI A,1(A)		;GET DESTINATION ADR
	BLT A,0(B)		;ZERO THE IB
	MOVE A,FILREO		;NOW CAUSE THE OFN TO BE WRITTEN OUT
	MOVX B,OFNWRB		;GUARANTEE IT WILL BE WRITTEN
	IORM B,SPTH(A)		;...
	CALL UPDOFN		;WRITE OFN TO DISK
	MOVE A,BKOFN		;DO THE SAME FOR BACKUP OFN
	MOVX B,OFNWRB
	IORM B,SPTH(A)
	CALL UPDOFN
	MOVEI A,0		;NOW UNMAP THE TEMP PAGES
	MOVE B,FILRER
	CALL SETMPG
	MOVEI A,0
	MOVE B,FILREB
	CALL SETMPG
	MOVE A,FILRER		;AND RELEASE THE TEMP PAGES
	CALL RELPAG
	MOVE A,FILREB
	CALL RELPAG
	MOVE A,BKOFN		;RELEASE THE OFN OF BACKUP FILE
	CALL RELOFN
	MOVE A,FILREO		;1/OFN FOR ROOT-DIRECTORY
	CALL RELOFN		;RELEASE THE OFN FOR ROOT-DIRECTORY
				; (CALLER WILL DO ASOFN LATER)
	MOVE A,STRN02		;GET STRUCTURE NUMBER
	MOVE A,STRTAB(A)	;POINT TO ITS SDB
	SETZRO STRRDO,(A)	;CLEAR THE OFN FOR ROOT-DIRECTORY
	RETSKP

RCDMSG:	ASCIZ/
[RECONSTRUCTION PHASE 1 COMPLETED]
/

; ERROR RETURN ROUTINES FOR FILREC

FLRER4:	MOVE A,FILREB		;GET PAGE FOR BACKUP XB
	CALL RELPAG		;RELEASE THE PAGE

FLRER3:	MOVE A,FILRER		;GET ADDRESS OF PAGE
	CALL RELPAG		;RELEASE THE PAGE

FLRER2:	MOVE A,FILREO		;GET OFN OF ROOT-DIRECTORY
	CALL RELOFN		;RELEASE THE OFN

FLRER1:	MOVE A,BKOFN		;GET OFN OF BACKUP FILE
	CALLRET RELOFN		;RELEASE THE OFN AND RETURN ERROR
;CPYBAK - COPY THE ROOT-DIRECTORY FILE TO THE BACKUP FILE
;ACCEPTS: A/ STRUCTURE NUMBER
;	CALL CPYBAK
;RETURNS +1:	ERROR DURING COPYING
;	 +2:	OK

;NOT CALLED FROM WITHIN FILINI

CPYBAK::SAVEQ
	EA.ENT
	STKVAR <STRN03,CPYBKA,CPYBKJ,CPYBKO>
	MOVEM A,STRN03		;SAVE STRUCTURE NUMBER
	NOINT			;DONT ALLOW INTERRUPTS OUT OF THIS
	SETZM Q2		;ASSUME SUCCESS
	MOVEI B,^D14		;GET ENOUGH SPACE FOR NAME OF BACKUP FILE
	CALL ASGJFR		;ASSIGN SPACE FOR COMPLETE NAME
	 RETBAD (,OKINT)	;FAILED, GIVE UP
	MOVE Q1,A		;SAVE ADDRESS OF BLOCK
	HRROI A,1(A)		;FORM POINTER TO WHERE NAME WILL GO
	MOVE B,STRN03		;GET STRUCTURE NUMBER
	HRROI C,[ASCIZ/<ROOT-DIRECTORY>BACKUP-COPY-OF-ROOT-DIRECTORY.IMAGE/]
	CALL STRST		;FORM COMPLETE FILE NAME
	 JRST [	SETOM Q2	;MARK THAT FAIL RETURN IS NEEDED
		JRST CPYBK6 ]	;GO RELEASE SPACE AND GIVE FAIL RETURN
	MOVX A,GJ%OLD!GJ%PHY!GJ%SHT
	HRROI B,1(Q1)		;GET POINTER TO NAME
	GTJFN			;GET JFN FOR BACKUP FILE
	 SETOM Q2		;MARK THAT FAIL RETURN IS NEEDED
	MOVEM A,CPYBKJ		;SAVE JFN
CPYBK6:	MOVEI A,JSBFRE		;GET ADDRESS OF FREE HEADER
	MOVE B,Q1		;GET ADDRESS OF BLOCK
	CALL RELFRE		;RELEASE FREE SPACE
	JUMPN Q2,R		;GIVE FAIL RETURN IF NEEDED

;[7172]SET THE 'NEVER DELETE' BIT IN THE FDB FOR THE BACKUP COPY OF THE
;[7172]ROOT DIRECTORY SO IT WILL NOT BE DELETED ACCIDENTLY.

	HRRZ A,CPYBKJ		;GET JFN
	IMULI A,MLJFN		;INDEX INTO JFN TABLES
	CALL GETFDT		;GET THE FDB FOR THIS FILE
	 JRST CPYBK4		;FAILED. GO REPORT ERROR
	SETONE <FBNDL>,(A)	;[7172]SET THE FILE 'NEVER DELETE'
	SETONE <K0EXM>,(A)	;SET EXEMPT FROM MIGRATION BIT
	CALL USTDIR		;UNLOCK THE DIRECTORY
	HRRZ A,CPYBKJ		;GET JFN AGAIN
	MOVE B,[440000,,OF%RD+OF%WR+OF%THW]
	OPENF			;OPEN THE FILE FOR READ AND WRITE
	 RETBAD (,<MOVE A,CPYBKJ
		   RLJFN
		    JFCL
		   OKINT>)
	CALL ASGPAG		;GET A TEMPORARY PAGE FOR PMAPING
	 JRST CPYBK4		;FAILED TO GET A PAGE
	MOVEM A,CPYBKA		;SAVE ADR OF PAGE
	MOVEI A,ROOTDN		;NOW MAP IN ROOT-DIR
	MOVE B,STRN03		;GET STRUCTURE NUMBER
	CALL MAPDIR		;...
	 JRST CPYBK5		;FAILED
	CALL BLKSCN		;MAKE SURE THIS IS A STILL VALID
	 JRST CPYBK5		;ROOT-DIR IS SICK, DONT KILL BACKUP
	CALL SYMCHK		;CHECK VALIDITY OF SYMBOL TABLE ALSO
	 JRST CPYBK5		;NO, DONT DESTROY OLD GOOD COPY
	HRLZ A,CPYBKJ		;GET OFN OF THIS FILE
	CALL JFNOFN		;FOR USE BY SETMPG
	 JRST CPYBK5		;FAILED
	HLRZM A,CPYBKO		;SAVE OFN
	MOVN Q1,NDIRPG		;SET UP AOBJN COUNTER
	HRLZS Q1
	;..
	;..

CPYBK1:	MOVE B,STRN03		;GET STRUCTURE NUMBER
	MOVE B,STRTAB(B)	;GET ADDRESS OF SDB
	LOAD A,STRRDO,(B)	;GET OFN OF ROOT-DIRECTORY
	HRLZ A,A		;CHECK IF ROOT-DIR PAGE EXISTS
	HRR A,Q1		;GET PAGE NUMBER
	CALL MRPACS		;GET ACCESSIBILITY
	TXNN A,PA%PEX		;PAGE EXIST?
	JRST CPYBK2		;NO, SKIP THIS PAGE
	HRR A,Q1		;GET PAGE #
	HRL A,CPYBKO		;GET OFN OF FILE
	MOVX B,PTRW		;READ AND WRITE ACCESS
	HRR B,CPYBKA		;GET ADR OF WHERE TO MAP FILE PAGE
	CALL SETMPG		;GET PAGE OF BACKUP FILE MAPPED IN
	MOVEI B,0(Q1)		;NOW SET UP TO BLT ROOT-DIR TO FILE
	LSH B,PGSFT		;GET ADDRESS OF ROOT-DIR PAGE
	ADD B,DIRORA		;ADD IN BASE ADR
	MOVE C,CPYBKA		;GET DEST ADDRESS
	MOVEI A,1000
	CALL XBLTA		;COPY ROOT-DIR TO BACKUP FILE
	MOVEI A,0		;UNMAP THE PAGE
	MOVE B,CPYBKA
	CALL SETMPG
CPYBK2:	AOBJN Q1,CPYBK1		;LOOP BACK FOR ALL PAGES IN DIR
CPYBK3:	MOVE A,CPYBKA		;NOW RELEASE TEMP PAGE
	CALL RELPAG		;...
	MOVE A,CPYBKJ		;AND RELEASE JFN
	CLOSF
	 JFCL
	OKINT
	RETSKP			;COPY HAS BEEN MADE SUCCESSFULLY

CPYBK5:	MOVE A,CPYBKA		;RELEASE TEMP PAGE
	CALL RELPAG
CPYBK4:	MOVE A,CPYBKJ		;AND RELEASE JFN
	RLJFN
	 JFCL
	OKINT
	RET			;GIVE ERROR RETURN

;ROUTINE TO GET AN OFN FOR THE INDEX TABLE FILE
;
; ACCEPTS:
;	T1/ STRUCTURE NUMBER
;		CALL FNDIDX IF FILE EXISTS
;			OR
;		CALL MAKIDX TO CREATE FILE

; RETURNS: +1	 ERROR
;	   +2	SUCCESS, HANDLE FOR INDEX TABLE FILE STORED IN SDB

;CALLED FROM REFRESH AND NORMAL STARTUP CODE AND WELL AS MSTR

FNDIDX::TDZA T3,T3		;INDICATE MUST FIND OLD FILE
MAKIDX::SETOM T3		;INDICATE CREATING NEW FILE
	STKVAR <CRIDXS,CRIDXB,CRIDXE,CRIDXJ,CRIDXF>
	EA.ENT
	MOVEM T3,CRIDXF		;SAVE INDICATOR OF ENTRY POINT
	MOVEM T1,CRIDXS		;SAVE STRUCTURE NUMBER
	SETZM CRIDXE		;INITIALIZE ERROR FLAG
	MOVEI T2,12		;GET # OF WORDS NEEDED FOR FILE NAME
	NOINT			;NOINT WHILE HAVE JSB FREE SPACE
	CALL ASGJFR		;ASSIGN SOME FREE SPACE
	 RETBAD (MONX02,<OKINT>) ;RETURN "INSUFFICIENT RESOURCES" - JSB FULL
	MOVEM T1,CRIDXB		;SAVE ADDRESS OF BLOCK ASSIGNED

; GET A JFN FOR THE INDEX TABLE FILE

	HRROI T1,1(T1)		;FORM POINTER TO WHERE NAME WILL GO
	MOVE T2,CRIDXS		;GET STRUCTURE NUMBER
	HRROI T3,[ASCIZ/<ROOT-DIRECTORY>INDEX-TABLE.BIN.1/]
	CALL STRST		;FORM COMPLETE FILE NAME
	 JRST [	SETOM CRIDXE	;FAILED, NOTE THAT AN ERROR OCCURRED
		JRST CRIDX2 ]	;FAILED, NOTE ERROR AND GO RELEASE SPACE
	MOVE T2,CRIDXB		;GET ADDRESS OF BLOCK CONTAINING NAME
	HRROI T2,1(T2)		;FORM POINTER TO FILE NAME
	SKIPE CRIDXF		;WANT TO CREATE IDXTAB?
	JRST MAKID1		;YES. GO DO IT
	MOVX T1,GJ%SHT!GJ%PHY!GJ%OLD!GJ%DEL ;SHORT CALL, PHYSICAL ONLY, OLD FILE
	GTJFN			;GET A JFN FOR THE INDEX TABLE FILE
MAKID2:	 JRST [	SETOM CRIDXE
		JRST CRIDX2]
	MOVEM T1,CRIDXJ		;SAVE JFN OF INDEX TABLE FILE
	HRLI T1,.FBCTL		;SET UP TO CHANGE CONTROL WORD
	MOVX T2,FB%DEL		;CHANGE DELETED BIT
	SETZM T3		;CLEAR IT
	CHFDB			;DO IT
	 ERJMP [SETOM CRIDXE	;INDICATE ERROR
		JRST CRIDX2]
	JRST CRIDX2		;GO TO COMMON CODE

;HERE WHEN CREATING NEW IDXTAB

MAKID1:	MOVX T1,GJ%SHT!GJ%PHY 	;TRY TO CREATE FILE
	GTJFN			;GET A JFN FOR THE NEW FILE
	 JRST [	SETOM CRIDXE	;FAILED, NOTE ERROR
		JRST CRIDX2 ]	;GO RELEASE SPACE AND RETURN ERROR TO USER
	MOVEM T1,CRIDXJ		;SAVE JFN OF NEW FILE
	MOVEI T2,.AREXM		;SET THE
	MOVEI T3,.ARSET		; EXEMPT FROM MIGRATION BIT
	ARCF			;DO IT
	 ERJMP .+1		;IGNORE ERRORS
	MOVE T1,CRIDXJ		;RESTORE JFN
	HRLI T1,.FBCTL		;GET OFFSET TO WORD TO BE CHANGED
	MOVX T2,FB%NOD!FB%NDL	;[7172]MAKE THE FILE NOT DUMP-ABLE
	MOVX T3,FB%NOD!FB%NDL	;[7172] AND 'NEVER DELETE'
	CHFDB			;CHANGE THE FDB OF THE NEW FILE
	 ERJMP .+1		;IGNORE FAILURE
	HRRZ T1,CRIDXJ		;GET JFN OF NEW INDEX TABLE FILE
	MOVX T2,<FLD(^D36,OF%BSZ)+OF%WR>
	OPENF			;OPEN THE FILE TO CREATE THE INDEX BLOCK
	 JRST [	SETOM CRIDXE	;NOTE OCCURRANCE OF ERROR
		MOVE T1,CRIDXJ	;GET JFN
		RLJFN		;RELEASE THE JFN
		 JFCL		;IGNORE ERRORS HERE
		JRST CRIDX2]	;GO RELEASE SPACE AND RETURN ERROR
	TXO T1,CO%NRJ		;DON'T RELEASE THE JFN
	CLOSF			;CLOSE THE FILE
	 JFCL			;IGNORE ERROR HERE
	MOVE T1,CRIDXS		;GET STRUCTURE NUMBER
	CALL CPYBAK		;UPDATE BACKUP COPY OF ROOT-DIRECTORY
	 JFCL			;IGNORE FAILURE TO UPDATE BACKUP ROOT-DIR

; RELEASE SPACE USED TO HOLD FILE NAME - RETURN ERROR IF ANYTHING HAS FAILED

CRIDX2:	MOVEI T1,JSBFRE		;GET FREE HEADER
	MOVE T2,CRIDXB		;GET ADDRESS OF FREE BLOCK
	CALL RELFRE		;RELEASE THE SPACE
	OKINT			;OKINT NOW THAT JSB FREE SPACE RETURNED
	SKIPE CRIDXE		;ANY ERRORS SO FAR ?
	RETBAD (MSTX11)		;YES, RETURN ERROR

; ASSIGN AN OFN FOR THE INDEX TABLE FILE AND SAVE IN THE SDB FOR THIS STRUCTURE

	MOVE T1,CRIDXJ		;GET THE JFN OF THE INDEX TABLE FILE
	IMULI T1,MLJFN		;COMPUTE OFFSET TO JFN BLOCK
	CALL GETFDT		;GET THE ADDRESS OF THE FDB FOR THIS FILE
	 JRST [	SETOM CRIDXE	;FAILED, NOTE THAT AN ERROR OCCURRED
		JRST CRIDX4 ]	;GO RELEASE THE JFN AND RETURN ERROR TO USER
	LOAD T1,FBADR,(A)	;GET ADDRESS OF INDEX BLOCK
	TXO T1,FILWB+THAWB	;OPEN FOR WRITE, THAWED
	MOVE T2,CRIDXS		;GET STRUCTURE NUMBER
	CALL ASROFN		;ASSIGN AN OFN IN THE ROOT-DIRECTORY
	 JRST [	SETOM CRIDXE	;FAILED, NOTE THAT AN ERROR OCCURRED
		JRST CRIDX3 ]	;GO UNLOCK DIRECTORY AND RETURN ERROR
	MOVE T2,CRIDXS		;GET STRUCTURE NUMBER
	MOVE T2,STRTAB(T2)	;GET ADDRESS OF SDB FOR THIS STRUCTURE
	STOR T1,STRIDX,(T2)	;STORE OFN OF INDEX TABLE IN SDB
	SETONE STIDX,(T2)	;NOTE THAT INDEX TABLE OFN HAS BEEN SET UP
CRIDX3:	CALL USTDIR		;UNLOCK THE DIRECTORY
CRIDX4:	MOVE T1,CRIDXJ		;GET JFN OF INDEX TABLE FILE
	RLJFN			;RELEASE THE JFN
	 JFCL			;FAILED, IGNORE FAILURE
	SETZRO <CURSTR,CURUC,IDXFLG>
	SKIPE CRIDXE		;ANY ERRORS OCCUR ?
	RETBAD (MSTX11)		;YES, RETURN ERROR CODE
	RETSKP			;NO, RETURN SUCCESS

;ROUTINE TO INITIALIZE THE INDEX TABLE
; CALL:	ACCEPTS IN T1/ STRUCTURE NUMBER
;		CALL IDXINI
;RETURNS +1:	 ERROR
;	 +2:	SUCCESS

;CALLED FROM COMMON CODE

IDXINI::STKVAR <IDXINS,IDXINR> ;VARIABLES FOR STRUCTURE NUMBER AND FWDN FOR ROOT
	EA.ENT
	SAVEP			;SAVE PERMANENT ACS
	MOVEM A,IDXINS		;SAVE STRUCTURE NUMBER

;CHECK ROOT-DIRECTORY AND REBUILD IT IF NECESSARY

	MOVE A,STRTAB(A)	;GET SDB
	LOAD B,STRUC,(A)	;GET UNIQUE CODE FOR THIS STRUCTURE
	HRLZS B			;B/ UNIQUE CODE,,DIRECTORY NUMBER
	HRRI B,ROOTDN		; FOR ROOT-DIRECTORY ON THIS STRUCTURE
	MOVEM B,IDXINR		;SAVE 36-BIT DIRECTORY NUMBER
	MOVX A,DD%CHK		;CHECK SYMBOL TABLE
	DELDF			;CHECK ROOT-DIRECTORY
	 ERJMP [MOVX A,DD%RST	;ERRORS - REBUILD
		MOVE B,IDXINR	;GET DIR NUMBER BACK
		DELDF		;REBUILD SYMBOL TABLE
		 ERJMP R	;IF FAILED, TELL CALLER
		JRST .+1]	;REBUILD SUCCEEDED

;MAP IN ROOT-DIRECTORY AND INITIALIZE ITS MAXIMUM ALLOWABLE SUBDIRECTORIES

	MOVE A,IDXINS		;GET STRUCTURE NUMBER
	MOVE A,IDXINR		;A/ (UNIQUE CODE,,DIRECTORY NUMBER) FOR ROOT-DIRECTORY
	CALL SETDIR		;MAP ROOT-DIRECTORY
	 RETBAD			;FAILED
	MOVE A,DIRORA		;CHECK SUBDIR COUNT
	LOAD B,DRSDC,(A)	; ...
	SKIPN B			;ZERO?
	MOVE B,MXDIRN		;YES - ROOT DIR ALWAYS HAS AT LEAST
	STOR B,DRSDC,(A)	;ITSELF
	CALL CLRIDX		;START BY ZEROING IDXTAB
	CALL USTDIR		;AND UNLOCK THE ROOT-DIR

;STEP THROUGH ALL DIRECTORIES AND CREATE THEIR ENTRIES IN IDXTAB

	HLLZ A,IDXINR		;GET STRUCTURE UNIQUE CODE
	MOVX F1,DIRSF!STEPF	;INDICATE STEPPING
IDXIN1:	SETZ C,			;NO WILD MASK
	CALL MDDDIR		;STEP THROUGH DIRS AND SETUP INDEX
	 JRST IDXIN2		;ANALYZE ERROR
	CALL USTDIR		;UNLOCK
	JRST IDXIN1		;LOOP

;HERE WHEN MDDDIR RETURNS FAILURE.  ALWAYS GET HERE WHEN IT REACHES
;LAST DIRECTORY

IDXIN2:	CAIE A,GJFX32		;NO MORE DIRECTORIES?
	BUG.(CHK,BADIDX,FILINI,HARD,<IDXINI - Partially unsuccessful index table rebuild>,,<

Cause:	IDXINI failed to create the index-table file during a refresh of
	PS:. Some of the directories may have been entered into the file
	before this failure occurred.
>,,<DB%NND>)			;[7.1210] 
	MOVE B,IDXINS		;GET STRUCTURE NUMBER
	MOVE B,STRTAB(B)	;GET ADDRESS OF SDB
	LOAD A,STRIDX,(B)	;GET OFN OF IDXTAB
	HRLZS A
	MOVEI T2,1000
	CALL UPDPGS
	MOVE A,IDXINS
	MOVE A,STRTAB(A)
	LOAD A,STRIDX,(A)
	CALL UPDOFN		;UPDATE ON DISK
	RETSKP			;RETURN SUCCESS

;SETUP NEW INDEX BLOCK FOR ROOT-DIRECTORY
;ACCEPTS:
;	A/DESIRED ADR OF INDEX BLOCK
;	B/STRUCTURE NUMBER

;	CALL NEWIB
; RETURN +1:  FAILURE
;	 +2: SUCCESS, WITH
;	1/ OFN
;	2/ DISK ADR

;CALLED FROM REFRESH CODE

NEWIB::	STKVAR<STRN04,DSKADR,IBOFN>
	MOVEM B,STRN04		;SAVE STRUCTURE NUMBER
	MOVSI C,(FILWB+FILNB+THAWB) ;CONSTRUCT BITS FOR CALL TO ASOFN
	MOVEM C,DSKADR		;SAVE TO MERGE WITH ADDRESS LATER
	CALL DSKASA		; Get a blank disc address
	 RET			;FAILED, RETURN ERROR
	EXCH A,DSKADR		;SAVE DSK ADR, RECOVER BITS
	IOR A,DSKADR		;MERGE ADR WITH BITS
	MOVE B,STRN04		;B/STRUCTURE NUMBER
	CALL ASROFN
	 RET			;FAILED, RETURN ERROR
	MOVEM A,IBOFN		;SAVE THE OFN
	CALL UPDOFN		;WRITE THE INDEX BLOCK TO THE DISK
	MOVE A,IBOFN		;RESTORE THE OFN
	MOVE B,DSKADR		;RESTORE THE DISK ADDRESS
	RETSKP

	TNXEND
	END

                                                                                                                                                                                                                                                      