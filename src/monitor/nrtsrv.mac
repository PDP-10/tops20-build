; UPD ID= 8569, RIP:<7.MONITOR>NRTSRV.MAC.2,  11-Feb-88 11:43:37 by GSCOTT
;TCO 7.1218 - Update copyright date.
; UPD ID= 2138, SNARK:<6.1.MONITOR>NRTSRV.MAC.12,   5-Jun-85 10:08:35 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 1590, SNARK:<6.1.MONITOR>NRTSRV.MAC.11,   5-Mar-85 18:03:01 by GLINDELL
;TCO 6.1.1233 - do the right things when logins not allowed
; UPD ID= 1577, SNARK:<6.1.MONITOR>NRTSRV.MAC.10,   1-Mar-85 13:23:32 by GLINDELL
;Remove NVTPSI - it can legally happen
; UPD ID= 1407, SNARK:<6.1.MONITOR>NRTSRV.MAC.9,  27-Jan-85 16:57:53 by NICHOLS
;Add data to NVTPSI BUGCHK, clean up some OPSTR <SKIPx> to be TMNx
; UPD ID= 1145, SNARK:<6.1.MONITOR>NRTSRV.MAC.8,   3-Dec-84 17:32:15 by GLINDELL
;D36COM is now in XCDSEC
; UPD ID= 1020, SNARK:<6.1.MONITOR>NRTSRV.MAC.7,   9-Nov-84 15:56:56 by PRATT
;More TCO 6.1.1022 - More of edit 983
;  Fix bad byte pointer when no host number
;  Set no known node name when SCTA2N fails or no host number
; UPD ID= 1007, SNARK:<6.1.MONITOR>NRTSRV.MAC.6,   7-Nov-84 21:35:09 by PRATT
;More TCO 6.1.1022 - EBD - Fix foolish typo in last edit
; UPD ID= 983, SNARK:<6.1.MONITOR>NRTSRV.MAC.5,   7-Nov-84 08:18:12 by PRATT
;More TCO 6.1.1022 - Fix problem with bad byte pointer if SCTA2N fails
; UPD ID= 956, SNARK:<6.1.MONITOR>NRTSRV.MAC.4,   5-Nov-84 19:16:26 by PRATT
;TCO 6.1.1032 - Make TTYSRV compile independently:
;  Move TTNU1 here and call it TTMCNU
;  Rename TTPHDV.MAC to NRTSRV.MAC
;  Duplicate the TTPHDV edit history here and in RSXSRV.MAC
;  Change reference of TTYASN to TTYASG
;  Change INTRAN to DINTRN since it conflicts with global in STG
;  Make many symbols global for TTYSRV
;  Don't use TDCALL to CTHNRT, TDCALx's are now only defined in TTYSRV
; UPD ID= 930, SNARK:<6.1.MONITOR>TTPHDV.MAC.20,  28-Oct-84 11:12:08 by PRATT
;TCO 6.1.1022 - Add support code for NTINF jsys: 
;  Add field NRRID for remote host ID
;  Do a read connect info to get the remote host ID just before accepting
; UPD ID= 713, SNARK:<6.1.MONITOR>TTPHDV.MAC.18,  26-Jul-84 08:31:11 by MCINTEE
;Add CTERM - NRT support
; UPD ID= 578, SNARK:<6.1.MONITOR>TTPHDV.MAC.17,  29-May-84 14:57:05 by MCINTEE
;Fix another of previous
; UPD ID= 575, SNARK:<6.1.MONITOR>TTPHDV.MAC.16,  29-May-84 13:19:03 by MCINTEE
;Fix detach/attach bug in NRT (TNUKIL)
; UPD ID= 545, SNARK:<6.1.MONITOR>TTPHDV.MAC.15,  23-May-84 07:49:45 by MCINTEE
;Merge from M60:
; UPD ID= 4178, SNARK:<6.MONITOR>TTPHDV.MAC.89,   7-May-84 13:32:27 by LOMARTIRE
;More TCO 6.2047 - Fix all possible cases of PI 6 NOSKED/OKSKED from TTYDED
; UPD ID= 381, SNARK:<6.1.MONITOR>TTPHDV.MAC.14,  12-Mar-84 14:58:09 by MCINTEE
;Fix logout bug in NRT.
; UPD ID= 332, SNARK:<6.1.MONITOR>TTPHDV.MAC.13,  13-Feb-84 14:35:32 by MCINTEE
;Make NRTSOF get more buffers
; UPD ID= 293, SNARK:<6.1.MONITOR>TTPHDV.MAC.12,  16-Jan-84 08:33:37 by MCINTEE
;Merge from M60:
; UPD ID= 3397, SNARK:<6.MONITOR>TTPHDV.MAC.88,   3-Jan-84 10:38:46 by PRATT
;TCO 6.1796 - Create TTNTM1, sets/clears TTNTS in fe only.
; UPD ID= 286, SNARK:<6.1.MONITOR>TTPHDV.MAC.11,   5-Jan-84 17:33:38 by NICHOLS
;Fix previous edit, it should give up (RET), not go to MCSRV2 or MCSRV5
; UPD ID= 282, SNARK:<6.1.MONITOR>TTPHDV.MAC.10,  27-Dec-83 23:23:52 by GROSSMAN
;Fix bug in MCSRV when NRTUNB fails, go to MCSRV2, not MCSRV5.
; UPD ID= 218, SNARK:<6.1.MONITOR>TTPHDV.MAC.9,  17-Oct-83 15:48:54 by MCINTEE
;Change IBFRCC to IBRFC1
; UPD ID= 197, SNARK:<6.1.MONITOR>TTPHDV.MAC.8,  25-Aug-83 07:55:07 by MCINTEE
;TCO 6.1784 - In TTSETH, fix logic that sets TTNPM 
; UPD ID= 191, SNARK:<6.1.MONITOR>TTPHDV.MAC.7,   5-Aug-83 12:29:25 by MCINTEE
;Yet another NRT bug fix. Add a SETZRO TTOTP in NETUSER release code.
; UPD ID= 189, SNARK:<6.1.MONITOR>TTPHDV.MAC.6,   4-Aug-83 09:46:46 by MCINTEE
;TCO 6.1718 - Fix code so LOCAL AUTOBAUD lines don't get the REMOTE bit set
;	when the speed is recieved from the FE
; UPD ID= 187, SNARK:<6.1.MONITOR>TTPHDV.MAC.5,   2-Aug-83 15:52:22 by MCINTEE
;More TCO 6.1426 - remove an extra SETZRO TTPRM
;TCO 6.1600 - Allow LOCAL lines to be set as autobaud
; UPD ID= 104, SNARK:<6.1.MONITOR>TTPHDV.MAC.8,  18-Apr-83 13:12:19 by PAETZOLD
;TCO 6.1557 - TCP Merge
; UPD ID= 94, SNARK:<6.1.MONITOR>TTPHDV.MAC.7,  28-Mar-83 14:03:38 by MCINTEE
;Do the previous edit in a cleaner manner
; UPD ID= 93, SNARK:<6.1.MONITOR>TTPHDV.MAC.6,  28-Mar-83 12:35:46 by MCINTEE
;Fix bug in NRT that causes an occasional NSKDIS bughlt.
; UPD ID= 2039, SNARK:<6.MONITOR>TTPHDV.MAC.83,  20-Mar-83 12:46:39 by HALL
;TCO 6.1502 - Allow resident free space in extended section
;	Use one-word global byte pointers to point to sendall buffer and
;		I/O buffers, which must be in section 0 for the DTE.
;	Convert one-word global to one-word local before handing to DTESRV
;	Change handling of end of I/O buffers, and definition of WRPMSK,
;		to reflect use of one-word globals
;	In FNDEND, use ADJBP to decrement byte pointer instead of previous hack
; UPD ID= 1985, SNARK:<6.MONITOR>TTPHDV.MAC.82,  14-Mar-83 08:48:34 by HALL
;TCO 6.1502 - Allow resident free space in extended section
;	Add EA.ENT to TTDTRM
; UPD ID= 1970, SNARK:<6.MONITOR>TTPHDV.MAC.81,  10-Mar-83 19:11:06 by HALL
;TCO 6.1502 - Allow resident free space in extended section
;	Add EA.ENT to TTYINT,TTSPST,TTYDON,TTYDLU,TTYHGU,TTYSLA,IDCTY,
;		DTESTO,DFNDL1
; UPD ID= 1945, SNARK:<6.MONITOR>TTPHDV.MAC.80,   9-Mar-83 10:16:58 by HALL
;TCO 6.1502 - Allow resident free space in extended section
;	Change call to ASGRSB to set RS%SE0
; UPD ID= 4, SNARK:<6.1.MONITOR>TTPHDV.MAC.2,   2-Feb-83 07:38:59 by MCINTEE
;TCO 6.1485 - Fix TCO 6.1480, put TT%XFF in dynamic storage block.
; UPD ID= 1714, SNARK:<6.MONITOR>TTPHDV.MAC.78,  28-Jan-83 10:56:17 by MURPHY
;More 6.1390 - Add dummy symbol if no FE code.
; UPD ID= 1711, SNARK:<6.MONITOR>TTPHDV.MAC.77,  27-Jan-83 22:58:02 by WEAVER
;TCO 6.1480 - Only send XOFF/XON status to front-end if TTXFF (XOFF FORCE)
;is set.
; UPD ID= 1572, SNARK:<6.MONITOR>TTPHDV.MAC.76,  27-Dec-82 08:30:12 by GRANT
;TCO 6.1426 - When closing an NVT connection, don't undo TTPRM if the line
; is an MCB TTY or the CTY
; UPD ID= 1533, SNARK:<6.MONITOR>TTPHDV.MAC.75,  14-Dec-82 09:55:48 by MURPHY
;TCO 5.1.1114 - Index needed at SNDXN2+8L to fix XOFF/XON for incoming chars.
; UPD ID= 1489, SNARK:<6.MONITOR>TTPHDV.MAC.74,  30-Nov-82 11:45:34 by WEAVER
;TCO 6.1393 - Use Break Through Write to send XONs and XOFFs to a line
; UPD ID= 1485, SNARK:<6.MONITOR>TTPHDV.MAC.73,  29-Nov-82 13:36:14 by MURPHY
;TCO 6.1390 - Shut off 20F line if more than 2 noise characters in 1 second.
; UPD ID= 1332, SNARK:<6.MONITOR>TTPHDV.MAC.72,  13-Oct-82 07:04:19 by GRANT
;More of previous edit - fix bug in TNTCLS's debugging code
; UPD ID= 1312, SNARK:<6.MONITOR>TTPHDV.MAC.71,   9-Oct-82 10:28:22 by GRANT
;TCO 5.1.1089 - Rewrite TNTCLS, save link IDs rather than LL block addresses
; UPD ID= 1086, SNARK:<6.MONITOR>TTPHDV.MAC.70,  16-Aug-82 14:31:44 by MURPHY
;TCO 6.1202 - Pass proper arg to TTCBF9 at TINET3.
; UPD ID= 994, SNARK:<6.MONITOR>TTPHDV.MAC.69,  18-Jul-82 13:52:18 by MURPHY
;TCO 5.1.1048 - Add TTCLSH to clear "set host" state when closing LL.
; UPD ID= 991, SNARK:<6.MONITOR>TTPHDV.MAC.68,  18-Jul-82 13:30:31 by MURPHY
;TCO 5.1.1047 - Put NOSKED before call to TNTCLS to interlock ULLCZQ.
; UPD ID= 990, SNARK:<6.MONITOR>TTPHDV.MAC.67,  18-Jul-82 13:28:02 by MURPHY
;TCO 5.1.1046 - Check TTNUS before call to TNUREC.
; UPD ID= 970, SNARK:<6.MONITOR>TTPHDV.MAC.66,  30-Jun-82 08:55:45 by GRANT
;TCO 5.1.1038 - Remove CALL SQIACK in DECnet NVT processor
; UPD ID= 328, SNARK:<6.MONITOR>TTPHDV.MAC.58,  19-Jan-82 15:23:21 by MURPHY
;TCO 5.1688 - report TTYSTP only once per line
; UPD ID= 851, SNARK:<6.MONITOR>TTPHDV.MAC.65,   6-Jun-82 13:29:44 by MURPHY
;TCO 6.1147 - Move bugdefs from BUGS.MAC to here and put them in-line.
; UPD ID= 819, SNARK:<6.MONITOR>TTPHDV.MAC.64,   3-Jun-82 07:42:18 by GRANT
;TCO 6.1154 - Fix failure return from CALL SNDCHK in MCSTRO.
;Change comment in CHKLLT.
; UPD ID= 800, SNARK:<6.MONITOR>TTPHDV.MAC.63,   1-Jun-82 08:31:46 by GRANT
;TCO 6.1148 - Remove code which breaks DECnet connection when a character is
;received on a line on which there is no job
; UPD ID= 771, SNARK:<6.MONITOR>TTPHDV.MAC.62,  19-May-82 17:20:19 by MILLER
;TCO 6.1066 AGAIN. Make RSP output work in secondary protocol
; UPD ID= 505, SNARK:<6.MONITOR>TTPHDV.MAC.61,  16-Mar-82 07:01:10 by MILLER
; UPD ID= 476, SNARK:<6.MONITOR>TTPHDV.MAC.60,  13-Mar-82 14:49:59 by MILLER
;TCO 6.1066 AGAIN. Add some of the RSP support code
; UPD ID= 458, SNARK:<6.MONITOR>TTPHDV.MAC.59,  11-Mar-82 11:47:06 by MILLER
;TCO 6.1066. Make MCSRV internal
; UPD ID= 328, SNARK:<6.MONITOR>TTPHDV.MAC.58,  19-Jan-82 15:23:21 by MURPHY
;TCO 5.1688 - report TTYSTP only once per line
; UPD ID= 150, SNARK:<6.MONITOR>TTPHDV.MAC.57,  21-Oct-81 12:14:07 by GRANT
;TCO 5.1594 - Move code from MCTYI2 and MCTYI3 into NSPSRV
; UPD ID= 193, SNARK:<5.MONITOR>TTPHDV.MAC.56,  17-Sep-81 13:19:49 by GRANT
;Reinstate the UPD ID=153 edit.  Also, it should say TCO 5.1490 no 5.1409
; UPD ID= 172, SNARK:<5.MONITOR>TTPHDV.MAC.55,  14-Sep-81 13:44:20 by GRANT
;Temporarily undo previous edit
; UPD ID= 153, SNARK:<5.MONITOR>TTPHDV.MAC.54,   8-Sep-81 17:31:11 by GRANT
;Needed for TCO 5.1490 - Remove segment number handling in MCTYI3
; UPD ID= 172, SNARK:<5.MONITOR>TTPHDV.MAC.55,  14-Sep-81 13:44:20 by GRANT
;Temporarily undo previous edit
; UPD ID= 153, SNARK:<5.MONITOR>TTPHDV.MAC.54,   8-Sep-81 17:31:11 by GRANT
;Needed for TCO 5.1409 - Remove segment number handling in MCTYI3
;Minor changes needed for handling LLOMSG queue in MCTYI3 and MCTYI2
; UPD ID= 138, SNARK:<5.MONITOR>TTPHDV.MAC.53,   2-Sep-81 16:38:01 by GRANT
;Eliminate cause of OKSKBG BUGHLT - in TNHCLS, NOSKED before calling TTCOB5
; UPD ID= 2307, SNARK:<5.MONITOR>TTPHDV.MAC.52,   8-Jul-81 11:20:59 by MURPHY
;CALL REQNS INSTEAD OF TNUSND FROM TTCHI
; UPD ID= 2295, SNARK:<5.MONITOR>TTPHDV.MAC.51,   6-Jul-81 13:50:54 by MURPHY
;DEBUG CODE TO RECORD DEAD LINKS
;PROCESS ALL INPUT IN TINET BEFORE QUITTING
; UPD ID= 2269, SNARK:<5.MONITOR>TTPHDV.MAC.50,  29-Jun-81 17:48:31 by MURPHY
;ANTX01
; UPD ID= 2190, SNARK:<5.MONITOR>TTPHDV.MAC.49,  11-Jun-81 15:59:54 by MURPHY
;CHANGE TQNx TO TMNx REFLECTING CHANGE IN MACSYM
;DITTO
; UPD ID= 1867, SNARK:<5.MONITOR>TTPHDV.MAC.45,  21-Apr-81 23:41:55 by MURPHY
;DITTO
; UPD ID= 1865, SNARK:<5.MONITOR>TTPHDV.MAC.44,  21-Apr-81 18:29:43 by MURPHY
;DITTO
; UPD ID= 1830, SNARK:<5.MONITOR>TTPHDV.MAC.43,  17-Apr-81 14:19:33 by MURPHY
;MAKE LINE SHUTOFF FOR 5 SECONDS INSTEAD OF 3
;REVISE SENDALL LOGIC
;REVISE STARTUP LOGIC
; UPD ID= 1752, SNARK:<5.MONITOR>TTPHDV.MAC.42,  20-Mar-81 13:32:21 by MURPHY
;Ditto
; UPD ID= 1745, SNARK:<5.MONITOR>TTPHDV.MAC.41,  19-Mar-81 23:11:04 by MURPHY
;Fix problems with line shut-off and XOFF/XON logic.
; UPD ID= 1663, SNARK:<5.MONITOR>TTPHDV.MAC.40,  11-Mar-81 16:30:30 by MURPHY
;Fix up some failures of DTEQ which were not handled
; UPD ID= 1554, SNARK:<5.MONITOR>TTPHDV.MAC.39,  11-Feb-81 17:33:25 by MURPHY
;MAKE SURE LINE GETS RESTARTED AFTER STOP BECAUSE INBFR OR TTBBUF FULL
; UPD ID= 1550, SNARK:<5.MONITOR>TTPHDV.MAC.38,  10-Feb-81 17:57:41 by MURPHY
;FIX XOFF DURING SYSTEM STARTUP PROBLEM
;CHANGE NAMES TO BLSUB., BLCAL.
;DITTO
; UPD ID= 1477, SNARK:<5.MONITOR>TTPHDV.MAC.35,  22-Jan-81 12:24:13 by MURPHY
;FIX TTQAD PROBLEMS
; UPD ID= 1377, SNARK:<5.MONITOR>TTPHDV.MAC.34,  22-Dec-80 18:25:37 by MURPHY
;<5.MONITOR>TTPHDV.MAC.33, 17-Dec-80 18:10:33, EDIT BY MURPHY
;TNUREC
; UPD ID= 1361, SNARK:<5.MONITOR>TTPHDV.MAC.32,  17-Dec-80 15:46:27 by MURPHY
;CHKLLT
;<5.MONITOR>TTPHDV.MAC.31, 12-Dec-80 11:11:34, EDIT BY MURPHY
;<5.MONITOR>TTPHDV.MAC.30, 12-Dec-80 10:34:51, EDIT BY MURPHY
;<5.MONITOR>TTPHDV.MAC.29, 12-Dec-80 10:23:26, EDIT BY MURPHY
;FLOW CONTROL
;<5.MONITOR>TTPHDV.MAC.28,  9-Dec-80 15:16:03, EDIT BY MURPHY
;CKMCOU
;<5.MONITOR>TTPHDV.MAC.27,  5-Dec-80 16:49:34, EDIT BY MURPHY
;VARIOUS MCB FIXES AND ENHANCEMENTS
;<5.MONITOR>TTPHDV.MAC.25, 24-Nov-80 16:46:49, EDIT BY MURPHY
;Requeue line if SQILS or SQIACK fails
;<5.MONITOR>TTPHDV.MAC.24, 21-Nov-80 18:29:16, EDIT BY MURPHY
;FLUSH LINK IF INPUT AND NO JOB
; UPD ID= 1301, SNARK:<5.MONITOR>TTPHDV.MAC.23,  19-Nov-80 17:05:35 by MURPHY
;LOCAL XON,XOFF OPTION FOR NVTS
; UPD ID= 1290, SNARK:<5.MONITOR>TTPHDV.MAC.22,  18-Nov-80 16:45:45 by MURPHY
;<5.MONITOR>TTPHDV.MAC.21, 31-Oct-80 17:37:34, EDIT BY MURPHY
;<5.MONITOR>TTPHDV.MAC.20, 30-Oct-80 22:59:18, EDIT BY MURPHY
;<5.MONITOR>TTPHDV.MAC.19, 21-Oct-80 12:10:07, EDIT BY MURPHY
;<5.MONITOR>TTPHDV.MAC.18, 20-Oct-80 17:12:52, EDIT BY MURPHY
;<5.MONITOR>TTPHDV.MAC.17, 20-Oct-80 14:40:25, EDIT BY MURPHY
;<5.MONITOR>TTPHDV.MAC.16,  7-Oct-80 15:27:36, EDIT BY MURPHY
;<5.MONITOR>TTPHDV.MAC.15,  6-Oct-80 11:32:21, EDIT BY MURPHY
; UPD ID= 1126, SNARK:<5.MONITOR>TTPHDV.MAC.14,   5-Oct-80 15:02:40 by MURPHY
;DITTO
;<5.MONITOR>TTPHDV.MAC.13,  3-Oct-80 14:04:57, EDIT BY MURPHY
; UPD ID= 1120, SNARK:<5.MONITOR>TTPHDV.MAC.12,   3-Oct-80 12:21:22 by MURPHY
;DITTO
; UPD ID= 1113, SNARK:<5.MONITOR>TTPHDV.MAC.11,   3-Oct-80 01:00:51 by MURPHY
;NVT IMPROVEMENTS
; UPD ID= 1077, SNARK:<5.MONITOR>TTPHDV.MAC.10,   1-Oct-80 10:37:44 by MURPHY
;RELEVANT END STATEMENTS FOR STKVAR, ETC.
; UPD ID= 1063, SNARK:<5.MONITOR>TTPHDV.MAC.9,  30-Sep-80 10:16:58 by MURPHY
;DITTO
; UPD ID= 1057, SNARK:<5.MONITOR>TTPHDV.MAC.8,  26-Sep-80 12:13:03 by MURPHY
;MCB FIXES
; UPD ID= 944, SNARK:<5.MONITOR>TTPHDV.MAC.7,  20-Aug-80 20:09:15 by MURPHY
;MCB FIXES
; UPD ID= 925, SNARK:<5.MONITOR>TTPHDV.MAC.6,  20-Aug-80 10:21:12 by MURPHY
;INCLUDE MCB DEVICE
; UPD ID= 699, SNARK:<5.MONITOR>TTPHDV.MAC.5,  25-Jun-80 17:23:34 by MURPHY
;REMOVE TTDBEF REDUNDANT SUBROUTINE
;MERGE TTFEDV AND TTDZDV FILES INTO TTPHDV
;CHANGE DEVICE VECTORING
; UPD ID= 645, SNARK:<5.MONITOR>TTFEDV.MAC.4,  16-Jun-80 12:09:09 by MURPHY
;CLEAN UP VECTOR COMMENTS
; UPD ID= 443, SNARK:<5.MONITOR>TTFEDV.MAC.3,  15-Apr-80 09:41:02 by KONEN
;TCO 4.1.1143 -- Check for XOFF before storing character in big buff.
; UPD ID= 405, SNARK:<5.MONITOR>TTFEDV.MAC.2,   3-Apr-80 16:06:55 by HALL
;CHANGES TO WRITE-PROTECT THE RESIDENT MONITOR:
;	CHANGE ALL REFERENCES TO TT1LIN TO EXPECT A TABLE
;<4.1.MONITOR>TTFEDV.MAC.52, 16-Nov-79 11:29:17, EDIT BY MILLER
;ASGALL NOW SKIPS
;<4.MONITOR>TTFEDV.MAC.51,  1-Nov-79 17:15:09, EDIT BY MILLER
;Previous edit lines deleted

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


 	SEARCH TTYDEF,PROLOG
	TTITLE	(NRTSRV,NRTSRV,< - DECnet Network Remote Terminal Support>)

	RESCD
	SEARCH D36PAR,SCPAR

;THIS MODULE IS NECESSARY TO SUPPORT THE NETWORK REMOTE TERMINALS (NRT)
;OVER DECnet.

;SPECIAL DEFINITIONS

DEFSTR TTHLL,TTDEV,35,36	;LOGICAL LINK FOR THIS LINE (HOST SIDE)
                                ;TTULL (USER SIDE) IS DEFINED IN TTYSRV

;NOTE - TTMLN IS NOW DEFINED IN TTYDEF


;NRTACV defines the ACVAR to be used at all entries to NRTSRV, so that
;subroutines can use the ACs with assurance that they are correctly
;assigned.

DEFINE NRTACV,<	ACVAR <W1,W2,W3,TDB,NRB,SAB> >

COMMENT @

                         Theory of NRT Operation

Except for NRTINI, NRTSRV runs only at schedular level, so it needs
little more interlocking.

MCSRV gets called every tick.  MCSRV counts down an interval timer.  The
timer is reinitialized to some small number, say 3, every time it expires.

MCSRV only runs after its interval counter expires for two reasons:
it imposes less overhead if it runs less often, and it lets more input
& output build up and thus fills the DECnet messages better than it
would if it ran more frequently.  It is important that it run often
enough that the user not see any delay, the optimum setting seems to
be around 3 to 5 ticks.

When the interval timer expires, MCSRV checks for service requests.  It
checks for both input and output ready on any line for which service is
requested.

                A word about NETHOST and NETUSER

In this program the term NETHOST will be used for the computer which runs a
job or provides other computing resources.  The term NETUSER will be used
for the computer to which a terminal is attached.

@
;NRT Data Base Definitions

;The NRB is the NRT Data Block.  One is allocated for each active
;link to hold data associating the DECnet link with a TDB.

BEGSTR NR			;USUALLY INDEXED BY REGISTER NRB
	WORD  TDB		;DYNAMIC PTR TO ASSOCIATED TDB

	FIELD FLG,6		;FLAGS
	  BIT CFG		;SET IF CONFIG MSG HAS BEEN SENT
	  BIT REL		;THIS NRB IS BEING RELEASED
	  BIT USR		;0=NETHOST LINK, 1=USER NETLINK
	  BIT TRN		;THIS NRB IS IN TRANSITION
	  BIT DEA		;DEALLOCATE TDB.
	FIELD CHN,12		;DECnet CHANNEL NUMBER
	HWORD STS		;CURRENT STATUS OF DECnet LINK

	WORD  SJB		;POINTER TO THIS LINK'S SJB

	HWORD SIZ		;MAX CHARS IN A SEGMENT ON THIS LINK
        HWORD PSI               ;SCJSYS'S ORIGINAL PSI MASK FOR NETUSER LINK

	HWORD RID		;Remotes node ID

;	HWORD INA		;INACTIVITY TIMER FOR NETHOST LINK
ENDSTR
;RESIDENT STORAGE

	NRTOBJ==^D23		;NRT OBJECT TYPE
	NRTINT==3		;TICKS BETWEEN NRT SERVICE CHECKS
	INACTIVITY==^D120	;SECS 'TIL INACTIVE LINK IS DISCONNECTED


;The length of the record and the max record we will send are separately
;defined so that the compiled-in record buffer can be larger than the actual
;record we send so that we can poke the max to a larger value for performance
;tests to systems we know can handle the size.

	NRTRML==^D500		;BYTES IN A NRT MESSAGE
	NRTMXC==^D500		;MAX LENGTH OF MESSAGE WE WILL SEND

IFG NRTMXC-NRTRML,NRTMXC==NRTRML ;ASSURE WE DON'T GET CARRIED AWAY

RSI NRTDFT,<<FLD(^D9,PDGOL) ! FLD(^D6,PDDQT) ! FLD(^D50,PDIPR)>>
RSI NRTMAX,NRTMXC		;MAX SIZED RECORD WE'LL SEND (POKABLE)
RSI NRTINA,INACTIVITY		;NUMBER OF SECONDS INACTIVITY ALLOWED
RSI NRTINL,NRTINT		;NUMBER OF TICKS BETWEEN NRT SERVICES

RS  NRTPSQ,1			;FLAG TELLING MCSRV TO CALL SCTPSQ
RS  NRTINC,1			;NRT INTERVAL COUNTER, SEE MCSRV
RS  NRTCWN,1			;NRB FOR NRT LINK IN CW STATE
RS  NRTSJP,1			;PTR TO NRT HOST'S SJB
RS  NRTSAP,1			;PTR TO NRT'S SAB
RS  NRTBLW,1			;SAVED NRB PTR FOR BLOCKED LINK
RS  NRTBLP,2			;SAVED BYTE PTR "    "      "
RS  NRTBLC,1			;SAVED BYTE COUNT "  "      "
RS  NRTRCO,<<NRTRML+3>/4>	;PLACE TO BUILD OUTPUT RECORD
RS  NRTRCI,<<NRTRML+3>/4>	;PLACE TO BUILD INPUT RECORD

;CALLED FROM STRTOU, TELL MCSRV THAT TTYSRV HAS OUTPUT TO GO
; T2/ TTY DYNAMIC DATA BLOCK ADDRESS
; RETURN +2 TO PREVENT NORMAL OUTPUT START ACTION

;TTOTP is set here for MCB (NETHOST) lines and it is cleared in TTSND
;in TTYSRV when it has been called to send the last char, thus TTOTP
;is set while this line has a REQNS request pending.  The only reason
;to set TTOTP for MC lines is to prevent the overhead of REQNS calls
;for every character output.

MCSTRO::CALL REQNS		;REQUEST MCSRV SERVICE AT SCHED LEVEL
	SETONE TTOTP,(T2)	;OUTPUT IN PROGRESS, DON'T START AGAIN
	RETSKP			;'ALL DONE' RETURN

;SET UP TTY CHARACTERISTICS, GIVE US PLENTY OF OUTPUT BUFFERS, SINCE
;NETWORK SHOULD BE A FAST LINE.
;RETURNS +2 ALWAYS WITH
;	T3/ SPEED TO THINK OF THIS LINE HAS HAVING WHEN IT COMES TO ALLOCATION
;	T4/ NUMBER OF BUFFERS TO ALLOCATE
NRTSOF::MOVEI T3,^D9600		;USE BUFFERS LIKE A FAST LINE
	MOVE T4,IBFRC1		
	RETSKP

;CLEAR OUTPUT BUFFER - SEND ROTO-ROOTER DOWN LINE
; T2/ DYNAMIC PTR

MCCOBF::RET

;SEND XON - SEND ALLOCATION TO ALLOW USER TO SEND MORE INPUT IF NECESSARY
; T2/ STATIC PTR (LINE NUMBER)

MCSXON::RET

;SKIP IF OUTPUT BUFFER NOT EMPTY - CHECK FOR ALL ACKS, ETC.
; T2/ DYNAMIC PTR

MCSBEF::RET

;SEE IF SENDALL SHOULD HAPPEN ON SPECIFIED LINE
; T2/ STATIC PTR (LINE NUMBER)
; RETURN +1: SKIP THIS LINE
; RETURN +2: T2/ LINE NUMBER = DO THIS LINE
;	T2/ -1 = SKIP ALL LINES OF THIS TYPE

MCCKSA::SKIPG TTACTL(T2)	;LINE ACTIVE?
	RET			;NO, SKIP IT
	RETSKP

;HANGUP - BREAK CONNECTION, ETC.
; T2/ STATIC PTR (LINE NUMBER)

MCHNGU::SAVEAC <T2>
	CALL STADYN
	 RET			;ALREADY GONE
	LOAD T1,TTHLL,(T2)
	JUMPE T1,RTN		;IN CASE ALREADY GONE
	SETONE NRREL,(T1)       ;MARK LINE AS READY TO BE RELEASED
	CALLRET REQNS           ;REQUEST NRT SERVICE AT SCHED LEVEL

;CHECK FOR OUTPUT POSSIBLE ON LINE
;OUTPUT NOT POSSIBLE IF LOGICAL LINK HAS BEEN CLOSED
; T2/ DYNAMIC PTR
; RETURN +1: OUTPUT NOT POSSIBLE
; 	+2: OUTPUT OK

CKMCOU::TMNN TTHLL,(T2)		;LL STILL THERE?
	RET			;NO
	RETSKP			;YES

;ENABLE/DISABLE XOFF HANDLING IN USER SIDE
; T2/ DYNAMIC PTR
; TTFLGS(T2)/ TT%PGM BIT - ON IF LINE IN PAGE MODE

MCEXF::	RET

;TURN LINE OFF ON RECEIPT OF XOFF
; T2/ DYNAMIC PTR

MCLNOF:	RET

;TURN LINE ON AGAIN AFTER XOFF

MCLNON::RET

;CLOSE NET HOST CONNECTION
; T2/ TDB

;NRTWAK - Called when SCLINK thinks we might want to wake the user
;
; Call:	T1/ Old Status,,PSI Mask (with TTY static line # in it)
;	T2/ New Status,,Channel Number
;	T3/ Pointer to Session Control Job Block
;	T4/ Link identifier to pass to SCTWKQ
;
; Return:
;	RET			;Only return
;
; Uses: T1,T2,T3,T4
;
;SCLINK calls this routine (via SAWKA) when either the link state has changed
;or one of the status bits has changed from a zero to a one.
;
;If we have a terminal line associated with this logical link, its static line
;number will be in the PSI mask field in T1.  In this case, we don't have to
;ask DECnet to remember the wake for us, since it is simpler to call REQNS to
;request a call to MCSRV at schedular level.  That way both input and output
;wakes will go to the same place.
;
;If we do not yet have a teminal line, then this wake must be telling us of a
;connect message which matched a link in connect wait state.  In this case, we
;must call SCTWKQ to get DECnet to remember the wake for us.
				;SCJSYS CALLS NRTWAK FOR NETUSER LINKS
				;NRTNSF PASSES THIS ADDR TO SCLINK
NRTWAK::			; FOR NRTSRV'S NETHOST LINES
	HRRZ T2,T1		;GET LINE NUMBER THAT WE STORED IN PSI MASK
	JUMPN T2,NRTWK1		;JUMP IF WE HAVE A LINE NUMBER

;Here if we have a wake from a link in Connect Received state, for which
;we cannot yet have a terminal line number.

	MOVE T1,T4		;PASS LINK ID TO SCTWKQ
	CALL SCTWKQ		;ASK DECNET TO REMEMBER THIS LINK FOR US
	SETOM NRTPSQ		;CALL SCTPSQ NEXT MCSRV CALL
	RET			;RETURN TO DECNET

;Here if we have a wake from a link for which we already have a terminal
;line number.

NRTWK1:	ANDI T2,77777		;REDUCE TO LINE NUMBER ONLY
	CALL STADYN		;CHANGE T2 TO DYNAMIC POINTER
	  RET			;NOPE, MUST BE DETACHING OR CLOSING
	CALLRET REQNS1		;(T2) REQUEST MCSRV SERVICE FOR LINE
				;RETURN TO DECNET


;LOCAL ROUTINE TO REQUEST SUBSEQUENT SERVICE
; T2/ DYNAMIC PTR
; PRESERVES ALL ACS

REQNS::	SAVEAC <T3,T4>          ;PRESERVES ALL ACs
REQNS1:	LOAD T3,TINTL,(T2)	;GET LINE NUMBER
	IDIVI T3,^D36           ;FIND Nth BIT
	MOVE T4,BITS(T4)        ; IN TABLE
	IORM T4,TNETRQ(T3)      ;SET REQUEST FLAG FOR MCSRV
	RET                     ;ONLY RETURN
;NRTHBR - Subroutine to do the HIBERs.

;NRTHBR - Called by SCLINK to dismiss
;
; Call:
;	T1/ Pointer to SJB
;
; Return:
;	RET			;ONLY RETURN
;
; Uses: T1

NRTHBR:	BUG.(CHK,NVTNHB,TTPHDV,SOFT,<NRTHBR should never be called>,,<

Cause:	DECnet has called NRT's host service at its "hiber" address.
	This should never happen, since NRT always uses asynchronous
	calls to DECnet.

Action:	Find a DECnet call which has the .NSWAIt flag on and turn it
	off, being sure that the surrounding code can handle asynch
	I/O.  If none is found, DECnet must be in error.
>)

;TTSETH - Called from SCJSYS to connect a DECnet link to a TTY line
;
; T1/ Flags,,Escape Character
; T2/ TTY Line Number
; T3/ SJB Pointer for DECnet Link
; T4/ PSI MASK to restore on escape,,DECnet Channel Number
; RETURN +1: Failed, Invalid TTY Line or no memory for NRB
;	 +2: OK

;This function is called by the MTOPR .MOSNH to connect a TTY line to
;a DECnet link, both of which are already running.  The MTOPR is used
;by programs which SET HOST using the LCB NRT protocol.  TTYSRV
;detects the escape character and breaks the connection.

TTSETH::NRTACV                  ;ACVAR <W1,W2,W3,TDB,NRB,SAB>
	MOVE W1,T1		;SAVE FLAGS,,ESCAPE CHAR
	MOVE W2,T3		;SAVE SJB PTR
	MOVE W3,T4		;SAVE PSI MASK,,DECNET CHANNEL NUMBER
	CALL STADYN		;(T2)CHECK LINE, GET TDB
	 RETBAD(ATSX27)		;TERMINAL IS NOT OPEN
	MOVE TDB,T2		;SAVE DYNAMIC PTR TO TERMINAL DATA BLOCK
	MOVX T1,SA.LEN		;GET AN
	XCALL (XCDSEC,DNGWDZ)	; SAB
	 RETBAD (NSPX01)	;RESOURCE ALLOCATION FAILURE
	MOVE SAB,T1		;SAVE SAB POINTER

;	W1/	Flags,,Escape Character
;	W2/	SJB Pointer for DECnet link to be spliced
;	W3/	PSI Mask,,DECnet Channel Number
;	TDB/	Dynamic TDB Pointer for TTY to be spliced
;	SAB/	Pointer to private SAB

	MOVEI T1,NR.LEN		;LENGTH (WORDS) OF A NRT BLOCK
	XCALL (XCDSEC,DNGWDZ)	;GET SPACE
	 RETBAD(NSPX01)		;RESOURCE ALLOCATION FAILURE
	MOVE NRB,T1		;POINTER TO NEW NRB
	STOR W3,NRCHN,(NRB)	;STORE DECnet CHANNEL NUMBER
        HLRZS W3		;GET SCJSYS'S PSI MASK INTO RIGHT HALF
        STOR W3,NRPSI,(NRB)	;SAVE FOR TNUESC
	SETONE <NRUSR,NRCFG>,(NRB) ;THIS IS A USER LINK (FROM SET HOST PROGGIE)
				   ; WHICH DOESN'T SEND CONFIG MESSAGES
	STOR W2,NRSJB,(NRB)	;STORE USER'S SJB POINTER FOR NRTNSF
	STOR TDB,NRTDB,(NRB)	;STORE ASSOCIATED TDB POINTER IN NRB

	LOAD T1,TINTL,(TDB)	;GET STATIC LINE NUMBER AGAIN
	TXO T1,1B18		;FIX THIS NAME!  ASSURE NON-ZERO HALF-WORD
	STOR T1,SAAA1,(SAB)	;STORE NEW "PSI MASK" = 1B18 ! LINE #
	MOVEI T1,.NSFPI		;SET PSI MASK FUNCTION
	MOVEI T2,3		;FUNCTION + CHAN + 1 ARG
	CALL NRTNSF		;CALL DECnet
	 JRST TTSET1    	;?CONNECTION ABORTED BY THIRD PARTY?

;Read link status to find out segment size

	CALL NRTRSS		;READ SEGMENT SIZE INTO NRB
	 JRST TTSET1    	;?CONNECTION ABORTED BY THIRD PARTY?

;Now that the errors are out of the way, its OK to diddle the TDB

	SETONE TTPRM,(TDB)	;KEEP THIS TDB UNTIL LL RELEASED
	STOR W1,TTUEC,(TDB)	;SAVE ESCAPE CHAR
	TXNE W1,SH%LPM		;"LOCAL" PAGE MODE?
	IFSKP.
	  SETZRO TTNPM,(TDB)  	;NO 
	ELSE.
	  SETONE TTNPM,(TDB)  	;YES
	ENDIF.
	STOR NRB,TTULL,(TDB)	;SAVE PTR TO 'USER' NRB
	SETONE TTNUS,(TDB)	;TELL TTYSRV LINE IS IN NETUSER STATE
	MOVE T1,SAB		;RELEASE SAB
	XCALL (XCDSEC,DNFWDS)
	MOVE T2,TDB		;IF CTERM,
	LOAD CX,TLTYP,(T2)	;GET LINE TYPE
	CAIN CX,TT.CTH		;CTERM LINE ?
	CALL CTHNRT		;YES - POST READ
	RETSKP			;SUCCESS RETURN

;Here on error - deallocate SAB and return
TTSET1:	MOVE T1,SAB		;RELEASE SAB
	XCALL (XCDSEC,DNFWDS)
	RETBAD (NSPX08)
	ENDAV.			;END ACVAR FOR NRTACV AT NTSNH

;MCSRV - Called every Tick
;Called from configuration-dependent code in STG
;
;Call:	No special arguments
;	RET			;ALWAYS
;
;Changes T1 through T4

MCSRV::	SOSG NRTINC		;HAS INTERVAL COUNTER EXPIRED YET?
	SKIPN NRTSJP		;YES, HAS NRTINI BEEN CALLED?
	RET			;NO
	SKIPL SCTLOK		;YES, SESSION CONTROL LOCK AVAILABLE?
	RET			;NO, TRY EVERY TICK UNTIL WE GET IN NOW
	MOVE T1,NRTINL		;YES, GET INTERVAL LENGTH
	MOVEM T1,NRTINC		;REINITIALIZE THE INTERVAL COUNTER

	NRTACV                  ;RANGE OF THIS ACVAR <W1,W2,W3,TDB,NRB,SAB>
				; IS LONG
	MOVE SAB,NRTSAP		;DECnet-DEALING ROUTINES NEED THIS
	SKIPN NRTBLW		;IS THERE A BLOCKED LINK?
	 IFSKP.
	   CALL NRTUNB		;YES, UNBLOCK IT
	     RET		;STILL BLK'D, TRY AGAIN NEXT INTERVAL
	 ENDIF.			;ALL CLEAR NOW, TRY FOR MORE OUTPUT
	SKIPN NRTCWN		;IS THERE A LINK IN CW STATE?
	CALL NRTNEP		;NO, MAKE ONE IF WE CAN

;We know that we can safely deal with at least one link, since there
;is now no other blocked link, so the worst that can happen is that
;this link will become blocked and we'll have to try it again.

;Call SCTPSQ if there is a connect wait link which just got a connect
;message

	SETZ T1,		;LOAD A ZERO TO STORE IN NRTPSQ
	EXCH T1,NRTPSQ		;ANY LINKS ON SCTL'S QUEUE?
	JUMPE T1,MCSRV2		;NO
MCSRV1:	MOVE T1,NRTSJP		;YES, LOAD PTR TO NRT'S SJB
	CALL SCTPSQ		;DEQUEUE NEXT LINK REQUESTING SERVICE
	  JRST MCSRV2		;NO MORE
	SKIPN NRB,NRTCWN	;GET PTR TO CONNECT-WAITING LINK'S NRB
	BUG.(CHK,NVTWWN,TTPHDV,SOFT,<No NRTCWN Connect Wait Wake>,,<

Cause:	NRT's host service has been waked for a circuit which has no TTY
	line number associated with it, yet there is no NRB for a
	logical link in connect wait state.

Action:	Either the NRB pointer in NRTCWN has been stepped on or an active
	logical link has lost its TTY line number which should be in the
	DECnet PSI mask.

>)
	LOAD T1,NRCHN,(NRB)	;GET ITS DECnet CHANNEL NUMBER
	HRRZS T2		;ISOLATE CHN OF LINK WE'RE EXAMINING
	CAME T1,T2		;ARE WE DEALING WITH RIGHT LINK?
	BUG.(CHK,NVTWWC,TTPHDV,SOFT,<Wrong Channel on Connect Wait Wake>,,<

Cause:	NRT's host service has been waked for a circuit which is not
	the logical link in connect wait state and which has no TTY
	line number associated with it.

Action:	Either the connect wait link is out of phase and should be corrected
	or an active link has lost its TTY line number which should be
	in the DECnet PSI mask.

>)
	SETZ TDB,		;RIGHT CHANNEL, NO TTY YET
	CALL NRTLKS		;SERVICE THE LINK
	JRST MCSRV1		;CHECK FOR MORE ANSWERS FROM SCTPSQ
	;...

	;...
;Here to check for active TTY lines

MCSRV2:	MOVSI W1,-NTSQWD	;SCAN BIT TABLE FOR NET-USER LINES
MCSRV3:	SKIPE T1,TNETRQ(W1)
MCSRV4:	JFFO T1,MCSRV5		;JUMP IF ACTIVE LINE
	AOBJN W1,MCSRV3
	RET			;ALL LINES QUIET, RETURN TO SCHEDULAR

MCSRV5:	MOVE W2,BITS(T2)	;SAVE BIT FOUND
	ANDCAM W2,TNETRQ(W1)	;CLEAR REQUEST
	HRRZ T3,W1		;COMPUTE LINE NUMBER
	IMULI T3,^D36		;36 BITS IN A WORD
	ADD T2,T3		;LINE NUMBER IN T2
	CALL STADY		;(T2)IS IT ACTIVE?
	 JRST MCSRV6		;NO, TRY NEXT
	MOVE TDB,T2		;YES, T2 HAS DYNAMIC PTR FOR LINE
	LOAD T1,TLTYP,(TDB)	;GET TYPE OF THIS LINE
	CAIE T1,TT.MCB		;IS IT A NRT HOST LINE?
	 IFSKP.
	   OPSTR <SKIPE NRB,>,TTHLL,(TDB) ;YES, GET PTR TO ITS HOST NRB
	   CALL NRTLKS			  ;GO SERVICE THE LINK
	 ENDIF.
	LOAD NRB,TTULL,(TDB)	;LOAD UP NRB FOR 'USER' LINK
	JUMPE NRB,MCSRV6	;SKIP IT IF NO LINK
	TMNE TTNUS,(TDB)	;STILL A NETUSER LINE?
	CALL NRTLKS		;YES, GO SERVICE THE LINK

MCSRV6:	MOVN T1,W2		;LOOK AT REST OF BIT WORD ONLY
	ANDCA T1,TNETRQ(W1)	;IGNORE EARLIER BITS THAT HAVE COME ON
	JRST MCSRV4		; DURING THIS SCAN

;Routine to service a link according to its DECnet state
;Call
;	NRB/ Pointer to NRB
;	TDB/ Pointer to TDB
;
;Return:
;	RET			;ONLY RETURN

NRTLKS: TMNE NRREL,(NRB)        ;IS THIS NRB BEING RELEASED?
	CALLRET NRTREL		;YES, COMPLETE THE PROCESS

;	SETZRO NRINA,(NRB)	;ZERO THE INACTIVITY TIME

	MOVX T1,.NSFRS		;READ STATUS FUNCTION CODE
	MOVEI T2,3		;FUNCTION + CHAN + 1 ARG
	CALL NRTNSF		;READ LINK STATUS, STORE IT IN NRB
	  CALLRET NRTREL	;ERROR, CLEAN UP
	LOAD T1,NRSTS,(NRB)	;GET LINK'S STATUS WORD
	LOAD T1,NSSTA,+T1	;GET THE STATE FIELD FROM STATUS
	CAILE T1,NJFTLN		;A STATE WE UNDERSTAND?
	JRST NJFTBL+0		;NO, CALL ILLEGAL STATE BUG.
	CALLRET @NJFTBL(T1)	;CALL ROUTINE APPROPRIATE TO LINK STATE


DEFINE LNKSTA(code),<
	IFN <.-NJFTBL-.NSS'code>,<PRINTX ?NJFTBL is in wrong order for "code">
	IFIW NJFR'code		;;ADDRESS OF NJF ROUTINE
>;END DEFINE LNKSTA

NJFTBL:	IFIW NJFRIL		;ILLEGAL STATE
	LNKSTA CW		;CONNECT WAIT
	LNKSTA CR		;CONNECT RECEIVED
	LNKSTA CS		;CONNECT SENT
	LNKSTA RJ		;REMOTE REJECTED CONNECT INIT
	LNKSTA RN		;LINK IS UP AND RUNNING
	LNKSTA DR		;DISCONNECT RECEIVED
	LNKSTA DS		;DISCONNECT SENT
	LNKSTA DC		;DISCONNECT CONFIRMED
	LNKSTA CF		;NO CONFIDENCE
	LNKSTA LK		;NO LINK
	LNKSTA CM		;NO COMMUNICATION
	LNKSTA NR		;NO RESOURCES
NJFTLN==.-1-NJFTBL		;LENGTH OF TABLE

	PURGE LNKSTA

;Here for the states in which we just wait for something to happen

NJFRCS:				;CONNECT SENT, WAITING FOR CONFIRM/REJECT
NJFRDS:				;DISCONNECT SENT, WAITING FOR DC
NJFRCW:	RET			;CONNECT WAIT, WAITING FOR A CONNECT


;Here if the state is illegal

NJFRIL:	BUG.(CHK,NVTILS,TTPHDV,SOFT,<NRT link in unexpected state>,,<

Cause:	NRT's host service has been called by DECnet for a link in
	an unexpected state.

Action:	Determine whether the link indeed is in an unexpected state, or
	whether it is in a state which NRT must deal.  If the former,
	the problem is probably in DECnet, if the latter, code must
	be added to NRT.

>)
	CALLRET NRTREL
;NJFRDR - Service Routine for a link in DISCONNECT RECEIVED state
;
;Call:
;	NRB/ Pointer to Link's NRB
;	RET			;ALWAYS
;
;The link is in one of the "gone sour" states.  Call NRTREL to release
;or unsplice the link.

NJFRRJ:				;REJECTED
NJFRDR:				;DISCONNECT RECEIVED
NJFRDC:				;DISCONNECT CONFIRMED
NJFRCF:				;NO CONFIDENCE
NJFRLK:				;NO LINK
NJFRCM:				;NO COMMUNICATION
NJFRNR:				;NO RESOURCES
	CALLRET NRTREL		;RELEASE THE LINK ALTOGETHER
;NJFRCR - Service Routine for a link in CONNECT RECEIVED state
;
;Call:
;	NRB/ Pointer to Link's NRB
;	RET			;ALWAYS
;
;Now we have someone interested in this link, try to get a TDB for
;it.  If that succeeds, accept the link.

NJFRCR:				;CONNECT RECEIVED STATE PROCESSOR
	SAVEAC <P1>
	SETZM NRTCWN		;NO LINKS IN CW STATE NOW
	MOVX T1,RSNACR		;REMOTE NODE ACCESS NOT PERMITTED REASON CODE
	MOVE T2,FACTSW		;SEE IF DECNET
	TXNN T2,SF%MCB		; LOGINS ALLOWED
	JRST NJRCRF		;NO, GO ANNOUNCE THE FAILURE

;Get a TTY for this link

	CALL NGTTDB		;GET A NRT TDB
	 IFNSK.
	   MOVX T1,RSNRES	;NO RESOURCES REASON CODE IN T1
	   JRST NJRCRF		;FAILED, REJECT CONNECTION
	 ENDIF.
				;SUCCEEDED, LINE NUMBER IN T1, TDB IN TDB
	TXO T1,1B18		;TELL SCJSYS & SCNSPJ THAT THIS IS MINE
	STOR T1,SAAA1,(SAB)	;STORE AS "PSI MASK" FOR PRESENTATION AT
	MOVEI T1,.NSFPI		; NRTWAK WHEN SOMETHING INTERESTING HAPPENS
	MOVEI T2,3		;FUNCTION + CHAN + 1 ARG
	CALL NRTNSF		;SET THE PSI MASK
	  CALLRET NRTREL	;ERROR, CLEAN UP

;Get the connect info, which includes the remote host id (node address)

	SETZ P1,		;Clear node ID in case we cant get it
	MOVEI T1,.NSFRI		;Function is 'read connect info'
	MOVEI T2,2		;Function + channel
	CALL NRTNSF		;Get the info
	IFSKP.			;Success,
	  OPSTR <SKIPN T1,>,SACBP,(SAB) ; -get connect block pointer
	  ANSKP.		; -yes, there is a connect block
	    LOAD P1,CBNUM,(T1)	;  so get the node number
	    XCALL (XCDSEC,DNFWDS) ;  and deallocate the connect block
	ENDIF.
	STOR P1,NRRID,(NRB)	;Save node address for NTINF% jsys

;Accept the Connect

	SETZRO SAAA1,(SAB)	;NO USER DATA
	MOVEI T1,NRTRML		;GET MAX BYTES IN OUR RECORD
	STOR T1,SAAA2,(SAB)	;USE A MSG SEGMENT NO BIGGER THAN THAT
	MOVX T1,NSF.C0		;ELECT NO FLOW CONTROL FOR INPUT
	STOR T1,SAAA3,(SAB)	;ARG #3
	MOVX T1,.NSFAC		;ACCEPT FUNCTION CODE
	MOVEI T2,5		;FUNCTION + CHAN + 3 ARGS
	CALL NRTNSF		;ACCEPT THE CONNECT
	  CALLRET NRTREL	;ERROR, CLEAN UP

;Read link status to find out segment size

	CALL NRTRSS		;READ SEGMENT SIZE INTO NRSIZ
	  CALLRET NRTREL	;ERROR, CLEAN UP

	CALLRET NRTNEP		;HANG OUT A NEW CONNECT WAIT LINK

;We'll send a configuration message when we get a data request.
;Here on failure in Connect Received state processing

NJRCRF:	SETZRO SAAA1,(SAB)	;NO OPTIONAL DATA
	STOR T1,SAAA2,(SAB)	;STORE REASON CODE IN ARGUMENT BLOCK
	MOVX T1,.NSFRJ		;REJECT FUNCTION CODE
	MOVEI T2,4		;FUNCTION + CHAN + 2 ARGS
	CALL NRTNSF		;REJECT THE CONNECT
	  CALLRET NRTREL	;RELEASE THE LINK
	RET			;WE'LL RELEASE LINK WHEN DC COMES IN


;The configuration message sent out when we accept a connect

CFGLEN==10			;BYTES IN CONFIG MESSAGE
CFGMSG:	BYTE(8) 1,1,0,0,10,0,10,0
;	Config--' ^ ^ ^  ^ ^  ^ ^
;		  ? ? ?  | ?  | ?
;	System=TOPS20----'    |
;	Protocol=TOPS20-------'
;Subroutine to Read link status to find out segment size
;Call:
;	SAB/ Pointer to an SAB
;	NRB/ Pointer to an NRB
;Return:
;	+1 on DECnet error
;	+2 on success, with NRSIZ filled in

NRTRSS:	MOVX T1,.NSFRS		;READ STATUS FUNCTION CODE
	MOVEI T2,3		;FUNCTION + CHAN + 1 ARG
	CALL NRTNSF		;READ LINK STATUS
	  RET			;PROPOGATE ERROR RETURN
	LOAD T1,SAAA1,(SAB)	;GET LINK'S SEGMENT SIZE
	CAMLE T1,NRTMAX		;IS THAT TOO BIG FOR US?
	MOVE  T1,NRTMAX		;YES, LOAD UP OUR MAX
	CAILE T1,NRTRML		;HAS SOMEONE POKED THAT TOO BIG?
	MOVEI T1,NRTRML		;YES, LIMIT TO SIZE OF RECORD
	STOR T1,NRSIZ,(NRB)	;STORE FOR NRTOUT
	RETSKP			;SUCCESS RETURN
;NJFRRN - Service Routine for a link in RUN state
;
;Call:
;	NRB/ Pointer to Link's NRB
;	RET			;ALWAYS
;
;The link is running, see if any traffic needs to be transferred.

NJFRRN:				;LINK IS UP AND RUNNING
	LOAD TDB,NRTDB,(NRB)	;GET PTR TO TDB

;First, try some input, may free up some DECnet buffers for output

	LOAD T1,NRSTS,(NRB)	;GET DECnet STATUS LAST TIME WE HEARD
NJFRR1:	TXNN T1,NSNDA		;NORMAL DATA AVAILABLE?
	JRST NJFRR2		;NO, TRY OUTPUT
	CALL NRTIN		;YES, TRY TO READ SOME
	  JFCL			;IGNORE ERROR HERE

;See if there is any output requested and allowed now.  If we are not
;allowed to send to DECnet now, we exit without calling REQNS.  When
;DECnet again has resources and data requests for this link, it will
;call NRTWAK, which will call REQNS, so we don't need to poll every
;NRT cycle.

NJFRR2:	LOAD T1,NRSTS,(NRB)	;GET DECnet STATUS LAST TIME WE HEARD
	TXNN T1,NSNDR		;NORMAL DATA REQUESTED?
	RET			;NO, ALL DONE WITH THIS LINK

	TMNE NRCFG,(NRB)        ;NEED TO SEND A CONFIG MESSAGE?
	IFSKP.
	   CALL SNDCFG          ;YES, DO SO NOW AND SET NRCFG FLAG
	     RET                ;ERROR, DON'T LOOP FOREVER
	   JRST NJFRR2          ;SEE IF WE CAN STILL SEND MORE
	ENDIF.
	CALL NRTOUT		;NO, TRY TO SEND SOME DATA
	  TRNA			;BLOCKED, CAN'T DO ANY OUTPUT
	RET			;SUCCESS, RETURN

;Here if we are blocked and can't output the chars we have ready to go.

	MOVE T2,TDB		;SET UP FOR REQNS1
	CALLRET REQNS1		;REQUEST NRT SERVICE AGAIN NEXT CYCLE
;SNDCFG - Send a configuration message
;
;Call:
;	NRB/ Pointer to Link's NRB
;	TDB/ Pointer to TDB
;
;Return:
;	RET			;ERROR
;	RETSKP			;SUCCESS
;
;Send a configuration message

SNDCFG:	MOVEI T1,CFGLEN		;LENGTH OF MESSAGE TO SEND
	STOR T1,SAAA1,(SAB)	;STORE AS FIRST ARG
	MOVE T1,[POINT 8,CFGMSG] ;BYTE POINTER TO CONFIG MSG
	STOR T1,SAAA2,(SAB)	;STORE BYTE POINTER
	SETONE SAEOM,(SAB)	;SEND THIS MESSAGE NOW

	MOVX T1,.NSFDS		;DATA SEND FUNCTION
	MOVEI T2,5		;FUNCTION + CHAN + 3 ARGS
	CALL NRTNSF		;SEND CONFIG MESSAGE
	  RET			;ERROR, MAYBE TRY AGAIN LATER
	TMNN SAAA1,(SAB)	;IS REMAINING SEND COUNT ZERO?
	IFSKP.			;NO, COMPLAIN AND RETURN ERROR
	   BUG.(CHK,NVTPCL,TTPHDV,SOFT,<Partial Configuration Msg Loss>,,<

Cause:	NRT's host service failed to send the configuration message in
	a single DECnet message segment.

Action:	If the message segment size for the link is really less than
	ten bytes, it should probably be enlarged, else the code will
	have to deal with the possibility of segmented configuration
	messages.
>)
	   RET			;ERROR RETURN
	ENDIF.
	SETONE NRCFG,(NRB)	;YES, CONFIGURATION MSG HAS BEEN SENT
	RETSKP			;SUCCESS RETURN
;NRTOUT - Try to do some output from TTYSRV to DECnet
;
;Call, when DECnet is ready to receive from us:
;	NRB/ Pointer to Link's NRB
;	TDB/ Pointer to TDB
;	SAB/ Pointer to NRT's SAB
;Return:
;	RET			;BLOCKED, TRY AGAIN LATER
;	RETSKP			;SUCCESS

NRTOUT:	SAVEAC <W1,W2,W3>
NRTOT1:	LOAD W1,NRSIZ,(NRB)	;GET MAX BYTES IN A SEGMENT ON LINK
	JUMPE W1,RTN		;DON'T GET CONFUSED BY ZERO-LENGTH RECORD
	MOVE W2,[POINT 8,NRTRCO] ;BYTE POINTER TO RECORD WE'LL SEND
	XMOVEI W3,TTSND		;ASSUME WE'RE SENDING FROM OUTPUT STREAM
	TMNE NRUSR,(NRB)	;IS THIS A NETUSER LINK?
	XMOVEI W3,GTTCI		;YES, WE'RE SENDING FROM INPUT STREAM
NRTOT2:	MOVE T2,TDB             ;PASS DYNAMIC PTR TO TTSND
	CALL 0(W3)		;GET A CHAR FROM BIGBUF
	  JRST NRTOT3		;NO MORE, SEND WHAT WE'VE COLLECTED
	IDPB T1,W2		;STORE BYTE IN NRTRCO
	SOJG W1,NRTOT2		;GET MORE WHILE THERE'S ROOM

	LOAD W2,NRSIZ,(NRB)	;GET MAX AGAIN
	CALL NRTOTS		;SEND THAT MUCH
	  RET			;BLOCKED, TRY AGAIN LATER
	LOAD T1,NRSTS,(NRB)	;GET DECnet STATUS AFTER LAST SEND
	TXNN T1,NSNDR		;NORMAL DATA STILL REQUESTED?
	RETSKP			;NO, OUTPUT OK CALL TO NRTWAK WILL RESTART
	JRST NRTOT1		;YES, TRY FOR MORE

NRTOT3:	LOAD W2,NRSIZ,(NRB)	;GET MAX AGAIN
	SUB W2,W1		;CALC NUMBER WE COPIED
	JUMPLE W2,NRTOTX	;SUCCESS RETURN NOW IF NONE
				;FALL THROUGH TO NRTOTS TO SEND

;Subroutine to send data for NRTOUT

NRTOTS:	STOR W2,SAAA1,(SAB)	;STORE LENGTH OF DATA TO SEND
	MOVX T1,<<POINT 8,>!1B12> ;MAKE A 2-WORD BYTE POINTER
	STOR T1,SAAA2,(SAB)	;STORE AS FIRST WORD OF BYTE POINTER
	XMOVEI T1,NRTRCO	;GET EXTENDED ADDR OF RECORD
	STOR T1,SAAA3,(SAB)	;STORE AS 2ND WORD OF BYTE POINTER
	SETONE SAEOM,(SAB)	;SET THE END-OF-MESSAGE FLAG

	MOVX T1,.NSFDS		;DATA SEND FUNCTION
	MOVEI T2,5		;FUNCTION + CHAN + 3 ARGS
	CALL NRTNSF		;SEND THE DATA TO DECnet
	  JRST NRTOTE		;ERROR, GO DEAL WITH IT
	LOAD T1,SAAA1,(SAB)	;GET COUNT OF BYTES LEFT TO SEND
	JUMPE T1,NRTOTX		;SUCCESS RETURN NOW IF ALL SENT

;Here when the link is blocked (DECnet is out of buffers)

	MOVEM NRB,NRTBLW        ;SAVE PTR TO BLOCKED LINK
	MOVEM T1,NRTBLC		;SAVE COUNT OF BYTES STILL TO SEND
	LOAD T1,SAAA2,(SAB)	;GET BYTE POINTER
	LOAD T2,SAAA3,(SAB)	;GET SECOND WORD OF BYTE POINTER
	DMOVEM T1,NRTBLP	;SAVE BYTE PNTR FROM WHICH TO SEND
	RET			;FAIL RETURN: WE'RE BLOCKED

NRTOTE:	LOAD T1,SAAST,(SAB)	;GET NEW STATUS
	LOAD T1,NSSTA,+T1	;GET THE STATE FIELD FROM STATUS
	CAIE T1,.NSSRN		;IN RUN STATE?
	IFSKP.			;IF NOT, DON'T COMPLAIN
	   BUG.(CHK,NVTOUT,TTPHDV,SOFT,<NRT output to DECnet failed>,,<

Cause:	An output call to DECnet's SCTNSF entry point failed unexpectedly.

Action:	Examine the DECnet error code in register T1.

>)
	   CALLRET NRTREL
	ENDIF.
NRTOTX:	RETSKP			;DON'T COMPLAIN NOW, ITS CLOSING
;NRTUNB - Unblock a link which is blocked trying to output
;
;Call:	NRTBLW/ Pointer to NRB of blocked link
;	NRTBLC/ Count of bytes still to send
;	NRTBLP/ Two-word byte pointer from which to send
;
;Return:
;	RET		;If link still blocked, NRTBLx updated
;	RETSKP		;If link is now free, NRTBLW zeroed
;
;Uses T1-T4, SAB and the SAB

NRTUNB:	SAVEAC NRB
	SKIPN NRB,NRTBLW	;GET POINTER TO BLOCKED NRB
	RETSKP			;NONE?  LEAVE SUCCESSFULLY
	MOVE T1,NRTBLC		;GET COUNT OF BYTES TO SEND
	STOR T1,SAAA1,(SAB)	;STORE IN SAB
	DMOVE T1,NRTBLP		;GET DOUBLE-WORD BYTE PTR
	STOR T1,SAAA2,(SAB)	;PASS IN SAB
	STOR T2,SAAA3,(SAB)	;PASS SECOND WORD OF BYTE PTR
	SETONE SAEOM,(SAB)	;SET THE END-OF-MESSAGE FLAG

	MOVX T1,.NSFDS		;DATA SEND FUNCTION
	MOVEI T2,5		;FUNCTION + CHAN + 3 ARGS
	CALL NRTNSF		;SEND THE DATA TO DECnet
	  JRST NRTOTE		;ERROR, GO DEAL WITH IT
	LOAD T1,SAAA1,(SAB)	;GET COUNT OF BYTES LEFT TO SEND
	JUMPE T1,NRTUN1		;SUCCESS RETURN NOW IF ALL SENT

;Here when the link is still blocked (DECnet is out of buffers)

	MOVEM T1,NRTBLC		;SAVE NEW COUNT OF BYTES STILL TO SEND
	LOAD T1,SAAA2,(SAB)	;GET NEW BYTE POINTER
	LOAD T2,SAAA3,(SAB)	;GET NEW BYTE POINTER (2ND WORD)
	DMOVEM T1,NRTBLP	;SAVE BYTE PNTR FROM WHICH TO SEND
	RET			;FAIL RETURN

;Here when the link is unblocked

NRTUN1:	SETZM NRTBLW		;NO LINK IS NOW BLOCKED
	RETSKP			;SUCCESS RETURN
;NRTIN - Try to do some input from DECnet to TTYSRV
;
;Call, when DECnet has something for us to read:
;	NRB/ Pointer to Link's NRB
;	TDB/ Points to TDB
;	SAB/ Points to NRT's SAB
;Return:
;	RET			;IF FATAL ERROR
;	RETSKP			;SUCCESS

NRTIN:	SAVEAC <W1,W2,W3>
NRTIN1:	MOVEI W2,NRTRML		;GET MAX CHARS WE'LL ALLOW AT ONCE
	TMNN NRUSR,(NRB)	;IS THIS A NETUSER LINK?
	 IFSKP.
	   LOAD T2,TOMAX,(TDB)	;YES, GET OUTBUF SIZE
	   MOVEI T1,-2(T2)	;LEAVE 2 CHRS SLACK IN OUTBUF CAPACITY
	   SUB T1,TTOCT(TDB)	;COMPUTE REMAINING OUTBUF CAPACITY
	   ASH T2,-1		;AT LEAST HALF THE MAX CAPACITY
	   CAMGE T1,T2		; AVAILABLE NOW?
	   JRST NRTIN4		;NO, DON'T BOTHER DECNET FOR SMALL STUFF
	   CAMLE W2,T1		;YES, WILL NRTRML CHARS FIT IN OUTBUF?
	   MOVE W2,T1		;NO, USE SMALLER OF TWO
	ENDIF.
	STOR W2,SAAA1,(SAB)	;STORE LENGTH OF DATA TO REQUEST FROM NET
				;SAVE W2 FOR LENGTH CALC LATER
;At one time, it was thought that we should limit the host input stream
;to the difference between the max chars allowed for this line and the
;current chars in BIGBUF for this line.  That did work nicely for
;computer-computer communication, but it made the behavior seen by
;people at terminals odd:  the typist who typed too much just saw the
;line hang, even ^C would stick in the DECnet link.  So now we just pour
;it all into TTYSRV and let it 'ding' and throw excess chars away.

	MOVX T1,<<POINT 8,>!1B12> ;MAKE A 2-WORD BYTE POINTER
	STOR T1,SAAA2,(SAB)	;STORE AS FIRST WORD OF BYTE POINTER
	XMOVEI T1,NRTRCI	;GET EXTENDED ADDR OF INPUT RECORD
	STOR T1,SAAA3,(SAB)	;STORE AS 2ND WORD OF BYTE POINTER
	SETZRO SAEOM,(SAB)	;DON'T INSIST ON A WHOLE MESSAGE
				; (NRT USES STREAM MODE)
	MOVX T1,.NSFDR		;DATA RECEIVE FUNCTION
	MOVEI T2,5		;FUNCTION + CHAN + 3 ARGS
	CALL NRTNSF		;GET DATA FROM DECnet
	  JRST NRTINE		;ERROR, GO DEAL WITH IT

;Now we have some data, give it to TTYSRV

	MOVE W1,[POINT 8,NRTRCI] ;GET BYTE POINTER TO NRT'S RECORD
	OPSTR <SUB W2,>,SAAA1,(SAB) ;CALC # OF CHARS WE GOT
	JUMPE W2,NRTIN3		;NONE, SEE IF IT WAS A NULL RECORD IN STREAM
	XMOVEI W3,TTCHID	;ASSUME WANT TO PUT CHAR IN INPUT STREAM
	TMNE NRUSR,(NRB)	;IS IT A NETUSER LINK?
	XMOVEI W3,TCOU1		;YES, WANT TO PUT CHAR IN OUTPUT STREAM
NRTIN2:	ILDB T1,W1		;GET NEXT CHARACTER FROM NRTRCI
	MOVE T2,TDB		;GET LINE NUMBER WE'RE FEEDING
	CALL 0(W3)		;(T1,T2)PUT CHAR IN APPROPRIATE TTY STREAM
	 NOP			;IN CASE OF SKIP
	SOJG W2,NRTIN2		;LOOP UNTIL ALL PASSED TO TTYSRV

NRTIN3:	LOAD TDB,NRTDB,(NRB)	;RESTORE TDB POINTER TO TDB
	LOAD T1,NRSTS,(NRB)	;GET DECnet STATUS AFTER LAST SEND
	TXNE T1,NSNDA		;NORMAL DATA STILL AVAILABLE?
	JRST NRTIN1		;YES, GO GET IT
	RETSKP			;NO, SUCCESS RETURN NOW

;Here when we have more data from the net, but TTYSRV can't accept it yet.

NRTIN4:	MOVE T2,TDB		;SET UP FOR CALL TO REQNS
	CALL REQNS		;(T2)CALL FOR SERVICE NEXT TICK
	RETSKP			;CALL IT SUCCESS FOR NOW, NO ERRORS

;Here on DECnet error

NRTINE:	LOAD T1,SAAST,(SAB)	;GET NEW STATUS
	LOAD T1,NSSTA,+T1	;GET THE STATE FIELD FROM STATUS
	CAIE T1,.NSSRN		;IN RUN STATE?
	RET			;NO, DON'T COMPLAIN NOW, ITS CLOSING
	BUG.(CHK,NVTINP,TTPHDV,SOFT,<NRT Input to DECnet failed>,,<

Cause:	An input call to DECnet's SCTNSF entry point failed unexpectedly.

Action:	Examine the DECnet error code in register T1.

>)
	CALLRET NRTREL
;NRTNEP - Do an Enter Passive to hang out a new DECnet link
;
;Call:
;	SAB/	Pointer to NRT's SAB
;	NRTSJP/	Pointer to NRT host's SJB
;
;Return:
;	RET			;ALWAYS

NRTNEP:	SKIPE NRTCWN		;CONNECT WAIT LINK WAITING?
	RET			;YES, DON'T HANG OUT ANY MORE

	SAVEAC <NRB,W1>
	MOVEI T1,NR.LEN		;LENGTH OF A NRB BLOCK
	XCALL (XCDSEC,DNGWDZ)	;GET A NEW NRB
	  RET			;COULDN'T
	MOVE NRB,T1		;POINTER TO NRB
	SETZRO NRUSR,(NRB)	;THIS IS A NETHOST LINK
	MOVE T1,NRTSJP		;NETHOST ALWAYS USES THIS SJB
	STOR T1,NRSJB,(NRB)	;NETUSER USES USER'S SJB

;Get and set up a connect block

	MOVEI T1,CB.LEN		;GET PLACE TO PUT CONNECT BLK
	XCALL (XCDSEC,DNGWDZ)
	  JRST [MOVE T1,NRB	;CAN'T, DEALLOCATE NRB AS WELL
		XCALLRET (XCDSEC,DNFWDS)] ; FREE NRB
	MOVE W1,T1		;W1 POINTS TO CONNECT BLOCK
	MOVEI T1,PB.LEN		;LENGTH OF PDB
	STOR T1,PBSIZ,+CB.SRC(W1) ;STORE SIZE OF SOURCE PDB
	STOR T1,PBSIZ,+CB.DST(W1) ;STORE SIZE OF DEST PDB
	MOVEI T1,0		  ;GET FORMAT TYPE 0
	STOR T1,PBFOR,+CB.SRC(W1) ;STORE FORMAT OF SOURCE PDB
	STOR T1,PBFOR,+CB.DST(W1) ;STORE FORMAT OF DEST PDB
	MOVX T1,NRTOBJ		  ;GET NRTSRV'S OBJECT TYPE
	STOR T1,PBOBJ,+CB.SRC(W1) ;STORE OBJECT TYPE OF SOURCE PDB
	STOR T1,PBOBJ,+CB.DST(W1) ;STORE OBJECT TYPE OF DEST PDB

;Now set up the SAB for an Enter Passive

	STOR W1,SAAA1,(SAB)	;CONNECT BLK IS FIRST ARG
	STOR W1,SACBP,(SAB)	;STORE POINTER TO CONNECT BLOCK HERE TOO

	MOVX T1,.NSFEP		;ENTER PASSIVE FUNCTION CODE
	MOVEI T2,3		;FUNCTION + CHAN + 1 ARG
	CALL NRTNSF		;ENTER PASSIVE
	  JRST NRTNEE		;CAN'T, RETURN MEMORY & LEAVE

;Now collect returned info not already stored by NRTNSF

	LOAD T1,SAACH,(SAB)	;GET NEW CHANNEL NUMBER
	STOR T1,NRCHN,(NRB)	;STORE CHANNEL NUMBER IN NRB
	MOVEM NRB,NRTCWN	;WE NOW HAVE A LINK IN CONNECT WAIT STATE
NRTNEX:	MOVE T1,W1		;GET POINTER TO CONNECT BLOCK
	XCALLRET (XCDSEC,DNFWDS) ;FREE IT

;Here on error when we have to deallocate an NRB

NRTNEE:	MOVE T1,NRB		;DEALLOCATE NRB AS WELL
	XCALL (XCDSEC,DNFWDS)	;FREE NRB
	JRST NRTNEX		;FREE CONNECT BLOCK AS WELL

;NRTNSF - Call SCLINK's SCTNSF and handle the return
;
; Call:
;	T1/ Function code
;	T2/ Number of Args
;	NRB/ Pointer to NRB
;	SAB/ Pointer to SAB, usually same as NRTSAP, not always
;
; Return:
;	RET			;FAILED, CODE IN T1
;	RETSKP			;SUCCESS

NRTNSF:	STOR T1,SAAFN,(SAB)	;FUNCTION CODE
	STOR T2,SANAG,(SAB)	;STORE NUMBER OF ARGS
	SETZRO SAMFG,(SAB)	;FIELD THAT NEEDS TO BE ZEROED FOR SCLINK
	SETONE SAEVA,(SAB)	;BUFFERS WE PASS WILL BE IN
				; EXEC VIRTUAL ADDRESS SPACE
	LOAD T1,NRSJB,(NRB)	;GET SJB POINTER FOR THIS LINK
	STOR T1,SASJB,(SAB)	;NETHOST USES NRTSJP, NETUSER USES USER'S SJB
	LOAD T1,NRCHN,(NRB)	;GET CHANNEL NUMBER
	STOR T1,SAACH,(SAB)	;STORE IN SAB
	MOVE T1,SAB		;PASS SAB TO SCLINK
	CALL SCTNSF		;DO THE DECnet FUNCTION

	LOAD T1,SAERR,(SAB)	;GET THE ERROR CODE
	JUMPN T1,RTN		;ERROR RETURN IF NON-ZERO
	LOAD T1,SAAST,(SAB)	;GET NEW LINK STATUS
	STOR T1,NRSTS,(NRB)	;STORE IN NRB
	RETSKP			;SUCCESS RETURN
;Subroutines -- NGTTDB - Get a TDB for NRTSRV

;NGTTDB - Get a remote TDB and make it mine
;
; Call:	NRB/ Pointer to NRB
;
; Return:
;	RET			;FAILED
;	RETSKP			;SUCCESS, TDB/ POINTER TO TDB
;				;     AND T1/  LINE NUMBER
; Uses: P4

NGTTDB:	SAVEAC <W1,W2>
	MOVE W1,TT1LIN+TT.MCB	;GET FIRST MCB LINE
	NOSKD1			;FIND LINE RACE FREE
NGTTD1:	LOAD T1,TTSTY,(W1)	;GET LINE TYPE
	CAIN T1,TT.MCB		;STILL MCB?
	IFSKP.
	   OKSKED               ;NO, NO LINES LEFT
	   RET                  ;ERROR RETURN
	ENDIF.
	MOVE T2,W1              ;YES, STILL MCB, CHECK THIS LINE #
	CALL STADYN		;IS LINE AVAILABLE?
	 JUMPE T2,NGTTD2	;YES, NO DATA BLOCK NOW ASSIGNED
NGTTD3:	AOJA W1,NGTTD1		;NO, STEP TO NEXT LINE

NGTTD2:	MOVE T2,W1              ;RETRIEVE STATIC LINE # OF AVAIL LINE
	CALL TTYASG		;ASSIGN TDB (SCHED-LEVEL ENTRY POINT FOR NRT)
	 JRST NGTTD3		;COULDN'T, TRY ANOTHER LINE
	CALL STADYN		;SHOULD WORK NOW
	 JRST NGTTD3		;??
	MOVE TDB,T2             ;RETURN DYNAMIC POINTER IN TDB
	STOR TDB,NRTDB,(NRB)	;STORE NEW TDB DYNAMIC PTR IN NRB
	SETONE TCJOB,(TDB)	;INIT LINE
	SETONE TTPRM,(TDB)	;TDB PERMANENT UNTIL LINK RELEASED
	STOR NRB,TTHLL,(TDB)	;STORE POINTER TO THIS LINK'S NRB

	MOVEI T1,.CHCNC         ;LOAD UP A CONTROL-C
	CALL TTCHID		;SEND IT TO START JOB
	 JFCL                   ;IGNORE ERROR RETURN

	OKSKED
	MOVE T1,W1		;RETURN LINE NUMBER IN T1
	RETSKP                  ;DYNAMIC PTR IN REGISTER TDB

;NRTREL - Release a link and all that goes with it.
;
; Call:	NRB/ Pointer to the NRB to release
;
; Return:
;	RET			;ALWAYS, NRB IS DEALLOCATED
;
; Uses:

NRTREL:	TMNN NRUSR,(NRB)	;IS IT A NETUSER LINK?
	JRST NRTRL1		;NO, ITS A NETHOST LINK

;If its a NETUSER link, just dissociate TTY and link
;If NRDEA is set, deallocate the TDB.

;Setting the PSI MASK back to what SCJSYS requested is the way we tell
;SCJSYS that NRT is no longer interested in this link.  From now on, any
;data which comes in on this link will go through SCJSYS to the user
;program as for any normal DECnet link.

	JN NRDEA,(NRB),NRTRE1   ;Jump if deallocating TDB
       	LOAD T1,NRPSI,(NRB)	;GET SCJSYS'S PSI MASK FOR THIS LINK
        STOR T1,SAAA1,(SAB)	;STORE FOR SCTNSF
        MOVX T1,.NSFPI		;SET PSI MASK FUNCTION
	MOVEI T2,3		;FUNCTION + CHAN + 1 ARG
	CALL NRTNSF		;SET PSI MASK TO WHAT SCJSYS ASKED FOR
	  JFCL			;  Ignore error return - this may legally
				;  in some cases when someone else logs out the
				;  job.
NRTRE1:	MOVE T2,TDB
	CALL CTYMCB		;(T2) THIS THE CTY OR AN MCB LINE?
	IFSKP.
	   SETZRO TTPRM,(TDB)	;NO, BLOCK IS NO LONGER PERMANENT
	ENDIF.
	JUMPE TDB,NRTRLN	;RELEASE NRB NOW IF NO TDB YET
	LOAD T1,TTUEC,(TDB)	;GET ESCAPE CHARACTER
	SETZRO TTULL,(TDB)	;LOSE PTR TO NRB
	SETZRO TTUEC,(TDB)	;LOSE ESC CHAR SO WON'T SEND TO USER AGAIN
	SETZRO TTNUS,(TDB)	;TELL TTYSRV LINE NOT IN NETUSER STATE
	SETZRO TTOTP,(TDB)	;TELL TTYSRV LINE HAS NO OUTPUT COMING.
	MOVE T2,TDB		;POINT T2 TO TDB FOR TTCHID CALL
 	LOAD T3,TCJOB,(TDB)	;IF HAVE JOB
	CAIE T3,-1		; ON THIS LINE
	SKIPN T1		;  AND THERE IS AN ESCAPE CHAR
	TRNA			;NO.
	CALL TTCHID		;(T1,T2) GIVE IT AS INPUT TO WAKE NRT JOB
	  NOP
	TMNN NRDEA,(NRB)        ;Deallocating TDB ?
	IFSKP.
	  MOVE T2,TDB		;Yes,
	  CALL TTYDED		; do so.
	ENDIF.
	CALL NRTRLN		;RELEASE NRB.
;	LOAD T1,SAAST,(SAB)	;SEE IF WE NEED TO GIVE A WAKE.
;	TXNN T1,<NSIDA+NSNDA>	;ANY DATA AVAILABLE ?
;	IFSKP.
;	  SAVEAC <T5>		;YES
;	  MOVE T5,T1 		;STATUS
;	  ANDX T5,<NSIDA+NSNDA>	; CHANGES
;	  LOAD T2,SAACH,(SAB)	;PORT #
;	  HRL T2,T1		;NEW STATUS
;	  MOVX T3,<NSIDA+NSNDA>	;MAKE UP OLD STATUS - NEW STATUS EXCEPT
;	  TXZ T1,<NSIDA+NSNDA>	; FOR DATA AVAILABLES
;	  HRLZS T1		;  IN LEFT HALF
;	  HRRZ T1,$SAAA1,(SAB)	;PSI MASK IN RIGHT HALF
;	  LOAD T3,SASJB,(SAB)	;SJB
;	  LOAD T4,SASLB,(SAB)	;LINK IDENTIFIER.
;	  CALL SCWAKE		;(T1-T5) GIVE WAKE.
;	ENDIF.
	RET			;DONE

;If its a NETHOST link, detach the TTY

NRTRL1:	OPSTR <SKIPN TDB,>,NRTDB,(NRB) ;ANY TDB HERE?
	JRST NRTRLL		;NO, JUST RELEASE THE LOGICAL LINK
	SETZRO TTHLL,(TDB)	;REMOVE 'HOST' NRB POINTER, TELLING MCSRV
				; THIS IS NO LONGER A NRT LINE
	TMNE TTNUS,(TDB)	;IS THIS TDB ALSO NRTed OUT?
	CALL [SAVEAC NRB	;YES, SAVE HOST NRB WHILE WE DEAL WITH SERVER
	      LOAD NRB,TTULL,(TDB) ;GET POINTER TO USER NRB
	      JUMPE NRB,RTN	;LEAVE IF NOT REALLY A TWO-LINKED TDB
	      CALLRET NRTREL]	;RELEASE USER LINK, THEN RETURN
				; TO RELEASE HOST LINK
	NOSKD1			;NO SCHED FOR TTCOB5'S OKSKD1
	CHNOFF DLSCHN		;TURN OF DTE INTERRUPT CHANNEL
	MOVE T2,TDB             ;SET UP TDB PTR FOR TTCOB5
	CALL TTCOB5		;FLUSH OUTPUT (DOES CHNON AND OKSKD1)
	SETZRO TTOTP,(TDB)	;CLEAR OUTPUT ACTIVE
	LOAD T2,TINTL,(TDB)     ;GET LINE NUMBER
	CALL NTYCOF		;DO CARRIER OFF EVENT
	LOAD T3,TCJOB,(TDB) 	;GET CONTROLLING JOB
	SETZRO TTPRM,(TDB)      ;TDB NO LONGER PERMANENT
	CAIE T3,-1		;IS THERE A CONTROLLING JOB?
	JRST NRTRLL		;YES, DONE
	MOVE T2,TDB		;NO, GET DYNAMIC PTR
	CALL TTCBF9		;CLEAR OUTBUF
	LOAD T2,TINTL,(TDB)     ;GET LINE NUMBER
	CALL TTYDE0		; AND DEALLOCATE DATA BLOCK
	 NOP

;Here to free the NRB and its associated DECnet link, we will hear no more
;from it after the ReLease call.

NRTRLL:	MOVX T1,.NSFRL		;RELEASE FUNCTION CODE
	MOVEI T2,2		;FUNCTION + CHAN + NO ARGS
	CALL NRTNSF		;RELEASE THE LINK
	  JFCL			;IGNORE ERROR RETURN

NRTRLN:	MOVE T1,NRB		;ADDRESS OF NRB
	SETZ NRB,               ;DON'T LET CALLERS USE NRB
	XCALLRET (XCDSEC,DNFWDS) ;FREE THE NRB

	ENDAV.                  ;END OF NRTACV IN MCSRV, WAY BACK

;TNUKIL is called by TTYSRV when a NETUSER line is detached.
;It sets flags (NRTRN) which causes MCSRV to clean up
;The flag also causes TTYSRV to throw away all input which occur in the
;interim.

;T2/ TDB
;Returns +1 on failure with error in T1
;Returns +2 on success

TNUKIL::SAVEAC <T1>
        LOAD T1,TTULL,(T2)	;GET POINTER TO 'USER' NRB
        JUMPE T1,RSKP          	;LEAVE NOW IF NO ASSOCIATED LINK
	SETONE NRTRN,(T1) 	;SAY IN TRANSITION.
	SETONE NRREL,(T1)	;QUEUE UP REQUEST FOR RELEASE.
	SETONE NRDEA,(T1)	;SAY DEALLOCATE.
	CALL REQNS		;(T2)
	RETSKP


;HANDLE LINE IN NET USER STATE

TTMCNU::LOAD CX,TLTYP,(T2)	;GET LINE TYPE
	CAIN CX,TT.CTH		;CTERM LINE ?
	CALL CTHNRT		;YES - POST READ
	LOAD T4,TTULL,(T2)	;GET NRB POINTER
	CALL DINTRN		;(T4) IN TRANSITION ?
	 RETSKP			;YES. DROP THE CHARACTER.
 	CALL TTCHXX		;CHECK FOR XON, XOFF
	 IFNSK.
	   JN TTNPM,(T2),RSKP	;IT WAS, FLUSH THE CHAR IF OLD MODE
	 ENDIF.
	LOAD T4,TTUEC,(T2)	;GET NETUSER ESCAPE CHARACTER
	XOR T4,T1		;IS THIS IT IN T1?
	JXN T4,177,TTMCI1	;JUMP IF NOT
 	CALL TNUDIE		;IN TRANSITION. QUEUE UP REQUEST FOR MCSRV.
	RETSKP



;TNUDIE is called by TTYSRV when a NETUSER line escapes.
;It sets a flag (NRTRN) which causes MCSRV to clean up
;The flag also causes TTYSRV to throw away all input which occur in the
;interim.

;T2/ TDB
;ONLY RETURN IS +1

TNUDIE::SAVEAC <T1>
        LOAD T1,TTULL,(T2)	;GET POINTER TO 'USER' NRB
        JUMPE T1,RTN           	;LEAVE NOW IF NO ASSOCIATED LINK
	SETONE NRTRN,(T1) 	;SAY IN TRANSITION.
	SETONE NRREL,(T1)	;QUEUE UP REQUEST FOR RELEASE.
	CALLRET REQNS		;(T2)


;IS THIS NRB IN TRANSITION ?
;CALL DINTRN
;RETURN +2 IF NRB IS NOT IN TRANSITION
;RETURN +1 IF NRB IS IN TRANSITION
DINTRN::TMNE NRTRN,(T4)     	;THE BIT
	RET			;IN TRANSITION.
	RETSKP			;NOT IN TRANSITION.

;NRTINI - Initialize NRT Host

;Here to set up NRT host object for DECnet

;Call:	No arguments
;	RET			;ALWAYS

;Here to initialize the NRT data base.  This is about the only part of
;the NRT service that does not run at schedular level.

NRTINI::                        ;CALLED FROM D36COM (D36INI)
	NRTACV                  ;ACVAR <W1,W2,W3,TDB,NRB,SAB>
	EA.ENT			;NRTSRV RUNS IN SECTION 1

	MOVX T1,SA.LEN		;LENGTH OF AN SAB
	XCALL (XCDSEC,DNGWDZ)	;GET WORDS FOR OUR SA BLOCK
	 BUG.(HLT,NVTSAB,TTPHDV,SOFT,<No memory for NRT's SAB>,,<

Cause:	NRT's initialization code was unable to get resident free
	space to build its control blocks.

Action:	Find out why there is so little resident free space so early
	in the system's life.

>)
	MOVE SAB,T1		;USE REGISTER SAB TO POINT TO SAB
	MOVEM SAB,NRTSAP	;STORE POINTER TO SCLINK ARG BLK

;We will elect No Flow Control on incoming links.

	MOVE T1,NRTDFT		;GET DEFAULT GOAL,QUOTAS
	SETZM NRTSJP		;IN CASE WE FAIL, SIGNAL TO OTHERS
	CALL MAKSJB		;GO MAKE AN SJB
	 BUG.(HLT,NVTSJB,TTPHDV,SOFT,<No memory for NRT's SJB>,,<

Cause:	NRT's initialization code was unable to get resident free
	space to build its control blocks.

Action:	Find out why there is so little resident free space so early
	in the system's life.

>)
	STOR SAB,SJSAB,(T1)	;SAVE SAB POINTER IN SJB
	MOVEM T1,NRTSJP		;SAVE POINTER TO NRT'S SJB

	XMOVEI T1,NRTHBR	;POINT TO THE HIBER ROUTINE (BUG.)
	STOR T1,SAHBA,(SAB)	;STORE IN THE HIBER ADDRESS ARGUMENT
	XMOVEI T1,NRTWAK	;GET ADDRESS OF WAKE HANDLER
	STOR T1,SAWKA,(SAB)	; AND TELL SCLINK ABOUT IT
	RET			;RETURN, NRT INITIALIZATION IS DONE

	ENDAV.                  ;END OF NRTACV AT NRTINI



;MCRRH - NRT device dependent "return remote host" code
;
; Given the line #, returns the originating hostname, line and
; network type. Places this info in the users NTINF% .NWRRH 
; argument block.  NTINF has already checked the user arguments 
; for validity.
;
; Call with T1/ address of internal arg block
;
;   ARG+.NWABC/ # of bytes available for host name
;   ARG+.NWFNC/ not used
;   ARG+.NWNNP/ byte pointer to store hostname string
;   ARG+.NWLIN/ address of dynamic data for line
;   ARG+.NWTTF/ flags, and network and terminal types
;   ARG+.NWNNU/ node # word 1
;   ARG+.NWNU1/ node # word 2
;
; Returns + 1 on error with T1/ error code
;	  + 2 on success

	SWAPCD

MCRRH::	SASUBR <UAB>
	MOVEM T1,UAB		;SAVE OUTPUT POINTER
	MOVX T4,NW%DNA		;SET NETWORK TYPE
	DPB T4,[POINT 9,.NWTTF(T1),17] ;STORE NETWORK TYPE
	MOVE T2,.NWLIN(T1)	;GET DYNAMIC DATA ADR
	NOSKED
	LOAD T3,TTHLL,(T2)	;GET LINK INDEX
	JUMPE T3,MCRRH3		;IN CASE ALREADY GONE
	LOAD T4,NRRID,(T3)	;GET DECNET ADDRESS 
	OKSKED	
	MOVEM T4,.NWNNU(T1)	;SAVE IT AWAY
	JUMPE T4,MCRRH4		;IF ZERO - NO HOST NAME
	MOVE T1,T4		;PUT ADDRESS WHERE SCTA2N WANTS IT
	CALL SCTA2N		;CONVERT # TO SIXBIT NAME
	IFNSK.
MCRRH4:	 MOVE T3,UAB		;GET ARG BLOCK ADDRESS
	 MOVE T2,.NWNNP(T3)	;GET BYTE POINTER
	 SETZ T3,		;NO KNOWN NODE NAME FLAG
	 JRST MCRRH2		;COULDN'T
	ENDIF.
	MOVE T3,UAB		;GET ARG BLOCK ADDRESS
	MOVE T2,.NWNNP(T3)	;GET POINTER TO OUTPUT STRING
	CALL GETSIX		;CONVERT SIXBIT TO ASCII
MCRRH2:	SETZ T1,
	IDPB T1,T2		;DEPOSIT A NULL
	MOVE T1,UAB		;GET POINTER TO USER ARG BLOCK
	MOVX T2,NW%NNN		;GET "NO NODE NAME KNOWN" FLAG
	SKIPN T3 		;GOT A NODE NAME ?
	IORM T2,.NWTTF(T1)	;NO - SET THE "NO NODE NAME KNOWN" FLAG
	RETSKP

MCRRH3:	OKSKED
	MOVE T1,UAB		;GET POINTER TO ARG BLOCK
	MOVE T2,.NWNNP(T1)	;GET POINTER TO OUTPUT STRING
	SETZ T3,		;NO NODE NAME
	CALLRET MCRRH2		;UPDATE HOSTNAME STRING, AND RETURN





	TNXEND
	END




