; Edit= 9014 to PHYMSC.MAC on 8-Nov-88 by LOMARTIRE
;Merge Production changes to BUG text
; Edit= 8913 to PHYMSC.MAC on 17-Aug-88 by GSCOTT
;Update BUG. documentation. 
; Edit= 8832 to PHYMSC.MAC on 20-Apr-88 by RASPUZZI (TCO 7.1276)
;Install TCO 7.1276 into the autopatch sources.
;TCO 7.1276 - TCO 7.1268 causes bad side effects. It was an attempt at making
;	      life easier in the login structures lane. Instead of using US.UNA
;	      for a dual purpose, us a new bit U1.NOL.
; UPD ID= 8694, RIP:<7.MONITOR>PHYMSC.MAC.6,   7-Apr-88 15:13:44 by RASPUZZI
;TCO 7.1268 - Set US.UNA during UDB creation. ONLINE will clear it.
; UPD ID= 8589, RIP:<7.MONITOR>PHYMSC.MAC.5,  11-Feb-88 16:55:56 by GSCOTT
;TCO 7.1218 - Update copyright date.
; UPD ID= 8436, RIP:<7.MONITOR>PHYMSC.MAC.4,   4-Feb-88 15:42:34 by GSCOTT
;TCO 7.1210 - Set MSCAOL, MSCAVA, MSCBPK, MSCCDF, MSCCWM, MSCDSR, MSCDWM,
; MSCN2S, MSCNUF, MSCOLE, MSCOLF, MSCORO, MSCPTG, MSCREJ, MSCRLD, MSCTMU, and
; MSCUKD normally not dumpable.  Generate table of contents.
; UPD ID= 8362, RIP:<7.MONITOR>PHYMSC.MAC.3,  21-Jan-88 14:47:28 by MCCOLLUM
;TCO 7.1193 - Hide MSCCDF under CIBUGX.
; *** Edit 7465 to PHYMSC.MAC by LILJA on 29-Apr-87, for SPR #21422
; Check the status of write locked drive in MSCCHK. If a write locked drive
; becomes write enabled clear US.WLK in the UDB and if necessary bring the
; drive online.
; *** Edit 7233 to PHYMSC.MAC by GRANT on 24-Jan-86
; Prevent a cause of FSICFS BUGHLTs by better processing of the online end
; message at MSCI1A. Make sure the command succeeded before setting the DSN. 
; *** Edit 7211 to PHYMSC.MAC by GRANT on 18-Dec-85
; Add CI counters for WATCH 
; *** Edit 7191 to PHYMSC.MAC by GRANT on 12-Nov-85
; Eliminate MSCREJ BUGINF unless in debugging mode 
; UPD ID= 2286, SNARK:<6.1.MONITOR>PHYMSC.MAC.197,  28-Jun-85 11:17:41 by MCCOLLUM
;Change MSCREJ to a BUGINF.
; UPD ID= 2257, SNARK:<6.1.MONITOR>PHYMSC.MAC.196,  21-Jun-85 11:12:56 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 2225, SNARK:<6.1.MONITOR>PHYMSC.MAC.195,  17-Jun-85 11:43:27 by TBOYLE
;document BUGHLT at DONE3
; UPD ID= 2160, SNARK:<6.1.MONITOR>PHYMSC.MAC.194,   5-Jun-85 10:41:28 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 2022, SNARK:<6.1.MONITOR>PHYMSC.MAC.193,  28-May-85 12:11:59 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 2003, SNARK:<6.1.MONITOR>PHYMSC.MAC.192,  24-May-85 12:01:25 by MCCOLLUM
;Fix up MSCDSR BUG.
; UPD ID= 1923, SNARK:<6.1.MONITOR>PHYMSC.MAC.191,   7-May-85 21:25:38 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1854, SNARK:<6.1.MONITOR>PHYMSC.MAC.190,  30-Apr-85 15:06:01 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1795, SNARK:<6.1.MONITOR>PHYMSC.MAC.189,  23-Apr-85 13:19:31 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1764, SNARK:<6.1.MONITOR>PHYMSC.MAC.188,  17-Apr-85 17:26:57 by GRANT
;TCO 6.1.1330 - Connect to software types, not hardware
; UPD ID= 1746, SNARK:<6.1.MONITOR>PHYMSC.MAC.187,   9-Apr-85 15:59:29 by MCCOLLUM
;TCO 6.1.1238 - Fix BUG. documentation
; UPD ID= 1553, SNARK:<6.1.MONITOR>PHYMSC.MAC.186,  20-Feb-85 17:24:23 by GRANT
;TCO 6.1.1200 - In GETSER, call PHYSIO (routine SETDSN) to set the drive serial number
; UPD ID= 1516, SNARK:<6.1.MONITOR>PHYMSC.MAC.185,  13-Feb-85 12:58:51 by TBOYLE
;More TCO 6.1.1125 - Get drive serial number when disk comes online.
; UPD ID= 1489, SNARK:<6.1.MONITOR>PHYMSC.MAC.184,   8-Feb-85 08:28:51 by LOMARTIRE
;More TCO 6.1.1060 - Move CFHSC code here from PHYKLP
; Also, key off of open connection, not open VC for HSC existance.
; UPD ID= 1448, SNARK:<6.1.MONITOR>PHYMSC.MAC.183,   1-Feb-85 14:17:54 by LOMARTIRE
;Add new symbols to describe the priority used by SC.SMG
; UPD ID= 1296, SNARK:<6.1.MONITOR>PHYMSC.MAC.182,   9-Jan-85 14:19:27 by TBOYLE
;TCO 6.1.1120 - Turn off physical addressing bit for UDBPS1,UDBPS2.
; UPD ID= 1231, SNARK:<6.1.MONITOR>PHYMSC.MAC.181,  19-Dec-84 18:36:17 by GRANT
;TCO 6.1.1091 - Put MSCPTG and MSCAVA under CIBUGX switch
; UPD ID= 1056, SNARK:<6.1.MONITOR>PHYMSC.MAC.180,  13-Nov-84 09:05:23 by LOMARTIRE
;Use new sending priority symbols in SC.SMG calls.
; UPD ID= 4898, SNARK:<6.MONITOR>PHYMSC.MAC.178,   6-Oct-84 17:30:39 by MCLEAN
;TURN OFF TAPES AGAIN
; UPD ID= 4880, SNARK:<6.MONITOR>PHYMSC.MAC.177,  25-Sep-84 15:13:18 by MCLEAN
;TURN ON TAPES FOR NOW
; UPD ID= 4866, SNARK:<6.MONITOR>PHYMSC.MAC.176,  24-Sep-84 15:34:24 by MCLEAN
;FIX TAPE PROBLEM WITH OFFLINE
; UPD ID= 4825, SNARK:<6.MONITOR>PHYMSC.MAC.175,  17-Sep-84 10:43:32 by PURRETTA
;Update copyright notice
; UPD ID= 4775, SNARK:<6.MONITOR>PHYMSC.MAC.174,  29-Aug-84 22:09:53 by MCLEAN
;IMPROVE INFORMATION ON MSCAVA
; UPD ID= 4766, SNARK:<6.MONITOR>PHYMSC.MAC.173,  28-Aug-84 21:12:11 by MCLEAN
;PREVENT MSCI1A FROM GETTING MSCUDB ON ONLINE ERRORS
; UPD ID= 4726, SNARK:<6.MONITOR>PHYMSC.MAC.172,  21-Aug-84 20:33:32 by MCLEAN
;TW2PWP USED THE WRONG POINTER TO THE .SBQOR LIST
; UPD ID= 4725, SNARK:<6.MONITOR>PHYMSC.MAC.171,  21-Aug-84 20:08:08 by MCLEAN
;REMOVE SOME DEBUGGING CODE
; UPD ID= 4720, SNARK:<6.MONITOR>PHYMSC.MAC.170,  20-Aug-84 20:40:51 by MCLEAN
;MAKE A PI CHECK AT MSCRIO
; UPD ID= 4719, SNARK:<6.MONITOR>PHYMSC.MAC.169,  20-Aug-84 20:33:10 by MCLEAN
;MAKE CHECK FOR QOR TABLE CLOBBERED
; UPD ID= 4716, SNARK:<6.MONITOR>PHYMSC.MAC.168,  20-Aug-84 14:36:14 by MCLEAN
;ADD DEBUG CODE AT DONE3: AND GET IT RIGHT...
; UPD ID= 4713, SNARK:<6.MONITOR>PHYMSC.MAC.165,  20-Aug-84 14:25:57 by MCLEAN
;BUILD BHD FOR NON-DATA OP'S CAUSE OF CONFLICT WITH QOR'S
; UPD ID= 4683, SNARK:<6.MONITOR>PHYMSC.MAC.164,  13-Aug-84 22:56:24 by MCLEAN
;ADD MSCGON
; UPD ID= 4648, SNARK:<6.MONITOR>PHYMSC.MAC.163,   7-Aug-84 10:22:40 by LOMARTIRE
;FIX HANDLING OF .SSPBC CALLBACK SINCE NOW WE CAN GET AN EXTRA ONE.
; UPD ID= 4585, SNARK:<6.MONITOR>PHYMSC.MAC.162,  24-Jul-84 22:30:03 by MCLEAN
;MAKE BLDUDB BE OFFLINE
; UPD ID= 4497, SNARK:<6.MONITOR>PHYMSC.MAC.161,  12-Jul-84 19:54:03 by LOMARTIRE
;REWORK CALLBACK HANDLING.  REPLACE .SSCBD WITH .SSDDG (DROPPED DATAGRAM)
;CODE FOR AC CHANGE IN .SSDGR/.SSMGR CALLBACK.  REMOVE .SSMNT AND .SSNWO.
; UPD ID= 4437, SNARK:<6.MONITOR>PHYMSC.MAC.160,   5-Jul-84 11:27:25 by PURRETTA
;Missing open braket at MSCINA
; UPD ID= 4431, SNARK:<6.MONITOR>PHYMSC.MAC.159,   4-Jul-84 22:16:21 by MCLEAN
;MAKE CHANGES FOR NEW HOME BLOCK READING
; UPD ID= 4424, SNARK:<6.MONITOR>PHYMSC.MAC.158,   3-Jul-84 14:26:41 by LOMARTIRE
;FIX REFERENCES TO REMOVED DEFSTR CBPTSB.
;MAKE CALL TO SC.RCD PASS IN THE ADDRESS OF THE ARGUMENT BLOCK.
;OBTAIN BLOCK FROM FREE SPACE SINCE SC.RCD NO LONGER DOES SO.
; UPD ID= 4378, SNARK:<6.MONITOR>PHYMSC.MAC.157,  22-Jun-84 17:09:03 by MCLEAN
;MAKE MORE HIGH DENSITY FIXES
; UPD ID= 4354, SNARK:<6.MONITOR>PHYMSC.MAC.156,  18-Jun-84 09:59:36 by MCLEAN
;FIX STATUS RESTORE
; UPD ID= 4352, SNARK:<6.MONITOR>PHYMSC.MAC.155,  15-Jun-84 16:43:46 by MCLEAN
;ADD CODE FOR DUMMY BSD IF THERE IS AN ODD WORD TRANSFER IN HD MODE
; UPD ID= 4349, SNARK:<6.MONITOR>PHYMSC.MAC.154,  15-Jun-84 16:29:40 by MCLEAN
;FIX BOT PROBLEMS AND REMOVE (COMMENT OUT TEMP HSC FIX CODE FOR ONLINE)
; UPD ID= 4332, SNARK:<6.MONITOR>PHYMSC.MAC.153,  13-Jun-84 21:24:01 by MCLEAN
;ADD CODE FOR PHYSICAL ADDRESSING
; UPD ID= 4327, SNARK:<6.MONITOR>PHYMSC.MAC.152,  12-Jun-84 21:13:37 by MCLEAN
;FIX HIGH DENSITY MODTBL ENTRY TO BE 9 NOT 1
; UPD ID= 4323, SNARK:<6.MONITOR>PHYMSC.MAC.151,  12-Jun-84 12:01:36 by MCLEAN
;FIX POLLER NOT TO TRY TO ONLINE THREE PORTED DISKS
; UPD ID= 4311, SNARK:<6.MONITOR>PHYMSC.MAC.150,   8-Jun-84 14:38:02 by MCLEAN
;FIX SOME = THAT SHOULD BE ==
; UPD ID= 4303, SNARK:<6.MONITOR>PHYMSC.MAC.149,   6-Jun-84 12:23:16 by MCLEAN
;FIX LOOP PROBLEM AT POLLER
; UPD ID= 4281, SNARK:<6.MONITOR>PHYMSC.MAC.148,   1-Jun-84 12:20:22 by LOMARTIRE
;VARIOUS CHANGES FOR SBI TO NODE NUMBER CONVERSION
; UPD ID= 4277, SNARK:<6.MONITOR>PHYMSC.MAC.147,  31-May-84 22:15:31 by MCLEAN
;FIX TAPE FORMAT CHECK
; UPD ID= 4261, SNARK:<6.MONITOR>PHYMSC.MAC.146,  30-May-84 16:53:08 by MCLEAN
;MESSED UP COUNT FOR NON-HIGH DENSITY STUFF
; UPD ID= 4240, SNARK:<6.MONITOR>PHYMSC.MAC.145,  24-May-84 22:06:58 by MCLEAN
;TEMP FIX TO TRY AND ELIMINATE MSCIBG
; UPD ID= 4212, SNARK:<6.MONITOR>PHYMSC.MAC.144,  11-May-84 17:48:00 by MCLEAN
;ADD A CHECK TO REFUSE TO START I/O BEFORE HOMEBLOCK CHECK
; UPD ID= 4196, SNARK:<6.MONITOR>PHYMSC.MAC.143,   9-May-84 13:17:30 by LOMARTIRE
;REPLACE .RJNOM WITH .CMCNM
; UPD ID= 4188, SNARK:<6.MONITOR>PHYMSC.MAC.142,   8-May-84 16:41:51 by MCLEAN
;SOME TAPE FIXES FOR EOT
; UPD ID= 4166, SNARK:<6.MONITOR>PHYMSC.MAC.141,   1-May-84 14:49:42 by MCLEAN
;TPD FIX AT MSSONL
; UPD ID= 4162, SNARK:<6.MONITOR>PHYMSC.MAC.140,   1-May-84 13:37:25 by MCLEAN
;LEFT IORBS ON PWQ WHEN SWITCHING UNITS
; UPD ID= 4158, SNARK:<6.MONITOR>PHYMSC.MAC.139,  30-Apr-84 21:21:56 by MCLEAN
;FIX DONET FOR EOT AND MAKE IT GO TO DONE NOT DONE1
; UPD ID= 4144, SNARK:<6.MONITOR>PHYMSC.MAC.138,  25-Apr-84 21:29:59 by MCLEAN
;CHANGE THE WAY RE-QUEUE WORKS
; UPD ID= 4101, SNARK:<6.MONITOR>PHYMSC.MAC.136,  18-Apr-84 19:36:54 by MCLEAN
;MAJOR CHANGES TO ADD TAPES AND FIX A FEW REGISTER SAVES
; UPD ID= 4010, SNARK:<6.MONITOR>PHYMSC.MAC.133,  30-Mar-84 16:45:27 by MCLEAN
;OFFLINE 16 BIT DISKS WITH US.UNA
; UPD ID= 4005, SNARK:<6.MONITOR>PHYMSC.MAC.132,  28-Mar-84 20:59:37 by MCLEAN
;HOME BLOCK CHECK WRONG AT MSCI17
; UPD ID= 3989, SNARK:<6.MONITOR>PHYMSC.MAC.131,  27-Mar-84 21:36:14 by MCLEAN
;ADD BH.PRE (PRESERVE VALID BIT).
; UPD ID= 3975, SNARK:<6.MONITOR>PHYMSC.MAC.130,  26-Mar-84 10:27:01 by HALL
;Fix previous edit so that tables are parallel
; UPD ID= 3968, SNARK:<6.MONITOR>PHYMSC.MAC.129,  23-Mar-84 22:09:26 by MCLEAN
;TAPE FIXES AND OFLINE FIX FOR MISSING BUFFER
; UPD ID= 3958, SNARK:<6.MONITOR>PHYMSC.MAC.128,  21-Mar-84 21:50:47 by MCLEAN
;ADD UPDATES FOR TAPE AND CHANGES FOUND IN CX
; UPD ID= 3927, SNARK:<6.MONITOR>PHYMSC.MAC.127,  14-Mar-84 13:24:53 by LOMARTIRE
;USE MSCOLD INSTEAD OF MSCCID FOR CALLS TO SC.NOD WHEN MSCCID IS INVALID
; UPD ID= 3884, SNARK:<6.MONITOR>PHYMSC.MAC.126,   9-Mar-84 15:18:00 by MCLEAN
;MAKE HSC50 DISCONNECTS RETRY
; UPD ID= 3881, SNARK:<6.MONITOR>PHYMSC.MAC.125,   7-Mar-84 22:26:15 by MCLEAN
;BUG AT MSCC44-5. CAN'T SET STATUS AFTER GCS
; UPD ID= 3853, SNARK:<6.MONITOR>PHYMSC.MAC.124,   5-Mar-84 13:34:40 by LOMARTIRE
;Add node number and connect ID to certain BUGxxx occurrences
;Change all BUGxxx names to MSCnnn 
; UPD ID= 3844, SNARK:<6.MONITOR>PHYMSC.MAC.123,   4-Mar-84 17:06:57 by MCLEAN
;ADD CODE TO SUPPORT UNIT 0
; UPD ID= 3841, SNARK:<6.MONITOR>PHYMSC.MAC.122,   2-Mar-84 22:59:11 by MCLEAN
;ALSO OTHER CLEANUPS
;HANDLE WRITE LOCK THAT OCCURS DURING WRITE
; UPD ID= 3838, SNARK:<6.MONITOR>PHYMSC.MAC.121,   2-Mar-84 15:50:03 by MCLEAN
;REMOVE KDB DISP 14 MSCCHK IS CALLED BY SCHEDULER
; UPD ID= 3743, SNARK:<6.MONITOR>PHYMSC.MAC.120,  23-Feb-84 16:38:04 by MCLEAN
;FIX FLGHOM TO USE SAVEAC TO SAVE P2 INSTEAD OF Q3
; UPD ID= 3712, SNARK:<6.MONITOR>PHYMSC.MAC.119,  21-Feb-84 12:59:14 by CDUNN
;Change process names to use a 16 byte 8 bit ASCII string. Also change calls 
;to SC.CON to pass the address of the string, not a byte pointer.
; UPD ID= 3670, SNARK:<6.MONITOR>PHYMSC.MAC.118,   8-Feb-84 10:09:26 by MILLER
;Set US.2PT for all CI disks
; UPD ID= 3643, SNARK:<6.MONITOR>PHYMSC.MAC.117,   2-Feb-84 11:58:57 by MCLEAN
;REMOVE CODE AT TW2PMS SINCE IT GOT THE STRUCTURE NUMBER CONFUSED.
; UPD ID= 3629, SNARK:<6.MONITOR>PHYMSC.MAC.116,   1-Feb-84 21:24:35 by MCLEAN
;GENERAL CLEANUP
; UPD ID= 3571, SNARK:<6.MONITOR>PHYMSC.MAC.115,  28-Jan-84 01:03:28 by MCLEAN
;STRUCTURE MACROS FROM SCAPAR ADDED
; UPD ID= 3548, SNARK:<6.MONITOR>PHYMSC.MAC.114,  25-Jan-84 23:15:15 by MCLEAN
;ADD A DISCONNECT SCAMPI RETURN JUST IN CASE....
; UPD ID= 3513, SNARK:<6.MONITOR>PHYMSC.MAC.113,  23-Jan-84 11:47:06 by MCLEAN
;CHECK FOR ILLEGAL NODE NUMBER IN MSCOUN
; UPD ID= 3507, SNARK:<6.MONITOR>PHYMSC.MAC.112,  22-Jan-84 19:00:35 by MCLEAN
;TYPO IN NODBYE
; UPD ID= 3506, SNARK:<6.MONITOR>PHYMSC.MAC.111,  22-Jan-84 16:26:29 by MCLEAN
;MANY UPDATES PER REVIEW
; UPD ID= 3461, SNARK:<6.MONITOR>PHYMSC.MAC.110,  16-Jan-84 11:37:52 by MCLEAN
;ADD MAXUNN
; UPD ID= 3454, SNARK:<6.MONITOR>PHYMSC.MAC.109,  13-Jan-84 16:06:54 by MCLEAN
;GAVE BUFFER BACK AND THEN USED IT.....
; UPD ID= 3438, SNARK:<6.MONITOR>PHYMSC.MAC.108,  11-Jan-84 22:22:19 by MCLEAN
;TAPE AND OTHER CLEANUPS
; UPD ID= 3437, SNARK:<6.MONITOR>PHYMSC.MAC.107,  11-Jan-84 16:58:13 by MCLEAN
;MSCTMO WAS BROKEN ALSO TAPE CLEANUPS
; UPD ID= 3425, SNARK:<6.MONITOR>PHYMSC.MAC.106,   8-Jan-84 20:20:31 by MCLEAN
;A FEW RANDOM CLEANUPS
; UPD ID= 3424, SNARK:<6.MONITOR>PHYMSC.MAC.105,   8-Jan-84 17:13:38 by MCLEAN
;ADD CHECK FOR MISSING CONNECT RESPONSE AND WAIT CHECKS FOR IT.
; UPD ID= 3414, SNARK:<6.MONITOR>PHYMSC.MAC.104,   6-Jan-84 05:58:37 by GRANT
;Remove MSONOD BUGINF
; UPD ID= 3410, SNARK:<6.MONITOR>PHYMSC.MAC.103,   6-Jan-84 00:45:20 by MCLEAN
;TAPE ONLY CHANGES
; UPD ID= 3406, SNARK:<6.MONITOR>PHYMSC.MAC.102,   3-Jan-84 20:58:45 by MCLEAN
;FIXES TO FNDSLT AND MSGAA FOR MULTPLE AVAILABLES/ONLINES
; UPD ID= 3390, SNARK:<6.MONITOR>PHYMSC.MAC.101,  29-Dec-83 23:43:35 by MCLEAN
;CHANGE JUMP TO MSCI23 BE MSCI18 WHICH MAY FIX SLTBSY BUGCHK
; UPD ID= 3389, SNARK:<6.MONITOR>PHYMSC.MAC.100,  29-Dec-83 23:18:01 by MCLEAN
;MAKE BUGXXX'S CORRECT TYPE
; UPD ID= 3388, SNARK:<6.MONITOR>PHYMSC.MAC.99,  29-Dec-83 16:34:52 by MCLEAN
;ALSO NEED TO CHECK BHD'S FOR COMPLETION CORRECTLY
;A FEW MORE POLLER CHECKS AND MAKE SENDPK RETURN
; UPD ID= 3368, SNARK:<6.MONITOR>PHYMSC.MAC.98,  26-Dec-83 14:12:26 by MCLEAN
;MORE EDITS TO MAKE POLLER WORK BETTER
; UPD ID= 3338, SNARK:<6.MONITOR>PHYMSC.MAC.97,  16-Dec-83 21:54:44 by MCLEAN
;FIX FNDSLT FOR SBI INDEX NOT NODE NUMBER
; UPD ID= 3336, SNARK:<6.MONITOR>PHYMSC.MAC.96,  16-Dec-83 20:56:06 by MCLEAN
;FIX SBI/NODE PROBLEMS AND OTHER RANDOM PROBLEMS.
; UPD ID= 3329, SNARK:<6.MONITOR>PHYMSC.MAC.95,  14-Dec-83 23:39:12 by MCLEAN
;CHANGE TW2PWQ TO MOVE ALL ENTRIES TO ONE PWQ
; UPD ID= 3292, SNARK:<6.MONITOR>PHYMSC.MAC.94,  11-Dec-83 20:36:52 by MCLEAN
;FIX DGREC FOR CORRECT DATA SIZE
; UPD ID= 3288, SNARK:<6.MONITOR>PHYMSC.MAC.93,  11-Dec-83 20:20:20 by GRANT
;In MSCRIO, use new symbol VC.OPN
; UPD ID= 3286, SNARK:<6.MONITOR>PHYMSC.MAC.92,  11-Dec-83 17:26:59 by MCLEAN
;FIX TW2PW5 TO SEARCH QOR'S CORRECTLY ALSO REMOVE US.2PT
;POLLER FIXES TO MAKE TIMEOUT FOR INDIVIDUAL HSC50'S.
; UPD ID= 3284, SNARK:<6.MONITOR>PHYMSC.MAC.91,   9-Dec-83 23:09:57 by MCLEAN
;MAKE INACTIVE WHEN OFFLINE
; UPD ID= 3277, SNARK:<6.MONITOR>PHYMSC.MAC.90,   7-Dec-83 18:10:50 by MCLEAN
;CAUSE TW2PWQ TO SAVE P'S
; UPD ID= 3275, SNARK:<6.MONITOR>PHYMSC.MAC.89,   7-Dec-83 15:21:29 by MCLEAN
;WORK ON GETTING SWITCHING UNITS RIGHT
; UPD ID= 3237, SNARK:<6.MONITOR>PHYMSC.MAC.88,  30-Nov-83 19:46:35 by MCLEAN
;MORE FIXES AND CHANGES FOR BATBLOCKS
; UPD ID= 3216, SNARK:<6.MONITOR>PHYMSC.MAC.87,  27-Nov-83 21:47:56 by MCLEAN
;FOUND EXTRANEOUS ENDSV.
; UPD ID= 3215, SNARK:<6.MONITOR>PHYMSC.MAC.86,  27-Nov-83 21:44:15 by MCLEAN
;USE SCAMPI FOR RESET AND START FUNCTIONS
; UPD ID= 3213, SNARK:<6.MONITOR>PHYMSC.MAC.85,  26-Nov-83 21:33:57 by MCLEAN
;GENERAL CLEANUP/RE-ARRANGEMENT ALSO FIX IT SO BHD IS NOT EXPECTED IN END
;PACKET
; UPD ID= 3212, SNARK:<6.MONITOR>PHYMSC.MAC.84,  23-Nov-83 18:33:51 by MCLEAN
;MANY STARTUP CHANGES
; UPD ID= 3205, SNARK:<6.MONITOR>PHYMSC.MAC.83,  20-Nov-83 19:21:40 by MCLEAN
;REMOVE TIMEOUT BY HSC CAUSE JUDY DOESN'T LIKE IT
; UPD ID= 3203, SNARK:<6.MONITOR>PHYMSC.MAC.82,  20-Nov-83 16:22:17 by MCLEAN
;MORE CHANGES TO ONLINE STUFF
; UPD ID= 3201, SNARK:<6.MONITOR>PHYMSC.MAC.81,  19-Nov-83 20:40:28 by MCLEAN
;TYPO IN .RJNOM AC
; UPD ID= 3200, SNARK:<6.MONITOR>PHYMSC.MAC.80,  19-Nov-83 17:28:07 by MCLEAN
;MANY RANDOM FIXES FOR RELIABILITY
;REMOVE BROKEN DEBUG STUFF.
; UPD ID= 3190, SNARK:<6.MONITOR>PHYMSC.MAC.79,  17-Nov-83 17:25:42 by MCLEAN
;CHANGE CMDJMP TABLE SO ENTRY 0 IS UNUSED
; UPD ID= 3189, SNARK:<6.MONITOR>PHYMSC.MAC.78,  17-Nov-83 16:23:21 by CDUNN
;More TCO 6.1127 - Make SC.SMG calls conform to new calling sequence
; UPD ID= 3139, SNARK:<6.MONITOR>PHYMSC.MAC.77,  11-Nov-83 16:19:54 by MCLEAN
;TEMP MAKE TABLES BIGGER
; UPD ID= 3113, SNARK:<6.MONITOR>PHYMSC.MAC.76,   7-Nov-83 21:40:25 by MCLEAN
;ADD PORT RELEASE DISPATCH
; UPD ID= 3106, SNARK:<6.MONITOR>PHYMSC.MAC.75,   7-Nov-83 21:18:15 by MCLEAN
;MAKE SERIAL NUMBER RIGHT JUSTIFIED
; UPD ID= 3092, SNARK:<6.MONITOR>PHYMSC.MAC.72,   2-Nov-83 04:34:44 by GRANT
;In MSCCHK, remove DGPOLL check;  MSCP no longer knows about KLIPA polling
; UPD ID= 3075, SNARK:<6.MONITOR>PHYMSC.MAC.71,  25-Oct-83 13:05:37 by GRANT
;Change MSCDSP.  Remove CHNDSP.  Move MSCCCW and MSCCCA to PHYKLP.
;MSCCHK now called from scheduler clock.  MSCCHK no longer calls KLPCHK.
; UPD ID= 3036, SNARK:<6.MONITOR>PHYMSC.MAC.70,  17-Oct-83 11:01:44 by TGRADY
; TCO 6.1829 - In MSCI1A use UNTYPE to check for valid unit type
; TCO 6.1830 - In CNRAVL check for valid Connect Id for BADCID BUGHLT
; UPD ID= 3025, SNARK:<6.MONITOR>PHYMSC.MAC.69,  10-Oct-83 22:34:43 by MCLEAN
;MISSING >
; UPD ID= 3024, SNARK:<6.MONITOR>PHYMSC.MAC.68,  10-Oct-83 22:29:24 by MCLEAN
;GENERAL CLEANUP OF JUNK
; UPD ID= 3015, SNARK:<6.MONITOR>PHYMSC.MAC.67,   8-Oct-83 23:05:43 by MCLEAN
;TYPO IN PREVIOUS EDIT
; UPD ID= 3014, SNARK:<6.MONITOR>PHYMSC.MAC.66,   8-Oct-83 22:27:30 by MCLEAN
;TCO 6.1822 DON'T LOOSE Q2 IN BLDUDB
; UPD ID= 2974, SNARK:<6.MONITOR>PHYMSC.MAC.65,   3-Oct-83 11:15:33 by MCLEAN
;SET US.2PT FOR MSCP DISKS
; UPD ID= 2963, SNARK:<6.MONITOR>PHYMSC.MAC.64,  30-Sep-83 16:07:18 by MCLEAN
;FIX CRNREJ TYPO IN MESSAGE
; UPD ID= 2937, SNARK:<6.MONITOR>PHYMSC.MAC.63,  27-Sep-83 09:44:51 by GRANT
;Change PPDINT, PPDZAP, and PPDCHK to KLPINT, KLPZAP, and KLPCHK, respectively.
; UPD ID= 2856, SNARK:<6.MONITOR>PHYMSC.MAC.62,  22-Aug-83 15:43:45 by MCLEAN
;NEED REFERENCES TO CI%PAK TO GET ERROR REPORT CORRECT.
; UPD ID= 2853, SNARK:<6.MONITOR>PHYMSC.MAC.61,  19-Aug-83 14:32:16 by MURPHY
;Reformat to TOPS20 conventions.
; UPD ID= 2821, SNARK:<6.MONITOR>PHYMSC.MAC.59,   9-Aug-83 15:31:58 by PURRETTA
;Remove crlf in middle of MSCILF bugchk description.
; UPD ID= 2714, SNARK:<6.MONITOR>PHYMSC.MAC.58,  21-Jul-83 15:54:01 by MCLEAN
;MISSING < IN SENDPK
; UPD ID= 2709, SNARK:<6.MONITOR>PHYMSC.MAC.57,  19-Jul-83 21:20:43 by MCLEAN
;SOME RELIABILITY EDITS AND A TXNN TO TDNN AT FNDSLT+5
; UPD ID= 2695, SNARK:<6.MONITOR>PHYMSC.MAC.56,  12-Jul-83 23:41:32 by MCLEAN
;A FEW MORE COMMENTS...
; UPD ID= 2692, SNARK:<6.MONITOR>PHYMSC.MAC.55,  11-Jul-83 15:30:11 by MCLEAN
;MAKE AOJA AT MSCCH3+ A FEW GO TO MSCCH3 NOT TO MSCCH3A
; UPD ID= 2691, SNARK:<6.MONITOR>PHYMSC.MAC.54,  11-Jul-83 15:05:47 by MCLEAN
;ONLCK1 DID NOT SETUP Q1 FOR MSGAV3
; UPD ID= 2687, SNARK:<6.MONITOR>PHYMSC.MAC.53,  10-Jul-83 22:19:35 by MCLEAN
;FIX CALLS TO PBRCOA SO THEY HAVE THE CORRECT INFORMATION AND
;FIX PBRCOA SO IT CALL FNDNDX
; UPD ID= 2660, SNARK:<6.MONITOR>PHYMSC.MAC.52,   3-Jul-83 20:54:37 by MCLEAN
;NEED EITHER IS.DTE OR IS.DVE TO GET I/O REQUEST TO FAIL...
;THERE MSCIS9 WOULD NOT SEE DATA ERRORS.
; UPD ID= 2658, SNARK:<6.MONITOR>PHYMSC.MAC.51,   3-Jul-83 20:32:37 by MCLEAN
;ERROR LOGGING NEEDS IS.DTE TO DO BAT BLOCK LOGIC.
; UPD ID= 2657, SNARK:<6.MONITOR>PHYMSC.MAC.50,   3-Jul-83 00:44:45 by MCLEAN
;EDIT DIDN'T MAKE IT.... TRY AGAIN
; UPD ID= 2655, SNARK:<6.MONITOR>PHYMSC.MAC.48,   2-Jul-83 10:35:23 by MCLEAN
;A LITTLE MORE INFORMATION AT PKSNFL BUGCHK
; UPD ID= 2653, SNARK:<6.MONITOR>PHYMSC.MAC.47,   1-Jul-83 17:15:04 by MCLEAN
;PKSNFL BUGCHK OCCURS MORE OFTEN THAN NECESSARY
; UPD ID= 2649, SNARK:<6.MONITOR>PHYMSC.MAC.46,  30-Jun-83 23:30:11 by MCLEAN
;MORE PARANOIA AND COMMENTS
; UPD ID= 2647, SNARK:<6.MONITOR>PHYMSC.MAC.45,  29-Jun-83 21:17:24 by MCLEAN
;ADD MORE COMMENTS.  DON'T WORRY MORE TO COME ALSO
; UPD ID= 2646, SNARK:<6.MONITOR>PHYMSC.MAC.44,  29-Jun-83 16:02:06 by MCLEAN
;A LOT OF COMMENTS AND SOME STATE INFORMATION.
; UPD ID= 2645, SNARK:<6.MONITOR>PHYMSC.MAC.43,  28-Jun-83 20:34:37 by MCLEAN
;ALU GOT IT WRONG THE FIRST TRY...... SO WE WILL TRY AGAIN.
;MASSIVE EDITS TO ADD TIMEOUT CODE AND TIMESHARING BUGCHECKS TO
;HELP FIND OUT WHAT THE STATUS OF THE DISK SUBSYSTEM WHEN SOMETHING
;UNUSUAL HAPPENS
;TCO 6.1703 CHANGE SAVEAC (Q1) TO SAVEAC <Q1>.
; UPD ID= 2575, SNARK:<6.MONITOR>PHYMSC.MAC.42,   8-Jun-83 18:01:32 by MOSER
; UPD ID= 2573, SNARK:<6.MONITOR>PHYMSC.MAC.40,   8-Jun-83 16:07:24 by MOSER
;TCO 6.1674 - REMOVE INIT DEPENDENT CODE
; UPD ID= 2567, SNARK:<6.MONITOR>PHYMSC.MAC.39,   7-Jun-83 22:10:34 by MCLEAN
;MORE BUGINFS AND A FIX FOR MISSING POP
; UPD ID= 2566, SNARK:<6.MONITOR>PHYMSC.MAC.38,   7-Jun-83 20:58:48 by MCLEAN
;ADD A LOT MORE BUGINF'S TO SEE WHAT IS GOING ON.
; UPD ID= 2537, SNARK:<6.MONITOR>PHYMSC.MAC.37,  27-May-83 15:08:57 by MCLEAN
;MORE TCO 6.1669 GET SETZM RIGHT
; UPD ID= 2536, SNARK:<6.MONITOR>PHYMSC.MAC.36,  26-May-83 21:48:26 by MCLEAN
;MORE TCO 6.1665 MISSED ONE CLEAR OF THE SERIAL NUMBER
; UPD ID= 2535, SNARK:<6.MONITOR>PHYMSC.MAC.35,  26-May-83 21:44:12 by MCLEAN
;ZERO OUT KDBIAC WHEN NOBODY IS WAITING
; UPD ID= 2534, SNARK:<6.MONITOR>PHYMSC.MAC.34,  26-May-83 19:37:54 by MCLEAN
;TCO 6.1669 ADD A (P2) AT RESTAC:
; UPD ID= 2513, SNARK:<6.MONITOR>PHYMSC.MAC.33,  24-May-83 20:43:02 by MCLEAN
;TCO 6.1665 ADD SECOND WORD TO SERIAL NUMBER CODE.
; UPD ID= 2504, SNARK:<6.MONITOR>PHYMSC.MAC.32,  23-May-83 15:18:10 by MOSER
; UPD ID= 2503, SNARK:<6.MONITOR>PHYMSC.MAC.31,  23-May-83 14:53:21 by MOSER
;TCO 6.1562 USE MSCPAR FOR SYMBOLS
; UPD ID= 2495, SNARK:<6.MONITOR>PHYMSC.MAC.30,  20-May-83 16:21:39 by MCLEAN
;TCO 6.1127 MAKE MSCOUN RETURN +2 IF SUCCESS.....
; UPD ID= 2492, SNARK:<6.MONITOR>PHYMSC.MAC.29,  18-May-83 23:37:00 by MCLEAN
;TCO 1657 AND YET MORE BUGCHK'S
; UPD ID= 2485, SNARK:<6.MONITOR>PHYMSC.MAC.28,  17-May-83 23:53:20 by MCLEAN
;TCO 1657 ADD A FEW MORE BUGXXX'S
; UPD ID= 2484, SNARK:<6.MONITOR>PHYMSC.MAC.27,  17-May-83 22:30:13 by MCLEAN
;TCO 6.1127 (TONY LIKED THIS ONE)
; UPD ID= 2472, SNARK:<6.MONITOR>PHYMSC.MAC.26,  16-May-83 17:28:22 by MOSER
;MORE TCO 6.1562 - ALLOW UNIT NUMBER UP TO 3000 OCTAL IN MSCEXT
; UPD ID= 2465, SNARK:<6.MONITOR>PHYMSC.MAC.25,  15-May-83 21:53:09 by MCLEAN
;TCO 1657 REMOVE ##'S AND ADD A FEW BUGINF'S
; UPD ID= 2464, SNARK:<6.MONITOR>PHYMSC.MAC.24,  13-May-83 11:16:26 by WACHS
; UPD ID= 2463, SNARK:<6.MONITOR>PHYMSC.MAC.23,  13-May-83 06:10:10 by WACHS
;More TCO 6.1127 - Add MSCOUN to ONLINE a disk via DIAG JSYS
; UPD ID= 2432, SNARK:<6.MONITOR>PHYMSC.MAC.22,   6-May-83 06:30:52 by WACHS
;More TCO 6.1127 - Fix confusion with INIT
; UPD ID= 2430, SNARK:<6.MONITOR>PHYMSC.MAC.21,   5-May-83 21:05:56 by WACHS
;More TCO 6.1127 - problems with HSCs crashing
;More TCO 6.1127 - error recovery additions
; UPD ID= 2365, SNARK:<6.MONITOR>PHYMSC.MAC.19,  27-Apr-83 21:15:43 by CDUNN
;More TCO 6.1127 - Remove false CFSINI
; UPD ID= 2337, SNARK:<6.MONITOR>PHYMSC.MAC.18,  25-Apr-83 13:35:29 by MOSER
;TCO 6.1562 - ALLOW BIGGER UNIT NUMBER FOR MSCP DISKS
; UPD ID= 2329, SNARK:<6.MONITOR>PHYMSC.MAC.17,  22-Apr-83 04:32:22 by WACHS
;More TCO 6.1127 - error recovery additions
; UPD ID= 2305, SNARK:<6.MONITOR>PHYMSC.MAC.16,  19-Apr-83 08:50:47 by MCINTEE
;Still more TCO 6.1127 - put closing angle bracket in previous edit
; UPD ID= 2303, SNARK:<6.MONITOR>PHYMSC.MAC.15,  19-Apr-83 07:34:53 by WACHS
;More TCO 6.1127 - error recovery additions
; UPD ID= 2208, SNARK:<6.MONITOR>PHYMSC.MAC.14,   8-Apr-83 06:11:27 by WACHS
;More TCO 6.1127
; UPD ID= 2142, SNARK:<6.MONITOR>PHYMSC.MAC.13,   4-Apr-83 07:29:53 by WACHS
;TCO 6.1587 - change addressing of HSC disks to per-page
; UPD ID= 2019, SNARK:<6.MONITOR>PHYMSC.MAC.11,  18-Mar-83 07:03:17 by WACHS
;TCO 6.1541 - Move DMA stuff from PHYMSC to PHYKLP
; UPD ID= 1986, SNARK:<6.MONITOR>PHYMSC.MAC.7,  14-Mar-83 15:31:30 by CDUNN
;More TCO 6.1127 - Change DEBUG to MSCDBG and put MSCDBG in SYSFLG.MAC
; UPD ID= 1966, SNARK:<6.MONITOR>PHYMSC.MAC.6,  10-Mar-83 16:07:54 by CDUNN
;More TCO 6.1127 - Recover from errors rather than call MSCBUG and other
;random stability edits.

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1984, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


	SEARCH PROLOG,SERCOD	;SYSTEM PARAMETERS
	TTITLE (PHYMSC,,< - MSCP DRIVER>)
	SUBTTL T. WACHS 28-JAN-82 R.H. MCLEAN 7/83
	SEARCH MSCPAR,PHYPAR,SCAPAR ;PHYSIO PARAMETERS
	Subttl	Table of Contents

;		     Table of Contents for PHYMSC
;
;				  Section		      Page
;
;
;    1. Start I/O  . . . . . . . . . . . . . . . . . . . . . .   4
;    2. General Purpose Packet Routines  . . . . . . . . . . .  13
;    3. Interrupt Service  . . . . . . . . . . . . . . . . . .  15
;    4. Diag Online  . . . . . . . . . . . . . . . . . . . . .  38
;    5. General Purpose Routines . . . . . . . . . . . . . . .  40
;    6. PHYSIO Interface . . . . . . . . . . . . . . . . . . .  46
;    7. Initialization . . . . . . . . . . . . . . . . . . . .  48
;    8. Init Assist Routines . . . . . . . . . . . . . . . . .  65
;    9. General Routines . . . . . . . . . . . . . . . . . . .  69
;   10. Periodic Check . . . . . . . . . . . . . . . . . . . .  75
;   11. CNFIG% JSYS Support
;       11.1    CFHSC (Return list of HSC node names)  . . . .  83
;   12. Storage  . . . . . . . . . . . . . . . . . . . . . . .  86
;   13. End of PHYMSC  . . . . . . . . . . . . . . . . . . . .  90


;LOCAL BYTE POINTERS

DEFSTR PKYEST,P.STS,PKPEST,PKSEST ;END-PACKET STATUS
DEFSTR PKYQSB,P.STS,PKPESB,PKSESB ;END-PACKET STATUS SUB-CODE
DEFSTR PKYFCD,P.STS,PKPFCD,PKSFCD ;END-PACKET FLAGS
DEFSTR PKYECD,P.STS,PKPECD,PKSECD ;ENDCODE

;Note: These process names are required by SCA to be 16 byte 8 bit ASCII 
;strings.

OURDNM:	ASCI8 (<T-20$DISK       >)
YURDNM:	ASCI8 (<MSCP$DISK       >)
OURTNM:	ASCI8 (<T-20$TAPE       >)
YURTNM:	ASCI8 (<MSCP$TAPE       >)
DEFSTR LOBYTE,,31,7

;CONTROLLER DISPATCH VECTOR FOR HSC-CONTROLLED DISKS

MSCDSP::JRST MSCRNG		;0 - INITIALIZATION
	JRST MSCSIO		;1 - START I/O
	JRST MSCRNG		;2 - HANDLE INTERRUPT
	RETSKP			;3 - ERROR RECOVERY
	RET			;4 - HUNG DEVICE (THE HSC MAY RETURN)
	JRST MSCRNG		;5 - CONVERT BLK # TO CYLINDER/SURF-SEC
	JRST MSCRNG		;6 - LATENCY COMPUTATION
	JRST MSCRNG		;7 - START POSITIONING
	JRST MSCRNG		;10 - ATTENTION INTERRUPT
	JRST MSCRNG		;11 - SKIP IF POSITIONING REQUIREDD
	JRST MSCRNG		;12 - STACK SECOND TRANSFER COMMAND
	JRST MSCEXT		;13- CHECK EXISTANCE OF UNIT
	JRST R			;14- CHECK FOR HALTED CONTROLLER
	RET			;15 - PORT RELEASE

MSCRNG:	BUG.(HLT,MSCBAD,PHYMSC,SOFT,<PHYMSC - Bad dispatch from PHYSIO>,,<

Cause:	PHYSIO called PHYMSC at the MSCDSP controller dispatch vector to
	perform a function that is illegal for MSCP devices.  This is a
	software problem.
>)
	SUBTTL Start I/O

;MSCSIO:,MSCRIO:  
;PHYSIO ENTERS AT MSCSIO TO START A DATA TRANSFER OR IN THE CASE OF
; A TAPE A POSITION FUNCTION.
;
;P1=CDB   P2=KDB   P3=UDB  P4=IORB
;RETURN:  +1 REQUEST FAILED. 
;	  +2 SUCCESS THE REQUEST IS QUEUE'D OR STARTED.
MSCSIO:	SAVEQ
	STKVAR <MRW1,FMT,CNT,SIZ>
MSCRIO:	MOVX T2,BS.HDM		;SET HIGH DENSITY AS DEFAULT
	MOVEM T2,FMT
	MOVEI T2,^D9		;SET SIZE AT 9
	MOVEM T2,CNT
	LOAD T2,SBVCST,(P2)	;GET VC STATE
	CAIN T2,VC.OPN		;IS IT OPEN?
	SKIPGE Q1,UDBSTS(P3)	;DISK ONLINE?
	RET			;NO. NO SENSE IN GOING FURTHER
	TXNE Q1,US.CHB		;HOMEBLOCK CHECK?
	CAMN P4,UDBCHB(P3)	;YES CHECK FOR SPECIAL IORB
	SKIPA			;NEITHER ALL OK
	RET			;CAN'T START THIS ONE
	LDB T1,IRYFCN		;YES. GET FUNCTION FROM IORB
	SKIPN Q3,MSCFCN(T1)	;YES, IS IT A DEFINED FUNCTION FOR AN MSCP SERVER?
	JRST  [BUG.(CHK,MSCILF,PHYMSC,SOFT,<PHYMSC - Illegal function at start IO>,<<T1,FCN>>,<

Cause:	Illegal function at call to start IO on a MSCP device.  The caller of
	MSCRIO or MSCSIO has specified an function code that is not legal for
	MSCP devices.

Action:	If this BUGCHK is reproducable, set it dumpable, and send in an SPR
	with the dump and how to reproduce the problem.

Data:	FCN - The illegal function
>)
		RET]

	SKIPL UDBSTR(P3)	;IS THE UNIT IN A STR?
	JRST MSCSI1		;YES
	HLRZ T1,UDBTWQ(P3)	;NO. GET END OF TWQ
	HRRZ T2,UDBTWQ(P3)	;AND FRONT OF QUEUE
	CAIE T1,(T2)		;THIS THE ONLY ENTRY IN THE QUEUE?
	JRST QUEIRB		;NO. ONLY ALLOW 1 REQUEST TO BE OUTSTANDING
	TXNN Q1,US.TAP		;CHECK FOR TAPES
	JRST MSCSI1		;NOT A TAPE NO DIFFERENT FORMAT
	LOAD T1,IRBDM,(P4)	;GET DENSITY
	CAIG T1,5		;LEGAL RANGE?
	SKIPGE T2,MODTBL(T1)	;YES CHECK FOR LEGAL HERE TOO
	JRST COMBAD		;BAD COMMAND
	HRLZM T2,FMT		;SAVE FORMAT
	HLRZM T2,SIZ		;SAVE SIZE
	HRRZ T2,MTSZMT(T1)	;GET THE SIZE PER WORD
	MOVEM T2,CNT		;SAVE THIS ALSO

MSCSI1:	CALL GETBUF		;GET A PACKET BUFFER FROM SCA
	 JRST QUEPAK		;NONE AVAILABLE, TRY LATER
	TXZE Q1,US.BOT		;CHECK FOR BOT
	TXNN Q3,OP.DEN		;SET DENSITY?
	TDZA P6,P6		;READ OR NOT BOT THEREFORE NO SET OF DENSITY
	JRST SETDEN		;SET DENSITY OF TAPE
	MOVEM Q1,UDBSTS(P3)	;RESTORE UDB STATE WITHOUT BOT
	HRRZ T1,Q3		;OPCODE
	TXNE Q3,OP.CHK		;VALIDITY CHECK AFTER OPERATION?
	TXO T1,MD.CMP		;YES, LET THE HSC DO THE COMPARE
	CAIN T1,OP.AVL		;CHECK FOR AVAILABLE
	TXO T1,MD.UNL		;SET UNLOAD MODIFIER
	TXNE Q3,OP.REV		;REVERSE DIRECTION (TAPE)?
	TXO T1,MD.REV		;YES
	TXNE Q3,OP.REW		;REWIND?
	TXO T1,MD.RWD!MD.IMM	;YES AND SET IMMEDIATE MODE
	TXNE Q1,US.TAP		;CHECK FOR TAPE
	TXO T1,MD.CSE		;CLEAR SERIOUS EXCEPTION
	CALL REVFUL		;REVERSE THE BYTES SO THE HSC WILL UNDERSTAND
	MOVEM T1,P.OPCD(Q2)	;SAVE OPERATION
	CALL GETBHD		;GET A BUFFER HEADER DESCRIPTOR
	 JRST RBFQUE		;NONE, QUEUE THE REQUEST
	MOVE Q1,T2		;Q1=BHD ADDRESS
	SETZM .BHBSA(Q1)	;IN CASE WE HAVE TO RETURN THE BHD
MSCSI3:	MOVEI T2,1B31
	ADDB T2,CRFNUM		;UPDATE COMMAND REFERENCE NUMBER
	TLZE T2,-1		;MAKE SURE LH STAYS 0 (NON-0 IS A FLAG)
	MOVEI T2,1B31		;INSURE WE DON'T GET COMMAND REF OF 0
	MOVEM T2,CRFNUM
	HRRZS T3,T1		;GET BDTTAB INDEX
	LSH T3,-BHDSHF		;CONVERT TO "REAL" INDEX
	IMULI T3,QORLEN		;COMPUTE INDEX INTO QOR TABLE
	ADDI T3,QORTAB		;COMPUTE TABLE ADDRESS

MSCSI4:	MOVEM T2,P.CRF(Q2)	;SAVE COMMAND REF NUMBER IN PACKET
	MOVEM T2,QORCRF(T3)	;SAVE COMMAND REFERENCE NUMBER
	MOVEM P4,QORIRB(T3)	;SAVE IORB ADDR
	HRLM P3,QORUNI(T3)	;SAVE UDB ADDRESS IN QOR
	LSH T1,^D35-BHPIDX	;POSITION INDEX
	LSH T2,^D35-BHPKEY-4	;POSITION IT IN KEY FIELD
	TDO T1,T2		;T1 = BUFFER NAME
	MOVEM T1,QORBHD(T3)	;SAVE NAME IN THE BHD FOR ERROR RECOVERY
	CALL SRVFUL		;REVERSE IT SO THE KLIPA WILL HANDLE IT RIGHT
	MOVEM T1,P.BUFF+1(Q2)	;STORE IN MSCP PACKET
	TXO T2,BH.VAL		;KEY + VALID
	HLRZ T4,UDBKDB(P3)	;FIND THE INDEX
	MOVE T4,CIDATA(T4)
	TXNN T4,DT.KL		;IF KL WE DON'T NEED PRESERVE
	TXO T2,BH.PRE		;SET PRESERVE
	TXNE Q3,OP.RDB		;READ
	TXO T2,BH.WRT		;WRITABLE
	SKIPG Q3
	MOVEM T2,.BHKEY(Q1)	;WHERE THE PORT WANTS TO SEE IT
	HLRZ T1,.SBQOR(P2)	;END OF LIST
	HRLM T1,QORLNK(T3)	;SAVE BACK-POINTER OF NEW END
	HRRM T3,QORLNK(T1)	;SAVE FORWARD-POINTER OF PREVIOUS END
	HRLM T3,.SBQOR(P2)	;SAVE END OF QUEUE POINTER IN HEAD
	MOVEI T1,.SBQOR(P2)	;POINT FORWARD LINK OF THIS PACKET
	HRRM T1,QORLNK(T3)	; BACK AT THE SYSTEM BLOCK
	JUMPG Q3,MSCSI7		;GO IF NON-DATA OPERATION
	CALL PHYXFL		;T1=START OF IO LIST, T2=END
	SETZM MRW1		;INITIALIZE COUNT OF NIBBLES TO TRANSFER
	MOVE T3,T1		;START OF LIST
	SUB T1,T2
	HRL T3,T1		;AOBJN WORD FOR CCWS
	MOVEI T4,.BHBSA-.BSNXT(Q1)

MSCSI6:	CALL GETBSD		;GET A BSD
	 JRST RBDQUE
	MOVEM T1,.BSNXT(T4)	;POINT PREVIOUS BSD AT THIS ONE
	MOVE T4,T1
	LOAD T2,CHCNT,(T3)	;WORD COUNT
	IMUL T2,CNT		;CONVERT TO NIBBLES (4 BITS)
	ADDM T2,MRW1		;ACCUMULATE
	MOVEM T2,.BSLEN(T1)	;AND STORE IN BSD
	SETZM .BSNXT(T1)	;ASSUME WE'RE AT THE END OF CCWS
	LOAD T2,CHADR,(T3)	;GET PHYSICAL ADDRESS OF CCW
	TDO T2,FMT		;DENSITY MODE
	MOVEM T2,.BSADR(T1)	;SAVE WHERE PORT WANTS TO SEE IT
	AOBJN T3,MSCSI6		;LOOP FOR ALL CCWS
	MOVE T1,MRW1		;RESTORE TOTAL NIBBLE COUNT
	MOVEM T1,.BHLEN(Q1)	;CONVERT IT FOR HSC - DIVIDE BY 2 TO GET BYTES,
	TRZE T1,1		;CHECK FOR AN EXTRA NIBBLE
	JRST [	ADDI T1,2	;ADD AN EXTRA NIBBLE IF THERE IS ONE
		LSH T1,3	;AND MAKE UP THE 32 BIT COUNT
		CALL REVFUL	;REVERSE IT FOR THE HSC
		MOVEM T1,P.BCNT(Q2) ;AND STORE IN THE PACKET
		CALL GETBSD	;GET AN EXTRA BSD
		JRST RBDQUE	;OOPS SORRY CAN'T DO THE XFER
		MOVEM T1,.BSNXT(T4) ;STORE THE FORWARD POINTER
		MOVEI T2,1	;MAKE IT 1 NIBBLE LONG
		MOVEM T2,.BSLEN(T1)
		SETZM .BSNXT(T1) ;ZERO FORWARD POINTER
		MAP T2,.BSLEN(T1) ;WHERE TO PUT THE EXTRA BYTE
		TLZ T2,777760	;MASK OFF THE JUNK BITS
		TDO T2,FMT	;SET THE FORMAT
		MOVEM T2,.BSADR(T1) ;STORE THE ADDRESS
		JRST MSCS6A]	;AND JOIN COMMON CODE
	LSH T1,3		; POSITION IT IN 32 BITS
	CALL REVFUL		;REVERSE IT SO THE HSC CAN GET THE RIGHT NUMBER
	MOVEM T1,P.BCNT(Q2)	;WHERE HSC-50 WANTS TO SEE IT
MSCS6A:	MOVX T1,US.DSK
	TDNN T1,UDBSTS(P3)	;IS THIS A TAPE?
	JRST MSCSIT		;YES. THERE IS NO ASSOCIATED LBN
	CALL PHYBLK		;DISK. GET LBN TO WRITE
	MOVE T1,T2
	TXZ T2,IRBPAD		;TURN OFF PHYSICAL ADDRESSING BIT FOR PS1,PS2
	MOVE T3,UDBSIZ(P3)	;POINTER TO SIZE TABLES
	IDIV T2,SECCYL(T3)	;COMPUTE CYLINDER, SECTOR IN CYLINDER
	MOVEM T2,UDBPS1(P3)	;SAVE FOR THE OUTSIDE WORLD TO SEE
	MOVEM T3,UDBPS2(P3)
	LDB T3,USYTYP		;GET UNIT TYPE
	CAIL T3,.UTNOD		;IS THIS A NODE OR GREATER?
	TXNN T1,IRBPAD		;CHECK FOR PHYSICAL ADDRESSING
	LSH T1,2		;NO MUST FORCE PAGE ADDRESS
	LSH T1,4		;POSITION LBN IN 32 BITS, CONVERT FROM PAGE NUMBER TO SECTOR NUMBER
	CALL REVFUL		;REVERSE IT FOR THE HSC
	MOVEM T1,P.LBN(Q2)	;TELL THE MSCP SERVER
	JRST MSCSI8		;KEEP ON GOING

;HERE IF A NON-DATA OPERATION IS REQUESTED
;THIS IS TAPE POSITIONING COMMANDS ETC
;
MSCSI7:	TXNE Q3,OP.REW		;REWIND?
	JRST [SETZM UDBPS1(P3)	;YES, CLEAR POSITION WORDS
		SETZM UDBPS2(P3)
		JRST MSCSI8]	;AND CARRY ON
	MOVEI T1,20		;NO, SPACE 1 RECORD
	CALL REVFUL		;SWITCH THE BITS FOR THE HSC
	MOVEM T1,P.TMGC(Q2)	;SAVE HOW MANY RECORDS TO DO

; HERE TO SEND A DATA OR POSITION REQUEST TO THE HSC

MSCSI8:	MOVE T1,UDBSLV(P3)	;MSCP UNIT NUMBER
	LSH T1,4		;POSITION IT WHERE THE HSC WANTS IT
	CALL REVFUL		;REVERSE THE BYTES FOR THE HSC
	MOVEM T1,P.UNIT(Q2)	;TELL THE MSCP SERVER
	HLRZ Q1,UDBKDB(P3)	;CID INDEX
	SKIPG MSCCID(Q1)	;LEGAL CONNECT ID?
	JRST RBDQUE		;NO -- ALL GONE REQUEUE
	BLCAL. (SC.DCI,<MSCCID(Q1)>) ;GET THE CONNECT ID
	 JRST [	MOVE T1,MSCCID(Q1) ;GET THE SOURCE CONNECT ID
		CALL SC.NOD	;(T1/T1,T2) GET THE DESTINATION NODE
		BUG.(CHK,MSCIDG,PHYMSC,SOFT,<PHYMSC - Connect ID gone>,<<T2,NODE>,<T1,CID>>,<

Cause:	When the MSCP driver was tyring to send a request to a server, the
	source connect ID disappeared (call to SC.DCI failed).  This appears to
	be a SCAMPI problem.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:  	NODE - destination node number
	CID  - source connect ID
>)
		RET]
	MOVEM T1,P.BUFF+2(Q2)	;TELL THE HSC THE LAST PART OF THE BUFFER NAME
	BLCAL. (SC.SMG,<MSCCID(Q1),[0],[P%LBN],Q2,[MSCPRI],[1],[0]>) ;SEND THE PACKET
				;FLAGS=0, PRIORITY=2, THRESHOLD=1
	 JRST MSCSI9		;ERROR ON THE SEND
	AOS MSCSNT		;[7211] COUNT THE MESSAGE
	RETSKP			;PACKET IS SENT. GOOD RETURN

;HERE ON AN ERROR ON THE SEND. PROBLEM WITH SCA WHEN WE GET HERE WE HAVE LOST
;ON OUR SEND REQUEST. IF IT IS A REFUSAL DUE TO LOSS OF CREDIT THEN WE WILL
;JUST RE-QUEUE THE REQUEST OTHERWISE WE WILL COMPLAIN AND RETURN AN ERROR TO
;PHYSIO.

MSCSI9:	CAIN T1,SCSNEC		;LOSE DUE TO NO CREDIT?
	JRST [	AOS LCRDT
		JRST RBDQUE]	;YES, QUEUE FOR LATER
	CAIN T1,SCSCWS		;WRONG STATE?
	JRST SNDWNS		;YUP WE LOST THIS ONE
	MOVE T3,T1		;MOVE ERROR CODE
	MOVE T1,MSCCID(Q1)	;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(CHK,MSCSDF,PHYMSC,SOFT,<PHYMSC - Send failure>,<<T2,NODE>,<T1,CID>,<T3,ERRCOD>>,<

Cause:	A message sent to SCAMPI failed for reasons other than no credit or
	connection in wrong state.  The send request is retried.  This
	appears to be a SCAMPI problem.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:	NODE   - node number
	CID    - connect ID
	ERRCOD - error code
>)
	JRST RBDQUE		;WAIT A WHILE AND TRY AGAIN

SNDWNS:	MOVE T3,T1		;MOVE ERROR CODE
	MOVE T1,MSCCID(Q1)	;GET THE CONNECT INFORMATION
	CALL SC.NOD		;(T1/T1,T2) GET THE NODE NUMBER FOR THE CONNECTION
	BUG.(CHK,MSCSCW,PHYMSC,SOFT,<PHYMSC - Send found wrong connect state>,<<T2,NODE>,<T1,CID>,<T3,ERRCOD>>,<

Cause:	The state of the connection is incorrect for the connect state.
	Previous states should have caught this unless the state changed during
	the send.  The send should have been done with the channel off.  The
	send is tried again.  This appears to be a SCAMPI problem.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:	NODE   - node number
	CID    - connect ID
	ERRCOD - error code

>)
	SETOM MSCCID(Q1)	;CLEAR OUT THE CONNECT STATUS SO WE DON'T DO IT AGAIN
	MOVX T1,DT.GAW
	IORM T1,CIDATA(Q1)
	CALL PHYOFL		;OFLINE THE DAMN THING BEFORE IT TRYS AGAIN
	JRST RBDQUE		;AND RE-QUEUE THIS REQUEST

MSCSIT:	MOVE T1,IRBCNT(P4)	;GET THE COUNT OF THE BYTES
	LOAD T2,IRBDM,(P4)	;GET MODE
	HLRZ T3,MODTBL(T2)	;GET BYTES
	IMULI T1,(T3)		;NUMBER OF BYTES
	LSH T1,4		;PUT IN 32 BITS
	CALL REVFUL
	MOVEM T1,P.BCNT(Q2)	;STORE COUNT
	JRST MSCSI8		;RETURN TO COMMON CODE

COMBAD:	MOVX T1,IS.ERR!IS.NRT!IS.DVE
	IORM T1,IRBSTS(P4)
	RET			;RETURN BAD WITH ERRORS

;
; ROUTINE TO SET THE DENSITY OF THE TAPE DRIVE. THIS IS ONLY
; EXECUTED AT BOT
;
SETDEN:	LOAD T1,IRBDN,(P4)	;GET DENSITY
	CAIL T1,4		;CHECK DENSITY HERE TOO
	CAILE T1,5		;LEGAL DENSITY
	JRST COMBAD		;NO BAD DENSITY
	HLRZ T1,MTSZMT(T1)	;GET NEW DENSITY
	CALL REVFUL		;REVERSE BITS
	MOVEM T1,P.FORM(Q2)	;SET FORMAT
	SETZM P.UNFL(Q2)	;SET NO FLAGS
	MOVEI T3,P%NREC		;SIZE OF BLOCK
	MOVX T2,OP.SUC!MD.CSE	;SET OPCODE TO SET UNIT CHARACTERISTICS
	SETO P6,0		;NO RETURN REQUIRED
	HRRZ T1,UDBSLV(P3)	;UNIT NUMBER
	HLRZ Q3,UDBKDB(P3)	;GET THE SID OFFSET
	CALL SENDPK		;SEND THE PACKET
	JRST MSCSI9
	MOVX T1,US.BOT		;CLEAR BOT FLAG
	ANDCAM T1,UDBSTS(P3)
	JRST MSCRIO		;DO REAL TRANSFTER NEXT
	ENDSV.
	SUBTTL General Purpose Packet Routines

;HERE TO UNLINK THE QOR, RETURN THE BHD/BSDS AND REQUEUE
;RBDQUE
; CALL P2/KDB
; Q2 PACKET ADDRESS
; P6=-1 NO BHD TO REQUEUE
;
; RETURNS +2 ALWAYS THIS IS DONE TO SATISFY START I/O SUCCESS RETURN
;
; THIS ROUTINE RETURNS THE BHD/BSD, QOR AND BUFFERS.  IT THEN
; REMOVES AN ENTRY FROM THE TRANSFER WAIT QUEUE AND PUTS IT
; ON THE POSITION WAIT QUEUE AND INDICATES THAT A TRANSFER
; IS NOW WAITING FOR A REQUEUE.
RBDQUE:	JUMPL P6,RBFQUE		;REQUE PACKET ONLY
	HLRZ Q1,.SBQOR(P2)	;GET ADDR OF QOR (LAST ENTRY ON QUEUE)
	SKIPE T1,QORBHD(Q1)	;FIND THE BHD IF THERE IS ONE
	CALL RTNBHX		;RETURN THE BHX
	CALL ULKQOR		;UNLINK THE QOR

;HERE TO RETURN THE PACKET BUFFER AND REQUEUE
RBFQUE:	CALL RTNBUF		;GIVE THE BUFFER BACK TO SCA

;HERE TO QUEUE THE IORB FOR LATER
QUEPAK:
QUEIRB:	CALL OFFTWQ		;PULL IORB FROM TWQ
	CAMN T1,UDBCHB(P3)	;IS THIS HOMEBLOCK?
	JRST [	CALL CLRCHB	;CLEAR HOMEBLOCK REQUEST
		JRST QUEHBK]	;AND RETURN TO CODE
	CALL ONPWQ		; AND PUT IT ONTO THE PWQ
QUEHBK:	SETOM QUEREQ		;INDICATE REQUEST RE-QUEUE'D
	HRRZS P1
	RETSKP			;TELL PHYSIO ALL IS WELL


;ROUTINE TO RETURN A BUFFER TO SCA
;CALL Q2/BUFFER ADDR
; THIS ROUTINE ASSUMES THAT WHEN THE BUFFER WAS ALLOCATED THE
; TOP OF THE BUFFER POINTS TO THE RETURN ADDRESS.  SINCE
; PHYMSC ALWAYS USES GETBUF THIS IS A GOOD ASSUMPTION.
;RETURNS +1 ALWAYS
RTNBUF:	SKIPE T1,Q2		;GO AWAY IF BUFFER WAS ALREADY RETURNED
	CALLRET @(Q2)		;RETURN THE PACKET BUFFER
	RET
;ROUTINE TO RETURN THE BHD, BSDS ASSOCIATED WITH A PACKET
;CALL:	Q2=ADDRESS OF PACKET BUFFER
;CALL RTNBHX WITH T1 = BUFFER NAME (IN CORRECT ORDER)
RTNBHX:	CALL GIVBHD		;RETURN THE BHD/BDT
	SKIPA T3,T2		;POINT T3 AT 1ST BSD
RTNBH1:	CALL GIVBSD		;RETURN THE BSD
	SKIPN T1,T3		;IS THERE A BSD?
	RET			;NO. WE'RE DONE
	MOVE T3,.BSNXT(T1)	;YES. PRESERVE ITS LINK
	JRST RTNBH1		;AND GIVE IT BACK


;ROUTINE TO GET A BUFFER FROM SCA
;CALL CALL GETBUF
;RETURN +1 IF NO BUFFERS AVAILABLE
;RETURN +2 Q2/ADDRESS OF BUFFER AND ADDRESS OF RETURN ROUTINE ON
;			THE FIRST ENTRY OF THE BUFFER
GETBUF::MOVEI T1,1
	CALL SC.ABF		;GET A PACKET BUFFER
	 RET			;NONE AVAILABLE
	MOVE Q2,T1		;SAVE ITS ADDRESS
	MOVEM T3,(Q2)		;SAVE WHERE TO RETURN THE BUFFER IF WE DON'T USE IT
	RETSKP			;GOOD RETURN

	SUBTTL Interrupt Service

;CALL WITH T1-T4 HAVING STATUS INFORMATION PROVIDED BY SCAMPI
;THIS CODE IS ENTERED AT INTERRUPT LEVEL AND A RETURN
;WILL EVENTUALLY EXIT THRU THE KLIPA INTERRUPT ROUTINE.
;WE ARE ENTERED HERE IN RESPONSE TO SOME ACTION ON THE
;CI THAT WE MUST ATTEND.

INTRPT:	SAVEPQ
	CAIG T1,INTRLG		;CHECK FOR LEGAL DISPATCHES
	JUMPGE T1,@DISPCH(T1)
	BUG.(HLT,MSCILD,PHYMSC,SOFT,<PHYMSC - Illegal dispatch from SCAMPI>,<<T1,CODE>>,<

Cause:	PHYMSC was called by SCAMPI with an illegal dispatch value (less than
	zero or greater than INTRLG).  This appears to be a SCAMPI problem.

Data:	CODE - Dispatch value
>)

DISPCH:	MSEC1,,DGREC		;.SSDGR - Datagram received
	MSEC1,,MSGREC		;.SSMGR - Message received
	MSEC1,,PBRCON		;.SSPBC - Port broke connection
	MSEC1,,R		;.SSCTL - Connect to listen
	MSEC1,,CNRAVL		;.SSCRA - Connect response available
	MSEC1,,R		;.SSMSC - Message/datagram send complete
	MSEC1,,R		;.SSDDG - Datagram dropped
	MSEC1,,R		;.SSLCL - Little credit left
	MSEC1,,MSCONL		;.SSNCO - Node came online
	MSEC1,,R		;.SSOSD - OK to send data
	MSEC1,,DSCREQ		;.SSRID - Remote initiated disconnect
	MSEC1,,MSCCIA		;.SSCIA - Credit is available
	MSEC1,,R		;.SSDMA - DMA complete
INTRLG==.-DISPCH-1

;
DSCREQ:	LOAD T1,SID,T2		;GET INDEX
	SKIPG MSCCID(T1)	;VALID CONNECT ID?
	RET			;FORGET IT
	MOVE T1,T2		;GET CID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(INF,MSCDSR,PHYMSC,SOFT,<PHYMSC - Disconnect request by remote node>,<<T2,NODE>,<T1,CID>,<T3,REASON>>,<

Cause:	The remote node has disconnected, the remote node has probably timed
	out on some operation to the MSCP driver.  All drives connected to the
	node are put offline.

Action:	No action is required, this bug is informational only.  The remote node
	might indicate why it disconnected.

Data:	NODE   - node number
	CID    - connect ID
	REASON - reason for disconnect
>,,<DB%NND>)			;[7.1210] 
	MOVE T2,T1		;REPOSITION CID
	LOAD Q3,SID,T2		;GET INDEX AGAIN
	MOVX T3,DT.DIS		;INDICATE DISCONNECTED
	IORM T3,CIDATA(Q3)	;SET IN STATUS
	CALL PBRCOA		;PUT IT OFFLINE
	SETOM MSCCID(Q3)
	RET			;RETURN

;HERE ON A NODE GOING AWAY (PORT BROKE CONNECTION)
;ENTER WITH T2=CONNECT ID OR -1 IF THIS IS AN EXTRANEOUS CALLBACK
;WE WILL SET THE DATABASE FLAGS IN MSCCID AND CIDATA TO INDICATE
;THAT WE HAVE LOST THE CONNECTION.  WE THEN DECLARE THE DRIVE
;TO BE OFFLINE AND RE-QUEUE ALL THE REQUESTS.
;WHEN THE PORT REVIVES THE POLLER SHOULD RECOVER FROM THIS PROBLEM.

PBRCON:	SKIPGE T2		;IS THIS AN EXTRA CALLBACK?
	RET			;YES, JUST RETURN
	MOVE T1,T2		;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	SKIPE CIBUGX		;CI DEBUGGING?
	BUG.(INF,MSCPTG,PHYMSC,SOFT,<PHYMSC - port went away>,<<T2,NODE>,<T1,CID>>,<

Cause:	The remote node has dropped the connection.  All drives connected to
	the node are put offline.

Action:	No action is required, this bug is informational only.

Data:	NODE - node number
	CID  - connect ID
>,,<DB%NND>)			;[7.1210] 
	MOVE T2,T1		;REPOSITION CID

NODBYE:	CALL FNDNDX		;SET UP MSCCID INDEX, CB ADDR
	JRST [ MOVX T2,DT.KEP	;CLEAR STATUS
	       ANDM T2,CIDATA(T1)
	       RET]		;AND QUIT
	SETOM MSCCID(T1)	;INDICATE WE ARE GONE
	MOVX T4,DT.KEP		;INDICATE DISCONNECT
	ANDM T4,CIDATA(T1)
	JRST PBRCOB		;JUMP FINISH OFFLINE

PBRCOA:	CALL FNDNDX
	JFCL			;THIS GUY BETTER NOT LOOSE...
	MOVX T3,DT.GAW		;INDICATE GONE AWAY
	IORM T3,CIDATA(T1)
PBRCOB:	SAVEP
	MOVE T1,.CBSBA(T2)	;POINT AT SB
	MOVE P1,KDBIUN(T1)	;POINT AT UNIT LIST
PBRCO1:	SKIPN P3,(P1)		;UNIT THERE?
	JRST PBRCO2		;NO
PBRC11:	CALL PHYOFL		;YES. TELL THE WORLD IT'S OFF LINE
	MOVX T1,UA.PAT		;THIS PORT IS NO LONGER ATTACHED
	ANDCAM T1,UDBALT(P3)
PBRCO2:	AOBJN P1,PBRCO1
	RET


;HERE ON A NODE COMING ONLINE
; WHEN A NODE COMES ONLINE WE MUST FIRST SEE IF THERE IS
; A FREE SLOT TO USE FOR A CONNECT ID.  AFTER THIS WE THEN
; GO THRU THE INIT CODE ATTEMPTING TO PUT THIS SPECIFIC
; UNIT ONLINE.
;T2 = INDEX INTO SB TABLE OF NODE

MSCONL:	HRRO Q1,T2		;SB INDEX INTO A MORE PERMANENT AC
	CALL FNDSLT		;FIND AN OPEN SLOT TO USE FOR THIS CONNECT
	 RET			;LOST ALL FULL
	CALLRET MSCIN1		;BUILD UDBS FOR THE UNITS

;HERE ON A CONNECTION RESPONSE AVAILABLE
; WHEN WE GET A CONNECT RESPONSE AVAILABLE IT IS IN RESPONSE TO A
; CONNECT THAT WE HAVE ISSUED.  WE FIRST CHECK TO SEE IF THE NODE
; WAS REALLY ONE THAT WE REALLY REQUESTED.  IF NOT THEN SCAMPI
; IS REALLY CONFUSED.  WHEN WE FIND WHICH ONE IT IS WE CAN THEN
; DETERMINE IF THE REQUEST WAS OK.  IF SO THEN IT IS LEGAL TO
; START TRAFFIC WITH THIS NODE.  IF NOT THEN WE FLAG THE NODE
; AS GONE AND FORGET ABOUT IT SINCE IT REALLY DIDN'T LIKE US.
;	T2=CONNECT ID
;	T3=-1 IF ACCEPTED,, 0 IF REJECTED
;	IF REJECTED T4= REASON CODE

CNRAVL:	LOAD Q3,SID,T2		;WHICH NODE IS THIS TALKING ABOUT
	JUMPE T3,CRNAV1		;CHECK TO SEE IF REJECTED
	SKIPG T2		;DID WE GET A VALID CID?
	 BUG.(HLT,MSCBID,PHYMSC,SOFT,<PHYMSC - bad connect ID from SCAMPI>,<<T2,CID>>,<

Cause:	A connect response available occurred and a negative or zero Connect ID
	was returned from SCA.  This indicates a SCAMPI problem.

Data:	CID - connect ID
>)
	CAME T2,MSCOLD(Q3)	;MATCH?
	JRST CNRREJ		;WE ALREADY KNOW ABOUT YOU??
	SETO T1,0
	CAMN T1,MSCCID(Q3)	;[8913] Coming online (waiting for this one?)
	IFSKP.			;[8913] No
CNRREJ:	  MOVE T1,T2		;GET CONNECT ID
	  CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	  BUG.(CHK,MSCNRA,PHYMSC,SOFT,<PHYMSC - Node response available when not requested>,<<T2,NODE>,<T1,CID>>,<

Cause:	A connect response available occurred on a node that isn't expected to
	have an available happen.  This could be a SCAMPI or PHYMSC problem.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:	NODE - node number
	CID  - connect ID

>,R)
	ENDIF.

	MOVEM T2,MSCCID(Q3)	;SAVE CONNECT ID
	MOVEM T2,MSCOLD(Q3)	;SAVE IT FOR DISCONNECT
CRNAV1:	MOVX T1,DT.KEP		;CLEAR STATUS
	ANDM T1,CIDATA(Q3)
	JUMPN T3,MSCIN5		;CONTINUE CONNECT INIT PROCESS
	MOVE T1,T2		;SAVE CONNECT ID
	MOVX T2,DT.GAW		;INDICATE WE DIDN'T GET THIS ONE
	IORM T2,CIDATA(Q3)
	SETOM MSCCID(Q3)	;INDICATE NOW UNUSED
	CAIN T4,.CMCNM		;CHECK FOR NO MATCH
	RET
	SKIPN CIBUGX		;[7191] ARE WE IN DEBUGGING MODE?
	RET			;[7191] NO, THEN DON'T SCARE THE OPERATOR
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(INF,MSCREJ,PHYMSC,SOFT,<PHYMSC - Node connection reject>,<<T2,NODE>,<T1,CID>>,<

Cause:	A connection response available was rejected.  The node cannot be
	reached.  The MSCP server on another TOPS-20 system rejects all
	connections until that system has joined the CFS cluster.

Action:	No action is required, this bug is for information only.

Data:	NODE - node number
	CID  - connect ID
>,R,<DB%NND>)			;[7.1210]

;ROUTINE TO SEARCH FOR MATCHING CONNECT ID
;ENTER T2/CONNECT ID
;	NON-SKIP RETURN IF NO MATCH
;	SKIP RETURN IF MATCH WITH T1/MSCCID INDEX, T2/CB ADDRESS
;PRESERVES T3, T4
FNDNDX:	SKIPN T2		;CHECK FOR BROKEN SCAMPI
MSNGID:	BUG.(CHK,MSCMID,PHYMSC,SOFT,<PHYMSC - Missing connect ID>,,<

Cause:	There is a missing or zero connect ID on call to FNDNDX.  This has to
	be a SCAMPI problem.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.
>)
	LOAD T1,SID,T2		;GET THE OFFSET INTO THE MSCCID TABLE
	CAME T2,MSCCID(T1)	;CHECK FOR CORRECT CONNECT ID
	RET			;NOPE THIS IS AN OLD ONE
	$LDCID T2,T2		;FOUND A MATCH FIND CB ADDRESS
	RETSKP			;RETURN


;ROUTINE TO SEARCH FOR AN OPEN OR UNUSED SLOT FOR CONNECT ID'S
;ENTER: Q1 = SBI COMING ON LINE
;RETURNS: Q3 = INDEX INTO MSCCID FOR NEW SLOT
;	RETURNS +1 ENTRY ALREADY IN USE
;	RETURNS +2 ALL OK

FNDSLT:	MOVE Q3,Q1		;SET UP Q3
	SKIPG T1,MSCCID(Q3)	;SEE IF THIS ENTRY IS FREE
	RETSKP			;YES
	MOVX T1,DT.GAW		;YES CHECK TO SEE IF REALLY GONE
	TDNE T1,CIDATA(Q3)	;HERE?
	RETSKP
	MOVE T1,MSCCID(Q3)	;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(CHK,MSCAOL,PHYMSC,SOFT,<PHYMSC - Online node event while node already online>,<<T2,NODE>,<T1,CID>,<Q1,SBI>>,<

Cause:	SCAMPI told us that this node was coming back on line but we think that
	it is already online.  We believe SCAMPI and put it online.  This is
	commonly seen from the HSC.

Action:	No action is required.  However, if this bug occurs often or is
	reproducible, change it to a BUGHLT and submit an SPR along with a dump
	and instructions on reproducing it.

Data:	NODE - node number
	CID  - connect ID
	SBI  - system block index
>,R,<DB%NND>)			;[7.1210]
;HERE ON MESSAGE RECEIVED.
;WHEN WE GET HERE WE HAVE RECEIVED A MESSAGE FROM A NODE THAT
;WE ARE CONNECTED TO.  WE MUST DETERMINE THE TYPE OF THE
;MESSAGE AND THEN DECIDE WHAT FUNCTION TO PERFORM.  WE
;CHECK TO SEE THAT THE MESSAGE IS REALLY ONE FOR WHICH WE
;HAVE A CONNECT ID.  AFTER THAT WE CHECK TO SEE IF IT IS A
;MESSAGE THAT WAS INITIATED OR AN END PACKET (RESPONSE)
;TO A REQUEST THAT WE HAVE MADE.  IF IT WAS A REQUEST THAT
;WE MADE THE LEFT HALF OF THE COMMAND REFERENCE NUMBER IS
;AN INDICATOR OF WHICH ROUTINE HANDLES THE COMPLETION OF
;THIS TYPE OF MESSAGE.  IF THE COMMAND REFERENCE LEFT HALF
;IS -1 THEN THE REQUESTOR DOES NOT NEED TO DO ANYTHING
;ON THE COMPLETION OF THE COMMAND.
;	ENTER WITH:	T1/ .SSMGR
;			T2/ CONNECT ID
;			T3/ ADDRESS OF MESSAGE BUFFER
;			T4/ FLAGS AND ADDRESS OF ROUTINE TO RETURN BUFFER

MSGREC:	AOS MSCRCV		;[7211] COUNT THE MESSAGES
	TLZ T4,770000		;[7211] REMOVE FLAG BITS
	MOVEM T4,(T3)		;SAVE BUFFER-RETURN ADDRESS IN BUFFER
	MOVE Q2,T3		;Q2=BUFFER ADDR
	MOVE P5,T2		;SAVE CONNECT ID IN CASE WE NEED IT
	CALL FNDNDX		;FIND MSCCID INDEX
	JRST RTNBUF		;NONE FOUND RETURN BUFFER AND QUIT
	MOVE Q3,T1		;SET IT IN Q3
	$LDCID P2,P5		;GET CONNECTION BLOCK ADDRESS
	MOVE P2,.CBSBA(P2)	;SYSTEM BLOCK (KDB)
	MOVE P1,.SBACD(P2)	;CDB
	CALL REVSTS		;MAKE THE BITS UNDERSTANDABLE
	LOAD T1,PKYECD,(Q2)	;GET ENDCODE
	TRZE T1,OP%AVA		;AVAILABLE?
	JRST MSGAVA		;YES. GO HANDLE IT
	TRZN T1,OP%END		;REASONABLE?
	JRST MSGRC8		;NO. THE SERVER BLEW IT
	CAIN T1,OP%ABO		;AN ABORT END PACKET?
	CALLRET RTNBUF		;YES. NOTHING NEEDS TO BE DONE
	MOVE T2,P.CRF(Q2)	;COMMAND REFERENCE NUMBER
	ASH T2,-4		;RIGHT ADJUST IT IN 36 BITS
	TLNN T2,-1		;LH NON-0?
	JRST MSGRC2		;NO, REGULAR MESSAGE
	CAIL T1,OP%GCS		;YES. IS IT A REASONABLE END CODE?
	CAILE T1,OP%SUC
	JRST MSGRC8		;NO. THE SERVER SCREWED UP
	CAIN T1,OP%SUC		;CHECK FOR SET UNIT CHAR'S
	JRST TAPSUC		;YES MUST BE A TAPE
	HLRZ T2,T2		;FIND THE COMMAND REQUEST
	CAIN T2,-1		;CHECK FOR -1 (ALL DONE)
	CALLRET RTNBUF		;DONE RETURN FROM INTERRUPT
	CAME T1,CMDTBL(T2)	;CHECK TO SEE THAT IT IS CONSISTENT
	JRST BROKE		;NO NOT REALLY

; AT THIS POINT P2= KDB,T1= END CODE, T2= FUNCTION DISPATCH
; Q2 = PACKET ADDRESS, Q3 = CONNECT ID INDEX
; WHEN WE GET HERE WE HAVE CHECKED THE CONSISTENCY OF THE
; COMMAND REFERENCE NUMBER BY CHECKING THE END CODE AGAINST
; THE LEFT HALF OF THE ENDCODE.  WE NOW GO TO THE ROUTINE
; THAT WAS REQUESTED ON COMPLETION OF THE REQUESTED SERVER
; FUNCTION.

	JRST @CMDJMP(T2)

BROKE: 	DMOVE T3,T1	;MOVE ENDCODE AND FUNCTION CODE
	MOVE T1,P5	;GET CONNECT ID
	CALL SC.NOD	;(T1/T1,T2)  AND NODE NUMBER
	BUG.(CHK,MSCBCN,PHYMSC,SOFT,<PHYMSC - Command reference number bad>,<<T2,NODE>,<T1,CID>,<T3,ENDCODE>,<T4,FUNCTION>>,<

Cause:	The command reference number is invalid.  This is an MSCP protocol
	problem.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:	NODE	 - node number
	CID	 - connect ID
	ENDCODE  - packet end code
	FUNCTION - command request

>)
	CALLRET RTNBUF		;QUIT THIS ONE IS JUNK

TAPSUC:	LOAD T3,PKYEST,(Q2)	;GET STATUS
	JUMPE T3,RTNBUF		;ALL OK
	MOVE T1,P5
	CALL SC.NOD		;GET NODE NUMBER
	BUG.(INF,MSCSUF,PHYMSC,SOFT,<PHYMSC - Set density failed>,<<T2,NODE>,<T1,CID>,<3,CODE>>,<

Cause:	The set unit characteristics command failed for a tape drive.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:	NODE - Node number
	CID - Connect ID
	CODE - Status code
>)
	JRST RTNBUF		;RETURN BUFFER
;WHEN WE GET HERE WE HAVE RECEIVED A RESPONSE TO A DATA TRANSFER
;MESSAGE.  THE ONLY REQUESTS THAT HAVE A LEFT HALF COMMAND REFERENCE
;NUMBER OF ZERO ARE DATA FUNCTIONS TO THE SERVER.  WE MUST NOW PROCEED TO
;SERVICE THE COMPLETION OF THE DATA REQUEST BY CLEANING UP THE
;DATA BASE AND CHECKING FOR THE STATUS OF THE TRANSFER REQUEST.

MSGRC2:	CAIG T1,OP%GUS		;"REAL" MESSAGE?
	JRST RTNBFX		;NO. RETURN THE BUFFER AND EXIT
MSGRC3:	HRRZ Q1,.SBQOR(P2)	;START AT 1ST QOR ON THE SYSTEM BLOCK
	MOVE T2,P.CRF(Q2)	;WE'RE LOOKING FOR THIS COMMAND REFERENCE NUMBER
MSGRC4:	CAMN T2,QORCRF(Q1)	;MATCH?
	JRST MSGRC5		;YES
	HRRZ Q1,QORLNK(Q1)	;NO, STEP TO NEXT
	CAIE Q1,.SBQOR(P2)	;ARE WE AT THE END OF THE QORS?
	JUMPN Q1, MSGRC4	;NO, TEST THIS ONE
				;IF Q1 IS 0 THEN TABLE IS CLOBBERED!

RTNBFX:	DMOVE T3,T1		;MOVE ENDCODE AND COMMAND REFERENCE NUMBER
	MOVE T1,P5		;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	JUMPE Q1,[BUG.(CHK,MSCQRC,PHYMSC,SOFT,<PHYMSC - QOR list clobbered>,<<T2,NODE>,<P2,KONT>,<T4,CRN>>,<

Cause:	The QOR (the link between MSCP commands and IORBs) list has been
	clobbered and has a 0 in it.  This indicates a PHYMSC problem.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:	NODE - Node number
	KONT - Controller number
	CRN - Command reference number
>,RTNBUF)]
	BUG.(CHK,MSCBPK,PHYMSC,SOFT,<PHYMSC - QOR bad packet>,<<T2,NODE>,<T1,CID>,<T3,ENDCODE>,<T4,CRN>>,<

Cause:	The HSC sent a packet whose command reference number can't be found.
	The packet is ignored.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:	NODE - node number
	CID - connect ID
	ENDCODE - packet end code
	CRN - Command reference number
>,,<DB%NND>)			;[7.1210] 
	CALLRET RTNBUF		;RETURN THE PACKET AND EXIT
;HERE WITH Q1 POINTING AT THE QOR FOR THE PACKET WE JUST REC'D
MSGRC5:	SKIPN T1,QORBHD(Q1)	;RETURN THE BHD IF THERE IS ONE
	JRST MSGR5A		;NO BHD
	LDB T3,[POINT BHSIDX,T1,BHPIDX] ;GET INDEX INTO BUFFER DESCRIPTOR TABLE
	ADD T3,BHDIPT		;POINT AT ENTRY
	MOVX T2,BH.ERR		;ERROR
	TDNE T2,(T3)		;IS THE ERROR BIT SET?
	BUG.(HLT,MSCBHE,PHYMSC,SOFT,<PHYMSC - BHD error bit set>,,<

Cause:	The BHD error bit was set.  This implies that the BSD had the wrong
	length.  Something is inconsistent in the state or too much data was
	sent.
>)
	SETZM 0(T3)		;CLEAR FLAGS WORD
	CALL RTNBHX
MSGR5A:	HRRZ P4,QORIRB(Q1)	;POINT P4 AT IORB
	HLRZ P3,QORUNI(Q1)	;GET UDB ADDRESS
	HRRZ T1,.SBQOR(P2)	;OLDEST QOR (COMMAND) OUTSTANDING
	CAIE T1,(Q1)		;IS THIS THAT QOR?
	JRST MSGRC6		;NO
	HLRZ T1,UDBKDB(P3)	;YES. SET NEW COMMAND STATUS
	HRLOI T2,377777		; TO INFINITY FOR NEXT GCS
	MOVEM T2,CICMST(T1)
;
;AT THIS POINT THE UDB (P3) MAY BE WRONG.  THIS IS BECAUSE
;THE I/O REQUEST MAY HAVE BEEN REQUEUE'D AND QORUNI WAS
;NOT FIXED UP WHEN THE REQUEST WAS MOVED BY PHYSIO FROM
;ONE UDB TO THE ALTERNATE UDB THIS IS WHY WE CHECK HERE
;FOR THE OTHER PORT ACTIVE.
;
MSGRC6:	CALL FRONTW		;MOVE THE REQUESTED ITEM TO THE FRONT OF THE QUEUE
	SKIPA			;IT WASN'T HERE
	JRST MSGR6A		;FOUND IT ALL MUST BE OK
	HRRZ P3,UDBALT(P3)	;TRY ALTERNATE
	JUMPE P3,DONE3		;OOPS LOST THE ENTRY
	CALL FRONTW		;TRY TO MOVE THIS ONE TO THE FRONT
	JRST DONE3		;NOT HERE EITHER WELL THEN QUIT

MSGR6A:	CALL ULKQOR		;UNLOCK AND LOOSE THE QOR FOR THIS XFR
	LOAD T1,PKYEST,(Q2)	;STATUS OF UNIT
	CAIE T1,ST%OFL		;OFF LINE?
	CAIN T1,ST%AVL		;AVAILABLE ALSO?
	SKIPA			;YES PUT THE DRIVE OFF-LINE DON'T CAUSE AN ERROR.
	JRST MSGRC7		;NO, CONTINUE
	CALL PHYOFL		;YES, TELL PHYSIO THE UNIT WENT OFF LINE
	MOVE T1,UDBSTR(P3)	;IS THE UNIT IN A STR?
	AOJE T1,ERRDON		;NOT IF UDBSTR=-1. IF SO, JUST RETURN AN ERROR
	MOVX T1,US.OIR		;IN A STR. BITCH AT THE OPERATOR
	IORM T1,UDBSTS(P3)	;SET TO GET THE "PROBLEM ON DEVICE" MESSAGE
	CALLRET RTNBUF		;GIVE BACK THE BUFFER AND RETURN
;
MSGRC7:	LDB T1,IRYFCN		;FUNCTION
	MOVE Q3,MSCFCN(T1)	;GET FUNCTION
	MOVE T1,P.BCNT(Q2)	;GET BYTE COUNT
	CALL REVFUL		;MAKE IT UNDERSTANDABLE
	LSH T1,-4		;RIGHT ADJUST IT
	MOVX T2,US.DSK
	TDNE T2,UDBSTS(P3)	;WHAT FLAVOR OF DEVICE IS THIS?
	JRST DSKEND		;DISK
	JRST TAPEND		;TAPE


;HERE ON A MESSAGE WITH A BAD END CODE

MSGRC8:	MOVE T3,T1		;SAVE ENDCODE
	MOVE T4,P.CRF(Q2)	;MAKE SURE WE HAVE COMMAND REFERENCE NUMBER
	ASH T4,-4		;RIGHT ADJUST IT IN 36 BITS
	MOVE T1,P5		;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(CHK,MSCPEI,PHYMSC,SOFT,<PHYMSC - Packet end code incorrect>,<<T2,NODE>,<T1,CID>,<T3,ENDCODE>,<T4,CRN>>,<

Cause:	The HSC sent a packet that had a bad packet end code.  There may be a
	problem with the HSC or it could be a software problem.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:	NODE    - node number
	CID	- connect ID
	ENDCODE - packet end code
	CRN	- command reference number
>)
	CALLRET RTNBUF		;CHUCK THE PACKET AND EXIT THE INTERRUPT

TAPEND:	MOVE P5,UDBDEN(P3)	;GET DENSITY
	CAIN P5,.SJD16		;1600 BPI (PE MODE)?
	SKIPA P5,P3		;YES, SET TO ACCUMULATE PE FRAMES
	MOVEI P5,1(P3)		;NO, SET TO ACCUMULATE GCR FRAMES
	TXNE Q3,OP.AVL		;AVLOAD?
	JRST TAPDN4
	TXNN Q3,OP.RDB		;READ?
	JRST TAPDN2		;NO
	ADDM T1,UDBRED(P3)	;ACCUMULATE FRAMES READ
	ADDM T1,UDBRPE(P5)	;ACCUMULATE FRAMES READ IN PE/GCR
	LOAD T3,IRBDM,(P4)
	HLRZ T3,MODTBL(T3)	;COMPUTE WORDS READ
	SOJE T3,TAPDN1		;SAVE TIME IF BYTES=FRAMES
	IDIVI T1,1(T3)
	JUMPE T2,TAPDN1		;GO IF AN INTEGRAL NUMBER OF BYTES
	ADDI T1,1
TAPDN1:	MOVEM T1,IRBCNT(P4)	;SAVE WORDCOUNT
TAPDN2:	TXNE Q3,OP.RDB		;WRITE?
	JRST TAPDN3		;NO
	LOAD T3,IRBDM,(P4)	;YES, ACCUMULATE BYTES WRITTEN
	HLRZ T3,MODTBL(T3)
	IMUL T3,IRBCNT(P4)
	ADDM T3,UDBWRT(P3)
	ADDM T3,UDBWPE(P5)	;ACCUMULATE BYTES WRITTEN IN PE OR GCR
TAPDN3:	TXNE Q3,OP.REV
	SOSA UDBPS1(P3)		;UPDATE RECORD COUNTER
	AOS UDBPS1(P3)

TAPDN4:	SETZ T3,		;ZERO STATUS
	LOAD T1,PKYEST,(Q2)	;GET END-PACKET STATUS
	JUMPE T1,DONET		;GO IF NO ERRORS
	CAIN T1,ST%TM
	TXO T3,IS.TPM		;TAPE MARK ENCOUNTERED
	CAIN T1,ST%BOT
	TXO T3,IS.BOT!IS.TPM	;BOT ENCOUNTERED
	CAIN T1,ST%DAT		;DATA ERROR?
	TXO T2,IS.NRT!IS.DTE!IS.ERR ;SET DATA ERROR
	CAIN T1,ST%RDT
	TXO T3,IS.RTL		;RECORD TOO LONG
	TXNN T3,IS.RTL!IS.BOT!IS.TPM!IS.DTE ;ANY OF THESE?
	TXO T3,IS.ERR!IS.NRT!IS.DVE ;NO. "REAL" ERROR
	TXNN T3,IS.BOT!IS.TPM	;BOT OR EOF?
	JRST DONET		;NO
	SETZM UDBPS1(P3)	;YES. AT 0TH RECORD
	TXNE T3,IS.BOT		;BOT?
TAPBOT:	JRST [SETZM UDBPS2(P3)	;YES. AT 0TH FILE TOO
	      MOVX T2,US.BOT	;SET BOT
	      IORM T2,UDBSTS(P3)
		JRST DONE]
	TXNE Q3,OP.REV		;NO. BACKWARDS?
	SOSA UDBPS2(P3)
	AOS UDBPS2(P3)		;ADJUST FILE COUNT
	JRST DONET

DONET:	LOAD T2,PKYFCD,(Q2)	;GET FULL STATUS
	TXNE T2,EF%EOT		;IS IT EOT?
	TXO T3,IS.EOT		;YES SET EOT FLAG
	TXNN Q3,OP.REW		;REWIND?
	JRST DONE		;NO NOT BOT
	JRST TAPBOT
;DISK TRANSFERS FINISH HERE BY UPDATING THE COUNT OF READS/WRITES
;AND CHECK FOR ERRORS BEFORE INFORMING PHYSIO THAT THE TRANSFER
;IS COMPLETE.

DSKEND:	LSH T1,-11		;CONVERT BYTES TO SECTORS
	TXNE Q3,OP.RDB		;READ?
	JRST [ADDM T1,UDBRED(P3) ;YES
		AOS UDBRCT(P3)
		JRST DSKEN1]
	ADDM T1,UDBWRT(P3)	;NO
	AOS UDBWCT(P3)
DSKEN1:	LOAD T1,PKYEST,(Q2)	;GET END PACKET STATUS
	JUMPE T1,DONE1		;ERROR?
	SKIPA T3,[IS.ERR!IS.DTE!IS.NRT] ;SET DATA ERROR SO WE GET BAT BLOCK ALLOCATION
ERRDON:	MOVX T3,IS.ERR!IS.NRT!IS.DVE ;YES
				;FALL INTO DONE

DONE:	IORM T3,IRBSTS(P4)	;LIGHT BITS IN IORB
DONE1:	CAIN T1,ST%CMD		;CHECK FOR ILLEGAL COMMAND
	JRST [	LOAD T3,PKYQSB,(Q2)
		BUG.(CHK,MSCIVC,PHYMSC,SOFT,<PHYMSC - Illegal command>,<<P1,CHAN>,<P2,KONT>,<P3,UNIT>,<T3,STS>>,<

Cause:	The remote node claimed we sent it an illegal command.  This indicates
	a MSCP protocol problem with the local or remote node.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:	CHAN - Channel number
	KONT - Controller number
	UNIT - Unit number
	STS  - Status returned by remote node
>)
		JRST .+1]
	CAIN T1,ST%WPR		;CHECK FOR WRITE PROTECT
	JRST [	MOVX T2,US.WLK  ;SET WRITE LOCK BIT
		IORM T2,UDBSTS(P3) ;SET IN UDB STATUS
		JRST .+1]
	LOAD T1,PKYFCD,(Q2)	;STATUS/END FLAGS
	MOVX T3,IS.NRT
	AND T3,IRBSTS(P4)	;ERROR STATUS FROM IORB
	TXNN T1,EF%LOG		;ERROR LOG GENERATED?
	JUMPE T3,DONE2		;NO. DONE IF NO ERROR
	CALL ERRSET		;YES. ALLOCATE AN ERROR BLOCK
	JUMPE T1,DONE2		;NO SPACE. CAN'T LOG IT
	MOVEM T1,UDBERP(P3)	;GOT ONE. SAVE ITS ADDRESS
	CALL REVSTS		;PUT P.STS BACK INTO ORIGINAL ORDER FOR ERROR LOG
	LDB T1,IRYFCN		;FUNCTION WE'RE DOING INTO UDBERR
	MOVEM T1,UDBERR(P3)	;JUST TO INFORM WORLD WE'RE PROCESSING AN ERROR
	MOVE T3,UDBERP(P3)	;STORE INTO THE ERROR BLOCK
	ADDI T3,CI%PAK+SEBDAT	;POINT TO THE WORD TO FILL IN
	XMOVEI T2,P.CRF(Q2)	;FROM THE PACKET
	MOVEI T1,P.TRBC-P.CRF+1	;AMOUNT OF DATA TO MOVE
	EXTEND T1,[XBLT]	;FILL IN THE DATA

DONE2:	CALL RTNBUF		;GIVE THE BUFFER BACK TO SCA
	CALL PHYINU		;TELL PHYSIO ABOUT THE COMPLETION
	HRRZ T1,UDBPWQ(P3)	;IS THERE SOMETHING TO DO?
	JUMPE T1,R		;NOPE FORGET IT
	CALL UNQUNT		;YES TRY TO QUEUE ANOTHER REQUEST
	RET			;NO PROBLEM IF FAILED
	RET			;DONE - RETURN TO SCA

DONE3:	SKIPN P4
	BUG.(HLT,MSCNIR,PHYMSC,SOFT,<PHYMSC - IORB zero>,<<P5,CID>>,<

Cause:  PHYMSC found the IORB register zero in a place it did not expect.

Data:   CID - Connect ID
>)
	MOVE T2,IRBSTS(P4)	;STATUS OF THE IORB (MAY NOT BE VALID)
	BUG.(INF,MSCGON,PHYMSC,SOFT,<PHYMSC - IORB/QOR gone>,<<P5,CID>,<P4,IORB>,<T2,STATUS>>,<

Cause:	PHYMSC had a data structure which pointed at an IORB.  It cannot find
	the IORB on the unit transfer queue.  This seems to be a problem with
	PHYMSC's handling of the QOR database.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:	CID - Connect ID
	IORB - IORB address
	STATUS - Status of IORB
>)
	CALLRET RTNBUF
;HERE ON THE RECEIPT OF A DATAGRAM
;WE ENTER HERE TO PERFORM ERROR LOGGING OF PROBLEMS THAT
;ARE REPORTED TO US FROM THE DEVICE.
;	ENTER WITH:	T1/ .SSDGR
;			T2/ CONNECT ID
;			T3/ ADDRESS OF DATAGRAM BUFFER
;			T4/ FLAGS AND ADDRESS OF ROUTINE TO RETURN BUFFER

DGREC:	AOS MSCDRC		;[7211] COUNT THE INCOMING DATAGRAM
	MOVE Q2,T3		;[7211] SAVE ADDR OF BUFFER
	MOVE P5,T2		;SAVE CID
	$LDCID T1,T2		;CB ADDR
	MOVE P1,.CBSBA(T1)	;SBK ADDR
	MOVE T1,.MHPKL(Q2)	;TOTAL BLOCK LENGTH
	IDIVI T1,4		;CONVERT FROM BYTES
	SKIPE T2		;CHECK FOR PARTIAL BYTES
	AOS T1			;INCLUDE EXTRA BYTE FOR 1 WORD
	AOS T2,T1		;NON STRING DATA SIZE
	CALL ALCSEB		;TRY TO GET ERROR BLOCK
	 JRST DGREC1		;NONE AVAILABLE. RETURN BUFFER TO SCA AND EXIT
	MOVE Q3,T1		;SAVE LOC OF ERROR BLOCK
	MOVEI T3,SEBDAT+EL%PAK(T1) ;STORE INTO THE ERROR BLOCK
	MOVE T1,.MHPKL(Q2)	;AMOUNT OF DATA TO MOVE
	IDIVI T1,4		;CONVERT FROM BYTES
	SKIPE T2
	AOS T1	
	XMOVEI T2,P.CRF(Q2)	;FROM THE PACKET
	EXTEND T1,[XBLT]	;FILL IN THE DATA
	MOVE T1,Q3		;ERROR BLOCK LOC AGAIN
	MOVE T2,[-NELTAB,,ELTAB] ;FILL IN THE HEADER
	CALL SEBCPY
	 JFCL
	MOVE T1,Q3		;RECOVER ERROR BLOCK
	CALL QUESEB		;HAND IT TO SPEAR

DGREC1:	MOVE T1,Q2		;ADDRESS OF BUFFER
	SETZM (Q2)		;CLEAR THE LINK TO THE NEXT BUFFER
	BLCAL. (SC.RDG,<P5,[1],Q2>)
	JFCL
	RET


ELTAB:	SEBPTR 0,SBTEVC,SEC%EL	;BLOCK TYPE
	SEBPTR EL%NOD,SBTWD,.SBDSP(P1) ;PORT,,NODE
NELTAB==.-ELTAB
;HERE ON AN AVAILABLE MESSAGE
;WHEN A DISK BECOMES AVAILABLE WE GET A MESSAGE THAT TELLS
;US THAT IT HAS RETURNED FROM A STATE WHERE IT WE COULD NOT
;USE IT.  WHEN WE GET HERE WE MUST CHECK TO SEE IF IT IS A NEW
;UNIT OR ONE THAT WE ALREADY KNEW ABOUT.  IF IT IS A NEW
;UNIT THEN WE MUST BUILD A UDB FOR IT AND MAKE IT KNOWN TO
;THE SYSTEM.  WHEN IT IS A UNIT THAT WE USED TO KNOW ABOUT
;THEN WE MUST PUT IT ONLINE AND REQUEST THAT THE HOMEBLOCKS
;BE RE-READ.  IF IT IS A UNIT THAT IS ALREADY ONLINE THEN
;WE MUST ALSO GO THRU THE CODE TO RE-READ THE HOMEBLOCKS
;BECAUSE THE DRIVE MAY HAVE GONE OFFLINE AND RETURND WITHOUT
;TELLING US OF IT'S DISAPPEARANCE.  FOR THE PURPOSE OF THIS
;ROUTINE AVAILABLE IMPLIES THAT THE UNIT HAS RECIENTLY BEEN
;OFFLINE!

MSGAVA:	BLCAL. (SC.RMG,<P5,[1],[0]>)	 ;REQUEST MORE CREDIT
	JFCL			;OOPS WELL WE LOST ONE
	CALL SETSUN		;GET UNIT NUMBER
	MOVE T4,T1		;SAVE UNIT NUMBER
	MOVE T1,P5		;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	SKIPE CIBUGX		;CI DEBUGGING?
	BUG.(INF,MSCAVA,PHYMSC,SOFT,<PHYMSC - Available message received>,<<T2,NODE>,<T1,CID>,<T4,UNIT>>,<

Cause:	When a disk becomes available we get a message that tells us that it
	has returned from a state where it we could not use it.  We then build
	a UDB if needed and start checking the home blocks.

Action:	No action required, this bug is for information only.

Data:	NODE - node number
	CID  - connect ID
	UNIT - Unit number
>,,<DB%NND>)			;[7.1210] 
	MOVE T2,P5		;GET CONNECT ID
	CALL FNDNDX		;COMPUTE SB INDEX
	 JRST RTNBUF		;NO MATCHING ID!
	MOVE Q3,T1		;PUT INDEX WHERE SCA WILL LOOK FOR IT

;HERE FROM MSCOUN TO ONLINE A UNIT IN RESPONSE TO A DIAG JSYS
INIUNI:	CALL SETP3		;SET P3 POINTING TO THE UDB
	 JFCL			;NO SUCH UDB, IT'S A NEW UNIT
MSGAV1:	MOVEI P6,MSGA1		;RETURN ON DONE TO MSGAA
	MOVEI T2,OP.GUS		;DO A GET UNIT STATUS
	CALL CURUN		;ASK THE HSC WHAT THE NEXT UNIT IS
	IFNSK.
	  MOVE T3,T1		;MOVE ERROR CODE
	  MOVE T1,P5		;GET CONNECT ID
	  CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	  BUG.(INF,MSCNUF,PHYMSC,SOFT,<PHYMSC - Get next unit failed>,<<T2,NODE>,<T1,CID>,<T3,ERRCOD>>,<

Cause:	PHYMSC was unable to get the next unit from a HSC, probably because 
	SC.SMG failed.  This is seen most often with broken HSC hardware.

Action:	If the hardware checks out OK, and if this bug occurs often or is
	reproducible, change it to a BUGHLT and submit an SPR along with a dump
	and instructions on reproducing it.

Data:	NODE   - node number
	CID    - connect ID
	ERRCOD - error code
>,,<DB%NND>)			;[7.1210] 
	ENDIF.
	RET
				;WAIT FOR ANSWER
; ENTER HERE AFTER GET NEXT UNIT CALL FROM MESSAG AVAILABLE

MSGAA:	CALL SETP3		;CHECK FOR A UNIT FOUND
	SKIPA			;UNIT NOT FOUND BUILD ONE
	JRST MSGAV7		;FOUND IT?? DOESN'T MATTER ONLINE IT
	MOVE Q1,T1		;GET UNIT NUMBER
	LOAD T3,PKYEST,(Q2)	;YES. GET STATUS OF UNIT
	CAIE T3,ST%AVL		;AVAILABLE?
	JUMPN T3,RTNBUF		;NO. IF NOT ONLINE THEN WE CAN'T USE IT
	TRNE Q3,TAPSID		;CHECK FOR TAPE
	JRST MSCI22		;YES ONLINE IT DIFFERENTLY
	CALL UNTYPE		;SET UNIT TYPE FROM MEDIA TYPE IN PACKET
	JRST RTNBUF		;NO ENTRY FOUND IN TABLE
	HRLI P2,1(Q1)		;UNIT NUMBER+1 IN LH(P2) FOR SETUDB
	CALL BLDUDB		;BUILD THE UDB
	 JRST RTNBUF		;NO SPACE TO CREATE THE UDB
	TLZ P2,-1		;CLEAR JUNK FROM LH OF P2
	CALL PHYDUA		;(P3/) LOOK FOR ANOTHER UDB WITH SAME DSN

MSGAV3:	MOVE T1,Q1		;RECOVER UNIT NUMBER
MSGAV7:	MOVEI P6,MSCGO1		;SET RETURN TO MSSONL  WHEN ONLINE SUCCESSFUL
ONLINA:	CALL ONLINE		;ONLINE THE UNIT
	JRST [	MOVE T3,T1		;MOVE ERROR CODE
		MOVE T1,MSCOLD(Q3)	;GET CONNECT ID
		CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
		BUG.(INF,MSCOLF,PHYMSC,SOFT,<PHYMSC - Available online failed>,<<T2,NODE>,<T1,CID>,<T3,ERRCOD>>,<

Cause:	An attempt to put an available unit online failed because of a send 
	failure.  The remote node could have crashed during the online attempt.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:	NODE   - node number
	CID    - connect ID
	ERRCOD - error code
>,,<DB%NND>)]			;[7.1210] 
	RET
				;WAIT FOR ONLINE TO COMPLETE
;HERE WHEN ONLINE RETURNS FROM MSGAV3.  WE MUST CHECK TO SEE THAT
;WE ARE NOW SUCCESSFUL AND SET ONLINE.
MSSONL:	LOAD T1,PKYEST,(Q2)	;CHECK TO SEE THAT ONLINE SUCCEEDED
	JUMPN T1,BUGMSC
	CALL SETP3
	 CALL NOONL		;CAN'T ONLINE A UNIT WE HAVE
	CALL GETSER		;(Q2,P3/) RE SETUP UDBDSN,UDBDSH.
	MOVE Q1,P.UNFL(Q2)	;SAVE UNIT FLAGS FOR FORMAT CHECK
	CALL RTNBUF		;GIVE BUFFER BACK TO SCA
	TXNE Q3,TAPSID		;CHECK FOR TAPE CONTROLLER
	JRST TAPAVL		;TAPE AVAILABLE (CLEAN UP STUFF)
	MOVE T1,UDBSTS(P3)	;GET STATUS
	TXNE T1,US.TPD		;CHECK FOR TPD
	RET			;YES FORGET USE OF THIS DISK
	MOVE T1,Q1		;GET THE UNIT FLAGS
	CALL REVFUL		;SWAP BYTES
	TXNN T1,UF.576		;CHECK FOR 576 FORMAT
	CALLRET PHYOFL		;OFFLINE THE THING IT ISN'T OURS
	MOVX T1,UA.PAT		;CLEAR AND SET PAT ON CORRECT DRIVES
	IORM T1,UDBALT(P3)	;SET PAT ON NEW DRIVE
	HRRZ T2,UDBALT(P3)	;GET OLD DRIVE
	SKIPE T2		;CHECK AND SEE IF THE OLD ONE EXISTS
	ANDCAM T1,UDBALT(T2)
	CALL FLGHOM		;FLAG HOME BLOCKS NEED REREADING
	CALL PHYONL		;INFORM PHYSIO
	HRRZ P3,UDBALT(P3)	;OFFLINE THIS DRIVE
	JUMPE P3,R		;QUIT IF NO ALTERNATE
	MOVX T1,US.ACT		;CLEAR ACTIVE BITS
	ANDCAM T1,UDBSTS(P3)
	CALLRET PHYOFL		;AND QUIT

;ROUTINE TO FLAG UDB SO PHYSIO WILL REREAD HOME BLOCKS
;CALL WITH P3/UDB
FLGHOM:	SAVEAC <P2>
	MOVX T1,US.CHB		;NEED TO CHECK HOME BLOCKS
	SKIPL UDBSTR(P3)
	TXO T1,US.OIR		;OPR INTERVENTION IF IN A STR
	IORM T1,UDBSTS(P3)	;MUST CHECK HOME BLOCKS
	MOVX T1,US.ACT		;MAKE UNIT INACTIVE
	ANDCAM T1,UDBSTS(P3)	; SO PHYSIO WILL DO HOME BLOCK CHECK
	HRRZ T1,UDBALT(P3)	;IS THERE AN ALTERNATE UDB?
	JUMPN T1,TW2PWQ		;YES GET ALL THE IORBS ONTO 1 QUEUE
	MOVE P5,P3		;SET UP TO MOVE TWQ TO PWQ
	CALL TW2PW3
	RET			;QUIT

TAPAVL:	MOVX T1,US.WLK!US.OMS!US.OIR ;CLEAN UP WRITE LOCK
	ANDCAM T1,UDBSTS(P3)	;BEFORE PUTTING TAPE BACK ONLINE
	JRST PHYONL
	SUBTTL Diag Online

;HERE FROM DIAG TO ONLINE A UNIT
;IT IS NOT OBVIOUS THAT THIS ROUTINE IS NECESSARY SINCE WE ARE
;SUPPOSED TO SEE ALL NODES/UNITS WHEN THEY COME ONLINE 
;THEREFORE THERE IS NOTHING HERE...

REPEAT 0,<
;CALL:	T1/NODE NUMBER
;	T2/UNIT NUMBER
;	CALL MSCOUN
;RETURNS +1 LOSE,  +2 - WIN

MSCOUN::SAVEPQ
	MOVE P6,T2		;SAVE UNIT
	SETZ Q3,
MSCOU1:	CAIGE Q2,C%SBLL		;CHECK FOR END OF LIST
	SKIPG T2,MSCCID(Q3)	;GET CID
	RET
	$LDCID T2,T2		;CB ADDR
	MOVE P2,.CBSBA(T2)	;SB ADDR
	HRRZ T2,.SBDSP(P2)	;NODE NUMBER
	CAME T1,T2		;MATCH?
	AOJA Q3,MSCOU1
	CALL GETBUF		;YES, GET A BUFFER FROM SCA
	 RET			;NONE
	LSH P6,4		;POSITION UNIT CORRECTLY
	MOVE T1,P6
	CALL REVFUL		;SWAP THE BYTES
	MOVEM T1,P.UNIT(Q2)	;SAVE WHERE WE EXPECT THE UNIT NUMBER
	HRRZ P1,.SBACD(P2)	;POINT AT CDB
	CALL INIUNI		;PRETEND WE JUST GOT AN AVAILABLE ATTENTION AND
	RETSKP			; GO ONLINE THE UNIT
>
MSCOUN::RETSKP			;RETURN SUCCESS

BUGMSC:	MOVE T3,T1		;SAVE CODE
	CAIN T3,ST%OFL		;IS IT OFFLINE? (REALLY POSSIBLE..)
	CALLRET	RTNBUF		;YES FORGET IT FOR NOW IT MAY SHOW UP LATER
	MOVE T1,MSCOLD(Q3)	;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(INF,MSCORO,PHYMSC,SOFT,<PHYMSC - Offline return to online when we were told avail>,<<T2,NODE>,<T1,CID>,<T3,CODE>>,<

Cause:	A node that indicated an online is not available when the online is
	attempted.  The remote node could have crashed during the online
	attempt.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:	NODE - node number
	CID  - connect ID
	CODE - end packet status code
>,,<DB%NND>)			;[7.1210] 

	CALL RTNBUF
	MOVE T2,MSCCID(Q3)	;INSURE WE HAVE CONNECT ID
	CALL PBRCOA
	BLCAL. (SC.DIS,<MSCCID(Q3),[0]>)
	 JFCL
	SETOM MSCCID(Q3)
	MOVX T1,DT.IDC
	IORM T1,CIDATA(Q3)
	RET
	SUBTTL General Purpose Routines

;ROUTINE TO SET UP P3 WITH THE UDB ADDRESS
;CALL:	Q2/PACKET ADDRESS
;	P2/SYSTEM BLOCK ADDR.  UNIT NUMBER IN P.UNIT
;RETURN+1 IF NO SUCH UDB EXISTS, WITH T1/UNIT NUMBER
;RETURN+2 WITH P3/UDB ADDR  T1/UNIT NUMBER

SETP3:	CALL SETSUN		;GET UNIT NUMBER
	HRRZ T2,P2		;JUST ADDRESS PART
	MOVE T2,KDBIUN(T2)	;POINTER TO UDBS
SETP31:	SKIPE P3,(T2)		;UNIT EXIST?
	CAME T1,UDBSLV(P3)	;YES. IS IT THIS ONE?
	AOBJN T2,SETP31		;NO, TRY NEXT
	JUMPL T2,RSKP		;RETURN SKIP IF FOUND A UDB
	RET			;RETURN NO SUCH UNIT

;HERE ON SCA CALLBACK IF MORE CREDIT IS AVAILABLE
;WHEN MORE CREDIT IS AVAILABLE THEN WE MUST TRY TO UNQUEUE
;ANY REQUESTS THAT WERE DELAYED DUE TO LACK OF CREDIT. IF
;NOTHING WAS WAITING THEN WE JUST RETURN.

MSCCIA:				;FALL INTO UNQALL TO START WHAT WE CAN

;CHECK TO SEE IF ANY QUEUED REQUESTS ARE WAITING. IF SO, START WHAT WE CAN
	MOVE Q1,T2		;SAVE THE CONNECT ID
	CALL FNDNDX		;GET THE KDB
	RET			;NONE FOUND NO PROBLEM FORGET IT
	MOVE P2,.CBSBA(T2)	;SET UP THE KDB POINTER
	MOVE P1,CHNTAB+KLPRH2	;GET THE CHANNEL POINTER
	CALLRET UNQALL		;RESTART ALL UNITS ON THIS KDB
;ROUTINE TO UNQUEUE REQUESTS FOR A SINGLE NODE
;CALL P2/KDB FOR THE NODE
;RETURNS +1 ALWAYS

UNQALL:	MOVE T1,KDBCUN(P2)	;WHERE WE LAST LEFT OFF
UNQNO1:	SKIPN P3,(T1)		;UNIT EXIST?
	JRST UNQNO5
	CALL UNQUNT		;UNQUEUE FOR THIS UNIT
	RET			;ALL DONE CAN'T QUEUE
UNQNO5:	AOBJN T1,UNQNO1		;NO, STEP TO NEXT UNIT
	RET


;UNQUNT -- ROUTINE TO UNQUEUE AND RE-START FOR A GIVEN UNIT
;P1/CHN P2/KDB P3/UDB
;
UNQUNT:	SAVET			;SAVE A FEW REGISTERS
	SETZM QUEREQ		;INDICATE NO REQUEUE
UNQLOP:	HRRZ T2,UDBPWQ(P3)	;YES. PWQ NON-EMPTY?
	JUMPE T2,RSKP
	MOVE T2,UDBSTS(P3)	;ON LINE AND NOT REREADING HOME BLOCKS??
	TXNE T2,US.OFS!US.CHB
	JRST RSKP		;NO. TRY ANOTHER UNIT
	HRRZ T2,UDBTWQ(P3)	;YES. IF DISK IS NOT IN A STR
	SKIPGE UDBSTR(P3)	; THEN ONLY ALLOW 1 REQUEST TO BE OUTSTANDING
	JUMPN T2,RSKP
	CALL OFFPWQ		;PULL 1ST REQUEST FROM PWQ
	MOVE P4,T1		;WHERE MSCSIO WANTS IORB ADDRESS
	CALL ONFTWQ
	CALL MSCSIO		;START THE IO
	 JRST [ BUG.(CHK,MSCSIF,PHYMSC,SOFT,<PHYMSC - Start IO failed>,<<P3,UDB>,<P2,KDB>,<P1,CHAN>>,<

Cause:	A call to MSCRIO failed when it was not expected to in UNQUNT.  This
	appears to be a PHYMSC problem.

Action:	If this bug occurs often or is reproducible, change it to a BUGHLT and
	submit an SPR along with a dump and instructions on reproducing it.

Data:	UDB - UDB address
	KDB - KDB address
	CHAN - Channel number
>)
		RET]
	SKIPN QUEREQ		;DID WE FAIL AND REQUEUE?
	JRST UNQLOP		;NO TRY ANOTHER REQUEST
	RETSKP			;YES. DONE WITH THIS NODE
;ROUTINE TO MOVE ALL THE REQUESTS FROM THE PRIMARY AND ALTERNATE
;QUEUE'S TO THE PWQ OF THE PRIMARY UDB.  THIS PERMITS UNIT SWITCHING
;AND ASSURES THAT THERE ARE NO LOST TRANSFERS ON THE UNUSED UDB.
;
;CALL T1/ UDB OF OLD REQUESTS
;     P3/ UDB OF NEW REQUESTS
;RETURNS +1 ALWAYS

TW2PWQ::SAVEPQ			;SAVE A LOT OF REGISTERS FIRST
	SAVET			;OR POLLER WILL HATE US
	MOVE Q3,T1		;SAVE THE OLD UDB ADDRESS
	MOVE P5,P3		;WHERE TO STORE THE TWQ
	CALL TW2PWP		;MOVE THE NEW UDB TO PWQ
	EXCH Q3,P3		;MOVE THE OLD UDB
	MOVX T1,US.CHB!US.OMS!US.OIR ;CLEAR UP FLAGS IN OLD UDB
	ANDCAM T1,UDBSTS(P3)
	CALL TW2PWP
TW2PWE:	HRRZ T1,UDBPWQ(P3)	;ANYTHING ON OLD PWQ?
	JUMPE T1,R		;NO QUIT NOW
	CALL OFFPWQ		;REMOVE IT
	EXCH P3,P5		;WHERE TO PUT IT
	CALL ONFPWQ		;STORE IT ON QUEUE
	EXCH P3,P5		;AND TRY NEXT ENTRY
	JRST TW2PWE

;ROUTINE TO MOVE THE ENTRIES FROM THE TWQ TO THE PWQ
; CALL /P3 SOURCE UDB
;      /P5 DESTINATION UDB
; RETURNS +1 ALWAYS
TW2PW3:	SAVEQ			;SAVE A FEW REGS
TW2PWP: HRRZ T1,UDBTWQ(P3)	;PICK UP IORB
	JUMPE T1,R		;DONE IF 0
	CALL OFFTWQ		;PULL FIRST ITEM FROM TWQ
	MOVE Q2,T1		;SAVE THE IORB ADDRESS
	HRRZ P2,UDBKDB(P3)	;GET KDB ADDRESS
	HRRZ Q1,.SBQOR(P2)	;PICK UP THE BEGINNING OF QOR TABLE
TW2PW5:	HRRZ T2,QORIRB(Q1)	;GET THE IRB ADDRESS
	CAIN T1,(T2)		;IS IT THE RIGHT ONE?
	JRST TW2PW2		;YES EXTRACT IT
	HRRZ Q1,QORLNK(Q1)	;NOPE TRY NEXT ONE
	CAIE Q1,.SBQOR(P2)	;END OF LIST?
	JRST TW2PW5		;NOPE TRY NEXT ONE
	JRST TW2PW4		;NOT FOUND COULD BE NOT QUEUE'D YET
TW2PW2:	SKIPE T1,QORBHD(Q1)	;BHD THERE?
	CALL RTNBHX		;YES RETURN IT
	CALL ULKQOR		;RETURN QOR
TW2PW4:	HRRZ T1,Q2		;RESTORE IORB
	CAMN T1,UDBCHB(P3)	;HOMEBLOCK IORB?
	JRST [ CALL CLRCHB	;YES RELEASE IT
	       JRST TW2PWP]	;AND FORGET IT
	EXCH P5,P3		;WHERE WE WANT ENTRY PUT
	CALL ONFPWQ		;AND INSERT IT ON PWQ
	EXCH P5,P3		;RESTORE UDB
	JRST TW2PWP		;LOOK FOR ANOTHER


;**** TEMP KILL ROUTINE FOR TAPES*****
PHYMKL::HRLZI T1,UDBPWQ(P3)	;ZERO QUEUE
	EXCH T1,UDBPWQ(P3)	;TAKE ALL THE CURRENT ENTRIES
	HRRZS T1		;ZERO LEFT HALF JUNK
	RET			;RETURN 


CLRCHB:	SAVET			;SAVE A COUPLE OF REGISTERS
	MOVX T1,IS.ERR		;INDICATE OFFLINE
	MOVE T2,UDBCHB(P3)	;GET IORB ADDRESS
	IORM T1,IRBSTS(T2)	;STORE THE STATUS
	RET			;AND RETURN
;ROUTINE TO UNLINK AND FREE UP A QOR
;CALL Q1/QOR LOC
;RETURNS +1 ALWAYS

ULKQOR:	HRRZ T2,QORLNK(Q1)	;FORWARD-POINTER
	HLRZ T3,QORLNK(Q1)	;BACKWARD-POINTER
	HRRM T2,QORLNK(T3)	;LINK AROUND THIS QOR
	HRLM T3,QORLNK(T2)
	SETZM QORLNK(Q1)	;INDICATE THE QOR IS AVAILABLE
	SETZM QORCRF(Q1)	;SO WE CAN CATCH DUPLICATES
	SETZM QORBHD(Q1)	;CLEAR THE BHD ADDRESS JUST IN CASE
	SETZM QORIRB(Q1)	;AND IORB JUST IN CASE
	RET

;ROUTINE TO PUT AN IORB ON THE FRONT OF THE TWQ
;CALL P3/UDB
;	P4/IORB
;RETURNS +1  IORB DOESN'T APPEAR ANYWHERE ON TWQ
;RETURNS +2  NORMALLY, IORB ON THE FRONT OF THE QUEUE

FRONTW:	HRRZ T1,UDBTWQ(P3)	;GET 1ST ITEM ON TWQ
	JUMPE T1,R		;NONE FOUND
	CAIN T1,(P4)		;IS IT THIS IORB?
	RETSKP			;YES, NO NEED TO FIDDLE WITH TWQ
FRONT1:	HRRZ T2,IRBLNK(T1)	;NO. STEP TO NEXT IORB IN QUEUE
	JUMPE T2,R		;CAN'T FIND IORB
	CAIN T2,(P4)		;IS THIS THE ONE?
	JRST FRONT2		;YES
	MOVE T1,T2		;NO, TRY ONE MORE
	JRST FRONT1
FRONT2:	CALL CONSTW		;REMOVE THE IORB FROM THE TWQ
	MOVE T1,P4
	CALL ONFTWQ		;AND INSERT IT AT THE FRONT OF THE QUEUE
	RETSKP			;GOOD RETURN
	SUBTTL PHYSIO Interface

;MSCEXT - CHECK FOR LEGALITY OF A UNIT
;	ENTER Q2/UNIT NUMBER
;	EXIT NON-SKIP IF BAD NUMBER
;	EXIT SKIP IF OK, P3/UDB

MSCEXT:	SKIPL Q2		;NEGATIVE
	CAILE Q2,MAXUNN		;OR GREATER THAN HIGHEST USED NUMBER
	JRST RFALSE		;GETS T1=-1
	MOVE T1,KDBIUN(P2)	;AOBJN WORD FOR ALL UNITS
MSCEX1:	SKIPE P3,(T1)		;GET A UNIT
	CAME Q2,UDBSLV(P3)	;RIGHT ONE?
	AOBJN T1,MSCEX1
	JUMPL T1,RSKP		;MATCH - GOOD RETURN
	JRST RTRUE		;NO MATCH

REPEAT 0,<
;HERE  TO ABORT ALL TRANSFERS CURRENTLY IN PROGRESS ON A UNIT
;CALL P2/SYSTEM BLOCK
;	P3/UDB ADDRESS

MSCABT:	SAVEQ
	HRRZ Q1,.SBQOR(P2)	;POINT AT 1ST THING ON THE QUEUE
	HLRZ Q3,UDBKDB(P3)	;POINT AT MSCCID INDEX
MSCAB1:	CAIN Q1,.SBQOR(P2)	;END OF QUEUE?
	RET			;YES. DONE
	HLRZ T1,QORUNI(Q1)	;UDB
	CAIE T1,(P3)		;IS IT FOR THIS UNIT?
	JRST MSCAB2		;NO, TRY NEXT QOR
	CALL GETBUF		;GET A BUFFER
	 RET			;NONE FOUND
	MOVE T1,UDBSLV(P3)	;YES. GET MSCP UNIT NUMBER
	MOVEI T2,OP.ABO		;ABORT THE REQUEST
	MOVE T3,QORCRF(Q1)	;COMMAND REF NUMBER TO ABORT
	MOVEM T3,P.OTRF(Q2)	;PUT IT INTO THE PACKET
	MOVEI T3,P%OTRF		;LENGTH PF MESSAGE
	SETO P6,		;SHOULDN'T NEED TO WORRY ABOUT RETURN
	CALL SENDPK		;TELL THE HSC TO ABORT THIS COMMAND
	SKIPE T1,QORBHD(Q1)	;BUFFER NAME ASSOCIATED WITH REQUEST
	CALL RTNBHX		;RETURN THE RESOURCES
	HRRZ Q2,QORLNK(Q1)	;GET LINK TO NEXT QOR
	CALL ULKQOR		;RETURN THE QOR
	SKIPA Q1,Q2		;LOOK AT LINK OF THIS QOR
MSCAB2:	HRRZ Q1,QORLNK(Q1)	;STEP TO NEXT QOR IN CHAIN
	JRST MSCAB1		;AND SEE IF IT'S FOR THE BAD UNIT
> ;END REPEAT
	SUBTTL Initialization
;
; INITIALIZATION  IS CALLED BY PHYSIO TO DETERMINE WHAT DEVICES
; ARE ON THE CI.  THE FIRST THING THAT WE MUST DO IS TO CHECK THE
; TIME SINCE WHEN IT BECOMES AVAILABLE WE MUST SEND THE TIME TO
; EACH HSC CONTROLLER.

MSCINI::
	SETOM HAVTIM		;INDICATE TIMES NOT YET SET IN SERVERS
	SETZM MSCHSC		;INITIALIZE THE CONTROLLER TIMER WORD
	SETOM MSCITD		;SET INITIALIZED FLAG
MSCINA:	BLCAL. (SC.SOA,<<.,INTRPT>>)	;TELL ME WHEN A NODE COMES OR GOES
	BUG.(HLT,MSCSOA,PHYMSC,SOFT,<PHYMSC - SC.SOA failed>,<<T1,ERRCOD>>,<

Cause:	Interrupts were requested and failed.  This has to be a SCAMPI problem.

Data:	ERRCOD - Error Code
>)
	SETZB Q3,Q1		;Q3 COUNTS MSCP CONTROLLERS, START AT 1ST SB
	SETOM MSCINF		;SET INIT FLAG
	SKIPA Q2,MSCINF		;SET INIT FLAG
				;FALL INTO MSCIN1
; WE ENTER HERE BOTH AT INIT TIME AND WHEN A UNIT IS TO BE
; CONNECTED BECAUSE THE POLLER HAS LOST THE UNIT AND WANTS
; TO TRY AGAIN.  THE FIRST THING WE DO IS TO GET THE TYPE
; OF NODE AND THEN WHEN WE DETERMINE THAT IT IS A HSC WE
; CONNECT TO IT.  AFTER THE CONNECT COMPLETES WE WILL GET A
; CONNECT RESPONSE AVAILABLE WHICH WILL TELL US THAT WE
; CAN SUCCESSFULLY TALK TO THE HSC ON THE OTHER END.  WE THEN
; SET SET CONTROLLER CHARACTERISTICS AND LOOK TO SEE WHAT TYPE
; OF DEVICE IS ON THE CONTROLLER.  ONCE WE FIND THAT IT IS REASONABLE
; WE THEN DO A GET NEXT UNIT STATUS TO FIND OUT WHAT ALL THE
; UNIT TYPES.  THIS THEN LEADS US TO TRY TO ONLINE THE UNITS AND
; SET THEM AVAILABLE FOR PHYSIO USE.

;ENTERED HERE IF NODE ONLINE INTERRUPT
MSCIN1:	SETZ Q2,
MSCINZ:	HRRZ T1,Q1		;ISOLATE ADDRESS PORTION
	SKIPN SBLIST(Q3)	;DO WE EXIST?
	JRST MSCI18		;NO THEN THERE IS NOTHING TO DO
	MOVX T2,DT.IRC		;RELOADING ALREADY?
	TDNE T2,CIDATA(Q3)
	JRST MSCI18		;YES IGNORE IT
	SETOM MSCCID(Q3)	;INDICATE IN USE
	MOVE T1,[XWD .RESP1,.RDLEN]  ;PRIORITY,,LENGTH OF FREE SPACE
	MOVEI T2,.RESGP		;GET SPACE FROM RESIDENT FREE POOL
	CALL ASGRES		;(T1,T2/T1) OBTAIN BLOCK
	 JRST MSCI18		;ERROR - COULD NOT GET A FREE SPACE BLOCK
	MOVEM T1,T2		;SAVE BLOCK ADDRESS
	HRRZ T1,Q1		;GET NODE NUMBER
	BLCAL. (SC.RCD,<<T1>,<T2>>)  ;GET CONGIFGURATION OF THIS NODE
	JRST [	MOVE T1,T2	;GET BLOCK ADDRESS
		CALL RELRES	;(T1) RETURN BLOCK TO FREE POOL
		JRST MSCI18]
	MOVE T1,[BYTE (8) "T","-","2","0"]
	CAMN T1,.RDDST(T2)	;IS IT TOPS-20?
	JRST [ MOVX T1,DT.KL	;YES, SET KL FLAG
	       IORM T1,CIDATA(Q3) ;SET IN DATA FLAG
	       JRST MSCINN]	;RETURN TO COMMON CODE
	MOVE T1,[BYTE (8) "H","S","C"," "]
	CAME T1,.RDDST(T2)	;IS IT HSC?
	JRST [	MOVE T1,T2	;NO, GET BLOCK ADDRESS
		CALL RELRES	;(T1) RETURN BLOCK TO FREE POOL
		JRST MSCI18]	;NO, DON'T WANT TO TALK TO IT

MSCINN:	MOVE T1,T2		;GET BLOCK ADDRESS
	CALL RELRES		;(T1) RETURN BLOCK TO FREE POOL
MSCIND:	HRRZ T1,Q1		;ELIMINATE POSSIBLE LH NON-0
	MOVX T2,DT.KEP		;CLEAR STATUS
	ANDM T2,CIDATA(Q3)
	MOVX T2,DT.IRC		;INDICATE WE ARE RECONNECTING
	IORM T2,CIDATA(Q3)	;SET RECONNECTING
	BLCAL. (SC.CON,<<.,OURDNM>,<.,YURDNM>,T1,[DCREDT],[DCREDT],<.,INTRPT>,Q3,[0],[HSCBFN],[DGNUM]>) ;CONNECT TO THE MSCP SERVER
	JRST [ MOVE T2,HAVTIM		;GET TIME POLLER STARTUP
	       CAIN T1,KLPX9		;VC OPEN?
	       CAIL T2,10		;NO CHECK FOR TOO SOON
	       SKIPE CIBUGX		;[7.1193]CI DEBUGGING?
	       BUG.(INF,MSCCDF,PHYMSC,SOFT,<PHYMSC - Connect to disk failure>,<<Q1,NODE>,<T1,ERRCOD>>,<

Cause:	A connect failure to use the disks on an HSC occurred after an
	indication that an HSC was present.  Connection attempts are not timed
	out by SCAMPI.  If PHYMSC is in the middle of connecting to a server on
	another node, and that node crashes, these BUGCHKs continue to appear 
	until that node reappears.

Action:	Bring up the remote node as soon as possible.  No other action is
	required.

Data:	NODE   - node number
	ERRCOD - error code
>,CONFLD,<DB%NND>)		;[7.1210] Go to CONFLD when done
	      JRST CONFLD]
	MOVEM T1,MSCOLD(Q3)	;SAVE CONNECT ID FOR ABORT
	JUMPG Q2,R		;RETURN IF ONLY THIS ONE WANTED

TAPCON:	JRST MSCI18		;TEMP!!!
;TAPCON:		JFCL			;PUT ABOVE IN IF YOU DON'T LIKE TAPES
;TAPCON:
	TXO Q3,TAPSID		;SET INDICATOR THAT THIS IS A TAPE
	MOVX T2,DT.KEP		;CLEAR STATUS
	ANDM T2,CIDATA(Q3)
	MOVX T2,DT.IRC!DT.TAP	;SET RELOADING AND TAPES
	IORM T2,CIDATA(Q3)
	SETOM MSCCID(Q3)
	HRRZ T1,Q1		;GET SBI
	BLCAL. (SC.CON,<<.,OURTNM>,<.,YURTNM>,T1,[TCREDT],[TCREDT],<.,INTRPT>,Q3,[0],[HSCBFT],[DGNUM]>)
	  BUG. (INF,MSCCTF,PHYMSC,SOFT,<PHYMSC - Connect to tape failure>,<<Q1,NODE>,<T1,ERRCOD>>,<

Cause:	A connect failure to use the tapes on an HSC occurred after an
	indication that an HSC was present.  Connection attempts are not timed
	out by SCAMPI.  If PHYMSC is in the middle of connecting to a server on
	another node, and that node crashes, these BUGCHKs continue to appear 
	until that node reappears.

Action:	Bring up the remote node as soon as possible.  No other action is
	required.

Data:	NODE   - node number
	ERRCOD - error code

>,TACFAL)
	MOVEM T1,MSCOLD(Q3)	;SAVE CONNECT ID FOR ABORT
	TXZ Q3,TAPSID		;NO LONGER TAPES SETUP
	JRST MSCI18

;HERE ON FAILURE OF TAPES TO CONNECT

TACFAL:	MOVX T2,DT.KEP		;CLEAR STATUS
	ANDM T2,CIDATA(Q3)
	MOVX T2,DT.GAW		;INDICATE GONE
	IORM T2,CIDATA(Q3)
	TXZ Q3,TAPSID		;NO LONGER WORKING ON TAPES
	JRST MSCI18

;HERE AFTER CONFAL BUGCHECK
; THE CONNECT HAS FAILED AND WE MUST CLEAR THE CONNECT IN PROGRESS
; FLAGS AND INDICATE THAT THE CONTROLLER HAS GONE AWAY.  THIS WILL
; CAUSE THE POLLER TO TRY AGAIN LATER WHEN THE HSC MAY HAVE RECOVERED.

CONFLD:	MOVX T2,DT.KEP		;CLEAR STATUS
	ANDM T2,CIDATA(Q3)
	MOVX T2,DT.GAW
	IORM T2,CIDATA(Q3)	;MARK GONE SO WE WILL TRY LATER
	JRST MSCI18		;TRY NEXT NODE


;ENTERED HERE IF ONLY A SINGLE NODE AND TYPE REQUIRED

MSCIN2:	SAVEQ			;SAVE A COUPLE OF REGISTERS TO KEEP POLLER HAPPY
	MOVEI Q2,1		;INDICATE WE CAME FROM POLLER AND ONLY WANT 1 CONNECT
	MOVX T2,DT.IRC		;CHECK FOR RELOADING
	TDNE T2,CIDATA(Q3)	;ARE WE?
	RET			;YES QUIT
	TXNE Q3,TAPSID		;TAPE?
	JRST TAPCON		;YES HANDLE THIS CONNECT ONLY
	JRST MSCIND		;NO DO DISK
;ENTER HERE TO LOOP OVER ALL THE UNITS TO DO CONNECTS.
;

MSCI18:	AOJA Q3,MSCI23		;COUNT A CONTROLLER

;HERE WHEN WE OBTAIN A TAPE UNIT
MSCI20:	CALL SETP3		;SET UP P3 IF IT EXISTS
	SKIPA			;NOT THERE
	JRST MSCI22		;FOUND THE UNIT USE IT
	HRLOI Q1,-MTAN-1	;YES. DRIVE IS THERE. FIND SLOT TO SAVE IT
MSCI21:	AOBJP Q1, [BUG.(INF,MSCN2S,PHYMSC,HARD,<PHYMSC - More tape drives than table space, excess ignored>,<<P2,KDB>,<P1,CHN>>,<

Cause:	The number of tape drives available exceeds the constant value MTAN.
	Only MTAN drives can be configured.

Action:	The monitor should be rebuilt after changing MTAN in STG with a value
	of MTAN large enough to accommodate all the tape drives available to
	the system.

Data:	KDB - KDB address
	CHN - Channel number
>,,<DB%NND>)			;[7.1210] 
		MOVE T1,P2
		JRST RTNBUF]
	SKIPE MTCUTB(Q1)	;CHECK TO SEE IF UNIT FREE
	JRST MSCI21		;NOPE TRY NEXT ONE
      BLOCK.
	SAVEAC <Q1,Q2>
	LDB Q2,PKYNOD		;NODE NUMBER IS THE UNIT NUMBER
	MOVE T3,[MSCDSP,,LU.TAP] ;YES, SET UP ADDRESS,,LENGTH
	CALL PHYUDB		;AND ASK FOR UDB ALLOCATION
	 RET			;EXIT BLOCK NONSKIP
	RETSKP			;EXIT BLOCK SKIPPING
      ENDBK.
	JRST RTNBUF		;RETURN NO SPACE FOUND
	CALL SETUDB		;SET UP UDB
	JRST RTNBUF
	HRLZM P1,MTCUTB(Q1)	;SAVE LINK TO CDB IN LOGICAL TABLE
	HRRM P3,MTCUTB(Q1)	;SAVE LINK TO UDB

MSCI22:	MOVE T1,P.UNFL(Q2)	;UNIT FLAGS
	CALL REVFUL		;MAKE THEM SENSIBLE
	MOVX T2,US.TAP!US.CIP	;UNIT IS A CI TAPE
	TXNE T1,UF.SWP!UF.HWP
	TXO T2,US.WLK		;WRITE LOCKED
	LOAD T1,PKYEST,(Q2)
	CAIN T1,ST%OFL
	TXO T2,US.OFS		;OFF LINE
	HLLM T2,UDBSTS(P3)	;SAVE STATUS
	MOVX T2,.UTTA7
	STOR T2,USTYP,(P3)	;DRIVE IS A TA78
	MOVE T1,P.FMEN(Q2)	;SPEEDS/FORMATS DRIVE IS CAPABLE OF
	CALL REVFUL		;MAKE IT UNDERSTANDABLE
	MOVX T2,UC.CD!UC.IC!UC.HD ;MODES - CORE DUMP, IND COMPAT, HIGH DENS
	TXNE T1,FM.800
	TXO T2,UC.800		;NRZI 800 BPI
	TXNE T1,FM.PE
	TXO T2,UC.160		;PE 1600 BPI
	TXNE T1,FM.GCR
	TXO T2,UC.625		;GCR 6250 BPI
	MOVEM T2,UDBCHR(P3)	;SAVE IN UDB
	SKIPGE UDBSTS(P3)	;OFF LINE?
	JRST MSCI17		;YES, CAN'T DO AN ONLINE
	MOVE T1,P.FORM(Q2)	;FORMAT
	CALL REVFUL		;MAKE IT INTELLIGIBLE
	TXNE T1,FM.800
	MOVX T2,.SJDN8		;800 BPI
	TXNE T1,FM.PE
	MOVX T2,.SJD16		;1600 BPI
	TXNE T1,FM.GCR
	MOVX T2,.SJD62		;6200 BPI
	MOVEM T2,UDBDEN(P3)	;SAVE DENSITY WHERE MAGTAP WANTS TO SEE IT
;***************************************************************************
;SINCE THERE IS NO WAY TO GAIN EXCLUSIVE USE OF A TAPE,
;WE WILL EVENTUALLY GO TO A METHOD WHERE OPR WILL DO A JSYS WHICH WILL
;LIGHT A BIT IN THE UDB. WE WILL ONLY ONLINE A TAPE IF THE BIT IS ON
;***************************************************************************
	JRST MSCI14		;GO DO AN ONLINE TO THE DRIVE

;WHEN WE GET HERE WE MUST CHECK TO SEE IF THIS IS INIT TIME.
;IF SO THEN WE TRY TO CHECK EACH KNOWN NODE.  OTHERWISE WE
;JUST RETURN TO THE CALLER.  THE INTERRUPT SERVICE STUFF WILL
; EVENTUALLY BRING THE UNITS ONLINE.

MSCI23:	JUMPGE Q2,R		;DONE IF NOT INIT
	CAIGE Q1,C%SBLL-1	;YES, AT TOP?
	AOJA Q1,MSCINZ		;NO, TRY NEXT CONTROLLER
	RET			;RETURN TO SCA

;HERE TO FINISH UP ON A NEW/RETURNED NODE DURING T/S

MSCI27:	JUMPGE Q1,R		;GO AWAY IF A NEW NODE
;***************************************************************************
;THE QUEUED REQUESTS HAVE BEEN MOVED TO THE PWQ. THEY WILL GET
;REPLAYED AFTER THE HOME BLOCKS HAVE BEEN CHECKED, BUT ALL OF THEM WILL GET
;PUT ON THE TWQ AT ONCE. THE MSCP SPEC SAYS THAT IT WOULD BE BETTER
;(BUT NOT MANDATORY) TO DO THEM ONE AT A TIME, NOT ASKING FOR ONE UNTIL THE
;PREVIOUS ONE FINISHES. TO DO THIS WE WOULD NEED A UDBSTS BIT
;***************************************************************************
	RET			;AND RETURN TO SCA

MSCI78:	CALL SETSUN		;SET UNIT NUMBER
	MOVE T3,T1		;SAVE UNIT NUMBER
	MOVE T1,MSCOLD(Q3)	;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(INF,MSCCWM,PHYMSC,HARD,<PHYMSC - Controller not in 576 mode>,<<T2,NODE>,<T1,CID>,<T3,UNIT>>,<

Cause:	The HSC controller is not in 576 bytes per sector mode.  It cannot be
	used by TOPS-20 unless it is in 576 bytes per sector mode.

Action: Set the HSC in 576 mode.

Data:	NODE - node number
	CID  - connect ID
	UNIT - unit number
>,,<DB%NND>)			;[7.1210] 
	JRST RTNBUF		;QUIT CAN'T USE THIS HSC50

MSCI38:	CALL SETSUN		;GET UNIT NUMBER
	MOVX T3,US.UNA		;SET UNAVAILABLE
	IORM T3,UDBSTS(P3)
	MOVE T3,T1		;SAVE UNIT NUMBER
	MOVE T1,MSCOLD(Q3)	;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(INF,MSCDWM,PHYMSC,HARD,<PHYMSC - Disk not in 576 mode>,<<T2,NODE>,<T1,CID>,<T3,UNIT>>,<

Cause:	A disk unit is not a 576 bytes per sector disk.  The disk unit will not
	be used.  This bug will be seen when a 16 bit HDA (used on VAX systems)
	is connected to a HSC that TOPS-20 is trying to use.

Action:	No action is required, this bug is for information only.

Data:	NODE - node number
	CID  - connect ID
	UNIT - unit number
>,,<DB%NND>)			;[7.1210] 
	JRST MSCI15
; ENTER HERE FROM A CONNECT RESPONSE AVAILABLE THAT WAS SUCCESSFUL.
; WE NOW WANT TO SET CONTROLLER CHARACTERISTICS AND FIND OUT IF THE DISK
; OR TAPE IS ONE THAT WE AN USE.

; ENTERED P2 = KDB

MSCIN5:	MOVEI P6,MSC5A		;RETURN TO MSC5AA ON RETURN FROM SET CHARACTERISTICS
	CALL SETCCH		;SET CONTROLLER CHARACTERISTICS
	 SKIPG T3,MSCCID(Q3)	;CHECK FOR VALID CONNECT ID
	RET			;ALL OK QUIT
	EXCH T1,T3		;SWAP ERROR CODE AND CID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(INF,MSCSCF,PHYMSC,SOFT,<PHYMSC - SETCCH failed to set characteristics>,<<T2,NODE>,<T1,CID>,<T3,ERRCOD>,<Q3,INDEX>>,<

Cause:	SETCHH failed to set characteristics.  This appears to be a hardware
	problem with the remote node.

Action:	Field Service should check the remote node's hardware.

Data:	NODE   - node number
	CID    - connect ID
	ERRCOD - error code
	INDEX  - MSCCID table index
>)
	RET
				;WAIT FOR SET CHARACTERISTICS TO URN

; ENTER HERE ON RETURN FROM SETCCH
; NOW WE MUST CHECK TO SEE THAT THIS IS REALLY USEFUL TYPE DISK
; AND THEN WE WILL TRY TO LOOK AT ALL THE UNITS ON THIS HSC TO
; SEE IF THEY ARE USABLE
;

MSC5AA:	MOVE T1,P.CNTF(Q2)
	CALL REVFUL		;REVERSE THE BYTES FROM THE HSC
	TXNN T1,CF.576		;DOES IT SUPPORT 576 BYTE XFERS?
	TXNE Q3,TAPSID		;CHECK FOR TAPE DRIVE
	SKIPA			;YES MUST BE OK
	JRST MSCI78		;NO. FORGET IT!
	DMOVE T1,P.CNTI(Q2)	;NEW - CONTROLLER ID
	DMOVEM T1,KDBCID(P2)
	MOVE P3,P2		;NEED POINTER OF KDB ALSO IN P3
	MOVEI T1,.BTKDB		;MARK AS A KDB
	DPB T1,USYBKT		;SET .BTKDB IN KDB
	MOVEI T1,.UTHSC		;GET CODE FOR HSC50
	STOR T1,USTYP,(P2)	;AND STORE IT INTO THE KDB
	MOVEI T1,MSCDSP		;GET CONTROLLER/UNIT DISPATCH VECTOR
	MOVEM T1,KDBDSP(P2)	;PUT IT IN KDB
	MOVX T1,KS.DSK		;GET FLAG READY
	TRNN Q3,TAPSID		;CHECK FOR TAPE
	IORM T1,KDBSTS(P2)	;REMEMBER THAT THIS CONTROLLER DRIVES DISKS
	MOVE T1,P.CTMO(Q2)	;GET CONTROLLER TIMEOUT
	CALL REVFUL		;MAKE IT USABLE
	LOAD T1,LOBYTE,T1	;GET THE LOW ORDER BYTE (THE ACTUAL TIMEOUT)
	CAIG T1,12		;CHECK FOR TIMEOUT OF 10
	MOVEI T1,12		;INSURE IT IS 10
	IDIVI T1,TIMOUT		;COMPUTE NUMBER OF OUR TIMEOUTS
	SKIPE T2		; IN 1 OF THEIRS
	ADDI T1,1
	LSH T1,1		;HSC PEOPLE LIKE *2 TIMEOUT
	MOVEM T1,MSCTMO(Q3)	;SET UP TIMEOUT INTERVAL
	MOVEM T1,MSCINT(Q3)	;SAVE THE TIMEOUT INTERVAL
	MOVX T1,DT.NXU		;SET UP NEXT UNIT FIRST PASS
	IORM T1,CIDATA(Q3)
MSCIN7:	HRRZ P2,P2		;START AT THE FIRST UNIT
	SKIPA

MSCIN8:	ADD P2,[1,,0]		;ADD 1 TO UNIT NUMBER SO WE DON'T GET OURSELVES TWICE
	HLRZ T1,P2
	MOVEI P6,MSCA8		;RETURN FROM NEXTUN TO MSCIA8
	CALL NEXTUN		;ASK THE HSC WHAT THE NEXT UNIT IS
	SKIPG T3,MSCCID(Q3)	;CHECK FOR LEGAL CONNECT ID
	RET			;DONE
	EXCH T1,T3		;SWAP ERROR CODE AND CID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(INF,MSCNXF,PHYMSC,SOFT,<PHYMSC - Get next unit failed>,<<T2,NODE>,<T1,CID>,<T3,ERRCOD>,<Q3,INDEX>>,<

Cause:	Get a next unit failed.  All the units on this HSC50 may not be found.
	This is seen most often with broken HSC hardware.

Action:	If the hardware checks out OK, and if this bug occurs often or is
	reproducible, change it to a BUGHLT and submit an SPR along with a dump
	and instructions on reproducing it.

Data:	NODE   - node number
	CID    - connect ID
	ERRCOD - error code
	INDEX  - MSCCID table index

>)
	RET
				;RETURN FROM INTERRUPT AND WAIT TILL 

;
; RETURN FROM MSCIN8 CALL TO NEXTUN
; THIS WILL HAVE THE NEW UNIT ON THE HSC STORED IN THE PACKET
; WE MUST CHECK TO SEE IF THAT UNIT IS AVAILABLE AND IF SO
; THEN WE CAN SET IT ONLINE.
;
; ENTERED WITH P2 = KDB,Q2 = PACKET ADDRESS

MSCIA8:	CALL SETSUN		;GET UNIT NUMBER
	JUMPN T1,MSCI8A		;NOT UNIT 0 THEN NOT DONE
	LOAD T3,PKYEST,(Q2)	;GET STATUS
	CAIN T3,ST%OFL		;CHECK FOR OFFLINE
	JRST RTNBUF		;GO AWAY WE ARE NOT INTERESTED IF NO DRIVES
	MOVE T3,CIDATA(Q3)	;IS THIS THE FIRST TIME?
	TXNN T3,DT.NXU		;IS THIS NEXT UNIT
	JRST RTNBUF		;QUIT ALL DONE
MSCI8A:	MOVX T3,DT.NXU		;CLEAR NEXT UNIT FLAG
	ANDCAM T3,CIDATA(Q3)	;IN STATUS
	HRLI P2,1(T1)		;REMEMBER NEXT UNIT NUMBER
	TRNE Q3,TAPSID
	JRST MSCI20		; GO ELSEWHERE WHEN WE FIND A UNIT
	SKIPE MSCINF
	JRST MSCIN9		;IF AN OLD CONTROLLER COMING BACK
	CALL SETP3		;SEARCH FOR THIS UNIT'S UDB
	 JRST MSCIN9		;NO SUCH UDB. BUILD A NEW ONE
	MOVX T1,UA.PAT		;OLD UDB. CLEAR PORT-ATTACHED BIT
	ANDCAM T1,UDBALT(P3)	; SINCE IT IS CURRENTLY NOT ATTACHED AT ALL
	HRLM Q3,UDBKDB(P3)	; SET UP THE NEW SERVER NUMBER
	SETZ P4,		;THIS DISK IS A KNOWN TYPE
	JRST MSCI12		;GO USE THE UDB
MSCIN9:	LOAD T3,PKYEST,(Q2)	;STATE OF UNIT
	CAIE T3,ST%OFL		;OFF LINE?
	JRST MSCI10		;NO
	LOAD T3,PKYQSB,(Q2)	;YES. GET REASON FOR OFFLINE
	CAIE T3,SB%NVM		;NO VOLUME MOUNTED?
	JRST MSCIN8		;UNIT IS NG, LOOK FOR NEXT
	TLO P1,-1		;REMEMBER UNIT IS OFF-LINE
	JRST MSCI11

MSCI10:	CAIE T3,ST%AVL		;UNIT IS NOT OFF LINE. AVAILABLE?
	JUMPN T3,MSCIN8		;NOT AVAILABLE. IF NOT ONLINE THEN WE CAN'T USE IT

MSCI11:	CALL UNTYPE		;SET UP UNIT TYPE IN UDB
	JRST RTNBUF		;NO ENTRY FOUND
	HRRZS P4		;ISOLATE INDEX
	CALL BLDUDB		;BUILD UNIT DATA BLOCK
	JRST RTNBUF		;NO SPACE
	TLZE P1,-1		;OFF-LINE?
	JRST MSCI17		;YES. CAN'T DO AN ONLINE COMMAND
MSCI12:	CALL PHYDUA		;(P3/) NO. SEE IF DISK IS DUAL PORTED
	HLRZ Q3,UDBKDB(P3)	;RESTORE CID INDEX
	SKIPE MSCINF		;CHECK FOR STARTUP
	JRST MSCI2Z		;YES DON'T CHECK DUAL PORT
	HRRZ T1,UDBALT(P3)	;IS IT DUAL-PORTED?
	JUMPN T1,MSCI13		;YES
	JRST MSCI14		;NO. BIND THE UNIT TO THIS CONTROLLER
MSCI2Z:	HLRZ T1,P2		;YES. GET UNIT NUMBER +1
	HRRZ T2,P2		;ISOLATE KDB ADDRESS
	XOR T1,.SBDSP(T2)	;EVEN NUMBER UNIT ON EVEN KDB OR ODD ON ODD?
	TRNE T1,1
	JRST MSCI14		;EVEN ON EVEN OR ODD ON ODD - BIND THE UNIT TO THIS KDB
	MOVX T2,US.OFS		;SET OFFLINE FOR NOW
	IORM T2,UDBSTS(P3)
	HRL P2,UDBSLV(P3)
	HRLM Q3,UDBKDB(P3)
	JRST MSCIN8		;TRY NEXT UNIT

;HERE IF WE FOUND THE UNIT ON A DIFFERENT KDB

MSCI13:	SKIPG UDBALT(T1)	;ALREADY ATTACHED ON OTHER PORT?
	JRST MSCI16		;YES. DON'T TRY TO ONLINE IT HERE
	MOVX T2,US.OFS		;NO, WE'LL ONLINE IT ON THIS PORT
	IORM T2,UDBSTS(T1)	;SO MARK THE OTHER PORT AS OFFLINE

MSCI14:	MOVE T1,UDBSLV(P3)	;UNIT NUMBER
	MOVEI P6,MSCI4M		;ONLINE RETURN
	JRST ONLINA		;ONLINE THE DISK
				;RETURN FROM COMMAND

; HERE ON RETURN FROM ABOVE ONLINE.
; THIS WILL CHECK THE STATE OF THE UNIT THAT HAS JUST BEEN REQUESTED
; TO COME ONLINE AND IT WILL THEN INFORM PHYSIO THAT THE UNIT IS
; READY TO USE.  IT ALSO CHECKS THE SIZE OF THE DISK AND SETS
; UP THE CORRECT GEOMETRY OF THE DISK.

MSCI1A:	LOAD T1,PKYEST,(Q2)	;[7233] GET STATUS OF ON-LINE ATTEMPT
	IFN. T1			;[8913] Did online succeed?
	  SKIPN CIBUGX		;[7233] NO, ARE WE DEBUGGING?
	  JRST RTNBUF		;[7233] (Q2) NO, DON'T SCARE THE OPERATOR
	  CALL SETSUN		;[7233] (Q2/T1) YES, GET UNIT NUMBER FROM THE PACKET
	  LDB T2,PKYNOD		;[7233] GET SERVER'S NODE NUMBER
	  LOAD T3,PKYEST,(Q2)	;[7233] GET THE STATUS CODE AGAIN
 	  BUG.(INF,MSCOLE,PHYMSC,HARD,<PHYMSC - Online failed>,<<T3,STATUS>,<T2,NODE>,<T1,UNIT>>,<

Cause:	An online request failed.  This has been known to happen when duplicate
	unit numbers are found, and, in some cases, when the TOPS-20 MSCP
	server returns a status of offline.

Action:	Check the remote node to see if it crashes or any other information on
	why the online failed.

Data:	STATUS - Status code in ONLINE end message
>,RTNBUF,<DB%NND>)		;[7.1210][7233]
	ENDIF.			;[7233]
	CALL SETP3		;[7233] (Q2,P2/T1,P3) SET UDB ADDRESS
	 JRST NOONL		;[7233] FAILED, THAT'S VERY BAD
	CALL GETSER		;[7233] (Q2,P3/) SET DRIVE SERIAL NUMBER IN UDB
	CALL PHYONL		;[7233] (P3) TELL PHYSIO
	TRNE Q3,TAPSID		;IS THIS TAPE?
	JRST MSCI17		;YES, WE'RE DONE WITH THIS UNIT
	MOVE T1,P.UNFL(Q2)	;NO, GET UNIT FLAGS
	CALL REVFUL		;REVERSE THE BYTES FOR THE HSC
	TXNN T1,UF.576		;IS IT A 576-BYTE DISK?
	JRST MSCI38		;NO. CAN'T USE IT
	MOVX T2,US.WLK		;YES. WRITE LOCKED?
	TXNE T1,UF.WPH+UF.WPS
	IORM T2,UDBSTS(P3)	;YES. FLAG IT
	CALL UNTYPE		;IS IT A VALID UNIT?
	 SKIPA			;NOPE
	JRST MSCI17		;YES

	MOVE T1,MSCOLD(Q3)	;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(INF,MSCUKD,PHYMSC,HARD,<PHYMSC - Unknown disk type>,<<T2,NODE>,<T1,CID>>,<

Cause:	A device on HSC is not a device recognized by TOPS-20 and is 
	not used.

Action:	No action required, this bug is for information only.

Data:	NODE - node number
	CID  - connect ID
>,,<DB%NND>)			;[7.1210] 

;HERE IF THE DISK IS 16-BIT MODE.
; 16 BIT DISKS ARE NOT USABLE TO THE PDP-10 SO WE DECLARE THEM
; OFFLINE AND DO NOT TRY TO USE THEM

MSCI15:	MOVE T1,UDBSLV(P3)	;GET UNIT NUMBER
	MOVEI P6,MSG55		;DON'T NEED RETURN FROM THIS MESSAGE
	CALL OFLINE		;MAKE IT AVAILABLE (NOT ONLINE) SINCE WE
	JFCL
	RET

NOONL:	BUG.(HLT,MSCUDB,PHYMSC,SOFT,<PHYMSC - UDB missing>,,<

Cause:	We have just set up a unit during initalization and now we can't find
	it.  This indicates a software problem.
>)				;[8913]

;RETURN HERE FROM OFFLINE

MSC15A:	CALL SETP3		;FIND THE UDB ETC
	 CALL NOONL		;OOPS WHERE DID IT GO?

;HERE IF THE UNIT IS NOT USABLE

MSCI16:	MOVX T1,US.OFS		;MAKE SURE IT DOESN'T GET USED
	IORM T1,UDBSTS(P3)
MSCI17:	HRL P2,UDBSLV(P3)	;GET UNIT NUMBER WHERE MSCIN8 NEEDS IT
	HRLM Q3,UDBKDB(P3)	;SAVE NEW CID INDEX IN UDB
	TRNN Q3,TAPSID		;CHECK FOR TAPE NO HOME BLOCKS HERE
	CALL FLGHOM		;FLAG UDB SO HOME BLOCKS WILL BE REREAD AND IO RESTARTED
	JRST MSCIN8		;GO LOOK FOR ANOTHER UNIT ON THE KDB
;ROUTINE TO TEST FOR NON-BOUND UNITS AFTER ENTIRE CONFIGURATION IS KNOWN
;IF ANY ARE FOUND IT WILL BIND THEM TO THE FIRST (OR ONLY) CONTROLLER THEY ARE ON
;ROUTINE IS CALLED FOR EVERY UDB WITH US.CIP ON IN UDBSTS

MSCI28:	MOVE T1,UDBSTS(P3)	;STATUS
	TXNN T1,US.OFS		;OFFLINE?
	TXNN T1,US.DSK		;NO. DISK?
	RET			;NOT USABLE OR NOT A DISK
	HRRZ T1,UDBALT(P3)	;ALREADY BOUND ON THIS PORT?
	JUMPL T1,R		;YES. DON'T DO IT AGAIN
	JUMPE T1,MSCI29		;IF DUAL PORTED
	MOVX T2,US.OFS		;INDICATE THE OTHER PORT IF OFFLINE
	IORM T2,UDBSTS(T1)	; SINCE WE'LL BE USING THIS PORT
MSCI29:	SAVEQ
	CALL GETBUF		;GET A BUFFER TO ONLINE WITH
	RET			;NONE WE LOST
	HLRZ Q3,UDBKDB(P3)	;CID INDEX
	MOVE T1,UDBSLV(P3)	;UNIT NUMBER
	JRST MSGAV1		;GET UNIT STATUS AND ONLINE IT
				;AND RETURN
	SUBTTL Init Assist Routines

;SUBROUTINE TO ASK THE HSC WHAT THE NEXT UNIT IS
;RETURNS +1 IF ERROR ON THE SEND
;RETURNS +2 T1/UNIT NUMBER AS RETURNED BY THE HSC

NEXTUN:	MOVE T2,[MD.NXU+OP.GUS]	;ASK HSC FOR STATUS OF NEXT UNIT
CURUN:	MOVEI T3,P%OPCD
	JRST SENDPK		;SEND PACKET

;SETSUN ROUTINE TO RETURN THE UNIT FROM A PACKET
;
;	Q2 - PACKET ADDRESS
;
;	RETURNS:	T1 UNIT NUMBER
;

SETSUN:	MOVE T1,P.UNIT(Q2)	;UNIT NUMBER
	CALL REVFUL		;REVERSE THE BYTES FOR THE HSC
	LSH T1,-4		;RIGH ADJUST ANSWER
	ANDI T1,177777		;JUST UNIT NUMBER
	RET
;ROUTINE TO SET UP UNIT TYPE IN UDB
;ENTER WITH RESPONSE TO GUS IN PACKET POINTED TO BY Q2
;RETURNS +1 IF TYPE NOT FOUND
;RETURNS +2 NORMALLY, P4/INDEX TO TYPE

UNTYPE:	MOVE T1,P.MEDI(Q2)	;MEDIA TYPE
	CALL REVFUL		;REVERSE THE BYTES FROM THE HSC
	MOVSI P4,-NUMTYP
	CAMN T1,TYPTAB(P4)	;DO WE KNOW ABOUT THIS UNIT TYPE?
	RETSKP			;YES. RETURN
	AOBJN P4,.-2
	RET			;TYPE NOT FOUND


REPEAT 0,<
;ROUTINE TO DETERMINE IF THE DEVICE IS A TAPE OR DISK.
;ENTERED WITH RESPONSE TO OP%GUS IN PACKET POINTED TO BY Q2.
;
;  RETURNS +1 IF TAPE
;  RETURNS +2 IF DISK

DRVTYP:	MOVE T1,P.MEDI(Q2)	;LOOK AT MEDIA TYPE
	CALL REVFUL		;PUT BYTES IN CORRECT ORDER
	MOVSI T2,-MAXTYP	;COUNT OF UNITS TO CHECK
	CAMN T1,TAPTYP(T2)	;CHECK TABLE FOR TAPE TYPES
	RET			;FOUND TAPE TYPE
	AOBJN T2,.-2		;LOOP TILL ALL TYPES SEARCHED
	RETSKP			;MUST BE DISK TYPE
> ;END REPEAT

;SUBROUTINE TO BUILD A UNIT DATA BLOCK
;CALL P2/UNIT+1,,KDB
;	Q2/PACKET ADDRESS
;	Q3/MSCCID INDEX
;RETURNS +1 IF NO SPACE TO CREATE THE UDB
;RETURNS +2 NORMALLY, P3/UDB ADDRESS

BLDUDB:	SAVEQ
	MOVE Q1,Q2		;SAVE Q2 FOR SETUDB
	LDB Q2,PKYNOD		;UNIT NUMBER IS THE NODE NUMBER
	MOVE T3,[MSCDSP,,UDBDDD]
	CALL PHYUDB
	 JRST UDBXTA		;LOSE
	MOVE T1,SIZTAB(P4)	;SET UP VARIABLE PART OF UDB
	HLRZM T1,UDBSIZ(P3)
	HRRZS T1
	TXO T1,US.OFS+US.DSK+US.CIP+US.2PT ;[7.1276] Indicate it's a CI disk, dual-ported, and off-line
	IORM T1,UDBSTS(P3)
	MOVX T1,U1.NOL		;[7.1276] Say we haven't been onlined yet
	IORM T1,UDBST1(P3)	;[7.1276] Set the bit in the correct word
	MOVE Q2,Q1		;RESTORE PACKET BUFFER ADDRESS
	CALLRET SETUDB		;SET UP UDB
				;RETURN +1 OR +2 DEPENDING ON SETUDB
;SUBROUTINE TO PUT P.STS INTO CORRECT (REVERSED BYTES) ORDER
;CALL WITH Q2=ADDRESS OF BUFFER

REVSTS:	MOVE T1,P.STS(Q2)	;PICK UP STATUS WORD
	CALL REVFUL		;MAKE IT LOOK LIKE WE WANT IT
	MOVEM T1,P.STS(Q2)	;STORE BACK IN THE PACKET
	RET			;AND RETURN
	SUBTTL General Routines

;THIS ROUTINE WILL BUILD A GENERAL PACKET TO BE USED
;BY ALL ROUTINES.  IT FIRST BUILDS A UNIQUE COMMAND REFERENCE
;NUMBER THAT CAN BE USED TO IDENTIFY THE TYPE OF REQUEST.
;IT ALSO DOES A LIMITED AMOUNT OF CHECKING TO SEE THAT
;THE SEND WAS SUCCESSFUL.  IF NOT THEN IT DECLARES THE
;UNIT TO BE GONE AND WAITS FOR THE POLLER TO PICK
;THIS UP AND TRY AND RE-START THE SEQUENCE.
;THIS ROUTINE IS NOT USED FOR DATA TRANSFERS AND
;THE LEFT HALF OF P6 CONTAINS THE INFORMATION ON WHERE
;TO GO AFTER THE COMPLETION OF THE PACKET. IF THE LEFT
;HALF OF P6 IS -1 THEN A RETURN IS NOT REQUIRED AND NO-ONE
;GETS CALLED ON COMPLETION OF THE PACKET.
;SUBROUTINE TO SEND A PACKET 
;CALL Q3/CONNECT ID INDEX
;	Q2/PACKET ADDRESS
;	P6/REQUEST CODE
;	RH(P2)/SB ADDRESS
;	T1/UNIT NUMBER, RIGHT JUSTIFIED
;	T2/OPCODE+MODIFIERS
;	T3/LENGTH OF PACKET

;	RETURN +1 ERROR CODE IN T1-- PACKET RETURNED!
;	RETURN +2 SUCCESS
SENDPK:	SAVEAC <P6>		;SAVE A REGISTER
	MOVEI T4,1B31		;BUMP COMMAND REFERENCE NUMBER
	ADDB T4,CRFNUM
	TLZE T4,-1		;MAKE SURE LH STAYS 0
	MOVEI T4,1B31		;INSURE THAT COMMAND REFERENCE NUMBER IS NON-ZERO
	MOVEM T4,CRFNUM		; (LH NON-0 IS A PC)
	HRRM P6,CIDATA(Q3)	;SAVE THE ID OF THE LAST REQUEST
	LSH P6,4
	HRL T4,P6		;SAVE REQUEST TYPE IN REFERENCE NUMBER
	MOVEM T4,P.CRF(Q2)	;SAVE AS COMMAND REFERENCE NUMBER
	LSH T1,4		;POSITION UNIT FOR HSC

	CALL SRVFUL		;REVERSE THE WORD FOR THE HSC, PRESERVE ACS
	MOVEM T1,P.UNIT(Q2)	;SAVE IN PACKET
	MOVE T1,T2		;OPCODE, MODIFIERS
	CALL SRVFUL		;REVERSE FOR THE HSC
	MOVEM T1,P.OPCD(Q2)	;OPCODE + MODIFIERS
	MOVX T1,KLPX9		;SET NO VC OPEN
	SKIPG T4,MSCCID(Q3)
	JRST SNDERA		;CONNECT HAS GONE AWAY
	BLCAL. (SC.SMG,<T4,[0],T3,Q2,[MSCPRI],[0],[0]>) ;SEND THE PACKET
	 JRST SNDERA		;LOST CHECK TO SEE WHY
	AOS MSCSNT		;[7211] COUNT THE MESSAGE
	RETSKP
SNDERA:	MOVE P6,T1		;SAVE THE ERROR CODE
	CALL RTNBUF
	MOVEM P6,T1
	RETBAD ()		;RETURN THE ERROR
;ROUTINE TO SET UP UDB
;CALL P2/UNIT+1,,KDB
;	P3/UDB
;	Q2/PACKET ADDRESS
;	Q3/MSCCID INDEX
;
;	RETURNS +1 IF TOO MANY UNITS
;	RETURNS +2 IF ENTERED

SETUDB:	HRRZ T1,P2		;SBK ADDR
	MOVE T1,KDBIUN(T1)	;POINTER TO UNITS
	SKIPE (T1)		;FIND THE NEXT FREE SLOT
	AOBJN T1,.-1
	JUMPG T1,UDBXTA		;TOO MANY UNITS IF POSITIVE
	HRRZM P3,(T1)
	HRRZM P2,UDBKDB(P3)	;SAVE POINTER TO KDB
	HRLM Q3,UDBKDB(P3)	;UDBKDB=CID INDEX,,SYSTEM BLOCK ADDRESS
	HLRZ T1,P2		;UNIT NUMBER
	SUBI T1,1
	HRRZM T1,UDBSLV(P3)	;SAVE IN UDB
	CALL GETSER		;(Q2,P3/) RE SETUP UDBDSN,UDBDSH.
	RETSKP			;AND WE'RE DONE

;GETSER - GET THE DRIVE SERIAL NUMBER
; Q2/ PACKET
; P3/ UDB
;	CALL GETSER		;(Q2,P3/)
; RETURN +1

GETSER:	STKVAR <DSN>		;LOW-ORDER DSN WORD
	MOVE T1,P.UNTI(Q2)	;PUT UNIT ID INTO REASONABLE CONDITION
	CALL REVFUL
	LSH T1,-4
	MOVEM T1,DSN		;STASH IT
	MOVE T1,P.UNTI+1(Q2)
	CALL REVFUL
	LSH T1,-4
	MOVE T2,DSN		;RETRIEVE LOW-ORDER WORD
	CALL SETDSN		;(T1,T2,P3/) SET DRIVE SERIAL NUMBER
	RET

	ENDSV.

UDBXTA:	BUG.(INF,MSCTMU,PHYMSC,HARD,<PHYMSC - Too many units for KDB>,<<P2,KDB>,<P1,CHN>>,<

Cause:	There are more than PRTMXU units on a particular HSC, therefore there
	is not enough room in the KDB for UDB entries.

Action:	If you want to support more than PRTMXU units on a HSC, a source
	rebuild of the monitor is required.  Change the symbol PRTMXU in SCAPAR
	and rebuild PHYMSC and PHYKLP.

Data:	KDB - KDB address
	CHN - Channel
>,,<DB%NND>)			;[7.1210] 
	RET			;RETURN WITH ERROR FOR NO ROOM
;HERE TO EXECUTE AN CALL TO MSCI28 ONCE FOR EACH UDB ON A CI CHANNEL

;CALL DGIMAP

;THE CALL TO MSCI28 WILL BE EXECUTED ONCE WITH P3 SETUP TO EACH UDB

DGIMAP:	SAVEPQ
	MOVEI P4,KLPRH2		;KLIPA CHANNEL
DGIMA1:	MOVX T1,CS.CIP
	SKIPE P1,CHNTAB(P4)	;CHAN EXIST?
	TDNN T1,CDBSTS(P1)	;YES. IS IT A CI CHAN?
	RET			;NO. RETURN
	CALL DGUMAP		;YES. DO INSTR FOR EACH UDB
	 CALL MSCI28		;INSTRUCTION TO EXECUTE
	RET			;DONE

;ROUTINES TO ONLINE, OFFLINE A DISK
;CALL P1,P2,P3 POINTING AT CDB,KDB,UDB
;	P6/REQUESTED RETURN ADDRESS CODE
;	T1/UNIT NUMBER
;	Q3/MSCCID INDEX
;RETURNS +1 ERROR
;RETURNS +2 SUCCESSFUL QUEUE OF REQUEST 

OFLINE:	MOVEI T2,OP.AVL		;OPCODE=AVAIL
	MOVEI T3,P%OPCD		;SIZE OF PACKET
	CALLRET SENDPK		;SEND PACKET

ONLINE:	MOVEI T2,OP.ONL		;OPCODE = ONLINE
	MOVEI T3,P%SHUN		;SIZE OF PACKET
	TXNE Q3,TAPSID		;TAPE OR DISK?
	JRST ONLTAP		;TAPE WE NEED TO DO SPECIAL WORK
	MOVX T4,UA.PAT		;INDICATE UDB IS ONLINE VIA THIS PORT
	IORM T4,UDBALT(P3)
	MOVX T4,US.UNA		;CLEAR UNIT UNAVAILABLE FLAG
	ANDCAM T4,UDBSTS(P3)
	MOVX T4,U1.NOL		;[7.1276] Say we have seen this disk
	ANDCAM T4,UDBST1(P3)	;[7.1276] By clearing this bit
;********************************************************************
	MOVEI T4,44000		;TEMP FIX TO ONLINE/OFLINE BUGCHK
;	MOVEM T4,13(Q2)		;TO BE REMOVED WHEN BUG IS FIXED IN FLAGS************
;********************************************************************
	SETZM P.DVPM(Q2)	;CLEAR DEVICE PARAMETERS
	SETZM P.SHUN(Q2)	;CLEAR SHADOW AND COPY SPEED
	CALLRET SENDPK		;SEND PACKET

ONLTAP:
	MOVX T4,US.BOT		;ASSUME BOT
	IORM T4,UDBSTS(P3)
	CALLRET SENDPK		;SEND ONLINE REQUEST
;ROUTINE TO SET CONTROLLER CHARACTERISTICS
;CALL Q3/MSCCID INDEX
;	P6/REQUESTED RETURN ADDRESS CODE
;RETURNS +1 ON ERROR
;RETURN +2 IF OK

SETCCH:	CALL GETBUF		;GET A BUFFER
	 RET			;NONE??????
	$LDCID P2,MSCCID(Q3)	;GET CB ADDRESS
	MOVE P2,.CBSBA(P2)	;SET SYSTEM BLOCK ADDRESS
	HRRZ P1,.SBACD(P2)
	SKIPG TADIDT		;HAVE THE TIME?
	JRST [SETZB T1,P.TIME+1(Q2) ;NO. CLEAR TIME SINCE WE DON'T KNOW IT
		JRST SETCC1]	;COME BACK LATER AND TELL IT THE RIGHT TIME
	CALL LGTAD		;NO. GET CURRENT TIME
	MOVE T2,TIMZON		;DIFFERENCE BETWEEN LOCAL TIME AND GMT
	IMULI T2,ZON2TM		;COMPUTE DIFFERENCE IN TIME-UNITS
	SUB T1,T2		;CONVERT GMT TO LOCAL TIME
	MUL T1,VAXTIM		;CONVERT TIME TO VAX'S REPRESENTATION
	LSH T2,1
	LSHC T1,-5
	DPB T2,[POINT 32,P.TIME(Q2),31] ;SAVE LOW ORDER TIME
	LSHC T1,-^D28
	MOVE T1,T2
	TRZ T1,17		;CLEAR THE EXTRANEOUS BITS
	CALL REVFUL		;REVERSE THE BYTES FOR THE HSC
	MOVEM T1,P.TIME+1(Q2)	;SAVE HIGH ORDER TIME
	MOVE T1,P.TIME(Q2)	;PICK UP LOW-ORDER TIME
	CALL REVFUL		;'CAUSE 11'S DO IT BACKWARDS
SETCC1:	MOVEM T1,P.TIME(Q2)	;MAKE IT UNDERSTANDABLE
	SETZM T1,P.HTMO(Q2)
	MOVX T1,CF.MSC+CF.THS+CF.576
	TXO T1,CF.ATN		;ENABLE FOR ATTENTION MESSAGES TOO
	CALL REVFUL		;REVERSE THE BYTES FOR THE HSC
	MOVEM T1,P.CNTF(Q2)	;SAVE CONTROLLER FLAGS, MSCP VERSION = 0
	MOVEI T2,OP.SCC		;SET CONTROLLER CHARACTERISTICS
	SETZB T1,P.CDPR(Q2)	;CONTROLLER DEPENDENT PARAMS ARE 0
	MOVEI T3,P%CDPR
	JRST SENDPK		;SEND PACKET

	SUBTTL Periodic Check
;
;THE POLLER HAS THE TASK OF FINDING OUT IF ALL THE UNITS ARE REALLY
;WORKING AND IN USE.  BESIDES MAKING PERIODIC CHECKS IT WILL
;SET THE TIME IN THE HSC CONTROLLERS THE FIRST TIME IT FINDS THAT
;TOPS-20 HAS THE TIME AND DATE.

; IF THE POLLER FINDS THAT THE HSC HAS FORGOTTEN US IT WILL TRY
; TO DISCONNECT AND RE-CONNECT.  THIS IS SUPPOSED TO CLEAN UP THE
; DATABASE AT THE HSC AND ALLOW US TO RE-START.  IF THIS FAILS
; THEN WE WILL TRY THE MORE DRASTIC APPROACH AND TRY AND RE-START
; THE HSC.  THIS IS A MUCH MORE DRASTIC THING TO DO SINCE IT MAY
; TAKE QUITE A WHILE FOR THE HSC-50 TO RE-START ITSELF FROM
; SCRATCH AND IN THE MEAN TIME WE CAN DO NOTHING WITH THE DISK
; OR TAPE TRANSFERS THAT ARE WAITING.

MSCCHK::MOVEI T1,^D1000		;RESET
	MOVEM T1,MSCTIM		; FOR SCHEDULER CLOCK
	SAVEPQ
	EA.ENT			;GET INTO SECTION 1
	SKIPE MSCITD		;DON'T DO ANYTHING IF NOT INITED
	SKIPG TADIDT		;DO WE KNOW THE TIME?
	RET
	AOSE T1,HAVTIM		;FIRST TIME?
	JRST MSCCH2		;NO
	SETZ Q3,		;YES. TELL THE MSCP SERVERS THE CORRECT TIME
MSCCH1:	SKIPG T1,MSCCID(Q3)	;SERVER EXIST?
	JUMPE T1,MSCCA2		;NO, CHECK NEXT ONE
	JUMPL T1,MSCCA2		;NOT REALLY READY YET STILL CONNECTING
	SETO P6,		;DON'T NEED RETURN FROM SET CHARACTERISTICS
	MOVE T1,CIDATA(Q3)	;YES. GET STATE OF SERVER
	TXNN T1,DT.GAW		;ARE WE CONNECTED TO IT?
	CALL SETCCH		;YES. DO A SET CONT. CHAR. (WITH CURRENT TIME)
	JFCL			;DON'T CARE IF ERROR WE WILL DO IT LATER
MSCCA2:	CAIGE Q3,CTABSZ-1	;AT THE END OF THE TABLE?
	AOJA Q3,MSCCH1		;NO, TRY NEXT ONE
MSCCH2:	MOVE T1,HAVTIM		;CHECK FOR INIT DONE
	CAIE T1,10		;IF DONE THEN WE CLEAR INIT FLAG
	JRST MSCCB2
	SETZM MSCINF
	CALL DGIMAP
MSCCB2:	SOSLE MSCHSC		;TIME TO GET COMMAND STATUS?
	RET			;NO. WE'RE DONE
	SETZ Q3,		;YES. START AT THE BEGINNING
	MOVEI T1,TIMOUT
	MOVEM T1,MSCHSC		;RESET TIMER

MSCCH3:	CAIL Q3,C%SBLL		;END OF LOOP?
	RET			;ALL DONE
	MOVE T2,CIDATA(Q3)
	TXNN T2,DT.GAW		;GONE AWAY?
	JRST MSCC3A		;NO CONTINUE
;HERE ON 1ST POLL AFTER WE DISCONNECTED
MSCCH6:	HRRO Q1,Q3		;DO ONLY ONE NODE
	CALL MSCIN2		;FOUND IT. TRY TO RECONNECT
	AOJA Q3,MSCCH3		;GO CHECK NEXT CID

MSCC3A:	TXNE T2,DT.GCS		;STILL HAVE AN OUTSTANDING GCS COMMAND?
	JRST [	SOSL MSCTMO(Q3)	;DECREMENT COUNT WHILE WAITING
		JRST MSCC44	;NOT TIMEOUT CHECK STATUS
		CAIG Q3,C%SBLL-1
		CALL DEDKON	;OOPS LOST HIM SINCE HE ISN'T TALKING
		AOJA Q3,MSCCH3]	;GO TO NEXT NODE
	TXNN T2,DT.IRC		;RELOADING?
	JRST MSCC3F
	MOVX T2,DT.IRC		;SET UP BEFORE TURNING OF PI
	HRRZ T3,CIDATA(Q3)
	IOPIOF			;TURN OF INTERRUPTS TO INSURE NO CHANGE
	TDNN T2,CIDATA(Q3)	;RE-CHECK STATE
	JRST MSCC3D		;NOT SAME QUIT
	CAIG T3,CONTMO		;CHECK FOR TOMEOUT
	JRST MSCC3B
	MOVE T1,MSCOLD(Q3)	;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(INF,MSCCRN,PHYMSC,SOFT,<PHYMSC - Connect did not complete in reasonable timeout>,<<T2,NODE>,<T1,CID>,<Q3,INDEX>>,<

Cause:	There was a connect request and no response.  The remote node probably
	is sick or has gone away.

Action:	Check the status of the remote node, and reload it if needed.

Data:	NODE  - node number
	CID   - connect ID
	INDEX - MSCCID table index
>)
	BLCAL. (SC.DIS,<MSCOLD(Q3),[0]>)
	JFCL			;IGNORE ERROR AFTER ABORT
	MOVX T2,DT.KEP		;CLEAR STATUS
	ANDM T2,CIDATA(Q3)
	MOVX T2,DT.GAW		;INDICATE GONE SO WE WILL RETRY LATER
	IORM T2,CIDATA(Q3)

MSCC3B:	AOS CIDATA(Q3)
MSCC3D:	IOPION
MSCC3F:	SKIPG P2,MSCCID(Q3)	;ARE WE HERE STILL?
	AOJA Q3,MSCCH3		;NO TRY AGAIN LATER
	CALL GETBUF		;GET A BUFFER FROM SCA
	 RET			;NONE AVAILABLE BETTER QUIT NOW
	$LDCID P2,P2		;YES. GET ADDR OF CB
	MOVE P2,.CBSBA(P2)	;SB ADDR
	HRRZ Q1,.SBQOR(P2)	;1ST (OLDEST) ITEM ON QUEUE
	CAIN Q1,.SBQOR(P2)	;EMPTY QUEUE?
	JRST MSCCH4		;YES
	MOVE T1,QORCRF(Q1)	;NO. GET COMMAND REF NUMBER
	HLRZ P1,QORUNI(Q1)	;GET ASSOCIATED UNIT
	SKIPA P1,UDBSLV(P1)	;GET MSCP UNIT NUMBER
MSCCH4:	SETZB T1,P1		;IDLE - UNIT=COMMAND REF = 0
	MOVEM T1,P.OTRF(Q2)	;SAVE REF NUMBER WE WANT AN ANSWER FOR
	MOVE T1,P1		;UNIT
	LSH T1,4		;POSITION IT
	MOVX T2,DT.GCS		;SET STATUS AS GET COMMAND STATUS
	IORM T2,CIDATA(Q3)
	MOVEI T2,OP.GCS		;OP IS GET COMMAND STATUS
	MOVEI T3,P%OTRF		;LENGTH OF MESSAGE
	MOVEI P6,MSCH30
	CALL SENDPK		;SEND THE COMMAND
	SKIPA T1,[DT.GCS]	;CLEAR NO BITS SO WE COME BACK HERE
	SKIPA			;GCS SUCCEEDED
	ANDCAM T1,CIDATA(Q3)	; GCS COMMAND
	MOVE T1,MSCINT(Q3)	;SET UP INTERVAL
	MOVEM T1,MSCTMO(Q3)
MSCC44:	SKIPG T2,MSCCID(Q3)	;GET CID
	AOJA Q3,MSCCH3		;TRY NEXT CONNECTION
	$LDCID T2,T2		;CB ADDR
	MOVE P2,.CBSBA(T2)	;SB ADDR
	JUMPE P2,MSC4L1		;NONE QUIT NOW....
	MOVE Q1,KDBIUN(P2)	;POINTER TO UDB'S
	HRRZ P1,CHNTAB+KLPRH2	;GET CHAN POINTER
MSC4L:	SKIPN P3,(Q1)		;FOUND ONE?
MSC4L1:	AOJA Q3,MSCCH3		;NOPE DON'T NEED TO CHECK IT
	MOVX T1,US.OFS!US.WLK	;[7465] CHECK FOR OFFLINE AND WRITE LOCKED
	MOVX T3,US.UNA!US.TPD	;AND CHECK FOR UNAVAILABLE
	TDNN T3,UDBSTS(P3)	;DON'T TRY TO PUT BACK ONLINE IF UNAVAILABLE (16 BIT DISK FOR NOW)
	TDNN T1,UDBSTS(P3)	;IS IT?
	JRST [ IOPIOF		;TURN OFF INTERRUTPS
		CALL UNQUNT	;START I/O ON THIS UNTE IF POSSIBLE
		JFCL		;NO PROBLEM ON FAILURE
		IOPION		;INTERRUPTS BACK ON
		AOBJN Q1,MSC4L	;NO CHECK NEXT UNIT
		AOJA Q3,MSCCH3]	;LAST UNIT QUIT
	CALL ONLCHK		;FOUND A UNIT THAT SHOULD BE ONLINE
	AOBJN Q1,MSC4L		;TRY NEXT UNIT

	AOJA Q3,MSCCH3		;SEE IF ANOTHER NODE EXISTS

;HERE WHEN WE GET AN ANSWER TO THE GCS
MSCC10:	MOVX T2,DT.GCS		;CLEAR GCS-IS-OUTSTANDING BIT, INITIATED A DISCONNECT
	ANDCAM T2,CIDATA(Q3)
	SKIPN T1,P.OTRF(Q2)	;REAL COMMAND REF NUMBER?
	JRST MSCC11		;NO. NOTHING TO CHECK
	HRRZ T2,.SBQOR(P2)	;YES. GET OLDEST OUTSTANDING COMMAND
	CAIE T2,.SBQOR(P2)	;IS THE QUEUE NOW EMPTY?
	CAME T1,QORCRF(P2)	;NO. IS THIS STILL THE OLDEST?
	JRST MSCC11		;THE COMMAND WE ASKED ABOUT HAS COMPLETED
	MOVE T1,P.CMST(Q2)	;THIS IS STILL THE OLDEST. GET ITS STATUS
	CALL REVFUL
	CAML T1,CICMST(Q3)	;HAS WORK BEEN DONE FOR IT?
	CALLRET DEDKOA		;NO. THEY'VE GONE OFF THE DEEP END
	MOVEM T1,CICMST(Q3)	;YES. SAVE NEW STATUS
MSCC11:	CALLRET RTNBUF		;GIVE THE BUFFER BACK TO SCA AND RETURN

;HERE TO TRY TO GET THE STATUS OF A DRIVE THAT IS OFFLINE
;BECAUSE IT SEEMS THAT WE MAY NOT ALWAYS GET AN AVAILABLE
;STATUS BACK FROM THE HSC.

ONLCHK:	CALL GETBUF		;GET A BUFFER FROM SCA
	 RET			;OOPS NONE AVAILABLE NOW
	MOVE T1,UDBSLV(P3)	;GET UNIT NUMBER
	MOVE P1,.SBACD(P2)	;GET THE CDB ADDRESS
	MOVEI T2,OP.GUS		;GET STATUS OF UNIT  
	MOVEI P6,ONLC1		;CODE FOR RETURN
	CALL CURUN		;GET STATUS OF CURRENT UNIT
	RET			;DON'T CARE ERROR RETURN
	RET

;HERE ON RETURN FROM GET CURRENT UNIT STATUS
; NOW WE CHECK THE STATUS OF THE UNIT AND IF IT IS REALLY
; THERE THEN WE CAN PUT IT ONLINE.  IF IT IS OFFLINE THEN
; WE JUST FORGET IT TILL THE NEXT TIME THRU THE POLLER.

ONLCK1:	CALL SETP3		;SET UNIT NUMBER
	JRST RTNBUF		;NO UNIT FOUND QUIT
	MOVE T1,P.UNFL(Q2)	;[7465] Get unit flags
	CALL REVFUL		;[7465] (T1/T1) Byte forward-ize T1
	TXNE T1,UF.WPH!UF.WPS	;[7465] Write protected??
	RET			;[7465] Yes, no need to bring online then
	MOVX T1,US.WLK		;[7465] Get write lock bit
	ANDCAM T1,UDBSTS(P3)	;[7465] Unit no longer write locked
	MOVX T1,US.OFS		;[7465] Get offline bit
	TDNN T1,UDBSTS(P3)	;[7465] Was drive offline?
	RET			;[7465] Nope, don't waste anymore time
	LOAD T3,PKYEST,(Q2)	;GET STATUS OF UNIT
	CAIE T3,ST%AVL		;AVAILABLE NOW?
	JUMPN T3,RTNBUF		;NO TRY AGAIN LATER 
	MOVE Q1,UDBSLV(P3)	;GET THE UNIT NUMBER TO Q1
	CALLRET MSGAV3		;TRY AND ONLINE THE THING

;HERE IF THE CONTROLLER IS INSANE
DEDKOA:	MOVE T1,MSCOLD(Q3)	;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(INF,MSCCTO,PHYMSC,SOFT,<PHYMSC - Request HSC disconnect - command timeout>,<<T2,NODE>,<T1,CID>>,<

Cause:	The HSC has not correctly responded to Get Command Status request.

Action:	Check the remote node for evidence of problems and reload it if needed.

Data:	NODE - node number
	CID  - connect ID
>)
	CALL RTNBUF			;RETURN BUFFER
	TXNE Q3,TAPSID			;CHECK FOR TAPE
	RET				;IGNORE DON'T WANT TO LOOSE DISKS
	JRST DEDKN3
DEDKON:	MOVE T1,MSCOLD(Q3)	;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(INF,MSCDIS,PHYMSC,SOFT,<PHYMSC - Request HSC disconnect>,<<T2,NODE>,<T1,CID>,<Q3,INDEX>>,<

Cause:	The messages from the HSC indicate a problem.  The HSC has probably
	crashed.  The HSC is disconnected and reconnected.

Action:	Check the remote node for evidence of problems.

Data:	NODE   - node number
	CID    - connect ID
	INDEX  - MSCCID table index
>)
DEDKN3:	IOPIOF
	SKIPG T2,MSCCID(Q3)	;GET CONNECT ID
	JRST DEDKN1		;NO CONNECT THERE DON'T DISCONNECT
	CALL PBRCOA		;MARK THE UNITS OFF-LINE
	SETOM MSCCID(Q3)	;SET IT SO NO-ONE CAN USE THIS AGAIN
	IOPION			;TURN INTERRUPTS BACK ON
	BLCAL. (SC.DIS,<MSCOLD(Q3),[0]>) ;DO THE DISCONNECT
	 JFCL
	SKIPA

DEDKN1:	IOPION
	SKIPG T1,CIDATA(Q3)	;DISK SERVER?
	RET			;TAPE DRIVER. IGNORE IT IF DISKS OK
	TXOE T1,DT.DI1		;DISK DRIVER. HAVE WE TRIED DISCONNECT/RECON BEFORE?
	JRST DEDKN2		;YES. IT'S TIME TO REBOOT THEM
	MOVEM T1,CIDATA(Q3)	;NO. TRY IT NOW
	MOVE T1,CIDATA+1(Q3)	;ASSOCIATED TAPE DRIVER
	TXNN T1,DT.GAW		;ARE WE CONNECTED TO IT?
	TXOE T1,DT.DI1		;AND HAVEN'T DISCONNECTED YET?
	RET			;DON'T NEED TO DO ANYTHING TO IT
	RET			;NO TAPES FOR NOW.....
	TXO Q3,TAPSID		;LOOK AT TAPES
	MOVEM T1,CIDATA(Q3)	;DISCONNECT FROM THE TAPE SERVER TOO
	SKIPG T1,MSCCID(Q3)	;CONNECTED?
	JRST DEDKNA
	BLCAL. (SC.DIS,<T1,[0]>)
	 JFCL
DEDKNA:	TXZ Q3,TAPSID		;BACK TO DISKS
	RET			;AND TEST NEXT SERVER

;HERE IF THE DISCONNECT/RECONNECT DIDN'T FIX THE PROBLEM

DEDKN2:	MOVE T1,MSCOLD(Q3)	;GET CONNECT ID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(INF,MSCRLD,PHYMSC,SOFT,<PHYMSC - HSC control reload initiated>,<<T2,NODE>,<T1,CID>>,<

Cause:	After a disconnect and reconnect to the HSC to clear up problems, the
	HSC is still not responding correctly and is reloaded.

Action:	Check the remote node for evidence of problems.

Data:	NODE - node number
	CID  - connect ID
>,,<DB%NND>)			;[7.1210] 

;HERE TO RELOAD THE HSC
;
;CALL: Q3 = INDEX INTO CID

HSCREL:	MOVE T1,MSCOLD(Q3)	;GET CID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BLCAL. (SC.RST,<T2,[1]>) ;RESET THE REMOTE
	JRST HSCABT		;COMPLAIN ABOUT FAILURE
	BLCAL. (SC.STA,<T2,[0],[0]>) ;START IT AT DEFAULT
	JRST HSCABT
	RET			;DONE SEE YA NEXT TIME.

HSCABT:	MOVE T3,T1		;MOVE ERROR CODE
	MOVE T1,MSCOLD(Q3)	;GET CID
	CALL SC.NOD		;(T1/T1,T2) GET NODE NUMBER
	BUG.(CHK,MSCRLF,PHYMSC,SOFT,<PHYMSC - Start or reset failed>,<<T2,NODE>,<T1,CID>,<T3,ERRCOD>>,<

Cause:	After problems were seen with a HSC, a disconnect and reconnect was
	tired.  The problems were not cleared up, it was sent a message to
	reload itself.  The HSC was unable to restart or reset.

Action:	Check the remote node for evidence of problems.

Data:	NODE   - node number
	CID    - connect ID
	ERRCOD - error code
>)
	RET


	SUBTTL CNFIG% JSYS Support -- CFHSC (Return list of HSC node names)
IFN CFSSCA,<

; Expects the following to be setup by .CNFIG entry code in JSYSA:
;
; P1/  Function code (in this case, .CFHSC)
; Q2/  Address of user block
; Q3/  Contents of user argument .CFNHN

; This subroutine will use the following registers:
;
; Q1/  Address of monitor block containing returned data
; P1/  Address of byte pointers in returned data block
; P2/  Address of HSC host names in returned data block
; P3/  AOBJN pointer
; P4/  Running address for byte pointers into users block
; P5/  Address of HSC name (in SC.RCD block)

CFHSC::	TRVAR <<CFHSCB,C%SBLL*3+1>,RCDBLK,<HSCNAM,2>>

;First, count up the number of HSCs in the system.

	CIOFF			;Shut off the CI so we get an accurate count
	SETZM T4		;T4/ Count of HSCs in system
	MOVSI P3,-C%SBLL	;P3/ AOBJN pointer into MSCCID
	DO.
	  SKIPG MSCCID(P3)	;Is there an MSCP connection to this node?
	  IFSKP.		;Yes
	    MOVX T2,DT.KL
	    TDNN T2,CIDATA(P3)	;Is this system an HSC50?
	    AOS T4		;Yes, count this node as an HSC
	  ENDIF.
	  AOBJN P3,TOP.		;Check every possible HSC connection
	ENDDO.

	XMOVEI Q1,CFHSCB	;Q1/ Address of monitor block
	STOR T4,CF%NHN,.CFNHN(Q1)  ;Store the number of HSC nodes found
	MOVEI P4,.CFHP1(Q2)
	ADD P4,T4    		;P4/ Running pointer into user block
	XMOVEI P1,.CFHP1(Q1)	;P1/ Place to store byte pointers
	MOVE P2,P1
	ADD P2,T4    		;P2/ Place to store host names

; Here is our main loop to get the names and stash them.

	MOVE T1,[XWD .RESP1,.RDLEN]  ;Priority,,Length of free space
	MOVEI T2,.RESGP		;Get space from resident free pool
	CALL ASGRES		;(T1,T2/T1) Obtain block
	IFNSK.			;Error - could not get a free space block
	  CION			;Turn on the CI
	  ITERR (MONX05)	;Return the error
	ENDIF.
	MOVEM T1,RCDBLK		;Save block address
	MOVSI P3,-C%SBLL	;P3/ AOBJN pointer into MSCCID
	DO.
	  SKIPG MSCCID(P3)	;Is there an MSCP connection to this node?
	  IFSKP.		;Yes
	    MOVX T2,DT.KL
	    TDNE T2,CIDATA(P3)	;Is this system an HSC50?
	    ANSKP.		;Yes
	      HRRZ T1,P3	;Get node number
	      MOVE T4,RCDBLK	;Get block address
	      BLCAL. (SC.RCD,<<T1>,<T4>>)  ;Get configuration of this node
	       JRST CFHS1	;Error - skip this node
	      HRR T2,P4		;Get the current offset pointer for user block
	      HRLI T2,(POINT 7,)
	      MOVEM T2,0(P1)	;Store the byte pointer to the name
	      AOS P1  		;Go to next byte pointer entry in block
	      ADDI P4,2		;Go to next offset location into user block
	      MOVE P5,RCDBLK	;Get address of SC.RCD block
	      ADDI P5,.RDNNM	;Point to location of HSC name
	      DMOVE T1,(P5)	;Get the HSC name
	      DMOVEM T1,HSCNAM	;... and stash it in HSCNAM because
	      MOVEI P5,HSCNAM	;... ASC8T7 expects section 0/1 pointer to name
	      CALL ASC8T7	;(P2,P5) Copy name to returned block and convert 
	      ADDI P2,2		;Point to start of next node name text area
	  ENDIF.
CFHS1:	  AOBJN P3,TOP.		;Continue at next entry in MSCCID
	ENDDO.

 	CION			;Turn on the CI again
	MOVE T1,RCDBLK		;Get the address of the SC.RCD block
 	CALL RELRES		;(T1) Return block to free pool

; Set up the initial values in the returned block.

	LOAD T1,CF%NHN,.CFNHN(Q1)  ;The number of HSC nodes found
	MOVEM T1,P3		;Save this number
	IMULI T1,3		;The number of nodes times 3
	AOS T1  		;...plus 1 is maximum number of words returned
	CALL CFLND2		;(T1,Q1,Q2,Q3) Setup the first returned word
	STOR P3,CF%NHN,.CFNHN(Q1)  ;Restore the number of HSC nodes found
	CALL CFRET		;(Q1,Q2,Q3) Transfer monitor data block to user
	RETSKP			;Done
	ENDTV.
>				;End of IFN CFSSCA

RS LCRDT,1			;COUNT OF TIMES RAN OUT OF CREDIT

	SUBTTL Storage

DCREDT==1			;CREDIT BEFORE NOTICE
TCREDT==^D1			;MIN TAPE CREDIT
HSCBFN==^D30			;NUMBER OF BUFFERS HSC SHOULD KEEP FOR US
HSCBFT==^D15			;NUMBER OF TAPE BUFFERS IT SHOULD KEEP
DGNUM==^D5			;NUMBER OF DATAGRAM BUFFERS WE NEED
HSCDGL==^D96			;MAX DATAGRAM LENGTH
TIMOUT==^D10			;CONTROLLER TIMEOUT INTERVAL
CTABSZ==2*C%SBLL*MAXPRT		;SIZE OF VARIOUS CONNECTION TABLES

;UDB EXTENSIONS IF A MAGTAPE
	UDBDEN==UDBDDM		;HARDWARE-DETERMINED DENSITY
				; NOTE THAT MAGTAP USES THIS WORD
	LU.TAP==UDBDEN+1	;LENGTH OF MAGTAPE UDB

;BITS IN CIDATA
	   DT.TAP==1B0		;CONTROLLER IS A TAPE DRIVER (MUST BE SIGN BIT)
	   DT.GAW==1B1		;NODE HAS GONE AWAY (CONNECTION BROKEN)
	   DT.GCS==1B2		;A GCS COMMAND IS OUTSTANDING
	   DT.IDC==1B3		;WE'VE INITIATED A DISCONNECT
	   DT.IRC==1B4		;WE'VE INITIATED A RECONNECT
	   DT.DIS==1B5		;THEY INITIATED A DISCONNECT
	   DT.DI1==1B6		;ALREADY TRIED DISCONNECT ONCE
	   DT.NXU==1B7		;FIRST PASS NEXT UNIT TEST
	   DT.KL==1B8		;REMOTE IS A KL
	   DT.KEP==DT.KL!DT.DI1 ;BITS TO KEEP AROUND ON RESET

CONTMO==15			;APPROXIMATELY 15 SECOND TIMEOUT FOR CONNECT REQUEST
TAPSID==MAXNDS+1			;MUST BE ON BIT BOUNDARY!! (I.E. 20 OR 40)

RS MSCINF,1			;INITIALIZATION FLAG
RS MSCITD,1			;REALLY STARTED FLAG
RS MSCHSC,1			;COUNT-DOWN TIMER FOR GET COMMAND STATUS
RS INTRVL,1			;NUMBER OF OUR TIMEOUTS IN 1 OF THEIRS
RS MSCCID,CTABSZ		;TABLE OF CONNECT IDS
RS MSCOLD,CTABSZ		;TABLE OF OLD CONNECT ID'S
RS CIDATA,CTABSZ		;BITS AND BYTES ASSOCIATED WITH THE CID
RS CICMST,CTABSZ		;STATUS OF OLDEST COMMAND FOR NODE
RS MSCTMO,CTABSZ		;TIME LEFT TO WAIT FOR REMOTE CONNECTION
RS MSCINT,CTABSZ		;INTERVAL TO WAIT FOR REMOTE
RS QUEREQ,1			;NON-0 IF REQS GOT QUEUED ON SOME UNIT'S PWQ
RS HAVTIM,1			;FLAG FOR SETTING CURRENT TIME IN SERVERS

VAXTIM:	DEC 52734375		;MAGIC CONSTANT FOR CONVERTING TO VAX TIME-BASE
ZON2TM==25252			;CONSTANT TO CONVERT GMT OFFSET INTO DATE FRACTION

;TABLE OF MEDIA TYPES
TYPTAB:	BYTE (16) 022544,010120	;RA80
	BYTE (16) 022544,010121	;RA81
	BYTE (16) 021244,010074	;RA60
	.UTRP4_4		;RP04 (KL MSCP SERVER)
	.UTRP6_4		;RP06
	.UTRP7_4		;RP07
	.UTP20_4		;RP20
NUMTYP==.-TYPTAB
TAPTYP:	BYTE (16) 064651,050116	;TU78
	BYTE (16) 066551,050121	;TU81 25/75 IPS STREAMER
MAXTYP==.-TAPTYP
SIZTAB:	DSKSZ5,,.UTR80
	DSKSZ6,,.UTR81
	DSKSZ7,,.UTR60
	DSKSZ0,,.UTRP4
	DSKSZ1,,.UTRP6
	DSKSZ2,,.UTRP7
	DSKSZ4,,.UTP20
	DSKSZ8,,.UTR82
	DSKSZ9,,.UTR62

;FRAMES/WORD,,MODE BITS
MODTBL:	-1			;0 - ILLEGAL
	5,,(BS.CDM)		;1 - CORE DUMP
	-1			;2 - SIXBIT
	-1			;3 - 7 BIT (ASCII)
	1,,(BS.ICM)		;4 - INDUSTRY COMPAT
	^D9,,(BS.HDM)		;5 - HIGH DENSITY
MAXMOD==.-MODTBL-1
MTSZMT:	-1			;ILLEGAL MODE
	-1,,^D10		;CORE DUMP
	-1
	-1
	FM.PE,,^D8		;1600BPI,,INDUSTRY COMPATABLE
	FM.GCR,,^D18		;6250BPI,,HIGH DENSITY


;IORB FUNCTION TO MSCP FUNCTION TRANSLATION
OP.DAT==1B0			;DATA FUNCTION
OP.REV==1B1			;REVERSE
OP.CHK==1B2			;CHECK AFTER FUNCTION IS DONE
OP.REW==1B3			;REWIND
OP.RDB==1B4			;READ (SINGLE BIT)
OP.DEN==1B5			;SET DENSITY IF NECESSARY

MSCFCN:	0			;0 - ILLEGAL
	OP.DAT!OP.RDB!OP.RD	;1 - READ
	OP.DAT!OP.RDB!OP.RD	;2 - READ FORMAT AND DATA
	OP.DAT!OP.DEN!OP.WR	;3 - WRITE
	OP.DAT!OP.DEN!OP.WR	;4 - WRITE FORMAT AND DATA
	0			;5 - SEEK
	OP.REP!OP.DEN		;6 - SKIP RECORD
	OP.REV!OP.REP		;7 - BACKSPACE RECORD
	OP.WTM!OP.DEN		;10 - WRITE TAPE MARK
	OP.ERG!OP.DEN		;11 - ERASE
	OP.REW!OP.REP		;12 - REWIND
	OP.AVL			;13 - UNLOAD
	OP.DAT!OP.REV!OP.RDB!OP.RD ;14 - READ REVERSE
	0			;15 - RECOVERY READ. ILLEGAL
	OP.DAT!OP.CHK!OP.WR	;16 - WRITE VALIDITY CHECK
	OP.DAT!OP.CHK!OP.RDB!OP.RD ;17 - READ VALIDITY CHECK

;
; THE FOLLOWING THREE TABLES MUST REMAIN IN SYNC.  THE EQUIV TABLE
; IS THE OFFSET INTO CMDJMP AND CMDTBL.
; WARNING!!! DO NOT USE 0 SINCE IT WILL BE CONFUSED WITH DATA REQUEST
;
ILEGLL==0			;DON'T USE THIS ENTRY!!
MSCGO1==1
MSC5A==2
MSCA8==3
ONLC1==4
MSCH30==5
MSCI4M==6
MSGA1==7
MSG55==8


; COMMAND TABLE.  THIS IS MAINLY USED AS A CHECK TO SEE THAT THE
; COMMAND WE HAVE MATCHES THE POSSIBLE COMMAND REFERENCE NUMBER
; AND IS REALLY A LEGALITY CHECK
CMDTBL: 0			;ILLEGAL
	OP%ONL			;ONLINE STATUS
	OP%SCC			;SET UNIT STATUS
	OP%GUS			;GET UNIT STATUS
	OP%GUS			;GET UNIT STATUS
	OP%GCS			;GET COMMAND STATUS
	OP%ONL			;ON LINE
	OP%GUS			;GET UNIT STATUS
	OP%AVL			;SET AVAILABLE


; COMMAND JUMP TABLE. THIS IS THE ADDRESS TO WHICH WE WILL JUMP
; WHEN A REQUEST TO THE SERVER HAS FINISHED OUR REQUEST.
;
CMDJMP:	0,,0			;JUMP TO TABLE
	MSEC1,,MSSONL
	MSEC1,,MSC5AA
	MSEC1,,MSCIA8
	MSEC1,,ONLCK1
	MSEC1,,MSCC10
	MSEC1,,MSCI1A
	MSEC1,,MSGAA
	MSEC1,,MSC15A

	SUBTTL End of PHYMSC
	TNXEND
	END
