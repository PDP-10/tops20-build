; UPD ID= 8583, RIP:<7.MONITOR>PHYH11.MAC.2,  11-Feb-88 16:54:08 by GSCOTT
;TCO 7.1218 - Update copyright date.
; UPD ID= 2154, SNARK:<6.1.MONITOR>PHYH11.MAC.14,   5-Jun-85 10:38:54 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 1907, SNARK:<6.1.MONITOR>PHYH11.MAC.13,   4-May-85 21:59:07 by MCCOLLUM
;TCO 6.1.1238 - Fix BUG. documentation
; UPD ID= 1784, SNARK:<6.1.MONITOR>APRSRV.MAC.196,  23-Apr-85 12:40:03 by MCCOLLUM
; UPD ID= 4522, SNARK:<6.MONITOR>PHYH11.MAC.12,  13-Jul-84 20:01:07 by PURRETTA
;Update copyright notice
; UPD ID= 1408, SNARK:<6.MONITOR>PHYH11.MAC.11,   3-Nov-82 16:36:03 by MOSER
;TCO 6.1345 - CHANGES TO READ PE FORMAT TAPES WITH CORRECTED ERRORS ON KS
; UPD ID= 860, SNARK:<6.MONITOR>PHYH11.MAC.10,   7-Jun-82 09:41:10 by MURPHY
;TCO 6.1147 - Move bugdefs from BUGS.MAC to here and put them in-line.
; UPD ID= 225, SNARK:<5.MONITOR>PHYH11.MAC.9,  29-Sep-81 09:36:51 by DONAHUE
;TCO 5.1523 - Set CDB offline if can't clear error at CLRRAE
; UPD ID= 1453, SNARK:<5.MONITOR>PHYH11.MAC.8,  20-Jan-81 05:46:32 by WACHS
;TCO 5.1234 ADD DUMMY FOR RETRY MAGTAPE ERRORS IN OPPOSITE DIRECTION
; UPD ID= 578, SNARK:<5.MONITOR>PHYH11.MAC.6,  31-May-80 23:03:10 by DBELL
;TCO 5.1048 - ADD NEW DISPATCH FOR EXTRACTING ADDRESS FROM CCW WORDS
; UPD ID= 482, SNARK:<4.1.MONITOR>PHYH11.MAC.64,  26-Apr-80 11:59:19 by DBELL
;TCO 4.1.1149 - CALL LOWER LEVEL ROUTINES FOR HUNG CALLS
; UPD ID= 361, SNARK:<4.1.MONITOR>PHYH11.MAC.63,  26-Mar-80 11:06:57 by DBELL
;TCO 4.1.1119 - MAKE CHANGES NECESSARY FOR RP20 DISKS
;<4.MONITOR>PHYH11.MAC.62, 20-Sep-79 15:04:36, EDIT BY DBELL
;TCO 4.2476 - ADD DISPATCH FOR UNIT EXISTANCE CHECK
;<OSMAN.MON>PHYH11.MAC.1, 10-Sep-79 15:58:04, EDIT BY OSMAN
;TCO 4.2412 - Move definition of BUGHLTs, BUGCHKs, and BUGINFs to BUGS.MAC
;<4.MONITOR>PHYH11.MAC.60, 17-Aug-79 14:16:00, EDIT BY OSMAN
;CHANGE P2RAE2 TO P2RAEX TO AVOID CONFLICT WITH PHYH2.MAC
;<4.MONITOR>PHYH11.MAC.59,  5-Mar-79 15:45:59, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<2BOSACK>PHYH11.MAC.4, 14-Feb-79 22:32:17, EDIT BY BOSACK
;<2BOSACK>PHYH11.MAC.3, 14-Feb-79 22:27:45, EDIT BY BOSACK
;HAVE CKERR CHECK TAPE CHAR BIT RATHER THAN UNIT TYPE
;<4.MONITOR>PHYH11.MAC.57, 21-Jan-79 17:53:29, Edit by MCLEAN
;ADD SUPPORT CODE FOR DIAG JSYS .DGPDL
;<4.MONITOR>PHYH11.MAC.56, 10-Jul-78 13:20:35, Edit by MCLEAN
;ADD MORE INFO ON RH11LOST INTERRUPT BUGCHK
;<3A.MONITOR>PHYH11.MAC.53,  7-Jul-78 01:47:02, Edit by MCLEAN
;MAKE TM03'S WORK
;<4.MONITOR>PHYH11.MAC.54,  5-Jun-78 13:17:37, Edit by MCLEAN
;<4.MONITOR>PHYH11.MAC.53,  5-Jun-78 13:15:30, Edit by MCLEAN
;<3A-NEW>PHYH11.MAC.52, 26-May-78 16:19:59, Edit by FORTMILLER
;PUT CODE IN FOR DX20 EVEN THOUGH IT MAY NEVER BE USED
;<3.SM10-RELEASE-3>PHYH11.MAC.95,  8-May-78 11:13:12, Edit by MCLEAN
;REMOVE PHYDLT BUGINF MUTTER MUTTER
;<3A.MONITOR>PHYH11.MAC.50, 27-Apr-78 23:15:29, Edit by MCLEAN
;<3A.MONITOR>PHYH11.MAC.49, 27-Apr-78 21:44:09, Edit by MCLEAN
;<3A.MONITOR>PHYH11.MAC.48, 27-Apr-78 21:16:30, Edit by MCLEAN
;MORE READBACKWARDS
;<3A.MONITOR>PHYH11.MAC.47, 27-Apr-78 00:16:26, Edit by MCLEAN
;MAKE READ BACKWARDS WORK
;<3.SM10-RELEASE-3>PHYH11.MAC.94, 24-Apr-78 14:51:52, Edit by MCLEAN
;STORE LH OF WINDOW (INTERESTING PART ON ERROR)
;<3.SM10-RELEASE-3>PHYH11.MAC.92,  2-Apr-78 15:46:30, Edit by MCLEAN
;FIX ERROR RECOVERY TO USE CDBCNI (UNUSED IN PHYH11) TO BE AN
;INDICATOR AS TO WHETHER DOING DATA OP OR NOT ON XFER COMPLETION
;<3.SM10-RELEASE-3>PHYH11.MAC.91, 31-Mar-78 15:04:03, Edit by MCLEAN
;PUT ERROR REGISTER 2 DEFINITION IN CORRECT PLACE
;<3A.MONITOR>PHYH11.MAC.43, 29-Mar-78 21:18:49, Edit by MCLEAN
;<3.SM10-RELEASE-3>PHYH11.MAC.88, 28-Mar-78 00:23:04, Edit by MCLEAN
;<3.SM10-RELEASE-3>PHYH11.MAC.87, 28-Mar-78 00:21:13, Edit by MCLEAN
;FIX CKERR TO RETURN CHANNEL ERROR CORRECTLY
;<3.SM10-RELEASE-3>PHYH11.MAC.86,  7-Mar-78 15:40:47, Edit by MCLEAN
;SOME CODE CLEANUPS
;<3A.MONITOR>PHYH11.MAC.38,  3-Mar-78 16:13:00, Edit by MCLEAN
;<3.SM10-RELEASE-3>PHYH11.MAC.85,  3-Mar-78 13:35:36, Edit by MCLEAN
;FIX UBGOOD CALL
;<3.SM10-RELEASE-3>PHYH11.MAC.32, 22-Feb-78 16:32:23, Edit by MCLEAN
;MAKE IT WORK IF RH IS NOT THERE
;<3.SM10-RELEASE-3>PHYH11.MAC.32, 22-Feb-78 16:32:23, Edit by MCLEAN
;MAKE IT WORK IF RH IS NOT THERE
;<4.MONITOR>PHYH11.MAC.34,  1-Feb-78 14:50:07, Edit by MCLEAN
;FIX PHYALC FOR NEW CALLING SEQ
;<4.MONITOR>PHYH11.MAC.33, 30-Jan-78 21:31:04, Edit by MCLEAN
;ADD CHANGES FOR UNIT GOING ON LINE
;<1MCLEAN>PHYH11.MAC.3, 25-Jan-78 15:19:16, Edit by MCLEAN

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


	SEARCH PROLOG		;PARAMETER FILE
	TTITLE (PHYH11,,< - CHANNEL DEPENDENT CODE FOR RH11 CONTROLLER>)
	SUBTTL R. MCLEAN (FROM PHYH2 T. HESS,T. WACHS,L. BOSACK)
	SEARCH PROKS
	SEARCH PHYPAR		;PHYSIO PARAMETERS

	SUBTTL PARAMETERS

; DEVICE EPENDENT STUFF


;DEVICE INDEPENDENT REGISTERS

DO.AS==4B5			;ATTENTION SUMMARY REGISTER
DO.DA==5B5			;DESIRED ADDRESS REGISTER
DO.DT==6B5			;DRIVE TYPE REGISTER

DO.LR==1B6			;LOAD REGISTER ENABLE
DO.DRE==1B9			;DISABLE RAE STOP

;DEVICE DEPENDENT DEFINITIONS IN THE CDB

RC1CS1==CDBDDP+0		;CONTROL STATUS 1
RC1DS==CDBDDP+1			;DRIVE STATUS REGISTER
RC1ER1==CDBDDP+2		;ERROR REGISTER 1
RC1MR==CDBDDP+3			;MAINT REGISTER
RC1AS==CDBDDP+4			;ATTENTION SUMMARY REGISTER
RC1DA==CDBDDP+5			;DESIRED ADDRESS REGISTER
RC1DT==CDBDDP+6			;DRIVE TYPE REGISTER
RC1LA==CDBDDP+7			;LOOK AHEAD REGISTER
RC1SN==CDBDDP+10		;SERIAL NUMBER REGISTER
RC1OF==CDBDDP+11		;OFFSET REGISTER
RC1DC==CDBDDP+12		;DESIRED CYL REGISTER
RC1CA==CDBDDP+13		;CURRENT CYL REGISTER
RC1ER2==CDBDDP+14		;ERROR REGISTER 2
RC1ER3==CDBDDP+15		;ERROR REGISTER 3
RC1EC1==CDBDDP+16		;ECC REGISTER 1
RC1EC2==CDBDDP+17		;ECC REGISTER 2
RC1WC==CDBDDP+20		;WORD COUNT REGISTER
RC1BA==CDBDDP+21		;CURRENT ADDRESS REGISTER
RC1CS2==CDBDDP+22		;CONTROL AND STATUS REGISTER 2
RC1CNT==23			;COUNT OF ABOVE REGISTERS
UBADSW==CDBDDP+23		;UNIBUS STATUS REGISTER ADDRESS
UBBASA==CDBDDP+24		;UNIBUS BUS ADDRESS BASE ADDRESS

L.RH2==CDBDDP+RC1CNT-CDBINT+2	;LENGTH OF RH11 CDB


CHXFR==1B0			;INDICATE XFER WORD
CHJMP==1B1			;INDICATE CHANNEL JUMP
CHLST==1B1			;INDICATE LAST XFER
CHREV==1B2			;INDICATE REVERSE

CCYADR:	POINT 22,T1,35		;BYTE POINTER TO CCW ADDRESS FIELD
CCYCNT:	POINT 11,T1,13		;BYTE POINTER TO CCW COUNT FIELD

;BITS IN CHANNEL LOGOUT AREA

CS1MPE==1B1			;MEMORY PARITY ERROR
CS1NSE==1B2			;NEGATION OF SBUS ERR
CS1NC0==1B3			;NEGATION OF WORDCOUNT = 0
CS1NXM==1B4			;NONEXISTANT MEMORY
CS1LTE==1B9			;LAST TRANSFER ERROR
CS1RHE==1B10			;RH11 ERROR
CS1LWC==1B11			;LONG WORD COUNT (RH11 FINISHED BEFORE CHANNEL)
CS1SWC==1B12			;SHORT WORD COUNT (CHANNEL FINISHED BEFORE RH11)
CS1OVR==1B13			;OVERRUN (MBOX BUFFER)

;SOFTWARE FLAGS IN FUNCTION (USED BY CHSTRT)
ERETRY==200
RQDUBW==MAXPPB			;NUMBER OF UNIBUS WINDOWS TO ALLOCATE

;RH11 CHANNEL STATUS BITS


;STATUS BITS IN CONTROL AND STATUS 1
RH1SC==1B20		;SPECIAL CONDITION
RH1TRE==1B21		;TRANSFER ERROR
RH1CPE==1B22		;MASS I/O CONTROL PARITY ERROR
RH1PSL==1B25		;PORT SELECT
RH1UAD==3B27		;UNIBUS ADDRESS EXTENSION BITS
RH1RDY==1B28		;READY
RH1IE==1B29		;INTERRUPT ENABLE
RH1ERR==RH1TRE!RH1CPE 	;BITS THAT CAUSE ERRORS

;STATUS BITS IN CONTROL AND STATUS 2

RH1DLT==1B20		;DATA LATE
RH1WCE==1B21		;WRITE CHECK ERROR
RH1PE==1B22		;PARITY ERROR
RH1NED==1B23		;NON EXISTENT DISK
RH1NEM==1B24		;NON EX MEMORY
RH1PGE==1B25		;PROGRAM ERROR
RH1MXF==1B26		;MISSED TRANSFER
RH1MDP==1B27		;MASS BUS PARITY ERROR
RH1CLR==1B30		;CONTROLLER CLEAR (ALSO CLEARS DRIVES)
RH1UNI==7B35		;UNIT SELECT BITS

; ERROR REGISTER 1 DEFINITIONS

ER.CPE==1B32			;CONTROL BUS PARITY ERROR
ER.FCE=1B26			;FRAME COUNT ERROR

RHOFF:	BYTE (6)0,12,14,24,16,6
	BYTE (6)26,20,30,32,34,36
	BYTE (6)40,42,44,46,2,4
	BYTE (6)10


; CHANNEL ADDRESS TABLE

RH1CTB:	RH11CA			;ADDRESS OF CHANNEL 0
	RH21CA			;ADDRESS OF CHANNEL 1
RH1CTZ==.-RH1CTB		;SIZE OF RH11 CHANNEL TABLE

RH1IVT:	RH11IV/4		;UNIBUS ADAPTER #,,INTERRUPT VECTOR ADDRESS CHANNEL 0
	RH21IV/4		;UNIBUS ADAPTER #,,INTERRUPT VECTOR ADDRESS CHANNEL 1





;CHANNEL DISPATCH TABLE FOR RH11

RH2DSP::JRST RH2INI		;0 - INITIATION
	RET			;1 - STACK CHAN COMMAND - RETURN FAILURE ON RH11
	JRST RH2SIO		;2 - START I/O
	JRST RH2POS		;3 - POSITION REQUEST
	JRST RH2LTM		;4 - RETURN BEST XFER
	JRST RH2INT		;5 - INTERRUPT PROCESSING
	JRST RH2CCW		;6 - MAKE CHANNEL XFER WORD
	JRST RH2HNG		;7 - TRANSFER HUNG
	JRST RH2RST		;10 - RESET CHANNEL
	JRST RH2CHK		;11 - PERIODIC CHECK
	JRST EXTKDB		;12 - CHECK UNIT EXISTANCE
	JRST RH2CCA		;13 - EXTRACT ADDRESS FROM CCW WORD

;DUMMIES

RH2LTM:	RET
	SUBTTL INITIALIZATION

RH2INI:	MOVE Q1,RH1CTB		;GET CHANNEL ADDRESS
	PUSH P,[0]		;SAVE ON PDL
RH2NCH:	MOVE T1,Q1		;GET ADDRESS OF DEVICE
	CALL UBGOOD		;CHECK TO SEE IF IT EXISTS
	JRST RH2NOU		;NOT HERE FORGET IT
	MOVEI T1,L.RH2		;GET LENGTH OF CDB
	CALL PHYALC		;ALLOCATE SOME STORAGE
	JRST PA1		;FAILURE QUIT INITALIZATION
	MOVEI P1,-CDBINT(T1)	;CDB BASE ADDRESS TO P1
	MOVEM P1,CHNTAB(P4)	;SAVE CDB IN CHANNEL TABLE
	HRRZM P4,CDBADR(P1)	;STORE CHNTAB INDEX
	AOS P4			;ADVANCE TO NEXT
	MOVE T2,0(P)		;FIND CHANNEL NUMBER
	HLRZ T1,RH1CTB(T2)	;GET UNIBUS ADAPTER NUMBER
	MOVEI T2,RQDUBW		;NEED WINDOWS
	CALL ALUBWA		;ALLOCATE WINDOW
	BUG.(HLT,NOUBWA,PHYH11,SOFT,<RH2NCH - No unibus window for RH11>,,<

Cause:	This BUGHLT can only occur on the 2020. It happens when the call to
	ALUBWA from the disk initialization code gets a failure return.
	The only reason ALUBWA would give such a failure return is if no
	more unibus adapter windows are available.
>)
	MOVEM T1,UBADSW(P1)	;SAVE ADDRESSES
	MOVEM T2,UBBASA(P1)	;SAVE UNIBUS BASE ADDRESS
	MOVEI T1,.CTRH3		;SET TYPE
	DPB T1,CSYTYP		;..
	MOVEI T4,RC1CS1(P1)	;START THE SAVE OF ADDRESSES
	MOVNI T1,RC1CNT		;GET SIZE OF TABLE
	MOVE T2,[POINT 6,RHOFF] ;GET ADDRESS TABLE
RH11DL:	ILDB T3,T2		;FIND THE OFFSET
	ADD T3,Q1		;CREATE AN ADDRESS
	MOVEM T3,0(T4)		;STORE IN CDB
	AOS T4			;POINT TO NEXT
	AOJL T1,RH11DL		;DO ALL REGISTERS
	MOVEI T3,CDBINT(P1)	;ADDRESS FOR XPCW ON INTERRUPT
	HRLI T3,(<XPCW>)	;BUILD INSTRUCTION
	MOVE T1,0(P)		;GET CHANNEL NUMBER
	HLRZ T2,RH1CTB(T1)
	HRRZ T1,RH1IVT(T1)	;GET VECTOR
	ADD T1,SMTEPT(T2)	;AND TABLE ADDRESS
	MOVEM T3,0(T1)		;STORE XPCW IN INTERRUPT VECTOR LOCATION
	MOVEI T3,CDBINT+4(P1)	;SET JUMP ADDRESS
	MOVEM T3,CDBINT+3(P1)	;SET IN XFER VECTOR
	SETZM CDBINT+2(P1)	;SET FLAGS TO 0
	MOVEI T1,KIEPT		;ADDRESS OF CHANNEL ICP AREA
	HRRM T1,CDBICP(P1)	;STASH IN CDB
; ...

	MOVE T1,[MOVEM P1,CDBSVQ]
	ADDI T1,0(P1)		;INSTRUCTION TO STORE P1 IN CDB
	MOVEM T1,CDBINT+4(P1)	;BUILD INTERRUPT CODE
	MOVE T1,[JSP P1,PHYINT]
	MOVEM T1,CDBINT+5(P1)	;DISPATCH TO PHYSIO
	MOVE T1,[BLT 17,17]	;INSTRUCTION TO RESTORE ACCUMULATORS
	MOVEM T1,CDBJEN(P1)	;PUT IN CDB
	MOVEI T1,CDBRST(P1)	;BUILD DATAO CDBRST, TO RESET THE
	MOVEI T1,CDBINT(P1)	;ADDRESS OF INTERRUPT PC
	HRLI T1,(<XJEN 0>)	;BUILD XJEN INSTRUCTION
	MOVEM T1,CDBJEN+1(P1)	;STORE
	MOVEI T1,RH2DSP		;INSERT DISPATCH VECTOR
	MOVEM T1,CDBDSP(P1)	;SET UP DISPATCH
				;NOW FIND UNITS & TYPES
	MOVE Q3,[-MAXRH,,CDBUDB] ;AOBJN POINTER TO UDB TABLE
	ADDI Q3,0(P1)		;RELOCATE POINTER
	MOVEM Q3,CDBCUN(P1)	;STORE IN CDB
	MOVEM Q3,CDBIUN(P1)	;...
	SETOM CDBXFR(P1)	;INDICATE CHANNEL FREE
	MOVEI Q2,0		;FIRST UNIT #
RH2UNL:	MOVEI T2,RH1CLR		;RESET CONTROLLER ERRORS
	WRIO T2,@RC1CS2(P1)
	SETZM P3		;IN CASE NOT WANTED
	SETOM P5		;INDICATE TO CREATE ALL UDBS AND KDBS
	CALL RH2UNS		;SELECT A UNIT
RH2NXU:	MOVEM P3,0(Q3)		;STORE IN CDB IF ANY (0 IF NONE)
	AOS Q2			;NEXT UNIT #
	AOBJN Q3,RH2UNL		;KEEP GOING
	MOVE T1,CDBIUN(P1)	;CHECK IF ANY DEVICES FOUND.
	SETOM CDBXFR(P1)	;SET NO TRANSFER IN PROGRESS
	SETZ T2,0		;UNIT 0
RH2CKU:	SKIPE (T1)		;UNIT PRESENT?
	JRST RH2NXT		;YES, GO ON TO NEXT CHANNEL
	AOS T2			;NEXT UNIT NUMBER IN CLEAR REQUEST
	AOBJN T1,RH2CKU		;NO, LOOP FOR MORE
	MOVSI T1,(CS.OFL)	;NONE PRESENT, MARK OFFLINE.
	IORM T1,CDBSTS(P1)	; ...
	JRST RH2NOU		;NO UNIT FOUND
;THE FOLLOWING SEQUENCE IS REQUIRED BECAUSE THE RH11 REQUIRES
;THAT A CLEAR INSTRUCTION BE FOLLOWED IMMEDIATELY BY A SELECTION
;OF AN EXISTANT UNIT NUMBER OTHERWISE ANY ATTEMPT TO ACCESS
;A REGISTER THAT IS NOT IN THE RH (CS1) WILL CAUSE
;MASSBUS PARITY ERRORS.

RH2NXT:	MOVEI T1,RH1CLR		;CLEAR RH11
	WRIO T1,@RC1CS2(P1)	;ISSUE CLEAR
	WRIO T2,@RC1CS2(P1)	;CLEAR CONTROLLER
	MOVEI T1,RH1IE+RH1TRE	;RESET AND ENABLE INTERRUPTS
	WRIO T1,@RC1CS1(P1)
RH2NOU:	AOS Q1,0(P)		;LOOK AT NEXT AND RESTORE DEVICE CODE
	CAIL Q1,RH1CTZ		;BEYOND LAST?
	JRST PA1		;PRUNE AND EXIT
	MOVE Q1,RH1CTB(Q1)	;GET NEXT CHANNEL ADDRESS
	JRST RH2NCH		;TRY NEXT


; ROUTINE TO DETERMINE THE SPECIFIC UNIT TYPES AND
; REQUEST KDB AND UDB POINTERS BE SET UP



RH2UNS::WRIO Q2,@RC1CS2(P1)	;SET UNIT NUMBER
	MOVEI T1,1		;ISSUE A NOP TO GET NED
	WRIO T1,@RC1CS1(P1)
	RDIO T1,@RC1CS2(P1)	;CHECK FOR ERROR
	TRNE T1,RH1NED		;NON EX DEVICE?
	RET			;YES, NEXT UNIT
RH2UNA:	RDIO T1,@RC1DT(P1)	;GET DRIVE TYPE
	LDB T1,[POINT 9,T1,35]	;GET DEVICE TYPE CODE
	CAIG T1,TY.RPH		;WITHING RP04,5,6 RANGE?
	CAIGE T1,TY.RPL		; ??
	SKIPA			;NO
	JRST RH2IRP		;YES - INITIALIZE IT
	CAIN T1,TY.RS4		;RS04 TYPE?
	JRST RH2IRS		;YES - INITIALIZE IT
	CAIN T1,TY.DXA		;DX20 TYPE?
	JRST RH2IDX		;YES, INITIALIZE IT
	CAIG T1,TY.T3H		;WITHIN TM03 RANGE?
	CAIGE T1,TY.T3L		;
	SKIPA			;NO
	JRST RH2ITM		;YES
	CAIG T1,TY.T2H		;GREATER THAN HIGHEST TM02 TYPE
	CAIGE T1,TY.T2L		;OR LOWER THAN LOWEST?
	RET			;YES - NOT TM02
	JRST RH2ITM		;IS TM02 - GO INITIALIZE

;ROUTINE TO INVOKE RP04/RS04 INITIATION

RH2IRS:	SKIPA T1,[.UTRS4]	;RS04 TYPE
RH2IRP:	MOVEI T1,.UTRP4		;RP04 TYPE
	CALL FNDUTP		;FIND TABLE ENTRY
	 CALL UDSINI(T1)	;CALL INITIALIZE IF FOUND
	RET			;ADVANCE TO NEXT UNIT

;HERE TO INITIALIZE A DX20

RH2IDX:	MOVX T1,.UTDXA		;SEARCH FOR
	JRST RH2ITD		; A DX20

;HERE TO INITIALIZE A TM02

RH2ITM:	MOVEI T1,.UTTM2		;SEARCH FOR TM02
RH2ITD:	MOVEI P2,0		;IN CASE NOT FOUND IN TABLES
	CALL FNDUTP		; ...
	 CALL UDSINI(T1)	;FOUND - CALL INITIALIZE, RETURN KDB IN P2
	MOVE P3,P2		;COPY KDB TO WHERE COMMON CODE WANTS IT
	RET			;LOOP FOR MORE

;ROUTINE TO SCAN CHANNEL/UNIT TABLES FOR TYPE GIVEN IN T1
;RETURNS TABLE ENTRY IN T1 (SKIP RETURN ON NOT FOUND)

FNDUTP:	MOVE T2,[PHYUNL,,PHYUNT] ;ENTRY FOR UNIT TABLE
FNDTPL:	HLRZ T3,0(T2)		;GET LH = TYPE CODE
	CAME T1,T3		;TYPES MATCH?
	AOBJN T2,FNDTPL		;NO - TRY NEXT
	JUMPGE T2,RSKP		;SKIP RETURN IF NO MATCH
	HRRZ T1,0(T2)		;MATCH - GET DISPATCH ADDRESS
	RET			;RETURN
	SUBTTL START I/O AND POSITIONING

;HERE TO START POSITIONING (P3 := UDB)

RH2POS:	HRRZ T1,UDBDSP(P3)	;ADDRESS OF DEVICE ROUTINE
	JRST UDSPOS(T1)		;START IT

;HERE TO START ACTUAL OPERATION (P3 := UDB , P4 := IORB)

RH2SIO:	HRRZ T1,UDBDSP(P3)	;DISPATCH TO DEVICE CODE
	CALL UDSSIO(T1)		;ATTEMPT TO START IO
	 JRST CLRCHL		;LOSE
	RETSKP			;WIN
	SUBTTL HUNG, RESET AND CHECK ENTRIES
;HERE ON A HUNG TRANSFER
;CALLED WITH PI OFF

RH2HNG:	CALL CLRRAE		;CLEAR POSSIBLE RAE
	MOVEI T1,RH1CLR		;CLEAR RH11
	WRIO T1,@RC1CS2(P1)
	WRIO T2,@RC1CS2(P1)
	CALL CLRCHL		;RESET THE CHANNEL
	HRRZ T1,UDBDSP(P3)	;GET DISPATCH ADDRESS
	CALLRET UDSHNG(T1)	;CLEAR THE CONTROLLER AND UNIT ALSO

;HERE TO RESET THE CHANNEL AND ALL UNITS
;T1/ 0 TO RESET JUST THE CHANNEL
;T1/ 1 FOR FULL RESET

RH2RST:	JUMPE T1,CLRCHL		;SIMPLE RESET
	JRST RH2HNG


;HERE EVERY NOW AND THEN (ABOUT 1 SEC) TO CHECK PIA.

RH2CHK:	MOVSI T1,(CS.OFL)	;CHECK FOR OFF LINE
	TDNE T1,CDBSTS(P1)
	RET			;OFF LINE IGNORE THIS REQUEST
	MOVEI T1,RH1IE		;CHECK FOR INTERRUPT ENABLE
	TIOE T1,@RC1CS1(P1)	;ON?
	RET			;YES ALL OK
	MOVE T2,RC1CS1(P1)	;GET FAILURE ADDRESS
	BUG.(CHK,PH1PIE,PHYH11,HARD,<PHYH11 - RH11 lost interrupt enable>,<<T2,RH11STS>>,<

Cause:	An RH11 is no longer enabled for interrupts. TOPS-20 will enable
	interrupts for the RH11.

Data:	RH11STS - RH11 status

>)
	BSIO T1,@RC1CS1(P1)	;SET INTERRUPT ENABLE (THIS WILL CAUSE IMMEDIATE INTERRUPT!)
	RET

	SUBTTL CHANNEL UTILITY ROUTINES

;DUMMY ROUTINE TO SATISYY GLOBALS
REVCCW::RET

;ROUTINE TO READ A MASS-BUSS REGISTER
;CALL - C(T2) := REGISTER TO BE READ
;	C(P3) := UDB POINTER
;	C(P1) := CDB POINTER
;RETURNS VALUE IN T1 , PRESERVES T4

RDREG::	HRRZ T3,UDBAKA(P3)	;GET UNIT #
	SKIPL T2		;INTERNAL REGISTER?
	TLO T2,(DO.DRE)		;NO - TRY FIRST WITH DRAES ON
	TLOA T2,(T3)		;SET UNIT NUMBER
RDREG3::TLO T2,<(DO.DRE)>(Q2)	;UNIT # IN Q2
	LDB T1,[POINT 3,T2,17]	;GET THE UNIT NUMBER
	WRIO T1,@RC1CS2(P1)	;SET THE UNIT NUMBER
RDREGX:	MOVEI T3,^D10		;INITIALIZE RETRY COUNTER
RDREGL:	LDB T1,[POINT 6,T2,5]	;GET THE REGISTER NUMBER
	ADD T1,P1		;POINT TO REGISTER ADDRESS
	RDIO T1,@RC1CS1(T1)	;READ REGISTER
	PUSH P,T1		;SAVE RESULT
	RDIO T1,@RC1CS2(P1)	;CHECK FOR DRIVE
	TRNE T1,RH1NED		;NON EX DISK?
	JRST RDRAE		;YES - BAD NEWS
RDRAE1:
	RDIO T1,@RC1CS1(P1)	;READ STATUS REGISTER
	TRNE T1,RH1CPE		;CONTROL BUS PAR ERR?
	JRST RDREGE		;YES - ERROR
RDEXIT:	POP P,T1		;RSTORE RESULT
	ANDI T1,177777		; CLEAR OUT GARBAGE
	RET			;EXIT

;HERE WHEN CBPE OR MISSING TRA

RDREGE:	SOJG T3,RDREGA		;LOOP IF RETRY STILL POSITIVE
	TLZ T2,(DO.DRE)		;TRY ONE MORE TIME - IF RAE, BOMB WORLD
	JUMPL T3,RDEXIT		;IF NOW NEGATIVE, DEPART, TRAGIC ERROR
RDREGA:	POP P,T1		;RESTORE REGISTER
	JRST RDREGL		;TRY AGAIN

;HERE WHEN A REGISTER ACCESS ERROR IS DETECTED

RDRAE:	PUSH P,T2		;SAVE ANOTHER REGISTER
	TLNE T2,(DO.DRE)	;DRAES?
	JRST RDRAE2		;YES - JUST CLEAR RAE
	BUG.(CHK,P1NED1,PHYH11,HARD,<PHYH11 - RH11 non existent disk reading register>,<<T1,RH11STS1>,<T2,RH11STS2>>,<

Cause:	This BUG is not documented yet.

Data:	RH11STS1 - RH11 status register 1
	RH11STS2 - RH11 status register 2
>)
	CALL CLRRAE		;RESET RAE
	POP P,T2		;RESTORE REGISTERS
	JRST RDEXIT		;ALL WE COULD DO...

RDRAE2:	CALL CLRRAE		;CLEAR ERROR
	POP P,T2
	JRST RDRAE1		;CONTINUE ATTEMPT
;ROUTINE TO WRITE A MASS-BUSS REGISTER
;CALL - C(T2) := REGISTER TO BE WRITTEN & DATA
;	C(P1) := CDB , C(P3) := UDB
;PRESERVES T1,T4

WTREG::	HRRZ T3,UDBAKA(P3)	;GET UNIT #
	TLOA T2,(T3)		;SET IN LHS AND LR ENABLE
WTREG3::TLO T2,(Q2)		;SET LR AND UNIT NUMBER FROM Q2
	PUSH P,T1		;SAVE A REGISTER
	HLRZ T1,T2
	ANDI T1,7		;MAKE UNIT NUMBER
	WRIO T1,@RC1CS2(P1)	;SET UNIT NUMBER
	SKIPA
WTREGX:				;WRITE A REGISTER WHEN THE DRIVE NUMBER DOESNT MATTER
	PUSH P,T1		;SAVE REGISTER
	LDB T1,[POINT 6,T2,5]	;GET THE COMMAND NUMBER
	SKIPN T1		;SET INTERRUPT ENABLE IF REGISTER 0
	IORI T2,RH1IE
	ADD T1,P1		;FIND ADDRESS OF REGISTER
	WRIO T2,@RC1CS1(T1)	;WRITE THE REGISTER
	RDIO T1,@RC1CS1(P1)	;READ THE STATUS BACK
	TRNE T1,RH1NED		;NON EX DISK?
	JRST WTRAE		;YES - BAD NEWS
	RDIO T1,@RC1ER1(P1)	;CHECK FOR CONTROL BUS PARITY ERRORS
	TRNE T1,ER.CPE		;YES?
	BUG.(CHK,P11PAR,PHYH11,HARD,<PHYH11 - Control write parity error>,<<T1,RH11ERR>,<T2,REG>>,<

Cause:	A parity error occurred while writing an RH11 register.

Data:	RH11ERR - RH11 error register
	REG - Word written to status register
>)
	POP P,T1		;NO - RESTORE REGISTER
	RET			;RETURN

;HERE WHEN NED ON WRITE

WTRAE:	PUSH P,T3		;SAVE REGISTER
	RDIO T3,@RC1CS1(P1)
	BUG.(CHK,P2RAEX,PHYH11,HARD,<PHYH11 - Register access error writing reg>,<<T1,RH11ERR>,<T2,REG>,<T3,RH11STS>>,<

Cause:	TOPS-20 attempted to write an RH11 register but got a "non-existent
	disk" error.

Data:	RH11ERR - RH11 error register
	REG - Word written to status register
	RH11STS - RH11 status register
>)
	MOVE T3,T2		;SAVE ATTEMPTED REGISTER
	CALL CLRRAE		;CLEAR RAE
	MOVE T2,T3		;RESTORE
	POP P,T3		;RESTORE
	POP P,T1
	RET

;HERE TO CLEAR RAE

CLRRAE:	SETZ T2,0		;STOP CURRENT TRANSFER
	MOVE T1,CDBIUN(P1)	;GET UNIT TABLE
NOTQUI:	MOVEI T4,RH1CLR		;CLEAR RH
	WRIO T4,@RC1CS2(P1)
	WRIO T2,@RC1CS2(P1)	;WRITE UNIT NUMBER
	AOBJN T1,CLRRA1		;TRY NEXT SLOT
	MOVSI T1,(CS.OFL)	;SET IT OFFLINE
	IORM T1,CDBSTS(P1)
	BUG.(CHK,CLRACE,PHYH11,HARD,<Unable to clear register access error>,,<

Cause:	This BUGCHK occurs only on the 2020.  It will happen if the
	CLRRAE routine fails to find an existing unit.  The CLRRAE is looking
	for an existing unit to select in order to clear the register access
	error.

	If no existent unit is found, the attempt to clear the register
	access error will cause another error immediately, so the BUGCHK
	is provided to indicate that none was found. The CDB is then
	set offline. The set online function of DIAG% can be used to turn it
	back online when the problem is corrected.
>)
	JRST XINT		;DISMISS THE INTERRUPT
CLRRA1:	RDIO T4,@RC1CS1(P1)	;FORCE AN ERROR BY GOING TO DRIVE
	MOVEI T4,RH1NED		;CHECK TO SEE IF IT IS STILL THERE
	TIOE T4,@RC1CS2(P1)
	AOJA T2,NOTQUI		;NOT QUITE THIS ONE DISAPPEARED
	MOVEI T2,RH1TRE!RH1IE	;CLEAR CONTROLLER ONLY
	WRIO T2,@RC1CS1(P1)	;CLEAR
	RET

;ROUTINE TO CLEAR RH20 CONTROLLER

CLRCHL::
ZAPCHL::MOVEI T1,RH1TRE!RH1IE	;RESET INTERRUPTING BITS
	WRIO T1,@RC1CS1(P1)
	RET			;RETURN

;ROUTINE TO START CHANNEL I/O
;CALLED WITH PI OFF
;C(T2) := DATAO , C(Q1) := FUNCTION , C(P3) := UDB POINTER
;C(Q1) = -1 IMPLIES ONLY DATAO FROM T2
;GIVES SKIP RETURN TO SHOW ALL OK

CHSTRT::SKIPE T2		;CHECK FOR VALID OPS
	SKIPN Q1		; ...
	BUG.(HLT,RH1ICF,PHYH11,SOFT,<PHYH11 - Invalid channel function>,,<

Cause:	This BUGHLT can only happen on the 2020. The CHSTRT routine is
	called to perform disk operations.  On the call, Q1 is supposed to
	contain a function code, and T2 is supposed to contain the value to
	be used for a DATAO.  However, -1 in Q1 denotes that T2 contains
	the DATAO but that no function is to be done.

	The BUGHLT will occur if T2 is 0, or if T2 is non-0 and Q1 is 0,
	which can only occur due to some caller supplying CHSTRT with
	bad arguments.
>)
	HRRZ T1,UDBAKA(P3)	;GET UNIT NUMBER
	WRIO T1,@RC1CS2(P1)	;SET UNIT NUMBER SELECT
	CAMN Q1,[EXP -1]	;NON CHANNEL FUNCTION
	JRST CHST2		;DO JUST 1 DATAO
	CAIGE Q1,50		;DATA TRANSFER OPERATION?
	JRST CHST1		;NO
	SETOM CDBCNI(P1)	;INDICATE NOW DOING DATA XFER OPERATION
	PUSH P,T2		;SAVE DATAO
	PUSH P,UBADSW(P1)	;SAVE ADDRESS OF UNIBUS WINDOW
	PUSH P,UBBASA(P1)	;SAVE PDP11 ADDRESS
	PUSH P,Q2		;SAVE ANOTHER REGISTER
	MOVSI T2,(CS.ACL)	;TOGGLE  CCW LIST
	XORM T2,CDBSTS(P1)
	MOVEI T1,CDBCCL(P1)	;YES - DO SETUP
	MOVEI T2,CDBCCL+1(P1)
	TRZN Q1,ERETRY		;ECC RETRY?
	CALL PHYXFL		;NO - GET HEAD OF TRANSFER LIST
	MOVE T4,T1		;SAVE VIRTUAL ADDRESS
	MAP T1,(T1)		;GET PHYSICAL ADDRESS
	TLZ T1,777760		;FLUSH ACCESS BITS ETC
	TLO T1,(CHJMP)		;BUILD CHANNEL JUMP
	HRRZ T3,CDBICP(P1)	;AND STORE IN
	MOVEM T1,(T3)		;CHANNEL ICPC
	SETZM 1(T3)		;CLEAR CS1
	MOVE T1,0(T4)		;SET UP THE ADDRESS DEPENDENT REGISTERS
	MOVEM T1,2(T3)		;SAVE INITIAL CCW
	MOVSI T3,(CHLST)	;SET LAST TRANSFER
	IORM T3,-1(T2)		;IN CCW LIST
	SETZ Q2,0		;SET BYTE COUNT TO 0
	TLNE T1,(CHREV)		;CHECK FOR REVERSE READ
	JRST [	MOVEI T2,<RQDUBW-1>*4000+2 ;FIND END OF ADDRESS SPACE
		ADDM T2,UBBASA(P1) ;UPDATE POINTER
		MOVEI T2,RQDUBW-1 ;ALSO WINDOW POINTER
		ADDM T2,UBADSW(P1)
		JRST .+1]
	LDB T2,CCYADR		;FIND THE CURRENT ADDRESS
	ANDI T2,777		;FIND A UNIBUS ADDRESS
	LSH T2,2		;MAKE INTO UNIBUS ADDRESS
	ADD T2,UBBASA(P1)	;GET THE UNIBUS OFFSET
	WRIO T2,@RC1BA(P1)	;SET THE BUS ADDRESS
	LSH T2,-^D8		;MOVE HIGH ORDER ADDRESS BITS TO CONTROL
	ANDI T2,1400		;CORRECT POS FOR CONTROL STATUS REG
	IORM T2,Q1		;STORE IN COMMAND REGISTER WORD
CHSLP:	MOVE T1,0(T4)		;GET CHANNEL COMMAND
	LDB T2,CCYCNT		;GET THE COUNT
	MOVNS T2		;SET TO NEGATIVE
	LSH T2,1		;MAKE PDP11 WORD COUNT
	ADD Q2,T2		;UPDATE WORD COUNT
	LDB T2,CCYADR		;GET REST OF ADDRESS
	SKIPN T2
	BUG.(HLT,RH11CC,PHYH11,SOFT,<PHYH11 - Illegal channel command word>,,<

Cause:	This BUGHLT can only occur on the 2020. This BUGHLT will happen if
	the CHSTRT routine encounters an address of 0 in the channel
	control word.  The right half of the channel control word is the
	address.
>)
	LSH T2,-^D9		;GET PAGE NUMBER
	MOVSI T3,(US.TAP)	;MAGTAPE?
	TDNE T3,UDBSTS(P3)
	JRST [	TLNE T1,(CHREV)	;YES CHECK FOR READ/REVERSE
		TROA T2,UNBVBT!UNBRPW ;SET READ/PAUSE WRITE
		TRO T2,UNBVBT	;NOT BACKWARDS ONLY VALID BIT
		JRST .+2]
	TRO T2,UNBVBT!UNB36B	;SET 36BIT TRANSFER AND VALID
	WRIO T2,@UBADSW(P1)	;WRITE THE UNIBUS STATUS REGISTER
	TLNE T1,(CHREV)		;REVERSE?
	SOSA UBADSW(P1)		;YES DOWN COUNT
	AOS UBADSW(P1)		;POINT TO THE NEXT UNIBUS WINDOW
	TLNN T1,(CHLST)		;LAST?
	AOJA T4,CHSLP		;NO -- DO NEXT WINDOW
	WRIO Q2,@RC1WC(P1)	;YES -- WRITE WORD COUNTER
	POP P,Q2		;RESTORE
	POP P,UBBASA(P1)	;RESTORE PDP11 ADDRESS
	POP P,UBADSW(P1)
	POP P,T2		;RECOVER DATAO

CHST1:	CALL WTREG		;WRITE REGISTER
	MOVEM Q1,CDBICR(P1)	;SAVE INITIAL TCR FOR LOGGER
	MOVE T2,Q1		;GET CONTROL REGISTER
CHST2:	CALL WTREG		;WRITE AND START WORLD
	RETSKP			;INDICATE SUCCESS

;ROUTINE TO GENERATE A CHANNEL XFER WORD FOR THE RH11
;CALL - C(T1) := MODE,,+COUNT(1B0 IF BACKWARDS) , C(T2) := PHYSICAL-ADDRESS
;RETURNS+1(ALWAYS):
;T1/ CCW FOR THIS TRANSFER
;NOTE: THE MAXIMUM TRANSFER WHICH WILL ALWAYS WORK IS 1 PAGE.
;	THE CALLER IS EXPECTED TO WORRY ABOUT PAGE CROSSING PROBLEMS

RH2CCW:	PUSH P,T1		;SAVE ARGUMENT
	HRRZ T3,T1		;GET WORD COUNT
	HLRZS T1		;GET MODE IN CORRECT PLACE
	TRZ T1,(1B0)		;CLEAR BACKWARDS BIT FROM MODE
	CAIN T1,IRMWRD		;CHECK FOR WORD MODE
	JRST RH2CW1		;YES SKIP JUNK
	SKIPLE T1		;CHECK MODE FOR LEGALITY
	CAILE T1,IRMMAX		; ...
	JRST [	BUG.(CHK,PH1IHM,PHYH11,HARD,<PHYH11 - Illegal hardware mode - word mode assumed>,,<<

Cause:	An illegal hardware mode was specified for an RH11 transfer.
	TOPS-20 is assuming word mode.
>)
		MOVEI T1,IRMWRD	;ASSUME WORD MODE
		JRST .+1]
	IDIV T3,MODTAB(T1)	;CONVERT TO WORDS
	SKIPE T4		;ROUND?
	AOS T3			;YES
RH2CW1:	POP P,T4		;GET ARGUMENT BACK
	MOVSI T1,(CHXFR)	;BUILD CCW
	DPB T3,CCYCNT		;STORE COUNT IN T1
	DPB T2,CCYADR		;STORE ADDRESS IN T1
	SKIPGE T4		;BACKWARDS?
	TLO T1,(CHREV)		;YES
	RET			;RETURN




;RH2CCA - EXTRACT THE PHYSICAL MEMORY ADDRESS FROM A CCW TRANSFER WORD.
;ARGUMENTS:
;  T1/	CCW WORD
;RETURNS:
;  T1/	ADDRESS, OR ZERO IF NONE


RH2CCA:	LDB T1,CCYADR		;GET ADDRESS FROM CCW WORD
	RET			;DONE

;ROUTINE TO DETERMINE IF ANY CHANNEL DEPENDENT ERROR OCCURED
;RETURN +1 IF ERROR , +2 IF NONE

CKERR::	RDIO T1,@RC1CS1(P1)	;GET RH11 STATUS
	ANDI T1,RH1ERR		;SEE IF ERRORS IN CONI
	MOVSI T3,(US.TAP)	;CHECK FOR MAGTAPE
	TDNN T3,UDBSTS(P3)	;TAPE?
	JRST CKERR2		;NO -- DON'T CHECK FOR FCE
	MOVEI T3,ER.FCE		;CHECK FOR FRAME COUNT ERROR
	TIOE T3,@RC1ER1(P1)	;CHECK REGISTER
	JRST CKERR3		;YES -- BUT IT IS OK
CKERR2:	SKIPGE CDBXFR(P1)	;DATA TRANSFER?
	JRST [	JUMPN T1,CKERR1	;NO - CONI ERRORS
		RETSKP]		;NO TO BOTH, RETURN GOOD
	TXNE T1,RH1CPE		;DATA TRANSFER, CHECK CONI ERRORS
	CALL CKERR1		;YES - FLAG AND DO CHANNEL CHECKS
CKERR3:	HRRZ T1,CDBICP(P1)	;NONE IN CONI, CHECK CHANNEL
	SKIPN T1,1(T1)		;GET STATUS WORD 1
	JRST CKERR1		;NOT STORED, CALL IT AN ERROR
	TLNE T1,(CS1MPE!CS1NXM!CS1RHE!CS1OVR) ;OR OTHER DEFINITE ERRORS?
	JRST [	TLNE T1,(CS1MPE) ;A PARITY ERROR?
		AOS CDBPAR(P1)	;YES - NOTE
		TLNE T1,(CS1NXM) ;NONEXISTANT MEMORY?
		AOS CDBNXM(P1)	;YES - NOTE
		TLNE T1,(CS1OVR) ;AN OVERRUN?
		AOS CDBOVR(P1)	;YES - NOTE
		CALL CKERR1	;INDICATE SOME ERROR HAPPENED
		JRST .+1]	;AND CONTINUE WITH LENGTH ANALYSIS
	MOVSI T2,(CS1LWC!CS1SWC) ;WORD COUNT ERROR BITS
	MOVSI T3,(US.TAP)	;MAGTAPE?
	TDNN T3,UDBSTS(P3)
	TLNN T1,(CS1LWC)	;CHECK FOR LONG WORD COUNT
	JRST CKERR4		;NO CHECK FOR ERROR RETURN
	MOVSI T1,(IS.RTL)	;FLAG LENGTH ERROR IN IORB
	IORM T1,IRBSTS(P4)	; ...
CKERR1:	MOVSI T1,(IS.DVE)	;DECLARE A DEVICE ERROR
	IORM T1,IRBSTS(P4)	; ...
	RET

CKERR4:	MOVSI T1,(IS.DVE)	;ERROR SET?
	TDNE T1,IRBSTS(P4)
	RET			;YES RETURN BAD
	RETSKP			;NOPE ALL GOOD

;ROUTINE TO GET CONI AND DATAI'S ON ERROR
;RETURNS T1=RC1CS1, T2=RC1CS2  T3=UBA MAP REGISTER,,UBA STATUS
ERRCNI::HRRZ T1,CDBICP(P1)	;GET CHANNEL LOGOUT AREA
	DMOVE T2,(T1)		; CS0,1
	DMOVEM T2,CDBCS0(P1)	;SAVE
	MOVE T2,2(T1)		;GET CS2
	MOVEM T2,CDBCS2(P1)	;SAVE
	MOVE T1,(T1)		;GET ICCW
	TLNE T1,(CHXFR)		;IF NOT JUMP,
	JRST ERCNI1		;DON'T TRY FOR CCWS
	LDB T1,CCYADR		;GET ADDRESS PART OF JUMP
	LSH T1,-PGSFT		;AS A PAGE
	PIOFF			;INTERLOCK WINDOW
	CALL MAPRCA		;MAP THIS PAGE
	HRRZ T2,CDBICP(P1)	;GET CHAN BLOCK AGAIN
	MOVE T3,(T2)		;GET JUMP CCW BACK
	ANDI T3,777		;GET ADDRESS WITHIN PAGE
	ADD T3,T1		;GET INDEX INTO WINDOW PAGE
	MOVE T4,(T3)		;GET FIRST POSSIBLE CCW
	MOVEM T4,CDBCC1(P1)	;SAVE IN CDB
	ADDI T3,1		;INCREMENT POINTER
	MOVEI T4,0		;DONT STORE GARBAGE IF OVERFLOW
	TRNE T3,777		;STILL WITHIN WINDOW BOUND?
	MOVE T4,(T3)		;YES - FETCH SECOND POSSIBLE CCW
	MOVEM T4,CDBCC1+1(P1)	;SAVE IN CDB
	CALL UNMRCA		;FREE WINDOW
	PION			;ALLOW INTERRUPTS AGAIN
ERCNI1:	RDIO T1,@RC1CS1(P1)	;READ STATUS 1
	RDIO T2,@RC1CS2(P1)	;READ STATUS 2
	HLLZ T4,UBADSW(P1)	;GET ADDRESS OF UBA
	RDIO T4,UNBSTW(T4)
	RDIO T3,@UBADSW(P1)	;GET STATUS
	HLRS T3			;SAVE INTERESTING BITS
	HRL T3,T4		;PUT TOGETHER
	RET

	SUBTTL INTERRUPT ROUTINE

;ENTER FROM PHYSIO W/ C(P1) := CDB CAUSING INTERRUPT.

RH2INT:	RDIO T2,@RC1CS2(P1)	;READ STATUS 2
	TRNN T2,RH1NED		;IS NED SET?
	JRST RH2IN1		;NO - GO ON
	BUG.(INF,P1NED3,PHYH11,HARD,<PHYH11 - NON EX DISK ON DONE OR ATN INTERRUPT>,<<T1,D>,<T2,D>>,<

Cause:	The RH11 status register reports a "non-existent disk" error on an
	attention or done interrupt.
>)
	CALL CLRRAE		;CLEAR RAE
RH2IN1:	MOVSI T2,(DO.AS)	;SET TO READ ATTENTION SUMMARY REGISTER
	CALL RDREGX		; READ (ANY UNIT WILL DO)
	MOVEI Q1,0		;INITIAL UNIT #
	ANDI T1,377		;MASK OUT IMPOSSIBLE BITS
	TRNN T1,377		;ANY ATTENTION ON?
	JRST NOATTN		;NO - CHECK DATA TRANSFER
ATCHKN:	LSHC T1,-1		;SHIFT 1 BIT OVER
	JUMPGE T2,ATCHK2	;JUMP IF NOT THIS UNIT
	PUSH P,T1		;SAVE REMAINDER
	HRRZ T1,Q1		;GET UNIT #
	CALL SETUDB		;SET UP P3 := UDB ADDRESS, T2 := DISPATCH
	JUMPE P3,ATNXU		;SPURIOUS INTERRUPT IF NO UNIT THERE
	SETZ P4,		;P4=0 IF NO ERRORS
	CALL UDSATN(T2)		;INFORM LOWER LEVEL
				;SETS LH(Q1) TO -1 IF POS DONE INTERRUPT
	JUMPN P4,ATNIRB		;IF DONE OR AN ERROR, GO RETURN
ATCHK1:	POP P,T1		;RESTORE ATTENTION REGISTER
ATCHK2:	SKIPE T1		;DONE IF ZERO
	AOJA Q1,ATCHKN		;INCR UNIT # AND TRY NEXT

NOATTN:	MOVE T1,CDBCNI(P1)	;PICK UP THE STATUS
	SKIPL T4,CDBXFR(P1)	;TRANSFER IN PROGRESS?
	JRST XFR		;YES - ANALYZE
NOATT1:	HLLE P4,Q1		;NO TRANSFER, SET P4=-1 OR 0
NOATT2:	MOVEI T1,RH1IE		;CHECK FOR INTERRUPT ENABLE
	TION T1,@RC1CS1(P1)	;IF INTERRUPT ENABLE SET LEAVE IT ALONE
	WRIOB T1,@RC1CS1(P1)	;OTHERWISE SET IT
	RETSKP			;AND LET PHYSIO DO ITS THING

XFR:	WRIOB T4,@RC1CS2(P1)	;SET UNIT NUMBER
	MOVEI T1,RH1RDY		;CHECK FOR READY
	TIOE T1,@RC1CS1(P1)
	SKIPN CDBCNI(P1)	;CHECK FOR DATA OPERATION
	JRST [	SETZ P4,	;YES, MUST BE FROM ERRPSI (PHYRP4)
		JRST NOATT2]	; SO JUST DISMISS THE INTERRUPT
	SETZM CDBCNI(P1)	;SET NO DATA OPERATION IN PROGRESS
	HRRZ T1,CDBICP(P1)	;FIND THE INITIAL CCW
	MOVE T1,2(T1)
	RDIO T2,@RC1WC(P1)	;FIND THE WORD COUNT
	MOVNS T2		;MAKE IT +
	ANDI T2,177777		;MASK OFF GOOD BITS
	LSH T2,-1		;MAKE  WORDS (PDP10)
	LDB T3,CCYCNT		;GET OLD COUNT
	DPB T2,CCYCNT		;SET IN NEW CCW
	SUB T3,T2		;FIND COUNT LEFT
	ADD T1,T3		;MAKE ADDRESS
	HRRZ T2,CDBICP(P1)	;FIND THE ADDRESS AGAIN
	MOVEM T1,2(T2)		;STORE IN LOGOUT AREA
	LDB T1,CCYCNT		;FIND THE COUNT AGAIN
	SKIPN T1		;SET WORD COUNT 0 IF TRUE
	TLOA T1,(CS1NC0)	;SET BIT
	TLO T1,(CS1LWC)
	HLLZS T1		;ZERO RIGHT HALF
	RDIO T3,@RC1CS2(P1)	;GET CS2
	TXNE T3,RH1NEM		;NON EXISTANT MEM?
	TXO T1,CS1NXM		;SET NXM
	TXNE T3,RH1DLT		;CHECK FOR DATA LATE
	TXO T1,CS1OVR		;DECLARE OVERRUN
	TXNE T3,RH1PE!RH1MDP	;PARITY ERROR OF SOME SORT
	TXO T1,CS1MPE		;FLAG IT
	TXNE T3,RH1PGE!RH1MXF	;PROG ERROR OR MISSED TRANSFER
	TXO T1,CS1RHE		;CALL IT AN RH ERROR
	TLO T1,400000		;INDICATE CHANNEL LOGOUT
	MOVEM T1,1(T2)		;SET IN CHANNEL LOGOUT
	HRRZ T1,CDBXFR(P1)	;GET UNIT NUMBER OF XFERRING UNIT
	ANDI T1,7		;MASK UNIT NUMBER
	CALL SETUDB		;SET UP P3,T2
	CALL UDSINT(T2)		;CALL INTERRUPT SERVICE
	 CALLRET CLRCHL		;ERRORS BELOW, RESET CHAN AND RETURN
	CALL CLRCHL		;NO ERRORS
	RETSKP

;HERE WHEN AN IORB FINISHED DURING ATTN INT SERVICE, OR A SEEK ERR

ATNIRB:	HRRZS P4		;CLEAR ANY ERROR FLAG
	POP P,(P)		;SCRAP STACK
	MOVEI T1,RH1IE		;CHECK FOR INTERRUPT ENABLE
	TION T1,@RC1CS1(P1)	;IF INTERRUPT ENABLE SET LEAVE IT ALONE
	WRIOB T1,@RC1CS1(P1)	;OTHERWISE SET IT
	RETSKP			;AND RETURN

;HERE ON AN INTERRUPT FROM A NONEXISTANT UNIT.

ATNXU:	PUSH P,Q1		;SAVE A REGISTER
	HRRZ Q2,Q1
	WRIOB Q2,@RC1CS2(P1)	;SET UNIT NUMBER
	CALL RH2UNA		;SELECT A UNIT
	ADD Q2,P1
	MOVEM P3,CDBUDB(Q2)	;STORE NEW UDB POINTER
	POP P,Q1
	MOVEI T2,1		;CLEAR ATTENTION DIRECTLY
	LSH T2,(Q1)		;POSITION BIT
	HRLI T2,(DO.AS)		;IN ATTENTION SUMMARY REGISTER
	CALL WTREGX		;SPECIAL REGISTER, NEEDS NO UNIT
	JRST ATCHK1		;AND CONTINUE LOOKING


;HERE WHEN DONE IS UP AND THE CHANNEL IS NOT OCCUPIED.

	SUBTTL ECC CHANNEL LOGIC

;THE FOLLOWING ROUTINES, AS IN SEVERAL OTHER PLACES, ASSUME THE
;CCW LIST IS EXACTLY ONE WORD LONG.

;HERE TO RETURN THE PHYSICAL ADDRESS OF THE START OF THE LAST BLOCK
;TRANSFERRED.

;	CALL ECCADR
;RETURNS+1(ALWAYS):
;T1/ PHYSICAL ADDRESS OF START OF LAST SECTOR TRANSFERRED
ECCADR::HRRZ T1,CDBICP(P1)	;GET STATUS AREA
	MOVE T1,2(T1)		;GET CS2, THE UPDATED CCW
	LDB T1,CCYADR		;GET ADDRESS PART
	SUBI T1,1		;BACK UP INTO LAST SECTOR TRANSFERRED
	TRZ T1,177		;MASK TO START OF 128WD BLOCK
	RET

;HERE TO UPDATE THE CCW LIST TO TRANSFER ANY DATA AFTER THE SECTOR
;WHICH WAS ECC CORRECTED.

;	CALL ECCUCL
;RETURNS+1:
;	NO MORE DATA TO TRANSFER
;RETURNS+2:
;	UPDATED CCW AT CDBCCL(P1)
;T1/ NUMBER OF WORDS TRANSFERED INCLUDING SECTOR ECC CORRECTED

ECCUCL::HRRZ T4,CDBICP(P1)	;GET STATUS AREA
	MOVE T1,2(T4)		;GET UPDATED CCW
	LDB T3,CCYCNT		;GET WORD COUNT
	JUMPE T3,R		;IF 0, ALL DONE.
	TLO T1,(CHXFR!CHLST)	;FORCE LAST TRANSFER
	MOVEM T1,CDBCCL(P1)	;STORE IN CDB
	SETZM CDBCCL+1(P1)	;CLEAR TAIL
	CALL PHYCNT		;GET IORB COUNT
	SUB T1,T3		;LESS WORDS TRANSFERRED
	RETSKP

	TNXEND
	END
