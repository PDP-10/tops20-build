; Edit= 9175 to ANAUNV.MAC on 28-Jun-90 by GSCOTT
;GTHST% function .GTHNT returns the interface type in SIXBIT in a unused word.
; Edit= 9160 to ANAUNV.MAC on 9-Mar-90 by GSCOTT
;Fixes for MAXLDR \=4, keep statistics in IMPEC9, give failure if SNDIM%
;fails, change XNENTs for .DBGIM and IMICHK to XRENTs, set message subtype in
;IMPHDR, fix ready line deadlock at ANXRSS (thanks to MRC). 
; Edit= 9156 to ANAUNV.MAC on 7-Mar-90 by GSCOTT
;Implement DNS resolver, including support to read file
;SYSTEM:INTERNET.NAMESERVERS, use of monitor's host tables as a cache of data,
;new IPOPR% function .IPDNS, extend GTHST% functions .GTHSN and .GTHNS, and
;new GTHST% functions .GTHPN, .GTHMX, .GTHAA, .GTHVN, .GTHOS, and .GTHDN.
; Edit= 9140 to ANAUNV.MAC on 16-Jan-90 by GSCOTT, for SPR #22074
;Implement Karn and Jacobson algorithms for retransmission timeout
;calculation, slow start, and congestion avoidance, as specified by RFC1122.
; Edit= 9135 to ANAUNV.MAC on 28-Nov-89 by GSCOTT
;Allow alternate IP address using "IPNIA" interface in INTERNET.ADDRESS. 
; Edit= 9115 to ANAUNV.MAC on 18-Jul-89 by GSCOTT
;Merge a fair number of TCP/IP bug fixes and performance enhancements from
;Stanford and the SRI-NIC. 
; UPD ID= 8468, RIP:<7.MONITOR>ANAUNV.MAC.5,   9-Feb-88 11:48:07 by GSCOTT
;TCO 7.1218 - Update copyright notice.
; UPD ID= 2040, SNARK:<6.1.MONITOR>ANAUNV.MAC.7,   3-Jun-85 14:04:41 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 1253, SNARK:<6.1.MONITOR>ANAUNV.MAC.6,   1-Jan-85 15:38:33 by PAETZOLD
;More TCO 6.1.1030 - Make NT.CIP stuff conditional to make 5.4 happy.
; UPD ID= 1030, SNARK:<6.1.MONITOR>ANAUNV.MAC.5,  12-Nov-84 15:23:23 by PAETZOLD
;TCO 6.1041 - Move ARPANET to XCDSEC
; UPD ID= 997, SNARK:<6.1.MONITOR>ANAUNV.MAC.4,   7-Nov-84 14:38:08 by PRATT
;TCO 6.1.1030 - Add defs for IPCI 
; UPD ID= 919, SNARK:<6.1.MONITOR>ANAUNV.MAC.3,  23-Oct-84 19:49:46 by PAETZOLD
; UPD ID= 282, SNARK:<TCPIP.5.4.MONITOR>ANAUNV.MAC.11,  24-Sep-84 13:53:16 by PURRETTA
;Update copyright notice.
; UPD ID= 192, SNARK:<TCPIP.5.4.MONITOR>ANAUNV.MAC.9,  17-Jun-84 13:07:03 by PAETZOLD
;NT.DEV initialization should not be under ANXN conditional.
; UPD ID= 167, SNARK:<TCPIP.5.4.MONITOR>ANAUNV.MAC.8,   9-Jun-84 11:28:49 by PAETZOLD
;Work on making NI and ANX stuff conditional.  Straighten up some stuff.
; UPD ID= 145, SNARK:<TCPIP.5.4.MONITOR>ANAUNV.MAC.7,  30-May-84 14:23:56 by PAETZOLD
;Remove BBN TCP JSYS flags from here.
; UPD ID= 67, SNARK:<TCPIP.5.4.MONITOR>ANAUNV.MAC.6,   4-May-84 15:18:16 by PRATT
;Add GH%DMB, use this address, host does not do ARP
; UPD ID= 38, SNARK:<TCPIP.5.4.MONITOR>ANAUNV.MAC.5,  24-Apr-84 13:06:42 by PRATT
;Add GH%ARP, this ght entry has been updated by ARP
; UPD ID= 37, SNARK:<TCPIP.5.4.MONITOR>ANAUNV.MAC.4,  16-Apr-84 13:00:22 by PRATT
;Add a comment about .NIINT having to be offset zero
; UPD ID= 11, SNARK:<TCPIP.5.4.MONITOR>ANAUNV.MAC.3,   2-Apr-84 20:21:31 by PRATT
;IPNI NCT definitions
; UPD ID= 1, SNARK:<TCPIP.5.4.MONITOR>ANAUNV.MAC.2,  20-Mar-84 19:52:11 by PAETZOLD
;Add definitions for IPNIDV mapping file offsets
; UPD ID= 3828, SNARK:<6.MONITOR>ANAUNV.MAC.9,  29-Feb-84 18:17:41 by PAETZOLD
;More TCO 6.1733 - ANBSEC and MNTSEC removal.  Bug fixes.  Cleanup.
;<TCPIP.5.3.MONITOR>ANAUNV.MAC.6,  6-Dec-83 23:47:26, Edit by PAETZOLD
;Add TCDUR. 
;Get rid of HHSIZ. 
;TCO 6.1867 - Delete SAVP1 macro. 
;TCO 6.1866 - Add NTODTI offset to the NCT. Add NTODTI word to AN20 NCT.
;Move gateway block symbols to here from IPIPIP.
;<TCPIP.5.1.MONITOR>ANAUNV.MAC.35, 5-Jul-83 22:32:15, Edit by PAETZOLD
;TCP Changes for 5.1


;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1990.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


	UNIVERSAL ANAUNV - Universal for TOPS-20 TCP/IP

	SALL
	SEARCH PROLOG,MONSYM,MACSYM

	FT.BCP==1			;ALLOW BBN JSYS FOR NOW
	IFNDEF FT.BCP,<FT.BCP==:0>	;DEFAULT IS NOT BBN JSYS INTERFACE

	Subttl	Table of Contents

;		     Table of Contents for ANAUNV
;
;				  Section		      Page
;
;
;    1. Parameters for 1822 (from IMPPAR)  . . . . . . . . . .   4
;    2. Internet Parameters (from IPPAR) . . . . . . . . . . .   6
;    3. TCP Parameters (from TCPPAR) . . . . . . . . . . . . .  26
;    4. Defintions for UDP . . . . . . . . . . . . . . . . . .  43
;    5. Definitions for Multinet . . . . . . . . . . . . . . .  44
;    6. Internet-Ethernet Interface Definitions  . . . . . . .  57
	SUBTTL Parameters for 1822 (from IMPPAR)

NDG ANX0,520			;[9115] Address of first AN20
NDG ANX1,530			;[9115] Address of second AN20

		;Define the words in a net buffer.
.NBHDR==0		;WORD 0 IS THE BUFFER HEADER (QUEUE POINTER AND SIZE)
.NBLD0==<MAXLDR-3>	;[9160] IMP-to-host leader, word 0
.NBLD1==<MAXLDR-2>	;[9160] I-H leader, word 1
.NBLD2==<MAXLDR-1>	;[9160] I-H leader, word 2
.NBHHL==<MAXLDR+0>	;[9160] Host-to-host leader
.NBDW0==<MAXLDR+1>	;[9160] Data word zero
ILDRSZ==<.NBLD2-.NBLD0+1> ;[9160] Length of IMP-host leader
HLDRSZ==<.NBHHL-.NBLD0+1> ;[9160] Length of host-host leader + IMP-host leader

				;Define the fields in the buffer header.
DEFSTR NBQUE,.NBHDR,17,18	;Link for queue of buffers
DEFSTR NBBSZ,.NBHDR,35,18	;Size of the buffer

				;Fields in IMP-TO-HOST leader
DEFSTR IHFTY,.NBLD0,7,4		;FORMAT TYPE FIELD. MUST BE 17 FOR LONG LDRS
	ITY%LL==17		;TYPE 17 FOR LONG LEADERS FROM IMP
DEFSTR IHNET,.NBLD0,15,8	;NETWORK NUMBER MSG GOES TO/FROM
DEFSTR IHLDF,.NBLD0,23,4	;LEADER FLAGS
DEFSTR IHMTY,.NBLD0,31,8	;MESSAGE TYPE
DEFSTR IHHT2,.NBLD0,35,4	;HIGH 4 BITS OF HANDLING TYPE
DEFSTR IHHTY,.NBLD1,3,4		;HANDLING TYPE, LOW 4 BITS
	HTY%NP==7		;NUMBER OF PACKETS
	HTY%HP==200		;HIGH PRIORITY BIT
DEFSTR IHADR,.NBLD1,27,24	;ADDRESS (HOST AND IMP)
				;SUBSTRUCTURES FOR ABOVE
  DEFSTR IHHST,.NBLD1,11,8	;HOST (ON IMP)
  DEFSTR IHIMP,.NBLD1,27,16	;IMP NUMBER
DEFSTR IHLNK,.NBLD1,35,8	;LINK (TOP 8 OF MESSAGE ID)
DEFSTR IHMI2,.NBLD2,3,4		;REST OF MESSAGE ID
DEFSTR IHSTY,.NBLD2,7,4		;SUBTYPE
	STY%FC==0		;NORMAL FLOW-CONTROLLED
	STY%UC==3		;UNCONTROLLED FLOW
DEFSTR IHLEN,.NBLD2,23,16	;LENGTH OF MESSAGE
DEFSTR IHPD1,.NBLD2,35,12	;LOW 12 BITS MUST BE MOVED TO FLUSH PADDING

HSTMSK==037777777777		;Host address as one 32-bit quantity

; For user interface only, old-style Imp message leader bits

IMPHIP==1B0			;Hi priority imp msg leader bit
FRMIMP==1B1			;From imp

				;Fields in Host-to-host leader
DEFSTR HHCNT,.NBHHL,27,16	;NUMBER OF BYTES IN THIS MESSAGE


			;Imp-to-Host parameters
FKHOST==^D252		;Fake hosts are 252. thru 255. on each Imp.

			;Special link numbers required for dispatching
INTLNK==^D155		;Internet traffic

;Message types in IHMTY (I2H = Imp to Host, & v.v.)

.IHREG==0		;Regular messages (Host-to-host)
.IHEWO==1		;Error, WithOut message ID (H2I)
.IHEIL==1		;Err in leader (I2H)
.IHHGD==2		;Host Going Down (H2I)
.IHIGD==2		;Imp Going Down (I2H)
.IHNOP==4		;No-op, takes padding request, tells my address.
.IHRFN==5		;Ready For Next message (I2H)
.IHDHS==6		;Dead Host Status (I2H)
.IHDDD==7		;Destination DeaD (I2H)
.IHERW==^D8		;Error, With message ID (H2I)
.IHERD==^D8		;Error in Data (I2H)
.IHINC==^D9		;Incomplete transmission (I2H)
.IHRES==^D10		;Interface reset (I2H)

; Special Internet parameters

.INVER==.NBHHL+0	;Word in H-H leader containing Internet version
.INPRO==.NBHHL+2	;Word in H-H leader containing Internet protocol

DEFSTR(INPVR,.INVER,3,4)	;Internet packet version
  .INTVR==4			;Current Internet version
DEFSTR(INPPR,.INPRO,15,8)	;Internet packet protocol
  .SCRFM==2			;Secure TCP format

	SUBTTL	Internet Parameters (from IPPAR)

;FR			; Flags, preserved by routines
;T1			; Temporary ACs.  Maybe freely clobbered.
;T2			; Subrs never expected to preserve these.
;T3			; Used to send args to subrs.
;T4			; Functions return value in T1
NTEMPS==4		; Number of temps. (used only in TEMP macro)
;Q1			; Locals.  Always preserved by subrs.
;Q2
;Q3
;P1			; More locals.
NLOCLS==4		; Number of locals (used only in LOCAL macro)
FR==0			; Be sure that AC0 is what we use for flags
BFR=P2			; Global ACs.  Implicit args to lower level
JFN=P2
TPKT=P3			; Subrs.  Changed only with great care.
PKT=P4
DEV=P4
TCB=P5			; Pointer to connection (TCP)
;P6			; Frame base used by .TRSET
;CX			; Scratch AC used by Jxxx macros and stack stuff
;P			; Push pointer.  Always covers the stack.

DEFINE SETSEC (AC,SECTION) <HRLI AC,SECTION>
DEFINE PUTSEC (AC,SECTION)<HRLZI AC,SECTION>
DEFINE GIW (ADDR,X<0>,I<0>) <<I>B1!<X>B5!<ADDR>B35>

DEFINE MKWAIT(A),<
	ROT T2,-^D9
	LSHC T1,^D27
	HRRI T1,A>

; Some auxilliary macros to be used by local variable stuff

DEFINE $INIT <
	DEFINE $INFO(X,Y)<X
Y>
$ACVNM==0
$STVNM==0
$TMVNM==0
>

DEFINE $REMOTE(Z)<$INFO(<DEFINE $INFO(X,Y)><X
Z,Y>)>

DEFINE $HERE <
	$INFO
	$INIT>

DEFINE $IPMSG(L,M,A,S,T) <PRINTX M at L (A,S,T)>

DEFINE $POP(L) <
	GSOPDEF %POP%,<POP P,>
	$REMOTE (<%POP% L>)>

DEFINE $PURGE (L)<$REMOTE (<PURGE L>)>



;Macro  to be used at entry to subroutine to define local variables and
;assign ACs to them.

DEFINE LOCAL(LIST) <
	IFG $ACVNM,<	$IPMSG(\.,<?LOCAL: Missing RESTORE>,\$ACVNM)
			$ACVNM==0>
	IRP LIST,<	IFGE $ACVNM-NLOCLS,<$IPMSG(\.,<?Too many LOCALs>)>
			$DFACL(LIST,\<$ACVNM>)
			$ACVNM==$ACVNM+1>>

DEFINE $DFACL(N,V) <
	IFDEF N,<$IPMSG(\.,<?LOCAL AC N already defined>)>
	PUSH P,T1+NTEMPS+V
	N==T1+NTEMPS+V
	$PURGE N
	$POP T1+NTEMPS+V>

;Macro for giving names to temporary AC's

DEFINE	TEMP(LIST) <
	IFG $TMVNM+$STVNM+$STVNM,<	$IPMSG(\.,<?TEMP: Missing RESTORE>,\$ACVNM,\$STVNM,\$TMVNM)
					$STVNM==0
					$TMVNM==0
					$ACVNM==0>
	IRP LIST,<	IFGE $TMVNM-NTEMPS,<$IPMSG(\.,<?Too many TEMPs>)>
			$DFTMP(LIST,\<$TMVNM>)
			$TMVNM==$TMVNM+1>>

DEFINE $DFTMP(N,V) <
	IFDEF N,<$IPMSG(\.,<?TEMP N already defined>)>
	N==T1+V
	$PURGE N>



; Macro for allocating locals on the stack

DEFINE	STACKL(LIST) <
	IFG $ACVNM+$STVNM,<	$IPMSG(\.,<?STACKL: Missing RESTORE>,\$ACVNM,\$STVNM)
				$ACVNM==0
				$STVNM==0>
	IRP LIST,<	$STKL1(LIST)>
	JSP CX,.TRSET##
	$STVNM,,$STVNM>

DEFINE $STKL1(PAIR)<$STKL2(PAIR)>

DEFINE $STKL2(NAME,SIZE) <
	$STKL3(NAME,\$STVNM)
	IFB <SIZE>,<$STVNM==$STVNM+1>
	IFNB <SIZE>,<$STVNM==$STVNM+SIZE>>

DEFINE $STKL3(NAME,LOC) <
	IFDEF NAME,<$IPMSG(\.,<?STACKL local NAME already defined>)>
	DEFINE NAME<^O'LOC+1(P6)>
	$PURGE NAME>

; Macro to restore all locals

DEFINE RESTORE <
	IFLE $ACVNM+$STVNM+$TMVNM,<$IPMSG(\.,<?Extra RESTORE macro>,\$ACVNM,\$STVNM,\$TMVNM)>
	$HERE>
$INIT

; Macro to leave a subroutine.
; Assembles as a RET if no RESTORE is needed.

DEFINE EXIT(TAG) <
	IFN $ACVNM,<JRST TAG>
	IFE $ACVNM,<RET>>



;Internet Gateway Parameters -- determine buffer and packet sizes:

;MF==^D<512/8>	; Fragments are a multiple of this size.
;		;  Must be power of 2.
;M0==^D144	; Segment size guaranteed not to require Internet
;		;  fragmentation.  Net input buffer must be this big.
;M1==4*M0	; Smallest segment size all Internet reassemblers
;		;  guarantee to handle.
;M2==M1		; Largest segment that a particular Internet layer is
;		;  able to receive, independent of reassembly.  Local
;		;  implementation limitation.
;M3==M1		; Largest seg size a particular protocol implementation
		;  will accept.  Determined by mutual agreement.
;M4==^D<2_14>	; Largest segment Internet level can talk about
;Constraints on the above:
;MF le M0 le M1 le M2 le M3  and M2 le M4.
;M0 chosen to so that one subtype-3 ARPANET packet can contain an
;Internet fragment.

; Where to get interface number from GWAY or LCLHID word

DEFSTR INTNUM,,3,4

; Protocol table definitions

.INTPC==0	;(Extended) address of Time Check routine (xxxCHK)
.INTPF==1	;Run request flag (xxxFLG)
.INTPI==2	;(Extended) address of Initialization routine (xxxINI)
.INTPQ==3	;(Extended) address of Input Queue head (xxxIPQ)
.INTPO==4	;Protocol ON flag (0 is off) (xxxON)
.INTPL==5	;Protocol number (.xxxFM)
.INTPP==6	;(Extended) address of Processing routine (xxxPRC)
.INTPS==7	;Protocol Segment Id (xxxSID)
.INTPT==^D8	;Next run Time, msec (xxxTIM)
.INTPE==^D9	;Handle an ICMP error message for this protocal (xxxICM)
.INTPZ==^D10	;Table length



;Definitions of network formats
;These extract a network number from right justified host number.

DEFSTR  NETCLS,0,6,3			; Bits identifying network class

DEFSTR	NETCA,0,11,8			; Class A network. High 8 bits
.NETCA==1B4				; Bit is off for a class A network

DEFSTR	NETCB,0,19,16			; Class B network. High 16 bits
.NETCB==1B5				; Bit is on for a class B network

DEFSTR	NETCC,0,27,24			; Class C network. High 24 bits.

; Macro for extracting the network number from a host address,
; both SRC and DST must be AC's (obviously).

DEFINE	NETNUM(DST,SRC,%HERE)<
	TXNN	SRC,.NETCA		; Class A network?
	 JRST	[LOAD	DST,NETCA,+SRC	; Get number
		 JRST	%HERE]
	TXNN	SRC,.NETCB		; Class B?
	 JRST	[LOAD	DST,NETCB,+SRC
		 JRST	%HERE]
	LOAD	DST,NETCC,+SRC		; Must be class C
%HERE:!>


;PACKET structure (indexed by PKT):

PKTQ==<.P==0>			;Offset of Packet queue
PKTFLG==<.P==.P+QSZ>		;Packet flags -- internal use only
DEFSTR(PFLGS,\<PKTFLG>,35,36)
  DEFSTR(PPROG,\<PKTFLG>,0,1)	;non-0 means program still needs pkt (eg. RX)
  DEFSTR(PINTL,\<PKTFLG>,1,1)	;non-0 means int. level still has Pkt
  DEFSTR(PFSIZ,\<PKTFLG>,2,1)	;non-0 if this is a full size pkt
				;MAXPSZ is buffer length & PACKSZ is IMPPHY length
				;I.E. it can be recycled as an input buffer
  DEFSTR(PRXD,\<PKTFLG>,3,1)	;non-0 means packet has been retrans'd
  DEFSTR(PSCR,\<PKTFLG>,4,1)	;non-0 if packet on a secure connection
  DEFSTR(PNLCL,\<PKTFLG>,5,1)	;non-0 to prevent local delivery
				;I.E. Send it to the source from the dest
  DEFSTR(PSROU,\<PKTFLG>,6,1)	;non-0 if user is source routing
  DEFSTR(PLCLO,\<PKTFLG>,7,1)	;0 if packet came from net, 1 if from host
  DEFSTR(PLKCD,\<PKTFLG>,8,1)	;[9115] TVT packets/buffers locked flag

PKTSII==<.P==.P+1>		;Start of internal information

DEFSTR(PTG,\<.P>,35,36)		;PACKET.TIME-GENERATED
.P==.P+1
DEFSTR(PXT,\<.P>,35,36)		;PACKET.XMIT-TIME
.P==.P+1
DEFSTR(PRXI,\<.P>,35,36)	;PACKET.REXMIT-INTERVAL
.P==.P+1
DEFSTR(PDCT,\<.P>,35,36)	;PACKET.DISCARD-TIME
.P==.P+1
DEFSTR(PTS,\<.P>,35,36)		;PACKET.TIMESTAMP
.P==.P+1
DEFSTR(PESEQ,\<.P>,35,36)	;PACKET.END-SEQUENCE (for TCP)

LCLPKT==<.P==.P+1>		;Marks start of local substructure

;Area  between LCLPKT and PKTELI must be big enough to hold the biggest
;possible local leader including fake free header. The  first  word  of
;all local packets is a fake IMPPHY-style free storage header.

;[9160] IMP96L==LCLPKT		;96-bit ARPANET Leader (should be flushed)
MAXLDR==4			;Current maximum local leader (Arpanet)
PKTELI==<.P==.P+MAXLDR>		;End Local Information

;Some related numbers:

;INTXPB (in STG) contains maximum PIPL for any interface.
;INTXPW (in STG) contains the maximum # words for PACKET structure.
;Note:	Packets buffers of this size are "full size" and have PFSIZ set.

;PACKSZ==PKTELI-LCLPKT+<M2+3>/4	;Num. words in IMPPHY Pkt
;MAXPSZ==LCLPKT+PACKSZ		;Maximum packet size
;Note:	MAXWPM <-> NBBSZ <-> PACKSZ <=> PFSIZ <=> MAXPSZ (for GETBLK)



			
			        ;Internet header word offsets
.IPKVR==0		        ;Word with version, type of service, etc
.IPKSG==1		        ;Word with segmentation info
.IPKPR==2		        ;Word with time to live, checksum, protocol
.IPKSH==3		        ;Word with source host
.IPKDH==4		        ;Word with destination host
MINIHS==<.IPKDH+1>*4	        ;Minimum Internet Header size (bytes)

DEFSTR(PIVER,PKTELI+.IPKVR,3,4)		;PACKET.IP.VERSION
DEFSTR(PIDO,PKTELI+.IPKVR,7,4)		;PACKET.IP.DATA-OFFSET
DEFSTR(PITOS,PKTELI+.IPKVR,15,8)	;PACKET.IP.TYPE-OF-SERVICE
					;Overlays for the above:
  DEFSTR(PIPRC,PKTELI+.IPKVR,10,3)	;PACKET.IP.PRECEDENCE
  DEFSTR(PILDY,PKTELI+.IPKVR,11,1)	;PACKET.IP.LOW-DELAY
  DEFSTR(PIHTR,PKTELI+.IPKVR,12,1)	;PACKET.IP.HIGH-THROUGHPUT
  DEFSTR(PIHRL,PKTELI+.IPKVR,13,1)	;PACKET.IP.HIGH-RELIABILITY
					;2 Unused bits
DEFSTR(PIPL,PKTELI+.IPKVR,31,16)	;PACKET.IP.PACKET-LENGTH
DEFSTR(PISID,PKTELI+.IPKSG,15,16)	;PACKET.IP.SEGMENT-ID
DEFSTR(PIFLG,PKTELI+.IPKSG,18,3)	;PACKET.IP.FLAGS
					;Overlays for the above:
					;1 Unused bit
  DEFSTR(PIDF,PKTELI+.IPKSG,17,1)	;PACKET.IP.DONT-FRAGMENT
  DEFSTR(PIMF,PKTELI+.IPKSG,18,1)	;PACKET.IP.MORE-FRAGMENTS
DEFSTR(PIFO,PKTELI+.IPKSG,31,13)	;PACKET.IP.FRAGMENT-OFFSET
DEFSTR(PITTL,PKTELI+.IPKPR,7,8)		;PACKET.IP.TIME-TO-LIVE
DEFSTR(PIPRO,PKTELI+.IPKPR,15,8)	;PACKET.IP.PROTOCOL
  .ICMFM==1				;Internet Control Message protocol
  .SCRFM==2				;Secure TCP format
  .GGPFM==3				;Gateway-gateway protocol
  .TCPFM==6				;TCP format
DEFSTR(PICKS,PKTELI+.IPKPR,31,16)	;PACKET.IP.HEADER-CHECKSUM
DEFSTR(PISH,PKTELI+.IPKSH,31,32)	;PACKET.IP.SOURCE-HOST
DEFSTR(PIDH,PKTELI+.IPKDH,31,32)	;PACKET.IP.DESTINATION-HOST



;Internet options, if any, are here.
;***** beware

MAXIOS==<.RTJST(-1,PIDO)*4-MINIHS>	; Maximum # Option bytes possible


;Case 1: 
;A  single  byte of option code ENDOPT is and must be 0. This marks the
;end of the option list. NOPOPT is and must be 1. This is one byte long
;and has no purpose.

;Case 2:
;General  form  of options is 1 byte of "kind", 1 byte of total length,
;and N-2 bytes of data, where N is read from the length byte.

;All  options  are  included under the appropriate checksum. IP Options
;which are copied on fragmentation if this bit is set

CPYOPT==200

;Class 0: Control

;END	End of options		ENDOPT
;NOP	Filler			NOPOPT
;LSR	Loose Source Routing	LSROPT,Len,ptr.ge.4,<route data>
;RRT	Record Route		RRTOPT,Len,ptr.ge.4,<route data>
;SID	Stream ID		SIDOPT,4,I,D
;SSR	Strict Source Routing	SSROPT,Len,ptr.ge.4,<route data>
;STY	Autodin II security	STYOPT,^D11,S,S,C,C,H,H,TCC,TCC,TCC

;Class 1: Reserved for future use	(OBSOLETE)

;ERR	Error
;SOP	Secure Open
;SCL	Secure Close

;Class 2: Debugging and measurement

;TSP	Timestamp		TSPOPT,Len,Ptr,OFLW/FLAG,[<inet adr>],<tsmp>
;Flag 0 <timestamp> only
;     1 <internet adr>,<timestamp> pairs
;     3 <internet adr>,<timestamp> pairs with <internet adr> pre-specified

;Class 3: Reserved for future use



;General IP Option generation macro

DEFINE IPOPTS (USER,RECV,ECHO)<
  OPTION(I,END,,^D0,^D1,USER,RECV,ECHO)
  OPTION(I,NOP,,^D1,^D1,USER,RECV,ECHO)
  OPTION(I,LSR,C,^D3,^D7,USER,RECV,ECHO)
  OPTION(I,RRT,,^D7,^D7,USER,RECV,ECHO)
  OPTION(I,SID,C,^D8,^D4,USER,RECV,ECHO)
  OPTION(I,SSR,,^D9,^D7,USER,RECV,ECHO)
  OPTION(I,STY,C,^D2,^D11,USER,RECV,ECHO)

  OPTION(I,TSP,,^D68,^D8,USER,RECV,ECHO)

> ; End of DEFINE IPOPTS

; Define Option Names

DEFINE OPTION(TYPE,NAME,COPY,NUMBER,LENGTH,USER,RECV,ECHO)<
IFDIF <COPY>,<C>,<	NAME'OPT==NUMBER	>
IFIDN <COPY>,<C>,<	NAME'OPT==CPYOPT+NUMBER	>>

IPOPTS



;Packet Printer Buffer

;Size and layout of the Packet Printer Buffer.
;Must  make  assumption  about the size of the per-protocol area in the
;packet:

;Assume  max  protocol to be TCP at 17(8) words & allow 2 words of data
;Size of a packet header including options:

PPBFSZ==PKTELI+.RTJST(-1,PIDO)+17+2-LCLPKT

;Size of the Packet Printer Buffer including control words:

DEFSTR(DFLAG,PPBFSZ+0,35,36)	;PPB.FLAGS
DEFSTR(DSS,PPBFSZ+1,17,18)	;PPB.SOURCE STATE
DEFSTR(DDS,PPBFSZ+1,35,18)	;PPB.DESTINATION STATE
DEFSTR(DTIME,PPBFSZ+2,35,18)	;PPB.REPORT TIME
DEFSTR(DPKTP,PPBFSZ+3,17,18)	;PPB.PACKET ADDRESS
DEFSTR(DPTRC,PPBFSZ+4,35,36)	;PPB.TRACE BITS

PPBWDS==PPBFSZ+5+1+LCLPKT	;Remove LCLPKT, add to PPBFSZ & reorder

;Flag bits in PPFLAG cell (Kept in F locally):

PP%MT==1B0	;Buffer is empty
PP%SK==1B1	;Source address is known
PP%DK==1B2	;Destination address is known
PP%SNT==1B3	;Packet has been sent
PP%RCV==1B4	;Packet has been received
PP%REX==1B5	;Packet retransmitted
PP%PZ==1B6	;Packet passed through Packetizer
PP%RA==1B7	;Packet passed through Reassembler
PP%GSS==1B8	;Got Source state (LH of PPSTAT valid)
PP%GDS==1B9	;Got Dest state (RH of PPSTAT valid)
PP%DUN==1B10	;Packet printable



;Packet Printer Trace Codes
;Old codes

PT%XX0==^D0	;    BG is flushing packet printer buffer
PT%XX1==^D1	;PZ  Generated normal packet "being output"
PT%XX2==^D2	;SNT EMTPKT, ABTNTC
PT%XX3==^D3	;RCV PKT on no connection, for RA
PT%XX4==^D4	;RA  Reassembly from packet completed
PT%XX5==^D5	;    IP Flushed (checksum, PKT on closed conn)
PT%XX6==^D6	;    INPUT finished: New SYN, DUP, IGN, no SEQ#, sent RST
PT%XX7==^D7	;SNT Sent a RST in response to received packet
PT%XX8==^D8	;REX Retransmitted a PKT

; New codes  (NB don't use 400000,,0)

			;Bit indicating validity
PP%%VR==100000,,0	;Registers valid
PT%%VH==040000,,0	;Higher level protocol (TCB=14)
PT%%VB==020000,,0	;User buffer (BFR=11)
PT%%VP==010000,,0	;Protocol pkt (T/CPKT=12)
PT%%VI==004000,,0	;IP (PKT=13)
PT%%VG==002000,,0	;Gateway (PKT=13)
PT%%VN==001000,,0	;Local Net (PKT=13)

			;Bit indicating error level
PT%%EI==000400,,0	;Internal error
PT%%EU==000200,,0	;Unimplemented
PT%%ER==000100,,0	;Resource
PT%%EN==000040,,0	;Normal

			;Bit indicating level of detail
PT%%LH==000010,,0	;High level
PT%%LF==000004,,0	;Filter
PT%%LM==000002,,0	;Medium
PT%%LL==000001,,0	;Low

			;Bit indicating "protocol"
PT%%TC==200000		;TCP
PT%%UQ==100000		;IP User Queues
PT%%GG==040000		;GGP
PT%%IC==020000		;ICMP
PT%%IP==010000		;IP
PT%%GW==004000		;Gateway
PT%%NT==002000		;Local Net

			;Agent & Direction
PT%%SY==001000		;System
PT%%UR==000400		;User
PT%%OU==000200		;Output
PT%%IN==000100		;Input

;Plus an ID code



DEFINE PT(NAM,VAL,LST)<	.X==VAL
			IRP LST,<.X==.X+PT%%'LST>
			PT%'NAM==.X>

					;Input, gateway level
PT(RGW,30,<SY,IN,GW,LL,VI>)		;Packet received at gateway from net
PT(KIP,11,<SY,IN,GW,LL,VI,EN>)		;Killed invalid format
PT(KCS,13,<SY,IN,GW,LL,VI,EN>)		;Killed checksum
PT(KDP,14,<SY,IN,GW,LL,VI,EN>)		;Killed duplication
PT(KIS,20,<SY,IN,GW,LL,VI,ER>)		;Killed no space to reassemble
PT(KIT,21,<SY,IN,GW,LL,VI,EN>)		;Killed reassembly timeout
PT(QIF,40,<SY,IN,GW,LL,VI>)		;Internet fragment queued (INTRAQ)
PT(DIF,44,<SY,IN,GW,LL,VI>)		;Dequeued and reassembled
PT(IRA,45,<SY,IN,GW,LL,VI>)		;Reassembled packet created

					;Input, IP level
PT(IDD,30,<SY,IN,IP,LL,VI>)		;Dequeued for dispatch
PT(IKC,13,<SY,IN,IP,LL,VI,EN>)		;Killed due to invalid checksum
PT(IKP,16,<SY,IN,IP,LL,VI,EU>)		;Killed due to invalid protocol
PT(IQP,57,<SY,IN,IP,LL,VI>)		;Queued for protocol module

					;Output, IP level
PT(IDO,57,<SY,OU,IP,LL,VI>)		;Dequeued packet for output
PT(IQG,30,<SY,OU,IP,LL,VI>)		;Queued packet for gateway

					;Output, Gateway level
PT(RGI,57,<SY,OU,GW,LL,VI>)		;Received at gateway from IP
PT(KDF,24,<SY,OU,GW,LL,VI,EN>)		;Killed fragmentation not allowed
PT(KIA,23,<SY,OU,GW,LL,VI,EN>)		;Killed addressing failure
PT(KPT,21,<SY,OU,GW,LL,VI,EN>)		;Killed packet (fragmentation) timeout
PT(KIO,22,<SY,OU,GW,LL,VI,EN>)		;Killed ill formated options
PT(KFS,20,<SY,OU,GW,LL,VI,ER>)		;Killed insufficient space to fragment
PT(BYP,34,<SY,OU,GW,LL,VI>)		;Queued for GW input
PT(IFR,33,<SY,OU,GW,LL,VI>)		;Internet fragment created
PT(QLN,30,<SY,OU,GW,LL,VI>)		;Queued for local net



       					;ICMP
PT(CDI,30,<SY,IN,IC,LM,VP>)		;ICMP received packet
PT(CKS,12,<SY,IN,IC,LL,VP,EN>)		;Killed due to truncated packet
PT(CKC,13,<SY,IN,IC,LL,VP,EN>)		;Killed due to bad checksum
PT(CKT,16,<SY,IN,IC,LL,VP,EN>)		;Killed due to bad ICMP Type
PT(CKX,17,<SY,IN,IC,LL,VP,EN>)		;Killed due to bad ICMP Code

					;GGP
PT(GDI,30,<SY,IN,GG,LM,VP>)		;Received packet
PT(GKS,12,<SY,IN,GG,LL,VP,EN>)		;Killed due to truncated packet
PT(GKC,13,<SY,IN,GG,LL,VP,EN>)		;Killed due to bad checksum
PT(GKT,16,<SY,IN,GG,LL,VP,EN>)		;Killed due to bad GGP Type
PT(GKX,17,<SY,IN,GG,LL,VP,EN>)		;Killed due to bad GGP Code

					;Input, Internet User Queues
PT(UDI,30,<SY,IN,UQ,LM>)		;Received packet
PT(UKQ,16,<SY,IN,UQ,LL,EN>)		;Killed due to no such queue
PT(UKS,20,<SY,IN,UQ,LL,ER>)		;No space in RECIN queue
PT(UKT,21,<SY,IN,UQ,LL,EN>)		;RCVIN queue timedout
PT(UQU,57,<SY,IN,UQ,LM>)		;Passed to user

					;User Interface, Internet User Queues
PT(UQA,02,<UR,IN,UQ,LM>)		;User queue assigned
PT(URJ,30,<UR,IN,UQ,LM>)		;User receive
PT(USJ,57,<UR,OU,UQ,LM>)		;User send
PT(UQD,02,<UR,OU,UQ,LM>)		;User queue deassigned

					;Output, Internet User Queues
PT(UDU,57,<SY,OU,UQ,LH,VI>)		;Received from user
PT(UKP,11,<SY,OU,UQ,LL,VI>)		;Killed
PT(UQO,30,<SY,OU,UQ,LL,VI>)		;Queued for output



					;Input, TCP level
PT(TDI,30,<SY,IN,TC,LH,VH,VP,VI>)	;Received packet
PT(TRS,01,<SY,IN,TC,LL,VH,VP,VI,EN>)	;Reset received
PT(TKR,10,<SY,IN,TC,LL,VH,VP,VI,EN>)	;Killed & sent RST
PT(TKC,13,<SY,IN,TC,LL,VH,VP,VI,EN>)	;Killed due to bad checksum
PT(TKD,14,<SY,IN,TC,LL,VH,VP,VI,EN>)	;Killed due to duplicate
PT(TKS,15,<SY,IN,TC,LL,VH,VP,VI,EN>)	;Killed due to sequence error
PT(TKX,16,<SY,IN,TC,LL,VH,VP,VI,EN>)	;Killed due to no local connection
PT(TKN,17,<SY,IN,TC,LL,VH,VP,VI,EN>)	;Killed due to closed connection
PT(TKT,20,<SY,IN,TC,LL,VH,VP,VI,EN>)	;TRMPKT killed packet - no space
PT(TTP,37,<SY,IN,TC,LL,VH,VP,VI>)	;TRMPKT trimming packet
PT(TQR,40,<SY,IN,TC,LL,VH,VP,VI>)	;Queued for reassembly
PT(TRA,42,<SY,IN,TC,LM,VH,VP,VI>)	;Being reassembled
PT(TDR,44,<SY,IN,TC,LL,VH,VP,VI>)	;Dequeued from reassembly
PT(TID,60,<SY,IN,TC,LL,VH,VP,VI>)	;Done with packet
PT(TIR,01,<SY,OU,TC,LL,VH,VP,VI,EN>)	;Reset sent in response to input pkt

					;User Interface, TCP level
PT(TST,01,<UR,IN,TC,LM,VH,VP,VI>)	;User status request
PT(TOJ,02,<UR,IN,TC,LM,VH,VP,VI>)	;User Open
PT(TIS,03,<UR,IN,TC,LM,VH,VP,VI>)	;Interrupt levels specified
PT(TSL,05,<UR,IN,TC,LM,VH,VP,VI>)	;User security level change
PT(TRD,30,<UR,IN,TC,LM,VH,VP,VI>)	;User receive data
PT(TIO,34,<UR,OU,TC,LM,VH,VP,VI>)	;Options to user
PT(TOO,35,<UR,IN,TC,LM,VH,VP,VI>)	;User options processed
PT(TSD,57,<UR,OU,TC,LM,VH,VP,VI>)	;User send data
PT(TBD,60,<UR,IN,TC,LM,VH,VP,VI>)	;User buffer processing completed
PT(TER,11,<UR,OU,TC,LM,VH,VP,VI>)	;Error
PT(TIU,06,<UR,IN,TC,LM,VH,VP,VI>)	;Interrupt to user
PT(TSC,04,<UR,OU,TC,LM,VH,VP,VI>)	;Secure close
PT(TCJ,02,<UR,OU,TC,LM,VH,VP,VI>)	;User Close
PT(TAJ,01,<UR,OU,TC,LM,VH,VP,VI>)	;User Abort
PT(TAB,01,<SY,OU,TC,LM,VH,VP,VI>)	;Abort (not user)

					;Output, TCP level
PT(TPZ,60,<SY,OU,TC,LM,VH,VP,VI>)	;TCP packet generated (Normal)
PT(TQX,40,<SY,OU,TC,LM,VH,VP,VI>)	;TCP PKT queued for RX
PT(TRX,42,<SY,OU,TC,LM,VH,VP,VI>)	;TCP PKT being RX'd
PT(TDX,44,<SY,OU,TC,LM,VH,VP,VI>)	;TCP PKT dequeued from RX
PT(TRX,30,<SY,OU,TC,LM,VH,VP,VI>)	;TCP packet transmitted
PT(TSC,04,<SY,OU,TC,LM,VH,VP,VI>)	;TCP secure close generated
PT(TOR,03,<SY,OU,TC,LM,VH,VP,VI>)	;TCP Reset generated by output



				;QUEUE structure:
DEFSTR(QNEXT,0,35,18)		;QUEUE.NEXT
DEFSTR(QPREV,0,17,18)		;QUEUE.PREVIOUS
	QSZ==1			;Number of words in a QUEUE structure

				;LOCK Structure:
DEFSTR(LWORD,0,35,36)		;LOCK.WORD
DEFSTR(LIDX,1,35,36)		;LOCK.WAITBIT INDEX
DEFSTR(LLOKR,2,35,36)		;LOCK.LOCKER
DEFSTR(LCCNT,3,35,36)		;LOCK.CONFLICT COUNT
DEFSTR(LOLKR,4,17,18)		;LOCK.CONFLICT.OLDLOCKER
DEFSTR(LNLKR,4,35,18)		;LOCK.CONFLICT.NEWLOCKER
	LOCKSZ==5		;Number of words in a LOCK structure

				;Histogram structure
DEFSTR(HTOTL,0,35,36)		;HISTOGRAM.TOTAL
DEFSTR(HSMPL,1,35,36)		;HISTOGRAM.SAMPLES

DEFINE IHBIN(X,I)<
	MOVEI CX,2(X)
	ADDI CX,0(I)
	AOS 0(CX)>

NHBINS==^D14		;Number of real bins, not incl garbage bin
HISTSZ==2+NHBINS+1	;Number of words in a histogram (for STG)



;ICMP packet structure and error codes

				;Message types (error type)
ICM%ER==^D0			;Echo reply message
ICM%DU==^D3			;Destination unreachable
ICM%SQ==^D4			;Source quench
ICM%RD==^D5			;Redirect output
ICM%EC==^D8			;Echo message
ICM%TE==^D11			;Time exceeded
ICM%PP==^D12			;Parameter problem
ICM%TM==^D13			;Timestamp
ICM%TR==^D14			;Timestamp reply
ICM%IQ==^D15			;Information request
ICM%IR==^D16			;Information reply

;Error codes (error subtypes)

				;Codes for Destination unreachable
DU%NET==0			;Net unreachable
DU%HST==1			;Host unreachable
DU%PRO==2			;Protocal unreachable
DU%PRT==3			;Port unreachable
DU%FRG==4			;Fragmentaion needed
DU%SRF==5			;Source route failed

				;Codes for Redirect
RD%NET==0			;Redirect output for net.
RD%HST==1			;Redirect for host
RD%TSN==2			;Redirect type of service and net
RD%TSH==3			;Redirect type of service and host

				;Codes for Time Exceeded
TE%TTL==0			;Time to live exceeded
TE%RTE==1			;Reassembly time exceeded

				;Codes for Parameter Problem
PP%PTR==0			;Pointer to byte causing problem



;ICMP Packet format, offset from 0 (preceded by an internet header).

DEFSTR(CMTYP,0,7,8)		;Type of message
DEFSTR(CMCOD,0,15,8)		;Code for messages
DEFSTR(CMCKS,0,31,16)		;Checksum

;The following structures are each only used by some message types.

DEFSTR(CMID,1,15,16)		;ID number in ICM%EC,R ICM%TM,R ICM%IQ,R
DEFSTR(CMSEQ,1,31,16)		;Sequence number in same

DEFSTR(CMPTR,1,7,8)		;Pointer for ICM%PP messages
DEFSTR(CMGWA,1,31,32)		;Gateway address for ICM%RD messages

.CMINH==2			;Internet header in ICM%SQ,ICM%RD,ICM%DU etc.
				;Timestamp fields
DEFSTR(CMTSO,2,31,32)		;Originate timestamp
DEFSTR(CMTSR,3,31,32)		;Receive timestamp
DEFSTR(CMTST,4,31,32)		;Transmit timestamp



				;Structure of a Gateway block
DEFSTR(GWUP,0,0,1)		;Gateway should be useable
DEFSTR(GWPIP,0,1,1)		;Ping in progress
DEFSTR(GWTYP,0,5,4)		;Gateway type
  GW%PRM==1			;Prime: Speaks ICMP
  GW%DUM==2			;Dumb: Fwd's pkts, but that's all
  GW%HST==3			;Host: Avoid except in emergency
  GW%AUP==4			;Always-up: Fwds but doesn't reflect
DEFSTR(GWHIS,0,14,7)		;Ping history bits
DEFSTR(GWSPC,0,17,3)		;Successful ping count
  .THRUP==<6*WID(GWHIS)>/8	;Threshold to say it is up
  .THRDN==<3*WID(GWHIS)>/8	;Threshold to say it is down
  IFL <<1_WID(GWSPC)>-1>-WID(GWHIS), PRINTX ?GWSPC too small
DEFSTR(GWICT,0,35,18)		;Interface count
.GWILS==1			;Where in block to find the list
	;NB: The FIRST ENTRY in the list is on a connected net
MXGWIC==6			;Maximum number of interfaces

GWBKSZ==.GWILS+MXGWIC		;Size of a gateway block

	SUBTTL	TCP Parameters (from TCPPAR)

;TCP Parameters:

MAXSEQ==1_^D32			;32 bit sequence numbers
SEQMSK==MAXSEQ-1		;Mask for doing mod MAXSEQ by AND op.
DEFINE MODSEQ(A)<TLZ A,(-MAXSEQ)>
CYCTIM==^D<2*60*60>		;Network cycle time in seconds
SNSTEP==MAXSEQ/CYCTIM		;A second's worth of sequence numbers



;TCP Header (indexed by TPKT):

.P==0
DEFSTR(PSP,\<.P>,15,16)		;PACKET.SOURCE.PORT
DEFSTR(PDP,\<.P>,31,16)		;PACKET.DESTINATION.PORT

.P==.P+1
DEFSTR(PSEQ,\<.P>,31,32)	;PACKET.SEQUENCE

.P==.P+1
DEFSTR(PACKS,\<.P>,31,32)	;PACKET.ACK.SEQUENCE

.P==.P+1
DEFSTR(PCTL,\<.P>,35,36)	;Word containing control flags
  DEFSTR(PTDO,\<.P>,3,4)	;PACKET.TCP.DATAOFFSET ( 32-BIT UNITS)
				;4 Unused bits
  DEFSTR(PTCTL,\<.P>,15,8)	;PACKET.TCP.CONTROLS
    				;2 Unsed bits
    DEFSTR(PURG,\<.P>,10,1)	;PACKET.CONTROL.URGENT
    DEFSTR(PACK,\<.P>,11,1)	;PACKET.CONTROL.ACK
    DEFSTR(PEOL,\<.P>,12,1)	;PACKET.CONTROL.EOL
    DEFSTR(PRST,\<.P>,13,1)	;PACKET.CONTROL.RST
    DEFSTR(PSYN,\<.P>,14,1)	;PACKET.CONTROL.SYN
    DEFSTR(PFIN,\<.P>,15,1)	;PACKET.CONTROL.FIN
  DEFSTR(PWNDO,\<.P>,31,16)	;PACKET.WINDOW

.P==.P+1
DEFSTR(PTCKS,\<.P>,15,16)	;PACKET.CHECKSUM
DEFSTR(PURGP,\<.P>,31,16)	;PACKET.URGENT.POINTER

.P==.P+1
MINTHS==4*.P			;Minimum TCP header size (bytes)

				;TCP Options (if any) are here:
MAXTOS==<.RTJST(-1,PTDO)*4-MINTHS> ;Maximum # Option bytes possible

;Derive some useful numbers from the above:

TCPNPW==PKTELI+.RTJST(-1,PIDO)+.RTJST(-1,PTDO)+<<<1_^D<WID(PIPL)-WID(PIFO)>>+3>/4>



;Options: Two cases.

;Case 1: A single byte of option code
;ENDOPT is and must be 0.  This marks the end of the option list.
;NOPOPT is and must be 1.  This is one byte long and has no purpose.

;Case 2: General form of options is 1 byte of "kind", 1 byte of total
;length, and N-2 bytes of data, where N is read from the length byte.
;All options are included under the appropriate checksum.
;END	End of options		ENDOPT
;NOP	Filler			NOPOPT
;MSL	Maximul Segment Length	MSLOPT,4,len,gth
;LBL	Packet Label		LBLOPT,4,seg,id
;RBS	Receive Buffer Size	RBSOPT,4,bfr,lth
;LTS	Local Timestamp		LTSOPT,6,t,i,m,e

;General TCP Option generation macro

DEFINE TCPOPTS (USER,RECV,ECHO)<
  OPTION(I,END,,^D0,^D1,USER,RECV,ECHO)
  OPTION(I,NOP,,^D1,^D1,USER,RECV,ECHO)
  OPTION(T,MSL,,^D2,^D4,USER,RECV,ECHO)
  OPTION(T,LBL,,^D33,^D4,USER,RECV,ECHO)
> ;End of DEFINE TCPOPTS

;Define Option Names

DEFINE OPTION(TYPE,NAME,COPY,NUMBER,LENGTH,USER,RECV,ECHO)<
IFDIF <COPY>,<C>,<	NAME'OPT==NUMBER	>
IFIDN <COPY>,<C>,<	NAME'OPT==CPYOPT+NUMBER	>
>

TCPOPTS


;TCB (internal connection block) structure:

TCBQ==<.T==0>				;TCB.Queue (TCBH, DeadQ, etc)

TCBLCK==<.T==.T+QSZ>			;TCB.LOCK

.T==.T+LOCKSZ
DEFSTR(TOWNR,\<.T>,17,18)		;TCB.OWNER (job #)
DEFSTR(TJCN,\<.T>,35,18)		;TCB.JCN (n of JCNTCB+n)

.T=.T+1
DEFSTR(TFH,\<.T>,35,36)			;TCB.FH
DEFSTR(TFHC,\<.T>,6,3)			;TCB.FH.NET-CLASS
					;TCB.FH.NET (0 => TWLDN=1)
.T=.T+1					;TCB.FH.TCP (0 => TWLDT=1)
DEFSTR(TLH,\<.T>,35,36)			;TCB.LH

.T=.T+1
DEFSTR(TFP,\<.T>,35,36)			;TCB.FP (0 => TWLDP=1)

.T=.T+1
DEFSTR(TLP,\<.T>,35,36)			;TCB.LP only 16 bits

.T=.T+1					;TCB Flags
DEFSTR(TERR,\<.T>,7,8)			;TCB.ERROR
DEFSTR(TWLDN,\<.T>,8,1)			;OPEN with Net wild
DEFSTR(TWLDT,\<.T>,9,1)			;OPEN with TCP wild
DEFSTR(TWLDP,\<.T>,10,1)		;OPEN with Port wild
DEFSTR(TSFP,\<.T>,11,1)			;TCB.SEND.FORCE-PACKET
DEFSTR(TSEP,\<.T>,12,1)			;TCB.SEND.ENCOURAGE-PACKET
DEFSTR(TRPP,\<.T>,14,1)			;TCB.RECV.PARITAL-PACKET
DEFSTR(TSCR,\<.T>,15,1)			;TCB.SECURE-CONNECTION
DEFSTR(TTVT,\<.T>,16,1)			;TCB.TCP-Virtual-terminal
DEFSTR(TSAP,\<.T>,17,1)
DEFSTR(TERRT,\<.T>,18,1)		;TCB.ERROR.TRACE
DEFSTR(TDEC,\<.T>,19,1)			;DEC JSYS TCB
DEFSTR(TRXD,\<.T>,20,1)			;[9140] Retransmission in progress
					;[9140] One free bit here

DEFSTR(TSTAT,\<.T>,35,14)		;TCB.STATE
  DEFSTR(TRSYN,\<.T>,24,3)		;TCB.STATE.RECV-SYNC
  DEFSTR(TSSYN,\<.T>,27,3)		;TCB.STATE.SEND-SYNC
					;State codes for connections
	SYNABL==4			;SYNCHABLE: Activated by user call
	SYNSNT==<SYNRCV==5>		;SYN sent or received
	SYNCED==7			;SYN acked
	FINSNT==<FINRCV==2>		;FIN sent or received but not ACKd
	NOTSYN==0			;Connection fully closed or not open

  DEFSTR(TSTVO,\<.T>,28,1)		;[9115] TVT output needed
  DEFSTR(TSUOP,\<.T>,29,1)		;TCB.STATE.USER-OPEN
  DEFSTR(TSOPN,\<.T>,30,1)		;TCB.STATE.SAID-OPEN
  DEFSTR(TSPRS,\<.T>,31,1)		;TCB.STATE.PERSISTENT
  DEFSTR(TSABT,\<.T>,32,1)		;TCB.STATE.ABORT
  DEFSTR(TSSV,\<.T>,33,1)		;TCB.STATE.SEQUENCE-VALID
  DEFSTR(TSURG,\<.T>,34,1)		;TCB.SEND.URGENT-MODE
  DEFSTR(TRURG,\<.T>,35,1)		;TCB.RECV.URGENT-MODE

;Send variables

.T=.T+1
DEFSTR(TSIS,\<.T>,35,36)		;[9140] TCB.SEND.INITIAL-SEQUENCE

.T=.T+1
DEFSTR(TSLFT,\<.T>,35,36)		;TCB.SEND.LEFT

.T=.T+1
DEFSTR(TSSEQ,\<.T>,35,36)		;TCB.SEND.SEQUENCE

.T=.T+1
DEFSTR(TSURP,\<.T>,35,36)		;TCB.SEND.URGENT-POINTER

.T=.T+1
DEFSTR(TSWND,\<.T>,17,18)		;TCB.SEND.WINDOW
DEFSTR(TSCB,\<.T>,35,18)		;TCB.SEND.CURRENT-BUFFER

.T=.T+1
DEFSTR(TSTO,\<.T>,35,36)		;TCB.SEND.TIME-OUT

TCBSBQ==<.T=.T+1>			;TCB.SEND.BUFFER-QUEUE
TCBRXQ==<.T=.T+QSZ>			;TCB.SEND.REXMIT-QUEUE

;Recv variables

.T==.T+QSZ
DEFSTR(TRIS,\<.T>,35,36)		;TCB.RECV.INITIAL-SEQUENCE

.T=.T+1
DEFSTR(TRLFT,\<.T>,35,36)		;TCB.RECV.LEFT

.T=.T+1
DEFSTR(TRURP,\<.T>,35,36)		;TCB.RECV.URGENT-POINTER

.T=.T+1
DEFSTR(TRWND,\<.T>,17,18)		;TCB.RECV.WINDOW
DEFSTR(TRCB,\<.T>,35,18)		;TCB.RECV.CURRENT-BUFFER

.T=.T+1
DEFSTR(TRCBY,\<.T>,35,36)		;TCB.RECV.CURRENT-BYTE

.T=.T+1
DEFSTR(TRBS,\<.T>,35,36)		;TCB.RECV.BUFFER-SPACE

TCBRBQ==<.T=.T+1>			;TCB.RECV.BUFFER-QUEUE
TCBRPQ==<.T=.T+QSZ>			;TCB.RECV.PACKET-QUEUE


;PSI variables

TCBPIC==<.T=.T+QSZ>			;TCB.PSI-CHANNELS
DEFSTR(TPSIC,TCBPIC,35,36)		;All PSI channels
					;Overlays for above
  DEFSTR(TPICU,TCBPIC,5,6)		;URGENT DATA ARRIVED
  DEFSTR(TPICR,TCBPIC,11,6)		;RECV DONE
  DEFSTR(TPICS,TCBPIC,17,6)		;SEND DONE
  DEFSTR(TPICE,TCBPIC,23,6)		;ERROR
  DEFSTR(TPICX,TCBPIC,29,6)		;STATE CHANGE
  DEFSTR(TPICA,TCBPIC,35,6)		;EOL ACK

					;Following must have same order as above
TCBPIF==.T+1				;TCB.PSI-FORKS
DEFSTR(TPIFU,TCBPIF+0,17,18)		;URGENT DATA ARRIVED
DEFSTR(TPIFR,TCBPIF+0,35,18)		;RECV DONE
DEFSTR(TPIFS,TCBPIF+1,17,18)		;SEND DONE
DEFSTR(TPIFE,TCBPIF+1,35,18)		;ERROR
DEFSTR(TPIFX,TCBPIF+2,17,18)		;STATE CHANGE
DEFSTR(TPIFA,TCBPIF+2,35,18)		;EOL ACK

.T==TCBPIF+3
DEFSTR(TOPNF,\<.T>,8,9)			;TCB.OPEN.WAIT FLAG INDEX
DEFSTR(TERRF,\<.T>,17,9)		;TCB.ERROR.FLAG index
DEFSTR(TOFRK,\<.T>,35,18)		;TCB.OWNING-FORK

;Retransmission variables

;[9140] Some of these fields are smaller than 36 bits but are left as whole
;words for fast arithmetic in TCPTCP.

.T=.T+1
DEFSTR(TMNRT,\<.T>,35,36)		;[9140] TCB.MIN-ROUND-TRIP

.T=.T+1
DEFSTR(TMXRT,\<.T>,35,36)		;TCB.MAX-ROUND-TRIP

.T=.T+1
DEFSTR(TRXI,\<.T>,35,26)		;[9115] TCB.RETRANSMIT-INTERVAL
DEFSTR(TRCNT,\<.T>,9,10)		;[9115] retranmission count

.T=.T+1					;[9140]
DEFSTR(TMEAS,\<.T>,35,36)		;[9140] TCB.measured-round-trip

.T=.T+1					;[9140]
DEFSTR(TCURW,\<.T>,35,36)		;[9140] TCB.current-window

.T=.T+1					;[9140]
DEFSTR(TCWND,\<.T>,35,36)		;[9140] TCB.congestion-window

.T=.T+1					;[9140]
DEFSTR(TSSTH,\<.T>,35,36)		;[9140] TCB.slow-start-threshold

.T=.T+1					;[9140]
DEFSTR(TSAVG,\<.T>,35,36)		;[9140] TCB.scaled-average-round-trip

.T=.T+1					;[9140]
DEFSTR(TSDEV,\<.T>,35,36)		;[9140] TCB.scaled-mean-deviation

; Queues and wakeup times for various processes:

TCBQRA==<.T=.T+1>			;Reassembler queue
TCBTRA==<.T=.T+QSZ>			;When RA needed

TCBQPZ==<.T=.T+1>			;Packetizer
TCBTPZ==<.T=.T+QSZ>

TCBQRX==<.T=.T+1>			;Retransmitter
TCBTRX==<.T=.T+QSZ>

TCBQDG==<.T=.T+1>			;Delay Actions
TCBTDG==<.T=.T+QSZ>


.T==.T+1
DEFSTR(TIFDF,\<.T>,0,1)			;IP Don't-Fragment flag
DEFSTR(TTTL,\<.T>,8,8)			;IP Time-to-live
					;1 Unused bit
DEFSTR(TTOS,\<.T>,17,8)			;IP Type-of-service
DEFSTR(TABTFX,\<.T>,35,18)		;Forkx of ABORTER

.T=.T+1
DEFSTR(TSLVN,\<.T>,17,18)		;Next Security level
DEFSTR(TSLVC,\<.T>,35,18)		;Current Security Level

.T=.T+1
					;2 bits really unused
DEFSTR(TOPFP,\<.T>,17,18)		;Foreign port at open
DEFSTR(TNUFM,\<.T>,18,1)		;OPENed with new formats
					;8 unused bits
DEFSTR(TVTL,\<.T>,35,9)			;Virtual terminal line number

.T=.T+1
DEFSTR(TOPFH,\<.T>,35,36)		;TCB.OPEN-FH

.T=.T+1
DEFSTR(TOPLH,\<.T>,35,36)		;TCB.OPEN-LH

.T=.T+1
DEFSTR(TSBYT,\<.T>,35,36)		;Bytes left to send

.T=.T+1
DEFSTR(TRLAK,\<.T>,35,36)		;Seq # of last PACKS sent

.T=.T+1
DEFSTR(TRLWN,\<.T>,35,36)		;Seq # of last PWNDO sent or -1

.T=.T+1
DEFSTR(TRMXP,\<.T>,17,18)		;[9140] Offered max packet length
DEFSTR(TSMXP,\<.T>,35,18)		;[9140] Max send packet (inc header)



;Option Variables

.T=.T+1
DEFSTR(TIPDO,\<.T>,5,4)			;IP Data offset, words
DEFSTR(TIPOR,\<.T>,11,6)		;IP Received options, bytes
DEFSTR(TIPOU,\<.T>,17,6)		;IP User options, bytes
DEFSTR(TIOPF,\<.T>,35,18)		;IP User option flags

.T=.T+1
DEFSTR(TTPDO,\<.T>,5,4)			;TCP Data offset, words
DEFSTR(TTPOR,\<.T>,11,6)		;TCP Received options, bytes
DEFSTR(TTPOU,\<.T>,17,6)		;TCP User options, bytes
DEFSTR(TTOPF,\<.T>,35,18)		;TCP User option flags

TCBIO==<.T=.T+1>			;IP Option list (send)
TCBIR==<.T=.T+<MAXIOS+3>/4>		;Last IP Options received
TCBIU==<.T=.T+<MAXIOS+3>/4>		;IP Options from User

TCBTO==<.T=.T+<MAXIOS+3>/4>		;TCP Option list (send)
TCBTR==<.T=.T+<MAXTOS+3>/4>		;Last TCP Options received
TCBTU==<.T=.T+<MAXTOS+3>/4>		;TCP Options from User

.T=.T+<MAXTOS+3>/4
DEFSTR(TERBF,\<.T>,17,18)		;Error/Trace (user) buffer adr
DEFSTR(TERJN,\<.T>,35,18)		;Error/trace (user) JFN

.T=.T+1
DEFSTR(TCTBS,\<.T>,17,18)		;Count of no-buffer errors
DEFSTR(TCTSQ,\<.T>,35,18)		;Count of sequence # pauses

.T=.T+1
DEFSTR(TSCPK,\<.T>,35,36)		;Send current packet

.T=.T+1
DEFSTR(TPRS1,\<.T>,17,18)		;Persistance parameter one
DEFSTR(TPRS2,\<.T>,35,18)		;Persistance parameter two

.T=.T+1					;DEC JFN Interface Flags
DEFSTR(TCDWT,\<.T>,0,1)			;DEC Wait mode flag
DEFSTR(TCDHT,\<.T>,1,1)			;DEC High Throughput Mode flag
DEFSTR(TCDFS,\<.T>,2,1)			;DEC Active Flag
DEFSTR(TCDOW,\<.T>,3,1)			;DEC OPENF block flag
DEFSTR(TCDGN,\<.T>,4,1)			;DEC GTJFN Name done once flag
DEFSTR(TCDGE,\<.T>,5,1)			;DEC GTJFN Extension done once flag
DEFSTR(TCDPS,\<.T>,6,1)			;DEC Persist flag
DEFSTR(TCDOB,\<.T>,7,1)			;DEC Output buffer setup
DEFSTR(TCDIB,\<.T>,8,1)			;DEC Input buffer setup
DEFSTR(TCDCW,\<.T>,9,1)			;DEC CLOSF Block flag
DEFSTR(TCDB8,\<.T>,10,1)		;DEC OPENF 8 bit byte mode
DEFSTR(TCDOQ,\<.T>,11,1)		;DEC Output buffer Queued
DEFSTR(TCDPU,\<.T>,12,1)		;DEC Do a PUSH flag
DEFSTR(TCDUR,\<.T>,13,1)		;DEC Do an URGENT flag

DEFSTR(TJFN,\<.T>,35,18)		;DEC TCB.JFN (JFN*MLJFN)

.T=.T+1
TJOBF=.T				;DEC TCB output buffer	for filling

.T=.T+1
TJOBA=.T       				;DEC TCB output buffer active

.T=.T+1
TJIBE=.T				;DEC TCB output buffer for emptying

.T=.T+1
TJIBA=.T				;DEC TCB output buffer active

.T=.T+1
TCPBCO=.T      				;DEC TCB real FILBCO

.T=.T+1
TCPBCI=.T				;DEC TCB real FILBCI

.T=.T+1					;Spare
TCBSIZ==.T+1				;Size of a TCB
	PURGE .T

;The following definition must match that in TTTVDV.MAC

TTNETW==4 			;(i.e. TTDEV)
DEFSTR(PTVT,TTNETW,35,18)	;Holds pointer to TVT's TCB


;Flag bit definitions:

TCP%ER==1B0			;ERROR
TCP%LE==1B1			;Local error flag (0 is remote)
TCP%PE==1B2			;Permanent error (0 is temporary)
TCP%EC==37B7			;Error code w/o flags
TCP%DN==1B12			;DONE
TCP%UR==1B15			;URGENT DATA
TCP%EL==1B16	;obsolete	;PUSH
TCP%PU==1B16			;PUSH
TCP%WM==1B17			;WORD MODE
.TCPBF==0			;Buffer Flags
.TCPBA==1			;Buffer data address
.TCPBC==2			;Buffer data count
.TCPBO==3			;Buffer option addresses
 .TCPOW==^D10			;Buffer option address word count
.TCPBI==4			;Buffer IP info
.TCPBS==5			;Buffer header size


;CHKARG stack parameter block definitions
;		Caller				Callee
;	STACKL <<ARGBLK,CHKADW>,...>
;	CHKADL <<locals>>			CHKADL <<locals>>
;	...code...				...code...
;	CHKADR					CHKADR

DEFINE CHKADL (LOCL)<
IFB  <LOCL>,<	LOCAL <PARAMS>		>
IFNB <LOCL>,<	LOCAL <PARAMS,LOCL>	>
	LALL
DEFINE LH<0(PARAMS)>
DEFINE LP<1(PARAMS)>
DEFINE FH<2(PARAMS)>
DEFINE FP<3(PARAMS)>
DEFINE JCN<4(PARAMS)>
DEFINE WILDOK<5(PARAMS)>
DEFINE FN<6(PARAMS)>
DEFINE ARG1<7(PARAMS)>
DEFINE ARG2<10(PARAMS)>
	SALL
> ;End of DEFINE CHKADL

CHKADW==11

DEFINE CHKADR <
	PURGE LH,LP,FH,FP,JCN,WILDOK,FN,ARG1,ARG2
	RESTORE
> ;End of CHKADR



;BUFFER Structure:

BFRQ==<.B==0>			;BUFFER QUEUE, LH contains flags

BFRSUI==<.B==.B+QSZ>		;BUFFER START USER INFORMATION
BFRFLG==BFRSUI+.TCPBF		;BUFFER FLAG WORD
DEFSTR(BURG,BFRFLG,^L<TCP%UR>,1);BUFFER URGENT
DEFSTR(BEOL,BFRFLG,^L<TCP%PU>,1);BUFFER END-OF-LETTER
DEFSTR(BWM,BFRFLG,^L<TCP%WM>,1)	;BUFFER WORD-MODE

BFRDAD==BFRSUI+.TCPBA
DEFSTR(BDADR,BFRDAD,35,36)	;BUFFER DATA ADDRESS

BFRCNT==BFRSUI+.TCPBC
DEFSTR(BCNT,BFRCNT,35,36)	;BUFFER.COUNT

BFROPT==BFRSUI+.TCPBO

BFREUI==<.B==BFRSUI+.TCPBS>	;BUFFER END USER INFO

DEFSTR(BHADR,\<.B>,35,36)	;BUFFER HEADER ADDRESS

.B==.B+1
DEFSTR(BICNT,\<.B>,35,36)	;BUFFER INITIAL COUNT

.B==.B+1
DEFSTR(BFRKX,\<.B>,17,18)	;BUFFER.FORKX
DEFSTR(BUPAG,\<.B>,35,18)	;BUFFER.USER PAGE

.B==.B+1
DEFSTR(BBLIP,\<.B>,17,18)	;BUFFER.BYTESLEFTINPAGE
DEFSTR(BMPAG,\<.B>,35,18)	;BUFFER.MONITORPAGE

BFRPTR==<.B==.B+1>
DEFSTR(BPTR,BFRPTR,35,36)	;BUFFER POINTER
				;Overlays for above:
  DEFSTR(BPTRP,BFRPTR,5,6)	;Size field
  DEFSTR(BPTRS,BFRPTR,11,6)	;Position field
  DEFSTR(BPTRA,BFRPTR,35,18)	;Address field

.B==.B+1
DEFSTR(BTCB,\<.B>,17,18)	;BUFFER.TCB
DEFSTR(BIDX,\<.B>,35,18)	;BUFFER.INDEX

.B==.B+1
DEFSTR(BTS,\<.B>,35,36)		;BUFFER.TIMESTAMP

	BFRSIZ==.B+1



;Event codes:

E.BIT==200			;ERROR bit
L.BIT==100			;LOCAL condition bit
P.BIT==040			;PERMANENT condition bit

OK==0*E.BIT+0*L.BIT+0*P.BIT	;General success code
XFT==0*L.BIT+0*P.BIT		;Temporary Foreign condition
XFP==0*L.BIT+1*P.BIT		;Permanent Foreign condition
XLP==1*L.BIT+1*P.BIT		;Permanent Local condition
EFT==1*E.BIT+0*L.BIT+0*P.BIT	;Temporary Foreign Error
EFP==1*E.BIT+0*L.BIT+1*P.BIT	;Permanent Foreign Error
ELT==1*E.BIT+1*L.BIT+0*P.BIT	;Temporary Local Error
ELP==1*E.BIT+1*L.BIT+1*P.BIT	;Permanent Local Error

;Other codes:

IGN==100		        ;Packet is to be ignored
DUP==10			        ;Packet is a duplicate (in TCPIP)
ERR==1			        ;Packet is in error (in TCPIP)



;Process block

PRCQ==0			;(Ext) ptr to input queue head (TCBs, etc)
PRCLCK==1		;Lock
.F==PRCLCK+LOCKSZ
PRCROU==.F		;(Ext) address of routine
PRCWAK==.F+1		;-1 or TODCLK of wakeup
PRCQOF==.F+2		;TCB,,m	Pointer to queue in TCB
PRCWOF==.F+3		;TCB,,n	Pointer to wakeup in TCB
PRCSGT==.F+4		;TODCLK of most recent signal
PRCRNC==.F+5		;Pointer to run counter	xxRNCT
PRCTMR==.F+6		;Pointer to timer xxUSE
	PROCSZ==.F+7	;Size of a process block

;Macro  which  expands  into  code  to  cause  a process to run after a
;specified delay. The interesting case is 0 delay in which the  routine
;may  be called directly, without the overhead of locking and unlocking
;the process Q twice, and locking the TCB again etc.

DEFINE $SIGNL(TPROC,DELTA,%TAGQ,%TAGX)<
	XMOVEI T1,TPROC		;Process to signal
  IFE DELTA,<
	MOVE T3,TODCLK		;Now
	SKIPL T2,PRCWAK(T1)	;If no wakeup set, NOW is ok
	 CAMLE T2,T3		;If past due, queue
	  SKIPLE NSKED		;NOW is ok unless NOSKED
	   JRST %TAGQ		;No.  Get in Q for FIFO behavior
	PUSH P,PROC		;Do it NOW
	MOVEM T3,PRCSGT(T1)	;TODCLK of most recent SIGNAL
	CALL TCPTSK		;Call the task
	POP P,PROC		;Restore our ID as running process
	JRST %TAGX		;All done
%TAGQ:	>	;IFE DELTA

;Avoid stack overflow on KA, always queue
	MOVX T2,DELTA		;Number of milliseconds
	CALL SIGNAL
  IFE DELTA,<
%TAGX:  >

> ;end DEFINE $SIGNL
	SUBTTL Defintions for UDP

.UDPFM==^D17			;[9156] UDP protocol number

;[9156] UDP header

.UDSDP==.IPKDH+1		;[9156] Word with source and dest port
.UDLNC==.IPKDH+2		;[9156] Word with header length and checksum
UDHSIZ==2			;[9156] Number of words in UDP header

DEFSTR(UDPSP,PKTELI+.UDSDP,15,16) ;[9156] Source port
DEFSTR(UDPDP,PKTELI+.UDSDP,31,16) ;[9156] Destination port
DEFSTR(UDPLN,PKTELI+.UDLNC,15,16) ;[9156] Length
DEFSTR(UDPCK,PKTELI+.UDLNC,31,16) ;[9156] Checksum

.UDPDA==.UDLNC+1		;[9156] Start of UDP data area

	SUBTTL Definitions for Multinet

;MACROs

;DEFWRD - Define a full word structure, and increment place in table
;arguments are A - Name for offset
;SIZ - number of words to reserve ( default to 1)

DEFINE DEFWRD(A,SIZ)
<	IF1 <IFDEF A,<PRINTX ? Multiply defined offset in DEFWRD>>

;Make symbol printable or not depending on if overlaps AC's

	A==:..OFST			;Set value as offset into table
	IFB <SIZ>,<..OFST==..OFST+1>	;Increment offset
	IFNB <SIZ>,<..OFST==..OFST+SIZ> ;Incrment by buffer size
>					;End of DEFWRD

;The following macros are used to access routines offset in the NCT

DEFINE	MNTCALL(FOO)<CALL @FOO(P1)>	;Call a routine
DEFINE	MNTJRST(FOO)<JRST @FOO(P1)>	;Jump to a routine
DEFINE	MNTXCT(FOO)<XCT FOO(P1)>	;Execute an instruction



DEFINE NCTDSP(A),<XCDSEC,,<A&777777>>

;The  following  MACROs  are used to actually create the NCT or Network
;Control Table. The macro TKNCTS should be called at  the  location  of
;the  NCT  storage  table.  The  Macro  MKPTRS  should be called at the
;location of the NCT vector table

;MKNCTS - The basic MACRO
;**NOTE** That the following must be called in the RESCD PSECT

DEFINE	MKNCTS
<	XALL			;Show the lines temporarily
NT.NUM==0			;Start with Interface 0
NCTNUM==0			;Start out at zero
DV.NUM==0			;Back to number 0
IFN ANXN,<			;[9115] Is this balanced now
NT.TYP==NT.NCP			;Network Type is NCP
NT.DEV==NT.ANX			;Device type AN20
REPEAT ANXN,<			;[9115] For all AN20s
	MAKNCT(\DV.NUM,\NCTNUM,^D576) ;[9115] Make that type NCT for AN20
	DV.NUM==DV.NUM+1	;[9115] Step to next device if any
>				;[9115] End of REPEAT ANXN
>				;[9115] End of IFN ANXN
IFN IPNIN,<			;[9115] If NIA20 support
NT.TYP==NT.NUN			;No local protocol 
NT.DEV==NT.NIP			;Device type IPNI
MAKNCT(\DV.NUM,\NCTNUM,^D576)	;Make that type NCT
DV.NUM==DV.NUM+1		;[9115] Count up the NCT number used
>				;[9115] End of IFN IPNIN

IFN IPNIAN,<			;[9135] If NIA20 alternat address support
NT.TYP==NT.NUN			;[9135] No local protocol 
NT.DEV==NT.NIA			;[9135] Device type IPNI alternate address
REPEAT IPNIAN,<			;[9135] For each of these devices
	MAKNCT(\DV.NUM,\NCTNUM,^D576) ;[9135] Make that type NCT
	DV.NUM==DV.NUM+1	;[9135] Count up the NCT number used
	>			;[9135] End of REPEAT IPNIAN
>				;[9135] End of IFN IPNIAN

IFN IPCIN,<			;[9115] If CI20 support
NT.TYP==NT.NUN			;No local protocol 
NT.DEV==NT.CIP			;Device type IPCI
MAKNCT(\DV.NUM,\NCTNUM,^D576)	;[9115] Make that type NCT
DV.NUM==DV.NUM+1		;[9115] Count up that NCT number
>				;[9115] End of IFN IPCIN
	SALL			; Again suppress expansions
>				; End of MKNCTS


;MAKNCT - Make a specific NCT
;*** WARNING *** This !MUST! agree with the table offsets defined below

DEFINE MAKNCT(NUM,NCTN,ISIZ)<

;The following section is the same among all NCT's
.NCT'NCTN=:.			;Set address of this NCT
	EXP	0		;Link word to next NCT in list
				;(filled in by MNTINI)
NCTNUM==NCTNUM+1		;Increment number of NCTS defined

	XWD	NT.TYP,NT.DEV	;Protocal and device codes
	EXP	NT.NUM		;Net index
NT.NUM==NT.NUM+1		;increment net index
	EXP	-1		;Internet network number (not yet set)
	EXP	-1		;Internet Address of this interface
	EXP	0		;Logical host mask for this network
IFB  <ISIZ>,<XWD 377777,-1>	;Maximum packet size
IFNB <ISIZ>,<EXP ISIZ>		;Maximum packet size



;NCP/AN20  MAKSAV  MACRO  Creates  an  interrupt  AC  save and dispatch
;routine in the current NCT at the current location. Uses The following
;locations (which therefore must be defined for  that  net  type).  The
;argument  PDP  is the address of a Push down pointer for this routine.
;DISP is the offset of the dispatch address.

DEFINE MAKSAV(PDP,DISP)
<	MOVEM P,.NCT'NCTN+NTSVAC+17	;Save P
	MOVEI P,.NCT'NCTN+NTSVAC	;Where the AC's go
	BLT P,.NCT'NCTN+NTSVAC+16	;Save all
	MOVE P,PDP			;Set new P
	XMOVEI P1,.NCT'NCTN		;Point to NCT
	CALL	@DISP(P1)		;And Goto routine
>					;End of MAKSAV


;MAKRES  -  Make  a 3 word AC restore , dismiss interrupt routine. AC's
;are assumed stored at NTSVAC. Arg PCW is the address of the  interrupt
;PC.

DEFINE	MAKRES(PCW)
<	MOVSI P,.NCT'NCTN+NTSVAC	;From there to 0
	BLT P,P				;Restore all AC's
	XJEN .NCT'NCTN+PCW		;And dismiss the interrupt
>					;End of MAKRES MACRO

IFE <<NT.TYP-NT.NCP>!<NT.DEV-NT.ANX>>,<

	ANI==ANX'NUM		;[9115] Input device address
	ANO==ANX'NUM+4		;[9115] Output side address

	CONSZ ANI,(T1)		;NTCNSZ - CONSZ INPUT
	CONSO ANI,(T1)		;NTCNSO - CONSO INPUT
	CONO ANI,(T1)		;NTCONO - CONO INPUT
	CONI ANI,T1		;NTCONI - CONI INPUT
	DATAO ANI,T1		;NTDATO - DATAO INPUT
	DATAI ANI,T1		;NTDATI - DATAI INPUT
	NCTDSP ANXINI		;NTINI  - INITIALIZATION INSTRUCTION
	NCTDSP ANXKIL		;NTKILL - SHUTDOWN INSTRUCTION
	NCTDSP ANXRSS		;NTRSRT - RESTART INSTRUCTION
	NCTDSP ANISRT		;NTISRT - START INPUT INSTRUCTION
	NCTDSP ANOSRT		;NTOSRT - START OUTPUT INSTRUCTION
	NCTDSP IMPEIN		;NTIDUN - INPUT DONE DISPATCH
	NCTDSP IMODUN		;NTODUN - OUTPUT DONE DISPATCH
	NCTDSP IMPHDR		;NTLLDR - MAKE HEADER INSTRUCTION
	NCTDSP RSKP		;NTOTOK - CLEAR PACKET FOR OUTPUT
	NCTDSP R		;NTMAIN - MAINTAINANCE
	NCTDSP ANXSCK		;NTSCHK - STATUS CHECK INSTRUCTION
	BLOCK NTINTT-NTIB	;[9175] NTIB through NTRDY
	SIXBIT/AN20/		;[9175] NTINTT - Interface type
	BLOCK NTOCNO-NTORDY	;[9175] NTORDY through NTOTYP
	CONO ANO,(T1)		;NTOCNO - CONO OUTPUT
	CONI ANO,T1		;NTOCNI - CONI OUTPUT
	CONSO ANO,(T1)		;NTOCSO - CONSO OUTPUT
	CONSZ ANO,(T1)		;NTOCSZ - CONSZ OUTPUT
	DATAO ANO,T1		;NTODTO - DATAO OUTPUT
	DATAI ANO,T1		;NTODTI - DATAI OUTPUT
	XPCW .+1		;NTIINT - INTERRUPT INSTRUCTION
	BLOCK 2			;NTIPCW - INTURRUPT PC STORAGE
	EXP 0			;NTINPC - NEW FLAGS (INPUT)
	XCDSEC,,.+1		;         NEW PC (INPUT SAVE)
	MAKSAV (IMPDP'NUM,NTIDSP) ;[9115] NTIISV - 6 words of AC save routine
	MAKRES (NTIPCW)		;NTIIRS - 3 WORDS OF AC RESTORE ROUTINE
	XPCW .+1	       	;NTOINT - INTERRUPT INSTRUCTION
	BLOCK 2			;NTOPCW - PC STORAGE
	EXP 0			;NTONPC - NEW FLAGS
	XCDSEC,,.+1		;         NEW PC (OUTPUT SAVE)
	MAKSAV (IMPDP'NUM,NTODSP) ;[9115] NTIOSV - 6 words of AC save
	MAKRES (NTOPCW)		;NTIORS   3 WORDS OF AC RESTORE
	BLOCK 20		;NTSVAC - AC storage
	PURGE ANI,ANO		;[9115] Zap junk symbols
>				;End of NCP/ANX conditional

;IPNI NCT defifition

IFE <<NT.TYP-NT.NUN>!<NT.DEV-NT.NIP>>,<

	JFCL          		;NTCNSZ - CONSZ Input
	JFCL          		;NTCNSO - CONSO Input
	JFCL          		;NTCONO - CONO Input
	JFCL          		;NTCONI - CONI Input
	JFCL          		;NTDATO - DATAO Input
	JFCL          		;NTDATI - DATAI Input
	NCTDSP NIPINI		;NTINI  - Initialization instruction
	NCTDSP NIPKIL		;NTKILL - Shutdown instruction
	NCTDSP NIPRST		;NTRSRT - Restart instruction
	NCTDSP R     		;NTISRT - Start input instruction
	NCTDSP NIPSTO		;NTOSRT - Start output instruction
	NCTDSP R     		;NTIDUN - Input done dispatch
	NCTDSP R       		;NTODUN - Output done dispatch
	NCTDSP NIPHDR		;NTLLDR - Make header instruction
	NCTDSP RSKP		;NTOTOK - CLear packet for output
	NCTDSP R      		;NTMAIN - Maintainance
	NCTDSP NIPSTA		;NTSCHK - Status check instruction
	BLOCK NTINTT-NTIB	;[9175] NTIB through NTRDY
	SIXBIT/IPNI/		;[9175] NTINTT - Interface type
	BLOCK NTSVAC-NTORDY	;[9175] NTORDY through NTIORS

>				;End of NIN/NIP conditional

;[9135] IPNIA NCT defifition

IFE <<NT.TYP-NT.NUN>!<NT.DEV-NT.NIA>>,<	;[9135] IPNIA psuedo device
	JFCL          		;[9135] NTCNSZ - CONSZ Input
	JFCL          		;[9135] NTCNSO - CONSO Input
	JFCL          		;[9135] NTCONO - CONO Input
	JFCL          		;[9135] NTCONI - CONI Input
	JFCL          		;[9135] NTDATO - DATAO Input
	JFCL          		;[9135] NTDATI - DATAI Input
	NCTDSP NIAINI		;[9135] NTINI  - Initialization instruction
	NCTDSP NIAKIL		;[9135] NTKILL - Shutdown instruction
	NCTDSP NIARST		;[9135] NTRSRT - Restart instruction
	NCTDSP R     		;[9135] NTISRT - Start input instruction
	NCTDSP NIASTO		;[9135] NTOSRT - Start output instruction
	NCTDSP R     		;[9135] NTIDUN - Input done dispatch
	NCTDSP R       		;[9135] NTODUN - Output done dispatch
	NCTDSP NIAHDR		;[9135] NTLLDR - Make header instruction
	NCTDSP RSKP		;[9135] NTOTOK - CLear packet for output
	NCTDSP R      		;[9135] NTMAIN - Maintainance
	NCTDSP NIASTA		;[9135] NTSCHK - Status check instruction
	BLOCK NTINTT-NTIB	;[9175] NTIB through NTRDY
	SIXBIT/IPNIA/		;[9175] NTINTT - Interface type
	BLOCK NTSVAC-NTORDY	;[9175] NTORDY through NTIORS
>				;[9135] End of NIN/NIA conditional


;IPCI nct definition

	IFE <<NT.TYP-NT.NUN>!<NT.DEV-NT.CIP>>,<

	JFCL          		; NTCNSZ - CONSZ Input
	JFCL          		; NTCNSO - CONSO Input
	JFCL          		; NTCONO - CONO Input
	JFCL          		; NTCONI - CONI Input
	JFCL          		; NTDATO - DATAO Input
	JFCL          		; NTDATI - DATAI Input
	NCTDSP CIPINI		; NTINI  - Initialization instruction
	NCTDSP CIPKIL		; NTKILL - Shutdown instruction
	NCTDSP CIPRST		; NTRSRT - Restart instruction
	NCTDSP R     		; NTISRT - Start input instruction
	NCTDSP CIPSTO		; NTOSRT - Start output instruction
	NCTDSP R     		; NTIDUN - Input done dispatch
	NCTDSP R      		; NTODUN - Output done dispatch
	NCTDSP CIPHDR		; NTLLDR - Make header instruction
	NCTDSP RSKP		; NTOTOK - CLear packet for output
	NCTDSP R      		; NTMAIN - Maintainance
	NCTDSP CIPSTA		; NTSCHK - Status check instruction
	BLOCK NTINTT-NTIB	;[9175] NTIB through NTRDY
	SIXBIT/IPCI/		;[9175] NTINTT - Interface type
	BLOCK NTSVAC-NTORDY	;[9175] NTORDY through NTIORS
>				; End of IPCIN/CIP conditional

>				;End of MAKNCT MACRO

;MKPTRS  -  Macro  for  creating the NCT vector table, called at vector
;table location. The following must also be called in the RESCD PSECT.

DEFINE MKPTRS<
..TMP==0			;Start at NCT #0
REPEAT %NETS,<
	MAKPTR(\..TMP)
	..TMP==..TMP+1>
>

;MAKPTR- Sub-macro for finding the proper NCT address

	DEFINE MAKPTR(NUM)<XCDSEC,,.NCT'NUM>



;General Definitions

;Definitions of network and protocal types

NT.NCP==:0			;Protocal type 0, NCP
NT.NUN==:1			;Protocal type 1, No local protocal

NT.ANX==:0			;AN20 device type
NT.NIP==:1			;IPNI device type
NT.CIP==:2			;IPCI device type
NT.NIN==:3			;No Particular Device
NT.NIA==:4			;[9135] IPNIA device type 

;Field definitions for InterNet address'

DEFSTR IANET,0,11,8		;Net Number

;(The next 5 overlap since different nets use the parts differently)

DEFSTR IAHI,0,19,8		;8 bit high part
DEFSTR IAHST,0,19,8		;8 bit host number
DEFSTR IAIMP,0,35,16		;16 bit Low part
DEFSTR IAMID,0,27,8		;8 bit middle
DEFSTR IALOW,0,35,8		;8 bit low part

;[9156] Structures in the Host tables, see MNETDV for more information.

DEFSTR HSTIDX,HOSTN,35,18	;INDEX TO STATUS TABLE
DEFSTR HSTNMP,HOSTN,17,16	;POINTER TO NAME STRING
DEFSTR HSTNIC,HOSTN,0,1		;[9156] This is a nickname, must be sign bit

DEFSTR HSTNDX,HOSTPN,35,18	;[9156] Index in HOSTN of primary name
DEFSTR HSTTTL,HOSTPN,17,18	;[9156] Time_to_live,,-1 in TODCLK units


;Tables for driving Multinet interfaces.

;The  basic  philosophy here, is that each interface (and network type)
;has some subset of functions in common with all others, and also  will
;have  some  other (hopefully smaller) set of functions that are unique
;to it. Partly in order to assure this, we restrict the interface types
;supported  to  packet-switched  networks,  and  preferably  supporting
;Internet protocals  (though  its  not  clear  that  this  is  actually
;necessary).  The  driver table is divided into 4 parts ( possibly with
;some overlap)

;1 - Device independent routines/instructions
;    i.e. I/O instructions and other things that
;    all will have in common
;2 - Device independent storage, Input/Output buffers etc
;3 - Device dependent routines, These depend on the type
;    of interface ( possibly type of network) and will
;    not exist except for those types ( i.e. each interface
;    type should have different definitions for the offsets
;    of these things)
;4 - Device dependent storage - see 3

;The  present  design  has  been  heavily  influenced  by  the  ARPANET
;1822/AN20  code, however it should be general enough to be expanded to
;any type of interface.



;Common Constants

DEFSTR	NTLNK,0,35,36		;Link to next Block
DEFSTR	NTTYP,1,17,18		;Type code of this network
DEFSTR	NTDEV,1,35,18		;Type code of device this interface is
DEFSTR	NTNUM,2,35,18		;Net number(internal index) of this net
..OFST==3			;Start after headers
DEFWRD	NTNET			;Internet network number of this interface
				;-1 until initialized
DEFWRD	NTLADR			;Local InterNet address on this interface
				;-1 until initialized
DEFWRD	NTNLHM			;Logical Host Mask for this (interface's) net
				;0 if none
DEFWRD	NTPSIZ			;Maximum packet size for this network (bytes)

DEFWRD	NTCNSZ			;CONSZ (T1) instruction
DEFWRD	NTCNSO			;CONSO (T1) instruction
DEFWRD	NTCONO			;CONO (T1) instruction
DEFWRD	NTCONI			;CONI T1 instruction
DEFWRD	NTDATO			;DATAO T1 instruction
DEFWRD	NTDATI			;DATAI T1 instruction

DEFWRD	NTINI			;Network Initialization instruction
DEFWRD	NTKILL			;Shutdown instruction
DEFWRD	NTRSRT			;Network restart instruction
DEFWRD	NTISRT			;Start input instruction
DEFWRD	NTOSRT			;Start output instruction
DEFWRD	NTIDUN			;Input done dispatch instruction
				;Called with buffer in T1
DEFWRD	NTODUN			;Output done dispatch instruction
				;Called with buffer in T1
DEFWRD	NTLLDR			;Make a local header instruction
				;Called T1/ (first hop) destination address
				;	T2/ pointing to an Internet buffer
				;	P1/ address of NCT
DEFWRD	NTOTOK			;Check if a packet can be sent.
				;Called T1/ (first hop) destination address
				;	T2/ pointing to an Internet buffer
				;	P1/ address of NCT
				;Skip return if yes,
				;Else non-skip w/ICMP error in T1
DEFWRD	NTMAIN			;Maintainance routine
DEFWRD	NTSCHK			;Hardware status check instruction
				;checks on whether net is on hardware-wise
				;skip return if so ( for an 1822 device
				;Checks the ready-line, note that not all
				;network types may have some thing they
				;can check on)


;Storage needed by all nets

DEFWRD	NTIB			;Current input buffer
DEFWRD	NTOB			;Current output buffer
				;Input interrupts
DEFWRD	NTIDSP			;Input interrupt dispatch address
				;Output interrupts
DEFWRD	NTODSP			;Output interrupt dispatch address

;The  rational behind the following allocation for buffer lists is that
;these are all Internet networks, with some  sort  of  local  protocal,
;consequently  there  is  one  list  for  messages  which  must  go out
;immediately, one for regular messages on the local  network,  and  one
;for  internet  messages.  Since  these are FIFO queues there is both a
;head and a tail pointer for each. In order to keep local  or  internet
;from  choking  the  other  off the NTPRIO word defines the priority of
;each, being more positive if local stuff  has  higher  priority  (  it
;would  be  good  to  keep  this  constant  among  the  various network
;drivers).

;NTBFFL is a flag indicating who owns a given  buffer.  The  left  half
;being  for  input buffers, rh for output. Negative if internet, >=0 if
;local.

DEFWRD	NTHOBO			;High priority output list, head pointer
DEFWRD	NTHOBI			;Tail pointer

DEFWRD	NTLOBO			;Local network output list head pointer
DEFWRD	NTLOBI			;Tail pointer

DEFWRD	NTIOBO			;Internet output list, head pointer
DEFWRD	NTIOBI			;Tail pointer

DEFWRD	NTPRIO			;Priority word for deciding between lists
DEFWRD	NTBFFL			;Flag for who owns buffer ( lh = input, rh out)



;Status flags

;The  following  act  as status flags (and correspond to the old IMPRDY
;GETAB table) between them governing the state of the network  on  that
;interface.

;Software  (protocal driver) flags

DEFWRD	NTRDY			;Actual interface status, 0 = Down,
				;>0 = (TODCLK to abort) Going down, -1=Up
DEFWRD	NETON			;Desired interface status, 0 - Network off,
				;-1 - On, <0,,-1> - Cycle net down & up
DEFWRD  NTINTT			;[9175] Interface type in SIXBIT for EXEC
DEFWRD	NTORDY			;Output enabled on Interface if -1,
				;otherwise no packets are queued (ICM%SQ)
DEFWRD	NTIUPT			;T&D of last time Net came up Internally
				;(for ex. Last time NCP cycled for that net)
DEFWRD	NTXDNT			;T&D of last time net went off externally
				;(for ex. readyline drop)
DEFWRD	NTXUPP			;T&D of last time net came on externally
				;(for ex. ready-line up)
DEFWRD	NTSTCH			;[9175] Unreported state change if +ive

; Hardware (interface driver) flags

DEFWRD	NTERRF			;An external error condition has been noticed
				;by the hardware (i.e. ready-line drop) if -1
DEFWRD	NTNOP			;A (+)count of # of null messages to send
DEFWRD	NTFLS			;A (-)count of # of input messages to ignore
DEFWRD	NTTOUT			;Output hung timeout (TODCLK), or 0 if none



;Storage  needed by only some nets/interface types Since different nets
;use different storage here the same offset can be known  by  different
;names.

;[Presently  storage  is  allocated  here optimaly for the two types of
;networks we have, if more were added it could of course be rearranged]

DEFWRD	NT11ST,0		;11's status word (Cheapnet DTE)
DEFWRD	HSTGDM			;Host going down message wanted (NCP type)
;0 - not going down, +N (why/when) Send msg when output queues are empty,
;or -N if (no output since) sent
DEFWRD	IMPCCH			;Flag to reset hosts (NCP Type nets)
DEFWRD	NTINP			;Current input pointer (AN20)
DEFWRD	NTOUP			;Current Output pointer (AN20)
DEFWRD	NTITYP			;Input transfer type (AN20)
DEFWRD	NTOTYP			;Output tranfer type (AN20)
DEFWRD	NTOCNO			;Output side CONO (T1) (AN20)
DEFWRD	NTOCNI			;Output side CONI T1 (AN20)
DEFWRD	NTOCSO			;Output side CONSO (T1) (AN20)
DEFWRD	NTOCSZ			;Output side CONSZ (T1) (AN20)
DEFWRD	NTODTO			;Output side DATAO T1 (AN20)
DEFWRD	NTODTI			;Output side DATAI T1 (AN20)
				;The following are the interrupt handlers
DEFWRD	NTIINT			;Input interrupt instruction (AN20)
DEFWRD	NTIPCW,2		;Interrupt PC etc storage (AN20)
DEFWRD	NTINPC,2		;New PC and flags (AN20)
DEFWRD	NTIISV,6		;Input interrupt save routine (AN20)
DEFWRD	NTIIRS,3		;Interrupt restore routine (AN20)
DEFWRD	NTOINT			;Output interrupt instruction
DEFWRD	NTOPCW,2		;Interrupt Output PC,flags storage (AN20)
DEFWRD	NTONPC,2		;New Pc on output interrupt
DEFWRD	NTIOSV,6		;Output interrupt save routine (AN20)
DEFWRD	NTIORS,3		;Output restore routine (AN20)
DEFWRD	NTSVAC,20		;Interrupt AC storage

	SUBTTL Internet-Ethernet Interface Definitions

.NICHK==:0              ;Computed checksum of file
.NIGTD==:1              ;GTAD format for date/time of when the file was created
.NIMIR==:2              ;IPHOST version # when created
.NILEN==:3              ;Number of words which follow
NIHMHL==:4		;max length of header 

.NIINT==:0              ;the internet host number  ** MUST BE OFFSET ZERO **
.NIEN1==:1              ;ethernet addr word 1
.NIEN2==:2              ;ethernet addr word 2
.NIGCF==:3              ;gateway control flags
  GH%ARP==1B0		;this ght entry has been updated by arp, adr is valid
  GH%DMB==1B1		;host does not have arp, use this address
NIHMDL==:4              ;max length of per host data

END			;Of ANAUNV

  