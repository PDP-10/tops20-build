; UPD ID= 8706, RIP:<7.MONITOR>DTESRV.MAC.9,  25-Apr-88 13:41:39 by GSCOTT
;TCO 7.1280 - Remove edit 7449 (fix to power fail restart on DN60s), since 
; you can't reliably load a DN60 with edit 7449 installed.   A better fix
; will follow at some future time.
; UPD ID= 8660, RIP:<7.MONITOR>DTESRV.MAC.8,  22-Feb-88 18:48:22 by GSCOTT
;TCO 7.1235 - Run SETSPD at offset 1 in entry vector.
; UPD ID= 8510, RIP:<7.MONITOR>DTESRV.MAC.7,   9-Feb-88 15:04:54 by GSCOTT
;TCO 7.1219 - Front end dumps should go to BS:<SYSTEM>
; UPD ID= 8509, RIP:<7.MONITOR>DTESRV.MAC.6,   9-Feb-88 15:00:00 by GSCOTT
;TCO 7.1218 - Update copyright notice.
; UPD ID= 8411, RIP:<7.MONITOR>DTESRV.MAC.5,   4-Feb-88 11:10:55 by GSCOTT
;TCO 7.1210 - Set DN20ST, DTECGB, DTEERR, DTEIDP, DTEIPR, DTEKPA, DTELDB,
; DTELPI, DTEP2S, DTESUI, DTETIP, DTETPR, DTEWAT, INDCNT to be not normally
; dumpable.
; UPD ID= 114, RIP:<7.MONITOR>DTESRV.MAC.3,  15-Sep-87 18:56:00 by GSCOTT
;TCO 7.1056 - Output "[DECSYSTEM-20 continued]" message to 20F lines only
; *** Edit 7449 to DTESRV.MAC by PRATT on 15-Apr-87, for SPR #20974
; Fix DTBELL in DN60 code to not cause SKDCL1s during powerfail restart 
; *** Edit 7407 to DTESRV.MAC by MCCOLLUM on 29-Dec-86
; Remove FEZDSN BUGCHK. It comes up for every non-existent FE drive. 
; *** Edit 7396 to DTESRV.MAC by MCCOLLUM on 18-Nov-86, for SPR #21429
; Issue BUGCHK in FEDLOP if the FE reports a drive serial number of zero. 
; *** Edit 7226 to DTESRV.MAC by GRANT on 14-Jan-86, for SPR #20842
; Prevent KPALVH BUGHLT when DTEN is changed 
; Edit 7154 to DTESRV.MAC by GRANT on 15-Oct-85
; Fix bug which prevents monitor from finding all the disks ported to the FE. 
;Move table FEDSKT to STG.MAC and fix routine FEDISK.
; UPD ID= 2069, SNARK:<6.1.MONITOR>DTESRV.MAC.57,   3-Jun-85 14:33:08 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 2016, SNARK:<6.1.MONITOR>DTESRV.MAC.56,  28-May-85 12:05:14 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1987, SNARK:<6.1.MONITOR>DTESRV.MAC.55,  17-May-85 15:52:50 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1943, SNARK:<6.1.MONITOR>DTESRV.MAC.54,   9-May-85 17:04:02 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1896, SNARK:<6.1.MONITOR>DTESRV.MAC.53,   4-May-85 15:54:33 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1876, SNARK:<6.1.MONITOR>DTESRV.MAC.52,   4-May-85 11:59:28 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1833, SNARK:<6.1.MONITOR>DTESRV.MAC.51,  26-Apr-85 09:51:07 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1712, SNARK:<6.1.MONITOR>DTESRV.MAC.50,   5-Apr-85 13:57:46 by MCCOLLUM
;TCO 6.1.1238 - Fix BUG. documentation
; UPD ID= 1648, SNARK:<6.1.MONITOR>DTESRV.MAC.49,  18-Mar-85 14:55:24 by PALMIERI
;Use MCBDBG instead of FTDEBUG
;Don't call DNADLL if no callback ID
; UPD ID= 1619, SNARK:<6.1.MONITOR>DTESRV.MAC.48,  12-Mar-85 13:39:40 by PALMIERI
; TCO 6.1.1231
; Don't issue DTETPR if running DECnet protocol
; Add DTBUGX - If zero DTESUI, DN20ST, and DTETPR will be skipped for MCB DTEs
; UPD ID= 1523, SNARK:<6.1.MONITOR>DTESRV.MAC.47,  13-Feb-85 17:36:30 by PALMIERI
;Don't issue DN20ST or DTESUI if procotol is MCB
;Put BUGINF DTEWAT under FTDEBUG
; UPD ID= 1141, SNARK:<6.1.MONITOR>DTESRV.MAC.46,   3-Dec-84 17:28:46 by GLINDELL
;D36COM is now in XCDSEC
; UPD ID= 922, SNARK:<6.1.MONITOR>DTESRV.MAC.45,  24-Oct-84 09:48:24 by PALMIERI
;Check to see if protocol is already running at DTDINI
; UPD ID= 786, SNARK:<6.1.MONITOR>DTESRV.MAC.41,   4-Sep-84 14:43:33 by PALMIERI
;Merge from M60:
; UPD ID= 4758, SNARK:<6.MONITOR>DTESRV.MAC.106,  27-Aug-84 11:31:35 by HAUDEL
;TCO 6.2199 - Add conditional assembly bughlt (SETSPF) under DTESW for
;a SETSPD failure after a FE reload.
; UPD ID= 745, SNARK:<6.1.MONITOR>DTESRV.MAC.40,  20-Aug-84 17:17:13 by TBOYLE
;Update TAKSTF for extended SYSERR (from m60:) It goes temporarily EA.ENT
; UPD ID= 735, SNARK:<6.1.MONITOR>DTESRV.MAC.39,  10-Aug-84 14:13:11 by GLINDELL
;Merge from M60:
; UPD ID= 4558, SNARK:<6.MONITOR>DTESRV.MAC.104,  18-Jul-84 16:41:49 by MCLEAN
;ADD FESER BIT TO INDICATE SERIAL NUMBERS FROM F/E HAVE ARRIVED
; UPD ID= 4553, SNARK:<6.MONITOR>DTESRV.MAC.103,  18-Jul-84 10:34:54 by MCLEAN
;ADD FE REPORTED DISK SERVICE
; UPD ID= 4513, SNARK:<6.MONITOR>DTESRV.MAC.102,  13-Jul-84 19:16:58 by PURRETTA
;Update copyright notice
; UPD ID= 4351, SNARK:<6.MONITOR>DTESRV.MAC.101,  15-Jun-84 16:37:01 by MCLEAN
;ADD TABLE ENTRY AND IGNORE SERIAL NUMBER STUFF
; UPD ID= 645, SNARK:<6.1.MONITOR>DTESRV.MAC.38,  29-Jun-84 15:25:45 by PALMIERI
;Change the way buffers are returned when DTE is cleared
; UPD ID= 638, SNARK:<6.1.MONITOR>DTESRV.MAC.37,  25-Jun-84 15:39:59 by PALMIERI
;Make sure CLRMCB is called each time the MCB line is halted
; UPD ID= 629, SNARK:<6.1.MONITOR>DTESRV.MAC.36,  18-Jun-84 13:32:47 by PALMIERI
;Don't check callback ID for non-zero at CALDVR
; UPD ID= 587, SNARK:<6.1.MONITOR>DTESRV.MAC.35,   1-Jun-84 10:09:52 by PALMIERI
;Use a safer AC at DTEQ14 45
; UPD ID= 583, SNARK:<6.1.MONITOR>DTESRV.MAC.34,  31-May-84 15:24:24 by PALMIERI
;At DTEQ13-15 or so, Don't put message pointer into QCOD if DN60 (MCB only)
; UPD ID= 548, SNARK:<6.1.MONITOR>DTESRV.MAC.33,  23-May-84 21:37:11 by PALMIERI
;Don't init protocol when opening MCB circuit, return MB when closing
; UPD ID= 542, SNARK:<6.1.MONITOR>DTESRV.MAC.32,  23-May-84 07:48:36 by MCINTEE
;Merge from M60:
; UPD ID= 4129, SNARK:<6.MONITOR>DTESRV.MAC.100,  25-Apr-84 11:09:06 by LOMARTIRE
;TCO 6.2046 - Adjust CALL RUNDII to use new argument format
; UPD ID= 484, SNARK:<6.1.MONITOR>DTESRV.MAC.31,  30-Apr-84 13:03:21 by PALMIERI
;Change to new DNADLL interface
; UPD ID= 344, SNARK:<6.1.MONITOR>DTESRV.MAC.30,  24-Feb-84 13:26:21 by PALMIERI
;Update for use with DNADLL
; UPD ID= 338, SNARK:<6.1.MONITOR>DTESRV.MAC.29,  20-Feb-84 09:04:18 by MCINTEE
;More of previous
; UPD ID= 337, SNARK:<6.1.MONITOR>DTESRV.MAC.28,  20-Feb-84 07:39:47 by MCINTEE
;Fix another ELORC bug.
; UPD ID= 334, SNARK:<6.1.MONITOR>DTESRV.MAC.27,  14-Feb-84 12:44:55 by MCINTEE
;Clean up previous
; UPD ID= 333, SNARK:<6.1.MONITOR>DTESRV.MAC.26,  14-Feb-84 12:25:44 by MCINTEE
;Fix ELORC bug.
; UPD ID= 316, SNARK:<6.1.MONITOR>DTESRV.MAC.25,   8-Feb-84 16:48:17 by PALMIERI
;Account for byte pointer overflow at CPYMS3-1
; UPD ID= 315, SNARK:<6.1.MONITOR>DTESRV.MAC.24,   8-Feb-84 11:00:59 by MCINTEE
;More FTPARANOID ELORC tracing.
; UPD ID= 306, SNARK:<6.1.MONITOR>DTESRV.MAC.23,  26-Jan-84 09:19:10 by MCINTEE
;Touch message blocks for MCB protocol in the ELORC quest. (Under FTPARANOID)
; UPD ID= 271, SNARK:<6.1.MONITOR>DTESRV.MAC.22,   7-Dec-83 10:02:34 by MCINTEE
;Typo in previous edit
; UPD ID= 270, SNARK:<6.1.MONITOR>DTESRV.MAC.21,   7-Dec-83 09:14:47 by MCINTEE
;Range check in DTEDSP - on failure, return.
; UPD ID= 266, SNARK:<6.1.MONITOR>DTESRV.MAC.20,   5-Dec-83 09:25:44 by MCINTEE
;Merge from M60:
; UPD ID= 3243, SNARK:<6.MONITOR>DTESRV.MAC.99,   1-Dec-83 12:57:08 by MCINTEE
;TCO 6.1889 - Fix sanity check in RELNOD. Also give the unnamed BUGHLT a name.
; UPD ID= 3156, SNARK:<6.MONITOR>DTESRV.MAC.98,  15-Nov-83 14:14:02 by PRATT
;TCO 6.1796 - ERJMP after "[DECSYSTEM-20 continued]" TTMSG
; UPD ID= 234, SNARK:<6.1.MONITOR>DTESRV.MAC.19,   7-Nov-83 12:29:37 by MCINTEE
;In DTDHLT, call CLRDT0 instead of CLRDTE for safety.
; UPD ID= 225, SNARK:<6.1.MONITOR>DTESRV.MAC.18,  26-Oct-83 18:35:34 by GROSSMAN
;WORK:<GROSSMAN.BUILD>DTESRV.MAC.17 26-Oct-83 18:32:01, Edit by GROSSMAN
;Merge in fixes for QP2 (MCB) protocol initialization.  This makes DTESRV
;do a KI.PRU when the first incoming message occurs, instead of just after
;the handshake is completed.
; UPD ID= 216, SNARK:<6.1.MONITOR>DTESRV.MAC.17,  10-Oct-83 14:02:05 by MCINTEE
;UPDATE FROM M60:
; UPD ID= 3016, SNARK:<6.MONITOR>DTESRV.MAC.97,  10-Oct-83 13:22:00 by MOSER
;MORE TCO 6.1816 - REMOVE EDIT FROM DTESRV. MAKE WORD RESIDENT IN STG
; UPD ID= 2980, SNARK:<6.MONITOR>DTESRV.MAC.96,   4-Oct-83 15:07:53 by MOSER
;TCO 6.1816 - FIX PITRAP
; UPD ID= 198, SNARK:<6.1.MONITOR>DTESRV.MAC.16,  25-Aug-83 08:01:13 by MCINTEE
;Add an EA.ENT
; UPD ID= 190, SNARK:<6.1.MONITOR>DTESRV.MAC.15,   4-Aug-83 15:04:27 by MCINTEE
;Merge from SNARK:<6.MONITOR>
; UPD ID= 2783, SNARK:<6.MONITOR>DTESRV.MAC.94,   2-Aug-83 15:13:15 by HALL
;Cosmetic stuff -- improve the comments
; UPD ID= 2595, SNARK:<6.MONITOR>DTESRV.MAC.93,  20-Jun-83 10:36:48 by HALL
;TCO 6.1689 - Move fork tables to extended section
;	Reference FKJOB via DEFSTR
; UPD ID= 108, SNARK:<6.1.MONITOR>DTESRV.MAC.13,  21-Apr-83 10:35:06 by MCINTEE
;Redo CPYMSG & SKVER2
; UPD ID= 101, SNARK:<6.1.MONITOR>DTESRV.MAC.12,   7-Apr-83 14:51:59 by MCINTEE
; Fix previous edit
; UPD ID= 100, SNARK:<6.1.MONITOR>DTESRV.MAC.11,   7-Apr-83 13:54:38 by MCINTEE
;Add BUGINFs telling about FE reloads.
; UPD ID= 99, SNARK:<6.1.MONITOR>DTESRV.MAC.10,   7-Apr-83 13:09:44 by MCINTEE
;In BTIPR, clean out output queue before initializing protocol.
; UPD ID= 92, SNARK:<6.1.MONITOR>DTESRV.MAC.9,  28-Mar-83 07:49:42 by MCINTEE
;In DTINMC, make ASGRES give section 0 buffers
; UPD ID= 90, SNARK:<6.1.MONITOR>DTESRV.MAC.8,  25-Mar-83 14:37:10 by MCINTEE
;before reloading a FE for keep-alive, BUGINF.
; UPD ID= 2084, SNARK:<6.MONITOR>DTESRV.MAC.92,  25-Mar-83 12:18:13 by WEAVER
;TCO 6.1570 - Change 0DUMP11.BIN to 0DMP11.BIN so name is 6 characters for DDT11
; UPD ID= 89, SNARK:<6.1.MONITOR>DTESRV.MAC.7,  25-Mar-83 07:36:45 by MCINTEE
;At DTDHLT, call DTREST, not DTERST !
; UPD ID= 85, SNARK:<6.1.MONITOR>DTESRV.MAC.6,  22-Mar-83 16:03:50 by MCINTEE
;Still more of 6.1073
; UPD ID= 2047, SNARK:<6.MONITOR>DTESRV.MAC.91,  21-Mar-83 09:56:43 by MCINTEE
;More of TCO 6.1073 - DISPLAY FLAGS FROM BOTH REGIONS
; UPD ID= 1895, SNARK:<6.MONITOR>DTESRV.MAC.90,   1-Mar-83 15:13:15 by GROSSMAN
;TCO 6.1531 - Put operating system type in comm region for front ends.
; UPD ID= 76, SNARK:<6.1.MONITOR>DTESRV.MAC.3,   7-Mar-83 08:18:34 by MCINTEE
;In CLRMCB, put address of buffer in A, not C
; UPD ID= 1796, SNARK:<6.MONITOR>DTESRV.MAC.89,  14-Feb-83 13:51:35 by MURPHY
;TCO 6.1504 - Init FFL before MCENTR at RELOAD.
; UPD ID= 5, SNARK:<6.DECNET>DTESRV.MAC.2,   8-Dec-82 14:20:42 by MCINTEE
;Problems in DTINMC - no more DECNET free pool, restore DTE #
; UPD ID= 1474, SNARK:<6.MONITOR>DTESRV.MAC.88,  23-Nov-82 13:33:30 by MCINTEE
;More of TCO 6.1321
; UPD ID= 1474, SNARK:<6.MONITOR>DTESRV.MAC.88,  23-Nov-82 13:33:30 by MCINTEE
;More of TCO 6.1321
; UPD ID= 1449, SNARK:<6.MONITOR>DTESRV.MAC.87,  16-Nov-82 15:25:17 by MCINTEE
;TCO 6.1377 - IFIWs in FNCTBL
; UPD ID= 1442, SNARK:<6.MONITOR>DTESRV.MAC.86,  15-Nov-82 08:49:45 by GRANT
;TCO 6.1010 - IFIWs in DTINI5's literal
; UPD ID= 1353, SNARK:<6.MONITOR>DTESRV.MAC.85,  19-Oct-82 06:53:51 by GRANT
;TCO 6.1321 - In DOFMCI, put in check for zero byte count
; UPD ID= 1130, SNARK:<6.MONITOR>DTESRV.MAC.84,   1-Sep-82 15:58:32 by HALL
;TCO 6.1245 - Fix RELOAD getting into section 0
; UPD ID= 928, SNARK:<6.MONITOR>DTESRV.MAC.83,  14-Jun-82 07:15:46 by MILLER
; UPD ID= 927, SNARK:<6.MONITOR>DTESRV.MAC.82,  13-Jun-82 20:56:59 by MILLER
;Additional fix for 5.1735. Restore a missing line
; UPD ID= 926, SNARK:<6.MONITOR>DTESRV.MAC.81,  12-Jun-82 20:08:59 by MILLER
;TCO 6.1168. Return input buffers on FE crash
; UPD ID= 925, SNARK:<6.MONITOR>DTESRV.MAC.80,  12-Jun-82 19:56:35 by MILLER
;TCO 5.1735. Fix DTEIOP
; UPD ID= 928, SNARK:<6.MONITOR>DTESRV.MAC.83,  14-Jun-82 07:15:46 by MILLER
; UPD ID= 927, SNARK:<6.MONITOR>DTESRV.MAC.82,  13-Jun-82 20:56:59 by MILLER
;Additional fix for 5.1735. Restore a missing line
; UPD ID= 926, SNARK:<6.MONITOR>DTESRV.MAC.81,  12-Jun-82 20:08:59 by MILLER
;TCO 6.1168. Return input buffers on FE crash
; UPD ID= 925, SNARK:<6.MONITOR>DTESRV.MAC.80,  12-Jun-82 19:56:35 by MILLER
;TCO 5.1735. Fix DTEIOP
; UPD ID= 876, SNARK:<6.MONITOR>DTESRV.MAC.79,   8-Jun-82 23:25:00 by MURPHY
;TCO 6.1147 - Move bugdefs from BUGS.MAC to here and put them in-line.
; UPD ID= 734, SNARK:<6.MONITOR>DTESRV.MAC.78,  11-May-82 17:45:57 by MURPHY
;More 6.1123 - LODCFE.
; UPD ID= 693, SNARK:<6.MONITOR>DTESRV.MAC.77,   5-May-82 10:43:16 by MCINTEE
;Again more TCO 6.1073 - less data in DTEMCC - BUG max. = 4
; UPD ID= 689, SNARK:<6.MONITOR>DTESRV.MAC.76,   4-May-82 18:02:55 by MURPHY
;TCO 6.1123 - Timeout CTY activity, reload FE if no CTY output.
; UPD ID= 676, SNARK:<6.MONITOR>DTESRV.MAC.75,   3-May-82 11:21:59 by MCINTEE
;Still more TCO 6.1073 - more data in DTEMCC (CMTST & CML11)
; UPD ID= 643, SNARK:<6.MONITOR>DTESRV.MAC.74,  14-Apr-82 15:15:42 by MCINTEE
;More TCO 6.1073 - put more of lost interrupt polling under CHNOFF, and
;     put more data in DTEMCC (CMINI bit)
; UPD ID= 578, SNARK:<6.MONITOR>DTESRV.MAC.73,   2-Apr-82 14:10:01 by MURPHY
;Ditto.  Get rid of brackets in comments.
; UPD ID= 576, SNARK:<6.MONITOR>DTESRV.MAC.72,   1-Apr-82 21:40:20 by MURPHY
;TCO 6.1074 - Revise build procedures.  Assemble for KL only.
; UPD ID= 546, SNARK:<6.MONITOR>DTESRV.MAC.71,  22-Mar-82 10:06:36 by MCINTEE
;TCO 6.1073 - check for 0 bytes to -10 transfer in MCB protocol
; UPD ID= 428, SNARK:<6.MONITOR>DTESRV.MAC.70,   1-Mar-82 09:43:08 by GRANT
;TCO 5.1741 - CHECK FOR 0 FORWARD POINTER IN ASGND2
; UPD ID= 427, SNARK:<6.MONITOR>DTESRV.MAC.69,  26-Feb-82 14:09:55 by PLATUKIS
; TCO 5.1738 - clear CMTOT in COMM region in routine DN10MC
; UPD ID= 386, SNARK:<6.MONITOR>DTESRV.MAC.68,   5-Feb-82 16:30:46 by SOUTH
;TCO 5.1720 - fix DN60 protocol race.
; UPD ID= 375, SNARK:<6.MONITOR>DTESRV.MAC.67,   2-Feb-82 10:54:01 by PLATUKIS
;TCO 5.1715 - fix loops at DTINM1+1 and DTINM2+1
; UPD ID= 369, SNARK:<6.MONITOR>DTESRV.MAC.66,   1-Feb-82 15:52:23 by GRANT
;One more try at TCO 5.1711
; UPD ID= 367, SNARK:<6.MONITOR>DTESRV.MAC.65,   1-Feb-82 13:16:57 by GRANT
;Typo in previous edit
; UPD ID= 365, SNARK:<6.MONITOR>DTESRV.MAC.64,   1-Feb-82 09:08:25 by GRANT
;TCO 5.1711 - Under DTESW, zero packet header when it gets assigned
; UPD ID= 350, SNARK:<6.MONITOR>DTESRV.MAC.63,  25-Jan-82 16:29:07 by MURPHY
;Fix bug in previous; make source identical to 5 where only cosmetically different.
; UPD ID= 329, SNARK:<6.MONITOR>DTESRV.MAC.62,  19-Jan-82 17:23:50 by HALL
;TCO 5.1690 -IN DTSNGL, USE S0.ENT TO GET INTO SECTION 0. CODE WAS RETURNING
;  IN SECTION 0 IF FRONT END WASN'T RUNNING
; UPD ID= 311, SNARK:<6.MONITOR>DTESRV.MAC.61,  18-Jan-82 10:46:14 by PLATUKIS
;TCO 5.1676 - fix loops at RMDNL1 and DOPAG1 to test done after timeup
;TCO 5.1677 - add BOTX20
; UPD ID= 297, SNARK:<6.MONITOR>DTESRV.MAC.60,  13-Jan-82 17:06:28 by GRANT
;More TCO 5.1650 - add checking for NCOMH being good
; UPD ID= 296, SNARK:<6.MONITOR>DTESRV.MAC.59,  13-Jan-82 16:57:01 by PAETZOLD
;TCO 5.1673 - change BOTX16 error to BOTX19
; UPD ID= 291, SNARK:<6.MONITOR>DTESRV.MAC.58,  11-Jan-82 13:24:22 by GRANT
;More TCO 5.1650
; UPD ID= 274, SNARK:<6.MONITOR>DTESRV.MAC.57,   5-Jan-82 09:40:52 by GRANT
;TCO 5.1650 - Define QINU, use it and some range checking in packet queuing
; UPD ID= 264, SNARK:<6.MONITOR>DTESRV.MAC.56,  20-Dec-81 16:00:56 by GRANT
;TCO 5.1640 - the word DECSYSTEM-20 should not be mixed case
; UPD ID= 254, SNARK:<6.MONITOR>DTESRV.MAC.55,  14-Dec-81 23:03:24 by SOUTH
; one more error exit in DN60 protocol
; UPD ID= 253, SNARK:<6.MONITOR>DTESRV.MAC.54,  14-Dec-81 20:23:21 by SOUTH
; put back 6.1045 for DN60 protocol only
; UPD ID= 252, SNARK:<6.MONITOR>DTESRV.MAC.53,  14-Dec-81 08:51:55 by SOUTH
; remove 6.1045 for decnet.
; UPD ID= 246, SNARK:<6.MONITOR>DTESRV.MAC.52,  10-Dec-81 23:27:53 by SOUTH
; morest 6.1044 - fix interference of time outs for waiting forks
; UPD ID= 245, SNARK:<6.MONITOR>DTESRV.MAC.51,  10-Dec-81 23:06:56 by SOUTH
; morer 6.1044 - change death test for waiting forks
; UPD ID= 244, SNARK:<6.MONITOR>DTESRV.MAC.50,  10-Dec-81 20:42:22 by SOUTH
; more 6.1044 - get it right this time.
; UPD ID= 241, SNARK:<6.MONITOR>DTESRV.MAC.49,   9-Dec-81 18:32:05 by SOUTH
; TCO 6.1045 - at DTINM1 and DTINM2 use process dismiss to wait for doorbell
; UPD ID= 238, SNARK:<6.MONITOR>DTESRV.MAC.48,   7-Dec-81 11:43:08 by SOUTH
; TCO 6.1044 - clean up error exits in DN60 protocol.
; UPD ID= 235, SNARK:<6.MONITOR>DTESRV.MAC.47,   5-Dec-81 02:27:03 by SOUTH
; TCO 6.1043 - DEDD60 sets D6%NT6 in D6STS to indicate front end death instead
; of releasing the page...unless there are pending operations
; UPD ID= 234, SNARK:<6.MONITOR>DTESRV.MAC.46,   4-Dec-81 19:38:26 by SOUTH
; TCO 6.1042 - at failure exit of CALL DTEQ after BTD63, change JRST BTD62
; to JRST BTD63
; UPD ID= 225, SNARK:<6.MONITOR>DTESRV.MAC.45,   1-Dec-81 09:51:43 by SOUTH
;TCO 6.1040 - bring release 6 version DN60 protocol up to current release 5
; state.
; UPD ID= 224, SNARK:<6.MONITOR>DTESRV.MAC.44,   1-Dec-81 08:41:43 by PAETZOLD
;TCO 6.1039 - Rework literal with label in RMGRNC
; UPD ID= 188, SNARK:<6.MONITOR>DTESRV.MAC.43,   6-Nov-81 11:12:56 by COBB
;Add an EA.ENT at RELOAD to force SEC1, temporary 'til SFORK code fixed to
;	pick up section # added in UPD ID 172 (MURPHY)
; UPD ID= 180, SNARK:<6.MONITOR>DTESRV.MAC.42,   2-Nov-81 17:00:57 by COBB
;Move S0.ENT to avoid trashing stack at DTEFLO.
; UPD ID= 173, SNARK:<6.MONITOR>DTESRV.MAC.41,  30-Oct-81 11:47:22 by MURPHY
;Set T3 to 0 for CALL DTEQ in DTJZCD.
; UPD ID= 172, SNARK:<6.MONITOR>DTESRV.MAC.40,  30-Oct-81 11:44:55 by MURPHY
;Start RELOAD fork in section 1
; UPD ID= 169, SNARK:<6.MONITOR>DTESRV.MAC.39,  26-Oct-81 11:22:34 by COBB
; UPD ID= 165, SNARK:<6.MONITOR>DTESRV.MAC.38,  23-Oct-81 15:45:00 by COBB
; UPD ID= 161, SNARK:<6.MONITOR>DTESRV.MAC.37,  23-Oct-81 15:14:02 by COBB
; UPD ID= 151, SNARK:<6.MONITOR>DTESRV.MAC.35,  21-Oct-81 14:09:48 by GRANT
;Turn off DTEIPR BUGINF
; UPD ID= 136, SNARK:<6.MONITOR>DTESRV.MAC.34,  19-Oct-81 15:49:33 by COBB
;TCO 6.1029 - CHANGE SE1CAL TO EA.ENT
; UPD ID= 245, SNARK:<5.MONITOR>DTESRV.MAC.33,   5-Oct-81 11:37:13 by HALL
;Fix bug in temporary test routine, JHTEST
; UPD ID= 234, SNARK:<5.MONITOR>DTESRV.MAC.32,  30-Sep-81 09:55:50 by SOUTH
; tco 5.1549 - extend  range of NOINT in DN60 protocol til dte deassigned
;  from fork to protect from asynchronous exits with dte in busy state.
; UPD ID= 231, SNARK:<5.MONITOR>DTESRV.MAC.31,  29-Sep-81 11:26:27 by SOUTH
; tco 5.1546 - patch  mcb error check to avoid checking DN60 messages.
; UPD ID= 218, SNARK:<5.MONITOR>DTESRV.MAC.30,  28-Sep-81 11:01:34 by SOUTH
; tco 5.1536 - insert DN60 protocol (.VND60). All dispatches on CMVRR extended
; to account for it. User access through BOOT jsys function code .BTD60.
; UPD ID= 38, SNARK:<5.MONITOR>DTESRV.MAC.29,  16-Jul-81 12:24:30 by HALL
;TEMPORARY CHECKS FOR RUNNING IN SECTION 0 IN RELOAD
; UPD ID= 2218, SNARK:<5.MONITOR>DTESRV.MAC.28,  19-Jun-81 08:32:24 by GRANT
;Add check in SKVR22 for bad message being sent to DN20
; UPD ID= 2185, SNARK:<5.MONITOR>DTESRV.MAC.27,  11-Jun-81 15:54:10 by MURPHY
;CHANGE TQNx TO TMNx REFLECTING CHANGE IN MACSYM
; UPD ID= 2082, SNARK:<5.MONITOR>DTESRV.MAC.26,  26-May-81 15:13:04 by GRANT
;Add DTEIPR BUGINF for debugging purposes
; UPD ID= 1726, SNARK:<5.MONITOR>DTESRV.MAC.25,  17-Mar-81 15:27:33 by MURPHY
;Change STKVAR to TRVAR in DTEQ
; UPD ID= 1717, SNARK:<5.MONITOR>DTESRV.MAC.23,  16-Mar-81 16:32:28 by MURPHY
;TYPO
; UPD ID= 1711, SNARK:<5.MONITOR>DTESRV.MAC.22,  16-Mar-81 14:37:15 by MURPHY
;Count message buffers in use by each DTE, limit to 1/2 of total
; UPD ID= 1698, SNARK:<5.MONITOR>DTESRV.MAC.21,  13-Mar-81 11:35:27 by MURPHY
;More of the same
; UPD ID= 1635, SNARK:<5.MONITOR>DTESRV.MAC.20,   2-Mar-81 18:01:06 by MURPHY
;Prevent failure of DTEQ at PI level
; UPD ID= 1497, SNARK:<5.MONITOR>DTESRV.MAC.19,  26-Jan-81 13:25:54 by ENGEL
;GET RID OF THE LCS STUFF. NO LONGER PART OF NEXT RELEASE.
; UPD ID= 1470, SNARK:<5.MONITOR>DTESRV.MAC.18,  22-Jan-81 09:21:31 by GRANT
;MAKE ALL DTESW CONDITIONALS CONFORM TO CODING STANDARD
; UPD ID= 1468, SNARK:<5.MONITOR>DTESRV.MAC.17,  21-Jan-81 21:56:35 by GRANT
;PUT CODE IN DOFMCI UNDER DTESW
; UPD ID= 1464, SNARK:<5.MONITOR>DTESRV.MAC.16,  21-Jan-81 11:23:05 by GRANT
;TCO 5.1230 - CHANGE OLD DEBUG SWITCH TO DTESW
; UPD ID= 1435, SNARK:<5.MONITOR>DTESRV.MAC.15,  13-Jan-81 16:22:32 by HALL
;TCO 5.1180 - Clear right half of index register in SEEER2 because fork
; 0 now calls it from section 1
; UPD ID= 1357, SNARK:<5.MONITOR>DTESRV.MAC.14,  16-Dec-80 13:03:38 by GRANT
;TCO 5.1216 - fix free space bug in DOFMCI
; UPD ID= 1344, SNARK:<5.MONITOR>DTESRV.MAC.13,  12-Dec-80 09:15:45 by GRANT
;Add resident free space debugging checks in DN10MC and DOFMCI
; UPD ID= 1303, SNARK:<5.MONITOR>DTESRV.MAC.12,  20-Nov-80 14:36:38 by HALL
;RELOAD - RUN IN SECTION 1 BECAUSE KILPAG LEADS TO GDSTX
; UPD ID= 1080, SNARK:<5.MONITOR>DTESRV.MAC.11,   1-Oct-80 11:43:12 by MURPHY
;FIX ACVAR, ETC.
; UPD ID= 974, SNARK:<5.MONITOR>DTESRV.MAC.10,  29-Aug-80 08:41:38 by ENGEL
;ADD LCS NSP CALLING STUFF
; UPD ID= 913, SNARK:<5.MONITOR>DTESRV.MAC.9,  18-Aug-80 22:30:53 by MURPHY
;TURN ON FE DEBUG MODE MESSAGES
; UPD ID= 904, SNARK:<5.MONITOR>DTESRV.MAC.8,  15-Aug-80 14:34:37 by MURPHY
;DITTO
; UPD ID= 895, SNARK:<5.MONITOR>DTESRV.MAC.7,  14-Aug-80 10:23:27 by MURPHY
;REVISE FE DEBUG MODE
; UPD ID= 891, SNARK:<5.MONITOR>DTESRV.MAC.6,  13-Aug-80 18:17:44 by MURPHY
;Send .DFDBG message depending on state of DBUGSW
; UPD ID= 814, SNARK:<5.MONITOR>DTESRV.MAC.5,  30-Jul-80 11:27:40 by MURPHY
;CHECK DBUGSW BEFORE "CONTINUED" MESSAGE
; UPD ID= 751, SNARK:<5.MONITOR>DTESRV.MAC.4,  11-Jul-80 14:16:28 by MURPHY
;FIX PREV EDIT CODING STYLE
; UPD ID= 722, SNARK:<5.MONITOR>DTESRV.MAC.3,   2-Jul-80 10:45:05 by LYONS
;J0NRUN from DTEQ when RSX is sick. Fork 0 can get blocked at HAVNOD.
; UPD ID= 421, SNARK:<4.1.MONITOR>DTESRV.MAC.63,   8-Apr-80 16:49:28 by KONEN
;Correct TCO 4.1.1059
; UPD ID= 336, SNARK:<4.1.MONITOR>DTESRV.MAC.62,  14-Mar-80 13:52:06 by MILLER
;TCO 4.1.1112. Add CMPCT to RSX20F protocol
; UPD ID= 329, SNARK:<4.1.MONITOR>DTESRV.MAC.61,  13-Mar-80 13:51:43 by KONEN
; UPD ID= 204, SNARK:<4.1.MONITOR>DTESRV.MAC.60,  16-Jan-80 15:07:47 by KONEN
;Make previous edit a little nicer
; UPD ID= 189, SNARK:<4.1.MONITOR>DTESRV.MAC.59,   8-Jan-80 09:37:01 by KONEN
;TCO 4.1.1059 - Add subroutine RMGRNC to call RMGRNK.
; UPD ID= 176, SNARK:<4.1.MONITOR>DTESRV.MAC.58,  21-Dec-79 16:36:42 by GRANT
;ADD DTETBE BUGHLT SYMBOL
;<4.MONITOR>DTESRV.MAC.57, 31-Oct-79 15:55:26, EDIT BY MILLER
;ADD DTEFLA. FLUSH ALL REQUESTS FOR A LINE
;<4.MONITOR>DTESRV.MAC.56, 31-Oct-79 15:23:21, EDIT BY MILLER
;FLUSH DTEQS IN SCHEDULER WHENEVER DTRLD IS SET OR DETECTED ON
;<4.MONITOR>DTESRV.MAC.55, 26-Sep-79 16:13:49, EDIT BY HALL
;LODSEC IN BOOT JSYS - CALL BLTUM1 INSTEAD OF BLTUM FOR EXTENDED
;ADDRESSING
;<4.MONITOR>DTESRV.MAC.54, 26-Sep-79 15:57:14, EDIT BY MILLER
;AVOID AWAKING JOB 0 AT TKACK2 IF DBUGSW IS 2
;<4.MONITOR>DTESRV.MAC.53, 20-Sep-79 12:29:31, EDIT BY MILLER
;ADD RLDFRK
;<4.MONITOR>DTESRV.MAC.52, 20-Sep-79 11:51:10, EDIT BY MILLER
;FIX DNSNGL
;<4.MONITOR>DTESRV.MAC.51, 19-Sep-79 17:05:08, EDIT BY MILLER
;<4.MONITOR>DTESRV.MAC.50, 19-Sep-79 11:25:59, EDIT BY MILLER
;CHECK FOR SINGLE CHAR PACKET IN CLRDTE
;<4.MONITOR>DTESRV.MAC.49, 19-Sep-79 10:43:35, EDIT BY MILLER
;ONE MORE TRY. CLEAR DTERL FIRST
;<4.MONITOR>DTESRV.MAC.48, 14-Sep-79 12:36:12, EDIT BY MILLER
;TCO 4.2467. FIX -11 RELOAD
;<OSMAN.MON>DTESRV.MAC.1, 10-Sep-79 15:27:43, EDIT BY OSMAN
;TCO 4.2412 - Move definition of BUGHLTs, BUGCHKs, and BUGINFs to BUGS.MAC
;<4.MONITOR>DTESRV.MAC.46, 30-Aug-79 19:49:02, EDIT BY MILLER
;FIX CODE AT DTPOL3 TO CALL DOFRGM WITH CORRECT ARGS
;<4.MONITOR>DTESRV.MAC.45,  3-Aug-79 14:32:03, EDIT BY ENGEL
;AVOID NOSKED PAGE FAULT AT PROINI
;<4.MONITOR>DTESRV.MAC.44, 11-Jun-79 17:32:50, Edit by KONEN
;REMOVE CALL TO KILPAG IN UNLPAG
;<4.MONITOR>DTESRV.MAC.43,  9-Jun-79 14:03:59, EDIT BY MILLER
;<4.MONITOR>DTESRV.MAC.42,  9-Jun-79 14:03:07, EDIT BY MILLER
;REPLACE MOST BUGHLTS WITH FE RELOADS.
;<4.MONITOR>DTESRV.MAC.41, 26-May-79 14:05:09, EDIT BY MILLER
;FIX ILULK2 BUGHLTS
;<4.MONITOR>DTESRV.MAC.40, 16-May-79 15:24:47, EDIT BY MILLER
;FIX DTEINA TO NOT WAIT FOREVER FOR TO -11 I/O COMPLETION
;<4.MONITOR>DTESRV.MAC.39, 20-Apr-79 10:23:44, EDIT BY KIRSCHEN
;SAVE ERROR CODE WHEN BOOT FUNCTION FAILS
;<4.MONITOR>DTESRV.MAC.38,  4-Apr-79 14:39:28, EDIT BY MILLER
;<4.MONITOR>DTESRV.MAC.37,  4-Apr-79 13:57:33, EDIT BY MILLER
;ZERO DTEEBP AND DTETBP AT DTREST
;<4.MONITOR>DTESRV.MAC.36, 26-Mar-79 10:09:24, EDIT BY MILLER
;<4.MONITOR>DTESRV.MAC.35, 23-Mar-79 09:28:19, EDIT BY MILLER
;PUT BACK TEST. BLOCK PROCESS IF CALL IS FOR MASTER DTE
;<4.MONITOR>DTESRV.MAC.34, 22-Mar-79 21:12:21, Edit by MCLEAN
;REMOVE JN DTERLD IN DTEQ12 SO WE DON'T LOOSE THINGS DURING RELOAD
;<4.MONITOR>DTESRV.MAC.33,  7-Mar-79 14:46:23, Edit by MCLEAN
;ADD A SETZM  DTECMD TO RELOAD TO PREVENT ILQ FRONT-END HALTS
;<4.MONITOR>DTESRV.MAC.32,  4-Mar-79 15:32:17, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.MONITOR>DTESRV.MAC.31,  4-Mar-79 14:44:33, EDIT BY MILLER
;ADD CODE TO CHECK FOR TO -10 TRANSFER TOO LONG
;<4.MONITOR>DTESRV.MAC.30, 14-Feb-79 16:56:07, EDIT BY MILLER
;<4.MONITOR>DTESRV.MAC.29, 14-Feb-79 16:46:35, EDIT BY MILLER
;SWITCH MEANINGS OF CMPCT AND CMQCT FOR MCB PROTOCOL
;<4.MONITOR>DTESRV.MAC.28,  7-Feb-79 15:42:07, EDIT BY KIRSCHEN
;FIX COMMENT ON DOFRGM
;<4.MONITOR>DTESRV.MAC.27,  1-Feb-79 17:05:35, EDIT BY KIRSCHEN
;DO NOT CLEAR -TO11 BYTE POINTER IN KILPAG; ALREADY CLEARED IN RMGRNK
;<4.MONITOR>DTESRV.MAC.26,  1-Feb-79 16:04:50, EDIT BY MILLER
;ADD DTE NUMBER TO ALL BUGCHK AND BUGINF MESSAGES
;<4.MONITOR>DTESRV.MAC.25, 30-Jan-79 13:47:43, EDIT BY KIRSCHEN
;CLEAR TO-11 BYTE POINTER IN EPT WHEN UNMAPPING DTERBT PAGE
;<4.MONITOR>DTESRV.MAC.24, 30-Jan-79 12:06:00, EDIT BY MILLER
;DON'T CHECK DTERL BIT IN DTEIOP
;<4.MONITOR>DTESRV.MAC.23, 14-Jan-79 15:08:09, Edit by MCLEAN
;REMOVE TTMVSP
;<4.MONITOR>DTESRV.MAC.21, 12-Jan-79 21:06:13, EDIT BY KIRSCHEN
;CHANGE SETZM T4, TO SETZ T4, IN BTCPN
;<4.MONITOR>DTESRV.MAC.20, 21-Dec-78 17:06:15, EDIT BY MILLER
;FIX BOOTTB FOR ILLEGAL FUNCTION TRANSFERS
;<4.MONITOR>DTESRV.MAC.19, 18-Dec-78 16:20:23, EDIT BY ENGEL
;FIX BAD PLACEMENT OF .BTCLI CHECK
;<4.MONITOR>DTESRV.MAC.18, 15-Dec-78 16:29:45, EDIT BY ENGEL
;FIX DTE CHECKING FOR .BTCLI (NOT WANTED)
;<4.MONITOR>DTESRV.MAC.17, 15-Nov-78 20:16:24, EDIT BY MILLER
;CHNAGE RMGRNK TO CLEAR BYTE COUNT REG AND TO -10 POINTER
;<4.MONITOR>DTESRV.MAC.16, 11-Nov-78 18:43:35, Edit by MCLEAN
;<4.MONITOR>DTESRV.MAC.15, 11-Nov-78 18:34:24, Edit by MCLEAN
;MAKE DTEFLO CHECK FOR INTERRUPT ADDRESS INSTEAD OF CODE
;THIS WILL HELP PREVENT MONPDL'S AND PERMIT XON/XOFF TO PASS
;<4.MONITOR>DTESRV.MAC.14,  6-Nov-78 16:29:13, EDIT BY ENGEL
;ADD RETSKP TO BTCPN
;<4.MONITOR>DTESRV.MAC.13,  6-Nov-78 14:27:05, EDIT BY ENGEL
;CHANGE COMPARE IN BTCLI
;<4.MONITOR>DTESRV.MAC.12,  6-Nov-78 11:03:42, EDIT BY ENGEL
;DON'T CHECK FOR NULL IN .BTCLI
;<4.MONITOR>DTESRV.MAC.11, 27-Oct-78 17:45:19, EDIT BY HALL
;FIX THE CHECKS ON Q2 AGAINST DTEN - WENT THE WRONG WAY
;<4.MONITOR>DTESRV.MAC.10, 27-Oct-78 10:10:38, EDIT BY ENGEL
;ADD .BTCLI AND .BTCPN
;<4.MONITOR>DTESRV.MAC.9, 18-Oct-78 14:43:36, EDIT BY KIRSCHEN
;REMOVE .BTLST
;<4.MONITOR>DTESRV.MAC.8, 13-Oct-78 09:07:34, EDIT BY KIRSCHEN
;FIX BOOT JSYS DISPATCH TABLE
;<4.MONITOR>DTESRV.MAC.7,  6-Oct-78 15:01:33, EDIT BY KIRSCHEN
;ADD BTLST FUNCTION TO BOOT JSYS
;<4.MONITOR>DTESRV.MAC.6, 16-Aug-78 11:19:42, EDIT BY MILLER
;FIX PROTOCOL PAUSE ROUTINES NOT TO GET CONFUSED IF IN SECONDARY PROTOCOL
;<4.MONITOR>DTESRV.MAC.5, 27-Jul-78 17:40:48, EDIT BY MILLER
;FIX RELOAD TO TRY MASTER FE AT LEAST 3 TIMES
;<4.MONITOR>DTESRV.MAC.4, 18-Jul-78 08:46:20, EDIT BY MILLER
;MORE OF "CONTINUED" CHANGES
;<4.MONITOR>DTESRV.MAC.3, 17-Jul-78 08:55:20, EDIT BY MILLER
;SUPPRESS "CONTINUED" MESSAGE ON PROTOCOL PAUSE
;<4.MONITOR>DTESRV.MAC.2, 14-Jul-78 13:59:58, EDIT BY MILLER
;MORE FIXES FOR RELAODING A DTE. FIX DTE SCHEDULER SO IT CAN RUN IN SECTION 1

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


	SEARCH PROLOG,SERCOD,D36PAR
	TTITLE DTESRV

  IFN KLFLG,<			;CONDITIONAL WHOLE FILE

	RESCD

MAXSGL==6
SNGHDR==3
SNGONQ==1B2
SNGAVL==1B3
SNGACT==1B4


;LOCAL DEFINITIONS FOR RELOAD WAITS

PWRDN1==^D1150			;-11 MUST COMPLETE POWER DOWN IN THIS TIME
ROMTIM==^D2000			;ROM MUST ACK -10 IN THIS TIME
BUTTIM==^D5000			;-11 BOOTSTRAP TRANSFER TIME
DRBTIM==^D60000			;-11 RELOAD TIME
T10TIM==^D3000			;MAX TIME FOR 1K OF -11 CORE TO BE
				; TRANSFERRED TO THE -10
MONPRO==^D5000			;MUST ENTER MONITOR PROTOCOL IN THIS TIME
PRIPRO==^D10000			;MUST ENTER PRIMARY IN THIS TIME
MCINI0==^D1500			;TIME FOR MCB TO INIT COMM REGIONS
MCINI1==^D500			;TIME TO COMPLETE PROTOCOL TRANSITION

	DTENL==^D256		;LINES PER DTE20
	SDTE==3			;SHIFT VALUE FOR DTE UNITS
	MAXINP==^D254		;MAX NUMBER OF BYTES IN AN INDIRECT
				; PACKET WHICH IS EVEN
	DSK11==1B28		;RP RELOAD DEVICE IN -11 ROM

;TEMPORARY DEFINITION OF DECNET BLOCK SIZE

	UBLSIZ==^D600

;SPECIAL DEFINITIONS FOR SCHEDULER PRIORITY WORDS

BOTPRI==1			;SPECIAL PRIORITY WORD FOR BOOT JSYS INIT
RLDPRI==<XWD ^D80,1>		;SPECIAL MASTER -11 RELOAD PRIORITY

;STORAGE USED HEREIN

RS NCOMH,1			;NUMBER OF NODES IN FREE LIST


;DTE SERVICE ROUTINE. THIS CODE CONTAINS THE INITIALIZATION CODE,
;THE QUEUE HANDLING AND SCHEDULING CODE AND THE INTERRUPT HANDLER
;FOR THE DTE.

;LOCAL DEFINITIONS

PVERSN==1			;PROTOCOL VERSION NUMBER
CVERSN==2			;COMMUNICATIONS VERSION NUMBER
LDTEPI==DTEPI0+DLSCHN+DTEPIE	;TURN ON ALL PI'S
MAG11N==1365			;THE RELOAD INDICATOR FOR THE -11 ROM

;DEFINE LOCAL STORAGE

DEFSTR (QLINK,0,35,18)		;LINK TO NEXT PACKET
DEFSTR (QINT,0,17,18)		;INT LOC FOR THIS FUNCTION
DEFSTR (QFNC,1,17,18)		;FUNCTION WORD FOR THIS REQUEST
DEFSTR (QDEV,1,35,18)		;DTE DEVICE CODE FOR THIS REQUEST
DEFSTR (QNSPH,1,35,36)		;FULL WORD FOR NSP BYTE POINTER
DEFSTR (QLIN,2,17,18)		;DEVICE UNIT NUMBER
DEFSTR (QMODE,2,18,1)		;IF ONE, INDIRECT DATA MUST BE BYTE MODE
DEFSTR (QINU,2,19,1)		;PACKET "IN USE" BIT
DEFSTR (QCNT,2,35,16)		;BYTE COUNT OR BYTE OR 0
DEFSTR (QPNTR,3,35,36)		;BYTE POINTER FOR INDIRECT OPERATION
				;OR LOCAL 8-BIT DATUM IF QCNT=0
DEFSTR (QCOD,4,35,36)		;UNIQUE CODE RETURNED TO INTERRUPT
				; ROUTINE

;DTE STATUS DEFINITIONS IN DTESTS


DEFSTR(DTERL,DTESTS,0,1)	;BIT TO SAY DTE IS RUNNING A PROTOCOL
.DTERL==1B0			;so it can be used efficiently
DEFSTR(DTEBF,DTESTS,1,1)	;WHICH BUFFER IS IN USE FOR RSX20F
DEFSTR (DTBLK,DTESTS,2,1)	;FOR MCB, TO -10 IS BLOCKED ON FREE
				; SPACE
DEFSTR(DTRLD,DTESTS,3,1)	;IF ONE, THIS -11 BEING RELOADED
.DTRLD==1B3			;so it can be used efficiently
DEFSTR (DTKAC,DTESTS,4,1)	;IF ONE, THIS -11 IS ILL
DEFSTR (DTSTI,DTESTS,5,1)	;STATUS PACKET IS SPLIT
DEFSTR(DTEB1,DTESTS,17,12)	;BYTE COUNT OF LAST TRANSFER

DEFSTR (DTEBC,DTESTS,29,12)	;BYTE COUNT REMAINING FOR SUBSEQUENT
DEFSTR (DTIPU,DTESTS,31,1)	;Tell DECnet about protocol up on 1st doorbell
DEFSTR (DTEST,DTESTS,35,4)	;DTE STATUS
	DTET10==1		;-10 IS RECIEVING LAST FRAGMENT OF A MESSAGE
	DTE11==2		;-11 IS RECEIVING BYTES
	DTE11I==4		;-11 IS RECEIVING AN INDIRECT QUEUE ENTRY
	DTET1F==10		;10 RECEIVING FIRST FRAFMENT OF
				; A MESSAGE

;PARALLEL STATUS TABLE CONTAINING CURRENT OPERATION DATA

DEFSTR(DT1FC,DTEST1,15,16)	;CURRENT FUNCTION CODE
DEFSTR(DT1DV,DTEST1,31,16)	;CURRENT DEVICE CODE

;SPECIAL REQUEST BITS FOR TO 11 CONDITIONS

DEFSTR(DT1TM,DTEST1,32,1)	;-11 WANTS TIME OF DAY
DEFSTR(DT1ID,DTEST1,33,1)	;WAITING FOR INDIRECT SETUP

DEFSTR(DTBTMR,DTETMR,35,36)	;TIMER VARIABLE
DEFSTR(DTBOBL,DTEOBL,35,36)	;SECTION ZERO OUTPUT BLOCK
DEFSTR(DTBIBL,DTEIBL,35,36)	;SECTION ZERO INPUT BLOCK
DEFSTR(DTBDID,DTEDID,35,36)	;DRIVER PORT IDENTIFIER

;MORE STORAGE DEFINITIONS



;STORAGE FOR INDIRECT PACKETS
	DEFSTR (INUNT,DTEIND,7,8)
	DEFSTR (INCNT,DTEIND,15,8)
	DEFSTR (INVLD,DTEIND,16,1) ;SAYS IF UNIT FIELD IS VALID
;********* FOR MCB, DTEIND CONTAINS FREE SPACE BLOCK ********


;DEFINITIONS FOR DTE PACKETS

DEFSTR (HDCNT,0,15,16)		;COUNT
DEFSTR (HDFNC,0,31,16)		;FUNCTION
DEFSTR (HDDEV,1,15,16)		;DEVICE CODE
DEFSTR (HDSPR,1,31,16)		;SPARE
DEFSTR (HDLIN,2,7,8)		;LINE NUMBER
DEFSTR (HDDAT,2,15,8)		;DATUM
DEFSTR (HDDT1,2,15,16)		;DATUM FOR SINGLE DATUM PACKET


;DEFINE THE COMMUNICATIONS REGION

;FIELD DEFINITIONS FOR THE COMMUNCIATIONS REGION
;FIRST THE OWNED AREA

	DEFSTR (CMTEN,0,0,1)	;TEN INDICATOR IN HEADER
	DEFSTR (CMVER,0,3,3)	;VERSION NUMBER
	DEFSTR (CPVER,0,11,6)	;COMMUNCIATIONS PROTOCOL VERSION NUMBER
	DEFSTR (CMNPR,0,16,5)	;NUMBER OF PROCESSORS HERE
	DEFSTR (CMSIZ,0,19,3)	;SIZE IN MULTIPLES OF 8 WORDS
	DEFSTR (CMNAM,0,35,16)	;PROCESSOR NAME
	DEFSTR (CMLNK,1,35,36)	;POINTER TO NEXT PROCESSOR
	DEFSTR (CMOPS,2,3,4)	;OPERATING SYSTEM TYPE
	DEFSTR (CMCPN,2,35,4)	;CPU NUMBER+1 FOR MULTI-PROCESSORS
	DEFSTR (CMKAC,KPALIV,35,36) ;PROCESSOR KEEP ALIVE COUNTER
		CMPCW==6	;PC WORD
		CMPIWD==7	;CONI PI, WORD
		CMPGWD==10	;CONI PAG, WORD
		CMPDWD==11	;DATI PAG, WORD
		CMAPRW==12	;CONI APR, WORD
		CMDAPR==13	;DATI APR, WORD

;NOW THE "TO" AREA
	DEFSTR (CMPRO,0,0,1)	;1 IF THIS IS CONNECTION TO A -10
	DEFSTR (CMDTE,0,1,1)	;I IF A DTE IS CONNECTING THESE TWO
	DEFSTR (CMDTN,0,3,2)	;DTE NUMBER
	DEFSTR (CMSZ,0,19,3)	;SIZE OF BLOCK/8
	DEFSTR (CMVRR,0,16,5)	;PROTOCOL IN USE BY THE TWO PROCESSORS
	DEFSTR (CMPNM,0,35,16)	;PROCESSOR NUMBER
	DEFSTR (CMPPT,1,35,36)	;POINTER TO ASSOCIATE PROCESSOR
	DEFSTR (CMPWF,2,0,1)	;POWER FAIL INDICATOR
	DEFSTR (CML11,2,1,1)	;LOAD-11 INDICATOR
	DEFSTR (CMINI,2,2,1)	;INI BIT FOR MCB PROTOCOL ONLY
	DEFSTR (CMTST,2,3,1)	;VALID EXAMINE BIT
	DEFSTR (CMQP,2,13,1)	;1 IF USING QUEUED PROTOCOL
	DEFSTR (CMFWD,2,17,1)	;SAYS TO DO FULL WORD TRANSFER
	MSKSTR (CMIP,2,400000)	;INDIRECT POINTER IS SET UP
	MSKSTR (CMTOT,2,200000) ;TOIT BIT
	DEFSTR (CM0IC,2,27,8)	;TO10IC FOR QUEUE TRANSFERS
	DEFSTR (CM1IC,2,35,8)	;TO11IC FOR QUEUE TRANSFERS
	DEFSTR (CMQCT,3,35,16)	;COUNT OF WORDS IN CURRENT QUEUE
	DEFSTR (CMPCT,3,19,16)	;COUNT OF ALL PIECES (OR QUEUES)

;DEFINITIONS FOR PROTOCOL VERSION .VNMCB ONLY

	DEFSTR (CMTMD,3,3,4)	;MODE OF THE TRANSFER
	DEFSTR (CMTBP,4,35,36)	;TO -10 POINTER AT END OF TRANSFER

;COMMON DEFINITIONS

	DEFSTR (CMRLF,4,35,36)	;RELOAD PARAMETER FOR THIS -11
	DEFSTR (CMKAK,5,35,36)	;MY COPY OF HIS CMKAC
	CMCLR1==2		;FIRST DYNAMIC WORD TO CLEAR
	CMCLR2==3		;OTHER WORD TO CLEAR

;FUNCTION TRANSFER VECTOR FOR RSX20F PROTOCOL (.VN20F) ONLY

FNCTBL:	IFIW!TAKCTY		;FE TELLING ABOUT THE CTY
	IFIW!TAKDS		;STRING DATA (FOR CDR)
	IFIW!TAKLC		;LINE CHARACTERS (FOR DLS)
	IFIW!NOOP		;NOT YET IMPLEMENTED
	IFIW!NOOP		;NOT YET IMPLEMENTED
	IFIW!TAKSTD		;-11 SENDING ERROR INFORMATION
	IFIW!NOOP		;UNSUPPORTED
	IFIW!SNDTOD		;-11 WANTS TIME OF DAY
	IFIW!TAKTOD		;-11 IS SENDING TIME OF DAY
	IFIW!NOOP		;FLUSH OUTPUT NOT SUPPORTED
	IFIW!NOOP		;SEND ALL NOT SUPPORTED
	IFIW!DIALUP		;A LINE DIALED UP
	IFIW!HANGUP		;A LINE HUNG UP
	IFIW!EMPTY		;LINE BUFFER EMPTY
	IFIW!NOOP		;XOFF
	IFIW!NOOP		;XON
	IFIW!TAKSPD		;SET LINE SPEED
	IFIW!LINEAL		;SET LINE ALLOCATION
	IFIW!TAKRLW		;TAKE -11 RELOAD INFORMATION
	IFIW!TAKACK		;ACK ALL DEVICES AND UNITS
	IFIW!NOOP		;TURN ON/OFF LINES
	IFIW!NOOP		;ENABLE/DISABLE DATASETS
	IFIW!NOOP		;LOAD TRANSLATION RAM
	IFIW!NOOP		;LOAD VFU
	IFIW!NOOP		;SUPPRESS SYSTEM MESSAGES
	IFIW!TAKKLI		;TAKE KLINIK DATA
	IFIW!NOOP		;CODE 34
	IFIW!NOOP		;CODE 35
	IFIW!NOOP		;CODE 36
	IFIW!NOOP		;CODE 37
	IFIW!FEDISK		;CODE 40 IGNORE NEW CODE FOR SERIAL NUMBERS
MINFNC==2			;FIRST IMPLEMENTED FUNCTION
MAXFNC==.-FNCTBL+MINFNC-1	;MAX FUNCTION NUMBER

;DEFINITIONS FOR NSP HEADER PACKET USING MCB PROTOCOL

NSPDN==177777B23		;POSITION OF DEST NODE ADDRESS
NSPMF==377B15			;POSIITON OF MESSAGE FLAGS (WORD 1)
NSPRF==377B7			;POSITION OF ROUTING FLAGS
NSPS0==377B31			;POSITION OF FIRST BYTE OF SOURCE NODE
NSPS1==377B7			;POSITION OF SECOND BYTE OF SOURCE NODE
				; (WORD 1)

;COMM REGION MODE TYPES FOR MCB BYTE TRANSFERS

.TMBYT==0			;BYTE MODE TRANSFERS
.TMWRD==2			;WORD MODE TRANSFERS
.TMBWD==1			;BYTES IN WORD MODE TRNASFERS
	SUBTTL Initialization

;THIS IS THE DTE INITIALIZATION CODE. IT SETS  UP THE
;COMMUNICATIONS AREA FOR THE MASTER DTE ONLY (WHICH RUNS .VN20F PROTOCOL)

	SWAPCD			;IS CALLED FROM JOB 0
PROINI::SETOM BTLOCK		;INITIALIZE BOOT PAGE LOCK
	SETOM RLDFRK		;INIT REOAD FORK I.D.
	MOVEI A,^D5000		;MAKE 5 SEC CHECK
	MOVEM A,DTETIM		;TO THE TIMER
	SETZM CTYUNT		;****TEMP VALUE FOR CTY
	SETZM TO11TM		;FREE UP TIME PACKET
	MOVE A,[DTEEPW,,DTEEPW+1] ;AVOID NOSKED PAGE FAULT
	NOSKED			;NO SCHEDULING
	CHNOFF DLSCHN		;TURN OFF THE DTE CHANNEL
	BLT A,DTEDRW+<DTEN-1>*10 ;CLEAR ENTIRE REGION IN THE EPT
STBUF1:	SETZ A,			;FIRST COMMUNICATIONS REGION
	MOVEI B,DTEN		;NUMBER TO DO
STOBUF:	MOVEM A,COMBUF(B)	;STORE THIS GUY
	ADD A,[1B11+COMSIZ]	;NEXT REGION
	CAIN B,DTEN		;IS THIS THE -10'S REGION?
	ADDI A,COMRGN*<DTEN-1>	;YES. ADD IN SPACE FOR ALL OF THE -11'S
	SOJGE B,STOBUF		;DO ALL OF REGION
	SETZM COMBAS		;SET UP TO CLEAR ENTIRE COM AREA
	MOVSI A,COMBAS		;FIRST WORD
	HRRI A,COMBUF+DTEN+2	;FIRST WORD BEYOND THAT
	BLT A,COMBUF+DTEN+IEXSIZ ;CLEAR ENTIRE COMM REGION

;NOW CREATE THE REQUEST QUEUE

	MOVSI A,1-NQPKT		;NUMBER OF LINKS TO MAKE
DOQLNK:	MOVEI B,QPKT+COMQ(A)	;THE NEXT PACKET
	MOVEM B,COMQ(A)		;MAKE A LINK
	ADDI A,QPKT-1		;TO MAKE THE AOBJN WORK
	AOBJN A,DOQLNK		;DO ALL PACKETS
	MOVEI A,COMQ		;THE FIRST PACKET
	MOVEM A,COMH		;MAKE THE HEADER POINT TO THE FIRST
	MOVEI A,NQPKT		;INIT FREE COUNT
	MOVEM A,NCOMH
	; ..

; INIT QUEUE HEADERS

	;..
	MOVSI A,-DTEN		;NUMBER TO DO
BUFFLP:	SETZM DTEQS(A)		;INIT SCHEDULER QUEUE
	AOBJN A,BUFFLP		;DO ALL DTE'S
	MOVE A,MSTRDT		;GET NUMBER OF MASTER DTE
	MOVEI B,.VN20F		;INIT IT TO RSX20F PROTOCOL
	CALL DTINIT		;DO IT
	CHNON DLSCHN		;TURN ON DTE CHANNEL
	OKSKED			;AND ALLOW SCHEDULING AGAIN
	CALL DFNDL1		;GO FIX UP SPECIAL LINES ON THE FE
	CALLRET INIDV1		;AND GO DO THE FRONT END DEVICES

;ROUTINE TO DO POWER FAIL INIT FOR EACH OF THE DTE'S.

	RESCD			;MUST BE RESIDENT SO RESTART WORKS

STODT2:	SAVEP			;SAVE PERMANENT REGISTERS
	MOVSI P1,-DTEN		;NUMBER OF DTE'S
STODTE:	JE DTERL,(P1),NODTEH	;RUNNING?
	MOVEI A,0(P1)		;YES. GET DTE NUMBER
	CALL DTINTP		;GO DO POWER FAIL RECOVERY
NODTEH:	AOBJN P1,STODTE		;GO DO ALL OF THEM
	CHNON DLSCHN		;ALLOW INTS NOW
	OKSKD1			;TURN ON SCHEDULING IF NECESSARY
	RET			;AND DONE

;CODE TO RESTART THE DTE'S ONE SYSTEM RESTART.
;CALLED FROM SYSRST

DTERST::NOSKD1			;NO SCHEDULING PLEASE
	CHNOFF DLSCHN		;AND NO DTE INTS
	CALLRET STODT2		;GO DO THE WORK

;ROUTINE TO CHECK IF A GIVEN DTE IS RUNNING A PROTOCOL
;	A/ DTE NUMBER
;RETURNS:
;	+1 /NOT RUNNING A PROTOCOL
;	+2/RUNNING A PROTOCOL
	SWAPCD			;IS SWAPPABLE

CHKDTE::CAIL A,DTEN		;AN EXTANT DTE?
	RETBAD			;NO
	JE DTERL,(A),R		;IF NOT RUNNING A PROTOCOL FAIL
	RETSKP			;SUCCESS

;ROUTINES TO INIT INDIVIDUAL DTE DATA BASES. CALLED FROM DTEINI
;AS WELL AS FROM THE REBOOT CODE
;MAY RUN WITH INTS AND SCHEDULING ENABLED
;ACCEPTS	A/ DTE NUMBER
;		B/ PROTOCOL VERSION TO INIT IF ENTRY IS AT DTINIT
;IF ENTRY IS AT DTINTP, PROTOCOL WILL BE INITED TO PREVAILING TYPE
;ACCEPTS:	A/ DTE #
;		B/ PROTOCOL VERSION NUMBER FOR DTINIT ONLY
;DTINTP WILL INIT DTE TO THE PROTOCOL IN EFFECT BEFORE THE POWER FAIL

	RESCD			;MUST BE RESIDENT FOR RESTART

DTINTP:	SETO B,			;REMEMBER POWER RESTART ENTRY
DTINIT:	STKVAR <DTNUMB,PROVER>	;TO SAVE DTE NUMBER
	HRRZS A			;GET DTE NUMBER ONLY
	MOVEM B,PROVER		;SAVE PROTOCOL VERSION NUMBER
	SETZM DTESTS(A)		;CLEAR STATUS WORD
	SETZM DTEST1(A)		;AND THE OTHER ONE
	CALL DTREST		;GO RESET THIS DTE
	SKIPGE PROVER		;POWER RESTART ENTRY?
	JRST DTINP1		;YES.
	SETONE DT1TM,(A)	;NO. SAY HE NEEDS TIME THEN
DTINP1:	LSH A,SDTE		;TO FIND THE EPT REGION
	SETZM DTEEPW(A)		;FORCE SECONDARY PROTOCOL
	LSH A,-SDTE		;RESTORE A
	CALL SETRGN		;GO FIND THE REGIONS
	SUBI D,COMDAT		;POINT TO FIXED PART OF -11'S REGION
	MOVEI C,COMBAS		;GET -10'S FIXED REGION
	EXCH D,C		;REVERSE MEANINGS OF REGISTERS
	CAME A,MSTRDT		;IS THIS THE MASTER?
	JRST [	CALL DING11	;NO. JUST RING BELL
		JRST DTINI1]	;AND PROCEED WITH INIT
	SETZM DTEFLG		;CLEAR FLAG WORD
	MOVEI B,DTEEMP		;ENTER SECONDARY COMMAND
	MOVEM B,DTECMD		;TO THE COMMAND WORD
	CALL DING11		;GO DING HIM
	MOVEI B,MONPRO		;TIME TO ENTER PROTOCOL
	CALL NEWTIM		;GET TIME IN FUTURE
DTINI2:	SKIPN DTEFLG		;GOT IT YET?
	JRST [	CALL CHKTIM	;IS TIME UP YET?
		JRST DTINI2	;NO. GO WAIT SOME MORE
		CALL LOADFE	;(T1) YES, REQUEST LATER RELOAD
		RET]		;AND DONE
	;..

	;..
DTINI1:	MOVEM A,DTNUMB		;SAVE DTE NUMBER
	MOVEI A,1		;TENIND
	STOR A,CMTEN,(D)	;SAY FIRST BLOCK IS FOR A TEN
	SETZRO CMTEN,(C)	;HE IS NOT
	MOVEI A,CVERSN		;CURRENT COMMUNICATIONS VERSION
	STOR A,CMVER,(D)	;STORE IT
	STOR A,CMVER,(C)	;FOR THE -11 ALSO
	MOVEI A,PVERSN		;PROTOCOL VERSION
	STOR A,CPVER,(C)
	STOR A,CPVER,(D)	;STORE THIS AS WELL
	MOVEI A,2		;EACH -11 ADDRESSES TWO PROCESSORS
	STOR A,CMNPR,(C)
	MOVEI A,DTEN+1		;NUMBER OF PROCESSORS
	STOR A,CMNPR,(D)	;STORE THESE
	SKIPGE B,PROVER		;DOING INIT?
	JRST DTINI7		;NO.
	MOVEI A,COMSIZ/COMRGN	;INTEGRAL SIZE OF A REGION
	CAIE B,.VN20F		;RSX20F PROTOCOL?
	MOVEI A,2		;NO. MCB HEADER IS ALWAYS 2
	STOR A,CMSIZ,(C)
	MOVEI A,2		;HEADER IN 10'S AREA IS 2
	STOR A,CMSIZ,(D)	;REMEMBER THE SIZE
DTINI7:	MOVE A,DTNUMB		;GET DTE NUMBER
	AOS A			;GET OFFSET INDEX
	STOR A,CMNAM,(C)	;HIS NUMBER
	SETZRO CMNAM,(D)	;MY NUMBER IS ZERO
	MOVEI B,COMBAS		;FIRST REGION
	MOVEI A,4		;THIS INDICATES THAT TOPS-20 IS RUNNING
	STOR A,CMOPS,(C)	;FOR FRONT-ENDS INTERESTED IN SUCH THINGS
	STOR A,CMOPS,(D)	;. . .
DTINI3:	JE CMLNK,(B),[	SETZRO CMLNK,(C)
			SUBI C,COMBAS ;OFFSET FOR -11
			STOR C,CMLNK,(B) ;LINK IT IN TO ACTIVE LIST
			JRST DTINI4] ;AND DONE
	LOAD B,CMLNK,(B)	;GET THE LINK
	ADDI B,COMBAS		;MAKE IT ABSOLUTE
	CAME B,C		;IS THIS THE ONE WE WANT?
	JRST DTINI3		;NO, GO CHECK IT
	; ..

;DTINIT ...

;NOW INIT THE PER PROCESSOR REGION OF EACH COM REGION

DTINI4:	MOVE A,DTNUMB
	CALL SETRGN		;GO FIND REGIONS AGAIN
	EXCH C,D		;REVERSE REGS AGAIN
	SETZM CMCLR1(C)
	SETZM CMCLR2(C)		;CLEAR DYNAMIC WORDS IN -11'S REGION
	SETZM CMCLR1(D)
	SETZM CMCLR2(D)		;CLEAR TEN DYNAMIC WORDS
	MOVEI A,1		;TENIND WORD
	STOR A,CMPRO,(C)	;TELL -11 HE IS CONNECTED TO A -10
	STOR A,CMDTE,(C)
	STOR A,CMDTE,(D)	;A DTE CONNECTS THESE TWO
	STOR A,CMTST,(D)	;SET VALID EXAMINE
	STOR A,CMSZ,(C)
	STOR A,CMSZ,(D)		;TO THE REGIONS
	MOVE A,DTNUMB		;GET DTE NUMBER
	STOR A,CMDTN,(C)	;TO HIS REGION
	STOR A,CMDTN,(D)	;AND TO MINE
	AOS A			;INDEX
	STOR A,CMPNM,(D)	;HIS NAME
	SETZRO CMPNM,(C)	;AND MY NAME IN HIS REGION
	SETZRO CMPPT,(C)	;HIS POINTER TO ME
	SUBI C,COMBAS+COMDAT	;HIS RELATIVE OFFSET IN COMM REGION
	STOR C,CMPPT,(D)	;MAKE MY REGION POINT TO HIM
	ADDI C,COMBAS+COMDAT	;RESTORE POINTER
	SKIPGE B,PROVER		;NEED TO DO MORE INITING?
	JRST DTINI5		;NO. ALL DONE FOR NOW
	STOR B,CMVRR,(D)	;YES. STORE PROTOCOL VERSION NUMBER
	STOR B,CMVRR,(C)	; IN BOTH REGIONS
	CAIE B,.VN20F		;DOING RSX20F?
	JRST DTINI5		;NO. ALL DONE WITH COMM REGION
	MOVEI A,1		;YES. GET A ONE
	STOR A,CMQP,(D)		;USING THE QUEUED PROTOCOL
	STOR A,CMQP,(C)		;FOR HIS AS WELL
	; ..

;NOW SET UP THE EPT FOR THIS DTE/-11 AND DO THE PROTOCOL
;TRANSITION

DTINI5:	MOVEM D,PROVER		;SAVE COMM REGION POINTER
	MOVE D,DTNUMB		;GET DTE NUMBER
	LSH D,SDTE		;GET TO THE EPT OFFSET
	MOVEI A,COMBUF+DTEN-1	;HIS EXAMINE REGION
	SUB A,DTNUMB		;WHERE IT REALLY IS
	MOVEI B,IEXSIZ+2	;GET INITIAL EXAMINE SIZE
	ADD B,DTNUMB		;ADD IN DTE NUMBER
	MOVEM A,DTEERW(D)	;EXAMINE RELOCATION WORD
	SUBI C,COMDAT		;STORE DEPOSIT RELOCATION
	MOVEM C,DTEDRW(D)	;STORE DEPOSIT RELOCATION
	ADDI C,COMDAT		;GET BACK COMM REGION POINTER
	MOVEM B,DTEEPW(D)	;STORE EXAMINE PROTECTION WORD
	MOVEI B,COMSIZ		;SIZE OF A SINGLE REGION
	MOVEM B,DTEDPW(D)	;STORE AS THE DEPOSIT PROTECTION
	MOVE A,DTNUMB		;THE DTE NUMBER
	MOVE B,DTETRP(A)	;GET TRAP INSTRUCTION
	MOVEM B,DTEINT(D)	;TO THE EPT
	MOVE D,PROVER		;RESTORE COMM REGION POINTER
	LOAD B,CMVRR,(C)	;GET PROTOCOL VERSION TO USE
	JRST @.+1(B)		;DISPATCH TO APPROPRIATE PROTOCOL INIT FCN
	   IFIW ! DTINRS	;RSX20F
	   IFIW ! DTINMC	;MCB
	   IFIW ! DTIND6	;DN60 (IBM)

;HERE TO INIT RSX20F PROTOCOL FOR THIS DTE AND THIS -11

DTINRS:				;RSX20F protocol init fcn
	SETZM DTEIND(A)		;CLEAR ANY RESIDUAL INDIRECT INFO
	SKIPE DTBFWD(A)		;HAVE BUFFERS YET?
	JRST DTIN10		;YES. USE THEM THEN
	MOVE A,[.RESP1,,BUFSIZ*2] ;NO. GET SOME SPACE THEN
	MOVX B,<RS%SE0+.RESGP>	;FROM THE GENERAL POOL
	CALL ASGRES		;GET THE SPACE
	 JRST [	MOVE A,DTNUMB	;FAILED. GET BACK DTE NUMBER
		CAMN A,MSTRDT	;IS THIS THE MASTER?
		BUG.(HLT,NORSXF,DTESRV,SOFT,<Failed to get space for master DTE>,,<

Cause:	While attempting to initialize RSX20F protocol for the console
	front end, the call to ASGRES (assign resident free space) failed.

>)
		CALL LOADFE	;(T1) REQUEST JOB 0 RELOAD
		RET]		;AND DONE
	MOVE B,DTNUMB		;GOT IT. GET BACK DTE NUMBER
	HRLI A,BUFSIZ(A)	;FORM BUFFER WORD
	MOVEM A,DTBFWD(B)	;STORE IT
	MOVE A,B		;GET DTE NUMBER
DTIN10:	SETZM DTEFLG		;SET UP TO LEAVE MONITOR MODE
	MOVEI B,DTEEPP+1	;ENTER PRIMARY AND RESET COMM REGION
	MOVEM B,DTECMD		;THE COMMAND TO MONFE
	CALL DING11		;GO DING HIM
	CAME A,MSTRDT		;IS THIS THE MASTER?
	JRST DTINI6		;NO. SKIP PROTOCOL TRANSITION THEN
	MOVEI B,PRIPRO		;TIME TO DO IT
	CALL NEWTIM		;WHEN TIME IS UP
	SKIPN DTEFLG		;WAIT FOR THE 11 TO ACKNOWLEDGE
	JRST [	CALL CHKTIM	;TIME UP YET?
		JRST .-1	;NO. GO WAIT
		CALL LOADFE	;(T1) REQUEST JOB 0 RELOAD
		RET]		;AND DONE
	SETOM FEFLG		;PRIMARY PROTOCL NOW AVAILABLE
DTINI6:	CALL CLRBEL		;CLEAR OUT RESIDUAL DOORBELLS
	CALL DTEON		;TURN ON PROTOCOL

;NOW THAT THE PROTOCOL EXISTS, QUERY THE FRONT END ON THE STATE
;OF THE CTY

	CALL DTESKD		;START UP SCHEDULER IF NECESSARY
	PUSH P,A		;SAVE DTE NUMBER
	CALL LINFRQ		;GO GET THE LINE FREQUENCY
	CAIN A,^D60		;60 HZ?
	SETZ A,			;YES. REMEMBER AS A 0
	EXCH A,0(P)		;SAVE LINE FREQUENCY, RESTORE DTE NO
	SETZ C,			;DIRECT
	MOVE B,[.DFLCI,,.FEDLS]	;GIVE LINE COUNT
	MOVEI D,NTTFE-1		;THE NUMBER OF FE LINES
	SKIPE 0(P)		;60 HZ?
	TRO D,(1B2)		;NO. SET 50 HZ BIT
	POP P,0(P)		;CLEAN UP STACK
	CALL DTEQ		;DO IT
	 JFCL			;WILL GO
	RET			;AND DONE

;HERE TO INIT THE DTE AND THE -11 FOR MCB PROTOCOL. AT THIS POINT:
;	C/ POINTER TO -11'S COMM REGION
;	D/ POINTER TO -10'S COMM REGION
;	DTNUMB IS A STKVAR WITH THE DTE NUMBER IN IT
;	PROVER IS A STKVAR WITH THE PROTOCOL VERSION IN IT

DTINMC:	EA.ENT			;RUN IN EXTENDED SECTION
	SETONE <CMTST,CMINI>,(D) ;SET MY INI BIT
	MOVE B,CNDO(A)		;GET PROTOTYPE CONO
	IORI B,DTEPIE!DTEPI0	;TURN ON PI0 ONLY
	XCT B			; SO -11 CAN EXAMINE ITS REGION
	CALL DING11		;GO RING -11'S BELL
	MOVE B,[CONSO DTE0,DTETDB]
	LSH A,^D26		;POSOITION DTE NUMBER
	ADD B,A			;MAKE PROPER WORD
	MOVEM B,PROVER		;SAVE IT
	MOVE A,DTNUMB		;RESTORE DTE NUMBER
	MOVEI B,MCINI0		;TIMEOUT FOR FIRST PHASE
	CALL NEWTIM		;GET ABSOLUTE TIME
DTINM1:	XCT PROVER		;SEE A DOORBELL YET?
	JRST [	CALL CHKTIM	;TIME UP YET?
		JRST DTINM1	;NO. KEEP POLLING
		XCT PROVER	; DOORBELL YET ?
		JSP B,DTINM6	; NO DOORBELL YET !
		JRST .+1]	; DOORBELL CAME
	TMNN CMINI,(C)		;SEE IF IT DID IT RIGHT
	 JSP B,DTINM7		; BIT IS CLEAR--NO GOOD
	CALL CLRBEL		;CLEAR DOORBELL
	SETZRO CMINI,(D)	;CLEAR INI BIT
	CALL DING11		;RING 11'S BELL AGAIN
	MOVEI B,MCINI1		;TIME FOR THIS PHASE
	CALL NEWTIM		;ABSOLUTE TIME
DTINM2:	XCT PROVER		;SEE A BELL YET?
	JRST [	CALL CHKTIM	;NO. TIME UP YET?
		JRST DTINM2	;NO. KEEP POLLING
		XCT PROVER	; DOORBELL YET ?
		JSP B,DTINM6	; NO DOORBELL YET !
		JRST .+1]	; DOORBELL CAME
	TMNE CMINI,(C)		;MAKE SURE IT DID IT RIGHT
	 JSP B,DTINM7		;BIT IS SET--NO GOOD, REPORT THE PROBLEM

;ALLOCATE A BLOCK A SECTION ZERO FREE SPACE FOR INPUT AND OUTPUT.

	JN DTBOBL,(A),DTINM4	;IF WE ALREADY HAVE ONE, WE'RE OK
	MOVX A,<<UBLSIZ+3>/4>	;GET A BLOCK THIS BIG
	HRLI A,.RESP1		;USE THE HIGHEST PRIORITY (CAN'T SWAP)
	MOVX B,<RS%SE0+.RESNP>	;USE THE DECnet POOL - SECTION 0
	CALL ASGRES		;GET THE FREE SPACE
	 JSP B,DTINM8		;OOPS, COULDN'T ALLOCATE IT
	MOVE B,DTNUMB		;GET BACK THE DTE NUMBER
	STOR A,DTBOBL,(B)	;STORE THE OUTPUT BLOCK POINTER

DTINM4:	MOVE B,DTNUMB		;GET BACK THE DTE NUMBER
	JN DTBIBL,(B),DTINM5	;IF WE ALREADY HAVE INPUT BLOCK, WE'RE OK
	MOVX A,<<UBLSIZ+3>/4>	;GET A BLOCK THIS BIG
	HRLI A,.RESP1		;USE THE HIGHEST PRIORITY (CAN'T SWAP)
	MOVX B,<RS%SE0+.RESNP>	;USE THE NETWORK POOL - SECTION 0
	CALL ASGRES		;GET THE FREE SPACE
	 JSP B,DTINM8		;OOPS, COULDN'T ALLOCATE IT
	MOVE B,A		;GET POINTER TO INPUT BLOCK
	MOVE A,DTNUMB		;GET BACK DTE NUMBER
	STOR B,DTBIBL,(A)	;STORE THE INPUT BLOCK POINTER

;NOW SIGNAL DRIVER (ROUTER) OF NEW CIRCUIT BEING OPENED.

DTINM5:	MOVE A,DTNUMB		;GET THE DTE NUMBER BACK
	MOVE B,DCNCID(A)	;Get DECnet callback ID
	STOR B,DTBDID,(A)	;SAVE THE DRIVER'S BLOCK ID

	SETONE DTIPU,DTESTS(A)	;TELL ROUTER ABOUT PROTOCOL UP ON 1ST DOORBELL

	CALL DTEON		;GO TURN PROTOCOL ON
	CALLRET DTESKD		;AND START THE PROTOCOL

;INIT FAILED.  TIMED OUT WAITING FOR A DOORBELL

DTINM6:	MOVE A,DTNUMB		;GET DTE #, IN CASE WE FORGOT.

  IFN MCBDBG, <			;Buginf only if debugging
	BUG.(INF,DTEWAT,DTESRV,SOFT,<DTE MCB initialization timed out>,<<A,DTE>,<B,PC>>,<

Cause:	The KL timed out while waiting for the MCB to answer a doorbell during
	QP2 initialization.

Action:	Try again.  If it still doesn't work, check the MCB software.  Failing
	that, have Field Service check out the DTE.

Data:	A - DTE NUMBER.
	B - PC OF CALLER.
>,,<DB%NND>)			;[7.1210]
  > ;End of MCBDBG
DTINM9:	SETONE DTRLD,(A)	;SET RELOAD
	AOS LOAD11		;SAY AN -11 DIED
	SETZRO DTERL,(A)	;NO LONGER RUNNING A PROTOCOL
	CALLRET DTREST		;AND RESET THE DTE

;INIT FAILED DURING HANDSHAKE.  ONE OF:
;	1) HIS TO-ME BIT NOT SET
;	2) HIS TO-ME BIT NOT CLEAR
;    AT THE APPROPRIATE TIMES

DTINM7:	MOVE A,DTNUMB		;GET DTE #, IN CASE WE FORGOT.
	BUG.(INF,DTEBWS,DTESRV,SOFT,<DTE MCB handshake incorrect>,<<A,DTE>,<B,PC>>,<

Cause:	The KL detected that the MCB's init bit was not correct during a QP2
	protocol initialization handshake.

Action:	Try again.  If it still doesn't work, check the MCB software.  Failing
	that, have field service check out the DTE.

Data:	A - DTE number
	B - PC of caller
>)
	JRST DTINM9		;GO DO NORMAL CLEANUP

;INIT FAILED BECAUSE WE COULDN'T GET SECTION ZERO MEMORY FOR INPUT OR OUTPUT
;BUFFERS

DTINM8:	MOVE A,DTNUMB
	BUG.(CHK,DTECGB,DTESRV,SOFT,<DTE MCB initialization timed out>,<<A,DTE>,<B,PC>>,<

Cause:	Couldn't allocate memory for section zero input or output buffers.

Action:	Try again later.

Data:	DTE - DTE number
	PC - PC of caller
>,,<DB%NND>)			;[7.1210]
	JRST DTINM9			;CLEANUP THINGS

;TIMING ROUTINES USED BY PROTOCOL INIT CODE
;COMPUTE TIME IN FUTRURE.
;	B/ INCREMENT

NEWTIM:	PUSH P,A		;SAVE DTE #
	PUSH P,B		;SAVE INCREMENT
	CALL GETMST		;GET NOW
	POP P,B			;GET BAC INCREMENT
	ADD B,A			;TIME IN FUTURE
	POP P,A			;DTE #
	RET			;DONE

;CHECK IF TIME HAS ELAPSED.
;	B/ ABSOLUTE TIME
;RETURNS:	+1/ TIME NOT UP
;		+2 TIME UP

CHKTIM:	SAVEAC <A>		;SAVE DTE #
	PUSH P,B		;SAVE TIME
	CALL GETMST		;GET NOW
	POP P,B			;GET BACK TIME
	CAMLE B,A		;TIME UP?
	RET			;NO
	RETSKP			;YES
	SUBTTL DTE Interrupt Service

;DTE INTERRUPT SERVICE. THIS CODE IS ENTERED WHENEVER ANY FLAVOR
;OF DTE INTERRUPT IS GENERATED. THERE IS A SEPARATE ENTRY ROUTINE
;FOR EACH DTE.

;For each DTE there is an XPCW block called "DTXPC" followed by the
;unit number. The new PC for the DTE points to code that

;	1) Does JSR SVDTRJ, which comes here to SVDTAC
;	2) Stores double-word interrupt PC at DTETRA
;	3) Does CONI DTE into F
;	4) Jumps to INTDTE

;ROUTINE TO SAVE THE AC'S ON A DTE INTERRUPT
;Reached via JSR SVDTRJ at interrupt level

	RESCD			;MUST BE RESIDENT
SVDTAC::MOVEM P,DTEACB+P	;GET A WORK REGISTER
	MOVEI P,DTEACB		;BLT ARG
	BLT P,DTEACB+P-1	;SAVE REST OF ARGS
	MOVE P,DTESTK		;GET LOCAL STACK
	JRST @SVDTRJ		;RETURN TO INTERRUPT VECTOR

;DISMISS A DTE INTERRUPT

DTEDN1:	JUMPE P4,DTEDNE		;IF NO MORE, GO DISMISS
	MOVEI C,0(P4)		;PACKET SIZE
	MOVE A,DTEDTE		;GET DTE NUMBER
	JRST DOFNC3		;GO DO THIS FUNCTION
DTEDNE:	MOVSI P,DTEACB		;TO DO BLT
	BLT P,P-1		;DO ALL BUT P
	MOVE P,DTEACB+P		;RESTORE P
	XJEN DTETRA		;RESTORE STATE OF MACHINE

;INTERRUPT ON NON-EX OR RELOADING DTE. TURN OFF THE DTE

DTEPRG:	CALL DTREST		;GO RESET THIS DTE
	JRST DTEDNE		;AND GO DISMISS IT

;ROUTINE USED BY DTINIT TO TURN ON DTE PROTOCOL RACE FREE
;	A/ DTE #

DTEON:	NOSKD1			;AVOID RACES WITH SCHEDULER
	SETONE DTERL,(A)	;SAY NOW RUNNING A PROTOCOL
	CALL DTPII		;TURN ON DTE PI'S
	OKSKD1			;ALLOW SCHEDULING AGAIN
	RET			;AND DONE

;COMMON INTERRUPT ROUTINE. ENTERS WITH
;	A/ DTE NUMBER WHICH CAUSED INTERRUPT
;	P/ POINTS TO LOCAL DTE INTERRUPT STACK
;	F/ RESULT OF CONI DTEN,
;
;THIS ROUTINE PROCESSES ALL DTE INTERRUPTS

INTDTE::JE DTERL,(A),DTEPRG	;IF NON-EX, FORGET IT
	JN DTRLD,(A),DTEPRG	;IF RELOADING THE -11, FORGET THIS INTERRUPT
	TXNE F,DTEPF		;-11 LOST POWER?
	JRST POW11		;YES. GO DO SOMETHING ABOUT IT
	TXNE F,DTEEDN		;-11 DONE?
	JRST [	CALL TO11DN	;CALL AS A SUBROUTINE
		JRST DTEDNE]	;GO DISMISS THE INTERRUPT
	TXNE F,DTETDN		;TO 10 DONE?
	JRST TO10DN		;YES. GO MAKE SURE WE WERE TRANSFERRING
	TXNE F,DTETDB		;-10 DOORBELL INTERRUPT
	JRST DINGME		;YES. I WAS DINGED
	TXNE F,DTEEER		;TO -11 ERROR TERMINATION
	JRST TO11ER		;YES. GO TRY AGAIN THEN
	TXNE F,DTETER		;TO 10 ERROR?
	JRST TO10ER		;YES. BAD NEWS
	JRST DTEDNE		;GO DISMISS THE INTERRUPT


;Here when hardware bit indicates to -10 done. See if software agrees.

TO10DN:	STKVAR<OSTATE>		;WORD TO SAVE OLD STATE
	MOVEM A,DTEDTE		;SAVE DTE NUMBER
	MOVE B,CNDO(A)		;PROTOTYPE CONO
	IORI B,DTETDN		;SET TO CLEAR THIS BIT
	XCT B			;CLEAR IT
	LOAD B,DTEST,(A)	;GET STATUS OF THE DTE
	MOVEM B,OSTATE		;SAVE THE STATE
	TXZE B,DTET10!DTET1F	;RECEIVING ANY FLAVOR OF MESSAGE?
	JRST DODMSG		;YES. GO DO THE MESSAGE THEN
	BUG.(CHK,DTETIP,DTESRV,HARD,<DTETDN - TO-10 done received with no transfer in progress>,<<A,DTE>>,<

Cause:	The KL received indication from the DTE that a TO-10 trasnfer has
	completed but the DTE status did not indicate that a trasnfer was
	in progress.

Action:	If the problem persists, call Field Service.

Data:	DTE - DTE number
>,,<DB%NND>)			;[7.1210]
	JRST DTEDNE		;GO DISMISS THIS INTERRUPT

;PROCESS TO -10 DONE. FIRST DETERMINE WHICH PROTOCOL IS IN USE...

DODMSG:	STOR B,DTEST,(A)	;NEW STATUS
	CALL SETRGN		;GO GET COMM REGION POINTERS
	LOAD B,CMVRR,(C)	;GET PROTOCOL IN USE ON THIS DTE
	MOVE B,DN10VC(B)	;GET ADDRESS OF PROCESSING ROUTINE
	JRST 0(B)		;GO DO IT

;TRANSFER VECTOR FOR TO -10 DONE (BASED ON PROTOCOL TYPE)

DN10VC:	EXP DN10RS		;FOR RSX20F PROTOCOL
	EXP DN10MC		;FOR MCB PROTOCOL
	EXP DN10D6		;FOR DN60 PROTOCOL


;DN10RS - CODE TO PROCESS TO -10 DONE FOR RSX20F PROTOCOL
;AT THIS POINT:
;	A/ DTE NUMBER
;	C AND D POINT TO COMM REGIONS

DN10RS:	LOAD B,DTEBC,(A)	;GET RESIDUE COUNT
	SETZ P5,		;ASSUME NO HEADER ON MESSAGE
	JUMPN B,[ CALL DOFRGM	;START THIS FRAGMENT
		  JRST DODMS1]	;AND MERGE THE CODES
	SETZRO CMTOT,(C)	;CLEAR INTRANSIT BIT
	LOAD C,DTEB1,(A)	;GET COUNT OF COMPLETED REQUEST
	LOAD D,DTEBF,(A)	;THE BUFFER WE USED
DODMS1:	XCT [	HRRZ D,DTBFWD(A)
		HLRZ D,DTBFWD(A)](D) ;PICK UP THE BUFFER BASE ADDRESS
	HRLI D,(<POINT ^D8,0>)	;MAKE IT A BYTE POINTER
	JN INCNT,(A),[		;HAVE A RESIDUAL FUNCTION COUNT?
		LOAD P3,INCNT,(A) ;YES. GET IT
		JRST OLDFC2]	;GO DO IT
	;..

;GET THE FUNCTION AND DEVICE FROM THIS INITIAL FRAGMENT

DOFNC3:	SETO P5,		;PROCESSING HEADER
	CAIGE C,12		;VALID PACKET?
	JRST [	BUG.(CHK,DTEP2S,DTESRV,HARD,<TO10DN - Packet too small>,,<

Cause:	The packet size field in a TO10 packet from a DTE contains an
	invalid length.

Action:	If the problem persists, call Field Service.

>,,<DB%NND>)			;[7.1210]
		JRST DTEDNE]	;NO. IGNORE IT
	ILDB B,D		;SECOND BYTE
	ILDB P3,D		;GET COUNT
	LSH P3,10		;THE FIRST BYTE
	IORI P3,0(B)		;MAKE COUNT FIELD
	ILDB P1,D		;LAST EIGHT BITS OF THE FUNCTION
	ILDB B,D		;FIRST 8 BITS OF THE FUNCTION
	LSH B,10		;TO FORM FULL CODE
	IOR P1,B		;GET FUNCTION CODE
	PUSH P,P1		;SAVE CODE
	TRZ P1,1B20		;CLEAR INDIRECT BIT
	STOR P1,DT1FC,(A)	;SAVE IT
	ILDB P1,D		;GET DEVICE CODE
	ILDB B,D
	LSH B,10
	IOR P1,B		;FORM FULL DEVICE CODE
	STOR P1,DT1DV,(A)	;SAVE THIS
	REPEAT 2,<ILDB B,D>	;SKIP THE SPARE
	POP P,P1		;GET BACK FUNCTION
	TRZE P1,1B20		;INDIRECT?
	JRST [	SETONE DT1ID,(A) ;YES. REMEMBER THIS
		LOAD B,DTEST,(A) ;GET STATE
		CAIN C,12	;MUST BE TWO BYTES LEFT
		TXNE B,DTET10!DTET1F ;IS IT QUIET?
		JRST [	BUG.(CHK,DTEIDP,DTESRV,HARD,<Bad indirect packet>,<<A,DTENO>>,<

Cause:	An indirect packet from a DTE was received but the DTE status word
	indicated that there is no transfer active.

Data:	DTENO - DTE number
>,,<DB%NND>)			;[7.1210]
			JRST DINGER]
		ILDB B,D	;GET COUNT
		STOR B,INCNT,(A) ;SAVE THIS TOO
		ILDB B,D	;GET LINE
		STOR B,INUNT,(A); SAVE IT
		SETONE INVLD,(A); SAY UNIT IS VALID
		JRST DTEDNE]	;AND DONE WITH THE REQUEST
	SETZRO INVLD,(A)	;UNIT IN INDIRECT WORD IN INVALID
	;..

	;..
OLDFC2:	CAILE P3,0(C)		;FUNCTION FULLY WITHIN PACKET?
	JRST [	SETZ P4,	;NO. NO LOCAL RESIDUAL COUNT
		SUBI P3,0(C)	;FIND HOW MANY IN NEXT PACKET
		STOR P3,INCNT,(A) ;SAVE IT
		JRST OLDFC1]	;GO DO IT
	SETZRO INCNT,(A)	;NO NEXT RESIDUAL
	EXCH P3,C
	SUBI P3,0(C)		;FIND LOCAL RESIDUAL
	MOVEI P4,0(P3)		;NEXT FUNCTION IS HERE

;Transfer according to the function code provided in the data

OLDFC1:	SKIPE P5		;NEED TO REMOVE HEADER?
	SUBI C,10		;BYTES IN HEADER
	JUMPLE C,DTEDN1		;IF NO BYTES, WE ARE DONE
	LOAD B,DT1FC,(A)	;GET OPERATIVE FUNCTION CODE
	CAIL B,MINFNC		;LEGAL FUNCTION?
	CAILE B,MAXFNC		;STILL LEGAL?
	JRST [	BUG.(CHK,DTEIFR,DTESRV,HARD,<DTESRV - Illegal FNC request>,<<A,DTENO>>,<

Cause:	A packet from a DTE was received that contained an invalid function
	code.

Action:	If the problem persists, call Field Service.

Data:	DTENO - DTE number

>)
		JRST DINGER]	;NO. KILL THE FE THEN
	JRST @FNCTBL-MINFNC(B)	;YES. GO DO IT THEN

;Here when function code provided is not supported

NOOP:	BUG.(CHK,DTEUIF,DTESRV,HARD,<DTESRV - Unimplemented function from 11>,<<A,DTENO>>,<

Cause:	A packet from a DTE was received that contained a function code
	that is not supported by TOPS-20.

Data:	DTENO - DTE number

>)
	JRST DINGER		;AND ZAP THE FE


;Here on interrupt for to -10 done, for RSX20F protocol, and
;-11 has sent line characters.

TAKLC:	CALL TAKLC2		;CALL PROCESSING ROUTINE
	JRST DTEDN1		;ALL DONE

TAKLC2:	STKVAR <BYTC,BYTP,SAVOFS,SAVTYP>;-11 HAS SENT LINE CHARACTERS
	TRNE C,1		;AN EVEN NUMBER OF BYTES?
	BUG.(CHK,DTEODD,DTESRV,HARD,<TAKLC - Odd byte count for line characters>,,<

Cause:	A TO-10 transfer completion interrupt was recieved from the DTE
	under RSX20F protocol that indicates the -11 has sent line
	characters and the byte count is odd.

>)
	LOAD B,DT1DV,(A)	;GET DEVICE FOR THIS OPERATION
	MOVEM B,SAVTYP		;SAVE DEVICE TYPE
	CAIN B,.FECTY		;IS IT THE CTY?
	JRST [	SETZM SAVOFS
		JRST ISCTY]
	CAIE B,.FEDLS		;IS IT "TTY"?
	JRST [	BUG.(CHK,DTETTY,DTESRV,HARD,<Non-TTY device>,<<A,DTENO>>,<

Cause:	A TO-10 transfer completion interrupt from the DTE was recieved
	under RSX20F protocol that indicates the -11 has sent line
	characters, but the device type provided in the packet is not a
	TTY.

Data:	DTENO - DTE number

>)
		JRST DINGER]
	IMULI A,DTENL		;YES. GET LINE OFFSET
	MOVEM A,SAVOFS		;SAVE IT FOR LATER
ISCTY:	MOVEM C,BYTC		;SAVE COUNT OF BYTES
	MOVEM D,BYTP		;AND THE BYTE POINTER
TAKLC1:	SOS BYTC		;MUST BE AT LEAST TWO BYTES HERE
	MOVE D,BYTP		;JUST IN CASE
	SOSGE BYTC		;THIS MAKES TWO
	RET			;ALL DONE
	ILDB A,BYTP		;GET BYTE
	ILDB B,BYTP		;GET LINE NUMBER
	ADD B,SAVOFS		;MAKE IT A "REAL" LINE NUMBER
	MOVE C,SAVTYP		;TYPE
	CALL DTESTO		;STORE IN BIGBUF
	JRST TAKLC1		;DO ALL BYTES


;Here on interrupt for to -10 done, for RSX20F protocol, and
;-11 has sent string data. Transfer according to device type

TAKDS:	LOAD B,DT1DV,(A)	;GET THE DEVICE
	CAIL B,MINDEV		;A REASONABLE DEVICE?
	CAILE B,MAXDEV		;STILL?
	JRST DMPBFR		;NO. FLUSH THE REQUEST
	SKIPE P1,DTEDTV(B)	;A KNOWN DEVICE?
	SKIPN P1,DTVSD(P1)	;YES. THIS DEVICE HAVE STRING DATA?
	JRST DMPBFR		;NO. FORGET IT
	CALL GETUNT		;FIND APPROPRIATE UNIT NUMBER
	HRLI A,0(C)		;THE COUNT
	LOAD C,DT1DV,(A)	;GET THE DEVICE
	MOVSS A			;PUT ARGS IN PROPER ORDER
	CALL 0(P1)		;GO DO DEVICE STUFF
	JRST DTEDN1		;ALL DONE

;MORE FUNCTIONS,ETC.

;COMMON ROUTINE USED BY TAKDS AND TAKSTS TO FIND UNIT. MAY BE
;STASHED AWAY IN DTEIND IF PACKET IS INDIRECT OR IN CURRENT
;PACKET

GETUNT:	JN INVLD,(A),[
		LOAD B,INUNT,(A) ;GET IT FROM INDIRECT WORD
		RET]		;AND DONE
	ILDB B,D		;NOT INDIRECT. GET IT FROM CURRENT
	ILDB B,D		;IS THE SECOND BYTE
	SUBI C,2		;TWO FEWER BYTES
	RET			;AND DONE

;Here on interrupt for to -10 done, for RSX20F protocol, and
;-11 is providing time of day

TAKTOD:	CAIGE C,2		;AT LEAST TWO MORE BYTES?
	JRST DNTIME		;NO. MUST NOT BE A TIME THEN
	ILDB P1,D		;AND ANOTHER
	ILDB B,D		;GET ONE BYTE
	SUBI C,2		;TOOK TWO OF THEM
	JUMPE P1,DNTIME		;IF ZERO,NO TIME IN THE -11
	CAIGE C,10		;ENOUGH BYTES
	JRST [	BUG.(CHK,DTEDAT,DTESRV,HARD,<TAKTOD - Illegal format for time/date>,,<

Cause:	A TO-10 transfer completion interrupt from the DTE
	under RSX20F protocol that indicates the -11 is providing the time
	of day was recieved. The packet format is incorrect.

>)
		JRST DNTIME]	;DONT BELIEVE IT
	CALL GTTFLD		;GET YEAR FIELD
	HRLM P1,TAD11		;STORE YEAR
	ILDB P1,D		;MONTH
	HRRM P1,TAD11		;TO MEMORY
	ILDB P1,D		;DAY OF MONTH
	HRLM P1,TAD11+1		;TO MEMORY
	ILDB P1,D		;DAY OF WEEK
	HRRM P1,TAD11+1		;TO MEMORY
	MOVX C,IC%DSA!IC%UTZ	;IDCNV BITS
	ILDB P1,D		;GET DST FLAG & TIME ZONE
	TRZE P1,1B28		;DST FLAG ON?
	TXO C,IC%ADS		;YES - USE DST THEN
	STOR P1,IC%TMZ,C	;STORE TIME ZONE
	MOVEM C,TAD11+2		;TO MEMORY
	CALL GTTFLD		;GET SECONDS
	LSH P1,1		;*2
	HRRM P1,TAD11+2		;TO MEMORY
	JRST DTEDN1		;ALL FINISHED

DNTIME:	SETOM TAD11		;NONE GIVEN


DMPBFR:	JUMPLE C,DTEDN1
	IBP C,D			;ADJUST BYTE POINTER
	MOVE D,C		;MOVE IT TO CORRECT REGISTER
	JRST DTEDN1		;AND RETURN

GTTFLD:	ILDB P1,D		;GET NEXT TIME/DATE FIELD
	ILDB C,D		;IN 2 BYTES
	LSH P1,10		;SLIDE FIRST PART OVER
	IOR P1,C		;FORM -11 WORD
	RET			;AND RETURN

;Here on interrupt for to -10 done, for RSX20F protocol, and
;-11 wants to receive time of day

SNDTOD:	SETONE DT1TM,(A)	;SAY -11 WANTS TIME OF DAY
	JRST DMPBFR		;MAKE SURE ALL IS OK

;Here on interrupt for to -10 done, for RSX20F protocol, and
;LINE HUNG UP OR DIALED UP

HANGUP:	TDZA P1,P1		;CLEAR P1
DIALUP:	MOVEI P1,1		;DIAL UP
	CAIGE C,2		;ENOUGH BYTES LEFT?
	JRST [	BUG.(CHK,DTECAR,DTESRV,HARD,<Carrier FNC with no line number>,<<A,DTENO>>,<

Cause:	A TO-10 transfer completion interrupt from the DTE under RSX20F
	protocol that indicates a line has hung up or dailed up was
	received. The packet contains no line number due to a format
	error.

Action:	If problem persists, contact Field Service.

Data:	DTENO - DTE number

>)
		JRST DINGER]
	LOAD P3,DT1DV,(A)	;GET DEVICE
	IMULI A,DTENL		;BIAS THE LINE NUMBER
ALLLNE:	ILDB B,D		;GET LINE NUMBER
	ILDB P2,D		;THROW AWAY UPPER PART OF WORD
	PUSH P,A		;SAVE BASE LINE NUMBER
	ADDI B,0(A)		;LINE NUMBER IN B
	PUSH P,C
	PUSH P,D
	MOVEI A,0(P3)		;DEVICE CODE
	XCT [	CALL TTYHGU
		CALL TTYDLU](P1) ;CALL PROPER ROUTINE
	POP P,D
	POP P,C
	POP P,A			;GET BACK BASE LINE NUMBER
	SOS C			;DECREMENT COUNT
	SOJG C,ALLLNE		;DO ALL LINES
	JRST DTEDN1		;AND DONE


;Here on interrupt for to -10 done, for RSX20F protocol, and
;line buffers are empty

EMPTY:	CALL EMPTY2		;GO DO PROCESSING
	JRST DMPBFR		;ALL DONE. MAKE SURE BUFFERS ALIGN
EMPTY2:	STKVAR <CNTSV,DTESV,PTRSV>
	MOVEM A,DTESV
	MOVEM C,CNTSV
	MOVEM D,PTRSV
	LOAD D,DT1DV,(A)	;GET DEVICE -11 IS ACK-ING
	CAIL D,MINDEV		;A REASONABLE DEVICE?
	CAILE D,MAXDEV		;MAYBE, STILL SO?
	JRST LINEA1		;NO
	SKIPE P1,DTEDTV(D)	;A KNOWN DEVICE?
	SKIPN P1,DTVACK(P1)	;THIS DEVICE WANT AN ACK?
	JRST EMPTY3		;NO. SKIP THE PACKET
EMPTY1:	MOVE A,DTESV		;GET DTE
	LOAD A,DT1DV,(A)	;GET FUNCTION DEVICE
	ILDB B,PTRSV		;GET LINE NUMBER
	ILDB C,PTRSV		;THROW AWAY UPPER HALF
	CALL 0(P1)		;GO DO THE POST
	SOS CNTSV		;THE DUMMY BYTE
	SOSLE CNTSV		;MORE LINES?
	JRST EMPTY1		;YES
EMPTY3:	MOVE C,CNTSV		;GET COUNT
	MOVE D,PTRSV		;RESTORE BYTE POINTER
	RET			;END OF FUNCTION

;Here on interrupt for to -10 done, for RSX20F protocol, and
;11 sent line speed
;DONE ON -10 RELOAD

TAKSPD:	CAIGE C,6		;ENOUGH BYTES?
	JRST DMPBFR		;NO. IGNORE IT THEN
	SUBI C,5		;YES. WE WILL USE FIVE OF THEM
	PUSH P,C		;SAVE RESIDUE COUNT
	CALL GETUNT		;GO FIND UNIT NUMBER
	LOAD A,DT1DV,(A)	;PICK UP DEVICE FIELD
	CALL GTTFLD		;GET INPUT SPEED
	MOVSI P2,0(P1)		;SAVE IT
	CALL GTTFLD		;GET OUTPUT SPEED
	HRRI P2,0(P1)		;FORM SPEED WORD
	ILDB C,D		;GET REMOTE INDICATOR
	PUSH P,D		;SAVE BP
	MOVE D,P2		;ARG FOR TTYSRV
	CALL TTSPST		;GO SET IT UP
	POP P,D
	POP P,C			;RESTORE IMPORTANT PARAMETERS
	JRST DMPBFR		;AND DONE

;Here on interrupt for to -10 done, for RSX20F protocol, and
;-11 is sending its reload register information:

TAKRLW:	CAIGE C,2		;MUST BE A WORD OF INFORMATION
	JRST DMPBFR		;IGNORE IT
	ILDB B,D		;GET LOW 8 BITS
	ILDB P1,D		;GET HIGH 8 BITS
	LSH P1,10		;ADJUST IT
	IORI P1,0(B)		;FORM SWITCH WORD
	TRZ P1,(1B2)		;IGNORE RETRY BIT
	PUSH P,C
	PUSH P,D		;SAVE REGISTERS
	CALL SETRGN		;FIND REGIONS
	STOR P1,CMRLF,(C)	;SAVE IN MY REGION
	POP P,D			;RESTORE REGISTERS
	POP P,C
	SUBI C,2		;TOOK 2 BYTES
	JRST DMPBFR		;GO ALIGN BUFFERS

;Here on interrupt for to -10 done, for RSX20F protocol, and
;WANTTO ACK ALL UNITS OF ALL DEVICES
;Transfer according to device type

TAKACK:	MOVSI P1,MINDEV-MAXDEV+.FECTY
	HRRI P1,.FECTY+1	;START BEYOND THE CTY
	PUSH P,D		;SAVE SP
	PUSH P,C		;SAVE COUNTER
TKACK1:	SKIPE C,DTEDTV(P1)	;THIS DEVICE EXIST?
	SKIPN C,DTVACK(C)	;YES. WANT AN ACK?
	JRST TKACK2		;NO
	MOVE A,DTEDTE		;GET DTE FOR THIS FUNCTION
	SETO B,			;SAY TO ACK THEM ALL
	CALL 0(C)		;GO DO IT
TKACK2:	AOBJN P1,TKACK1		;GO DO ALL DEVICES
	POP P,C
	POP P,D
	MOVE A,DBUGSW		;GET RUNNING STATE
	CAIE A,0		;DEBUGGING SOME STUFF?
	JRST DMPBFR		;YEP. SKIP MESSAGE THEN
	AOS JB0FLG
	MOVEI A,1
	IORM 1,UPFLAG		;SAY WE NEED MESSAGE
	JRST DMPBFR		;GO ALIGN BUFFERS

;Here when we receive a packet of front-end disk serial numbers

FEDISK:	SETZ C,0		;[7154] START WITH UNIT 0
FEDLOP:	ILDB A,D		;GET THE HIGH ORDER PART OF THE SERIAL NUMBER
	ILDB B,D		;GET LOW ORDER PART
	LSH B,^D28		;SHIFT SO WE CAN MAKE FULL PACKET
	LSHC A,^D8		;MAKE ONE FULL WORD
	MOVEM A,FEDSKT(C)	;[7154] STORE IT IN THE TABLE
	CAIE C,FEDSKL-1		;[7154] LOOKED AT ALL UNITS?
	AOJA C,FEDLOP		;[7154] NO, NEXT UNIT
	CALL PHYFED		;[7154] () YES, SET THE UDBS
	SETOM FESER		;TELL PHYSIO ALL SERIAL NUMBERS HAVE ARRIVED
	JRST DTEDNE		;AND DONE

;Here on interrupt for to -10 done, for RSX20F protocol, and
;-11 is sending KLINIK data

TAKKLI:	CAILE C,KLIMAX		;WILL IT FIT?
	JRST [	BUG.(CHK,KLIOVF,DTESRV,HARD,<DTESRV - KLINIK data base too large>,<<C,PAKSIZ>>,<

Cause:	A TO-10 transfer completion interrupt from the DTE under RSX20F
	protocol was recieved that indicates the -11 is sending KLINIK
	data but the size of the data field is out of range.

Action:	Contact Field Service if the problem persists.

Data:	PAKSIZ - Size of KLINIK data field in packet

>)
		JRST DTEDNE]	;AND IGNORE DATA
	MOVEM C,KLIDTA		;SAVE COUNT
	MOVE A,[POINT ^D8,KLIDTA+1] ;GET POINTER TO BUFFER
TAKKL1:	ILDB B,D		;GET NEXT BYTE
	IDPB B,A		;SAVE IT
	SOJG C,TAKKL1		;MOVE ALL BYTES
	JRST DTEDNE		;AND DONE

;Here on interrupt for to -10 done, for RSX20F protocol, and
;-11 is ending line allocation information

LINEAL:	CALL LINEA2		;GO DO PROCESSING
	JRST DMPBFR		;ALL DONE. MAKE SURE BUFFERS ALIGN

LINEA2:	STKVAR <CNTSV,DTESV,PTRSV>
	MOVEM C,CNTSV		;SAVE COUNT
	MOVEM A,DTESV		;SAVE DTE #
	MOVEM D,PTRSV		;SAVE POINTER
	LOAD D,DT1DV,(A)	;GET DEVICE CODE
	CAIG D,MAXDEV		;A KNOWN DEVICE?
	CAIGE D,MINDEV		;?
LINEA1:	JRST [	BUG.(CHK,DTEDEV,DTESRV,HARD,<Illegal device>,<<A,DTENO>>,<

Cause:	A TO-10 transfer completion interrupt from the DTE under RSX20F
	protocol that indicates the -11 is ending line allocation
	information was recieved. The device code provided is out of
	range.

Action:	If the problem persists, contact Field Service

Data:	DTENO - DTE number

>)
		JRST DINGER]	;ERROR
	SKIPE P1,DTEDTV(D)	;A KNOWN DEVICE?
	SKIPN P1,DTVTLA(P1)	;YES. CAN SET LINE ALLOCATION?
	JRST EMPTY3		;NO. GIVE IT UP
	CALLRET EMPTY1		;GO DO COMMON PROCESSING

;Here on interrupt for to -10 done, for RSX20F protocol, and
;-11 IS SENDING ID OF THE CTY

TAKCTY:	ILDB B,D		;GET LINE NUMBER
	CALL IDCTY		;IDENTIFY IT TO TELETYPE SERVICE
	SUBI C,1		;TOOK ONE BYTE
	JRST DMPBFR		;GO ALIGN BUFFERS


;Here on interrupt for to -10 done, for RSX20F protocol, and
;-11 is sending error information
;Transfer according to device type

TAKSTD:	CALL GETUNT		;GET THE UNIT
	STOR B,INUNT,(A)	;SAVE UNIT FOR SYSERR
	JN DTSTI,(A),[	SETZRO DTSTI,(A) ;CLEAR SPLIT INDICATOR
			MOVE B,D ;MOVE POINTER
			JRST TAKSTF]	;AND GO
	LOAD A,DT1DV,(A)	;GET DEVICE
	CAIL A,MINDEV		;A REASONABLE DEVICE?
	CAILE A,MAXDEV		;STILL?
TAKSTE:	JRST SEEERR		;UNKNOWN, SEE IF SYSERR REQUESTED
	SKIPE A,DTEDTV(A)	;A KNOWN DEVICE?
	SKIPN A,DTVTLS(A)	;YES. WANT DEVICE STATUS?
	JRST TAKSTE		;NO
	PUSH P,C		;SAVE COUNT
	PUSH P,D		;AND STRING POINTER
	CALL 0(A)		;DISPATCH OFF
	POP P,D			;RESTORE POINTER
	POP P,C			;AND COUNT
SEEERR:	ILDB B,D		;GET SOFTWARE STATUS
	ILDB B,D		;LOW 8 BITS
	SUBI C,2		;COUNT DOWN THOSE BYTES
	TXNN B,.DVFLG		;ERROR LOGGING REQUESTED?
	JRST DMPBFR		;GO ALIGN BUFFERS
	;..

;CODE TO MAKE FIRST PASS AT SYSERR ENTRY. THIS CODE WILL QUEUE
;UP ALL OF THE DEVICE DEPENDENT ERROR DATA, AND WILL STORE
;THE DEVICE CODE AND THE WORD COUNT OF THE ERROR DATA. IT WILL
;ALSO SCHEDULE A JOB 0 SUBROUTINE TO COMPLETE THE BLOCK

	;..
	ADDI C,2		;GET BACK THE SOFTWARE STATUS
	MOVNI B,2		;NUMBER OF BYTES TO RECOVER
	IBP B,D			;ADJUST THE BYTE POINTER
TAKSTF:	PUSH P,C		;SAVE BYTE COUNT
	PUSH P,B		;SAVE BYTE POINTER
	ADDI C,3		;CALCULATE WORDS IN ERROR REPORT
	LSH C,-2		;""
	PUSH P,C		;SAVE WORD COUNT
	MOVEI A,FE%LEN(C)	;WORDS TO ALLOCATE
	MOVEI B,FE%SIZ(C)	;SIZE OF HEADER
	EA.ENT			;EXTENDED FOR SYSERR
	CALL ALCSBX		;GET THEM
	 JRST	[S0.ENT		;***WARNING*** REMOVE THIS IF MADE EXTENDED
	 	JRST SEEER1]	;NONE THERE. PUNT
	MOVE B,DTEDTE		;GET DTE NUMBER
	MOVEM B,FE%DTE+SEBDAT(A) ;SAVE DTE NUMBER IN THE PACKET
	LOAD C,INUNT,(B)	;GET UNIT
	LOAD B,DT1DV,(B)	;GET DEVICE CODE
	HRLI B,0(C)		;MOVE UNIT TO LH
	MOVEM B,FE%DEV+SEBDAT(A);SAVE DEVICE CODE
	POP P,C			;WORD COUNT FOR ERROR STUFF
	MOVNI D,0(C)
	HRLM D,FE%PTR+SEBDAT(A)	;SAVE COUNT OF WORDS
	POP P,D			;GET DATA STRING
	POP P,C			;AND BYTE COUNT
	MOVE B,[POINT ^D8,FE%INF+SEBDAT(A)] ;POINTER
	MOVEM C,FE%BYT+SEBDAT(A) ;STORE # OF -11 BYTES
SEEER3:	ILDB P1,D		;ERROR BYTE
	IDPB P1,B		;SAVE IT
	SOJG C,SEEER3		;DO ALL BYTES

	MOVE B,[-2,,[		;INSERT EVENT CODE AND RECALL
		SEBPTR 0,SBTEVC,SEC%FE ;EVENT CODE
		SEBPTR 0,SBTFNA,SEEER2]] ;RECALL
	MOVE P1,D		;SAVE SP
	MOVE P2,A		;SAVE POINTER
	CALL SEBCPY		;DO COPY
	 JFCL
	MOVE A,P2		;GET BACK POINTER
	CALL QUESEB		;NOW QUEUE IT UP
	S0.ENT			;***WARNING*** REMOVE THIS IF MADE EXTENDED
	MOVE D,P1
	CALL CHKFRG		;SEE IF MORE TO COME
	JRST DTEDN1		;ALL DONE

SEEER1:	POP P,0(P)		;CLEAN UP STACK
	POP P,D			;SP
	POP P,C			;BYTE COUNT
	CALL CHKFRG		;SEE IF MORE TO DO
	JRST DMPBFR		;GO ALIGN BUFFERS

;CODE TO PROCESS TO -10 DONE FROM AN MCB FRONT END TRANSFER
;	A/ DTE NUMBER
;	C AND D POINT TO COMM REGIONS

DN10MC: EA.ENT			;DECNET RUNS IN EXTENDED SECTIONS
	STKVAR <DTENO>		;PLACE TO SAVE DTE NUMBER
	MOVEM A,DTENO		;SAVE DTE NUMBER FOR LATER
	SETZRO CMTOT, (C)	; clear in transit flag
	JN DTEBC,(A),DTEDNE	;IF MORE TO DO, GO WAIT.

	MOVE B,DTEIND(A)	;GET THE MESSAGE BLOCK POINTER
	LOAD A,DTBIBL,(A)	;POINT TO THE INPUT SECTION ZERO BLOCK
	CALL CPYWDS		;COPY THE INPUT TO THE MSG BLOCK

	MOVX B,DI.INC		;INPUT DONE INTERRUPT
	MOVE A,DTENO		;GET BACK THE DTE NUMBER
	SETZ C,
	EXCH C,DTEIND(A)	;GET THE POINTER TO THE MSG BLOCK
	CALL CALDVR		;CALL DRIVER (ROUTER)
	JRST DTEDNE		;AND DONE

;HERE TO COPY DATA FROM INPUT BLOCK TO MESSAGE BLOCK
; CALLED WITH A/ SECTION ZERO BLOCK
;	      B/ MESSAGE BLOCK TO COPY TO

CPYWDS:	XMOVEI B,UD.MSD(B)	;POINT TO THE "INPUT" MSD
	LOAD C,MDBYT,(B)	; AND USE THAT AS THE BYTE COUNT
	ADDI C,3		;ROUND THE COUNT UP
	LSH C,-2
	LOAD B,MDALA,(B)	;GET THE ALLOCATED ADDRESS
	XCALLRET (XCDSEC,DNCPYW) ;COPY THE WORDS TOGETHER

; -11 REQUESTED RELOAD OR INIT
DINGDY:	MOVE B,$CMINI(D)	;GET WORD FROM -11'S REGION
	LOAD C,CMVRR,(C)	;Get protocol version
	SKIPN DTBUGX		; Skip this if we aren't interested
	CAIE C,MCPRON		;If DECnet, no buginf
	 BUG.(INF,DTESUI,DTESRV,SOFT,<Front end requested reload or init>,<<A,DTE>,<B,STATUS>>,<

Cause:	An -11 has requested a reload or init but the enabled
	protocol for this DTE is not DECnet.

Data:	DTE - DTE number.
	STATUS - Status word from -11's comm region
>,,<DB%NND>)			;[7.1210]
	JRST DINGER

;COLLECTION OF ROUTINES TO DO ERROR PROCESSING.

;Here on interrupt, when CONI bit DTEEER indicates to -11 error

TO11ER:

;Here on interrupt, when CONI bit DTETER indicates to -10 error

TO10ER:	BUG.(CHK,DTEERR,DTESRV,HARD,<DTESRV - DTE device error>,<<A,DTENO>,<F,STATUS>>,<

Cause:	A packet has been received from a DTE that has a flag lit
	indicating a TO -10 or TO -11 error.

Action:	Contact Field Service

Data:	DTENO - DTE number
	STATUS - Result of CONI DTEN,
>,,<DB%NND>)			;[7.1210]
	JRST DINGER		;GO RELOAD THE MACHINE

;Here on interrupt, when CONI bit DTEPF indicates power failure

POW11:	CALL DTEPF1		;TELL -11 ABOUT THE POWER FAIL
	JRST DTEPRG		;GO SHUT OFF THIS -11



;ROUTINE TO REQUEST A RELOAD OF THIS MACHINE

LOADME::MOVE A,MSTRDT		;THE MASTER -11
	CALL SETRGN		;GO FIND REGIONS
	SETONE CML11,(C)	;SET MY RELOAD INDICATOR
	CALLRET DING11		;GO TELL HIM TO DO IT

;ROUTINE CALLED FROM SCHED TO TELL MASTER -11 ABOUT A POWER FAIL
;INTERRUPT

DTEPWF::MOVE A,MSTRDT		;GET MASTER -11
DTEPF1:	CALL SETRGN		;FIND COMM REGIONS
	SETONE CMPWF,(C)	;SET OUR POWER-FAIL INDICATOR
	CALLRET DING11		;AND TELL THE -11

;ROUTINE TO SEE IF STATUS PACKKET WAS FRAGMENTED

CHKFRG:	MOVE A,DTEDTE		;GET DTE NUMBER
	MOVE B,DTESTS(A)	;GET STATUS
	TXNN B,DTET10!DTET1F	;NOW ACTIVE?
	RET			;NO
	SETONE DTSTI,(A)	;REMEMBER NEXT PART TO DO LOGGING
	RET			;AND DONE

;Here on interrupt, when CONI DTE bit DTETDB indicates doorbell.
;Most likely cause is that the -11 wants to start a to -10 transfer.

;-10 HAS RECEIVED A TO 10 DOORBELL. MUST FIGURE OUT WHAT THE -11
;WANTS AND HOW TO DO IT

DINGME:	CALL SETRGN		;GO FIND THE COMM REGIONS
	JN <CMINI,CML11>,(D),DINGDY ;WANT RELOAD OR REINIT?
DINGM1:	LOAD B,CMVRR,(C)	;GET PROTOCOL TYPE
	CAIE B,.VN20F		;IS THIS THE RSX20F FRONT END?
	JRST DINGM2		;NO. DON'T CHECK FOR INDIRECT THEN
	JN DT1ID,(A),INDRCT	;YES, COMPLETING AN INDIRECT?
DINGM2:	LOAD P1,CM0IC,(C)	;MY TO 10 COUNTER
	LOAD P2,CM0IC,(D)	;HIS TO 10 COUNTER
	CAMN P2,P1		;DIFFERENT?
	JRST [	CALL CLRBEL	;CLEAR BELL
		JRST DTEDNE]	;GO AWAY
	CAIE P2,1(P1)		;WITHIN ONE OF ME?
	JRST [	CAIN P2,0	;DID HIS WRAP AROUND?
		CAIE P1,377	;YES. IS MINE AT MAX VALUE?
		JRST DINGM3	;NO. ERROR
		JRST .+1]	;YES. ALL IS WELL
	STOR P2,CM0IC,(C)	;MAKE COUNTS THE SAME
INDRC1:	MOVX B,DTET10!DTET1F	;TO 10 BITS
	TDNE B,DTESTS(A)	;IS THERE A TO 10 GOING?
	JRST DINGM4		;YES. ERROR
	SETONE CMTOT,(C)	;SET IN TRANSIT BIT
	CALL CLRBEL		;CLEAR DOORBELL
	LOAD B,CMQCT,(D)	;GET QUEUE COUNT
	SKIPG B			;IS IT A VALID COUNT
	JRST DINGM5		;NO. ERROR
	CALL DOFRGM		;START TRANSFER IN PROPER PROTOCOL
	JRST DTEDNE		;AND DONE

;COMPLETING AN INDIRECT FOR RSX20F PROTOCOL ONLY

INDRCT:	JE CMIP,(D),[
		LOAD P1,CM0IC,(C) ;MY TO 10 COUNT
		LOAD P2,CM0IC,(D) ;HIS TO 10 COUNT
		CAIE P1,0(P2)	;COUNTS THE SAME?
		JRST DINGM6	;NO. ERROR
		CALL CLRBEL	;YES. CLEAR EXTRANEOUS BELL
		JRST DTEDNE]	;GO DISMISS THE INTERRUPT
	SETZRO DT1ID,(A)	;CLEAR EXPECTING INDIRECT
	LOAD B,INCNT,(A)	;GET COUNT FROM HEADER
	OPSTR <CAME B,>,CMQCT,(D) ;SAME AS DATA NOW BEING SENT?
	JRST [	BUG.(INF,INDCNT,DTESRV,HARD,<DTESRV - Bad indirect count>,<<A,DTENO>>,<

Cause:	The DTE was attempting to complete an indirect but the count in
	the data being sent does not match the count in the indirect
	packet.

Data:	DTENO - DTE number.

>,,<DB%NND>)			;[7.1210]
		JRST DINGER]	;AND DO A RELOAD
	JRST INDRC1		;GO DO THE REQUEST

;ERROR ROUTINES FOR DOORBELL SERVICE

DINGER:	SKIPE FEDBSW		;YES. WANT TO SUPPRESS RELOADS?
	JRST DTEDNE		;YES. IGNORE CONDITION
	CAME A,MSTRDT		;IS THIS THE MASTER?
	CALL [	CALL DTREST 	;NO. CLEAR IT
		SETZRO DTERL,(A) ;AND SAY NOT RUNNING A PROTOCOL
		CALLRET CLRDTE] ;AND DONE
	CALL LOADFE		;(T1) REQUEST JOB 0 RELOAD
	JRST DTEDNE		;AND GO DISMISS INTERRUPT

;TO -10 COUNTS ARE WRONG

DINGM3:	BUG.(INF,DTECDM,DTESRV,HARD,<DTESRV - TO-10 counts do not match>,<<A,DTNENO>>,<

Cause:	TOPS-20 received a doorbell interrupt from the DTE but the TO-10
	counter in the front end does match the counter kept by TOPS-20.

Action:	TOPS-20 is reloading the FE.

Data:	DTENO - DTE number
>)
	JRST DINGER		;AND GO RELOAD

;TO -10 REQUEST FROM FE WHILE ONE IS IN PROGRESS

DINGM4:	BUG.(INF,DTEDIN,DTESRV,HARD,<DTESRV - TO-10 in progress on doorbell>,<<A,DTENO>>,<

Cause:	The 10 received a doorbell from the 11, but a TO -10 transfer was
	already in progress.

Data:	DTENO - DTE number

>)
	JRST DINGER

;INVALID Q COUNT FROM -11

DINGM5:	BUG.(INF,DTEDME,DTESRV,HARD,<DTESRV - Zero queue count>,<<A,DTENO>>,<

Cause:	A transfer from the 11 to the 10 is about to be started, but the
	count of free bytes in the transfer queue is zero.

Action:	Examine the DTE to see if it has hardware problems.

Data:	DTENO - DTE number

>)
	JRST DINGER

;INCORRECT INDIRECT SET UP FROM FE

DINGM6:	BUG.(INF,DTEPNR,DTESRV,HARD,<DTESRV - Incorrect indirect setup>,<<A,DTENO>>,<

Cause:	While trying to complete an indirect from an RSX20F FE the
	TO -10 count provided by RSX did not match the count kept by
	TOPS-20.

Data:	DTENO - DTE number

>)
	JRST DINGER

;ROUTINE TO PROCESS A TO 11 DONE INTERRUPT

TO11DN:	MOVE B,CNDO(A)		;CONO WORD
	IORI B,DTEEDN		;TO CLEAR 11 DONE
	XCT B			;CLEAR THE BIT
	CALL SETRGN
	LOAD B,CMVRR,(C)	;GET PROTOCOL IN USE
	MOVE B,DN11TR(B)	;GET ROUTINE TO PROCESS THIS
	JRST 0(B)		;GO TO IT

;PROCESS RSX20F TO -11 DONE

DN11X:	LOAD B,DTEST,(A)	;GET STATE OF DTE
	TXZE B,DTE11		;DOING TO 11?
	JRST DN11		;YES. GO HANDLE IT
	TXZE B,DTE11I		;DOING INDIRECT?
	JRST DN11I		;YES
	RET			;ALL DONE

DN11I:	TXO B,DTE11		;DOING REGULAR 11
	STOR B,DTEST,(A)	;NEW STATE
	HRRZ B,DTEQS(A)		;GET QUEUE PACKET
	LOAD D,QCNT,(B)		;GET BYTE SIZE
	CAILE D,MAXINP		;TOO BIG FOR PROTOCOL?
	MOVEI D,MAXINP		;YES. FRAGMENT IT THEN
	STOR D,CMQCT,(C)	;TO MY REGION
	LSH A,SDTE			;*4
	JN QMODE,(B),[		;FORCE BYTE MODE?
		LOAD B,QPNTR,(B) ;YES. GET BYTE POINTER
		JRST NOTWRD]	;AND GO DO IT
	LOAD B,QPNTR,(B)		;GET BYTE POINTER
	TLNN B,100000		;EVEN # OF BYTES IN FIRST WORD?
	TRNE D,1		;YES. EVEN # OF BYTES IN MESSAGE?
	JRST NOTWRD		;NO. SEND IN BYTE MODE THEN
	LDB D,[POINT 6,B,11]	;GET BYTE SIZE
	CAIN D,10		;8 BITS?
	JRST [	MOVEI D,^D16	;YES. DO IT FULL WORD THEN
		DPB D,[POINT 6,B,11]
		SETONE CMFWD,(C) ;TELL -11 IT IS FULL WORD
		JRST .+1]
NOTWRD:	MOVEM B,DTEEBP(A)	;SET UP BYTE POINTER
	LSH A,-SDTE		;RESTORE A
	SETONE CMIP,(C)		;TELL -11 ALL IS OKAY
	CALL DING11		;GO DING -11
	RET			;ALL DONE

DN11:	STOR B,DTEST,(A)	;NEW STATE
	SETZRO CMIP,(C)		;NOT DOING INDIRECT ANYMORE
	HRRZ B,DTEQS(A)		;DEQUEUE THE PACKET
	CALL TSTSGL		;IS THIS A SINGLE PACKET GROUP?
	JRST DNSNGL		;YES. GO DO SPECIAL POSTING
	LOAD D,QCNT,(B)		;SEE IF IT WAS INDIRECT
	JUMPE D,DEQDTE		;NO. GO ON TO THE DEQUEUE LOGIC
	CAIG D,MAXINP		;YES. DID WE SEND IT ALL?
	JRST DEQDTE		;YES. GO ON

;INDIRECT REQUEST MUST BE PARTITIONED. DO NEXT PART

	SUBI D,MAXINP		;SAY SENT ONE SECTION
	STOR D,QCNT,(B)		;ABD STASH AWAY NEW COUNT
	MOVEI D,MAXINP		;COUNT OF BYTES SENT
	LOAD C,QPNTR,(B)	;GET BYTE POINTER
	IBP D,C			;ADJUST IT
	STOR D,QPNTR,(B)	;NEW BYTE POINTER
	CALL DTESKD		;GO DO NEXT PART
	RET			;AND DONE

;DEQUEUE COMPLETED REQUEST,POST IT, AND SCHEDULE NEXT REQUEST

DEQDTE:	LOAD C,QLINK,(B)	;GET NEXT GUY
	HRRM C,DTEQS(A)		;NEW HEAD
	SKIPN C			;HAVE A HEAD?
	SETZM DTEQS(A)		;NO. CLEAR THE WORD
	LOAD C,QINT,(B)		;INTERRUPT GUY
	PUSH P,C		;SAVE INTERRUPT
	LOAD C,QDEV,(B)		;DEVICE CODE
	PUSH P,C		;SAVE IT
	LOAD C,QCOD,(B)		;UNIQUE CODE
	PUSH P,C		;SAVE THIS AS WELL
	LOAD C,QLIN,(B)		;UNIT
	PUSH P,C		;SAVE IT
	MOVE C,A
	LSH C,SDTE		;FIND EPT OFFSET FOR THIS DTE
	SETZM DTEEBP(C)		;CLEAR TO -11 POINTER
	CALL RELNOD		;FREE THE NODE - RELNOD (A,B)
MSTSKD:	OPSTR <SKIPE>,DTERL,(A)	;MAKE SURE DTE IS ACTIVE
	CALL DTESKD		;START DTE AGAIN
	POP P,B			;UNIT
	POP P,A			;CODE
	POP P,C			;DEVICE CODE
	POP P,D			;ADDRESS
	SKIPE D			;HAVE ONE?
	CALL 0(D)		;YES. GO HANDLE IT
	RET			;ALL DONE

;TRANSFER VECTOR FOR TO -11 DONE

DN11TR:	DN11X			;RSX20F PROTOCOL
	DN11MC			;MCB PROTOCOL
	DN1160			;DN60 protocol

;ROUTINE TO POST A SINGLE CHARACTER DONE

DNSNGL:	LDB P1,[POINT 6,0(B),17] ;GET COUNT OF ENTRIES
	LOAD C,QLINK,(B)	;GET Q LINK
	HRRM C,DTEQS(A)		;NEW HEADER
	SKIPN C			;Q NOW EMPTY?
	SETZM DTEQS(A)		;YES
	SETZM 0(B)		;CLEAR ALL FLAGS
	MOVEI P2,SNGHDR(B)	;FIRST CHARACTER
	CALL DTESKD		;REACTIVATE THE DTE
	HRLI P2,(POINT ^D16,)	;MAKE A BYTE POINTER
SNGPST:	ILDB B,P2		;GET AN ENTRY
	LSH B,-^D8		;LINE NUMBER ONLY
	SETZ A,			;NO CODE
	MOVEI C,.FEDLS		;THE DSL
	CALL TTYINT		;GO DO THE POST
	SOJG P1,SNGPST		;DO ALL
	RET			;AND DONE

;TEST IF PACKET POINTED TO BY B IS A SINGLE PACKET GROUP.
;INPUT B/ POINTER
;RETURNS: +1 IS A SINGLE GROUP
;	+2 IS NOT

TSTSGL:	MOVE D,0(B)		;GET FLAGS
	TLNE D,(1B0)		;IS IT?
	TLNN D,(1B1)		;MAYVE
	RETSKP			;NO
	RET			;YES

;ROUTINE TO PROCESS A TO -11 DONE FOR A FE RUNNING DN60 PROTOCOL

DN1160:	EA.ENT
	SAVEQ			;GET WORK REGS
	HRRZ B,DTEQS(A)		;GET PACKET WE JUST COMPLETED
	LOAD Q1,DTEST,(A)	;GET CURRENT STATE OF THE DTE
	TXZN Q1,DTE11		;DONE WITH DATA TRANSFER?
	RET			;NO. IGNORE THE INTERRUPT THEN
	STOR Q1,DTEST,(A)	;YES. SAVE NEW STATE
	JRST DEQDTE		;AND GO FINISH UP THIS REQUEST

;ROUTINE TO PROCESS A TO -11 DONE FOR A FE RUNNING MCB PROTOCOL

DN11MC:	EA.ENT
	SAVEQ			;GET WORK REGS
	HRRZ B,DTEQS(A)		;GET PACKET WE JUST COMPLETED
   IFN FTPARANOID,<
	LOAD D,QCOD,(B)		;Get address of message block
	XMOVEI CX,.		;Touch 
	STOR CX,NMMAG,(D)	; it.
   >;END IFN FTPARANOID
	LOAD Q1,DTEST,(A)	;GET CURRENT STATE OF THE DTE
	TXZN Q1,DTE11		;DONE WITH DATA TRANSFER?
	RET			;NO. IGNORE THE INTERRUPT THEN
   IFN FTPARANOID,<
	XMOVEI CX,.		;Touch 
	STOR CX,NMMAG,(D)	; message block
   >;END IFN FTPARANOID
	STOR Q1,DTEST,(A)	;YES. SAVE NEW STATE
	JRST DEQDTE		;AND GO FINISH UP THIS REQUEST

;HERE TO POST OUTPUT COMPLETES BACK TO THE DRIVER (ROUTER, ETC.).

DNPOST:	EA.ENT			;DECNET AND ALL OTHER USERS OF THE
				;INTERFACE RUN IN SECTION MUMBLE
	EXCH A,C		;EXCH QDEV AND QCOD (WHICH ARE DTE#
				; AND MSG BLOCK POINTER RESPECTIVELY)
	MOVX B,DI.ODN		;INTERRUPT TYPE WILL BE OUTPUT DONE
	CALLRET CALDVR		;POST IT TO ROUTER

	SUBTTL Start of to -10 transfer

;ROUTINE TO START A TO 10 TRANSFER. ACCEPTS:
;	A/DTE NUMBER
;	B/ BYTES LEFT IN QUEUE (FOR CONSOLE FRONT END ONLY)
;RETURNS +1 WITH
;	A/DTE NUMBER
;	B/CLOBBERED
;	C/OLD COUNT FROM DTEB1
;	D/BUFFER POINTER BIT FOR LAST OPERATION

DOFRGM:	SAVEP			;PRESERVE THESE
	PUSH P,B		;SAVE INPUT
	CALL SETRGN		;GO FIND HIS REGION
	POP P,B
	LOAD P5,CMVRR,(C)	;GET PROTOCOL TYPE
	JRST @DOFRTR(P5)	;GO HANDLE PROPER PROTOCOL

;CODE FOR RSX20F PROTOCOL

DOFRRS:	LOAD P5,CMFWD,(D)	;GET WORD/BYTE INDICATOR
	LOAD C,DTEBF,(A)	;GET CURRENT BUFFER BIT
	MOVE D,C		;SAVE FOR CALLER
	TRC C,1			;NEXT BUFFER
	STOR C,DTEBF,(A)	;STORE THIS AS CURRENT BUFFER
	XCT [	HRRZ P4,DTBFWD(A)
		HLRZ P4,DTBFWD(A)](C) ;PICK UP BUFFER BASE
	HRLI P4,(<POINT ^D8,0>)	;MAKE IT A POINTER
	SKIPE P5		;DOING BYTE MODE?
	HRLI P4,(<POINT ^D16,0>) ;NO. GET WORD POINTER THEN
	LOAD C,DTEB1,(A)	;GET PREVIOUS COUNT
	CAIG B,BYTBUF		;ROOM IN A BUFFER FOR THIS MESSAGE?
	JRST [	SETZRO DTEBC,(A) ;YES. NO PENDING OPERATION THEN
		STOR B,DTEB1,(A) ;NCURRENT COUNT
		SKIPE P5	;BYTE TRANSFER?
		LSH B,-1	;NO. CALCULATE 16 BIT COUNT
		MOVNI B,0(B)	;GET NEG WORD COUNT
		ANDI B,7777	;ONLY 12 BITS FOR THE DTE
		IORI B,1B23	;SET I BIT TO INFORM 11
		MOVEI P2,DTET10	;DOING A TO 10 TRANSFER
		JRST SET1]	;AND GO DO IT
	MOVEI P2,DTET1F		;DOING A FRAGMENTED MESSAGE
	SUBI B,BYTBUF		;FIND RESIDUE
	STOR B,DTEBC,(A)	;SAVE IT FOR LATER
	MOVNI B,BYTBUF		;NUMBER OF BYTES
	SKIPE P5		;BYTE MODE?
	ASH B,-1		;NO. GET WORD COUNT THEN
	ANDI B,7777		;ONLY WANT 12 BITS
	MOVEI P1,BYTBUF
	STOR P1,DTEB1,(A)	;REMEMBER THIS COUNT
; ..

	; ..
;READY TO START THE TO -10 TRNASFER

SET1:	LSH A,SDTE		;FIND DTE REGION
	MOVEM P4,DTETBP(A)	;STORE APPROPRIATE BYTE POINTER
	LSH A,-SDTE		;RESTORE DTE NUMBER
SET2:	IORM P2,DTESTS(A)	;INSERT STATUS WORD
	MOVE P1,DATO(A)		;DATAO WORD
	IORI P1,B		;WHERE DATA LIVES
	XCT P1			;DO TRANSFER
	MOVX B,DTIPU		;DO WE WANT TO INDICATE PROTOCOL UP?
	TDNN B,DTESTS(A)	;???
	 RET			; NO, JUST RETURN
	ANDCAM B,DTESTS(A)	;YES, CLEAR THE BIT
	MOVX B,DI.LSC		;GET THE ROUTER FUNCTION
	MOVX C,LS.ON		;The line went to the on state
	CALLRET CALDVR		;AND TELL ROUTER ABOUT IT

;TRANSFER VECTOR FOR DOFRGM

DOFRTR:	IFIW!DOFRRS		;FOR RSX20F
	IFIW!DOFRMC		;FOR MC PROTOCOL
	IFIW!D6DRBL		;for DN60 protocol

;CODE TO HANDLE TO -10 TRANSFER FOR MCB PROTOCOL

DOFRMC:	EA.ENT			;RUN IN EXTENDED SECTION.
	LOAD P5,DTEBC,(A)	;GET RESIDUAL COUNT
	LOAD B,CMQCT,(D)	;GET PIECEMEAL COUNTER
	JUMPLE B,DOFRMB		;IF COUNT IS NOT GOOD, BUGCHK AND RELOAD
	JUMPE P5,DOFMCI		;NO RESIDUAL COUNT. GO GET A FREE BLOCK
	LOAD P3,CMTMD,(D)	;GET MODE OF THIS TRANSFER
	CAMG B,P5		;REASONABLE TRANSFER?
	IFSKP.
DOFRMB:	  BLOCK.		;no. complain.
	  SAVEAC <P4,P2>
	  MOVE P4,$CMTST(C) 	;get flags from -10's region.
	  MOVE P2,$CMTST(D) 	;get flags from -11's region.
	  BUG.(CHK,DTEMCC,DTESRV,SOFT,<DOFRGM - DN20 disagrees with count>,<<A,D>,<P5,REST>,<C,RGN10>,<P2,RGN11>>,<

Cause:	Either the monitor has calculated a different value than it was
	given by the front end, or an invalid count (.LE 0) has been found.

Action:	Check for DTE hardware problems;  if there is none, the code in the
	DN20 should be investigated.

Data:	D - Comm region address
	REST - residual count of transfer
	RGN10 - Flags from -10's region
	RGN11 - Flags from -11's region
>)
	  ENDBK.
	  JRST DINGER		;AND RELOAD DN20
	ENDIF.

	SUB P5,B		;COMPUTE NEW RESIDUAL COUNT
	STOR P5,DTEBC,(A)	;STASH IT
	CAIE P3,.TMBYT		;BYTE MODE TRANSFER?
	LSH B,-1		;NO. HALVE NUMBER THEN

	MOVNI B,0(B)		;GET NEG OF COUNT
	ANDI B,7777		;MAKE IT 12 BITS
	IORI B,1B23		;SET I BIT
	MOVEI P2,DTET10		;SAY DOING TO -10 TRANSFER
	JRST SET2		;AND GO DO THE TRANSFER

;HERE TO START A NEW TRANSFER

DOFMCI:	LOAD CX,CMPCT,(D)	;GET COUNT OF ENTIRE MESSAGE
	JUMPLE CX,DOFRMB	;IF BAD COUNT, BUGCHK AND RELOAD.
	MOVE C,CX		;GET COUNT INTO C
	STOR C,DTEBC,(A)	;SAVE STARTING COUNT
;********* Handle message too long *************

	SKIPN DTEIND(A)		;Have a message block?
	 JRST [SETONE DTBLK,(A) ; SAY THIS DTE IS BLOCKED FOR FREE SPACE
	       SETZRO DTEBC,(A) ; INVALIDATE THE BYTE COUNT
	       RET]		   ; AND GIVE UP
	LOAD P1,DTBIBL,(A)	;POINT TO THE SECTION ZERO INPUT BLOCK
	CALL SETRGN		;FIND REGIONS AGAIN
	LOAD B,CMTMD,(D)	;GET MODE OF THESE TRANSFERS
	HRLI P1,(<POINT ^D8,>)	;ASSUME BYTE MODE
	CAIE B,.TMBYT		;IS IT?
	HRLI P1,(<POINT ^D16,>)	;NO. MAKE IT WORDS THEN
	LSH A,SDTE		;FIND PROPER DTE GROUP
	MOVEM P1,DTETBP(A)	;STORE INTO THE EPT
	LSH A,-SDTE		;RESTORE DTE NUMBER

;NOW WE WILL SET UP SOME LOCATIONS IN THE MESSAGE BLOCK TO TELL
;ROUTER WHERE THE DATA IS LOCATED AND HOW MUCH THERE IS.

	LOAD B,CMPCT,(D)	;GET THE COUNT OF THE TRANSFER
	MOVE P1,DTEIND(A)	;GET THE MSG BLK POINTER BACK
	XMOVEI C,UD.MSD(P1)	;CALCULATE THE "FIRST" MSD ADDRESS
	STOR C,MBFMS,(P1)	;SET THAT UP FOR ROUTER
	STOR B,MDBYT,(C)	; ALONG WITH THE COUNT
	JRST DOFRMC		;AND GO DO INITIATE THE TRANSFER

;ROUTINE USED BY TTYSRV TO QUEUE UP A SINGLE CHARACTER OUTPUT
;REQUEST. THESE REQUESTS ARE HANDLED SPECIALLY IN THAT THEY ARE
;PACKED TOGETHER IN A SPECIAL PACKET.
;INPUT IS:
;	B/ FUNCTION,,DEVICE
;	C/ UNIT,,
;	D/ BYTE

DTSNGL::CALL DTSNG0		;DO WORK
	 JRST DTSNG3		;COULDN'T DO IT
	RETSKP			;SUCCESS

;WORKER ROUTINE

DTSNG0:	SAVEP			;GET SOME WORK REGS
	S0.ENT			;HAVE TO RUN IN SECTION 0
	MOVE A,MSTRDT		;TO THE MASTER -11
	JE DTERL,(A),R		;IF NOT RUNNING, GIVE UP FOR NOW
	MOVEI P3,SNGPK1		;ADDRESS
	MOVE P4,SNGPK1		;LOOK AT THIS ONE
	TXNN P4,SNGACT		;INACTIVE?
	TXNE P4,SNGAVL		;YES, THIS PACKET AHVE SPACE IN IT?
	JRST DTSNG1		;NO. TRY OTHERS
	JRST DTSNG6		;GO DO COMMON CODE

DTSNG1:	MOVE P4,SNGPK2		;GET FLAGS
	MOVEI P3,SNGPK2
	TXNN P4,SNGACT		;INACTIVE?
	TXNE P4,SNGAVL		;THIS ONE HAVE ROOM?
	RET
DTSNG6:	CALL DTSNG2		;GO ADD BYTE
	RETSKP			;DONE
	; ..

;DTSNGL...

;WORKER ROUTINE TO ADD BYTE TO SINGLE PACKET

DTSNG2:	TXOE P4,SNGONQ		;ON THE QUEUE YET?
	JRST DTSNG4		;YES. GO ADD THE DATUM
	TXO P4,3B1		;SAY IS A SINGLE PACKET GROUP
	HLRZ P1,DTEQS(A)	;NO. MUST ADD IT
	HRLM P3,DTEQS(A)	;ADD IT TO THE TAIL
	SKIPN P1		;EMPTY QUEUE?
	JRST [	HRRM P3,DTEQS(A) ;YES. MAKE IT THE HEAD ALSO
		JRST DTSNG5]
	STOR P3,QLINK,(P1)	;NO. LINK THIS ONE IN
DTSNG5:	SETZRO QLINK,(P3)	;THIS ONE DOESN'T LINK
	DMOVE P1,[BYTE (^D16) 10,.DFHLC
		BYTE (^D16) .FEDLS,0]
	DMOVEM P1,1(P3)
DTSNG4:	MOVSI P1,(2B15)		;INCREASE Q COUNT
	ADDM P1,1(P3)		;DO IT
	LDB P1,[POINT 6,P4,17]	;GET COUNT OF ENTRIES IN QUEUE
	IDIVI P1,2		;ENTRIES PER -10 WORD
	ADDI P3,SNGHDR(P1)	;WORD TO PUT IT IN
	MOVEI B,0(B)		;DEVICE
	CAIN B,.FECTY		;IS THIS THE CTY?
	MOVS C,CTYUNT		;YES. GET REAL NAME
	LSH C,-^D10		;POSITION LINE NUMBER
	IORI C,0(D)		;MERGE IN BYTE
	XCT [	DPB C,[POINT ^D16,0(P3),15]
		DPB C,[POINT ^D16,0(P3),31]](P2)
	LDB P2,[POINT 6,P4,17]	;GET RESIDENT COUNT
	AOS P2			;INCREASE IT
	CAIL P2,MAXSGL		;FULL?
	TXO P4,SNGAVL		;YES. NO MORE THEN
	DPB P2,[POINT 6,P4,17]	;PUT BACK THE COUNT
	SUBI P3,SNGHDR(P1)	;BACK TO TOP OF PACKET
	HLLM P4,0(P3)		;SET UP NEW FLAGS
	MOVX B,DTE11!DTE11I	;ACTIVE STATUS
	TDNN B,DTESTS(A)	;IS IT ACTIVE?
	CALL DTESKD		;NO. GO START IT
	RET			;AND DONE

;COULD NOT PUT ENTRY IN EITHER SINGLE PACKET. USE CONVENTIONAL
;MECAHNISM

DTSNG3:	MOVSI A,TTYINT		;THE INTERRUPT LOCATION
	CALLRET DTEQ		;DO IT

;REQUEST TIME AND DATE FROM 11

RQTAD1::			;ALTERNATE ENTRY FOR REQUEST TIME AND DATE 11
	MOVSI B,.DFRTD		;GET TIME/DATE FUNCTION
	MOVE A,MSTRDT		;THE MASTER -11
	SETZM C			;NO UNIT - SEND DIRECT
	CALLRET DTEQ
;THIS IS ROUTER (AND POSSIBLY OTHER HIGHER LEVEL DRIVERS) ENTRY INTO
;DTESRV.  DTESRV PERFORMS THREE FUNCTIONS FOR ROUTER; HALT A LINE,
;INITIALIZE A LINE AND QUEUE A MESSAGE ON A LINE.
;
;CALLED:
;	A/ FUNCTION CODE (DD.OPN, DD.CLS, OR DD.XMT, DD.PRB)
;	B/ LINE IDENTIFIER QUANTITY (DTE NUMBER IN OUR CASE)
;	C/ MESSAGE BLOCK POINTER (FOR DD.XMT FUNCTION) or
;	   DNADLL callback ID for DD.OPN function or
;	   Message block address for DD.PRB function
;
;RETURNS:
;	RET			;COULDN'T PERFORM FUNCTION
;				; * OR FUNCTION WAS DD.CLS OR DD.OPN *
;	RETSKP			;ALL IS DONE

DTEDSP::EXCH A,C		;EXCHANGE FUNCTION AND MSG BLK POINTER
	EXCH A,B		;EXCHANGE MSG BLK POINTER AND LINE BLOCK
				; ADDRESS (DTE NUMBER)
	SKIPL A			;[7226] RANGE CHECK
	CAIL A,DTEN		;[7226]  DTE NUMBER
	RET			;[7226] NOT POSSIBLE FOR THIS CONFIGURATION
	CAIL C,DD.OPN		;RANGE CHECK THE FUNCTION
	CAILE C,DD.MAX		; TYPE
	BUG.(CHK,INVDFN,DTESRV,SOFT,<DTEDSP - Bad function specified>,,<

Cause:	The caller of DTEDSP supplied an illegal controller function.
>,RTN)
	CALL @DTEDST(C)		;DISPATCH BY FUNCTION CODE
	RET			;BAD RETURN * OR DD.CLS OR DD.OPN *
	RETSKP			;GOOD RETURN

DTEDST:	IFIW DTDINI		;0 = INITIALIZE PROTCOL
	IFIW DTDHLT		;1 = HALT ALL PROTOCOL
	IFIW DTDQUE		;2 = QUEUE OUTPUT BUFFER
	IFIW DTDPRB		;3 = Post receive message block
	IFIW DTREAL		;4 = Check existance of DTE
	IFIW CPOPJ		;NTMAN - SET PARAMETER
	IFIW CPOPJ		;NTMAN - CLEAR PARAMETER
	IFIW CPOPJ		;NTMAN - READ PARAMETER
	IFIW CPOPJ		;NTMAN - SHOW COUNTERS
	IFIW CPOPJ		;NTMAN - SHOW and ZERO COUNTERS

;HERE TO HALT A LINE (A CONTAINS THE DTE NUMBER)
DTDHLT:	CALL DTREST		;RESET THE DTE
	SETZRO DTERL,(A)	;MAKE IT LOOK DEAD
	CALL CLRDT0		;CLEAR IT OUT AND POST ALL DEAD MESSAGES
	SETZ B,			;Prepare to clear message block pointer
	EXCH A,B		;Change AC with DTE number
	EXCH A,DTEIND(B)	;Get message block if any
	RETSKP			;Return with possible MB in T1(A)

;HERE TO INITIALIZE PROTOCOL ON A LINE (Turn the line on)
DTDINI:	JN DTERL,(A),R		;If running a protocol already, then error
	MOVEM B,DCNCID(A)	;Save DNADLL callback ID
	MOVEI B,MCPRON		;Get protocol we will use
	SKIPE T4		;A buffer for us?
	 MOVEM T4,DTEIND(A)	;Yes, save it
	RETSKP

;HERE TO QUEUE OUTPUT
DTDQUE:	HRLI A,DNPOST		;CALLBACK ADDRESS FOR OUTPUT DONE
	JRST DTEQ

;Here to post a receive buffer (message block)
DTDPRB:	SKIPE DTEIND(A)		;Do we already have one?
	 RET			;Yes, we can only handle one now
	MOVEM B,DTEIND(A)	;No, save address for next TO-10 transfer
	RETSKP

	SUBTTL ROUTER INTERFACE
;CALL CALDVR
;ALL CALLS TO ROUTER (OR ANOTHER HIGH LEVEL USER OF DTE) GO THROUGH
;THIS ROUTINE.
;
;CALL:
;	A/ DTE#
;	B/ FUNCTION CODE (DI.XXX; SEE D36PAR FOR DEFINTIONS)
;	C/ FUNCTION SPECIFIC DATA
;	D/ EVEN MORE FUNCTION SPECIFIC DATA
;
;RETURN:
;	RET			;ALWAYS

CALDVR:	EXCH A,B		;EXCHANGE DTE# AND FUNCTION CODE
	LOAD B,DTBDID,(B)	;GET THE DRIVER'S (ROUTER'S) BLOCK ID
				; (USUALLY THE ADDRESS OF HIS DATA BLOCK
				; FOR HIS CIRCUIT)
	JUMPE B,RTN		;Nobody cares...
	CALLRET DTIPPI##	;CALL DNADLL (FOR NOW HE'S OUR ONLY USER)
	SUBTTL DTEQ - Queue requests for the DTE

;THIS IS THE DTE REQUEST QUEUER. FOR RSX20F PROTOCOL ACCEPTS:
;	F/DRIVER UNIQUE CODE
;	A/DRIVER INT LOC,,DTE NUMBER
;	B/DTE FUNCTION CODE,,FE DEVICE CODE
;	C/UNIT NUMBER,,BYTE COUNT OR ZERO
;		BIT 18 OF C IS A ONE IF INDIRECT DATA MUST BE SENT
;		IN BYTE MODE. IF 0, THEN DTESRV DECIDES HOW TO PACKAGE
;		AND SEND THE BYTES
;	D/INDIRECT BYTE POINTER (IF RH OF C NE 0) OR LOCAL DATUM
;	  IF LOCAL DATUM SPECIFIED (I.E. RH OF C EQ 0) THEN
;	  IF LH OF C =0, DATUM IS 16 BITS. IF LINE NUMBER
;	  IS NON-ZERO, THEN DATUM IS 8 BITS.

;AND FOR MCB PROTOCOL ACCEPTS:
;
;	A/ DRIVER INT LOC,,DTE NUMBER
;	B/ POINTER TO MESSAGE BLOCK
;
;	RETURNS:
;	+1 IF NO PACKETS AND CALLED FROM SCHEDULER. REQUEST NOT
;	   QUEUED.
;	+2 REQUEST QUEUED
;
;MAY BE CALLED FROM PI OR NON-PI LEVEL .

;DTEQI is alternate entry point.  It returns +1 always.  If called
;in scheduler or PI level, it will use the "reserve" of nodes to
;avoid failure.

;LOCAL FLAGS

NOFF==1B0			;NO FAILURE POSSIBLE

DTEQI::	S0.ENT			;THIS RUNS IN SECTION 0
	TRVAR <SAVF,SAVA,SAVB,SAVC,SAVD,PISTAT,PROVER,EFLAG> ;SAVE REGS HERE
	MVI. NOFF,EFLAG		;INIT EFLAG
	JRST DTEQ14

DCNMSO::
DTEQ::	S0.ENT			;THIS RUNS IN SECTION 0
	TRVAR <SAVF,SAVA,SAVB,SAVC,SAVD,PISTAT,PROVER,EFLAG> ;SAVE REGS HERE
	SETZM EFLAG		;INIT EFLAG

DTEQ14:	JE DTERL,(A),DTEOFF	;DTE IS NOT RUNNING. CHECK OUT WHAT TO DO
	MOVEM A,SAVA		;SAVE ALL ARGS
	HRRZS A			;ISOLATE DTE NUMBER
	CAIL A,DTEN		;A KNOWN DTE?
	BUG.(HLT,INVDTE,DTESRV,SOFT,<DTEQ - Invalid DTE specified>,,<

Cause:	The DTE request queuer for outgoing messages has been given
	an invalid (greater than 3) DTE number.

Action:	Look at the dump.  The stack should indicate the calling
	routine.

>)
	CAMN A,MSTRDT		;IS THIS THE MASTER?
	SKIPE FEFLG		;YES. PRIMARY PROTOCOL AVAILABLE?
	SKIPA			;ALL SET
	RETSKP			;NO PROTOCOL INIT. IGNORE REQUEST
	MOVEM B,SAVB
	MOVEM C,SAVC
	MOVEM D,SAVD
	MOVEM F,SAVF		;SAVE UNIQUE CODE AS WELL
	CALL SETRGN		;GO GET COMM REGION POINTERS
	LOAD C,CMVRR,(C)	;GET PROTOCOL VERSION
	MOVEM C,PROVER		;SAVE IT FOR LATER
	SETZM PISTAT		;ASSUME PI IS ON
	CONSO PI,1B<DLSCHN+^D20> ;AT DTE PI LEVEL?
	CONSO PI,1B<DLSCHN+^D28> ;IS PI OFF?
	SETOM PISTAT		;YES, INTERLOCK ALREADY IF EFFECT
	BLCAL. ASGNOD,<A,PISTAT,<NOFF,EFLAG>> ;GET BUFFER
	 RET			;COULDN'T AND CAN'T BLOCK - GIVE UP
	MOVEI D,0(A)		;MOVE ADDRESS
	HLRZ B,SAVA		;INT LOC
	STOR B,QINT,(D)		;TO THE REQUEST
	SETZRO QMODE,(D)	;ASSUME FREE CHOICE ON INDIRECT
	HRRZ B,SAVC		;COUNT OR DATUM
	STOR B,QCNT,(D)		;STORE COUNT
	TXZE B,DTBYTM		;FORCE BYTE MODE?
	JRST [	SETONE QMODE,(D) ;YES
		JRST .+1]	;PROCEED
	MOVE A,SAVF		;GET UNIQUE CODE
	STOR A,QCOD,(D)		;PUT IN THE PACKET

	MOVE C,PROVER		;GET PROTOCOL VERSION NUMBER
	CAIN C,.VN20F		;IS THIS RSX20F PROTOCOL?
	IFSKP.			;No, then must be DN60 or MCB
	  MOVE B,SAVB		;GET POINTER TO MESSAGE BLOCK
	  STOR B,QPNTR,(D)	;STORE IT
	  CAIE C,.VNMCB		;For the MCB?
	  IFSKP.
	    STOR B,QCOD,(D)	;STORE MESSAGE BLOCK HERE FOR TO -11 DONE CODE.
	  ENDIF.
	  HRRZ B,SAVA		;DTE NUMBER 
	  STOR B,QDEV,(D)	; FOR TO -11 DONE CODE.
	ELSE.
	  HLRZ C,SAVB		;THE FUNCTION CODE
	  SKIPE B		;AN INDIRECT INDICATOR?
	  TRO C,1B20		;YES. MARK IT AS SUCH
	  STOR C,QFNC,(D)	;AND THE FUNCTION
	  HLRZ C,SAVC		;UNIT NUMBER
	  STOR C,QLIN,(D)	;TO THE PACKET
	  HRRZ B,SAVB		;DEVICE CODE
	  STOR B,QDEV,(D)	;TO REQUEST
	  MOVE B,SAVD		;BYTE POINTER OR DATUM
	  STOR B,QPNTR,(D)	;STORE POINTER OR DATUM
	ENDIF.
	HRRZ A,SAVA		;DTE NUMBER
	SKIPE PISTAT		;PI OFF BY CALLER?
	JRST DTEQ1		;YES
	NOSKD1			;PROTECT THE DATA STRUCTURES
	CHNOFF DLSCHN		;AND AGAIN
DTEQ1:	HLRZ B,DTEQS(A)		;GET TAIL
	HRLM D,DTEQS(A)		;MAKE THIS THE TAIL
	SKIPN B			;WAS Q EMPTY?
	JRST [	HRRM D,DTEQS(A)	;YES
		JRST OCUPID]	;AND GO INLINE
	STOR D,QLINK,(B)	;NO. ADD THIS ONE
OCUPID:	SETZRO QLINK,(D)	;THIS ONE HAS NO LINK
	LOAD B,DTEST,(A)	;GET STATUS OF THIS DTE
	TXNN B,DTE11!DTE11I	;IS TO 11 IDLE?
	CALL DTESKD		;GO START UP THE DTE
	SKIPE PISTAT		;PI OFF BY CALLER?
	IFSKP. <		;PI ON AND NOT IN PI
	 CHNON DLSCHN		;TURN ON THE DTE AGAIN
	 OKSKD1>			;AND THE SCHEDULER
	TMNE NOFF,EFLAG		;TELL CALLER OF FAILURE?
	RET			;NO
	RETSKP			;AND RETURN

;DTEQ CONTINUED. DTE IS NOT RUNNING. SEE IF WE SHOULD BLOCK

DTEOFF:	HRRZ CX,A		;GET DET #
	CAME CX,MSTRDT		;IS THIS THE MASTER?
	RET			;NO. GIVE UP NOW THEN
	SKIPN INSKED		;IN THE SCHEDULER?
	SKIPE NSKED		;OR NOSKED?
	RET			;YES. GIVE UP THEN
	MOVE CX,RLDFRK		;GET FORK ID OF RELOAD FORK
	CAME CX,FORKX		;IS THIS IT?
	CONSZ PI,1B<DLSCHN+^D20> ;AT DTE INTERRUPT LEVEL?
	RET			;YES. GIVE UP

;CAN BLOCK THE PROCESS. DO IT

	PUSH P,A		;SAVE ARG
	MOVEI A,RLDTST		;WAIT FOR MASTER TO BE RELOADED
	MDISMS			;DO IT
	POP P,A			;GET BACK ARG
	JRST DTEQ14		;AND TRY AGAIN

;SCHEDULER TEST FOR ABOVE

	RESCD
RLDTST:	MOVE A,MSTRDT		;GET MASTER DTE NUMBER
	OPSTR <SKIPE>,DTERL,(A)	;NOW RUNNING?
	ADDI 4,1		;YES.
	JRST 0(4)		;AND DONE

	ENDTV.

;ROUTINE TO START A TO 11 OPERATION FROM THE TOP OF THE DRIVER
;QUEUE
;ACCEPTS A/ DTE NUMBER


;TRANSFER VECTOR FOR PROTOCOL TYPES

SKDVEC:	SKVER1			;ROUTINE FOR RSX20F PROTOCOL
	SKVER2			;ROUTINE FOR MCB DECNET PROTOCOL
	SKVER3			;routine for DN60 protocol

DTESKD:	SKIPN DTEQS(A)		;A REQUEST?
	RET			;NO. ALL DONE THEN
	JN DTRLD,(A),R		;IF RELOADING -11, DON'T DO ANYTHING
	CALL SETRGN		;GO FIND MY COMM REGION TO THIS -11
	LOAD D,CMVRR,(C)	;GET PROTOCOL VERSION NUMBER
	MOVE D,SKDVEC(D)	;GET ROUTINE TO DO THIS PROCESSING
	HRRZ B,DTEQS(A)		;MAKE SURE STILL A REQUEST THERE
	JUMPN B,0(D)		;IF STILL HERE, DO IT
	RET			;IF GONE, JUST RETURN

;CODE TO PROCESS PROTOCOL VERSION 1 PACKETS (RSX20F)
;	A/ DTE NUMBER
;	B/ PACKET

SKVER1:	STKVAR <PCCNT>		;RESERVES SOME SPACE
	SETZM PCCNT		;INIT EXTRA COUNT TO ZERO
	CALL TSTSGL		;IS IT A SINGLE CHARACTER GROUP?
	JRST [	MOVX C,DTE11	;TO -11 STATUS
		IORM C,DTESTS(A) ;SET IT
		MOVX C,SNGACT	;GET ACTIVE BIT
		IORM C,0(B)	;SAY SO
		CALL SETRGN
		MOVEI B,1(B)	;THE DATA
		EXCH B,C
		LDB D,[POINT ^D16,0(C),15] ;BYTES
		JRST DTSKDM]	;GO DO IT
	JE QFNC,(B),DEQDTE	;IF FLUSHED, POST ONLY
	MOVEI C,0(A)		;DTE NUMBER
	IMULI C,PKTSIZ		;SIZE OF QUEUE PACKET
	ADDI C,PKTADR		;GET BASE ADDRESS OF THIS PACKET
	LOAD D,QDEV,(B)		;DEVICE CODE
	STOR D,HDDEV,(C)	;TO THE QUEUE
	LOAD D,QFNC,(B)		;THE FUNCTION
	STOR D,HDFNC,(C)	;TO THE QUEUE
	SETZRO HDSPR,(C)	;ZERO THE SPARE
	LOAD D,QCNT,(B)		;GET THE COUNT
	JUMPN D,[CAILE D,MAXINP	;CAN WE SEND IT ALL?
		MOVEI D,MAXINP	;NO. SEND MAX NUMBER
		STOR D,HDDAT,(C) ;PUT SIZE IN PACKET
		MOVEM D,PCCNT	;REMEMBER THIS AS SIZE OF EXTRA STUFF
		LOAD D,DTEST,(A) ;DTE STATE
		TXO D,DTE11I	;DOING INDIRECT
		STOR D,DTEST,(A);NEW STATE
		SETZRO HDLIN,(C) ;CLEAR OUT LINE NUMBER FIELD
		 JRST STOREG]	;GO STORE IN MY REGION
	LOAD D,QPNTR,(B)	;GET DATUM
	STOR D,HDDT1,(C)	;STORE IN PACKET
	LOAD D,DTEST,(A)	;DTE STATE
	TXO D,DTE11		;REGULAR 11
	STOR D,DTEST,(A)	;NEW STATE

	; ..

	; ..
STOREG:	MOVEI D,12		;INCLUDE DATUM
	STOR D,HDCNT,(C)	;TO THE PACKET
	LOAD D,QLIN,(B)		;UNIT
	JUMPE D,STORG1		;IF NO LINE GIVEN,ALLOW FOR 16 BIT  DATUM
	STOR D,HDLIN,(C)	;TO THE QUEUE
STORG1:	PUSH P,C		;SAVE QUEUE POINTER
	CALL SETRGN		;GET MY COMM REGION
	MOVE B,C		;MOVE MY COMM REGION POINTER
	POP P,C			;RESTORE Q POINTER
	MOVEI D,12		;THE COUNT OF THIS ONE
DTSKDM:	HRLI C,(<POINT ^D8,0>)	;POINTER
	SETZRO CMFWD,(B)	;DOING BYTE MODE
	STOR D,CMQCT,(B)	;RECORD SIZE OF THIS PIECE
	ADD D,PCCNT		;COMPUTE TOTAL MESSAGE SIZ
	STOR D,CMPCT,(B)	;STORE FOR FE

;COMMON POINT FOR SKVER1 AND SKVER3

DTSTRT:	LOAD D,CM1IC,(B)	;TO -11 COUNT
	AOS D
	STOR D,CM1IC,(B)	;UP IT
	LSH A,SDTE			;*4
	MOVEM C,DTEEBP(A)	;STORE POINTER
	LSH A,-SDTE		;/4
   IFN DTESW,<
	HRRZ T2,DTEQS(T1)	;GET HEAD PACKET
	CAIE T2,SNGPK1		;IS THIS A
	CAIN T2,SNGPK2		; SINGLE PACKET SPECIAL?
	JRST DTSTR1		;YES, MOVE ON
	CAIL T2,COMQ		;NO, REGULAR.  IS IT
	CAILE T2,COMQ+<NQPKT*QPKT>-1  ; WITHIN RANGE?
	JSR BUGHLT		;NO
	TMNN QINU,(T2)		;YES, PACKET IN USE?
	JSR BUGHLT		;NO, THAT'S BAD
DTSTR1:
   >
	CALL DING11		;GO START THE -11
	RET			;AND DONE

;ROUTINE TO HANDLE PROTOCOL VERSION 2 PACKETS FOR MCB
;	A/ DTE NUMBER
;	B/ PACKET
;	C/ COMM REGION POINTER

SKVER2:	SAVEAC <Q1,Q2,Q3,P1,P2>	;SAVE REGS
	STKVAR <DTENUM,QNOD,COMREG>
	EA.ENT			;DECNET-36 RUNS IN EXTENDED SECTIONS
	MOVEM A,DTENUM		;SAVE DTE NUMBER
	MOVEM B,QNOD		; Q-PACKET
	MOVEM C,COMREG		; COMM REGION POINTER

	MOVX Q1,.TMBYT		;THIS WILL BE AN
	STOR Q1,CMTMD,(C)	; 8-BIT XFER
	MOVX D,DTE11		;MAKE THE NEW STATE
	IORM D,DTESTS(A)	; REG XFER IN PROGRESS

	LOAD A,QPNTR,(B)	;GET MESSAGE BLOCK POINTER
	XCALL (XCDSEC,DNLENG)	;GET THE LENGTH

	MOVE C,COMREG		;GET BACK THE COMM REGION POINTER
	STOR A,CMPCT,(C)	;STORE IN "PACKET COUNT" OF COMM REGION
	STOR A,CMQCT,(C)	;ALONG WITH Q COUNT (WE WON'T DO SCATTER
				;GATHER FOR NOW)
	MOVE A,DTENUM		;GET DTE NUMBER BACK
	MOVE B,QNOD		; AND POINTER TO Q-BLOCK
	LOAD Q1,DTBOBL,(A)	;SET UP POINTER TO "OUTPUT" BLOCK
	LOAD Q2,QPNTR,(B)	;LOAD UP POINTER TO THE MESSAGE BLOCK

   IFN FTPARANOID,<
	XMOVEI CX,.		;Touch 
	STOR CX,NMMAG,(Q2)	; message block.
   >;END IFN FTPARANOID

	CALL CPYMSG		;(Q1,Q2/A) COPY MESSAGE BLOCK TO SECTION ZERO
				; BLOCK FOR DTE TRANSFER
	MOVE C,COMREG		;SET UP COMM REGION POINTER
	LOAD D,CM1IC,(C)	;GET TO-11 COUNT
	AOS D			;INCREMENT IT TO INDICATE
	STOR D,CM1IC,(C)	; NEW PACKET FOR 11
	MOVE D,A		;GET BYTE POINTER FROM CPYMSG
	MOVE A,DTENUM		;SET UP DTE NUMBER
	LSH A,SDTE		;*4
	MOVEM D,DTEEBP(A)	;STORE THE BYTE POINTER
	MOVE A,DTENUM		;ONCE AGAIN GET THE DTE NUMBER
	CALL DING11		; AND RING THE DOOR-BELL TO WAKE UP 11
	RET			;RETURN TO SENDER

;COPY MULTI-SEGMENT MESSAGE BLOCK TO SECTION ZERO CONTIGUOUS BLOCK
;USES SECTION 0 - SECTION 1 MAPPING.
;CALL CPYMSG
;	Q1/ SECTION ZERO BLOCK POINTER
;	Q2/ MESSAGE BLOCK POINTER
;RETURNS +1 ALWAYS WITH A/ BYTE POINTER TO START OF MESSAGE IN SECTION ZERO.
;USES Q1,Q2,Q3,P1,P2
;SOME OF THE AWKWARDNESS OF THE CODE IS CAUSED BY THIS FACT:
;IN AN EXTEND T1,[MOVSLJ], AC3 & AC6 MAY NOT BE USED AS INDEX REGISTERS
;FOR THE BYTE POINTERS IN AC2 & AC5

CPYMSG:	SETZ D, 		;COLLECT BYTE COUNT IN THIS REGISTER.
	LOAD P1,MBFMS,(Q2)     	;POINT TO FIRST MSD

;TALLY BYTE COUNT OF ALL BUT THE LAST MSD
CPYMS1:	OPSTR <SKIPN B,>,MDNXT,(P1) ;IS THERE A NEXT ?
	JRST CPYMS2		;NO. THIS IS THE LAST. DON'T COUNT IT
	OPSTR <ADD D,>,MDBYT,(P1) ;YES. COUNT THE BYTES
	MOVE P1,B 		;STEP TO
	JRST CPYMS1		; NEXT MSD

;IS THE LAST MSD BIG ?
CPYMS2:	LOAD Q3,MDBYT,(P1)	;IS IT
	CAIG Q3,20		; WORTH OUR WHILE ?
	JRST CPYMS6		;NO. DO IT THE EASY WAY.

;AT THE LAST MSD, CONVERT BYTE POINTER, FIND ADDRESS OF IT, AND
;BLT TO DESTINATION

	LOAD Q3,MDAUX,(P1)	;INDEXED B.P. TO START OF SOURCE
	HRRZ B,Q3		;ISOLATE OFFSET
	TLNE Q3,700000		;IS B.P. 041006,,nnn ?
	JRST CPYMS3		;NO. NO PROBLEM.
	TLO Q3,400000		;YES. MAKE IT
	HRRI Q3,1(Q3)		; 441006,,nnn+1
	ADDI B,1		;Account for the nnn+1 we just did
CPYMS3:	OPSTR <ADD B,>,MDALA,(P1) ;ADDRESS OF THE SOURCE DATA
	MOVEI C,3(D)		;BYTES BEFORE THIS MSD, ROUNDED UP.
	ASH C,-2		;NUMBER OF WORDS "" ""
	HRR Q3,C		;SAVE THIS FOR LATER CALC OF DEST B.P.
	ADD C,Q1		;DEST ADDR FOR THIS CHUNK
	LOAD T1,MDBYT,(P1)	;# OF BYTES IN LAST MSD OF SOURCE
	ADDI T1,3+3		;SLOP FOR BLT - 3 BYTES BEFORE & 3 BYTES AFTER
	ASH T1,-2		;# OF WORDS TO BLT
	CALL XBLTA 		;(T1,T2,T3) MOVE IT.
;CALCULATE DESTINATION STARTING BYTE POINTER
	IFE. D			;WERE THERE ANY BYTES BEFORE THE LAST MSD ?
	  HLL A,Q3		;NO. MAKE BYTE POINTER
	  TLZ A,17		; WITH NO INDEX
	  HRR A,Q1		;ADDRESS OF DESTINATION BLOCK
	  RET			;ALL DONE.
	ENDIF.
	MOVN P1,D		;YES. NUMBER OF BYTES BEFORE LAST MSD
	ADJBP P1,Q3		;ADJUST
	TLZ P1,17		;GET RID OF INDEX
	ADD P1,Q1		;ADDRESS OF START OF BLOCK
	TLZ P1,1		;GET RID OF POSSIBLE CARRY.

;MAKE A BYTE POINTER FOR MOVSLJ IN Q1 -

	HLLZ Q1,P1		;P & S FIELDS
	TLO Q1,Q3		; INDEXED BY Q3
	HRR Q3,P1		;MAKE Q3 GLOBAL
	HRLI Q3,MSEC1		; SO MOVSLJ WILL WORK - NOTE SECTION NUMBER
				; 1, EVEN THOUGH THE BUFFER IS IN SECTION
				; ZERO. MOVSLJ REQUIRES THIS, SO IF THE
				; SECTION 0-1 MAPPING GOES AWAY, THIS CODE
				; WILL BE BROKEN.

;NOW MOVE BYTES FROM ALL MSDs EXCEPT THE LAST

	OPSTR <SKIPE Q2,>,MBFMS,(Q2) ;POINT TO FIRST MSD, IF ANY.
CPYMS4:	TMNN MDNXT,(Q2)		;IS THIS THE LAST MSD ?
	JRST CPYMS5		;YES. DONE
	LOAD A,MDBYT,(Q2)	;BYTE COUNT.
	LOAD B,MDAUX,(Q2)	;SOURCE BYTE POINTER
	TLZ B,17		;BUT MAKE
	TLO B,P2		; IT INDEXED BY P2
	LOAD P2,MDALA,(Q2)	;LOAD UP THE INDEX
	MOVE D,A		;THE DEST COUNT
	EXTEND T1,[MOVSLJ]	;PREPEND HEADER TO USER DATA
	 BUG. (HLT,COMDTE,DTESRV,SOFT,<MOVSLJ failed>,,<

Cause:	DTESRV attempted to execute a MOVSLJ instruction, but it failed.

Action:	Look at the dump and try to determine why the instruction failed.
>)
	LOAD Q2,MDNXT,(Q2)	;STEP TO NEXT
	JRST CPYMS4		;CONTINUE

CPYMS5:	MOVE T1,P1		;RETRIEVE B.P. TO START OF DEST
	RET			;DONE.

;HERE WHEN LAST MSD IS SMALL. JUST MOVSLJ EVERYTHING

CPYMS6:	XMOVEI Q3,(Q1)		;MAKE A FULL SECTION POINTER
	LOAD P1,MBFMS,(Q2)      ;POINT TO FIRST MSD
	MOVE Q2,Q1		;SAVE ADDRESS OF SECTION ZERO AREA
	MOVE Q1,[POINT 8,(Q3)]	;MAKE BYTE POINTER TO MESSAGE DATA

CPYMS7:	LOAD A,MDBYT,(P1)	;NOT DONE. GET BYTE COUNT.
	LOAD B,MDAUX,(P1)	;SOURCE BYTE POINTER
	TLZ B,17		;BUT MAKE
	TLO B,P2		; IT INDEXED BY P2
	LOAD P2,MDALA,(P1)	;LOAD UP THE INDEX
	MOVE D,A		;THE DEST COUNT
	EXTEND T1,[MOVSLJ]	;PREPEND HEADER TO USER DATA
	 BUG. (HLT,COMDT1,DTESRV,SOFT,<MOVSLJ failed>,,<

Cause:	DTESRV attempted to execute a MOVSLJ instruction, but it failed.

Action:	Look at the dump and try to determine why the instruction failed.

>)
	LOAD P1,MDNXT,(P1)	;STEP TO NEXT
	JUMPN P1,CPYMS7		;CONTINUE
;Done
       	MOVE T1,Q2		;MAKE BYTE POINTER
	HRLI T1,(POINT ^D8)	; TO START OF BUFFER
	RET

;ROUTINE TO HANDLE PROTOCOL VERSION 2 PACKETS FOR IBM COMM
;	A/ DTE NUMBER
;	B/ PACKET
;	C/ COMM REGION POINTER

SKVER3:	SAVEQ			;SAVE REGS
	LOAD Q3,QPNTR,(B)	;GET POINTER
	LDB Q1,[POINT 6,Q3,11]	;GET BYTE SIZE
	MOVEI Q2,.TMBYT		;ASSUME BYTE
	CAIN Q1,^D16		;A WORD POINTER?
	MOVEI Q2,.TMWRD		;YES. DO WORD MODE THEN
	CAIE Q1,^D8		;EIGHT BITS?
	JRST SKVR22		;NO. ALL SET THEN

SKVR22:	STOR Q2,CMTMD,(C)	;PUT IN MODE OF THE TRANSFER
	MOVX D,DTE11		;SAY REGULAR TRANSFER IN PROGRESS
	IORM D,DTESTS(A)	;""
	LOAD D,QCNT,(B)		;GET Q COUNT
	CAIN Q2,.TMWRD		;WORD MODE?
	LSH D,1			;YES. COMPUTE # OF 8 BIT BYTE THEN
	STOR D,CMPCT,(C)	;STORE COUNT OF THIS TRANSFER
	STOR D,CMQCT,(C)	;SIZE OF WHOLE TRANSFER IS THE SAME
	MOVE B,Q3		;BYTE POINTER TO B
	EXCH B,C		;FIX UP REGS
	JRST DTSTRT		;AND GO START THE DTE

;SPECIAL ROUTINES TO RING -11'S DOORBELL ,TO MANIPULATE THE
;PI CAPABILITY, TO RESET THE DTE, AND TO FINE COMM REGION POINTERS

;RING -11'S DOORBELL
;	A/ DTE NUMBER
;CLOBBERS B

DING11:	MOVE B,CNDO(A)
	IORI B,DTEEDB		;THE -11'S BELL
	XCT B
	RET			;AND DONE

;CLEAR DOORBELL

CLRBEL:	MOVE B,CNDO(A)
	IORI B,DTETDB		;DOORBELL BIT
	XCT B			;CLEAR IT
	RET			;AND DONE

;ROUTINE TO RESET A DTE. TURNS OFF ITS INTS. ANY CONDITIONS
;ACCEPTS:	A/ DTE #

DTREST:	MOVE B,CNDO(A)		;GET PROTOTYE CONO
	IORI B,DTEPIE!DTETDB!DTETDN!DTEEDN
	XCT B			;CLEAR ALL CONDITIONS
	PUSH P,A		;SAVE DTE ARG
	HRRZS A			;ISOLATE DTE NUMBER
	LSH A,SDTE		;FIND DTE EPT REGION
	SETZM DTETBP(A)		;CLEAR LATENT POINTER
	SETZM DTEEBP(A)		;AND THIS ONE ALSO
	CALLRET PA1		;AND DONE

;ROUTINE TO INIT INT STATE OF A DTE
;ACCEPTS:	A/ DTE #

DTPII:	CALL DTREST		;FIRST RESET IT
	MOVE B,CNDO(A)		;GET PROTOTYPE CONO
	IORI B,LDTEPI		;GET PI ASSIGNMENT
	XCT B			;SET IT
	RET			;AND DONE

;ROUTINE TO SET UP COMM REGION POINTERS. ACCEPTS:
;	A/ DTE NUMBER
;RETURNS:
;	C/ POINTER TO -10'S PER PROCESS REGION
;	D/ POINTER TO -11'S PER PROCESS REGION

SETRGN:	MOVEI C,0(A)		;THE DTE NUMBER
	IMULI C,COMRGN		;SIZE OF A PER PROCESS REGION
	ADDI C,COMBAS+COMDAT	;BASE OF -10'S REGION TO THE -11
	MOVNI D,2(A)		;NOW FIND THE -11'S
	HRRZ D,COMBUF+DTEN+1(D)	;GET VALUE FROM POINTER
	ADDI D,COMBAS+COMDAT	;MAKE IT ABSOLUTE POINTER TO -11'S REGION
	RET			;AND DONE

;ROUTINE TO FLUSH ALL OUTPUT REQUEUST FOR A GIVEN TTY UNIT.
;ACCEPTS:	A/DTE #
;		B/DEVICE
;		C/UNIT,,0
;RETURNS:	+1 WITH OUTPUT REQUESTS FLUSHED
;CLOBBERS ALL TEMP REGISTERS EXCEPT A,B,C
;MUST BE NOINT AND CHNOFF ON THE DTE CHANNEL

	RESCD			;IS RESIDENT
DTEFLA::TDZA D,D		;ENTRY TO FLUSH ALL
DTEFLO::MOVEI D,1		;ENTRY TO FLUSH ONLY DATA
	S0.ENT			;MUST RUN IN SECTION 0
	STKVAR <SVDTN,SVLIN,SVDEV,SVD>
	MOVEM D,SVD		;SAVE ENTRY FLAG
	MOVEM A,SVDTN		;SAVE DTE NUMBER
	MOVEM B,SVDEV		;SAVE DEVICE CODE
	MOVSM C,SVLIN		;SAVE LINE NUMBER (FROM LH)
	HRLI A,DTEQS(A)		;INITIAL PREVIOUS
	HRRZ C,DTEQS(A)		;TOP ITEM
	JUMPE C,SKPPK1		;IF EMPTY, JUST WRAP UP
CHKPKT:	MOVE B,C		;MOVE POINTER
	CALL TSTSGL		;IS THIS A SINGLE BYTE GROUP?
	 JRST SKPPKT		;YES. SKIP IT
	LOAD B,QDEV,(C)		;DEVICE CODE
	CAME B,SVDEV		;SAME DEVICE?
	JRST SKPPKT		;NO. SKIP IT
	LOAD B,QLIN,(C)		;LINE NUMBER
	CAME B,SVLIN		;SAME LINE?
	JRST SKPPKT		;NO. GO TO NEXT
	LOAD B,QINT,(C)		;GET INTERRUPT ADDRESS
	CAIE B,TTYINT		;IS IT TTYINT?
	SKIPN SVD		;NO. FLUSH ALL?
	SKIPA			;YES. FLUSH THIS PACKET
	JRST SKPPKT		;NO. LEAVE IT
	SETZRO QFNC,(C)		;YES. MARK IT AS FLUSHED
	SETZRO QCOD,(C)		;AND PREVENT ACCOUTNING
SKPPKT:	HRL A,C			;ESTABLISH NEW PREVIOUS
	LOAD C,QLINK,(C)	;GET LINK
	JUMPN C,CHKPKT		;GO LOOK AT IT
SKPPK1:	MOVE A,SVDTN		;RESTORE DTE NUMBER
	MOVE B,SVDEV		;RESTORE DEVICE
	MOVS C,SVLIN		;RESTORE LINE (TO LH)
	SE1CAL			;ENTER SEC1 FOR RETURN
	RET			;AND DONE

;ROUTINE CALLED FROM APRSRV TO WAIT FOR ALL DTE'S
;TO COMPLETE TRANSFERS.MUST BE CALLED PIOFF AND NOT
;FROM INTERRUPT LEVEL

DTEINA::SAVEAC <Q1>		;GET A WORK REG
	MOVSI Q1,-DTEN		;LOOK AT THEM ALL
DTENA0:	JE DTERL,(Q1),DTENA1	;IF NOT RUNNING, SKIP IT
	MOVX A,DTET10!DTET1F	;SEE IF TO -10 IN PROGRESS
	TDNN A,DTESTS(Q1)	;IS IT?
	JRST DTENA2		;NO. CHECK ON TO -11
	MOVE B,CNDO(Q1)		;YES. GET A CONO WORD
	TXO B,<<CONSO 0>-<CONO 0>+DTETDN+DTETER> ;GET CONSO WORD
	XCT B			;DONE YET?
	JRST .-1		;NO. WAIT FOR IT THEN
DTENA2:	MOVX A,DTE11!DTE11I	;SEE IF ANY TO -11 IN PROGRESS
	TDNN A,DTESTS(Q1)	;IS IT?
	JRST DTENA1		;NO. GO TO NEXT DTE THEN
	MOVE B,CNDO(Q1)		;YES. GET CONO WORD
	TXO B,<<CONSO 0>-<CONO 0>+DTEEDN+DTEEER>
	MOVX A,^D100000		;# OF POLLS
	XCT B			;WAIT FOR COMPLETTION
	SOJGE A,.-1		;WAIT, BUT NOT FOREVER
DTENA1:	AOBJN Q1,DTENA0		;DO ALL OF THEM
	CALLRET DTPAUS		;PAUSE ALL DTE ACIVIITY

;ROUTINE TO REQUEST PAUSE OF ALL DTE ACTIVITY. MAY BE CALLED
;FROM ANY LEVEL

DTPAUS::MOVEI A,[SETZM DTEEPW(B)
		RET]		;ROUTINE TO EXECUTE
	JRST DTACT0		;GO TO WORKER ROUTINE

;ROUTINE TO REACTIVATE FE'S. THIS CODE MERELY TURNS ON
;VALID EXAMINE FOR ALL ACTIVE DEVICES.

DTEACT::MOVEI A,[MOVEI C,IEXSIZ+2(A) ;GET EXAMINE SIZE
		MOVEM C,DTEEPW(B) ;STORE CORRECT VALUE
		RET]
DTACT0:	SAVEAC <Q1,Q2>		;GET A WORK REG
	SKIPN PROFLG		;DOING PRIMARY PROTOCOL?
	RET			;NO. DON'T DO ANYTHING THEN
	MOVE Q2,A		;SAVE SUBROUTINE ADDRESS
	MOVSI Q1,-DTEN		;POLL ALL DEVICES
DTEAC0:	HRRZ A,Q1		;GET DTE NUMBER
	JE DTERL,(A),DTEAC1	;IF NOT ACTIVE, SKIP IT
	SKIPE SVVEXM		;NOW IN FORCED SECONDARY PROTOCOL?
	CAME A,MSTRDT		;YES. IS THIS THE MASTER -11?
	SKIPA B,A		;NO. COPY DTE NUMBER AND PROCEED
	JRST DTEAC1		;YES. SKIP IT THEN
	LSH B,SDTE		;GET EPT INDEX
	CALL 0(Q2)		;DO ROUTINE
	CALL DING11		;MAKE FE SEE IT
DTEAC1:	AOBJN Q1,DTEAC0		;LOOK AT ALL FE
	RET			;DONE

;SPECIAL ROUTINE TO INHIBIT "CONTINUED" MESSAGE

DTICON::MOVX A,1B0		;GET "FIRST-TIME" BIT
	ANDCAM A,UPFLAG		;NOT FIRST-TIME ANYMORE
	RET			;DONE

;THESE ROUTINES ALLOCATE AND DEALLOCATE REQUEST NODES
;ASGNOD (DTENO,BLKFLG,FAILFLG)
; RETURNS:
;	+1 failure, can't block
;	+2 WITH A/ADDRESS OF NODE
;DTENO - number of DTE to which message being sent
;BLKFLG is non-0 if blocking is prohibited
;FAILFLG is non-0 if failure can't be handled.  If failure can be
;handled, we will keep some buffers in reserve.

	RESCD			;MUST BE RESIDENT

ASGNOD:	BLSUB. <DTENO,BLKFLG,FAILFL>
	SAVEAC <B>
	SKIPN INSKED		;CHECK OBVIOUS BLOCK PREVENTION
	SKIPE NSKED
	SETOM BLKFLG		;CAN'T BLOCK
ASGND1:	SKIPE FAILFL		;IS FAILURE OR BLOCK POSSIBLE?
	SKIPN BLKFLG
	IFSKP. <JRST ASGND2>	;NO, BYPASS ALL CHECKS
	MOVE B,DTENO
	MOVEI A,NQPKT/2
	CAMG A,NDTEMQ(B)	;THIS DTE USING HALF OR MORE ALREADY?
	JRST BLKNOD		;YES, DON'T DO IT
	MOVEI A,NQPKT/3		;USUAL THRESHOLD
	SKIPN FORKX		;FORK 0?
	MOVEI A,NQPKT/4		;YES, LOWER THRESHOLD
	CAMLE A,NCOMH		;ABOVE THRESHOLD?
	JRST BLKNOD		;NO, BLOCK
ASGND2:	PIOFF			;PREVENT ALL INTS
	SKIPN A,COMH		;HAVE A NODE?
	IFNSK. <PION
		BUG.(CHK,NODTEN,DTESRV,SOFT,<DTESRV - NO DTE buffers available in critical case>,,<

Cause:	A buffer is needed for a queued protocol message to a front-end
	-11 via a DTE.  There are no buffers available, and the
	caller is not prepared to handle failure.

Action:	Assume the message was sent.
>)
		RET>
	HRRZ B,0(A)		;GET LINK TO NEXT

   IFN DTESW,<
	CAIL A,COMQ		;IS HEAD
	CAILE A,COMQ+<NQPKT*QPKT>-1  ; WITHIN RANGE?
	JSR BUGHLT		;NO
	TMNE QINU,(A)		;PACKET IN USE?
	JSR BUGHLT		;YES, THAT'S BAD
	SETZM (A)		;ZERO
	HRLI C,(A)		; THE
	HRRI C,1(A)		;  PACKET
	BLT C,QPKT-1(A)		;   HEADER
	SETONE QINU,(A)		;SAY IT'S NOW IN USE
	JUMPE B,ASGND3		;IF NEXT IS 0, O.K.
	CAIL B,COMQ		;IS NEXT
	CAILE B,COMQ+<NQPKT*QPKT>-1  ; WITHIN RANGE?
	JSR BUGHLT		;NO
ASGND3:	SKIPG NCOMH		;COUNT MUST BE POSITIVE
	JSR BUGHLT		;TOO BAD
   >

	HRRZM B,COMH		;MAKE NEW LINK
	SETZM 0(A)		;CLEAR HEADER
	PION			;ALLOW INTS AGAIN
	SOS NCOMH		;KEEP COUNT
	MOVE B,DTENO
	AOS NDTEMQ(B)		;COUNT USE BY EACH DTE
	RETSKP			;GOOD RETURN

BLKNOD:	SKIPE BLKFLG		;BLOCK POSSIBLE?
	RET			;NO, FAIL
	HRL A,A			;INCLUDE THRESHOLD LEVEL IN TEST
	HRRI A,SPCTST		;MAKE TEST WORD
	MDISMS			;WAIT HERE FOR A NODE
	JRST ASGND1		;GO TRY IT AGAIN

	ENDBS.

SPCTST::CAML T1,NCOMH		;NOW ABOVE THRESHOLD?
	JRST 0(4)		;NOT YET
	JRST 1(4)		;YES

;RELNOD  RELEASES A NODE
;ACCEPTS: A/ DTE NUMBER
;	 B/THE NODE ADDRESS
;RETURNS +1 ALWAYS

RELNOD:	SAVEAC <C>
	HRRZ C,COMH		; TOP OF QUEUE
   IFN DTESW,<
	IFN. C			;Is queue nonempty ?
	  CAIL C,COMQ		;Yes. IS HEAD
	  CAILE C,COMQ+<NQPKT*QPKT>-1  ; WITHIN RANGE?
	  CALL DTEREL		;NO. Die.
	ELSE.
	  SKIPE NCOMH		;No. Is count correct ?
	  CALL DTEREL		;NO. Die.
	ENDIF.
	CAIL B,COMQ		;IS NODE BEING RELEASED
	CAILE B,COMQ+<NQPKT*QPKT>-1  ; WITHIN RANGE?
	CALL DTEREL		;NO. Die.
	TMNN QINU,(B)		;PACKET IN USE?
	CALL DTEREL		;NO. Die.
	SETZRO QINU,(B)		;YES, SAY IT'S NO LONGER IN USE
	MOVE D,NCOMH		;GET COUNT
	CAIL D,NQPKT		;LEGIT?
	CALL DTEREL		;NO. Die.
   >;END IFN DTESW
	MOVEM C,0(B)		;MAKE LINK TO THIS NEW HEAD
	HRRZM B,COMH		;NEW HEAD
	AOS NCOMH		;KEEP COUNT
	SOS NDTEMQ(A)		;COUNT PER DTE
	RET			;AND DONE

   IFN DTESW,<

;THIS ROUTINE IS CALLED TO REPORT AN INCONSISTENCY IN THE DTESRV NODE 
;PACKET DATA BASE
;CALL DTEREL with no arguments
;Never returns.
DTEREL:	BUG.(HLT,DTENOD,DTESRV,HARD,<DTE data base bad>,,<

Cause:	An inconsistency has been deteced in the DTESRV node data base.

Action:	Look on the stack to find the caller of this BUGHLT. Try to
	determine why the node data base has been trashed,

>)
   >;END IFN DTESW


;THIS ROUTINE IS CALLED TO DEQUEUE AND POST ALL REQUESTS FOR
;A GIVEN DTE
;ACCEPTS:	A/ DTE #
;RETURNS:
;	+1. A PRESERVED

CLRDTE:	JN DTERL,(A),R		;IF NOW ACITVE, IGNORE REQUEST
	SASUBR <DTENM>		;SAVE DTE NUMBER
CLRDT1:	SKIPE B,DTEQS(A)	;HAVE ANY REQUESTS?
	IFSKP.			;If all done
	 LOAD B,DTEST,(A)	;Get state
	 TXZN B,DTET10!DTET1F	;To-10 in progress?
	 RET			;No
	 STOR B,DTEST,(A)	;Update status, in case called again
	 CALL SETRGN		;Find regions
	 SETZRO CMTOT,(C)	;Clear transfer in progress
	 RET
	ENDIF.
	HRRZS B			;YES. GET THE REQUEST
	HRRZS A			;GET DTE # ONLY
	CAMN A,MSTRDT		;IS THIS THE MASTER?
	JRST [	CALL TSTSGL	;SINGLE CHAR PACKET?
		 SKIPA		;IT IS
		JRST .+1	;NOT
		CALL DNSNGL	;HANDLE IT
		JRST CLRDT2]	;GO ON
	CALL DEQDTE		;AND DEQUEUE THIS REQUEST
CLRDT2:	MOVE A,DTENM		;GET BACK DTE NUMBER
	JRST CLRDT1		;AND GO GET NEXT ONE

;CLRDT1:	SKIPN B,DTEQS(A)	;HAVE ANY REQUESTS?
;	 JRST CLRDT3		;No
;	HRRZS B			;YES. GET THE REQUEST
;	HRRZS A			;GET DTE # ONLY
;	CAMN A,MSTRDT		;IS THIS THE MASTER?
;	JRST [	CALL TSTSGL	;SINGLE CHAR PACKET?
;		 SKIPA		;IT IS
;		JRST .+1	;NOT
;		CALL DNSNGL	;HANDLE IT
;		JRST CLRDT2]	;GO ON
;	CALL DEQDTE		;AND DEQUEUE THIS REQUEST
;CLRDT2:	MOVE A,DTENM		;GET BACK DTE NUMBER
;	JRST CLRDT1		;AND GO GET NEXT ONE
;
;CLRDT3:	CALL SETRGN		;Find regions (sets up C and D)
;	LOAD B,DTEST,(A)	;Get state
;	TXZN B,DTET10!DTET1F	;To-10 in progress?
;	IFSKP.
;	  STOR B,DTEST,(A)	;Update status, in case called again
;	  SETZRO CMTOT,(C)	;Clear transfer in progress
;	ENDIF.
;	LOAD B,CMVRR,(C)	;Get version of protocol
;	JRST @CLRVEC(B)		;Do any special stuff

;ENTRY TO ABOVE FOR NON-INTERRUPT CODE

CLRDT0:	NOSKED
	CHNOFF DLSCHN		;TURN OFF MACHINE
	CALL CLRDTE		;PROCESS QUEUES
	CHNON DLSCHN
	OKSKED			;TURN ON MACHINE
	RET			;AND DONE

;SPECIAL ENTRY FOR THE SCHEDULER

CLRDTF:	CHNOFF DLSCHN		;TURN OFF CHANNEL
	SETZRO DTERL,(A)	;MAKE IT DO IT
	CALL CLRDTE		;CLEAR OUT THE ENTRIES
	SETONE DTERL,(A)	;RESTORE BIT
	CHNON DLSCHN		;RESTORE CHANNEL
	RET			;AND DONE

;CLRDTE continued. Handle to -10 in progress here

;CLRVEC:	IFIW!R			;20F
;	IFIW!CLRMCB		;For MCB
;	IFIW!R			;For DN60

;Here if a to -10 was inp progress when "clear" was requested for MCB

;CLRMCB:	EA.ENT			;DECNET AND ALL OTHER USERS OF THE
;				;INTERFACE RUN IN SECTION MUMBLE
;	SETZ B,
;	EXCH B,DTEIND(A)	;GET BUFFER ADDRESS IF ANY
;	RETSKP

	SUBTTL I/O Page Fail
;ROUTINE CALLED FROM APRSRV WHEN A DTE CAUSES AN IO PAGE FAIL
;ACCEPTS:	A/ DTE NUMBER
;RETURNS:	+1 ALWAYS WITH DTE SHUT OFF

DTEIOP::CALL DTREST		;TURN OFF THE DTE
	SETZRO DTERL,(A)	;Make sure it is dead
	CALL CLRDTE		;GET RID OF ITS BLOCKS
	SETONE DTRLD,(A)	;AND SAY IT NEEDS RELOADING
	BUG.(CHK,DTEPGF,DTESRV,HARD,<DTE transfer page fail>,<<A,DTENO>>,<

Cause:	A transfer from a DTE has generated a page fail. The FE is now
	marked as dead.

Action:	Check the DTE for hardware problems.

Data:	DTENO - DTE number

>)
	AOS LOAD11		;SAY AN -11 DIED
	AOS JB0FLG		;MAKE JOB 0 SEE IT ASAP
	RET			;AND DONE
	SUBTTL DTECHK - Periodic Check

;THIS ROUTINE PERFORMS LOST INTERRUPT POLLING FOR THE DTE20 DEVICES.
;IT IS STARTED PERIODICALLY TO LOOK FOR ANY ANAMOLOUS CONDITIONS
;ON THE DTE'S.

DTECHK::SKIPN FEFLG		;IN SECONDARY PROTOCOL?
	JRST DTCHK2		;NO, DON'T POLL THEN
	SAVEQ			;SAVE PERMANENT REGS
	STKVAR <PRCONI>		;PROTOTYPE CONI
	MOVSI A,-DTEN		;NUMBER OF DTE'S IN CONFIGURATION
	MOVE B,[CONI DTE0,D]	;THE CONI
	MOVEM B,PRCONI		;SAVE IT
DTPOL1:	CHNOFF DLSCHN		;prevent state changes.
	JE DTERL,(A),DTPOL2	;DONT POLL NON-EX DEVICE
	HRRZ B,A		;GET DTE NUMBER
	IFQN. DTRLD,(A)
	  CAMN B,MSTRDT 	;BEING RELOADED - IS THIS THE MASTER?
	  CALL CLRDTF 		;YES. KEEP EVERYBODY MOVING
	  JRST DTPOL2		;AND GO ON
	ENDIF.
	CAME B,MSTRDT		;IS THIS THE MASTER?
	IFSKP.
	  XCT PRCONI		;YES. GET CONI BITS
	  TXNE D,DTEPF		;POWER FAILING?
	  JRST DTPOL2		;YES. DON'T POLL IT NOW THEM
	  SKIPE FEDBSW		;NO. WANT RELOADS?
	  JRST DTPL10		;NO. DON'T LOOK THEN
	ENDIF.
	CALL SETRGN		;GO FIND APPROPRIATE COMM REGIONS
	SUBI D,COMDAT		;GET POINTER TO -11'S OWNED AREA
	LOAD B,CMKAC,(D)	;GET HIS KEEP ALIVE COUNTER
	LOAD D,CMKAK,(C)	;GET MY COPY OF LAST ONE
	CAME B,D		;SAME?
	JRST DTPOL9		;NO. ALL IS OK
	IFQE. DTKAC,(A)		;IF FIRST TIME,LET HIM GO
	  SETONE DTKAC,(A) 	;BUT REMEMBER THIS TRANSGRESSION
	  JRST DTPL10		;AND GO ON
	ENDIF.
	;...

	;...
;HERE WHEN RELOADING A FRONT END
	HRRZ B,A		;ISOLATE DTE NUMBER
	BUG.(INF,DTEKPA,DTESRV,SOFT,<DTE keep alive fail>,<<B,DTENO>>,<

Cause:	The DTE keep alive counter is not being updated by the 11.

Action:	Check the 11 to see if it is running properly.

Data:	DTENO - DTE number
>,,<DB%NND>)			;[7.1210]
	CAMN B,MSTRDT		;IS THIS THE MASTER?
	IFSKP.
	  CALL DTREST		;NO. RESET THE DTE
	  CALL CLRDTF		;CLEAR OUT THE QUEUE NOW
	  SETZRO DTERL,(A)	;AND TURN OFF PROTOCOL
	ENDIF.
	CALL LOADFE		;(A) INITIATE A RELOAD IN JOB 0
	JRST DTPOL2		;FORGET ABOUT IT FOR NOW

DTPOL9:	STOR B,CMKAK,(C)	;KEEP THIS COPY FOR NEXT TIME
	SETZRO DTKAC,(A)	;IT PASSED THE TEST
	;..

;DTECHK...

;NOW LOOK AT ITS STATE
DTPL10:	XCT PRCONI		;LOOK AT THE DTE STATE
	TRNE D,DLSCHN		;CHANNEL ASSIGNED?
	JRST DTCHK1		;YES. GO ON
	CALL DTPII		;GO SET UP PI STUFF
	HRRZ B,A		;ISOLATE DTE NUMBER
	BUG.(INF,DTELPI,DTESRV,HARD,<DTECHK - DTE lost PI assignment>,<<B,DTENO>>,<

Cause:	A CONI of the DTE has indicated it has lost it's channel assignment.

Action:	Have Field Service check the DTE.

Data:	DTENO - DTE number
>,,<DB%NND>)			;[7.1210]
DTCHK1:
   REPEAT 0,<LOAD B,DTEST,(A)	;GET DEVICE'S STATE
	TXNN B,DTE11!DTE11I	;SENDING TO -11?
	JRST DTPOL3		;NO. GO ON
	CALL SETRGN		;FIND THE COMM REGIONS
	MOVE B,D		;MOVE HIS POINTER
	XCT PRCONI		;GET STATE OF DTE NOW
	LOAD Q1,CM1IC,(B)	;HIS TO 11 COUNT
	LOAD C,CM1IC,(C)	;MY TO 11 COUNT
	CAMN C,Q1		;SAME?
	JRST DTPOL4		;YES. GO SEE IF TRANSFER IS OK
	TXNE D,DTEEDB		;IS -11 DOORBELL UP?
	JRST DTPOL3		;YES. ASSUME IT WILL FIND IT
	CALL DING11		;RING IT AGAIN
	BUG.(INF,DTELDB,DTESRV,HARD,<DTECHK - 11 lost doorbell>,,<

Cause:	The DTE's TO -11 count disagrees with our TO -11 count. TOPS-20 is
	ringing the 11's doorbell.
>,,<DB%NND>)			;[7.1210]
	JRST DTPOL3		;GO TO NEXT

DTPOL4:	LOAD D,CMVRR,(B)	;GET PROTOCOL VERSION
	CAIN D,.VN20F		;RSX20F?
	JRST DTPOL3		;YES. DONE WITH POLLING THEN
	JN CMTOT,(B),DTPOL3	;IF IN TRANSIT, OK.
	XCT PRCONI		;GET DEVICE STATE AGAIN
	TXNE D,DTEEDN		;NOT IN TRANSIT. IS FLAG UP?
	JRST DTPOL3		;YES. ASSUME WE WILL SEE THE INTERRUPT
	BUG.(INF,DT11DN,DTESRV,HARD,<DTECHK - 10 lost TO11DN interrupt>,,<

Cause:	This BUG is not documented yet.


>)
	PUSH P,A		;SAVE DTE POINTER
	CALL TO11DN		;GO FAKE THE INTERRUPT
	POP P,A			;RESTORE POINTER
   >				;END OF REPEAT 0

DTPOL3:	JN DTBLK,(A),[	SETZRO DTBLK,(A) ;CLEAR INDICATOR
			PUSH P,A	;SAVE AOBJN WORD
			MOVEI A,0(A)	;GET DTE NUMBER ONLY
			CALL DOFRGM ;IF BLOCKED. TRY NOW
			POP P,A	;RESTORE AOBJN POINTER
			JRST .+1] ;AND GO ON
DTPOL2:	CHNON DLSCHN		;REENABLE CHANNEL
       	MOVX B,4B11		;NEXT DTE
	ADDM B,PRCONI		;NEXT DTE FOR THE CONI
	AOBJN A,DTPOL1		;DO ALL DTE'S
DTCHK2:	MOVEI A,^D5000		;NEXT CHECK IN 5 SECS
	MOVEM A,DTETIM		;TO THE TIME CELL
	RET			;AND DONE

;REQUEST RELOAD OF A FRONT-END
; T1/ DTE NUMBER
;	CALL LOADFE		;(T1)
;(T1) RETURNS +1: ALWAYS, REQUESTS RELOAD BY JOB 0
;Or, 	CALL LODCFE
; Returns +1: Always, requests reload of console FE.

LODCFE::MOVE T1,MSTRDT		;FOR THE MASTER DTE PLEASE...
LOADFE::SETONE DTRLD,(A) 	;SET RELOAD FLAG
	AOS LOAD11		;TELL JOB 0 OF RELOAD
	AOS JB0FLG		;SCHEDULE JOB 0
	RET
	SUBTTL

;ROUTINE CALLED FORM JOB 0 TO SEE IF ANY DTE'S NEED ATTENTION

	SWAPCD			;PART OF JOB 0

DTEPOL::CALL DTJZC1		;DO CHECKS 1-4
	CALL DTJZC2
	CALL DTJZC3
	CALL DTJZC4
	CALL DTJZCD		;CHECK STATE OF DBUGSW
	RET

;SEE IF DBUGSW HAS CHANGED SUCH THAT WE NEED TO TELL FE

DTJZCD:	SKIPE T1,DBUGSW		;MONITOR IN DEBUG MODE?
	SETO T1,		;YES
	XOR T1,FEDBST		;SAME AS FE NOW?
	JUMPE T1,R		;RETURN IF YES
	MOVSI T2,.DFDBN		;DEBUG ON FUNCTION
	SKIPN DBUGSW		;NOW DEBUGGING?
	MOVSI T2,.DFDBF		;NO, DEBUG MODE OFF
	MOVE T1,MSTRDT		;SEND MESSAGE
	SETZ T3,		;DIRECT
	CALL DTEQ
	 RET			;COULDN'T SEND, TRY AGAIN LATER
	SETCMM FEDBST		;REMEMBER FE STATE TOGGLED
	RET

;CHECK STATUS OF LOAD FORK IF PRESENT

DTJZC1:SKIPN A,LODFRK		;HAVE A FORK NOW?
	JRST DTPOL8		;NO
	RFSTS			;YES. GET ITS STATUS
	HLRZS A			;ONLY LH PLEASE
	CAIE A,2		;HALTED?
	CAIN A,3		;OR AN ERROR?
	SKIPA A,LODFRK		;YES
	JRST DTPOL8		;NO. GO ON
	KFORK			;KILL IT
	SETZM LODFRK		;AND THE HANDLE
	SETOM RLDFRK		;NO RELOAD FORK NOW
DTPOL8:	RET

;CREATE FORK TO LOAD FE IF NECESSARY

DTJZC2:	SKIPE LOAD11		;-11'S TO LOAD?
	SKIPE LODFRK		;YES. A FORK TO DO IT?
	JRST DTPOL7		;DON'T CREATE ANOTHER
	MOVX A,1B1		;SET CAPABILITIES TO WHEEL
	SETZ B,			;NO START ADDRESS
	CFORK			;GET ONE
	 JRST DTPOL7		;FAILED WAIT TILL NEXT TIME
	MOVEM A,LODFRK		;THE ID
	MOVE B,[MSEC1,,RELOAD]	;START ADDRESS
	MSFRK			;START IT IN MONITOR MODE
DTPOL7:	RET

;DO "CONTINUED" MESSAGE IF NECESSARY

DTJZC3:	SKIPN LOAD11		;ALL -11'S DONE RELOADING?
	SKIPN A,UPFLAG		;DO WE NEED A CONTINUE MESSAGE?
	JRST DTPL87		;NO . GO ON THEN
	TRZN A,1		;WANT A MESSAGE?
	JRST DTPL87		;NO
	JUMPGE A,[MOVSI A,(1B0)	;IS FIRST TIME
		MOVEM A,UPFLAG	;NEXT TIME WILL DO IT
		JRST DTPL87]	;AND DONE
	MOVEM A,UPFLAG
	SKIPE DBUGSW		;DEBUG MODE?
	JRST DTPL87		;YES, NO MESSAGE
	MOVNI A,2		;[7.1056] Send to all console front end lines
	HRROI B,[ASCIZ /
[DECSYSTEM-20 continued]
/]
	TTMSG			;TELL THE WORLD
	 ERJMP .+1		;IN CASE OF REFUSAL
DTPL87:	RET

;SEND TIME TO FE'S IF NECESSARY

DTJZC4:	SKIPE B,TAD11		;HAVE A TIME?
	CAMN B,[-1]		;?
	JRST DTPL88		;NO . GO ON
	DMOVE C,TAD11+1		;YES. GET REST OF IT
	IDCNV			;GET INTERNAL FORMAT
	 JRST DTPL89		;TIME IS BAD. INFORM HIM
	PUSH P,B		;SAVE THE TIME
	CALL LGTAD		;GET SYSTEM'S TIME
	POP P,B			;GET -11'S TIME
	CAME A,[-1]		;HAVE A TIME YET?
	SKIPN DBUGSW		;DEBUGGING?
	SKIPA			;NO. MUST CHECK THE TIME THEN
	JRST DTPL88		;YES. SKIP SETTING IT
	CAMLE A,B		;NO. NEED TO SET THE TIME?
	JRST DTPL89		;NO. SKIP SETTING IT
	MOVE A,B		;GET THE TIME
	STAD			;AND SET IT
	 JFCL
	JRST DTPL88		;GO DO REST

DTPL89:	MOVE A,MSTRDT		;TELL MASTER HE IS WRONG
	SETONE DT1TM,(A)	;TELL HIM NOW
DTPL88:	SETOM TAD11		;NO TIME
	SKIPE TO11TM		;TIME PACKET AVAILABLE?
	RET			;NO. NO SENSE LOOKING THEN
	SAVEPQ			;YES. SAVE ALL REGS
DTPOL6:	MOVE A,MSTRDT		;GET MASTER -11
	JE DT1TM,(A),DTPOL5	;-11 WANT TIME?
	SETZRO DT1TM,(A)	;SAY HE GOT IT

;-11 WANTS TIME OF DAY AND PACKET IS FREE

	SETOM TO11TM		;IN USE
	SETO B,			;GET CURRENT LOCAL TIME
	SETZ D,			;SAY TO USE LOCAL TIME ZONE
	ODCNV			;""
	HLRZ A,B		;GET YEAR
	DPB A,[POINT ^D16,TO11TM,31] ;STORE YEAR
	MOVE P1,[POINT ^D8,TO11TM+1] ;WHERE REST IS GOING
	IDPB B,P1		;STORE MONTH
	HLRZ A,C		;GET DAY OF MONTH
	IDPB A,P1		;STORE IT
	IDPB C,P1		;DAY OF WEEK
	LOAD C,IC%TMZ,D		;GET TIMEZONE
	TXNE D,IC%ADS		;DST IN EFFECT?
	TRO C,1B28		;YES - SET FLAG
	IDPB C,P1		;STORE INDICATOR
	LSH D,-1		;DIVIDE SECONDS BY 2
	DPB D,[POINT ^D16,TO11TM+2,15];SECONDS SINCE MIDNIGHT
	MOVSI A,TM1DON		;POSTING ROUTINE
	HRR A,MSTRDT		;DTE NUMBER
	MOVSI B,.DFHTD		;HERE IS TIME FUNCTION
	MOVEI C,^D10		;NUMBER OF BYTES IN MESSAGE
	MOVE D,[POINT ^D8,TO11TM] ;BYTE POINTER
	CALL DTEQ		;Q THE REQUEST
	 JFCL			;WILL GO
DTPOL5:	RET			;AND DONE

	RESCD			;MUST BE RESIDENT

;ROUTINE TO POST TIME SENT TO -11

TM1DON:	SETZM TO11TM		;SAY TIME PACKET IS FREE
	RET			;AND DONE

;ROUTINE CALLED FROM STAD JSYS TO ARRANGE FOR TIME TO BE SENT TO
;ALL 11'S.

	SWAPCD			;IS SWAPPABLE
DTTIME::MOVSI A,-DTEN		;FORM AOBJN WORD
DTTIM2:	JE DTERL,(A),DTTIM1	;IF NOT EXISTANT, DON'T DO IT
	SETONE DT1TM,(A)	;SAY HE NEEDS THE TIME
DTTIM1:	AOBJN A,DTTIM2		;DO ALL DTE'S
	RET			;AND DONE


;ROUTINE CALLED BY JOB 0 TO COMPLETE A SYSERR PACKET.
;ARGS ARE:
;	1/ POINTER TO PACKET
;RETURNS +1 ALWAYS WITH REMAINDER OF INFO FILLED IN
;CALLS DEVICE DEPENDENT ROUTINES TO GET THE OWNING FORK. CALL IS
;	CALL DEVICE-DEPENDENT-ROUTINE
;WITH:
;	B/ UNIT,,DEVICE
;RETURNS:
;	+1/NO OWNING PROCESS (AT LEAST, NOT NOW)
;	+2/SUCCESS WITH 1=OWNING PROCESS ID

	SWAPCD			;IS SWAPPABLE

SEEER2:	HRRZ B,FE%DEV+SEBDAT(A)	;GET DEVICE CODE
	CAIL B,MINDEV		;A KNOWN DEVICE?
	CAILE B,MAXDEV		;?
	JRST SEEER6		;UNKNOWN
	SKIPE C,DTEDTV(B)	;HAVE A TRANSFER VECTOR?
	SKIPN C,DTVSER(C)	;THIS DEVICE PREPARED?
SEEER6:	JRST [	MOVSI C,(1B0)	;UNKNOWN BIT
		IORM C,FE%DEV+SEBDAT(A) ;SET IT
		JRST SEEER4]	;GO SAY NO FORK,,JOB
	PUSH P,A		;SAVE BLOCK
	CALL 0(C)		;GET INFORMATION
	 JRST [	POP P,A		;CLEAN UP THE STACK
		JRST SEEER4]	;AND ASSUME UNKNOWN
	MOVE B,A		;FORK #
	POP P,A			;BLOCK
	CAIN B,-1		;UNASSIGNED?
	JRST [	HRLS B		;YES. PROPOGATE THE -1
		MOVEM B,FE%FJB+SEBDAT(A) ;SAY IS UNASSIGNED
		JRST SEEER5]	;AND GO WRAP UP
	LOAD C,FKJO%,(B)	;GET JOB #
	HRLI C,0(B)		;FORK
	MOVEM C,FE%FJB+SEBDAT(A);STORE IN BLOCK
	HRRZS C			;MAKE INDEXED REF WORK IN SECTION 1
	MOVE B,JOBDIR(C)	;GET DIRS
	HRLI B,USRLH		;SET UP A USER NUMBER
	MOVEM B,FE%DIR+SEBDAT(A);TO THE BLOCK
	MOVE B,JOBPNM(C)	;GET NAME
	MOVEM B,FE%NAM+SEBDAT(A);TO THE BLOCK
SEEER5:	MOVEI B,FE%INF		;START OF ERROR WORDS
	HRRM B,FE%PTR+SEBDAT(A);TO THE BLOCK
	SETZM FE%ID+SEBDAT(A)	;NO VERSION NUMBER YET
	RET			;AND DONE

SEEER4:	MOVE C,[-2,,-2]		;UNASSIGNED
	MOVEM C,FE%FJB+SEBDAT(A);SAY SO
	JRST SEEER5		;GO FINSISH THE SETUP

;THIS CODE IS A COLLECTION OF SUBROUTINES USED TO RELOAD AN -11.

;ROUTINE TO INITIATE ROM BOOT AND OPTIONALLY DUMP OR LOAD THE -11
;ACCEPTS:	A/FLAGS,, DTE #
;FLAGS ARE: GRONK/DON'T GRONK ROM
;		B/ COROUTINE ADDRESS FOR DUMPING
;		  IF B=0, NO DUMP
;		C/ COROUTINE ADDRESS TO GET NEXT PAGE TO LOAD
;		 IF C=0 NO LOAD WILL BE DONE
;		D/ ERROR ROUTINE IF LOAD OR DUMP FAILED (FOR UNLOCKING PAGES)

;RETURNS:	+1 FAILED. A CONTAINS THE CODE FOR THE FAILURE
;				-1 MEANS NO SUCH DTE
;		+2 SUCCESS. DUMP IS TAKEN AND BOOT IS ACTIVATED
;NOTE: THIS ROUTINE MUST HAVE RESET THE DTE AND INTERLOCKED THE
;BOOT LOCK
;NOTE SOME MORE: THE COROUTINES ARE CALLED WITH THE Q REGISTERS
;INTACT. THAT IS, Q1,Q2, AND Q3 WILL HAVE WHAT THE CALLER OF
;RMGRNK PUT IN THEM. THIS IS USEFUL FOR PASSING ARGS TO THE COROUTINES

;COROUTINES WORK AS FOLLOWS:
;RETURNS	+1 IF NO MORE TO DO. AC1=0 SAYS NO EXTRA DOORBELL
;		+2 MORE TO DO. IF LOADING, AC1 CONTAINS BYTE POINTER
;			TO NEXT CHUNK OF CORE TO LOAD
;			AND AC2 CONTAINS A ZERO IF NO DOORBELL
;			WANTED AFTER BYTE POINTER IS SET UP. IF DUMPING,
;			AC1 CONTAINS COUNT OF BYTES TO DUMP, AND
;			AC2 CONTAINS BYTE POINTER.

	SWAPCD			;IS SWAPPABLE
RMGRNC:	CALL RMGRNK		;DO ACTUAL WORK
	 SKIPA			;NON-SKIP RETURN
	  RETSKP		;SKIP RETURN SO PASS IT DOWN
	CAMN 1,[-1]		;NO SUCH DTE20?
	 RET			;RIGHT
	JFFO 1,RMGLIT		;WHICH ERROR BIT IS SET?
	SKIPA			;NO ERROR BITS SET
RMGLIT: CAILE T2,NBOTER 	;MORE ERROR TYPES THAN KNOWN?
	MOVEI T2,NBOTER 	;YES, SET ERROR TO BE MOST GENERAL
	MOVE T1,BOTERR(T2)	;GET ERROR CODE
	RET

BOTERR:	BOTX06
	BOTX07
	BOTX20
	BOTX09
	BOTX10
	BOTX11
	BOTX12
	BOTX13
	BOTX14
	BOTX15
	BOTX19
	BOTX17
	BOTX08
	BOTX18		;GENERAL BOOT ERROR CODE
NBOTER==.-BOTERR-1

RMGRNK:	SAVEP			;GET PERM REGISTERS
	MOVEI P1,3		;MAX TRIES
	SETZ P2,		;NO ERRORS YET
	ASUBR <RMDTE,RMJFN,RMCORT,RMERR>
	TXNN A,RM%ROM		;WANT TO GRONK ROM?
	JRST RMWAT1		;NO. SEE ABOUT DUMPING THEN
RMGRN1:	HRRZ A,RMDTE		;GET DTE NUMBER AGAIN
	CALL DTREAL		;GO VERIFY DTE EXISTS
	 JRST [	SETOM T1	;NO SUCH DTE
		RET ]		;RETURN FAILURE
	MOVE B,DATO(A)		;GET DATAO WORD
	IORI B,C		;DATA IS IN C
	SETZM C			;CLEAR BYTE COUNT REG
	XCT B			;DO IT
	MOVE B,CNDO(A)		;GET PROTOTYPE CONO
	IORI B,DTEPIE		;FIRST, TURN OFF PI0 TO RESET THE DTE
	XCT B			;""
	IORI B,DTESER!DTEPIE!DTEPI0 ;THE RELOAD INDICATOR AND PI
	XCT B			;SET THE RELOAD INDICATOR
	MOVEI B,PWRDN1		;TIME TO COMPLETE POWER-FAIL
	ADD B,TODCLK		;ABSOLUTE TIME WHEN IT IS OVER
	CAML B,TODCLK		;READY?
	JRST .-1		;NO. KEEP WAITING

;ROM SHOULD BE READY FOR US NOW

	MOVE B,CNDO(A)		;GET A CONO WORD AGAIN
	IORI B,DTECER		;CLEAR RELOAD BIT
	XCT B			;TURN OFF RELOAD

;NOW PUT A MAGIC NUMBER IN BYTE COUNT REGISTER SO ROM CAN FIND US

	MOVE B,A		;GET DTE NUMBER
	LSH B,SDTE		;GET TO EPT OFFSET
	SETZM DTETBP(B)		;CLEAR TO -10 BYTE POINTER WORD
	MOVE B,DATO(A)		;GET A DATAO WORD
	IORI B,C		;MAGIC NUMBER WILL BE IN C
	MOVEI C,MAG11N		;THE MAGIC NUMBER
	XCT B			;DO IT
	CALL DING11		;AND RING -11'S DOORBELL
	MOVE P3,[CONSO DTE0,DTEEDB] ;TEST WORD
	LSH A,^D26		;POSITION DTE #
	ADD P3,A		;GET PROPER I/O WORD
	HRRZ A,RMDTE		;RESTORE A
	MOVEI B,ROMTIM		;TIME FOR ROM TO MAKE IT
	ADD B,TODCLK		;ABSOLUTE TIME
RMWAT0:	XCT P3			;IS DOORBELL STILL UP?
	JRST RMWAT1		;NO. ROM RESPONDED
	CAML B,TODCLK		;IS TIME UP YET?
	JRST RMWAT0		;NO. TRY AGAIN
	TXO P2,.R1RMF		;NO ROM RESPONSE
RMTRY:	MOVX A,RM%ROM		;MAKE SURE WE CAN RETRY
	TDNE A,RMDTE		;CAN WE REGRONK ROM?
	SOJG P1,RMGRN1		;YES, GO TRY AGAIN
RMTRY1:	HRRZ A,RMDTE		;ERROR-- GET BACK DTE #
	CALL DTREST		;RESET DTE PI0 ENABLE
	MOVE A,P2		;GET ERROR INIDCATION
	RET			;AND RETURN FAILURE

;ROM IS PROPERLY INITIALIZED HERE. TRY DOING THE BOOT

RMWAT1:	SETZ P4,		;INIT COROUTINE COUNTER
RMWAT2:	SKIPN B,RMJFN		;A DUMP ROUTINE GIVEN?
	JRST RMLOAD		;NO. DON'T DO THE DUMP THEN
	MOVEI A,0(P4)		;ARG TO COROUTINE
	CALL 0(B)		;CALL THE DUMP COROUTINE
	 JRST [	SETZM RMJFN	;DON'T DO DUMP ON RETRY
		CALL CHKBEL	;SEE IF A BELL IS NEEDED
		JRST RMLOAD]	;AND GO SEE ABOUT LOADING

;COROUTINE RETURNED WITH:
;		A/ COUNT OF WORDS TO DUMP
;		B/ BYTE POINTER TO USE

	MOVE C,A		;PUT COUNT INTO C
	HRRZ A,RMDTE		;GET DTE NUMBER
	CALL DODUMP		;TRY DUMPING THIS BUNCH
	 JRST [	TXO P2,.R1DPF	;DUMP ABORTED
		TDO P2,A	;ADD IN BITS FROM DODUMP
		SETO A,		;SAY FAILURE IS FROM THE DUMP
		SKIPE B,RMERR	;WANT ERROR POSTING?
		CALL 0(B)	;YES. DO IT
		SKIPN RMCORT	;WANT TO LOAD IT TOO?
		JRST RMTRY1	;NO. ERROR OUT NOW THEN
		SETZM RMJFN	;DON'T TRY DUMP AGAIN
		JRST RMTRY]	;AND TRY, TRY AGAIN
	AOJA P4,RMWAT2		;GO DO NEXT PIECE OF DUMP


;ROUTINE CALLED BY DUMP AND LOAD CODE TO SEE IF A BELL IS NEEDED
;AFTER COMPLETION.
;ACCEPTS:	A/ 0 = NO BELL
;		RMDTE CONTAINS DTE NUMBER

CHKBEL:	JUMPE A,R		;IF NO BELL NEEDED, RETURN
	HRRZ A,RMDTE		;GET DTE NUMBER
	CALLRET DING11		;AND GO RING THE BELL

;-11 IS NOW DUMPED. SEE IF A LOAD IMAGE IS NEEDED

RMLOAD:	SETZ P4,		;ARG TO COROUTINE
RMLOD0:	SKIPN B,RMCORT		;HAVE A ROUTINE TO DO?
	RETSKP			;NO. RETURN
	HRRZ A,RMDTE		;GET DTE NUMBER
	MOVE C,CNDO(A)		;GET A CONO WORD
	IORI C,DTEEDN		;GET TEST BITS
	XCT C			;TURN OFF TEST BITS
	MOVE A,P4		;TELL COROUTINE WHICH CALL THIS IS
	CALL 0(B)		;GO GET NEXT PAGE
				;RETURNS A=EXEC VIRT ADDRESS
				; B=0 IF NO DOORBELL AFTER SETUP
	 JRST [	CALL CHKBEL	;SEE IF BELL IS NEEDED
		RETSKP]		;AND DONE
	MOVE C,A		;SAVE POINTER
	HRRZ A,RMDTE		;GET DTE NUMBER AGAIN
	LSH A,SDTE		;FIND THE EPT
	MOVEM C,DTEEBP(A)	;PUT CORRECT BYTE POINTER IN EPT
	HRRZ A,RMDTE		;DTE AGAIN
	SKIPE B			;WANT A DOORBELL AFTER SETUP
	CALL DING11		;GO START TRANSFER
	MOVEI B,BUTTIM		;TIME FOR THE PAGE TO CLEAR
	ADD B,TODCLK		;WHEN IT MUST BE DONE
	MOVE P3,CNDO(A)		;GET A CONO WORD
	TXO P3,<<CONSO 0>-<CONO 0>+DTEEDN+DTEEER> ;MAKE IT A CONSO WORD
RMDNL1:	XCT P3			;DONE YET?
	JRST [	CAML B,TODCLK	;NO. TIME UP?
		JRST RMDNL1	;NO. KEEP WAITING
		XCT P3		;did function complete ?
		SKIPA		;no report error
		JRST .+1	;yes it did finally finish after all !!
		CALL CLR11B	;YES. CLEAR BYTE POINTER
		TXO P2,.R1BSF	;ERROR CODE
		JRST RMLERR]	;AND GIVE ERROR
	TXZ P3,DTEEDN		;FINISHED. SEE IF SUCCESSFUL
	CALL CLR11B		;CLEAR BYTE POINTER
	XCT P3			;WAS IT AN ERROR
	AOJA P4,RMLOD0		;NO, GO SEE IF MORE LOAD WANTED
	TXO P2,.R111E		;SAY ERROR
RMLERR:	SETZ A,			;SAY ERROR OCCURRED ON LOAD
	SKIPE B,RMERR		;WANT ERROR NOTICE?
	CALL 0(B)		;YES. DO IT
	JRST RMTRY		;GO TRY WHOLE THING AGAIN

;LOCAL ROUTINE TO CLEAR TO -11 BYTE POINTER IN THE EPT.

CLR11B:	SAVEAC <A>		;SAVE ALL REGS
	HRRZ A,RMDTE		;GET DTE #
	LSH A,SDTE		;COMPUTE EPT REGION FOR THIS DTE
	SETZM DTEEBP(A)		;ZERO THE BYTE POINTER
	RET			;AND DONE


;PROCESS RUN BY JOB 0 TO RELOAD THE MASTER -11.

	SWAPCD			;IS SWAPPABLE

;TEMPORARY CODE TO FIGURE OUT WHY KILPAG IS GETTING CALLED FROM SECTION 0
   IFN DTESW,<
JHTEST:	PUSH P,CX
	MOVX CX,VSECNO
	TDNN CX,-1(P)		;DIE IF RUNNING IN SECTION 0
	JSR BUGHLT
	POP P,CX
	RET
   >				;END OF IFN DTESW

RELOAD:	MOVX A,UMODF
	MOVEM A,FFL		;SIMULATE CALL FROM USER MODE
	MCENTR			;ENTER MONITOR CONTEXT
	MOVE A,FORKX		;GET OUR FORK HANDLE
	MOVEM A,RLDFRK		;AND REMEMBER IT FOR LATER
	MOVX A,RLDPRI		;GET SPECIAL PRIORITY WORD FOR RELOAD
	MOVEM A,JOBBIT		;FOR REMAINDER OF RELOAD
RELOD2:	MOVE A,MSTRDT		;GET ID OF MASTER
	JN DTRLD,(A),RELOD1	;FOUND ONE
	MOVSI A,-DTEN		;NOW CHECK ALL OF THE OTHERS AS WELL
RELOD3:	JE DTRLD,(A),RELOD4	;THIS ONE NEED ATTENTION?
	HRRZ B,A		;YES, GET DTE # ONLY
	CAMN B,MSTRDT		;DID THE MASTER DIE AGAIN?
	JRST RELOD1		;YES. GO DO IT NOW
	PUSH P,A		;NO.
	CALL SETRGN		;Set up regions so we can get protocol type
	LOAD C,CMVRR,(C)	;Get protocol version
	SKIPN DTBUGX		; Skip this if we aren't interested
	CAIE C,MCPRON		;If DECnet, no buginf
	 BUG.(INF,DN20ST,DTESRV,HARD,<DTESRV - DN20 stopped>,<<B,DTENO>>,<

Cause:	A DN20 has crashed.

Action:	Reload the DN20.

Data:	DTENO - DTE number
>,,<DB%NND>)			;[7.1210]
	LSH B,SDTE		;GET EPT OFFSET
	SETZM DTEEPW(B)		;CLEAR "VALID EXAMINE"
	CALL CLRDT0		;CLEAR OUT THE QUEUES
	CALL RELODR		;INFORM APPROPRIATE MONITOR ROUTINES
	POP P,A			;GET BACK REG
	SETZRO <DTRLD,DTKAC>,(A) ;TURN OFF ATTENTION BITS
RELOD4:	AOBJN A,RELOD3		;SCAN THEM ALL
	SETZM LOAD11		;ALL DONE
	AOS JB0FLG		;MAKE JOB 0 SEE HALTED STATE ASAP
	HALTF			;NONE LEFT. ALL DONE

;RELOAD MASTER -11. REGISTER USAGE AS FOLLOWS:
;	Q1/ OFN,,JFN OF DUMP FILE (PASSED TO RELODD BY RMGRNK)
;	Q2/ -11 ERROR WORDS RETURNED BY RELODD IF DUMP SUCCEEDED
;	Q3/ CUMULATIVE ERROR REGISTER
;	P5/ RETRY COUNT

RELOD1:
   IFN DTESW,<
	CALL JHTEST
   >				;END OF IFN DTESW
	SETZRO DTERL,(A)	;BE SURE NOT RUNNING A PROTOCOL
	CALL CLRDT0		;FLUSH SCHEDULING QUEUE
	SETZB Q3,Q2		;CLEAR STATUS AND ERROR WORDS
	MOVE A,MSTRDT		;GET BACK DTE #
	MOVEI P5,3		;MAX TRIES
	CALL FNDFIL		;GO GET JFN AND OFN FOR THE DUMP FILE
	 JRST [	TXO Q3,.R1DPF	;THE DUMP WON'T BE DONE
		SETZ P1,	;NO JFN
		JRST .+1]	;GO INLINE
   IFN DTESW,<
	CALL JHTEST
   >				;END OF IFN DTESW
	HRR Q1,P1		;Q1 NOW HAS OFN,,JFN

;READY TO GRONK THE ROM.

RELODA:	MOVEI B,RELODD		;DUMP COROUTINE
	CAIN P5,3		;IS THIS THE FIRST TIME?
	SKIPN P1		;HAVE A JFN FOR DUMPING?
	SETZ B,			;NO. DON'T DO THE DUMP THEN
	MOVEI C,RELODL		;ADDRESS OF LOAD ROUTINE
	MOVEI D,RELODE		;ERROR ADDRESS
	TXO A,RM%ROM		;MUST DO ROM BOOT
	SETZM DTECMD		;CLEAR SECONDARY PROTOCOL COMMAND WORD
   IFN DTESW,<
	CALL JHTEST
   >				;END OF IFN DTESW
	CALL RMGRNK		;GO GRONK THE ROM
RELODF:	 JRST [	MOVE Q3,A	;SAVE ERROR FLAGS
		SOJG P5,RELODA	;TRY AGAIN, MAYBE
		MOVE A,MSTRDT	;THE DTE NUMBER
		CALL RELOD7	;GO DO SYSERR
		AOS JB0FLG	;MAKE JOB 0 RUN NOW
		MOVEI A,^D1000
		DISMS		;WAIT HERE FOR IT TO RUN AND DO SYSERR
		AOS SHLTW	;AND STOP SYSTEM
		HALTF]		;DONE
	; ..

	; ..
;RELOAD OF THE -11 IS NOW IN PROGRESS. DO PROTOCOL INIT

	MOVE A,MSTRDT		;THE -11 NUMBER
   IFN DTESW,<
	CALL JHTEST
   >				;END OF IFN DTESW
	CALL KILPAG		;GO PURGE THE BUFFER PAGE
	MOVSI D,(<CONSO DTE0,>) ;GET A CONSO WORD
	MOVE A,MSTRDT		;THE -11 NUMBER
	LSH A,^D26		;PSOITION IT
	ADD D,A			;THE WORD
	MOVE A,MSTRDT		;DTE # AGAIN
	IORI D,DTETDB		;SET UP TO WAIT FOR A DOORBELL
	MOVEI B,DRBTIM		;TIME TO WAIT FOR RELOAD TO COMPLETE
	ADD B,TODCLK		;WHEN WAIT IS UP
RELD11:	XCT D			;WAIT
	JRST [	CAML B,TODCLK	;WAIT SOME MORE?
		JRST RELD11	;YES
		TXO Q3,.R1NRL	;NO RELOAD
		SOJG P5,RELODA	;SEE IF WE SHOULD TRY AGAIN
		MOVE A,Q3	;FLAGS
		JRST RELODF]	;NO. FAIL!!!!!!

	CALL DTREST		;GO RESET THE DTE
	MOVEI B,.VN20F		; FOR RSX20F PROTOCOL
	CALL DTINIT		;GO INIT THE COMM REGIONS
	CALL RELOD7		;GO DO SYSERR
	MOVE A,MSTRDT		;RECOVER DTE NUMBER
	JN DTRLD,(A),RELOD2	;IF WANTS RELOAD AGAIN, GO DO IT NOW
	CALL RELODR		;INFORM REST OF MONITOR
	MOVX A,GJ%OLD!GJ%SHT!GJ%PHY
	HRROI B,SETSPD
	MOVEI C,1		;[7.1235] Offset 1 in entry vector
	SETZM D			;DO NOT RECORD FORK NUMBER
	CALL RUNDII		;GO SET DEFAULT SPEEDS AGAIN
	 IFN DTESW,<
	  BUG.(HLT,SETSPF,DTESRV,SOFT,<SETSPD failed to run correctly after FE reload>,,<

Cause:	SETSPD failed to run correctly after a FE reload. 

Action:	Report this bughlt to software engineering.

>)
>				;END OF DTESW
	 JFCL			;CAN'T HELP IT
	SKIPN C,KLIDTA		;HAVE ANY KLINIK DATA?
	JRST RELOD2		;NO,GO WRAP UP
	HRRZ A,MSTRDT		;YES. GET I.D. OF MASTER
	MOVSI B,.DFKLS		;GET FUNCTION TO SEND KLINIK DATA
	MOVE D,[POINT ^D8,KLIDTA+1] ;GET KLINIK DATA BASE POINTER
	CALL DTEQ		;GO SEND THE KLINIK DATA
	 JFCL			;WILL GO
	JRST RELOD2		;AND GO WRAP UP

;ROUTINE OF RELOAD TO INFORM APPROPRIATE MONITOR DRIVERS OF THIS RELOAD.
;	A/ DTE #

RELODR:	HRRZS A			;GET DTE #
	ASUBR <DTENBR>		;SAVE DTE NUMBER
	CALL SETRGN		;FIND COMM REGIONS
	LOAD B,CMVRR,(C)	;GET PROTOCOL VERSION #
	JRST @.+1(B)		;DISPATCH TO DEAD FE HANDLER
	   IFIW ! RLODR1	;RSX20F
	   IFIW ! RELMCB	;MCB
	   IFIW ! DEDD60	;DN60 (IBM)


;HERE FOR RSX20F PROTOCOL

RLODR1:	MOVSI P5,MINDEV-MAXDEV+.FECTY ;TO SEARCH DTEDTV
	HRRI P5,.FECTY+1	;START AFTER CTY
RLODR2:	MOVE A,DTENBR		;GET DTE #
	SKIPE B,DTEDTV(P5)	;THIS DEVICE EXIST?
	SKIPN B,DTVRLD(B)	;YES. WANT TO KNOW ABOUT RELOADS?
	SKIPA			;NO
	CALL 0(B)		;YES. TELL HIM
	AOBJN P5,RLODR2		;DO ALL DEVICES
	RET			;AND DONE

;HERE WHEN THE MCB FELL OVER

RELMCB:	EA.ENT			;DECNET-36 RUNS IN SECTION ONE
	MOVX B,DI.LSC		;SIGNAL LINE STATE CHANGE
	MOVX C,LS.OFF		; TO OFF
	CALLRET CALDVR		;GIVE ROUTER THE NEWS

;COROUTINES OF RMGRNK TO DO LOADING OF -11

;COROUTINE TO LOAD BOOTSTRAP

RELODL:	JUMPG A,[CALL UNLPAG	;IF NOT FIRST TIME, UNLOCK PAGE
		CALLRET RTRUE]	;AND GET A FINAL BELL
	CALL LOKPAG		;GO LOCK DOWN BOOT PAGE
	MOVE B,[DTERBT,,DTERBT+1]
	SETZM DTERBT		;SET UP TO CLEAR REBOOT PAGE
	BLT B,DTERBT+1_PGSFT-1	;ZAP THE WHOLE PAGE
	MOVE A,MSTRDT		;GET DTE NUMBER
	CALL CLRBEL		;TURN OFF TO -10 DOORBELL
	CALL SETRGN		;FIND COMM REGIONS
	DMOVE A,[12700,,0	; MOVE #0,R0
		137,,173034]	; JMP 173034 (A MAGIC ADDRESS)
	LOAD C,CMRLF,(C)	;GET RELOAD FLAGS
	TXZ C,7			;TURN OFF RELOAD -10 FLAGS
				; AND SWITCH REGISTER REQUEST
	HRRI A,4(C)		;TO THE BOOT PROGRAM
				; AND TURN ON NO -10 REBOOT BIT
	DMOVEM A,DTERBT		;TO THE PAGE
	TXNE A,DSK11		;IS THIS AN RP REBOOT?
	JRST [	MOVE B,[DSKRBT,,DTERBT] ;YES. MOVE PORT CONTENTION
				; CODE IN FIRST
		BLT B,DTERBT+DSKPSZ-1 ;MOVE IT ALL
		HRRM A,DTERBT	;STICK IN THE UNIT STUFF
		JRST .+1]	;ALL READY TO GO
	MOVE A,[POINT ^D18,DTERBT] ;GET POINTER TO BOOT CODE
	SETO B,			;AND RING DOORBELL AFTER SETUP
	RETSKP			;AND GO BOOT IT

;ROUTINE TO LOCK DOWN DTERBT

LOKPAG:	NOINT			;NO INTERRUPTS WITH LOCK LOCKED
	LOCK BTLOCK		;LOCK THE BOOT PAGE
	MOVEI A,DTERBT		;THE PAGE
	MOVES 0(A)		;CREATE IT
	CALL FPTA
	CALL MLKPG		;AND LOCK IT
	RET			;DONE

;ROUTINE TO UNLOCK DTERBT

UNLPAG:	MOVEI A,DTERBT		;ADDRESS OF THE PAGE
	CALL FPTA		;GET ID
	CALL MULKPG		;GO DO IT
;DN20'S WON'T LOAD WITH THE FOLLOWING LINE
;	CALL KILPAG		;CLEAN UP ADDRESS SPACE
	UNLOCK BTLOCK		;NO LONGER OWN PAGE
	OKINT			;PERMIT INTERRUPTS AGAIN
	RET			;RETURN

;ERROR ROUTINE

RELODE:	CALL UNLPAG		;FREE THE PAGE
	RET			;AND DONE

;COROUTINE TO PERFORM THE DUMP OF THE MASTER -11
;ARGS:	Q1/ OFN,,JFN OF THE DUMP FILE
;	A/PAGE NUMBER

RELODD:	ASUBR <PAGENO>		;THE ARG TO THIS COROUTINE
	JUMPE A,[CALL LOKPAG	;IF FIRST TIME, LOCK DOWN PAGE
		JRST RELDD1]	;AND GO PROVIDE ARGS

;NOT THE FIRST TIME. DTERBT CONTAINS GOOD DATA, AND A CONTAINS PAGE NUMBER

	CAIN A,1		;IS THIS THE FIRST 1 K OF -11 MEMEORY?
	MOVE Q2,DTERBT		;YES. GET CODE FOR SYSERR
	NOINT
	CALL ASGPAG		;GET A WORK PAGE FOR THIS
	 JRST [	OKINT		;FAILED. ALLOW INTS AGAIN
		JRST RELODE]	;AND GIVE ERROR
	PUSH P,A		;SAVE CORE ADDRESS
	HLL A,Q1		;OFN OF THE FILE
	HRR A,PAGENO		;PAGE NUMBER OF THE FILE
	SOS A			;PAGE NUMBER FOR THE DUMP FILE
	MOVE B,0(P)		;THE TEMP PAGE WE JUST GOT
	TXO B,PA%WT!PA%RD	;NEED ACCESS
	CALL SETMPG		;MAP THE FILE TO THE PAGE
	MOVSI B,DTERBT		;WHERE THE DATA IS
	HRR B,0(P)		;THE DESTINATION
	POP P,A			;AGAIN
	BLT B,777(A)		;MOVE THE DATA
	CALL RELPAG		;RELEASE AND UNMAP THE PAGE
	OKINT			;ALLOW INTS AGAIN
	MOVE A,PAGENO		;THE PAGE NUMBER
	CAIL A,^D28		;DONE ALL OF CORE?
	JRST RELODC		;YES. GO CLOSE FILE
RELDD1:	MOVEI A,2000		;COUNT OF BYTES
	MOVE B,[POINT ^D18,DTERBT] ;WHERE TO DO NEXT DUMP
	RETSKP			;GO DO IT

;DUMP IS DONE. CLOSE FILE

RELODC:	HRRZ A,Q1		;THE JFN
	TXO A,1B0		;DON'T RELEASE THE JFN
	CLOSF			;CLOSE IT
	 JFCL
	CALL UNLPAG		;GO UNMAP THE PAGE
	CALLRET RFALSE		;AND SAY NO BELL NEEDED

;ROUTINE TO GET JFN AND OFN FOR THE DUMP FILE
;INPUT:	A/ DTE NUMBER
;RETURNS: +1 /FAILURE. CONDITION BIT ON IN Q3
;	  +2/ SUCCESS. P1/THE JFN  Q1/ OFN,,

FNDFIL:	SAVET			;SAVE TEMPS
	HRROI B,DTERBT		;WHERE TO FORM THE NAME
	MOVEI D,"0"(A)		;FIRST BYTE IS -11 NUMBER
	SETZ C,			;TERMINATE ON NULL
	HRROI A,[ASCIZ /BS:<SYSTEM>/] ;[7.1219] Put file in BS:<SYSTEM>
	SIN			;COPY STIRNG
	IDPB D,B		;PUT IN -11 NUMBER
	HRROI A,[ASCIZ /DMP11.BIN;P770000/]
	SIN			;COPY REST OF NAME
	IDPB C,B		;TIE IT OFF
	MOVX A,GJ%FOU!GJ%PHY!GJ%SHT ;GTJFN BITS
	HRROI B,DTERBT		;THE ADDRESS OF THE FILE PAGE
	GTJFN			;GET A JFN
	 JRST [	TXO Q3,.R1GTF	;GTJFN FAILED
		RET]		;AND GIVE UP
	MOVEI P1,0(A)		;SAVE JFN
	HRLI A,.FBBYV		;SET UP TO CHANGE BYTE SIZE
	MOVX B,7777B11		;SET RETENTION AND BYTE SIZE
	MOVX C,0044B11		;SET RETENTION TO INFINITE
	CHFDB			;CHANGE IT
	ERJMP FNDFL1		;FAILED. PUNT IT
	HRLI A,.FBSIZ		;EOF POINTER
	SETO B,			;CHANGE WHOLE WORD
	MOVEI C,^D28*^D512	;SET TO 28 PAGES
	CHFDB			;DO IT
	ERJMP FNDFL1		;FAILED. PUNT IT
FNDFL1:	MOVE B,[440000+OF%WR]	;OPEN CONDITIONS
	MOVEI A,0(P1)		;GET JFN AGAIN
	OPENF			;OPEN THE FILE
	 JRST [	TXO Q3,.R1OPF	;OPENF FAILED
		RET]		;GIVE IT UP
	HRLZS A			;JFN TO LH
	CALL JFNOFN		;GET THE OFN
	 JRST [TXO Q3,.R1OPF	;OPENF FAILED
		RET]
	MOVE Q1,A		;SAVE THE OFN
	RETSKP			;MADE IT

;THIS ROUTINE PERFORMS THE ACTUAL DUMP OF THE -11. INPUT IS:
;	A/ DTE NUMBER
;	B/ BYTE POINTER TO USE FOR THE DUMP
;	C/ FLAGS AND COUNT OF WORDS TO DUMP
;		COUNT IS RIGHTMOST 12 BITS (DTEBYC)
;		FLAGS:	DTETI (SET "I" BIT ON TRANSFER)
;RETURNS:
;	+1/ FAILED. CONDITION SET IN A
;	+2/ SUCCESS

DODUMP:	SAVEPQ			;SAVE ALL REGS
	MOVE D,[CONSO DTE0,DTETDN!DTETER] ;DTE CONDITIONS
	MOVE P3,DATO(A)		;GET A DATAO FOR THIS DTE
	MOVE Q3,CNDO(A)		;GET A CONO WORD
	IORI Q3,DTETDN		;TO SET UP PROPER STATE
	IORI P3,A		;ARG WILL GO IN A
	LSH A,^D26		;POSITION DTE NUMBER
	ADD D,A			;FORM HARDWARE TEST WORD
	LSH A,-^D26+SDTE	;FORM EPT INDEX
	MOVEM B,DTETBP(A)	;PUT BYTE POINTER IN EPT
	XCT Q3			;TURN OFF ALL TO -10 INDICATORS

;GO GET THE CORE

	MOVE B,C		;COPY BYTE COUNT AND "I" BIT
	MOVN A,C		;GET NEG OF COUNT
	ANDI A,DTEBYC		;ONLY 12 BITS
	TXNE B,DTETI		;WANT "I" BIT SET ?
	TXO A,DTETI		;YES, SET "I" BIT
	XCT P3			;DO THE DATAO
	MOVEI B,T10TIM		;TIME FOR IT TO COMPLETE
	ADD B,TODCLK		;WHEN WAIT IS UP
DOPAG1:	XCT D			;WAIT FOR IT TO COMPLETE
	JRST [	CAML B,TODCLK	;WAIT SOME MORE?
		JRST DOPAG1	;YES. GO DO IT
		XCT D		;did function complete ?
		SKIPA		;no report error
		JRST .+1	;yes, it finally finished
		SETZ A,		;NO. ASSUMED IT WON'T FINISH
		XCT P3		;ABORT TRANSFER
		MOVX A,.R1RTM	;set read timeout status
		JRST DMPERR]	;AND GO MARK ERROR
	TXZ D,DTETER		;SEE IF IT WAS ERROR OR NORMAL DONE
	XCT D			;""
	JRST [	MOVX A,.R110E	;WAS AN ERROR. BAD NEWS
		JRST DMPERR]
	TXO D,DTETER		;RESTORE THIS
	XCT Q3			;TURN OFF DONE FLAGS
	RETSKP			;DUMP IS DONE

;ERROR DOING THE DUMP

DMPERR:	XCT Q3			;RESET THE DTE
	RET			;DONE

;ROUTINE TO MAKE SYSERR ENTRY FOR -11 RELOAD. INPUT IS:
;	A/ DTE NUMBER
;	P1/ JFN
;	P3/ RETRY COUNT
;	Q2/ -11 ERROR WORDS
;	Q3/ STATUS

RELOD7:	TRVAR <DTNOM,SYBLK,ER11,<FILESP,^D20>> ;FOR SYSERR INFO
	MOVEM Q2,ER11		;SAVE -11 ERROR WORDS
	MOVEM A,DTNOM		;SAVE DTE NUMBER
	MOVEI A,R1%LEN		;SIZE OF PACKET
	MOVEI B,R1%SIZ		;LENGHT (INCLUDING STIRNGS)
	CALL ALCSEB		;ALLOCATE A BLOCK
	 JRST [	MOVE A,DTNOM
		RET]		;DONE
	MOVEM A,SYBLK		;SAVE BLOCK
	MOVEI B,3		;MAX TRIES
	SUBM B,P5		;NUMBER OF TRIES
	IOR P5,Q3		;FORM FINAL STATUS WORD
	MOVE B,[-4,,[		;TO DO THE COPIES
		SEBPTR 0,SBTEVC,SEC%11 ;CODE
		SEBPTR R1%NUM,SBTWD,DTNOM ;-11 NUMBER
		SEBPTR R1%STS,SBTWD,P5 ;STATUS
		SEBPTR R1%ERW,SBTWD,ER11]] ;-11 ERROR WORDS
	MOVE A,SYBLK		;BLOCK ADDRESS
	CALL SEBCPY		;COPY THE DATA
	 JFCL
	TXNE Q3,.R1DPF		;DID THE DUMP SUCCEED?
	JRST RELOD9		;NO. GO ON
	MOVEI B,0(P1)		;YES. GET JFN
	HRROI A,FILESP		;A BUFFER FOR THE FILE NAME
	MOVE C,[11110,,10011]	;JFNS BITS
	JFNS			;GET THE NAME
	MOVE A,SYBLK		;SYSERR BLOCK
	MOVE B,[-1,,[
		SEBPTR R1%FNM,SBTSTR,FILESP]] ;COPY STRING
	CALL SEBCPY		;DO IT
	 JFCL
RELOD9:	MOVE A,SYBLK		;GET SYSERR BLOCK
	CALL QUESEB		;QUEUE IT UP
	 JFCL			;?
	RET			;AND DONE

;CODE TO DO THE RP REBOOT OF THE -11. THIS INCLUDES THE PORT
;CONTENTION LOGIC AND THE BOOT CODE

DSKRBT:	12700,,0		;MOV #0,R0
	12704,,176700		;MOV #RPEXP,R4
	12703,,176710		;MOV #RPEXP+10,R3
	12713,,40		;MOV #40,@R3
	10005,,305		;MOV R0,R5
				; SWAB R5
	42705,,177770		;BIC #177770,R5
	110513,,12701		;MOVB R5,@R3
	2,,12714		;MOV#2,R1
	23,,32714		;MOV #23,@R4
	4000,,1771		;BIT #DVA,@R4
				; BEQ 10$
	5301,,1371		;DEC R1
				; BNE 20$
	137,,173034		;JUMP 173034
DSKPSZ==.-DSKRBT

;ROUTINE TO CHECK IF A DTE EXISTS
;ACCEPTS:	A/ DTE NUMBER
;RETURNS:	+1 DOESN'T EXIST
;		+2 EXISTS

DTREAL:	JN DTERL,(A),RSKP	;IF NOW ACTIVE, IT EXISTS
	CALL DTREST		;PUT IT IN A KNOWN STATE
	MOVE B,CNDO(A)		;GET A CONO WORD
	IORI B,DTEPIE+DTEPI0	;ENABLE PI 0 ONLY
	XCT B			;GO SET THEM
	TXC B,<<CONSO 0>-<CONO 0>> ;CHANGE CONO INTO A CONSO
	XCT B			;SEE IF BITS ARE ON
	RET			;NO. DEVICE DOESN'T EXIST
	CALL DTREST		;YES. RESET DEVICE
	RETSKP			;AND SAY IT EXISTS

; BOOT JSYS - PERFORMS BOOTSTRAP FUNCTIONS FOR ADJACENT COMPUTERS


; TABLE OF DISPATCH ADDRESSES

BOOTTB:	BTROM			;  0 ACTIVATE ROM
	BTLDS			;  1 LOAD SECONDARY BOOTSTRAP PROGRAM
	BTLOD			;  2 LOAD MEMORY
	BTDMP			;  3 DUMP MEMORY
	BTIPR			;  4 INITIALIZE PROTOCOL
	BTTPR			;  5 TERMINATE PROTOCOL
	BTSTS			;  6 RETURN STATUS
	BTBEL			;  7 WAIT FOR TO-10 DOORBELL
	BTRMP			; 10 READ MOP MESSAGE
   REPEAT 3,<
	[RETBAD (ARGX02)]>	; 11-13 ARE ILLEGAL
	BTCLI			; 14 (.BTCLI) CONVERT LINE ID TO PORT NUMBER
	BTCPN			; 15 (.BTCPN) CONVERT PORT NUMBER TO LINE ID
	BTD60			; 16 (.BTD60) perform a DN60 operation

	BOOTLN==.-BOOTTB

.BOOT::	MCENT			;MONITOR CONTEXT ENTRY
	MOVE T1,CAPENB		;GET ENABLED CAPABILITIES
	TXNN T1,SC%WHL!SC%OPR!SC%MNT ;WHEEL, OPERATOR, OR MAINTENANCE ?
	ITERR (CAPX1)		;NO, GIVE ERROR

; VALIDATE DTE-20 NUMBER

	UMOVE Q1,2		;GET ADDRESS OF USER'S ARGUMENT BLOCK
	UMOVE Q2,.BTDTE(Q1)	;GET DTE-20 NUMBER FROM USER
	UMOVE T1,1		;GET FUNCTION CODE FROM USER
	CAIN T1,.BTCLI		;SPECIAL CASE - DON'T CHECK DTE NUMBER
	JRST BOOT1		;YES - SKIP VALIDATION
	CAIL Q2,DTEN		;VALID DTE-20 SPECIFIED ?
	ITERR (BOTX01)		;NO, GIVE ERROR

; DISPATCH TO PROCESSING ROUTINE BASED ON REQUESTED FUNCTION

BOOT1:	CAIL T1,.BTROM		;CHECK RANGE OF GIVEN
	CAIL T1,BOOTLN		; FUNCTION CODE
	ITERR (ARGX02)		;INVALID FUNCTION CODE
	MOVE T1,BOOTTB(T1)	;GET ADDRESS OF PROCESSING ROUTINE
	CALL (T1)		;DISPATCH TO APPROPRIATE ROUTINE
	 ITERR()		;ERROR
	MRETNG			;SUCCESS, RETURN TO USER

; COMMON ERROR ROUTINE TO STORE FAILURE STATUS IN ARG BLOCK AND RETURN
; ACCEPTS IN T1/ ERROR STATUS

BTERR:	CAMN T1,[-1]		;NO SUCH DTE20 ?
	JRST [	MOVX T1,BOTX01	;YUP, GET CORRECT ERROR CODE
		RET ]		;AND DONE
	UMOVEM T1,.BTERR(Q1)	;SAVE ERROR STATUS
	RET			;GIVE FAIL RETURN

; ROUTINE TO ACTIVATE (GRONK) THE ROM

BTROM:	CAIGE Q2,DTEN		;VALID DTE-20 SPECIFIED ?
	SKIPGE Q2		;??
	RETBAD (BOTX01)		;NO, GIVE ERROR
	MOVE T1,Q2		;GET DTE-20 NUMBER
	TXO T1,RM%ROM		;INDICATE THAT ROM SHOULD BE GRONKED
	SETZB T2,T3		;DON'T DUMP, DON'T LOAD
	CALL RMGRNC		;GO GRONK THE ROM
	 JRST BTERR		;FAILED, RETURN ERROR STATUS
	RETSKP			;SUCCESS, GIVE GOOD RETURN


; ROUTINE TO ACTIVATE (GRONK) THE ROM AND LOAD A SECONDARY BOOTSTRAP

BTLDS:	CAIGE Q2,DTEN		;VALID DTE-20 SPECIFIED ?
	SKIPGE Q2		;??
	RETBAD (BOTX01)		;NO, GIVE ERROR
	MOVE T1,Q2		;GET NUMBER OF DTE-20
	TXO T1,RM%ROM		;NOTE THAT ROM SHOULD BE ACTIVATED
	SETZM T2		;NO DUMP WANTED
	MOVE T3,[LODSEC]	;ADR OF COROUTINE TO LOAD SECONDARY BOOT
	MOVE T4,[RELODE]	;ADDRESS OF ERROR COROUTINE
	CALL RMGRNC		;INITIATE LOAD OF SECONADRY BOOTSTRAP
	 JRST BTERR		;FAILED, RETURN ERROR STATUS
	RETSKP			;SUCCESS, GIVE GOOD RETURN

; COROUTINE TO PERFORM LOADING OF SECONDARY BOOTSTRAP

LODSEC:	JUMPG T1,LDSEC2		;IF SECOND CALL, GO UNLOCK PAGE AND RETURN
	CALL LOKPAG		;LOCK THE PAGE TO HOLD THE DATA TO TRANSFER
	CALL CLRRBT		;ZERO THE BOOT PAGE
	MOVEI T1,200		;NUMBER OF WORDS TO TRANSFER IS MAXIMUM SIZE
				; OF SECONDARY BOOTSTRAP
	UMOVE T2,.BTSEC(Q1)	;GET SOURCE ADDRESS OF DATA IN USER SPACE
	MOVE T3,[DTERBT]	;GET ADDRESS OF BOOT PAGE (DESTINATION)
	CALL BLTUM1		;COPY BOOTSTRAP INTO MONITOR SPACE
	MOVE T1,Q2		;GET DTE-20 NUMBER
	CALL CLRBEL		;TURN OFF THE TO -10 DOORBELL
	SETOM T2		;NOTE THAT A DOORBELL IS REQUESTED
	MOVE T1,[POINT ^D16,DTERBT] ;GET BYTE POINTER TO SECONDARY BOOT PGM
	RETSKP			;RETURN TO CALLER

; HERE ON SECOND ENTRY AFTER DATA HAS BEEN TRANSFERRED

LDSEC2:	CALL UNLPAG		;DONE WITH BOOT PAGE
	CALLRET RTRUE		;RETURN AND REQUEST FINAL DOORBELL

; ROUTINE TO LOAD MEMORY OF AN ADJACENT COMPUTER HAVING LOADED A BOOTSTRAP

CNTBYT==2			;NUMBER OF COUNT BYTES PRECEDING DATA BYTES

BTLOD:	CAIGE Q2,DTEN		;VALID DTE-20 SPECIFIED ?
	SKIPGE Q2		;??
	RETBAD (BOTX01)		;NO, GIVE ERROR
	UMOVE T2,.BTCNT(Q1)	;GET TOTAL NUMBER OF DATA BYTES TO TRANSFER
	JUMPLE T2,[RETBAD (BOTX04)] ;COUNT MUST BE POSITIVE
	HRLM T2,Q2		;SAVE NUMBER OF BYTES REMAINING TO LOAD
	UMOVE T1,.BTFLG(Q1)	;GET FLAGS FROM USER SPACE
	TXNE T1,BT%BEL		;USER WANT DOORBELL ?
	TXO Q1,BT%BEL		;YES, NOTE REQUEST
	UMOVE T1,.BTLPT(Q1)	;GET POINTER TO DATA BYTES IN USER SPACE
	MOVEM T1,Q3		;SAVE BYTE POINTER TO DATA

; VALIDATE THE USER'S BYTE POINTER

	LDB T2,[POINT 6,T1,11]	;GET SIZE OF BYTES
	CAIE T2,^D8		;ONLY 8-BIT BYTES PERMITTED
	RETBAD (BOTX02)		;INVALID BYTE SIZE SPECIFIED

; DETERMINE THE NUMBER OF DATA BYTES PER PAGE

	MOVEI T1,^D36		;GET NUMBER OF BITS/WORD
	IDIV T1,T2		;COMPUTE NUMBER OF BYTES/WORD
	IMULI T1,PGSIZ		;FORM TOTAL NUMBER OF BYTES/PAGE
	SUBI T1,CNTBYT		;COMPUTE NUMBER OF DATA BYTES/PAGE
	HRRM T1,Q1		;SAVE # OF DATA BYTES/PAGE

; SET UP TO DO THE TRANSFER

	HRRZ T1,Q2		;GET NUMBER OF DTE-20
	SETZM T2		;NO DUMP WANTED
	MOVEI T3,LODRTN		;ADR OF COROUTINE TO LOAD DATA
	MOVEI T4,RELODE		;ADDRESS OF ERROR COROUTINE
	CALL RMGRNC		;INITIATE LOAD OF SECONADRY BOOTSTRAP
	 JRST BTERR		;FAILED, RETURN ERROR STATUS
	RETSKP			;SUCCESS, GIVE GOOD RETURN

; COROUTINE TO PERFORM LOADING OF AN ADJACENT COMPUTER'S MEMORY
;
;ACCEPTS IN Q1/	FLAGS,,NUMBER OF DATA BYTES PER PAGE
;			FLAGS: BT%BEL IF DOORBELL WANTED
;	    Q2/	# OF BYTES LEFT TO LOAD,,DTE-20 NUMBER
;	    Q3/	BYTE POINTER TO NEXT BYTE INTO USER'S ADDRESS SPACE

LODRTN:	HLRZ T1,Q2		;GET NUMBER OF BYTES LEFT TO DO
	JUMPLE T1,LDRTN2	;IF DONE ALL BYTES, UNLOCK BOOT PAGE AND RETURN
	CALL LOKPAG		;LOCK THE BOOT PAGE
	CALL CLRRBT		;ZERO THE BOOT PAGE
	HLRZ T1,Q2		;GET NUMBER OF BYTES LEFT TO DO
	HRRZ T2,Q1		;ASSUME AN ENTIRE PAGE OF BYTES LEFT TO DO
	CAIGE T1,(Q1)		;LESS THAN A PAGE OF DATA BYTES LEFT ?
	HLRZ T2,Q2		;YES, GET JUST THE NUMBER LEFT TO LOAD
	SUB T1,T2		;COMPUTE BYTES REMAINING AFTER THIS LOAD
	HRL Q2,T1		;SAVE NEW NUMBER OF BYTES LEFT TO DO

; STORE THE NUMBER OF DATA BYTES TO TRANSFER AS THE FIRST TWO BYTES

	MOVE T4,[POINT 8,DTERBT] ;SET UP DESTINATION POINTER
	IDPB T2,T4		;STORE LOW ORDER BYTE OF COUNT
	LDB T3,[POINT 8,T2,27]	;GET HIGH ORDER BYTE OF COUNT
	IDPB T3,T4		;STORE HIGH ORDER BYTE OF COUNT

; GET THE DATA BYTES FROM THE USER (T2 NOW HAS NUMBER OF BYTES TO LOAD)

USRD10:	XCTBU [ILDB T3,Q3]	;GET NEXT BYTE FROM THE USER
	IDPB T3,T4		;STORE NEXT DATA BYTE TO LOAD
	SOJG T2,USRD10		;LOOP FOR ALL BYTES TO LOAD

; NOW SET UP FLAGS AND POINTER TO DATA AND RETURN

	HRRZ T1,Q2		;GET NUMBER OF DTE-20
	CALL CLRBEL		;TURN OFF THE TO -10 DOORBELL
	SETZM T2		;ASSUME NO TO -11 DOORBELL WANTED
	TXNE Q1,BT%BEL		;USER WANT A TO -11 DORRBELL ?
	SETOM T2		;YES, NOTE THAT A DOORBELL IS REQUESTED
	MOVE T1,[POINT 8,DTERBT] ;GET BYTE POINTER TO DATA
	RETSKP			;RETURN AND DO TRANSFER

; HERE WHEN ALL DATA HAS BEEN LOADED - UNLOCK THE BOOT PAGE AND RETURN

LDRTN2:	CALL UNLPAG		;UNLOCK THE BOOT PAGE
	CALLRET RFALSE		;RETURN (NO DDORBELL)

; ROUTINE TO DUMP AN ADJACENT COMPUTER'S MEMORY

BTDMP:	STKVAR <BTDBLK,BTDERR>
	CAIGE Q2,DTEN		;VALID DTE-20 SPECIFIED ?
	SKIPGE Q2		;??
	RETBAD (BOTX01)		;NO, GIVE ERROR
	MOVEM Q1,BTDBLK		;SAVE ADDRESS OF USER ARG BLOCK
	UMOVE T2,.BTCNT(Q1)	;GET TOTAL NUMBER OF DATA BYTES TO TRANSFER
	HRLM T2,Q2		;SAVE NUMBER OF BYTES REMAINING TO DUMP
	UMOVE T1,.BTDPT(Q1)	;GET POINTER TO DATA BYTES IN USER SPACE
	MOVEM T1,Q3		;SAVE BYTE POINTER TO DATA

; DETERMINE THE NUMBER OF DATA BYTES PER PAGE

	LDB T2,[POINT 6,T1,11]	;GET SIZE OF BYTES
	MOVEI T1,^D36		;GET NUMBER OF BITS/WORD
	IDIV T1,T2		;COMPUTE NUMBER OF BYTES/WORD
	IMULI T1,PGSIZ		;FORM TOTAL NUMBER OF BYTES/PAGE
	HRRZM T1,Q1		;SAVE # OF DATA BYTES/PAGE

; SET UP TO DO THE TRANSFER

	SETZM BTDERR		;INITIALIZE ERROR FLAG
	HRRZ T1,Q2		;GET NUMBER OF DTE-20
	MOVE T2,[DMPRTN]	;GET ADDRESS OF DUMP COROUTINE
	SETZM T3		;NO LOAD ROUTINE NEEDED
	MOVE T4,[RELODE]	;ADDRESS OF ERROR COROUTINE
	CALL RMGRNC		;INITIATE DUMP
	 MOVEM T1,BTDERR	;SAVE ERROR STATUS
	MOVE Q1,BTDBLK		;GET ADDRESS OF USER ARG BLOCK AGAIN
	UMOVEM Q3,.BTDPT(Q1)	;STORE UPDATE POINTER INTO USER SPACE
	HLRZ T1,Q2		;GET # OF BYTES LEFT TO DUMP
	UMOVEM T1,.BTCNT(Q1)	;STORE UPDATED COUNT IN USER SPACE
	SKIPE T1,BTDERR		;DID AN ERROR OCCUR ON THE DUMP ?
	JRST BTERR		;YES, GO STORE ERROR CODE AND RETURN
	RETSKP			;SUCCESS, GIVE GOOD RETURN

; COROUTINE TO PERFORM DUMPING OF AN ADJACENT COMPUTER'S MEMORY
;
;ACCEPTS IN Q1/	# OF BYTES DUMPED ON LAST CALL,,NUMBER OF DATA BYTES PER PAGE
;	    Q2/	# OF BYTES LEFT TO DUMP,,DTE-20 NUMBER
;	    Q3/	BYTE POINTER TO NEXT BYTE INTO USER'S ADDRESS SPACE

DMPRTN:	STKVAR <DMPNUM>
	MOVEM T1,DMPNUM		;SAVE NUMBER OF THIS CALL
	SKIPN DMPNUM		;FIRST TIME HERE ?
	JRST DMPRT1		;YES, SKIP RETURNING BYTES TO USER

; RETURN DUMPED BYTES TO USER PROGRAM

	HLRZ T4,Q1		;GET # OF BYTES DUMPED LAST TIME
	MOVE T3,[POINT 8,DTERBT] ;GET BYTE POINTER
	LDB T1,[POINT 6,Q3,11]	;GET SIZE OF USER'S BYTE POINTER
	DPB T1,[POINT 6,T3,11]	;FORM BYTE POINTER FOR CORRECT SIZE BYTES
DMPRT0:	ILDB T1,T3		;GET A DUMPED BYTE
	XCTBU [IDPB T1,Q3]	;STORE BYTE INTO USER SPACE
	SOJG T4,DMPRT0		;LOOP OVER ALL BYTES TO DUMP

DMPRT1:	SKIPE DMPNUM		;IS THIS THE FIRST CALL ?
	JRST DMPRT2		;NO, DO NOT INITIALIZE BOOT PAGE
	CALL LOKPAG		;YES, LOCK THE BOOT PAGE
	CALL CLRRBT		;ZERO THE BOOT PAGE

DMPRT2:	HLRZ T2,Q2		;GET NUMBER OF BYTES LEFT TO DO
	JUMPLE T2,DMPRT3	;IF DONE ALL BYTES, UNLOCK BOOT PAGE AND RETURN
	HLRZ T1,Q2		;GET NUMBER OF BYTES LEFT TO DO
	HRRZ T2,Q1		;ASSUME AN ENTIRE PAGE OF BYTES LEFT TO DO
	CAIGE T1,(Q1)		;LESS THAN A PAGE OF DATA BYTES LEFT ?
	HLRZ T2,Q2		;YES, GET JUST THE NUMBER LEFT TO DUMP
	HRLM T2,Q1		;SAVE # OF BYTES TO BE DUMPED THIS PASS
	SUB T1,T2		;COMPUTE BYTES REMAINING AFTER THIS DUMP
	HRL Q2,T1		;SAVE NEW NUMBER OF BYTES LEFT TO DO

;SET UP TO DO THE NEXT DUMP

	MOVE T1,T2		;GET # OF BYTES TO DUMP
	MOVE T2,[POINT 8,DTERBT] ;GET POINTER TO WHERE DUMPED BYTES GO
	LDB T3,[POINT 6,Q3,11]	;GET SIZE OF USER'S BYTE POINTER
	DPB T3,[POINT 6,T2,11]	;FORM BYTE POINTER FOR CORRECT SIZE BYTES
	RETSKP			;REQUEST NEXT SET OF BYTES TO BE DUMPED

; HERE AFTER FINAL SET OF BYTES HAS BEEN DUMPED

DMPRT3:	CALL UNLPAG		;UNLOCK THE BOOT PAGE
	CALLRET RFALSE		;NO EXTRA DOORBELL NEEDED

; ROUTINE TO WAIT FOR A TO-10 DOORBELL

BTBEL:	SE0ENT			;ENTER SECTION 0
	HRLZ T1,Q2		;GET DTE-20 NUMBER
	HRRI T1,DBWAIT		;GET SCHEDULER TEST ROUTINE ADDRESS
	MDISMS			;WAIT FOR DOORBELL TO COME ON
	MOVE T1,Q2		;GET DTE-20 NUMBER
	LSH T1,^D26		;POSITION DTE-20 NUMBER
	ADD T1,[CONO DTE0,DTETDB] ;FORM INSTRUCTION TO TURN OFF DOORBELL
	XCT T1			;TURN OFF TO-20 DOORBELL
	RETSKP			;DOORBELL WAS ON, RETURN

; SCHEDULER TEST TO WAIT FOR A DOORBELL FROM A DTE-20
; ACCEPTS IN T1/ DTE-20 NUMBER

	RESCD
DBTMR:	MOVE	T2,TODCLK	;GET THE TIME
	CAML	T2,DTETMR(T1)	;TIME TO WAKE UP YET?
	JRST	1(4)		;YES - SO SUC
				;NO  - THEN CHECK IF DOORBELL ARRIVED YET

DBWAIT:	LSH T1,^D26		;POSITION DTE-20 NUMBER
	ADD T1,[CONSO DTE0,DTETDB] ;FORM TEST INSTRUCTION
	XCT T1			;IS DOORBELL ON YET ?
	JRST 0(4)		;NO, WAIT SOME MORE
	JRST 1(4)		;YES, RETURN SUCCESS
	SWAPCD


; ROUTINE TO PURGE THE DTE BUFFER PAGE (DTERBT)
;
;ACCEPTS IN T1/	DTE #

KILPAG:	SAVET
	MOVEI T2,DTERBT		;GET ADDRESS OF BUFFER PAGE
	SETZ T1,		;DELETE THE PAGE
	CALLRET SETMPG		;...

; ROUTINE TO READ A MOP MESSAGE FROM AN ADJACENT COMPUTER
;
; PROTOCOL:		BYTE COUNT (2 BYTES, INCLUDING BYTE COUNT)
;			MOP MESSAGE
;	ONLY 8-BIT BYTES ARE PERMITTED.  A SECONDARY BOOTSTRAP CAPABLE OF
;	ADHERING TO THIS PROTOCOL MUST HAVE BEEN LOADED INTO THE ADJACENT
;	COMPUTER PRIOR TO PERFORMING THIS FUNCTION.


BTRMP:	CAIGE Q2,DTEN		;VALID DTE-20 SPECIFIED ?
	SKIPGE Q2		;??
	RETBAD (BOTX01)		;NO, GIVE ERROR
	SE0ENT			;ENTER SECTION 0
	MOVE T1,Q2		;GET DTE-20 NUMBER
	MOVEI T2,RCVMOP		;ADDRESS OF DUMP COROUTINE
	MOVEI T3,0		;NO LOADING DESIRED
	MOVEI T4,RELODE		;ADDRESS OF ERROR COROUTINE
	CALL RMGRNC		;INITIATE THE TRANSFER
	 JRST BTERR		;FAILED, RETURN ERROR STATUS

; THE MESSAGE HAS BEEN TRANSFERRED TO MONITOR VIRTUAL ADDRESS SPACE.
; RETURN THE MESSAGE TO THE USER (Q3 CONTAINS THE # OF BYTES TRANSFERRED).

	UMOVE T1,.BTMPT(Q1)	;GET DESTINATION BYTE POINTER TO USER SPACE
	UMOVE T2,.BTCNT(Q1)	;GET MAX BYTE COUNT USER WILL ACCEPT
	CAML T2,Q3		;WAS LESS ACTUALLY TRANSFERRED ?
	MOVE T2,Q3		;YES, USE SMALLER BYTE COUNT
	UMOVEM T2,.BTCNT(Q1)	;STORE UPDATED BYTE COUNT IN USER SPACE
	MOVE T4,[POINT 8,DTERBT,15] ;GET BYTE POINTER TO SOURCE
	JUMPE T2,BTRM20		;IF DONE, RETURN

; LOOP TO RETURN THE MESSAGE TO THE USER

BTRM10:	ILDB T3,T4		;GET BYTE FROM MESSAGE
	XCTBU [IDPB T3,T1]	;STORE BYTE INTO USER SPACE
	SOJG T2,BTRM10		;LOOP OVER ENTIRE MESSAGE

BTRM20:	UMOVEM T1,.BTMPT(Q1)	;STORE UPDATED BYTE POINTER
	RETSKP			;RETURN SUCCESS

; COROUTINE TO RECEIVE MOP MESSAGES

RCVMOP:	JUMPN T1,RCVM10		;IF NOT FIRST CALL, GO READ MSG OR RETURN

; THIS IS THE INITIAL CALL - SET UP TO READ THE BYTE COUNT

	CALL LOKPAG		;LOCK THE BOOT PAGE
	CALL CLRRBT		;ZERO THE BOOT PAGE
	MOVEI T1,2		;BYTE COUNT IS FIRST TWO BYTES
	MOVE T2,[POINT 8,DTERBT] ;GET BYTE POINTER
	RETSKP			;RETURN TO READ FIRST TWO BYTES

; HERE ON SECOND CALL - SET UP TO READ THE ACTUAL MOP MESSAGE

RCVM10:	CAIE T1,1		;IS THIS THE SECOND CALL ?
	JRST RCVM20		;NO, GO UNLOCK THE BOOT PAGE AND RETURN
	LDB Q3,[POINT 8,DTERBT,7] ;YES, GET LOW ORDER BYTE OF BYTE COUNT
	LDB T1,[POINT 8,DTERBT,15] ;GET HIGH ORDER BYTE OF BYTE COUNT
	DPB T1,[POINT 8,Q3,27]	;FORM COMPLETE BYTE COUNT
	MOVE T1,Q3		;GET BYTE COUNT
	CAILE T1,PGSIZ*4-2	;MAX MESSAGE SIZE IS ONE PAGE-COUNT (2 BYTES)
	MOVEI T1,PGSIZ*4-2	;MESSAGE TOO LARGE, JUST GET ONE PAGE
	TXO T1,DTETI		;REQUEST "I" BIT ALSO
	MOVE T2,[POINT 8,DTERBT,15] ;START MESSAGE AT THIRD BYTE IN FIRST WORD
	RETSKP			;RETURN AND TRANSFER DATA BYTES

; HERE ON THIRD CALL - ENTIRE MESSAGE HAS BEEN TRANSFERRED

RCVM20:	CALL UNLPAG		;UNLOCK THE BOOT PAGE
	UMOVE T2,.BTFLG(Q1)	;GET FLAGS FROM USER
	SETZM T1		;ASSUME NO DOORBELL WANTED
	TXNE T2,BT%BEL		;USER ASK FOR A DOORBELL ?
	SETOM T1		;YES, REQUEST A DOORBELL
	RET			;RETURN, TRANSFER COMPLETED

; ROUTINE TO TERMINATE PROTOCOL ON A DTE-20

BTTPR:	CAIGE Q2,DTEN		;VALID DTE-20 SPECIFIED ?
	SKIPGE Q2		;??
	RETBAD (BOTX01)		;NO, GIVE ERROR
	CAMN Q2,MSTRDT		;IS THIS THE MASTER -11?
	RETBAD (BOTX01)		;YES. ILLEGAL TO STOP IT
	MOVE T1,Q2		;Get DTE # in T1 for SETRGN
	CALL SETRGN		;Get comm region ptrs in C and D
	LOAD T1,CMVRR,(C)	;Get protocol version
	SKIPN DTBUGX		; Skip this if we aren't interested
	CAIE T1,MCPRON		;If DECNET, do not issue buginf
	BUG.(INF,DTETPR,DTESRV,SOFT,<DTE protocol terminated>,<<Q2,DTENO>>,<

Cause:	The protocol on the DTE has been terminated due to a BOOT% request.

Data:	DTENO - DTE number
>,,<DB%NND>)			;[7.1210]
	LOAD T1,DTERL,(Q2)	;GET CURRENT PROTOCOL STATE
	PUSH P,T1		;SAVE IT
	SETZRO DTERL,(Q2)	;NOTE THAT THIS DTE NOT RUNNING A PROTOCOL
	MOVE T1,Q2		;GET DTE-20 NUMBER
	CALL DTREST		;GO TURN OF INTERRUPTS FOR THIS DTE
	SKIPE 0(P)		;WAS IN PROTOCOL?
	CALL LOADFE		;(T1) YES, REQUEST RELOAD IN JOB 0
	POP P,T1		;GET PREVIOUS PROTOCOL STATE
	RETSKP			;RETURN
				;FALL INTO ROUTINE TO RETURN DTE20 STATUS

; ROUTINE TO RETURN STATUS OF A DTE-20

BTSTS:	CAIGE Q2,DTEN		;VALID DTE-20 SPECIFIED ?
	SKIPGE Q2		;??
	RETBAD (BOTX01)		;NO, GIVE ERROR
	MOVE T1,Q2		;GET DTE-20 NUMBER
	CALL CHKDTE		;SEE IF THIS DTE IS RUNNING SOME PROTOCOL
	 JRST [	SETOM T1	;NO PROTOCOL RUNNING
		JRST BTST1 ]	;GO RETURN THAT STATUS TO USER

; DETERMINE WHICH PROTOCOL IS RUNNING IN THE SPECIFIED DTE

	MOVE T1,Q2		;GET DTE-20 NUMBER
	CALL SETRGN		;GET ADDRESS OF COMM REGIONS
	LOAD T1,CMVRR,(T3)	;GET VERSION OF RUNNING PROTOCOL

; HERE TO RETURN STATUS TO USER (STATUS IS IN T1)

BTST1:	UMOVEM T1,.BTCOD(Q1)	;RETURN STATUS TO USER
	RETSKP			;RETURN SUCCESS

; ROUTINE TO ZERO THE BOOT PAGE

CLRRBT:	MOVE T2,[DTERBT,,DTERBT+1] ;SET UP TO CLEAR BOOT PAGE
	SETZM DTERBT		;CLEAR FIRST WORD OF PAGE
	BLT T2,DTERBT+PGSIZ-1	;INITIALIZE PAGE TO HOLD BOOT PROGRAM DATA
	RET			;RETURN

; ROUTINE TO INITIALIZE THE PROTOCOL ON A SPECIFIED DTE-20

BTIPR:	CAIGE Q2,DTEN		;VALID DTE-20 SPECIFIED ?
	SKIPGE Q2		;??
	RETBAD (BOTX01)		;NO, GIVE ERROR
	UMOVE Q3,.BTPRV(Q1)	;GET PROTOCOL VERSION NUMBER
	MOVE T1,Q3		;COPY PROTOCOL VERSION NUMBER
	CALL CHKPRO		;VALIDATE THE PROTOCOL SPECIFIED
	 RETBAD ()		;INVALID PROTOCOL SPECIFIED
	MOVE T1,Q2		;GET DTE-20 NUMBER
	CALL DTREAL		;IS THIS DTE EXISTANT?
	 RETBAD (BOTX01)	;NO. CAN'T INIT IT THEN
	JN <DTERL,DTRLD>,(T1),[RETBAD (BOTX01)] ;MUST BE INACTIVE ALSO
	CALL CLRDT0		;CLEAN OUT OUTPUT QUEUE
	MOVE T2,Q3		;GET PROTOCOL VERSION NUMBER
	NOINT			;INHIBIT PROCESS INTERRUPTS
	PUSH P,JOBBIT		;SAVE FORK'S PRIORITY WORD
	MOVX T3,BOTPRI		;GET SPECIAL PRIORITY WORD
	MOVEM T3,JOBBIT		;""
	CALL DTINIT		;INITIALIZE COMM REGIONS AND PROTOCOL
   REPEAT 0,<
	BUG.(INF,DTEIPR,DTESRV,SOFT,<DTESRV - Protocol initialized on DTE>,<<T1,DTENUM>>,<

Cause:	BOOT JSYS was executed to initialize protocol.

Data:	DTENUM - the DTE number

>,,<DB%NND>)			;[7.1210]
 >  ;DEBUGGING AID TO CATCH RANDOM RELOADS
	POP P,JOBBIT		;RESTORE PRIORITY WORD
	JN DTRLD,(Q2),[SETZRO DTRLD,(Q2)
			OKINT	;INTS ALLOWED NOW
			RETBAD (BOTX05)] ;IT DIDN'T. INFORM CALLER
	OKINT			;ALLOW INTS NOW
	RETSKP			;GIVE SUCCESS RETURN



;ROUTINE TO CONVERT LINE-ID TO PORT NUMBER

BTCLI:	UMOVE T4,.BTLID(Q1)	;GET POINTER TO LINE-ID STRING
	TLC T4,-1		;SEE IF POINTER IS -1,,ADR TYPE
	TLCN T4,-1		;??
	HRLI T4,(POINT 7,)	;MAKE INTO AN ASCII POINTER
	SETZ T2,		;WHERE WE WILL BUILD STRING
	MOVE T3,[POINT 7,2]	;POINT TO  IT
	XCTBU [	ILDB T1,T4]	;GET FIRST CHARACTER OF STRING
	IDPB T1,T3		;AND STUFF
	XCTBU [	ILDB T1,T4]	;GET SECOND CHARACTER OF STRING
	IDPB T1,T3		;AND STUFF
	XCTBU [	ILDB T1,T4]	;GET THIRD CHARACTER OF STRING
	IDPB T1,T3		;AND STUFF
	XCTBU [	ILDB T1,T4]	;GET FOURTH CHARACTER OF STRING
	IDPB T1,T3		;AND STUFF
	CAMN T2,[ASCIZ/DTE_/]	;ASKING FOR A DTE?
	JRST BTCNUM		;YES GET THE NUMBER
	XCTBU [	ILDB T1,T4]	;GET FIFTH CHARACTER OF STRING
	IDPB T1,T3		;AND STUFF
	CAME T2,[ASCIZ/DTE20/]	;"DTE20_" IS ALSO ACCEPTIBLE
	RETBAD(BOTX01)		;NUMBER OUT OF RANGE
	XCTBU [	ILDB T1,T4]	;GET SIXTH CHARACTER OF STRING
	CAIE T1,"_"		;IS THE THE "DTE20_" STRING
	RETBAD(BOTX01)		;NUMBER OUT OF RANGE
BTCNUM:	XCTBU [	ILDB T1,T4]	;GET LAST CHARACTER OF STRING
	SUBI T1,60		;MAKE INTO A NUMBER
	CAIL T1,DTEN		;CHECK FOR OUT OF RANGE
	RETBAD(BOTX01)		;NUMBER OUT OF RANGE
	XCTBU [	ILDB T2,T4]	;STRING SHOULD END WITH NULL
	UMOVEM T1,.BTPRT(Q1)	;GIVE USER THE NUMBER
	RETSKP			;SUCCESS RETURN
;ROUTINE TO CONVERT PORT NUMBER TO LINE-ID

BTCPN:	CAIGE Q2,DTEN		;VALID DTE-20 SPECIFIED ?
	SKIPGE Q2		;??
	RETBAD (BOTX01)		;NO, GIVE ERROR
	UMOVE T3,.BTLID(Q1)	;GET USER'S POINTER FOR WHERE TO PUT STRING
	TLC T3,-1		;SEE IF POINTER IS -1,,ADR TYPE
	TLCN T3,-1		;??
	HRLI T3,(POINT 7,)	;MAKE INTO AN ASCII POINTER
	MOVEI T2,"D"		;PUT THE STRING "DTE_" IN USER SPACE
	XCTBU [	IDPB T2,T3]
	MOVEI T2,"T"
	XCTBU [	IDPB T2,T3]
	MOVEI T2,"E"
	XCTBU [	IDPB T2,T3]
	MOVEI T2,"_"
	XCTBU [	IDPB T2,T3]
	MOVE T4,Q2		;GET THE DTE NUMBER
	ADDI T4,60		;MAKE NUMBER INTO AN ASCII QUANTITY
	XCTBU [	IDPB T4,T3]	;SAVE THE DTE NUMBER
	SETZ T4,		;END WITH A NULL
	XCTBU [	IDPB T4,T3]	;PUT NULL INTO USER SPACE
	UMOVEM T3,.BTLID(Q1)	;SAVE UPDATED POINTER
	RETSKP

;CHKPRO - ROUTINE TO VALIDATE A PROTOCOL VERSION NUMBER
;
;ACCEPTS IN T1/	PROTOCOL VERSION NUMBER TO CHECK
;		CALL CHKPRO
;RETURNS: +1	 INVALID PROTOCOL SPECIFIED, ERROR CODE IN T1
;	  +2	VALID PROTOCOL GIVEN

CHKPRO:	MOVSI T4,-PRVSIZ	;SET UP TO LOOP THROUGH PROTOCOL TABLE
CHKPR1:	CAMN T1,PRVTAB(T4)	;FOUND VALID PROTOCOL ?
	RETSKP			;YES, GIVE SUCCESS RETURN
	AOBJN T4,CHKPR1		;NO, LOOP THROUGH REMAINDER OF TABLE
	RETBAD (BOTX03)		;INVALID PROTOCOL VERSION NUMBER

PRVTAB:	.VN20F			;RSX20F PROTOCOL
	MCPRON			;DECNET NETWORK SERVICES PROTOCOL
				;ASSEMBLE ONLY IF HAVE DECNET SUPPORT
	.VND60			;DN60 protocol

	PRVSIZ==.-PRVTAB

;.BTD60==16				;DN60 PROTOCL OPERATION
;.VND60==2				;DN60 protocol type

;BTD60 ARG BLOCK

;	DEFSTR	(BT6DTE,0,35,36)	;DTE number
;.BT6DTE==0
;	DEFSTR	(BT6ERR,1,35,36)	;returned error flags
;.BT6ERR==1
;	DEFSTR	(BT6HBC,2,17,18)	;DN60 header byte count
;.BT6HBC==2
;	DEFSTR	(BT6HDR,2,35,18)	;DN60 header address(begins on word)
;.BT6HDR==2
;	DEFSTR	(BT6DBC,3,35,36)	;data byte count
;.BT6DBC==3
					;	positive = write data mode
					;	zero     = no data transfer
					;	negative = read data mode
;	DEFSTR	(BT6PTR,4,35,36)	;data byte ptr
;.BT6PTR==4
					;the following are returned for timing analysis
;	DEFSTR	(BT6TMR,5,35,36)	;time of request
;.BT6TMR==5
;	DEFSTR	(BT6TAS,6,35,36)	;TIME DTE ASSIGNED
;.BT6TAS==6
;	DEFSTR	(BT6THQ,7,35,36)	;time header queued to 11
;.BT6THQ==7
;	DEFSTR	(BT6TRD,10,35,36)	;time of -10 done for response header
;.BT6TRD==10
;	DEFSTR	(BT6TDD,11,35,36)	;time of -10 done for data
;.BT6TDD==11
;	DEFSTR	(BT6TFR,12,35,36)	;time finished request
;.BT6TFR==12

;DN60 header definitions

D6HWSZ==4				;number of 36 bit words in header
D6HBSZ==4*D6HWSZ			;number of 8 bit bytes in header

;DN60/DTE database/work space definitions

D6WDBS==PGSIZ				;working space size in words

	DEFSTR	(D6STS,0,35,36)		;port status
$D6STS==0
					;protocol flags
;	 D6%BSY==1B0			;port is busy - sign bitness is used in testing
;	 D6%QHD==1B1			;header has been queued
;	 D6%HDD==1B2			;to -11 done for header seen
;	 D6%NDT==1B3			;this is a no-data-transfer operation
;	 D6%RED==1B4			;this is a read data type operation
;	 D6%QDT==1B5			;data has been queued(for write fcn)
;	 D6%DTD==1B6			;to -11 done for write data seen
;	 D6%RBL==1B7			;to -10 doorbell for response header seen
;	 D6%RDN==1B8			;to -10 done for response header seen
;	 D6%DBL==1B9			;to -10 doorbell for read data seen
;	 D6%DDN==1B10			;to -10 done for read data seen
;	 D6%FDN==1B11			;to -10 done for read data was faked
					;error flags
;	 D6%BDP==1B30			;bad data byte ptr
;	 D6%ARD==1B31			;11 attempted to send read data when
					; when none was expected
;	 D6%TRS==1B32			;timed out waiting for response header
;	 D6%TDT==1B33			;timed out waiting for read data

;	 D6%TPO==1B34			;timed out waiting for port to be free
;	 D6%NT6==1B35			;not a DN60 front end

	 D6%SER==D6%BDP!D6%ARD!D6%TRS!D6%TDT!D6%TPO!D6%NT6 ;all errors

	DEFSTR	(D6DTE,1,17,18)		;DTE number for this work space
$D6DTE==1
	DEFSTR	(D6RBC,1,35,18)		;response byte count
$D6RBC==1
	DEFSTR	(D6WDC,2,17,18)		;write data byte count
$D6WDC==2
	DEFSTR	(D6RDC,2,35,18)		;read data byte count
$D6RDC==2
	DEFSTR	(D6BSZ,3,35,36)		;data byte size
$D6BSZ==3
	DEFSTR	(D6BPW,4,35,36)		;data bytes per word
$D6BPW==4
	DEFSTR	(D6BLF,5,35,36)		;data bytes left in 1st word
$D6BLF==5
	DEFSTR	(D6BDP,6,35,36)		;beginning data byte ptr
$D6BDP==6
	DEFSTR	(D6DAD,7,35,36)		;byte ptr to 1st data byte in user space
$D6DAD==7
	DEFSTR	(D6CLK,10,35,36)	;timer for 11 requests
$D6CLK==10
	DEFSTR	(D6FRK,11,35,36)	;requesting fork
$D6FRK==11
	DEFSTR	(D6SUP,12,35,36)	;count of waiting supplicants
$D6SUP==12
	DEFSTR	(D6TRD,13,35,36)	;time of -10 done for response header
$D6TRD==13
	DEFSTR	(D6TDD,14,35,36)	;time of -10 done for data
$D6TDD==14

D6HDR==15				;offset to beginning of header area
D6BUF==D6HDR+D6HWSZ			;offset to beginning of data buffer

D6BFS==D6WDBS-D6BUF			;number of words in D6BUF


;here to handle DN60 io requests - from .BOOT
;parameters:	Q1/arg block ptr
;		Q2/DTE number
; user space:	AC2/arg block ptr


BTD60:	MOVE	T1,TODCLK		;save the request time
	USTOR	T1,BT6TMR,(Q1)
	XCT	4,[SETZM .BT6TAS(Q1)]	;now clear all other timer statistics
	XCT	4,[SETZM .BT6THQ(Q1)]
	XCT	4,[SETZM .BT6TRD(Q1)]
	XCT	4,[SETZM .BT6TDD(Q1)]
	XCT	4,[SETZM .BT6TFR(Q1)]

	NOSKED				;flush scheduler while we check for contention
	SKIPN	Q3,D6DTP(Q2)		;get the work space ptr
	JRST	D6NOSK			;DN60 protocol not running on this dte
	NOINT				;don't allow any soft interrupts while
					;waiting here - it screws up the contention data
	SKIPL	$D6STS(Q3)		;look for clear status
	JRST	[MOVE T1,FORKX		;get the loser's fork
		 CAMN T1,$D6FRK(Q3)	;check greediness
		 SKIPN $D6SUP(Q3)	;greed is not always inconsiderate
		 JRST BTD61		;ok to proceed
		 JRST .+1]		;others waiting(impatiently most likely)
					;the loser must wait in line

BTD60A:	AOS	$D6SUP(Q3)		;one more loser
	OKSKED				;allow scheduler to run
	MOVEI	T1,D6BWT		;hang the user til port is free
	CALL	D6WAIT			;twiddle thumbs
	NOSKED				;just to be safe
	SOSGE	$D6SUP(Q3)		;one less loser(he hopes)
	SETZM	$D6SUP(Q3)		;for when all this care is inadequate
	SKIPGE	T1,$D6STS(Q3)		;check for unbusy now
	JRST	[TXNE T1,D6%NT6		;check if protocol is alive and well
		 JRST D6NOSI		;indeed it's dead
		 JRST BTD60A]		;all is ok...just slow

BTD61:	MOVX	T1,D6%BSY		;port unbusy - make it so
	IORB	T1,$D6STS(Q3)		;init the port status to begin transaction
	TXNE	T1,D6%NT6		;is the fe dead ?
	JRST	D6NOSI			;yes - exit
	MOVE	T1,FORKX		;remember user
	MOVEM	T1,$D6FRK(Q3)
	MOVE	T1,TODCLK		;record time of dte assignment
	USTOR	T1,BT6TAS,(Q1)
					;can't allow asynchronous exits until
					;dte is deassigned
	OKSKED				;allow scheduler to run
	SETZRO	D6RBC,(Q3)		;init some transaction history
	SETZRO	D6WDC,(Q3)
	SETZRO	D6RDC,(Q3)
	SETZRO	D6BSZ,(Q3)
	SETZRO	D6BPW,(Q3)
	SETZRO	D6BLF,(Q3)
	SETZRO	D6BDP,(Q3)
	SETZRO	D6CLK,(Q3)
	SETZRO	D6TRD,(Q3)
	SETZRO	D6TDD,(Q3)

	ULOAD	T1,BT6HBC,(Q1)		;get xmit header byte count
	SKIPLE	T1			;default to full size
	CAILE	T1,D6HBSZ		;limit to full size
	MOVEI	T1,D6HBSZ
	MOVE	P1,T1			;save the header xmit count
	TRNE	T1,3			;headers are always 8 bit bytes = 4 bytes/word
	ADDI	T1,4
	LSH	T1,-2
	ULOAD	T2,BT6HDR,(Q1)		;get header address
	MOVEI	T3,D6HDR(Q3)		;where it goes
	CALL	BLTUM1			;xfer header to local space

	MOVX	T2,D6%RED		;check out type of operation
	XCT	4,[SKIPN T1,.BT6DBC(Q1)];determine direction of data transfer
	TXOA	T2,D6%NDT		;zero byte = this a non-data-xfer fcn
	SKIPL	T1			;skip if read data fcn
	TXZ	T2,D6%RED		;write type
	IORB	T2,$D6STS(Q3)		;set the appropriate indicator
	TXNE	T2,D6%NDT		;if not data transfer type
	JRST	BTD63			;go queue the header
					;data mover - calc some byte ptr things
	XCT	10,[MOVEI T1,@.BT6PTR(2)] ;get the data effective address
	XCT	4,[HLL T1,.BT6PTR(Q1)]	;get the ptr part
	TLZ	T1,77			;flush extraneous things
	IBP	T1			;make sure address field = address of 1st word
	HRRZM	T1,$D6DAD(Q3)		;keep it
	TXNN	T2,D6%RED		;read data ?
	JRST	BTD62			;write
	XCT	4,[MOVE T4,@$D6DAD(Q3)] ;read data - get the 1st dest word
	MOVEM	T4,D6BUF(Q3)		;write over it locally

BTD62:	HRRI	T1,D6BUF(Q3)		;beginning byte ptr
	MOVNI	T4,1			;make T1 an ildb ptr
	ADJBP	T4,T1
	STOR	T4,D6BDP,(Q3)		;save it
	LDB	T1,[POINT 6,T4,11]	;the byte size
	JUMPE	T1,[MOVX T1,D6%BDP	;crufty data ptr
		    JRST D6TMO]
	STOR	T1,D6BSZ,(Q3)		;preserve it
	LDB	T4,[POINT 6,T4,5]	;the byte position
	MOVEI	T2,^D36
	IDIV	T2,T1			;bytes per word
	STOR	T2,D6BPW,(Q3)		;preserve it too
	HRREI	T3,-^D36(T4)		;T3/- number bits used
	IDIV	T3,T1			;T3/- number bytes used
	ADD	T2,T3			;T2/  number bytes left in 1st word
	STOR	T2,D6BLF,(Q3)		;save this also

BTD63:	LOAD	T1,D6DTE,(Q3)		;get the dte number
	HRLI	T1,D6HDDN		;the to -11 done interrupt process
	MOVEI	T2,D6HDR(Q3)		;where the data is
	HRLI	T2,(POINT 8)		;the ptr thereto
	MOVE	T3,P1			;retrieve the xmit header count
	MOVE	F,Q3			;driver unique code = workspace ptr
	MOVE	T4,TODCLK		;record time we did this
	USTOR	T4,BT6THQ,(Q1)
	CALL	DTEQ			;queue the header
	JRST	[LOAD T1,D6STS,(Q3)	;failed - check if fe dead
		 TXNE T1,D6%NT6
		 JRST D6FAL		;yes - no use prolonging agony
		 MOVEI	T1,SPCTST	;no queue blocks - wait for some
		 HDISMS (^D2000)
		 JRST	BTD63]
	MOVX	T1,D6%QHD		;header queued
	IORB	T1,$D6STS(Q3)
	TXNE	T1,D6%RED!D6%NDT	;check for write data function
	JRST	BTDRSP			;no - read data or no data

BTDWRT:	ULOAD	T1,BT6DBC,(Q1)		;get the byte count
	LOAD	P1,D6BPW,(Q3)		;bytes per word
	IMULI	P1,D6BFS-1		;check buffer space
	ADD	P1,$D6BLF(Q3)		;add no. bytes left in 1st word
	CAMLE	T1,P1			;limit request to available room
	SKIPA 	T1,P1
	MOVE	P1,T1			;remember what we used
	STOR	T1,D6WDC,(Q3)		;save actual count
	IDIV	T1,$D6BPW(Q3)		;find buffer space needed in words
	SKIPE	T2
	AOS	T1
	HRRZ	T2,$D6DAD(Q3)		;get the source address
	MOVEI	T3,D6BUF(Q3)		;where it is going
	CALL	BLTUM1			;move the data to local space

BTDWR1:	LOAD	T1,D6DTE,(Q3)		;get the dte number
	HRLI	T1,D6DTDN		;to -11 done for data interrupt process
	LOAD	T2,D6BDP,(Q3)		;get the beginning ptr
	MOVE	T3,P1			;get actual bytes to send
	MOVE	F,Q3			;driver unique code = workspace ptr
	CALL	DTEQ			;queue the data block
	JRST	[LOAD T1,D6STS,(Q3)	;failed - check if fe dead
		 TXNE T1,D6%NT6
		 JRST D6FAL		;yes - no use prolonging agony
		 MOVEI	T1,SPCTST	;no queue blocks - wait for some
		 HDISMS	(^D2000)	;wait for one
		 JRST	BTDWR1]		;and try again
	MOVX	T1,D6%QDT		;mark this part done
	IORM	T1,$D6STS(Q3)

BTDRSP:	MOVEI	T1,D6RWT		;wait for the response sched test
	MOVX	T2,D6%RDN!D6%NT6
	TDNN	T2,$D6STS(Q3)		;check if already done
	CALL	D6WAIT			;twiddle thumbs
	MOVE	T1,$D6STS(Q3)		;check if fe died
	TXNE	T1,D6%NT6
	JRST	D6FAL			;yes - go away
	TXNN	T1,D6%RDN		;check if response came
	JRST	[MOVX T1,D6%TRS		;timed out
		 JRST D6TMO]

					;response has arrived
	LOAD	T1,D6RBC,(Q3)		;get response byte count
	CAILE	T1,D6HBSZ		;i should hope so
	MOVEI	T1,D6HBSZ
	USTOR	T1,BT6HBC,(Q1)		;stuff back in arg block
	JUMPE	T1,BTDRS0		;no response(and no data either)
	TRNE	T1,3			;headers are always 8 bit bytes = 4 bytes/word
	ADDI	T1,4
	LSH	T1,-2
	ULOAD	T3,BT6HDR,(Q1)		;get header address
	MOVEI	T2,D6HDR(Q3)
	CALL	BLTMU1			;xfer the header back to user
	LOAD	T1,D6STS,(Q3)		;get transaction status
	TXNN	T1,D6%NDT		;check if read data expected
	TXNN	T1,D6%RED
	JRST	BTDRS3			;no - go finish up
	MOVEI	T1,D6DWT		;no - wait here for it
	MOVX	T2,D6%DDN!D6%NT6
	TDNN	T2,$D6STS(Q3)		;check if already done
	CALL	D6WAIT			;twiddle thumbs
	LOAD	T1,D6STS,(Q3)		;well, did it?
	TXNE	T1,D6%NT6		;check if fe died
	JRST	D6FAL			;yes - go away
	TXNN	T1,D6%DDN
	JRST	[MOVX	T1,D6%TDT	;no - not coming i guess
		 JRST	D6TMO]

BTDRS0:	LOAD	T1,D6RDC,(Q3)		;data arrived - get the amount
	USTOR	T1,BT6DBC,(Q1)		;stuff in arg block
	JUMPE	T1,BTDRS3		;no data received but protocol is happy
	SUB	T1,$D6BLF(Q3)		;find words beyond 1st
	JUMPG	T1,BTDRS1		;some
	MOVEI	T1,1			;none
	JRST	BTDRS2

BTDRS1:	IDIV	T1,$D6BPW(Q3)
	SKIPE	T2
	AOS	T1
	SKIPE	$D6BLF(Q3)		;no increment if 1st word is empty
	AOS	T1			;add 1st word

BTDRS2:	HRRZ	T3,$D6DAD(Q3)		;get destination
	MOVEI	T2,D6BUF(Q3)		;local source
	CALL	BLTMU1

BTDRS3:	CALL	BTDRS4			;record final statistics
	LOAD	T1,D6STS,(Q3)		;get transaction status back
	TXNE	T1,D6%SER		;did any errors occur?
	JRST	D6FAL			;yes - take error exit
	XCT	4,[SETZM .BT6ERR,(Q1)]	;stuff transaction status in arg block
	SETZRO	D6STS,(Q3)		;make port available
	OKINT				;allow soft interrupts now
	RETSKP

D6TMO:	IORB	T1,$D6STS(Q3)		;timed out waiting for something

D6FAL:	PUSH	P,T1			;save it
	LOAD	T1,D6DTE,(Q3)		;get the dte number
	NOSKED
	CALL	CLRDTF			;clean up transaction
	CALL	BTDRS4			;record final statistics
	MOVX	T1,D6%NT6		;check if fe died
	ANDB	T1,$D6STS(Q3)		;never clear death bit
	JUMPE	T1,D6FAL1		;all is hunkydory
	SKIPE	$D6SUP(Q3)		;are there any suplicants?
	JRST	D6FAL1			;yes - can't blow away the workspace yet
	LOAD	T1,D6DTE,(Q3)		;no - blow it all away
	SETZM	D6DTP(T1)		;flush the ptr to workspace
	MOVE	T1,Q3
	CALL	RELRES			;and return the page to free space

D6FAL1:	OKSKED
	POP	P,T1			;get error status back
	JRST	D6NOGO			;and fail

D6NOSK:	NOINT				;fe is dead

D6NOSI:	MOVX	T1,D6%NT6		;DN60 protocol not running on this dte
	SKIPE	Q3,D6DTP(Q2)		;get the data base
	ANDB	T1,$D6STS(Q3)		;never clear death bit
	OKSKED

D6NOGO:	USTOR	T1,BT6ERR,(Q1)		;set the error code
	OKINT				;allow soft interrupts now
	RET				;fail


BTDRS4:	MOVE	T2,TODCLK		;record some final statistics
	USTOR	T2,BT6TFR,(Q1)		;when we finished
	MOVE	T2,$D6TRD(Q3)
	USTOR	T2,BT6TRD,(Q1)		;when header got here
	MOVE	T2,$D6TDD(Q3)
	USTOR	T2,BT6TDD,(Q1)		;when data got here
	RET

;init DTE and 11 for DN60 protocol - dispatched to from DTEINI
;parameters:	T1/DTE number
;		T3/ptr to 11's comm region
;		T4/ptr to 10's comm region
;		DTNUMB is a stkvar for DTE number

DTIND6:	PUSH	P,T3			; protect these
	PUSH	P,T4
	SKIPN	T2,D6DTP(T1)		;find work space for DTE
	JRST	[PUSH	P,T1
		 MOVE	T1,[.RESP3,,D6WDBS] ;get some work space for this DTE
		 MOVX	T2,<RS%SE0+.RESGP>
		 CALL	ASGRES
		 JRST	[POP P,T1	;couldn't
			 POP P,T4
			 POP P,T3
			 RET]		;fail
		 POP	P,T2		;recover slot ptr
		 EXCH	T1,T2		;retrieve the  DTE number,save the
		 MOVEM	T2,D6DTP(T1)	; associated workspace ptr
		 JRST	.+1]
	SETZRO	D6STS,(T2)		;T2/work space ptr
	STOR	T1,D6DTE,(T2)		;init some stuff
	SETOM	$D6FRK(T2)		;last forker that came by
	SETZM	$D6SUP(T2)		;none of them waiting in line
	POP	P,T4			;get the region ptrs
	POP	P,T3

					;now go init MCB protocol

D6INMC:	SETONE	<CMTST,CMINI>,(D)	;set my ini bit
	MOVE	B,CNDO(A)		;get prototype cono
	IORI	B,DTEPIE!DTEPI0		;turn on pi0 only
	XCT	B			;so -11 can examine its region
	CALL	DING11			;go ring -11's bell
	MOVEI	B,MCINI0		;timeout for first phase

D6INM1:	CALL	DTBELL			;go wait for doorbell or timeout
	JE	CMINI,(C),D6INM3	;see if it did it right
	CALL	CLRBEL			;clear doorbell
	SETZRO	CMINI,(D)		;clear ini bit
	CALL	DING11			;ring 11's bell again
	MOVEI	B,MCINI1		;time for this phase

D6INM2:	CALL	DTBELL			;go wait for doorbell or timeout
	JN	CMINI,(C),D6INM3		;make sure it did it right
	CALL	DTEON			;go turn protocol on
	JRST	DTESKD			;and start the protocol

;init failed - kill off dte

D6INM3:	SETONE	DTRLD,(A)		;set reload
	SETZRO	DTERL,(A)		;no longer running a protocol
	JRST	DTREST			;and reset the dte

;DTBELL - Wait for doorbell upto specified increment of time.
;[7.1280] Replace old DTBELL code
;
; Call with A/ DTE # 
;	    B/ time increment from now of when to time out
;
; Returns + 1 always

DTBELL:	ADD B,TODCLK		;calc wakeup time
	MOVEM B,DTETMR(A)	;save it
	PUSH P,A		;save the dte number
	HRLI A,DBTMR		;get scheduler test
	MOVSS A			;put things in right place
	HDISMS (^D2000)		;and wait
	POP P,A			;return dte number
	RET

REPEAT 0,<			;[7.1280] Remove edit 7449
;[7449]
;	  
; This code originally set up a scheduler test to wait for the
; doorbell. This caused SKDCL1 bughalts when the powerfail restart
; code ran. The new code waits for the doorbell without dismissing.

DTBELL:	SAVEAC <A>		;SAVE AWAY THE DTE #
	CALL NEWTIM		;(B/) CALCULATE NEW WAKE UP TIME
	LSH A,^D26		;PUT DTE # INTO CORRECT POSITION FOR CONSO
	ADD A,[CONSO DTE0,DTETDB] ;FORM FULL CONSO TEST INSTRUCTION
DTBEL1:	XCT A			;IS DOORBELL ON YET ?
	IFNSK.
	 CALL CHKTIM		;NO, (B/) TIME TO QUIT ? 
	  JRST DTBEL1		;NO, TRY IT AGAIN
	ENDIF.
	RET			;RETURN
>				;[7.1280] End of REPEAT 0

;DEDD60 handles cleaning up dead DN60 nodes
;	called from RELODR

DEDD60:	PUSH	P,T1			;save the dte number
	NOSKD1				;protect from contention
	SKIPN	T1,D6DTP(T1)		;get the workspace ptr
	JRST	DEDD6X			;already dead
	MOVX	T2,D6%NT6		;mark fe dead
	IORB	T2,$D6STS(T1)
	JUMPL	T2,DEDD6X		;currently in use
	SKIPE	$D6SUP(T1)		;not in use - check suplicants
	JRST	DEDD6X			;there are some - can't flush workspace
	CALL	RELRES			;release the storage
	POP	P,T1			;get the dte number back
	SETZM	D6DTP(T1)		;no more workspace
	JRST	DEDD6Y

DEDD6X:	POP	P,T1			;get dte number back

DEDD6Y:	OKSKD1
	RET

	RS	D6DTP,10		;DN60 workspace/dte table

;resident code for interrupt processes and scheduler tests

	RESCD

;scheduler tests

D6BWT:	SKIPGE	$D6STS(T1)		;dte busy wait test
	JRST	D6WKT			;check timer
	JRST	1(4)			;free now

D6RWT:	SKIPA	T2,[D6%RDN!D6%NT6]	;wait for response header test or death

D6DWT:	MOVX	T2,D6%DDN!D6%NT6	;wait for read data done test or death
	TDNN	T2,$D6STS(T1)		;T1/dte data base tpr
	JRST	(4)			;no - wait
	JRST	1(4)			;yes - go ahead

D6WKT:	SKIPE	T2,$D6CLK(T1)		;get the timer
	CAMG	T2,TODCLK		;set - check the tempis
	JRST	1(4)			;free now
	JRST	(4)			;more waiting

D6WAIT:	MOVE	T2,TODCLK		;T1/scheduler test
	ADDI	T2,^D1800
	SKIPN	$D6CLK(Q3)		;don't mung running timer
	MOVEM	T2,$D6CLK(Q3)		;set the alarm in the not too distant future
	HRL	T1,Q3			;give a handle
	HDISMS	(^D2000)		;an outrageous time
	SETZM	$D6CLK(Q3)		;kleen up
	RET

;interrupt processes

;the following two are called from TO11DN with T1/workspace ptr(driver unique code)

D6HDDN:	SKIPA	T2,[D6%HDD]		;to -11 done for header interrupt process

D6DTDN:	MOVX	T2,D6%DTD		;to -11 done for data interrupt process
	IORM	T2,$D6STS(T1)		;set write to -11 done flag
	RET

;the following is dispatched to from to -10 doorbell interrupt
;	T1/dte number
;	T4/11 comm region ptr

D6DRBL:	SKIPN	T2,D6DTP(T1)		;find workspace ptr
	JRST	DBLER			;not a DN60 fe
	PUSH	P,Q2
	PUSH	P,Q3
	DMOVE	Q2,T1			;save dte and workspace ptr
	LOAD	T1,D6STS,(Q3)		;get the transaction status
	LOAD	T2,CMQCT,(T4)		;yes - get the expected byte count(piecemeal)
	STOR	T2,DTEBC,(Q2)		;we will take it all - this,of course,
					; assumes the 11 honors the limit sent
	TXNE	T1,D6%RDN		;have we seen response header done?
	JRST	D6BL1			;yes - must be data doorbell
	STOR	T2,D6RBC,(Q3)		;save response header size
	JUMPE	T2,D6BL1		;if no response - no data either
	MOVEI	T2,D6HDR(Q3)		;beg word of buffer
	MOVEI	T3,D6HWSZ-1(T2)		;last word of buffer
	MOVSI	P1,(POINT 8)		;make byte ptr for dte
	HRR	P1,T2
	TXO	T1,D6%RBL		;have seen response header doorbell
	JRST	D6BL2

D6BL1:	TXO	T1,D6%DBL!D6%RDN	;have seen data doorbell and response done
	STOR	T2,D6RDC,(Q3)		;where the data goes
	JUMPE	T2,D6BL1A		;no data to read!
	TXNN	T1,D6%NDT		;are we expecting data?
	JRST	D6BL1B			;yes - read it
	SETZRO	D6RDC,(Q3)		;no - we won't do it
	TXO	T1,D6%ARD		;set error flag
D6BL1A:	TXO	T1,D6%DDN!D6%FDN	;got data doorbell but no data is to be
					;read - fake a to -10 done interrupt here
	STOR	T1,D6STS,(Q3)		;update transaction status
	JRST	DBLER0			;and go neutralize the doorbell

D6BL1B:	MOVEI	T3,D6BFS-1(T2)		;end of it all
	LOAD	P1,D6BDP,(Q3)		;get the beg byte ptr

D6BL2:	STOR	T1,D6STS,(Q3)		;update transaction status
	MOVEM	T2,DTEIND(Q2)
	MOVEM	T3,DTEEND(Q2)		;MCB version 5 wants this for some reason
	POP	P,Q3
	MOVE	T1,Q2
	POP	P,Q2
	CALL	SETRGN			;get the comm region ptrs again
	LSH	A,SDTE			;find proper dte group
	MOVEM	P1,DTETBP(A)		;store into the ept
	LSH	A,-SDTE			;restore dte number
	JRST	DOFRMC			;rejoin mcb code

DBLER0:	POP	P,Q3			;unexpected doorbell of some flavor
	MOVE	T1,Q2			;get dte number back
	POP	P,Q2
DBLER:	SETZRO	DTEBC,(T1)		;nullify this request
	RET

;to -10 done interrupt processing - called from TO10DN
;	T1/ dte number
;	T3/10 comm region ptr
;	T4/11 comm region ptr

DN10D6:	SKIPN	T2,D6DTP(T1)		;find the workspace
	JRST	DTEDNE			;strange - try to ignore
	LOAD	T3,D6STS,(T2)		;get the transaction status
	TXNN	T3,D6%RBL!D6%DBL	;have we seen any doorbells?
	JRST	DTEDNE			;curiouser
	TXNE	T3,D6%DBL		;yes - which
	TXOA	T3,D6%DDN		;data - we go the data
	TXO	T3,D6%RDN		;response header
	STOR	T3,D6STS,(T2)		;update the transaction status
	PUSH	P,TODCLK		;save nowness
	TXNN	T3,D6%DDN		;was this data ?
	JRST	D6DDN1			;header
	POP	P,$D6TDD(T2)		;record -10 done for data
	JRST	DTEDNE			;now go away in confidence
D6DDN1:	POP	P,$D6TRD(T2)		;record -10 done for response header
	JRST	DTEDNE

	RESCD

;KEEP ALIVE INSTRUCTION USED BY SCHED TO DO KEEP ALIVE FUNCTION
;FOR THE 11

KEPALV::AOS COMBUF+DTEN+1+KPALIV	;BUMP KEEP ALIVE COUNTER

  >			;** END IFN KLFLG ON FIRST PAGE **

	TNXEND
	END

