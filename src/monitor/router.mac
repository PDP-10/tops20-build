; Edit= 9171 to ROUTER.MAC on 22-Jun-90 by GSCOTT
;Prevent ROUNAV BUGCHKs when an endnode suddenly becomes a router (bug turned
;up by the DECrouter-2000 implementation); allocate a routing vector and give
;BUGINF ROUTEU when this happens. 
; Edit= 8988 to ROUTER.MAC on 2-Nov-88 by LOMARTIRE
;Merge Production changes to BUG text
; Edit= 8932 to ROUTER.MAC on 23-Aug-88 by LOMARTIRE
;Improve BUG. documentation
; UPD ID= 8608, RIP:<7.MONITOR>ROUTER.MAC.4,  11-Feb-88 17:17:36 by GSCOTT
;TCO 7.1218 - Update copyright date.
; UPD ID= 8441, RIP:<7.MONITOR>ROUTER.MAC.3,   4-Feb-88 16:20:19 by GSCOTT
;TCO 7.1210 - Set ROUCGV normally not dumpable.
; *** Edit 7480 to ROUTER.MAC by MCCOLLUM on 12-May-87
; Check RCDSR in circuit block instead of comparing NI addresses when sending
; router hellos to the Ethernet 
; *** Edit 7437 to ROUTER.MAC by MCCOLLUM on 10-Apr-87, for SPR #21441
; If endnode, throw out "router-hello" packets from routers in other area 
; *** Edit 7397 to ROUTER.MAC by MCCOLLUM on 18-Nov-86, for SPR #21441
; Don't drop NI packets from nodes in different areas. Send reponses through
; the area router. 
; *** Edit 7318 to ROUTER.MAC by MCCOLLUM on 11-Jun-86, for SPR #21246
; Alter PARAMETER macro to store values in full words and change some network
; management parameters to accept values in millseconds 
; Edit 7179 to ROUTER.MAC by PALMIERI on 29-Oct-85 (TCO 6.1.1548)
; Router often incorrectly selects itself to be the designated router. 
; Edit 7178 to ROUTER.MAC by PALMIERI on 29-Oct-85 (TCO 6.1.1547)
; In routine RHMASR STKVAR not initialized correctly and incorrectly placed
; label RHMAR1. 
; Edit 7177 to ROUTER.MAC by PALMIERI on 29-Oct-85 (TCO 6.1.1546)
; Node not entered into on-ethernet cache correctly. 
; Edit 7176 to ROUTER.MAC by PALMIERI on 29-Oct-85 (TCO 6.1.1545)
; Incomplete address displayed for adjacency down event. 
; UPD ID= 2306, SNARK:<6.1.MONITOR>ROUTER.MAC.125,   5-Aug-85 08:30:00 by PALMIERI
;TCO 6.1.1502 One too many passes made through the routing vector for non
;phase IV nodes in RTRBSV.
; UPD ID= 2270, SNARK:<6.1.MONITOR>ROUTER.MAC.124,  24-Jun-85 14:48:09 by PALMIERI
;TCO 6.1.1472  Load cost for each circuit at RTRBS1 when looping through
;circuit blocks.
; UPD ID= 2265, SNARK:<6.1.MONITOR>ROUTER.MAC.123,  21-Jun-85 14:23:31 by PALMIERI
;Increment the count of routing adjacencies when DR comes online to us if we
;are an endnode.
; UPD ID= 2252, SNARK:<6.1.MONITOR>ROUTER.MAC.122,  19-Jun-85 21:49:31 by PALMIERI
;TCO 6.1.1457  Don't build maybe vector if EVSDRP=0
; Fix several off-by-one bugs pertaining to last entry in reach vector
; UPD ID= 2219, SNARK:<6.1.MONITOR>ROUTER.MAC.121,  12-Jun-85 17:27:00 by PALMIERI
;TCO 6.1.1435  Remove reference to %RTEHS and %RTBSZ  Remove some redundant
; Increment 2 counters that were not being incremented. Adjust circuit re-open
; timer.
; UPD ID= 2175, SNARK:<6.1.MONITOR>ROUTER.MAC.120,   5-Jun-85 10:57:59 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 2011, SNARK:<6.1.MONITOR>ROUTER.MAC.119,  24-May-85 15:46:40 by MCCOLLUM
;TCO 6.1.1238 - Fix ROUEHM BUG.
; UPD ID= 2009, SNARK:<6.1.MONITOR>ROUTER.MAC.118,  24-May-85 15:04:54 by PALMIERI
;TCO 6.1.1407  Be certain to process all of the routing message even if Partial
; Routing Update Loss.  Compute highest address correctly for P.R.U.L.
; UPD ID= 1992, SNARK:<6.1.MONITOR>ROUTER.MAC.117,  17-May-85 16:13:10 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1981, SNARK:<6.1.MONITOR>ROUTER.MAC.116,  15-May-85 22:20:33 by PALMIERI
;TCO 6.1.1392  Add TOPS20 specific event 96.7 to signal NML (link watcher) that
; we have just opened a portal to an MCB DTE.
;TCO 6.1.1391  Close Ethernet portal on line down and try to reopen it a bit
; later.  This is so we get everthing back that NISRV owes us.
; UPD ID= 1929, SNARK:<6.1.MONITOR>ROUTER.MAC.115,   7-May-85 22:04:17 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1846, SNARK:<6.1.MONITOR>ROUTER.MAC.114,  30-Apr-85 12:15:22 by MCCOLLUM
;TCO 6.1.1238 - Fix BUG. documentation
; UPD ID= 1836, SNARK:<6.1.MONITOR>ROUTER.MAC.113,  26-Apr-85 13:18:11 by PALMIERI
;Make calls to RTEMFE JSPs
;Give a buginf if we receive a routing message from a non-routing node
;Make ROUCGV an buginf instead of bugchk
;Too many 4.14 events generated
;T1 and T2 not set up for call to RTRZAB when receiving empty hello and hence
;removing the adjacency
; UPD ID= 1698, SNARK:<6.1.MONITOR>ROUTER.MAC.112,  29-Mar-85 12:01:16 by PALMIERI
;Wrong state code loaded into AC at RHMNSD - MOVE ==>MOVX
; UPD ID= 1697, SNARK:<6.1.MONITOR>ROUTER.MAC.111,  29-Mar-85 11:16:13 by PALMIERI
;Release message if empty hello received on the Ethernet
; UPD ID= 1689, SNARK:<6.1.MONITOR>ROUTER.MAC.110,  27-Mar-85 15:18:01 by PALMIERI
;Cost was saved from T2 when it was in Q2 at ~ RTRBS1+10
; UPD ID= 1686, SNARK:<6.1.MONITOR>ROUTER.MAC.109,  25-Mar-85 18:47:31 by PALMIERI
;Set recompute flag when an endnode adjacency goes to the up state
; UPD ID= 1651, SNARK:<6.1.MONITOR>ROUTER.MAC.108,  19-Mar-85 16:48:18 by PALMIERI
;Fix up table of contents - Fix some events
;Notice errors from RTRCTD - Add circuit state rejected
; UPD ID= 1632, SNARK:<6.1.MONITOR>ROUTER.MAC.107,  13-Mar-85 18:01:44 by PALMIERI
;Increase EVTMLN from ^D40 to ^D50, Make TCIFLG a STKVAR in RTRBNV
;TCO 6.1.1260  Make loop node work for endnodes as best we can.
;Document some more BUG.s
; UPD ID= 1567, SNARK:<6.1.MONITOR>ROUTER.MAC.106,  25-Feb-85 15:44:16 by PALMIERI
;Clear address of desiginated router when clearing a circuit block
; UPD ID= 1559, SNARK:<6.1.MONITOR>ROUTER.MAC.105,  21-Feb-85 08:07:29 by PALMIERI
;Add missing wedges at NMXRNS
; UPD ID= 1558, SNARK:<6.1.MONITOR>ROUTER.MAC.104,  20-Feb-85 21:26:18 by PALMIERI
;Wrong form of symbol used for RNCCH and RNMBY at NMXRNS
; UPD ID= 1544, SNARK:<6.1.MONITOR>ROUTER.MAC.103,  20-Feb-85 14:10:49 by PALMIERI
;Wrong AC used in compare at RTRINI resulting of incorrectly setting ENFLG
; UPD ID= 1543, SNARK:<6.1.MONITOR>ROUTER.MAC.102,  20-Feb-85 14:08:23 by PALMIERI
;Need full word compare at RTRTM1+7  CAIGE => CAMGE
; UPD ID= 1539, SNARK:<6.1.MONITOR>ROUTER.MAC.101,  19-Feb-85 17:42:55 by PALMIERI
;Fix seconds since last zeroed for cicuits
; UPD ID= 1522, SNARK:<6.1.MONITOR>ROUTER.MAC.100,  13-Feb-85 17:36:06 by PALMIERI
;Add ENFLG to indicate if we are an endnode.  This supercedes loading from
;a cell and comparing with a value.
;Remove code to reserve emergency buffers, now in DNADLL
;Don't return node reachability change for node 0
; UPD ID= 1495, SNARK:<6.1.MONITOR>ROUTER.MAC.99,   8-Feb-85 15:50:03 by PALMIERI
;Extra code at RTRFD4 and RTRFD5
;Should not be able to SET/CLEAR maximum node address
; UPD ID= 1494, SNARK:<6.1.MONITOR>ROUTER.MAC.98,   8-Feb-85 14:40:50 by PALMIERI
;Circuit ID not correct for Adjacency up event if endnode
; UPD ID= 1486, SNARK:<6.1.MONITOR>ROUTER.MAC.97,   6-Feb-85 22:01:17 by PALMIERI
;TCO 6.1.1173 - Loop node adjacency pointer was being overwritten in RTRFWD
;Set RCTLR to negative of the routing timer for that circuit type
;Set send routing when adjacency comes up
; UPD ID= 1476, SNARK:<6.1.MONITOR>ROUTER.MAC.96,   4-Feb-85 16:58:35 by PALMIERI
;Some IDIVIs should be IMULIs for time based parameters
; UPD ID= 1475, SNARK:<6.1.MONITOR>ROUTER.MAC.95,   3-Feb-85 23:25:16 by PALMIERI
;TIMBAS is a value not a cell
; UPD ID= 1435, SNARK:<6.1.MONITOR>ROUTER.MAC.94,  31-Jan-85 15:29:56 by PALMIERI
;Next node is incorrect for out of area nodes whose in node number is in the
;endnode cache.
; UPD ID= 1433, SNARK:<6.1.MONITOR>ROUTER.MAC.93,  31-Jan-85 14:59:19 by PALMIERI
;Line down from DNADLL no longer causes NI circuit to be turned off
;Document some BUG???s, convert some parameters to accept seconds from NTMAN
; UPD ID= 1387, SNARK:<6.1.MONITOR>ROUTER.MAC.92,  22-Jan-85 13:24:38 by PALMIERI
;Add 2503 for executor as well
; UPD ID= 1382, SNARK:<6.1.MONITOR>ROUTER.MAC.91,  22-Jan-85 11:28:15 by PALMIERI
;Add TOPS20 specific parameter 2503 for the NODE JSYS function .NDGNT
; UPD ID= 1373, SNARK:<6.1.MONITOR>ROUTER.MAC.90,  21-Jan-85 13:51:58 by PALMIERI
;1340 broke state parameter for endnodes
; UPD ID= 1369, SNARK:<6.1.MONITOR>ROUTER.MAC.89,  21-Jan-85 10:54:29 by PALMIERI
;At PSINFO+12 the jump to RTEMFE should just return without freeing the message
; UPD ID= 1360, SNARK:<6.1.MONITOR>ROUTER.MAC.88,  17-Jan-85 17:34:16 by PALMIERI
;Set RTRMX3 to RTRMXN if it is greater than RTRMXN
;Ethernet addresses incorrectly formatted in event messages
; UPD ID= 1340, SNARK:<6.1.MONITOR>ROUTER.MAC.86,  15-Jan-85 21:25:48 by PALMIERI
;ENPARM un-necessarily checking maybe flag
;Add event 4.14 - Remove  TSTS6's and TO?RESCDs
; UPD ID= 1328, SNARK:<6.1.MONITOR>ROUTER.MAC.85,  14-Jan-85 16:03:35 by PALMIERI
;Remove references to %RTBSW
; UPD ID= 1298, SNARK:<6.1.MONITOR>ROUTER.MAC.84,   9-Jan-85 21:10:04 by PALMIERI
;Fix Update routine sending two too many bytes in routing message
; UPD ID= 1287, SNARK:<6.1.MONITOR>ROUTER.MAC.83,   8-Jan-85 13:44:49 by PALMIERI
;Bad CAIE over a STOR
; UPD ID= 1268, SNARK:<6.1.MONITOR>ROUTER.MAC.82,   4-Jan-85 13:57:15 by PALMIERI
;Add at RET under FTOPS20 at RTRJIF
; UPD ID= 1259, SNARK:<6.1.MONITOR>ROUTER.MAC.81,   2-Jan-85 15:57:02 by PALMIERI
;Remove call to DNDTIC
; UPD ID= 1238, SNARK:<6.1.MONITOR>ROUTER.MAC.80,  26-Dec-84 11:32:13 by NICHOLS
;Fix RTRCBS to take into account the suggested blocksize in the
;endnode-nocached case.
; UPD ID= 1209, SNARK:<6.1.MONITOR>ROUTER.MAC.79,  13-Dec-84 17:35:00 by PALMIERI
;Keep local router in the cache; have RTRCBS check for too large blocksize
; UPD ID= 1202, SNARK:<6.1.MONITOR>ROUTER.MAC.78,  12-Dec-84 18:06:12 by PALMIERI
;Fix cache timeout timer, and RTRCBS 
; UPD ID= 1191, SNARK:<6.1.MONITOR>ROUTER.MAC.77,  11-Dec-84 21:47:36 by PALMIERI
;When router is an endnode return node as next node if in cache
;Add RTRCBS for SCLINK to see if buffer size it was trying to use is reasonable
; UPD ID= 1161, SNARK:<6.1.MONITOR>ROUTER.MAC.76,   5-Dec-84 17:32:03 by GLINDELL
;Remove unnecessary intra-section calls
; UPD ID= 1132, SNARK:<6.1.MONITOR>ROUTER.MAC.75,  28-Nov-84 10:00:31 by PALMIERI
;Get/return parameters that are timers as milliseconds
; UPD ID= 1128, SNARK:<6.1.MONITOR>ROUTER.MAC.74,  26-Nov-84 15:25:43 by GLINDELL
;Remove EXTERNAL declaration of KONDSP
; UPD ID= 1125, SNARK:<6.1.MONITOR>ROUTER.MAC.73,  21-Nov-84 16:47:01 by PALMIERI
;RN%MBY should have been RNMBY at RTRBMV+
; UPD ID= 1119, SNARK:<6.1.MONITOR>ROUTER.MAC.72,  20-Nov-84 21:00:29 by PALMIERI
;Clean up code at NMXPCM
; UPD ID= 1083, SNARK:<6.1.MONITOR>ROUTER.MAC.71,  15-Nov-84 16:18:10 by PALMIERI
;Too many adjacency ups at RTCNIE
; UPD ID= 1080, SNARK:<6.1.MONITOR>ROUTER.MAC.70,  14-Nov-84 14:14:25 by PALMIERI
;Fix next node and circuit when executor is an endnode
; UPD ID= 1077, SNARK:<6.1.MONITOR>ROUTER.MAC.69,  14-Nov-84 13:36:59 by GLINDELL
;Fix IFIW's
; UPD ID= 1028, SNARK:<6.1.MONITOR>ROUTER.MAC.68,  12-Nov-84 14:46:36 by PALMIERI
;Fix checking of output blocksize exceeded when running as an endnode
; UPD ID= 988, SNARK:<6.1.MONITOR>ROUTER.MAC.67,   7-Nov-84 13:10:13 by PALMIERI
;Support for large buffers, fix a couple of network management parameters
;Try to support loop circuit on the Ethernet
; UPD ID= 903, SNARK:<6.1.MONITOR>ROUTER.MAC.66,  19-Oct-84 17:41:43 by PALMIERI
;Update table of contents
;Fix CAME bug at RTRZAB
;Add routine to check the DSR timer
; UPD ID= 896, SNARK:<6.1.MONITOR>ROUTER.MAC.65,  17-Oct-84 17:28:25 by PALMIERI
;More work on SELDSR
; UPD ID= 895, SNARK:<6.1.MONITOR>ROUTER.MAC.64,  17-Oct-84 16:08:06 by PALMIERI
;Fix NMXSHC
; UPD ID= 893, SNARK:<6.1.MONITOR>ROUTER.MAC.63,  17-Oct-84 15:41:24 by PALMIERI
;Fix seconds since zeroed again
; UPD ID= 890, SNARK:<6.1.MONITOR>ROUTER.MAC.62,  17-Oct-84 13:20:13 by PALMIERI
;Redo code to compute desiginated router, fix CICTAB seconds since zeroed
;Clean up code at RTIOTC and set the adjacency off-line at RTCERH+
; UPD ID= 880, SNARK:<6.1.MONITOR>ROUTER.MAC.60,  12-Oct-84 15:36:34 by PALMIERI
;KONCST index AC smashed
; UPD ID= 877, SNARK:<6.1.MONITOR>ROUTER.MAC.59,  12-Oct-84 14:10:02 by PALMIERI
;Make seconds since last zeroed return seconds not milliseconds
; UPD ID= 862, SNARK:<6.1.MONITOR>ROUTER.MAC.58,  10-Oct-84 16:09:10 by PALMIERI
;Move to extended section, enforce max routers on an Ethernet circuit
; UPD ID= 851, SNARK:<6.1.MONITOR>ROUTER.MAC.57,   5-Oct-84 17:10:05 by PALMIERI
;Fix Router type sent in point-to-point inits
; UPD ID= 837, SLICE:<6.1.MONITOR>ROUTER.MAC.53,  27-Sep-84 18:21:53 by PALMIERI
;Fix use of adjacency types at RTCIN0-5 or so
; UPD ID= 834, SLICE:<6.1.MONITOR>ROUTER.MAC.52,  26-Sep-84 21:04:03 by PALMIERI
;Move many of Router's variables from globals to locals.  Those that must be
;global are moved to D36COM
; UPD ID= 815, SLICE:<6.1.MONITOR>ROUTER.MAC.51,  24-Sep-84 12:06:49 by PALMIERI
;Fix endnode compares at NMXRAL and NMXSAN
; UPD ID= 811, SLICE:<6.1.MONITOR>ROUTER.MAC.49,  20-Sep-84 14:52:14 by PALMIERI
;Fix ROURML
; UPD ID= 807, SLICE:<6.1.MONITOR>ROUTER.MAC.48,  19-Sep-84 16:05:54 by GUNN
; Fix ROUATL BUG. macro. The short text description has a CRLF in it
; which causes a bad BUGSTRINGS.TXT file entry.
; UPD ID= 804, SLICE:<6.1.MONITOR>ROUTER.MAC.47,  18-Sep-84 17:08:09 by PALMIERI
;Fix endnode address computation at RTR2R4+22 or so
; UPD ID= 797, SLICE:<6.1.MONITOR>ROUTER.MAC.46,  14-Sep-84 18:47:44 by PALMIERI
;Return "no data" for "show adj nodes" if an endnode
;Change the way DCNSTA is checked
;Always use the newly built routing vector at RTRBNV
;If circuit fails to start from NMXSCS then clear restart timer
;Fix NMXPCM so next node returned correctly
; UPD ID= 788, SNARK:<6.1.MONITOR>ROUTER.MAC.45,   4-Sep-84 15:52:44 by PALMIERI
;Make counter/parameter table swappable - shuffle NMXPCM routine
; UPD ID= 779, SNARK:<6.1.MONITOR>ROUTER.MAC.44,  31-Aug-84 14:36:38 by PALMIERI
;Fix way desiginated router is returned to NTMAN
; UPD ID= 776, SNARK:<6.1.MONITOR>ROUTER.MAC.43,  31-Aug-84 13:46:52 by PALMIERI
;New network management
;Elective end node
;Revamp RTRUPD (RTRSRM) the routine to send routing updates
; UPD ID= 609, SNARK:<6.1.MONITOR>ROUTER.MAC.36,   8-Jun-84 09:50:51 by PALMIERI
;Make RTCL2M cough up its MB and return it to the free pool
; UPD ID= 603, SNARK:<6.1.MONITOR>ROUTER.MAC.35,   6-Jun-84 14:14:45 by GLINDELL
;Add Martys change to add new NSP function NV.RFR
; UPD ID= 596, SNARK:<6.1.MONITOR>ROUTER.MAC.34,   4-Jun-84 15:24:23 by PALMIERI
;When range checking Ethernet hello message size, don't include header
; UPD ID= 589, SNARK:<6.1.MONITOR>ROUTER.MAC.33,   1-Jun-84 12:08:51 by PALMIERI
;Fix AC usage at RTRTMR
; UPD ID= 586, SNARK:<6.1.MONITOR>ROUTER.MAC.32,  31-May-84 18:13:26 by GLINDELL
;Load RCLID word before calling RTNEVT
; UPD ID= 585, SNARK:<6.1.MONITOR>ROUTER.MAC.31,  31-May-84 17:53:47 by GLINDELL
;Initialize EVTSIG in RTNEVT
; UPD ID= 581, SNARK:<6.1.MONITOR>ROUTER.MAC.29,  31-May-84 15:21:15 by PALMIERI
; Change circuit reopen timer
; UPD ID= 570, SNARK:<6.1.MONITOR>ROUTER.MAC.28,  28-May-84 13:55:11 by PALMIERI
;Circuit down for the DTE is sent to NMX signal processor
; UPD ID= 568, SNARK:<6.1.MONITOR>ROUTER.MAC.27,  25-May-84 16:24:45 by PALMIERI
;Remove references to %RTBSZ
; UPD ID= 561, SNARK:<6.1.MONITOR>ROUTER.MAC.26,  24-May-84 15:30:58 by PALMIERI
;Allow no area number at RTCTST
; UPD ID= 549, SNARK:<6.1.MONITOR>ROUTER.MAC.25,  23-May-84 21:37:45 by PALMIERI
;Detect line state for NI after doing open so correct circuit state is set
;Add circuit reopen timer after Router detected circuit faults
; UPD ID= 536, SNARK:<6.1.MONITOR>ROUTER.MAC.22,  21-May-84 17:49:05 by PALMIERI
;Remove worthless broken code at RTREH3+13 and fix RTRZAA:
; UPD ID= 529, SNARK:<6.1.MONITOR>ROUTER.MAC.21,  20-May-84 20:39:13 by PALMIERI
;Fix circuit down code
; UPD ID= 519, SNARK:<6.1.MONITOR>ROUTER.MAC.20,  11-May-84 13:17:42 by PALMIERI
;Add new "failed" state to Network Management table
; UPD ID= 503, SNARK:<6.1.MONITOR>ROUTER.MAC.19,   7-May-84 11:24:51 by PALMIERI
;Close only DTE circuits at RTIDWN:
; UPD ID= 489, SNARK:<6.1.MONITOR>ROUTER.MAC.18,  30-Apr-84 16:43:12 by PALMIERI
;RTRSAO used P1 when it should use AJ
; UPD ID= 482, SNARK:<6.1.MONITOR>ROUTER.MAC.17,  30-Apr-84 12:55:08 by PALMIERI
;Change to new DNADLL interface
; UPD ID= 396, SNARK:<6.1.MONITOR>ROUTER.MAC.15,  19-Mar-84 16:47:21 by PALMIERI
;Call DNADLL intialization routine and once per second
; UPD ID= 383, SNARK:<6.1.MONITOR>ROUTER.MAC.14,  12-Mar-84 17:24:30 by PALMIERI
;Fixes to Phase IV routing message send routines
; UPD ID= 372, SNARK:<6.1.MONITOR>ROUTER.MAC.13,   5-Mar-84 16:00:49 by PALMIERI
;Fix loop at RTRSAO:, Don't clear broadcast circuit bit at RTRZCB:
; UPD ID= 365, SNARK:<6.1.MONITOR>ROUTER.MAC.12,   1-Mar-84 09:29:39 by PALMIERI
;When sending routing messages don't check adjacency type for now (fix later)
; UPD ID= 352, SNARK:<6.1.MONITOR>ROUTER.MAC.11,  24-Feb-84 17:50:29 by PALMIERI
;For endnodes count the hello as having heard from adjacency
; UPD ID= 351, SNARK:<6.1.MONITOR>ROUTER.MAC.10,  24-Feb-84 17:11:00 by PALMIERI
;Be sure to free message if RTRPNI get an error
; UPD ID= 346, SNARK:<6.1.MONITOR>ROUTER.MAC.9,  24-Feb-84 13:28:42 by PALMIERI
; UPD ID= 300, SNARK:<6.1.MONITOR>ROUTER.MAC.7,  20-Jan-84 15:51:24 by GLINDELL
;New event logger interface

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1984, 1990.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


      ;TITLE ROUTER - Routing Layer Service for DECnet-36  V050

	SUBTTL V. Brownell & Anthony J. Rizzolo/Tarl/AJR/HMP 15 Jan 85
	SEARCH D36PAR		;[9171]
	SALL

	ENTRY RTRINI

XP ROUTER,050
IFN FTOPS20,<
	SEARCH PROLOG
	TTITLE ROUTER,,< - Routing Layer Service for DECnet-36>
	>

IFN FTOPS10,<
	SEARCH F,S,MACSYM	;[9171]
	TITLE ROUTER - Routing Layer Service for DECnet-36
>;END OF IFN FTOPS10
	D36SYM			;SET UP D36 SPECIFIC PARAMETERS

IFN FTOPS10,<$RELOC>
	XRESCD			;RELOC TO HIGHSEG (RSCOD PSECT ON TOPS-20)
	Subttl	Table of Contents

;		     Table of Contents for ROUTER
;
;				  Section		      Page
;
;
;    1. Loose ends . . . . . . . . . . . . . . . . . . . . . .   6
;    2. Definitions
;        2.1    External References  . . . . . . . . . . . . .   7
;        2.2    Accumulators . . . . . . . . . . . . . . . . .   9
;        2.3    Macros . . . . . . . . . . . . . . . . . . . .  10
;        2.4    Packet Route Header  . . . . . . . . . . . . .  11
;        2.5    Router Control Message . . . . . . . . . . . .  12
;        2.6    Routing Vectors  . . . . . . . . . . . . . . .  13
;        2.7    NI Hello IINFO format  . . . . . . . . . . . .  14
;        2.8    Miscellaneous  . . . . . . . . . . . . . . . .  15
;    3. Network management tables  . . . . . . . . . . . . . .  16
;        3.1    Circuit counters . . . . . . . . . . . . . . .  17
;        3.2    Node parameters  . . . . . . . . . . . . . . .  18
;        3.3    Executor parameters  . . . . . . . . . . . . .  19
;        3.4    Circuit parameters . . . . . . . . . . . . . .  20
;    4. RTRINI - Initialize Router User  . . . . . . . . . . .  21
;    5. RTRON - Turn Router (and DECnet) On  . . . . . . . . .  22
;    6. RTROFF - Turn Router (and DECnet) Off  . . . . . . . .  23
;    7. RTRSEC - Once a second processing for Router . . . . .  24
;    8. RTRJIF - Once a jiffy processing for Router  . . . . .  25
;    9. RTRLCK - Get the RTR interlock . . . . . . . . . . . .  27
;   10. RTRXMT - NSP's entry into Router . . . . . . . . . . .  29
;   11. RTRFWD - Perform Routing of Message  . . . . . . . . .  30
;   12. RTR2RM - Send Message to Remote Node . . . . . . . . .  36
;   13. RTRBEH - Build header for ethernet data messages . . .  39
;   14. R2NODN - Return Output Done to NSP . . . . . . . . . .  40
;   15. R2NRTN - Return Message to NSP . . . . . . . . . . . .  41
;   16. R2NRCV - Pass received Message to NSP  . . . . . . . .  42
;   17. R2KINI - Initialize a Kontroller's Circuit . . . . . .  43
;   18. R2KCLS - Close the data link circuit . . . . . . . . .  44
;   19. CALKON - Call the Kontroller . . . . . . . . . . . . .  45
;   20. CALQOB - Call CALKON for queued output.  . . . . . . .  46
;   21. XMTFAI/CIRFAI - Transmit/Line failed . . . . . . . . .  47
;   22. RTRRCR - Recompute Routing . . . . . . . . . . . . . .  48
;   23. RTRBSV - Build scratch routing vector  . . . . . . . .  49
;   24. RTRBNV - Build the normal vector from scratch vector .  50
;   25. RTRBMV - Maybe vector update when running as an endnod  51
;   26. RTRUPD - Send routing messages if needed . . . . . . .  52
;   27. RTRSNI - Send hello/routing message on the NI  . . . .  59
;   28. CKECTO - Check the cache timer for each node . . . . .  60
;   29. SELDSR - Select a desiginated router . . . . . . . . .  61
;   30. RTRTMR - Routine to perform timer functions  . . . . .  62
;   31. RTRENH - Send Ethernet end-node hello  . . . . . . . .  69
;   32. RTRCHH - Build common part of Ethernet hellos  . . . .  70
;   33. DSRCHK - Check the DSR timer for each circuit  . . . .  71
	Subttl	Table of Contents (page 2)

;		     Table of Contents for ROUTER
;
;				  Section		      Page
;
;
;   34. Data Link Layer Interface  . . . . . . . . . . . . . .  72
;       34.1    RTICCB - Create circuit block  . . . . . . . .  74
;       34.2    RTILSC - Process line state change . . . . . .  75
;       34.3    RTIOTC - Process Output Complete . . . . . . .  76
;       34.4    RTIINC - Process Input Complete  . . . . . . .  77
;   35. RTRSTI - Send routing intitialization message  . . . .  80
;   36. Control Message Processors
;       36.1    RTCINI - Inititialization Messages . . . . . .  82
;       36.2    RTCVER - Verification Messages . . . . . . . .  84
;       36.3    RTCRTE - Routing Messages  . . . . . . . . . .  85
;       36.4    RTCTST - Test or Hello Messages  . . . . . . .  87
;       36.5    RTCL2M - Level 2 Routing Messages  . . . . . .  88
;       36.6    RTCERH - Ethernet Router Hello . . . . . . . .  89
;       36.7    RHMASE - Hello message if Endnode  . . . . . .  90
;       36.8    RHMASR - Hello message if Router . . . . . . .  91
;       36.9    RTCNIE - NI Endnode Hello message  . . . . . .  93
;   37. RTCILL - Illegal message received  . . . . . . . . . .  94
;   38. RTRBAV - Build adjacency's routing vector from routing  95
;   39. RTCRME - Routing message error processor . . . . . . . 100
;   40. RTRPNI - Parse a Message Header for NI Hello messages  101
;   41. PSINFO - Parse the info field of Ethernet router hello 102
;   42. RTRRCV - Read version information from message . . . . 103
;   43. RTRHDP - Parse a Input Router Message Header . . . . . 104
;   44. RTRCTD - Check for valid test pattern in Hello/Test me 107
;   45. RTRGNA - Get node address from message header  . . . . 108
;   46. PADSKP - Skip over pad bytes in an Ethernet message he 109
;   47. Network Management
;       47.1    RTRNMX - Entry into Router . . . . . . . . . . 110
;       47.2    Read/Set/Clear a parameter . . . . . . . . . . 111
;       47.3    Common routine for parameters  . . . . . . . . 112
;       47.4    Setup for loading parameter data . . . . . . . 113
;       47.5    Qualified parameters . . . . . . . . . . . . . 114
;       47.6    READ node/executor state . . . . . . . . . . . 115
;       47.7    Read circuit state . . . . . . . . . . . . . . 116
;       47.8    Set/Clear executor state . . . . . . . . . . . 117
;       47.9    Set/Clear circuit state  . . . . . . . . . . . 118
;       47.10   Show counters  . . . . . . . . . . . . . . . . 119
;       47.11   Return list  . . . . . . . . . . . . . . . . . 120
;       47.12   Show known/active nodes  . . . . . . . . . . . 121
;       47.13   Show adjacent nodes  . . . . . . . . . . . . . 122
;       47.14   Show active circuits . . . . . . . . . . . . . 123
;       47.15   Show known circuits  . . . . . . . . . . . . . 124
;       47.16   Return list of adjacencies on a circuit  . . . 125
	Subttl	Table of Contents (page 3)

;		     Table of Contents for ROUTER
;
;				  Section		      Page
;
;
;   48. Network Management Event Interface
;       48.1    Router Event Types . . . . . . . . . . . . . . 126
;       48.2    Event Reason Definitions . . . . . . . . . . . 128
;       48.3    RTNEVT - Event Reporter  . . . . . . . . . . . 129
;       48.4    Event Parameter Processors . . . . . . . . . . 130
;       48.5    Event Processor Subroutines  . . . . . . . . . 133
;       48.6    Miscellaneous Event Processors . . . . . . . . 134
;   49. Miscellaneous Routines
;       49.1    RTRSAO - Set Adjacency off line  . . . . . . . 136
;       49.2    RTRZCB - Zap Circuit Block . . . . . . . . . . 137
;       49.3    RTRZAA - Zap all Adjacancies associated with R 138
;       49.4    RTRZAB - Zap an adjacency block  . . . . . . . 139
;       49.5    RTRMCB - Make a Circuit Block  . . . . . . . . 141
;       49.6    RTRGCB - Get Circuit Block Pointer . . . . . . 142
;       49.7    CPYMSG - Copy all MSDs together  . . . . . . . 145
;       49.8    RTRGBS - Get maximum blocksize . . . . . . . . 146
;       49.9    RTRCBS - Get useable blocksize . . . . . . . . 147
;       49.10   FREMSG - Toss a Message  . . . . . . . . . . . 148
;       49.11   CKSNRM - Normalize Checksum  . . . . . . . . . 149
;   50. Local Router Storage . . . . . . . . . . . . . . . . . 150
;   51. End of ROUTER  . . . . . . . . . . . . . . . . . . . . 151
	SUBTTL Loose ends

;Fix events returned to NTMAN (poorly formatted)
;Don't do BUG??? in RTCRTE if endnode
;Improve LSH's at RTR2R4 - Build into RTROAV when entered into cache?
;Highest address in Partial Routing Update Loss

	SUBTTL Definitions -- External References

;These are the external references to the D36COM library of routines.

	EXT DNGINI		;INITIALIZE FOR INPUT (DGXYBY)
	EXT DNPINI		;INITIALIZE FOR OUTPUT (DPXYBY)

	EXT DNP1BY		;PUT ONE BYTE IN MESSAGE
	EXT DNP2BY		;PUT TWO BYTES IN MESSAGE
	EXT DNPHIO		;Put 4 bytes of ethernet address into message
	EXT DNPENA		;DEPOSIT 6 BYTES FOR NI ADDRESSES
	EXT DNPEBY		;PUT AN EXTENSIBLE BYTE IN MESSAGE
	EXT DNPZB		;Write (T1) bytes of zeros into the message

	EXT DNG1BY		;GET ONE BYTE FROM MESSAGE
	EXT DNG2BY		;GET TWO BYTES FROM MESSAGE
	EXT DNGHIO		;Get four bytes of hi-order ethernet address
	EXT DNGENA		;GET SIX BYTES FROM MESSAGE
	EXT DNGEBY		;GET EXTENSIBLE BYTE FROM MESSAGE

	EXT DNGMSG		;GET DECNET-36 MESSAGE BLOCK
	EXT DNFMSG		;FREE MESSAGE BLOCK
	EXT DNMINI		;RE-USE MESSAGE BLOCK

	EXT DNNMSG		;GET NUMBER OF BUFFERS AVAILABLE TO ROUTER

	EXT DNLENG		;GET THE MESSAGE LENGTH
	EXT DNSLNG		;FIND THE SEGMENT LENGTH

	EXT DNGWDS		;GET SOME WORDS
	EXT DNGWDZ		;GET SOME ZEROED WORDS
	EXT DNFWDS		;FREE SOME WORDS
	EXT DNSWDS		;SMEAR SOME WORDS

	EXT DNBKBY		;GO BACKWARDS SOME BYTES
	EXT DNSKBY		;SKIP SOME BYTES

	EXT DNRPOS		;RETURN POSTION IN MESSAGE
	EXT DNGPOS		;GO TO POSITION IN MESSAGE
	EXT DNGOPS		;GO TO POSITION IN OUTPUT MESSAGE

	EXT DNLMSS		;LINK MESSAGE SEGMENT INTO MESSAGE BLOCK
	EXT DNCPMS		;COPY MESSAGE BLOCKS

	EXT UPDTCK		; Better TODCLK
	EXT DNGTIM		;RETURN CURRENT UPTIME (IN MS)
	EXT NTPARM		; Routine to load parameters
	EXT NTCTRS		; Routine to load counters

	EXT TIMBAS		;Fractions of a second used for time
				; computation

;References to DNADLL

	EXT DNDDSP		;Entry into DNADLL
	EXT DNDINI		;Initialization point for DNADLL
	EXT DNDSEC		;DNADLL second routine

;These are external data locations.

	EXT DCNSTA		;THE STATE VARIABLE OF DECNET
	EXT DCNTSB		;Maximum system buffers
	EXT RTRHOM		; Home area
	EXT RTRADR		; Our node number
	EXT RTRHIO		; High order Ethernet address
	EXT RTRLOO		; Low order Ethernet address
	EXT RTRBSZ		; Blocksize we advertise
	EXT RTRMXN		; Maximum node address we talk to
	EXT RTRMX3		; Maximum number of Phase III nodes
	EXT RTRVER		; Version of ROUTER
	EXT RTRECO		; ECO level of ROUTER
	EXT RTRCUS		; Customer version

	EXT IBBLK		;DECnet-36 initialization block

;This is the reference to LLINKS.

	EXT NSPRTR		;THE ONE AND ONLY

;We need to know our node name for Phase II NI messages.

	EXT SCTA2N		;PERFORM TRANSLATION FROM ADDRESS TO NODE NAME
;These are some default parameters

	EXT %RTMXN		;DEFAULT MAXIMUM NODE NUMBER
	EXT %RTMXC		;DEFAULT MAXIMUM CIRCUIT COST
	EXT %RTMXH		;DEFAULT MAXIMUM HOPS
	EXT %RTMX3		;MAXIMUM NUMBER OF PHASE III NODES
	EXT %RTMXV		;MAXIMUM VISITS COUNT
IFN FTOPS10,EXT %RTADR		;DEFAULT LOCAL ADDRESS
	EXT %RTRMA		;"ALL ROUTERS" MULTICAST ADDRESS
	EXT %RTEMA		;"ALL ENDNODES" MULTICAST ADDRESS
	EXT %RTHIO		;HI PART OF THE NI ADDRESS
	EXT %RTHOM		;HOME AREA FOR THIS NODE
	EXT %RTMXR		;Default maximum number of routers on the NI
	EXT %RTBRA		;NUMBER OF BROADCAST ROUTER ADJACENCIES
	EXT %RTBEA		;NUMBER OF BROADCAST ENDNODE ADJACENCIES
	EXT %RTPRI		;Priority to be the designated router (NI)
	EXT %RTTM1		;LONG TIMER FOR POINT TO POINT
	EXT %RTBT1		;LONG TIMER FOR BROADCAST
	EXT %RTTM3		;DEFAULT HELLO MESSAGE TIMER
	EXT %RTTM4		;DEFAULT NODE LISTENER TIMEOUT VALUE
	EXT %RTT3M		;HELLO TIMER MULTIPLIER FOR NON-BROADCAST
	EXT %RTB3M		;HELLO TIMER MULTIPLIER FOR BROADCAST CIRCUITS
	EXT %RTITM		;TI TIMER
	EXT %RTCTO		;Time we can spend in cache without update
	EXT %RTCST		;DEFAULT CIRCUIT COST
	EXT %RTVER		;ROUTER VERSION NUMBER
	EXT %RTECO		;EDIT LEVEL
	EXT %RTCUS		;CUSTOMER EDIT LEVEL

;Other external references

	EXT NMXEVT		;REPORT AN EVENT TO NMX
	EXT NTEIPV		;TELL NETWORK MANAGEMENT THAT BAD VALUE

	EXT KONCST		;TABLE OF DEFAULT COSTS PER KONTROLLER TYPE

	EXT EVSDRP		;Whether as an endnode we listen to packets
				; sent to multicast ID "all routers"

	EXT RTN			;NON-SKIP RETURN
	EXT RSKP		;SKIP RETURN


;Interlock management

IFN FTOPS10,<
;	EXT RTRLOK		;ROUTER INTERLOCK
;	EXT RTRLKO		;INTERLOCK OWNER
	EXT .CPCPN		;CURRENT CPU NUMBER
	EXT .CPSK0		;SKIP IF CURRENT CPU IS BOOT CPU
>
	SUBTTL Definitions -- Accumulators

;These are some local AC defintions for Router-36.

	RC=FREE1		;RC USUALLY POINTS TO THE CIRCUIT BLOCK
	AJ=FREE2		;AJ USUALLY POINTS TO THE ADJACENCY ENTRY

	PURGE FREE1		;LOSE THIS SYMBOL
	PURGE FREE2		;LOSE THIS ONE TOO

	SUBTTL Definitions -- Macros

;Event Logging Macro

DEFINE EVENT(TYPE,TEXT,MSGBLK),<
	CALL [
IFN FTTRACE,<
	      ETRACE RTR,<RTR Event: 'TEXT>
>
	      MOVX T1,TYPE	;;PUT EVENT TYPE IN T1
IFNB <MSGBLK>,MOVE T4,'MSGBLK	;;IF HE GAVE MB POINTER, GIVE IT
IFB <MSGBLK>, SETZ T4,		;;IF NOT, GIVE RTNEVT A ZERO
	      CALLRET RTNEVT]	;;CALL THE EVENT PROCESSOR AND RETURN
>

REPEAT 0,<
DEFINE EVENT(TYPE,TEXT,MSGBLK),<
	CALL RTNEVT
	CAI [IFN FTTRACE,<ETRACE RTR,<RTR Event: 'TEXT>>
	     TYPE
	     MSGBLK]
>
>
	SUBTTL Definitions -- Packet Route Header

;The first byte of the packet route header is defined in the Router
;section of the message block structure.  This is purely for convience
;sake.  The whole byte is called RMFST and each bit is defined within
;this field.

;The only other field that has to be defined (other than the source and
;destination address) is the FORWARD field which simply consists of the
;VISITS field.

BEGSTR FW			;FORWARD BYTE
	FIELDM VST,77		; VISITS COUNT
ENDSTR

	SUBTTL Definitions -- Router Control Message

;The following are field definitions for the Router Control messages.

;Control message all begin with the field CTLFLG, which specifies the type
;of control message.

BEGSTR CM			;CTLFLG
	FIELDM TYP,7_1		; TYPE OF MESSAGE
	FIELDM CTL,1
ENDSTR

;These are the various types of router control messages (in CMTYP).

	XP RCM.TI,0		;Router init
	XP RCM.TV,1		;Router verification
	XP RCM.TT,2		;Router hello and test
	XP RCM.1R,3		;Level 1 routing message
	XP RCM.2R,4		;Level 2 routing message
	XP RCM.RH,5		;Ethernet Router hello message
	XP RCM.EH,6		;Ethernet Endnode hello mesaage

;Routing control messages consist of a RTGINFO entry for every node in
;the network, followed by a two byte checksum.

BEGSTR RG			;RTGINFO
	FIELDM HOP,37_^D10	; HOPS
	FIELDM CST,1777		; COST
ENDSTR


;Transport Initialization control messages start with field TIINFO which
;contains the node type and verification required flags.

BEGSTR TI			;TIINFO
	FIELDM RSV,36_3		; RESERVED
	FIELDM BLO,1_3		;BLOCKING REQUESTED
	FIELDM VER,1_2		; VERIFY FLAG
	FIELDM NTY,3		; NODE TYPE
ENDSTR

	XP TI.MXL,^D12		;MAX LENGTH OF ROUTER INIT MSG

;These are the possible types of nodes that can be at the other end
;of a circuit (in FIELD TINTY).

	XP ANT.XX,0		;RESERVED
	XP ANT.L2,1		;LEVEL 2 ROUTER
	XP ANT.L1,2		;LEVEL 1 ROUTER
	XP ANT.RT,2		;ROUTING
	XP ANT.NR,3		;NON-ROUTING


;Router hello message has NO.HEL bytes of the byte HEL.LO.

	XP NO.HEL,^D10		;NUMBER OF TEST BYTES
	XP NO.NIH,^D64		;Number of test bytes in endnode hello
	XP HEL.LO,^O252		;CONSTANT FOR HELLO AND TEST MESSAGES

	SUBTTL Definitions -- Routing Vectors

;These are the definitions for each entry in both the scratch and the
;normal routing vectors.  The vectors consist of one entry for each
;possible node in the network.  Non-existant (un-reachable) nodes are
;set to the maximum node cost and hops.

BEGSTR RN
	FIELD FLG,6		;Flags
	  BIT RCH		;If set, node is reachable
	  BIT LCL		;Node is local NSP user
	  BIT CHG		;Node status was changed
	  BIT CCH		;Node is in the on-ethernet cache
	  BIT MBY		;Node maybe reachable (if we are an endnode)
	FILLER 15
	FIELD HOP,5		;MIN HOPS
	FIELD CST,10		;MIN COST
ENDSTR

;Define right justified symbols for max-cost and max-hops.

	XP RN%CST,MASK.(WID(RNCST),^D35) ;MAX COST
	XP RN%HOP,MASK.(WID(RNHOP),^D35) ;MAX HOPS

	SUBTTL Definitions -- NI Hello IINFO format

BEGSTR II
	FIELDM TYP,3		;NODE TYPE
	FIELDM VRQ,1_2		;VERIFICATION REQUIRED (0 FOR NI)
	FIELDM RJF,1_3		;REJECT FLAG
	FIELDM VFL,1_4		;VERIFICATION FAILED
	FIELDM MTA,1_5		;NO MULTI-CAST ACCEPTED
	FIELDM BRQ,1_6		;BLOCKING REQUESTED FLAG
	FIELDM RSV,1_7		;RESERVED BIT
ENDSTR

;These are the values in the IITYP field

	XP IIT.L2,1		;LEVEL 2 ROUTER
	XP IIT.L1,2		;LEVEL 1 ROUTER
	XP IIT.EN,3		;ENDNODE

	SUBTTL Definitions -- Miscellaneous


	SUBTTL  Network management tables
	SUBTTL  Network management tables -- Executor counters

;Generate the executor counter table
	XSWAPCD
EXCTAB:

COUNTER(^D900,^D8,<MOVE T1,RTRCAP>,<SETZM RTRCAP>,,<Aged packet loss>)
COUNTER(^D901,^D16,<MOVE T1,RTRCNU>,<SETZM RTRCNU>,,<
	Node unreachable packet loss>)
COUNTER(^D902,^D8,<MOVE T1,RTRCNO>,<SETZM RTRCNO>,,<
	Node out-of-range packet loss>)
COUNTER(^D903,^D8,<MOVE T1,RTRCOP>,<SETZM RTRCOP>,,<Oversized packet loss>)
COUNTER(^D910,^D8,<MOVE T1,RTRCPF>,<SETZM RTRCPF>,,<Packet format error>)
COUNTER(^D920,^D8,<MOVE T1,RTRCPR>,<SETZM RTRCPR>,,<
	Partial routing update loss>)
COUNTER(^D930,^D8,<MOVE T1,RTRCVR>,<SETZM RTRCVR>,,<Verification reject>)

EXCTBL==.-EXCTAB

	SUBTTL  Network management tables -- Circuit counters

CICTAB:			;Circuit counters maintained by the circuit

COUNTER (^D0,^D16,<CALL [SAVEAC <T2>
			 LOAD T2,RCSLZ,(RC)	; Time stamp of last zeroed
			 CALL DNGTIM		; Current time
			 SUB T1,T2		; Compute milliseconds
			 IDIVI T1,TIMBAS	;  and return as seconds
			 RET ]>,<
		   CALL [CALL DNGTIM
			 STOR T1,RCSLZ,(RC)
			 RET ]>,,<Seconds since zeroed>)

COUNTER(^D800,^D32,<LOAD T1,RCCAP,(RC)>,<SETZRO RCCAP,(RC)>,,<
	Terminating packets received>)
COUNTER(^D801,^D32,<LOAD T1,RCCDP,(RC)>,<SETZRO RCCDP,(RC)>,,<
	Originating packets sent>)
COUNTER(^D802,^D16,<LOAD T1,RCCAL,(RC)>,<SETZRO RCCAL,(RC)>,,<
	Terminating congestion loss>)
COUNTER(^D810,^D32,<LOAD T1,RCCTR,(RC)>,<SETZRO RCCTR,(RC)>,,<
	Transit packets received>)
COUNTER(^D811,^D32,<LOAD T1,RCCTS,(RC)>,<SETZRO RCCTS,(RC)>,,<
	Transit packets sent>)
COUNTER(^D812,^D16,<LOAD T1,RCCTL,(RC)>,<SETZRO RCCTL,(RC)>,,<
	Transit congestion loss>)
COUNTER(^D820,^D8,<LOAD T1,RCCCD,(RC)>,<SETZRO RCCCD,(RC)>,,<Circuit down>)
COUNTER(^D821,^D8,<LOAD T1,RCCIF,(RC)>,<SETZRO RCCIF,(RC)>,,<
	Initialization failure>)
COUNTER (^D2500,^D16,<LOAD T1,RCBSX,(RC)>,<SETZRO RCBSX,(RC)>,,<
	Transmit packets discarded-blocksize exceeded>)

CICTBL==.-CICTAB

	SUBTTL  Network management tables -- Node parameters

NOSET==PANST	;From BEGSTR in D36PAR
NOCLR==PANCL
BEX==PABEX	;Buffer expected

NDPTAB:
PARAMETER(0,<NOSET!NOCLR>,,,,,<CALL NMXRNS>,,<Node state>)
PARAMETER(^D810,<NOSET!NOCLR>,,,,<TRN>,< CALL [SKIPN AJ
						RNMXND
					       LOAD T2,AJNTY,(AJ)
					       RNMXOK ]>,<TRN>,<
	Adjacency type>)
PARAMETER(^D820,<NOSET!NOCLR>,,,,<TRN>,< CALL [SKIPN P2
						RNMXND
					       LOAD T2,RNCST,(P2)
					       RNMXOK ]>,<TRN>,<Cost>)
PARAMETER(^D821,<NOSET!NOCLR>,,,,<TRN>,< CALL [SKIPN P2
						RNMXND
					       LOAD T2,RNHOP,(P2)
					       RNMXOK ]>,<TRN>,<Hops>)
PARAMETER(^D822,<NOSET!NOCLR>,,,,<TRN>,<LOAD T2,RCLID,(RC)>,<TRN>,<Circuit>)
PARAMETER(^D830,<NOSET!NOCLR>,,,,<TRN>,< CALL [SKIPN AJ
						RNMXND
					       MOVE T2,RTRNTY
					       CAIE T2,RNT.NR
					       IFSKP.
						 LOAD T2,NFEID,(P1)
						 MOVE T1,T2
						 LSH T1,-^D10
						 CAME T1,RTRHOM
						 IFSKP.
						   TXZ T2,RN%ARE
						   ADD T2,RTRNRV
						   TMNN RNCCH,(T2)
						   IFSKP.
						     LOAD T2,NFEID,(P1)
						     RNMXOK
						   ENDIF.
						 ENDIF.
					       ENDIF.
					       LOAD T2,AJADR,(AJ)
					       RNMXOK ]>,<TRN>,<
	Next node>)

;Note:  The following parmameter is used for the NODE JSYS function .NDGNT
;	only.  Is is NEVER used by NTMAN and is not part of the specified
;	DECnet architecture.

PARAMETER(^D2503,<NOSET!NOCLR>,,,,,<CALL NMXRNS>,,<Node state-I DECnet only>)

NDPTBL==.-NDPTAB

	SUBTTL  Network management tables -- Executor parameters

EXPTAB:

PARAMETER(0,,,,<DS.ON>,<CALL NMXSES>,<CALL NMXRNS>,<CALL NMXSES>,<
	Executor state>)
PARAMETER(^D900,<NOSET!NOCLR>,,,,,<CALL [ MOVE T1,RTRVER
					  STOR T1,VNVER,+T2
					  MOVE T1,RTRECO
					  STOR T1,VNECO,+T2
					  MOVE T1,RTRCUS
					  STOR T1,VNUCO,+T2
					  RNMXOK]>,<TRN>,<Routing version>)
PARAMETER(^D901,,,,<RNT.L1>,<TRN>,<MOVE T2,RTRNTY>,<TRN>,<Router type>)
PARAMETER(^D910,,^D65535*TIMBAS,,<%RTTM1>,<MOVEM T2,RTRTM1>,<MOVE T2,RTRTM1>,<MOVEM T2,RTRTM1>,<Maximum update interval timer>)	;[7318]
PARAMETER(^D912,,^D65535*TIMBAS,,<%RTBT1>,<MOVEM T2,RTRBT1>,<MOVE T2,RTRBT1>,<MOVEM T2,RTRBT1>,<Max broadcast update int. timer>) ;[7318]
PARAMETER(^D920,<NOSET!NOCLR>,,,,,<MOVE T2,RTRMXN>,,<Maximum address>)
PARAMETER(^D921,,<^D20>,<^D1>,<^D20>,<MOVEM T2,RTRMCN>,<MOVE T2,RTRMCN>,<
	MOVEM T2,RTRMCN>,<Maximum number of circuits>)
PARAMETER(^D922,,<^D1022>,<1>,<%RTMXC>,<MOVEM T2,RTRMXC>,<MOVE T2,RTRMXC>,<
	MOVEM T2,RTRMXC>,<Maximum circuit cost>)
PARAMETER(^D923,,<^D30>,<1>,<%RTMXH>,<MOVEM T2,RTRMXH>,<MOVE T2,RTRMXH>,<
	MOVEM T2,RTRMXH>,<Maximum hops>)
PARAMETER(^D924,,<^D30>,<1>,<%RTMXV>,<MOVEM T2,RTRMXV>,<MOVE T2,RTRMXV>,<
	MOVEM T2,RTRMXV>,<Maximum visits>)
PARAMETER(^D926,,<^D1022>,<0>,<%RTBEA>,<MOVEM T2,RTNBEA>,<MOVE T2,RTNBEA>,<
	MOVEM T2,RTNBEA>,<Maximum broadcast endnode adjacencies>)
PARAMETER(^D927,,<^D64>,<0>,<%RTBRA>,<MOVEM T2,RTNBRA>,<MOVE T2,RTNBRA>,<
	MOVEM T2,RTNBRA>,<Maximum broadcast router adjacencies>)
PARAMETER(^D930,<NOSET!NOCLR>,,,,,<LOAD T2,IBMXB,+IBBLK>,,<Maximum buffers>)
PARAMETER(^D931,<NOSET!NOCLR>,,,,,<MOVE T2,RTRBSZ>,,<Maximum buffer size>)
PARAMETER(^D932,<NOSET!NOCLR>,,,,,<MOVE T2,RTRBSZ>,,<Segment buffer size>)

;See note above
PARAMETER(^D2503,<NOSET!NOCLR>,,,,,<CALL NMXRNS>,,<Node state-I DECnet only>)

EXPTBL==.-EXPTAB

	SUBTTL  Network management tables -- Circuit parameters
CCPTAB:

PARAMETER(0,,,,<NCK.OF>,<CALL NMXSCS>,<CALL NMXRCS>,<CALL NMXSCS>,<
	Circuit state>)

PARAMETER(^D800,<NOSET!NOCLR!BEX>,,,,,<CALL NMXRAL>,,<Adjacent node(s)>)
PARAMETER(^D801,<NOSET!NOCLR>,,,,,<CALL [ LOAD T2,RCDSL,(RC)
					  HRLZ T2,T2
					  CALL CVTSTN
					  RNMXOK]>,,<Desiginated router>)
PARAMETER(^D810,<NOSET!NOCLR>,,,,,<CALL NMXQPS>,,<Block size>)
PARAMETER(^D900,,<^D25>,<1>,<1>,<STOR T2,RCCST,(RC)>,<LOAD T2,RCCST,(RC)>,<
	STOR T2,RCCST,(RC)>,<Cost for this circuit>)
PARAMETER(^D901,,<^D255>,<0>,<%RTMXR>,<STOR T2,RCMXR,(RC)>,<
	LOAD T2,RCMXR,(RC)>,<
	STOR T2,RCMXR,(RC)>,<Maximum routers on this circuit>)
PARAMETER(^D902,,<^D127>,<0>,<0>,<MOVEM T2,RTRPRI>,<MOVE T2,RTRPRI>,<
	MOVEM T2,RTRPRI>,<Priority to be designated router>)
PARAMETER(^D906,,<^D8191*TIMBAS>,<1*TIMBAS>,<%RTTM3>,<STOR T2,RCTM3,(RC)>,<LOAD T2,RCTM3,(RC)>,<STOR T2,RCTM3,(RC)>,<Hello timer>) ;[7318]
PARAMETER(^D907,<NOSET!NOCLR>,,,,,<CALL NMXQPT>,,<
	Listen timer>)

CCPTBL==.-CCPTAB

	XRESCD

	SUBTTL RTRINI - Initialize Router User

;RTRINI - Set up a router user
;
; Call: 
;	with nothing
;
; Return: 
;	RET			;ON RESOURCE FAILURE
;	RETSKP			;ON SUCCESS
;
; Uses: T1-T3
;
;This routine gets called at system initialization.  It sets up the memory
;for the routing vectors and the node type vector.  Must be called before
;DECnet is turned on.


	INTERN RTRINI
	XSWAPCD

RTRINI:	TRACE RTR,<Initializing Router>

;Get the Router parameters defined in SETSPD's config file

	XMOVEI T2,IBBLK		; Get pointer to initialization block
	LOAD T1,IBRTR,(T2)	; Get Router type desired
	MOVEM T1,RTRNTY		; Save as our node type
	SETZM ENFLG		; Assume routing IV
	CAIN T1,RNT.NR		; Are we an endnode today?
	 SETOM ENFLG		; Yes, then non-routing IV
	LOAD T1,IBADR,(T2)	; Get 16 bit node address
	MOVEM T1,RTRNAD
	TXZ T1,RN%ARE		; Clear the area number
	MOVEM T1,RTRADR		;  and save the node number
	MOVE T1,RTRNAD		; Now get the area number
	TXZ T1,RN%NOD		;  from the address
	LSH T1,-^D10		; Right justify
	MOVEM T1,RTRHOM
	LOAD T1,IBBSZ,(T2)	; Get blocksize to use
	CAMGE T1,RTRBSZ		; Compare with default (576)
	 MOVEM T1,RTRBSZ	; If smaller use that, else keep default
	LOAD T1,IBMXA,(T2)	; Get the maximum node address
	MOVEM T1,RTRMXN
	CAMGE T1,RTRMX3		; Is it less than maximum for Phase III nodes?
	 MOVEM T1,RTRMX3	; Yes, use it then

;Here to allocate the "normal" and "scratch" routing vectors.

	MOVE T1,RTRMXN		;GET THE MAXIMUM NODE NUMBER
	ADDI T1,1		;Add one for node 0 (nearest area router)
	ASH T1,1		;MAKE IT TWICE AS LONG (HALF FOR REACH VECTOR
				; HALF FOR OUTPUT ADJACENCY VECTOR)
	CALL DNGWDZ		;GET THAT MANY WORDS
	 RET			;COULD NOT INITIALIZE
	MOVEM T1,RTRNRV		;SAVE POINTER TO NORMAL ROUTING VECTOR
	MOVE T2,RTRMXN		;GET OUR CURRENT MAXIMUM NODES
	ADDI T2,1		;START THE RTRNOV AT ONE ALSO
	MOVEM T2,RTROFS		;SAVE AS OFFSET FROM START OF NRV AND SRV
				; NOTE THAT MXN CANNOT GET LARGER!
	ADD T1,T2		;CALCULATE START OF NORMAL OUTPUT VECTOR
	MOVEM T1,RTRNOV		;SAVE IT

	MOVE T2,RTRNRV		;PREPARE TO CALC END OF SMEAR
	ADD T2,RTRMXN		;ADD NUMBER OF ENTRIES TO SPRAY
	MOVE T1,RTRNRV		;POINT TO THE HEAD OF THE NORMAL VECTOR
	MOVX T3,RNHOP!RNCST	;SMEAR WITH MAXIMUM COST AND HOPS
	CALL DNSWDS		;SPRAY THE BLOCK WITH MAXS

	MOVE T1,RTRMXN		;GET MAXIMUM NODE NUMBER
	ADDI T1,1		;ONE MORE FOR NODE 0
	ASH T1,1		;MULT BY TWO (ONE FOR SRV, ONE FOR SOV)
	CALL DNGWDZ		;GET THE WORDS FOR SCRATCH VECTOR
	 RET			;OOPS, GIVE BAD RETURN
	MOVEM T1,RTRSRV		;SAVE THE SCRATCH ROUTING VECTOR POINTER
	ADD T1,RTROFS		;CALCULATE START OF SOV
	MOVEM T1,RTRSOV		;SAVE SOV FOR LATER USERS

;Get and initialize an EC (Event Communication) block

	MOVX T1,EV.GEC		;Function code "get EC block"
	CALL NMXEVT
	  RET			;  -failed to get memory for block
	MOVEM T1,RTRECP		;Save pointer
	MOVX T2,^D8		;ROUTER may queue 8 event blocks on queue
	STOR T2,ECMAX,(T1)

	CALL DNDINI		;Initialize DNADLL
	RETSKP			;RETURN NICELY

	SUBTTL RTRON - Turn Router (and DECnet) On

;RTRON - Turn Router (and DECnet) On
;
; Call:
;	With nothing special
;
; Return:
;	RET			;ON FAILURE (DECNET IS ALREADY ON, NO
;				;LOCAL NODE NUMBER DEFINED, ETC.)
;	RETSKP			;WITH DECNET TURNED ON
;
; Uses: T1-T4
;
;Note that RTRINI must be called to set up the routing vectors for
;Router before DECnet is turned on.

	INTERN RTRON

RTRON:	SAVEAC <RC,AJ>
	MOVE T1,DCNSTA		;Get DECnet state
	CAIE T1,DS.ON		;Is it on?
	 SKIPN T1,RTRADR	;AND DO WE HAVE AN ADDRESS FOR ROUTER?
	  RET			;NO, CANNOT TURN DECNET ON YET

	DPB T1,[POINTR (T2,RN%NOD)] ; Generate our node address in
	MOVE T1,RTRHOM		;  Ethernet string format
	DPB T1,[POINTR (T2,RN%ARE)]
	LSHC T1,^D28		;
	DPB T1,[POINT 8,T2,15]
	MOVEM T2,RTRLOO		; Low order in string format

	MOVE T1,RTRADR
	ADD T1,RTRNRV		;FIND THE ENTRY IN THE NORMAL REACH VECTOR
	D36OFF			;TURN ON INTERLOCK

	SETONE <RNLCL,RNRCH,RNCCH>,(T1) ;LOCAL AND REACHABLE and in cache
	SETZRO <RNCST,RNHOP>,(T1) ;ZERO THE HOPS AND COST FOR THIS NODE

	MOVE T2,[XCDSEC,,NSPRTR] ;GET NSP'S ENTRY VECTOR
	ADD T1,RTROFS		;POINT TO OUTPUT-CIRCUIT VECTOR ENTRY
	MOVEM T2,(T1)		;SAVE THE ENTRY VECTOR
	D36ON			;TURN OFF INTERLOCK

;And turn DECnet on!

	MOVX T1,DS.ON		;GET THE ON STATE
	MOVEM T1,DCNSTA		;SET IT
	SETZM RTRLMG		;Reset rounting message offset

;Now go through all the circuits, initializing each one.

	SKIPN RC,RTRCBQ		;PICK UP FIRST CIRCUIT BLOCK
	RETSKP			;NONE THERE, RETURN SUCCESS
RTRON1:	CALL R2KINI		;INITIALIZE THIS CIRCUIT
	 TRN
	LOAD RC,RCNXT,(RC)	;Step to next circuit, if any,
	JUMPN RC,RTRON1		; and initialize
	RETSKP			;NO MORE, JUST RETURN SUCCESS

	SUBTTL RTROFF - Turn Router (and DECnet) Off

;RTROFF - Turn Router (and DECnet) Off
;
; Call:
;	With nothing special
;
; Return:
;	RETSKP			;ALWAYS
;
; Uses: T1-T4

RTROFF:	SAVEAC <RC,AJ>

;Now go through all the circuits, halting each one.

	SKIPA RC,RTRCBQ		;GET THE FIRST CIRCUIT BLOCK
RTROF1:	LOAD RC,RCNXT,(RC)	;STEP THROUGH TO NEXT ONE
	JUMPE RC,RTROF2		;NONE THERE, RETURN SUCCESS
	CALL RTIDWN
	CALL R2KCLS
	JRST RTROF1		; 

RTROF2:	MOVX T1,DS.OFF		;SET THE STATE OF DECNET
	MOVEM T1,DCNSTA		; TO "OFF"
	RETSKP			;NO MORE, JUST RETURN SUCCESS
	SUBTTL RTRSEC - Once a second processing for Router

;RTRSEC - Once a second processing
;
; Call:
;	 With nothing
;
;Return:
;	RET			;ALWAYS
;
; Uses: T1
;
;This is the clock level routine for Router. Once a second this
;routine gets executed. If we are running TOPS-10 SMP, we must make
;sure that this is run on the BOOT CPU. The routine simply calls RTRRCR
;(to recompute the routing) if needed and calls RTRUPD to see if
;routing messages need to be sent out on any or all circuits. Next, we
;call the hello processor to check hello and listener timers for each
;circuit. Finally, it checks the resend queue, and if there are any
;messages on it, it forwards them.

	INTERN RTRSEC
	XRESCD

RTRSEC:	MOVE T1,DCNSTA		;Get DECnet state
	CAIE T1,DS.ON		;Is it on?
	 RET			;NO, NOTHING TO DO
IFN FTOPS10,<
	XCT .CPSK0		;SKIP IF BOOT CPU
	RET			;NO, SHOULDN'T BE HERE, BUT JUST RETURN
	SEC1			;RUN IN EXTENDED SECTIONS
>				;END IFN FTOPS10

	CALL DNDSEC		;Poll DNADLL each second

;	SKIPL RTRLOK		;CHECK TO SEE IF ANYONE HAS INTERLOCK
;	JRST [SETOM RTRSSV	;COULDN'T GET IT, JUST RETURN
;	      RET]		; WITH SERVICE NEEDED
;	SETZM RTRSSV		;WE HAVE PROVIDED SERVICE

;Note that we did not get the interlock here; we only tested it.
;The interlock is just to keep this clock level code from changing
;the database while any process level code is running.  We may
;get interrupted now by interrupt code, but this won't affect us
;as our critical sections are surronded by D36ON/D36OFF.

	SAVEAC <P1,P2,MS,RC,AJ,Q1,Q2,Q3> ;SAVE SOME NON-SMASHABLE ACS
	CALL RTRTMR		;CALL THE TIMER PROCESSOR, WHICH MAY TURN
				; ON RTRRCF
	SKIPE RTRRCF		;IS THE RECOMPUTE ROUTING FLAG ON?
	CALL RTRRCR		; YES, GO RECOMPUTE THE ROUTING
	CALL RTRUPD		;Now go through the update process
;	SETOM RTRLKO		;CLEAR OWNER OF INTERLOCK
IFN FTRTST,<
	SKIPE T1,TSTFLG
	 CALL RTRTST
	SETZM TSTFLG
>
	SKIPN ENFLG		;Endnode?
	 CALL SELDSR		;No, select a designated router
	SKIPGE ENFLG		;Endnode?
	 CALL CKECTO		;Yes, check the cache timer
	RET			; AND RETURN
	SUBTTL RTRJIF - Once a jiffy processing for Router

;RTRJIF - Once a jiffy processing
;
; Call: 
;	With nothing
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1
;
;This routine's only purpose is to service kontroller requests that
;CALKON queues when the request is for a device on the wrong CPU.  Since
;this is a TOPS-10 SMP only problem, it does nothing for TOPS-20.

	INTERN RTRJIF

	XRENT RTRJIF

IFN FTOPS20,<RET>		;Nothing to do for TOPS20

IFN FTOPS10,<
IFN FTMP,<
	SEC1			;RUN IN SECTION ONE
;	SKIPL RTRLOK		;TEST THE ROUTER INTERLOCK
;	RET			;SOMEONE HAS IT, WE'LL TRY AGAIN LATER

	SAVEAC <RC,AJ,MB>	;SAVE SOME ACS TO USE

	SKIPA RC,RTRCBQ		;START WITH THE FIRST CIRCUIT BLOCK
RTRJI1:	LOAD RC,RCNXT,(RC)	;GET PTR TO NEXT CIRCUIT BLOCK
	JUMPE RC,RTN		;NO MORE, JUST RETURN

	LOAD T1,LIKON,+RC.LID(RC) ;GET THE POINTER TO THE CIRCUIT BLOCK
	CAME T1,.CPCPN		;ARE WE RUNNING ON THE CPU FOR THIS CIRCUIT?
	JRST RTRJI1		;NO, CHECK OUT THE NEXT BLOCK

;Check the circuit's resend queue for any requests that we can queue
;for it now that we are running on the correct CPU.

RTRJI2:				;CHECK IF OTHER CPU HAD KONTROLLER TASKS
				; QUEUED UP.
	JE RCHLT,(RC),RTRJI3	;IF NO HALT REQUESTED, SKIP THIS CODE
	MOVEI T1,DF.HLT		;KONTROLLER FUNCTION HALT.
	MOVE T2,RC		;POINT TO CIRCUIT BLOCK
	CALL CALKON		;AND TRY TO DO IT.
	  JRST RTIDWN		;IF IT FAILS, DECLARE THE CIRCUIT DEAD.
RTRJI3:	JE RCINI,(RC),RTRJI4	;IF NO INITIALIZE REQUESTED, SKIP THIS CODE
	MOVEI T1,DF.OPN		;THE OTHER CPU DID REQUEST THIS.
	MOVE T2,RC		;SET UP POINTER TO CIRCUIT BLOCK
	CALL CALKON		;INITIALIZE THE LINE
	  JRST RTIDWN		;AND DECLARE THE CIRCUIT DOWN.
RTRJI4:	SETZRO <RCINI,RCHLT>,(RC) ;CLEAR BITS INDICATING KONTROLLER FUNCTIONS
	D36OFF			;TURN OFF INTERRUPTS WHILE PLAYING WITH QUEUES
	DEQUE MB,RC.JSQ(RC),MB.NXT,RTRJI6 ;DEQUEUE ANYTHING THAT'S THERE
	D36ON			;TURN INTERRUPTS BACK ON
				;WE KNOW THAT BY VIRTUE OF GETTING THE MESSAGE
				;BLOCK FROM RC.JSQ, RC IS SET UP CORRECTLY.
	CALL CALQOB		;SEND THE BLOCK OUT.
	JRST RTRJI2		;SEE IF ANYTHING ELSE ON CIRCUIT'S Q
RTRJI6:	D36ON			;TURN THE INTERRUPTS BACK ON
	JRST RTRJI1		; AND CHECK THE NEXT CIRCUIT'S QUEUE
>;End of IFN FTMP
	RET
>;End of IFN FTOPS10

	SUBTTL RTRLCK - Get the RTR interlock
REPEAT 0,<
;RTRLCK - Grab the RTR interlock
;
; Call:
; 	With nothing special
;
; Return:
;	RET			;ALWAYS WITH INTERLOCK
;
; Uses: Nothing
;
;Note: This interlock routine is only called by RTRXMT.  RTRXMT, which
;is NSP's entry point, will never be called by more than one CPU due to
;the NSP interlock. If the NSP interlock changes, we may have to modify
;this assumption.  The Router interlock is used to keep Router's clock
;level from modifying the database at clock level (Note that the
;database is only modified at clock level), while someone at process
;level is using it.  Route-through happens at interrupt level, so we
;don't have to worry.  Our only process level caller is NSP, who always
;has his "global interlock".

RTRLCK:	AOSE RTRLOK		;GRAB THE INTERLOCK
	RET			;SOMEONE HAS IT (PROBABLY INTERRUPT LEVEL)
				; WE DON'T CARE AS LONG AS CLOCK LEVEL
				; KNOWS THAT IT CAN'T RUN
	APRID RTRLKO		;SET THE OWNER OF THE INTERLOCK
	ADJSP P,-1		;WE'LL CALL THE CALLER
	PUSHJ P,@1(P)		; SO WE DON'T NEED HIM ON STACK
	 TRNA			;NON-SKIP RETURN
	AOS -1(P)		;SKIP RETURN

	SETOM RTRLKO		;CLEAR THE OWNER OF THE INTERLOCK
	SETOM RTRLOK		;GIVE UP THE LOCK
	SKIPE RTRSSV		;DID WE GET A REQUEST FOR SERVICE?
	CALLRET RTRSEC		;YES, GIVE IT
	RET			;OTHERWISE, JUST RETURN
>

IFN FTRTST,<
RTRTST:	SAVEAC P1
	MOVEI P1,TSTBLK		; Test data block
	STOR T1,TRTND,(P1)	; Node to loop with
	MOVX T1,^D300		; Length of data segment
	CALL DNGMSG		; Get that many bytes
	 RET			; Resource failure, tough luck
	MOVE MB,T1		; Set up MB with message block pointer
	XMOVEI T1,UD.MSD(MB)	; Initialize the user data segment
	CALL DNPINI
	LOAD T1,TRTSN		; Get serial number
	CALL DNP2BY		; Place serial number in message
	MOVX T3,^D298		; Get the count for loop
RTRTS2:	MOVX T1,HEL.LO		; Word that goes in hello messsage
	CALL DNP1BY		; Put one in
	SOJG T3,RTRTS2		;  and continue till we have enough
	MOVE T1,RTRADR
	DPB T1,[POINTR (T2,RN%NOD)]
	MOVE T1,RTRHOM
	DPB T1,[POINTR (T2,RN%ARE)]
	STOR T2,MBSRC,(MB)
	SETZ T1,
	MOVX T2,LD.NI		; Get the device type for the NI
	STOR T2,LIDEV,+T1	; Save it
	CALL RTRGCB		; Get the circuit block in RC
	 CALLRET FREMSG
	LOAD T1,TRTND,(P1)	; Get number of node to test with
	STOR T1,MBDST,(MB)	;	
	CALL RTRGAJ		; Get the correct adjacency in AJ
	 CALLRET FREMSG
	STOR AJ,RMOAP,(MB)	; Save for RTRFWD
	CALL TSTTIM
	STOR T1,TRTAF,(P1)	; Save as time at RTRFWD
	SETONE RMTST,(MB)	; Indicate this is a test message
	SETZ T1,		; No flags
	CALLRET RTRXMT		; Try to send it
>

	SUBTTL RTRXMT - NSP's entry into Router

;RTRXMT - Routine to forward messages from NSP
;
; Call:
;	MB/ Ptr to Message Block
;	T1/ RQR flag (RT%RQR)
;	    ODN flag (RT%ODN)
;	    TRY flag (RT%TRY)
; Public portion of message block must be filled with destination
; and source nodes and output circuit.
;
; Returns:
;	RTN			;ALWAYS
;
;This is the only way which an NSP calls router (except for
;initialization).  The ODN flag in T1 specifies whether or not NSP
;really wants message back (see FREMSG).  The RQR flag specifies
;whether or not NSP is requesting this message be returned.

	INTERN RTRXMT
	XRESCD

RTRXMT:	MOVE T2,DCNSTA		;Get DECnet state
	CAIE T2,DS.ON		;Is it on?
	 CALLRET FREMSG		;NO, PUNT THE MESSAGE CORRECTLY AND LEAVE

	SAVEAC <MB,MS,RC,AJ>	;SAVE A FEW FOR NSP
;	CALL RTRLCK		;GET INTERLOCK

	MOVX T2,RMRQR		;GET RETURN REQUEST BIT FOR MESSAGE BLK
	ANDCAM T2,RM.RQR(MB)	;CLEAR FLAG, ASSUMING NOT INTERESTED
	TXNE T1,RT%RQR		;DOES HE WANT IT BACK?
	IORM T2,RM.RQR(MB)	;YES, SET BIT IN THE MESSAGE BLK

	MOVX T2,RMODN		;GET "NSP WANTS MSG BACK" BIT
	ANDCAM T2,RM.ODN(MB)	;CLEAR FLAG, ASSUMING CALLER NOT INTERESTED
	TXNE T1,RT%ODN		;DOES HE WANT OUTPUT DONE CALL?
	IORM T2,RM.ODN(MB)	;YES, SET FLAG FOR FREMSG AND R2NODN

	MOVX T2,RMTRY		;Get "TRYHARD" on NI bit
	ANDCAM T2,RM.TRY(MB)	;Assume not requesting us to try hard
	TXNE T1,RT%TRY		;Asked to "try hard"?
	IORM T2,RM.TRY(MB)	;Yes, set flag to clear destination from cache

	SETZRO RMICP,(MB)	;THERE'S NO INPUT CIRCUIT BLOCK POINTER
	SETZRO RMIAP,(MB)	; and no input adjacency
	SETZRO RMOAP,(MB)	;THERES NO OUTPUT ADJACENCY YET EITHER
	SETZRO MBVST,(MB)	;ZERO VISITS COUNT
	SETONE RMMB1,(MB)	;BIT THAT MUST BE ONE IN FIRST BYTE

	LOAD T1,MBSRC,(MB)	;GET SOURCE NODE ADDRESS
	LDB T2,[POINTR (T1,RN%ARE)] ;GET THE AREA NUMBER
	LDB T1,[POINTR(T1,RN%NOD)] ;GET THE NODE NUMBER
	
	CAME T2,RTRHOM		;IN OUR AREA
	 JRST CKLOOP		;NOPE ,THEN FORGET ABOUT IT
	ADD T1,RTRNRV		;ADD OFFSET TO NORMAL ROUTING VECTOR
	TMNN RNLCL,(T1)		;IS THIS THE LOCAL NODE?
	BUG.(CHK,ROUBSN,ROUTER,SOFT,<Bad source node in message from NSP>,,<

Cause:	We have received a message from NSP to send.  However, the source node
	address is not that of the local Router.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.  Check in LLINKS or SCLINK to 
	see how an invalid source node address occurred.
>,FREMSG)

CKLOOP:	LOAD T1,MBCHN,(MB)	;GET CHANNEL NUMBER (circuit id)
	JUMPE T1,RTRFWD		;IF NO LOOP BACK CIRCUIT SPECIFIED BY
				;SESSION CONTROL, DON'T SET CIRCUIT PTR
	CALL RTRGCB		;YES, TRANSLATE INTO A CIRCUIT BLK PTR
	 BUG.(CHK,ROUILS,ROUTER,SOFT,<Illegal Circuit Specified in NSP msg>,,<

Cause:	There was a request to send a message on a particular circuit, however  
	the circuit has never been intialized by the routing layer.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.
>,FREMSG)
	STOR RC,RMOCP,(MB)	;Store it as output circuit
	LOAD AJ,RCAJQ,(RC)	;Get an adjacency pointer

;Note that this grabs the the first adjacency which is the only one for point
; to point, but not necessarily for broadcast

	STOR AJ,RMOAP,(MB)	;Save it for forward routine (this is enough
	JE RCBCT,(RC),RTRFWD	; unless circuit is broadcast)
CKLOO1:	LOAD T1,AJNTY,(AJ)	;Get adjacency type
	CAIN T1,ADJ.LN		; If a routing node
	IFSKP.
	  STOR AJ,RMOAP,(MB)	; Save it for forward routine
	  JRST RTRFWD		;  and then forward the message
	ENDIF.
	LOAD AJ,AJNXT,(AJ)	;  Else get next adjacency
	JUMPE AJ,FREMSG		;   none found then cannot forward the message
	JRST CKLOO1		;   check the one we got

	SUBTTL RTRFWD - Perform Routing of Message

;RTRFWD - Routine to do routing
;
; Call:
;	MB/ Ptr to Message Block
;
; Return:
;	RTN			;ALWAYS
;
; Uses T1-T3
;
;This routine takes an input message, checks its Router header and
;routes it to the correct destination using the "normal" routing
;vector.  The relavent fields in the public section of the Message
;Block must have been set up.

RTRFWD:	XMOVEI T1,RM.MSD(MB)	; Router's private MSD
	CALL DNPINI		; Initialize it, as this is where we will
				;  build the routing layer header
	LOAD T1,MBDST,(MB)	; Get the destination address
	LDB T2,[POINTR(T1,RN%ARE)] ; Extract the area number
	LDB T1,[POINTR(T1,RN%NOD)] ;  and the node number from it
	CAME T2,RTRHOM		; Is it in our area?
	 SETZ T1,		;  No, select the area router
	SKIPL T1		;LESS THAN 0
	 CAMLE T1,RTRMXN	;GREATER THAN THE MAX NODE ADDRESS?
	  JRST RTRFOR		;DEST IS OUT OF RANGE
	ADD T1,RTRNRV		; Add in the offset to routing vector
	OPSTR <SKIPE>,RMOAP,(MB) ; Have we selected an output adjacency?
	IFSKP.
	  TMNN RNLCL,(T1)	; No, is destination local?
	  IFSKP.
	    SETONE MBLCL,(MB)	; Yes, indicate that in message block
	    JRST RTRFD2		;  and skip ahead
	  ENDIF.
	ENDIF.
	SKIPN ENFLG		; Endnode?
	IFSKP.			; Yes
	  MOVE RC,RTRCBQ	; Get pointer to our only circuit
	  JUMPE RC,RTRFUR	; If no circuit can't do much
	  LOAD T2,RCSTA,(RC)	; If circuit is not running
	  CAIE T2,RCS.RN	;  cannot forward message
	   JRST RTRFUR
	  STOR RC,RMOCP,(MB)	; Save circuit block address
	  SETONE <RMMZ2,RMMZ3>,(MB) ; Set intra-ethernet and long format hdr
	  CALL RTRBEH		; Build the ethernet header
	  JRST RTR2RM		;  and try to send message
	ELSE.
	  TMNE RNRCH,(T1)	; Is destination reachable?
	  IFSKP.
	    SETONE MBUNR,(MB)	; No, indicate that,
	    SETZRO RMOAP,(MB)	;  clear output adjacency,
	    JRST RTRPHR		;  and skip further checking
	  ENDIF.
	ENDIF.
	OPSTR <SKIPE T2,>,RMOAP,(MB) ;Compute an adjacency if we don't have one
	IFSKP.
	  ADD T1,RTROFS		; Index into the output adjacency vector
	  MOVE T2,(T1)		; Get the output adjacency
	  STOR T2,RMOAP,(MB)	;  and use it as the adjacency to forward to
	ENDIF.
	LOAD T2,AJSTA,(T2)	; Get state of adjacency
	CAIE T2,ADJ.UP		; Is it up?
	 JRST FREMSG		; No, toss the message

;Now check for over aged packet

RTRFD2:	JE RMIAP,(MB),RTRFD3	; If from our NSP then visit count is zero
	LOAD T1,RMFST,(MB)	;GET THE FIRST BYTE OF MESSAGE
	OPSTRM <AOS T2,>,MBVST,(MB) ; AND UPDATE AND GET VISITS FIELD
	MOVE T3,RTRMXV		;THIS IS THE MAXIMUM VISITS COUNT ALLOWED
	TXNE T1,RM%RTS		;IS THIS GOING TO BE COMING BACK?
	 ASH T3,2		;YES, GIVE IT TWICE AS MANY HOPS
	CAMG T2,T3		;HAS IT AGED TOO MUCH?
	 JRST RTRFD3		;NO, PUT HEADER ON MSG

;Here to report a aged packet loss event.

	SETZ T2,		;THIS EVENT HAS NO ENTITY ASSOCIATED WITH IT
	SETZ T3,		;Default address to nothing
	SKIPE AJ
	 LOAD T3,AJNAN,(AJ)	;Get address of last router in path
	EVENT RE.APL,<Aged packet loss event>,MB
	AOS RTRCAP		;INCREMENT THE AGED PACKET COUNTER
	CALLRET FREMSG		;FREE THE MESSAGE AND RETURN

;Now decide if destination is point-point or broadcast and build the
;appropriate routing message header.

RTRFD3:	TMNE MBLCL,(MB)		;IS THE DESTINATION OUR LOCAL NSP?
	 JRST RTRPHR		;YES, THEN WE CAN SKIP THE REST OF THIS
IFN FTRTST,<
	LOAD T1,MBSRC,(MB)	;Get source address
	TMNE RMTST,(MB)		;Is this a test message
	 JRST [STOR T1,MBDST,(MB) ;Then we want it back
	       SETZRO MBVST,(MB) ;Reset the visits
	       JRST .+1]
>
	LOAD AJ,RMOAP,(MB)	; OUTPUT ADJACENCY
	LOAD RC,AJCBP,(AJ)	; OUTPUT CIRCUIT BLOCK
	JN RCBCT,(RC),RTRFNI	; Jump if broadcast circuit?

;Build a short data packet header for packets going out on point-to-point

	SETZRO <RMMZ2,RMMZ3>,(MB) ;Short format header - Not intra-NI
	LOAD T1,RMFST,(MB)	;GET THE FIRST BYTE OF MESSAGE
	CALL DNP1BY		;PUT IT IN MESSAGE HEADER AREA
	LOAD T1,MBDST,(MB)	;GET THE DESTINATION NODE ADDRESS
	LDB T2,[POINTR(T1,RN%ARE)] ;GET THE AREA
	LDB T1,[POINTR(T1,RN%NOD)] ;GET THE NODE NUMBER
	SKIPN T2		;HAVE ONE?
	 MOVE T2,RTRHOM		;GET OURS THEN
	TMNE AJPH4,(AJ)		;Is "next hop" Phase IV?
	 DPB T2,[POINTR(T1,RN%ARE)] ; Yes, then we need an area
	CALL DNP2BY		;PUT DESTINATION NODE ADDRESS INTO MESSAGE
	LOAD T1,MBSRC,(MB)	;GET THE SOURCE NODE ADDRESS
	LDB T2,[POINTR(T1,RN%ARE)] ;GET THE AREA
	LDB T1,[POINTR(T1,RN%NOD)] ;GET THE NODE NUMBER
	SKIPN T2		;Have an area?
	 MOVE T2,RTRHOM		;NO, USE OURS THEN
	TMNE AJPH4,(AJ)		;Is the next hop Phase IV?
	IFSKP.	
	  CAME T2,RTRHOM	;No, is this from a foreign area?
	   CALLRET RTRFUR	;Yes, treat as unreachable because we cannot
				; forward a P4 packet to an adjacent P3 node
	ELSE.
	  DPB T2,[POINTR(T1,RN%ARE)] ;Yes, P4 nodes get an area number
	ENDIF.
	CALL DNP2BY		;PUT SOURCE NODE ADDRESS INTO MESSAGE
	LOAD T1,MBVST,(MB)	;GET VISITS BYTE
	CALL DNP1BY		;AND PUT THAT IN, TOO
	JRST RTRPHR		;DO THE COMMON HEADER STUFF

;Here when the output circuit is an Ethernet

RTRFNI:	SETONE RMMZ3,(MB)	;****INDICATES LONG FORMAT TRANSPORT HEADER**
	LOAD T2,RMIAP,(MB)	;GET THE INPUT ADJACENCY POINTER
	JUMPE T2,RTRFN1		;MESSAGE IS FROM LOCAL NSP

	LOAD T3,AJNTY,(T2)	;GET THE NODE TYPE
	LOAD T4,AJNTY,(AJ)	;GET THE NODE TYPE FOR THE OUTPUT ADJACENCY
	CAIN T3,ADJ.LN		;IT IS AN ENDNODE?
	CAME T3,T4		;YES, ARE THEY BOTH?
	 JRST RTRFN2		;NO, THEN SKIP THIS

;They are both endnodes, see if the input/output circuits are the same NI

	LOAD T2,AJCBP,(T2)	;GET THE INPUT CIRCUIT BLOCK POINTER
	LOAD T2,RCLID,(T2)	;GET THE LINE ID
	LOAD T4,LIDEV,+T2	;GET THE DEVICE TYPE
	CAXE T4,LD.NI		;IS IT AN NI?
	 JRST RTRFN2		;NO, THEN NO INTRA-NI
;	LOAD T2,LIUNI,+T2	;UNIT NUMBER
	LOAD T3,RCLID,(RC)	;AND THE ONE FOR OUTPUT
;	LOAD T3,LIUNI,+T3	;GET THE UNIT NUMBER
	CAME T2,T3		;ARE THEY THE SAME NI?
	 TRNA			;NOT NI OR NOT SAME ONE
RTRFN1:	SETONE RMMZ2,(MB)	;YES, THEN SET THE INTRA-NI BIT

RTRFN2:	CALL RTRBEH		;Now build the Ethernet header



RTRPHR:	CALL DNRPOS		;GET CURRENT POSITION IN THE BLOCK
	STOR T1,RMMK1,(MB)	;AND SET MARK IN BLOCK
	
	TMNE MBLCL,(MB)		;FOR THE LOCAL NSP?
	 JRST RTRFLC		;AND FORWARD TO LOCAL NSP
	TMNE MBUNR,(MB)		;UNREACHABLE?
	 JRST RTRFUR		;YES, LOG IT THEN
	JN RMOAP,(MB),RTR2RM	;If output adjacency was spec'd, forward it

	LOAD T1,MBDST,(MB)	;HAVE A DESTINATION
	LDB T1,[POINTR(T1,RN%NOD)] ;GET THE NODE NUMBER
	 BUG. (CHK,ROUIFS,ROUTER,SOFT,<Router got through the forward routine without picking a route>,,<

Cause:	RTRFWD got through its Forward process and either did
	not pick up a route or failed to flag a message which was for the
	local node or an unreachable message.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.  Analyze the dump and look for 
	corruption in the routing vector.
>,FREMSG)

;Here when destination node is out-of-range.

RTRFOR:	TMNE RMRQR,(MB)		;WAS RETURN REQUESTED
	JRST RTRFRT		;YES, RETURN IT

	LOAD T2,RMICP,(MB)	;GET THE CIRCUIT IT CAME IN ON
	SKIPN T2
	 BUG.(CHK,ROUNSO,ROUTER,SOFT,<NSP sent out of range packet>,,<

Cause:	There is a request to forward a packet to a node whose address is
	outside the range of our routing vector.  Either our NSP has given
	a packet the monitor cannot forward or the monitor has received one 
	from the wire.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
        at the time the BUG was observed.

       	If the source is local check to see how NSP could give a packet
	whose destination node address is greater than RTRMXN.  If the
	source is remote then there is something wrong with its routing
	database or algorithm.
>,FREMSG)

	LOAD T2,RCLID,(T2)	;Get device ID
	SETZ T3,		;Default address to nothing
	SKIPE AJ
	 LOAD T3,AJNAN,(AJ)	;Get address of last router in path
	EVENT RE.NOR,<Node out-of-range packet loss>,MB
	AOS RTRCNO		;INCREMENT OUT-OF-RANGE COUNT
	CALLRET FREMSG		;RETURN THE MSG BLK
;Here when destination node is unreachable.

RTRFUR:	TMNE RMRQR,(MB)		;WAS RETURN REQUESTED?
	JRST RTRFRT		;WE HAVE TO RETURN MESSAGE

	OPSTR <SKIPN T2,>,RMICP,(MB) ;GET THE CIRCUIT IT CAME IN ON
	IFSKP.
	  LOAD T2,RCLID,(T2)	; and get the circuit ID
	  SETZ T3,		;Default address to nothing
	  SKIPE AJ
	   LOAD T3,AJNAN,(AJ)	;Get address of last router in path
	  EVENT RE.NUR,<Node unreachable packet loss>,MB
	  AOS RTRCNU		;INCREMENT EXECUTOR NODE COUNTER
	ENDIF.
	CALLRET FREMSG		;GIVE THE MESSAGE BACK AND RETURN

;Here to return message to sender due to unreachability.

RTRFRT:	ETRACE RTR,<Returning message due to unreachability>
	CALL RTRERH		;EAT THE ROUTER HEADER WE PUT ON THE MESSAGE
	SETZRO RMRQR,(MB)	;ZERO THE RQR FLAG
	SETONE RMRTS,(MB)	;SET THE RETURN TO SENDER FLAG
	LOAD T1,MBDST,(MB)	;GET THE DST ADDR
	LOAD T2,MBSRC,(MB)	; AND THE SRC ADDR
	STOR T2,MBDST,(MB)	;SWITCH THEM
	STOR T1,MBSRC,(MB)	; AROUND
	TMNN RMICP,(MB)		;THIS MSG COME FROM LOCAL NSP?
	JRST [CALL CPYMSG	;YES, MAKE THIS MSG LOOK LIKE AN INPUT
				; BY COPYING SEGMENTS TOGETHER
	       CALLRET FREMSG	;OOPS, COULDN'T GET MSG BLOCK, FORGET IT
	      EXCH T1,MB	;POINT TO THE NEW MSG IN MB
	      CALL DNFMSG	;FREE THE OLD MSG
	      CALLRET R2NRTN]	; AND RETURN THE NEW MSG
	CALLRET RTRFWD		;TRY TO FORWARD AGAIN
;Here when the message is for a local NSP.

RTRFLC:	LOAD RC,RMICP,(MB)	;SEE WHERE MSG CAME FROM
	JUMPE RC,RTRF2C		;IF ICP IS ZERO, MSG IS FROM NSP,
				; SO WE HAVE TO COPY DATA
				;IF ICP IS NON-ZERO, MSG IS FROM
				; OUTSIDE & JUST FALL THROUGH

;We are here when we have to pass an incoming message to NSP.

	INCR RCCAP,(RC)		;INCR ARRIVING PACKETS RECEIVED (TO NSP)
RTRF2N:	TMNE RMRTS,(MB)		;IS THIS A RETURNED MESSAGE?
	CALLRET R2NRFR		;Yes, then give it to NSP
	CALLRET R2NRCV		;NO, THIS IS GOOD OLDE RECEIVED DATA

RTRF2C:
;***************************************
	TORESCD
RTRLTR::TRN			;Label for DNSNUP to find local messages
	TOXRESCD
;***************************************

	CALL RTRERH		;EAT THE ROUTING HEADER
	CALL CPYMSG		;COPY THE MSD'S TOGETHER
	 CALLRET FREMSG		;DON'T CARE IF IT FAILS, THEN FREE IT UP
	PUSH P,T1		;SAVE THE POINTER TO NEW THE MESSAGE
	CALL FREMSG		;RETURN THE ORIGINAL TO NSP
	POP P,MB		;AND WE CAN DIDDLE WITH OUR NEW COPY
	JRST RTRF2N		;NOW PASS THE MESSAGE ON TO NSP

; Get some bytes that we put in the router MSD above.  This was to fix problems
; with Event processing, But the local NSP and the Return to sender code does
; not expect these fields to be set up.  So we will punt them here.


RTRERH:	LOAD T1,MBFMS,(MB)	;GET THE POINTER TO THE FIRST MSD
	XMOVEI T2,RM.MSD(MB)	;GET THE ADDRESS OF THE ROUTER MSD
	CAME T1,T2		;SEE IF IT AGREES WITH THE FIRST ONE THERE
	 RET			;JUST RETURN MUST BE LLINKS RETURN MESSAGE
	LOAD T1,MDNXT,+RM.MSD(MB) ;GET THE NEXT MSD POINTER
	STOR T1,MBFMS,(MB)	;SAVE AS THE FIRST ONE
	RET			;AND RETURN
	SUBTTL RTR2RM - Send Message to Remote Node

;RTR2RM - Queue Out Message to Remote through the DLL
;
; Call:
;	MB/ Pointer to message block
;	RC/ Pointer to circuit block
;	AJ/ Pointer to adjacency block if we are a level 1 router
;
; Return:
;	RET			;ALWAYS
;
; Uses: P1-P2, T1-T3

RTR2RM:	LOAD T1,RCSTA,(RC)	;GET THE CIRCUIT'S STATE
	CAIE T1,RCS.RN		;IS IT RUNNING
	CAIN T1,RCS.TT		; OR IN TEST?
	TRNA			;YES, WE CAN FORWARD THE PACKET
	CALLRET FREMSG		;NO, DESTROY THE PACKET
	SKIPN ENFLG
	IFSKP.
	  INCR RCCDP,(RC)	; Count data packets
	  JRST RTR2R1		;  and continue
	ENDIF.
	JE RMICP,(MB),[INCR RCCDP,(RC)	;IS THE PACKET FROM OUR LOCAL NSP?
		       JRST RTR2R1]	;YES, INCREMENT COUNT OF NSP PACKETS
					; AND SEND MSG WITHOUT WORRYING ABOUT
					; SQUARE-ROOT LIMIT

	LOAD T1,RMICP,(MB)	;GET THE INPUT CIRCUIT BLOCK
	LOAD T1,LIDEV,+RC.LID(T1) ;GET THE LINE ID
	LOAD T2,RMIAP,(MB)	;GET THE SOURCE ADJACENCY
	LOAD T2,AJNTY,(T2)	;GET THE SOURCE NODE TYPE
	CAXN T2,ADJ.LN		;IS IT AN END NODE?
	 CAXE T1,LD.NI		;IS THIS THE NI DEVICE
	 JRST RTRCSQ		;HAVE BOTH GOT TO BE ON THE NI

;Get here when we have a source which is an NI endnode.  The SPEC says
;if we get an NI endnode as the source and the destination is not one,
;then we have to check to be sure the hiorder bytes of S-ID are set to
;HIORD.  If they are not, we discard the packet.  We must do this here
;as opposed to when we receive the packet, as we do not know the
;output adjacency when we have just received it.


	LOAD T1,LIDEV,+RC.LID(RC) ;GET THE DEVICE TYPE
	LOAD T2,AJNTY,(AJ)	;GET THE NODE TYPE
	CAXN T1,LD.NI		;IS THIS ON AN NI TOO?
	 CAXE T2,ADJ.LN		; AND IS THE DESTINATION AN END NODE?
	TRNA			;NOT ON AN NI OR NOT AN END NODE
	 JRST RTRCSQ		;THEN SKIP THIS
	LOAD T1,MBSR1,(MB)	;GET THE FIRST 4 BYTES OF SOURCE ADDRESS
	CAME T1,RTRHIO		;IS THIS THE HIORDER?
	 JSP T1,RTEMFE		;++MESSAGE FORMAT ERROR EVENT
	LOAD T1,MBDS1,(MB)	; Now check the first 4 bytes of the
	CAME T1,RTRHIO		;  destination address
	 JSP T1,RTEMFE


;We now check the "square-root" limit criterion, to see if the message
;should be discarded.  We check this by comparing the number of message
;blocks queued out on this circuit with the number of message blocks that
;the memory manager has guaranteed router divided by the square-root
;of the number of circuits (We simplify things by just using the number
;of circuits divided by two, which is close enough for a small number of
;circuits).

RTRCSQ:	INCR RCCTR,(RC)		;NO, INCREMENT THE TRANSIT PACKETS RECEIVED
	CALL DNNMSG		;GET NUMBER OF MESSAGE BLOCKS AVAILABLE
	MOVE T2,RTRNLN		;FIND THE NUMBER OF CIRCUITS IN USE
	ASH T2,-1		;DIVIDE BY TWO
	IDIV T1,T2		;DIVIDE TO FIND THE QUEUE THRESHOLD
	OPSTR <CAMLE T1,>,RCCMQ,(RC) ;COMPARE WITH NUMBER OF MSG BLKS QUEUED
	JRST RTR2R1		;WE DON'T HAVE TO FLUSH IT

;Here to discard a message that has exceeded the "square-root" limit.

	TRACE RTR,<Congestion Loss on output>
	INCR RCCTL,(RC)		;INCREMENT THE CONGESTION LOSS COUNTER
	CALLRET FREMSG		;FREE THE MESSAGE AND RETURN

;All packets to be sent come through here.

RTR2R1:
;Now we have to diddle with the MSD pointers slightly to convince
;the DLL not to get the router header from the input MSD.

	XMOVEI T1,RM.MSD(MB)	;POINT TO THE ROUTER MSD
	STOR T1,MBFMS,(MB)	;STORE IN FIRST MSD SLOT

	MOVE T1,MB
	CALL DNLENG		; Get length of message
	OPSTR <SUB T1,>,MDBYT,+RM.MSD(MB) ; Don't count Router's header
	SKIPN ENFLG		; Endnode?
	IFSKP.
	  LOAD T2,RCRBS,(RC)	; Check against our receive block size
	ELSE.
	  LOAD T2,AJBSZ,(AJ) 	;  else check against adjacencies
	ENDIF.
	CAMG T1,T2		; Too many bytes for
	IFSKP.			;   destination's buffer?
	  INCR RCBSX,(RC)	; Yes, count the times this happens
	  CALLRET FREMSG	;  and toss the message
	ENDIF.

	JE RMICP,(MB),RTR2R4	;DID IT COME FROM A REMOTE NODE?
	INCR RCCTS,(RC)		;IT DID, INCREMENT TRANSIT COUNT
	LOAD T1,MDPTR,+IN.MSD(MB) ;ALSO GET THE DYNAMIC BYTE POINTER
	STOR T1,MDAUX,+IN.MSD(MB) ; AND STORE IT IN THE ORIGNAL BYTE POINTER
				  ; SO THE DLL DOESN'T USE THE OLD ROUTER
				  ; HEADER, WHICH WE JUST STRIPED AWAY
;Now set up the arguments for the data link and give it the packet

RTR2R4:	INCR RCCMQ,(RC)		;INCREMENT NUMBER OF MESSAGES QUEUED
	MOVX T1,DF.XMT		;Function is transmit
	SKIPN ENFLG		; Endnode?
	IFSKP.
;Clear cache if try-hard
	  LOAD T2,MBDST,(MB)	; Yes, get the destination address
	  MOVE T3,T2		; In case we need it later
	  TXZ T2,RN%ARE		; Clear the area number field
	  ADD T2,RTRNRV		; Add reach vector offset
	  TMNN RMTRY,(MB)	; "Try hard" flag set?
	  IFSKP.
	    SETZRO RNCCH,(T2)	; Yes, clear the in-cache flag
	  ENDIF.
;Now we must determine the next hop address.  The following rules apply:
;	 If destination is in cache then nexthop = destination
;	  else
;	 If designated router .ne. 0 then nexthop = desiginated router
;	  else
;	 nexthop = destination

	  LOAD T4,RCDSL,(RC)	; No, get address of designated router
	  TMNN RNCCH,(T2)	; Is cache flag set?
	   JUMPN T4,RTR2R5	; Not in cache, use DSR if we have one
	  CAME T3,RTRNAD	; Is this destined for us?
	  IFSKP.		; Yes, must be loop node from NML
	    SKIPE T4		; Do we have a DSR?
	     JRST RTR2R5	; Yes, send it there
	  ENDIF.		; No, send it to ourselves (this will fail)
	  SETZ T4,		; Start clean
	  LSHC T3,-^D8		; Convert from 0,,N1,N2 to N2,N1,,0
	  LSH T3,2
	  LSH T4,-^D18		; Shift back to last character in string
	  IOR T4,T3		; Put it in T4 with the next to last char.
	ELSE.
	  LOAD T4,AJNAL,(AJ)	; Address of next hop (Ethernet only)
	ENDIF.
RTR2R5:	HRLZ T4,T4		; Position address correctly
	MOVE T2,RC		; Send on this circuit
	MOVE T3,MB		;  this message
	CALL CALKON		; Call the data link layer (DNADLL)
	 CALLRET XMTFAI		; The transmit failed - Restart data link
	RET			;GIVE A GOOD RETURN TO CALLER

	SUBTTL RTRBEH - Build header for ethernet data messages

RTRBEH:	LOAD T1,RMFST,(MB)	;GET THE FIRST BYTE
	CALL DNP1BY		;PUT IT INTO THE MESSAGE
	SETZ T1,		;CLEAR OUT SOME RESERVED FIELDS
	CALL DNP2BY		;D-AREA, D-SUBAREA
	MOVE T1,RTRHIO		;Get HIORD
	CALL DNPHIO		;Place in message
	LOAD T1,MBDST,(MB)	; and the 16 bit node address NSP gave us
	CALL DNP2BY
	SETZ T1,		;ZERO SOME MORE FIELDS
	CALL DNP2BY		;S-AREA, S-SUBAREA
	MOVE T1,RTRHIO		;Get HIORD
	CALL DNPHIO
	LOAD T1,MBSRC,(MB)	; and the 16 bit source address
	CALL DNP2BY
	SETZ T1,		;SOME MORE RESERVEDS
	CALL DNP1BY		;NEXT LEVEL 2 ROUTER
	LOAD T1,MBVST,(MB)	;Get visits count
	CALL DNP1BY
	SETZ T1,		;NEXT 2 FIELDS ARE RESERVED, JUST WRITE ZERO'S
;	LOAD T1,MBSCL,(MB)	;GET THE SERVICE CLASS
	CALL DNP1BY		;INTO THE MESSAGE
;	LOAD T1,MBPRO,(MB)	;GET THE PROTOCAL TYPE
	CALL DNP1BY		;INTO THE MESSAGE
	RET

 	SUBTTL R2NODN - Return Output Done to NSP

;R2NODN - Give Output Done to NSP
;
; Call: 
;	MB/ Pointer to Message Block
;The relevant fields must be set up in the public portion of the message
;block (i.e., source and destination node addresses, etc.)
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1-T4

R2NODN:	MOVX T3,NV.ODN		;GET THE OUTPUT DONE ENTRY TYPE
	MOVE T4,MB		;SET UP MB FOR NSP
	LOAD T1,MBSRC,(MB)	;IT'S GOING BACK TO SOURCE
	LDB T1,[POINTR(T1,RN%NOD)] ;GET THE NODE NUMBER
	CALLRET R2NCL1		;CALL NSP
	SUBTTL R2NRTN - Return Message to NSP

;R2NRTN - Return Message to NSP
;
; Call: 
;	MB/ Pointer to Message Block
;Fields must be set up correctly in the Public portion of the message
;block.
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1-T4

R2NRTN:	SKIPA T3,[NV.RTS]	;Returned by local router to local NSP
R2NRFR:	MOVX T3,NV.RFR		;Returned by remote router to local NSP
	CALLRET R2NCAL		;MERGE WITH THE OTHER CODE

	SUBTTL R2NRCV - Pass received Message to NSP

;R2NRCV - Pass received message to router user (ususally NSP)
;
; Call: 
;	MB/ Pointer to Message Block
;Fields must be set up correctly in the public portion of the message
;block.
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1-T4
;
;R2NCAL, which is the actual routine which calls a router user (also called
;an NSP), will check the message block for the destination address and use
;this to find look up the correct entry vector in the normal routing vector.
;RTRNOV contains the entry vector for NSP when the node entry for RTRNRV
;says it is a local node (RNLCL is on).

R2NRCV:	MOVX T3,NV.RCV		;GIVE RECEIVED MESSAGE ENTRY TYPE
R2NCAL:	SKIPN T4,MB		;HE WANTS THE MESSAGE BLOCK PTR IN T4
	 BUG.(CHK,ROUXNZ,ROUTER,SOFT,<R2NCAL called with MB=0>,,<

Cause:	Somehow MB was trashed in the forward process.  It is unlikely
	to get this far if RTRFWD rececived a bad MB.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.  Look for faulty code in the 
	forward process.
>,RTN)
	LOAD T1,MBDST,(MB)	;GET THE DESTINATION OF THIS MESSAGE
	LDB T2,[POINTR(T1,RN%ARE)] ;GET THE AREA IN T2
	LDB T1,[POINTR(T1,RN%NOD)] ;GET THE NODE NUMBER

	SKIPE T2		;Do we have an area?
	 CAMN T2,RTRHOM		;Yes, is it ours?
	SKIPA			;Ours or don't have one
	 JRST R2NCLE		;Not ours, THEN LET SOMEONE ELSE WORRY ABOUT IT
R2NCL1:	ADD T1,RTRNRV		;GET NODE'S ENTRY IN "NORMAL" VECTOR
	JN RNLCL,(T1),R2NCL2	;IF IT IS A LOCAL NODE, RETURN MESSAGE
	TMNE RMODN,(MB)		;NOT LOCAL, CHECK FLAGS FOR CONSISTENCY
	BUG.(CHK,ROUNLN,ROUTER,SOFT,<Trying to return msg to non-local NSP>,,<

Cause:	We have decided to return a message to the local NSP but the local
	NSP was not the originator.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.
>,R2NCLE)
R2NCLE:	SETZRO RMODN,(MB)	;MAKE FREMSG TOSS THE MSG NOW
	CALLRET FREMSG		;RETURN MSG BLK TO FREE POOL

R2NCL2:	ADD T1,RTROFS		;GET THE VECTORED ENTRY POINT POINTER
	MOVE T1,(T1)		;GET THE CORRECT ENTRY
	CALLRET (T1)		;CALL WHATEVER IS ABOVE US

	SUBTTL R2KINI - Initialize a Kontroller's Circuit

;R2KINI - Initialize a DLL circuit
;
; Call: 
;	RC/ Pointer to Circuit Block
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1-T2

R2KINI:	LOAD T1,RCSTA,(RC)	;GET THE CIRCUIT STATE
	CAIE T1,RCS.OF		;We must be in OFF or
	 CAIN T1,RCS.RJ		; rejected state
	  TRNA
	RET			;NO, THEN SKIP THIS
	MOVX T1,DF.OPN		; Function is open
	MOVE T2,RC		; Circuit block
	LOAD T3,RCLID,(RC)	; Get the line ID for sanity check
	CALL CALKON		; Try to open the port
	IFSKP.
	  JE RCBCT,(RC),R2KIN1	; Point-to-point doesn't send NI hellos
	  CAIE T1,LS.ON		; Is line running?
	  IFSKP.
	    MOVX T1,RCS.RN	; Yes, then put circuit into the run state
	    SETONE RCSHM,(RC)	; Send a hello message to start things off
	  ELSE.
	    MOVX T1,RCS.WT	; No, say "waiting" then
	  ENDIF.
	  STOR T1,RCSTA,(RC)	; Set the state
	  SETZRO RCTIN,(RC)	; Clear timer
	  RETSKP
	ELSE.
	  CALL DNGTIM		; Get the current time
	  ADD T1,RTRCRT		; Wait before re-attempting the open
	  STOR T1,RCTIN,(RC)
	  RET			; and indicate failure
	ENDIF.

R2KIN1:	MOVX T1,RCS.WT		; Advance to the wait state
	STOR T1,RCSTA,(RC)
	MOVX T1,ADJ.IN		;SAY THE ADJACENCY IS INITIALIZING
	OPSTR <SKIPE AJ,>,RCAJQ,(RC) ;Get the adjacency
	STOR T1,AJSTA,(AJ)	;STORE IT IN THE ADJACENCY BLOCK
IFN FTOPS20,<
	LOAD T1,LIDEV,+RC.LID(RC) ; Get the device type
	CAIE T1,LD.DTE		; If DTE then give it a TOPS20
	IFSKP.
	  MOVX T1,RE.LDL	;  specific event.  This is so the
	  LOAD T2,RCLID,(RC)	;  Data Link Watcher will wiggle
	  MOVX T3,RS.LSL	;  the DTE again.
	  SETZ T4,
	  CALL RTNEVH		; Give a hidden event to NML
	ENDIF.
>  ;End IFN FTOPS20
	RETSKP			;GIVE GOOD RETURN ABOVE

	SUBTTL R2KCLS - Close the data link circuit

;R2KCLS - Close a DLL circuit
;
; Call: 
;	RC/ Pointer to Circuit Block
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1-T2
;
;We have to set the state of the circuit to off state.

R2KCLS:	MOVX T1,RCS.OF		;We are in "OFF" state
	STOR T1,RCSTA,(RC)	;Store this state
	MOVX T1,DF.CLS		;Function is close
	MOVE T2,RC		;Circuit block
	CALL CALKON		;Tell the DLL we are shutting down
	 TRN
	RET

	SUBTTL CALKON - Call the Kontroller

;CALKON - Call the DLL level "kontroller"
;
; Call: 
;	T1/ Kontroller Function Code
;	T2/ Pointer to circuit block
;	T3/ Argument (Usually Pointer to Message Block)
;	T4/ Next hop for the NI
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1-T4
;
;This routine will call the correct Kontroller on the correct circuit
;given the line id.  The kontroller is called with T1 containing the
;function to perform, T2 containing the hardware line address and T3
;with function specific data.  If the device is on the wrong CPU (only
;on TOPS-10 SMP), CALKON will queue the request to be serviced
;at once-a-jiffy service on the correct CPU.

CALKON:	SAVEAC <RC,P1>		;SAVE A COUPLE ACS
	MOVE RC,T2		;SET UP THE CIRCUIT BLOCK POINTER

IFN FTMP,<
	LOAD T4,LIDEV,+RC.LID(RC) ;GET THE DEVICE TYPE
	CAIN T4,LD.DDP		;IS IT NOT CPU-DEPENDANT?
	JRST CALKO5		;NOT CPU DEPENDANT, GO AHEAD AND DO IT.
	LOAD T4,LIKON,+RC.LID(RC) ;GET THE CPU NUMBER OF THE CIRCUIT
	CAMN T4,.CPCPN		;ARE WE ON THAT CPU NOW?
	JRST CALKO5		;YES
	CAIN T1,DF.XMT		;QUEUED OUTPUT?
	JRST CALKO4		;YES, QUEUE UP THE MESSAGE BLOCK.
	CAIE T1,DF.OPN		;IS THIS AN INITIALIZE FUNCTION?
	JRST CALKO1		;NO, TRY FOR SOMETHING ELSE
	SETONE RCINI,(RC)	;FLAG INITIALIZE TO BE DONE AT JIFFY LEVEL.
	RETSKP			;SAY WE DID IT.
CALKO1:	CAIE T1,DF.HLT		;IS THIS A HALT KONTROLLER FUNCTION?
	 BUG.(CHK,ROUIKF,ROUTER,SOFT,<Illegal Kontroller function>,,<

Cause:	CALKON was called with an illegal function code. The only allowed
	values are DF.XMT, DF.OPN, and DF.CLS.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.
>,RTN)

	SETONE RCHLT,(RC)	;FLAG HALT TO BE DONE AT JIFFY LEVEL.
	RETSKP			;SAY WE DID IT
CALKO4:	D36OFF			;NO, WE'LL HAVE TO QUEUE THE MESSAGE
	ENDQUE T3,RC.JSQ(RC),MB.NXT,T1 ;QUEUE THE MESSAGE
	D36ON			;TURN INTERRUPTS BACK ON
	RETSKP			; AND RETURN TO SENDER
CALKO5:
>;End of IFN FTMP
	LOAD T2,RCDLB,(RC)	;GET THE KONTROLLER'S BLOCK ADDRESS

	LOAD P1,LIDEV,+RC.LID(RC) ;GET THE DEVICE TYPE
;************************
	TORESCD
RTROTR::TRN			;LABEL FOR DNSNUP TO FIND OUTPUT MESSAGES
	TOXRESCD
				;EXPECTS (T3) = MESSAGE BLOCK
;************************

	CALLRET DNDDSP		;DISPATCH TO DNADLL AND RETURN +1 OR +2

	SUBTTL  CALQOB - Call CALKON for queued output.
;CALQOB - Send a message to the DLL "kontroller"
;
; Call:
;	RC/ Pointer to the circuit block
;	MB/ Pointer to message block
;	T4/ Next hop address (if any)
; Return:
;	+1, Always. If the output fails, it calls XMTFAI which returns
;		the message in MB and closes the port, setting a time at
;		which to reopen it.
;
;This routine is a jacket around CALKON to make the code sending messages
;simpler and easier to read.

CALQOB:	INCR RCCMQ,(RC)		;INCREMENT NUMBER OF MESSAGES QUEUED
	MOVX T1,DF.XMT		;SET UP FUNCTION CODE
	MOVE T2,RC		;COPY POINTER TO CIRCUIT BLOCK
	MOVE T3,MB		;COPY POINTER TO MESSAGE BLOCK
	CALL CALKON		;CALL THE KONTROLLER
	 CALLRET XMTFAI		;OUTPUT FAILED
	RET			;RETURN SUCCESS

	SUBTTL XMTFAI/CIRFAI - Transmit/Line failed

;Call:
;	RC/ Circuit block
;	MB/ Message that couldn't be transmitted


XMTFAI:	SETZRO RMDRM,(MB)	; Don't try to resend this
	MOVE T3,MB		; SET UP MESSAGE BLOCK POINTER FOR RTIOTC
	CALL RTIOTC		; FREE UP THE MESSAGE BLOCK
CIRFAI:	CALL RTIDWN		; SAY THE LINE IS NOW DOWN
	CALL R2KCLS		; Close the port
	MOVX T1,RCS.RJ		; Set state to rejected
	STOR T1,RCSTA,(RC)
	CALL DNGTIM		; and try to reopen it soon
	STOR T1,RCTIN,(RC) 	;
	RET

	SUBTTL RTRRCR - Recompute Routing

;RTRRCR - Routine to Recompute Routing Vector
;
; Call:
;	RTRNRV is expected to contain a ptr to the current "normal"
;routing vector, while RTRSRV points to a scratch routing vector.
;
; Return:
;	RET			;ALWAYS
;
; Uses: T1-T4
;
; AC Usage:
;	AJ/ Pointer to the adjacency block
;	RC/ Ptr to circuit block
;	T4/ Index into scratch routing vector
;	T3/ Index into normal routing vector
;
;This routine is called whenever it is thought that the topology of
;the network may have changed.  RTRNRV is the normal routing vector
;which is used by the forwarding routine, while RTRSRV is a scratch
;routing vector which this routine uses to compute the new routing
;vector.

RTRRCR:	SKIPN RTRCBQ		;Any circuits yet?
	 RET			;If not, just return
	TRACE RTR,<Recomputing network topology>
	STKVAR	<MSGLEN>
	SKIPN ENFLG		; Endnode?
	IFSKP.
	  SKIPE EVSDRP		; If we are not eavesdropping then nothing to
	   CALL RTRBMV		;  update.  Update "maybe" vector
	ELSE.
	  MOVE T2,RTRSRV	;POINT TO THE SCRATCH ROUTING VECTOR
	  XMOVEI T1,(T2)	;START AT FIRST NODE
	  ADD T2,RTRMXN		;ADD MAX NODE NUMBER FOR END OF SMEAR
	  MOVX T3,RNHOP!RNCST	;SMEAR WITH MAXIMUM HOPS AND COST
	  CALL DNSWDS		;SMEAR SCRATCH VECTOR WITH MAX
	  CALL RTRBSV		; Build the scratch routing vector from the
				;  individual adjacency vectors
	  CALL RTRBNV		; Now copy the scratch routing vector to the
	  SETZM RTRRCF		; Clear the "recompute-routing" flag
	ENDIF.			;  normal vector if there were any changes
	SKIPN T1,AJOFLQ		; Any adjacencies to free?
	 RET			; No
RTRRC2:	LOAD P1,AJNXT,(T1)	; Get next adjacency on queue if any
	CALL DNFWDS		; Return the memory
	MOVE T1,P1		; Get possible next adjacency to free
	JUMPN T1,RTRRC2		; If another tryto free it
	SETZM AJOFLQ		; The queue is now empty
	RET			; And now we are done

	SUBTTL RTRBSV - Build scratch routing vector

;Loop through all adjacencies on all circuits and copy their routing
;information into the scratch routing vector

RTRBSV:	SKIPN RC,RTRCBQ		; Get pointer to circuit queue
	 RET			; None there, so see if we should copy vector

RTRBS1:	LOAD Q2,RCCST,(RC)	; Cost on this circuit	
	LOAD AJ,RCAJQ,(RC)	; Get the adjacency block pointer
	JUMPE AJ,RTRBS7
;Enter adjacencies into the vector as only one hop away

RTRBS2:	MOVE P1,RTRSRV		; Build into spare vector
	LOAD T1,AJSTA,(AJ)	; Get the state of the adjacency
	CAXE T1,ADJ.UP		; Was it up?
	 JRST RTRBS6		; No, check next
	LOAD T1,AJNAN,(AJ)	; Get the node number for this adjacency
	JUMPE T1,RTRBS6		; Don't use it if no address
	ADD T1,RTRSRV		; Offset for this node
	SETONE RNRCH,(T1)	; It is reachable!
	LOAD T4,RNCST,(T1)	; Get the current cost
	CAIL Q2,(T4)		; Is new one (Q2) better?
	 JRST RTRBS3		; No, don't use it
	STOR Q2,RNCST,(T1)	; Yes, save cost
	MOVEI T3,1		; Number of hops is 1
	STOR T3,RNHOP,(T1)	; Save hops
	ADD T1,RTROFS		; Offset to adjacency vector
	MOVEM AJ,(T1)		; Use this new adjacency

RTRBS3:	LOAD P2,AJRTV,(AJ)	;GET POINTER TO ROUTING VECTOR FOR THIS ONE
	JUMPE P2,RTRBS6		; Endnodes won't have a routing vector
	MOVE Q1,RTRMXN		;GET THE MAXIMUM NUMBER OF NODES
	TMNE AJPH4,(AJ)		;Phase IV node?
	IFSKP.
	  ADDI P2,1		; NO, THEN START WITH NODE 1
	  ADDI P1,1
	  SOJ Q1,		; and we have one less to do
	ENDIF.
	MOVE Q3,P1		;GET THE OFFSET TO SRV
 	ADD Q3,RTROFS		;ADD IN THE OFFSET TO OSV
RTRBS4:	LOAD T2,RNCST,(P2)	;GET THE COST
	ADD T2,Q2		;ADD THE CIRCUIT COST
	LOAD T1,RNHOP,(P2)	;GET THE NUMBER OF HOPS
	AOJ T1,			;ADJUST IT BY US
	CAMG T2,RTRMXC		;IS THE COST WITHIN THE MAX
	CAMLE T1,RTRMXH		; HOW ABOUT THE HOPS?
	 JRST RTRBS5		;NO, THEN DO THE NEXT NODE
	LOAD T4,RNCST,(P1)	;GET THE BEST COST FOR HIM SO FAR
	CAMLE T2,T4		;Is this cost the same or better?
	 JRST RTRBS5		;No don't use it then
	CAME T2,T4		;Is it the same?
	IFSKP.			;Must be the same
	  JUMPN P1,RTRBS5	;Yes, but not the area router - so don't change
	  LOAD T4,AJNAN,(AJ)	;Get node number for this adjacency	  
	  MOVE T3,P1		;Get reach vector offset
	  ADD T3,RTROFS		;Add offset to output adjacency vector
	  MOVE T3,(T3)		;Get the adjacency
	  SKIPE T3		;None, don't try a reference
	   LOAD T3,AJNAN,(T3)	;Get the node's number
	  CAMGE T3,T4		;Is new one (T4), greater?
	   JRST RTRBS5		;No, don't use it
	ENDIF.
	STOR T1,RNHOP,(P1)	;IT'S BETTER, STOR HOPS
	STOR T2,RNCST,(P1)	;AND THE COST
	SETONE RNRCH,(P1)	;WE CAN REACH HIM
	MOVEM AJ,(Q3)		;STORE IT
RTRBS5:	AOJ P1,			;DO THE NEXT ONE
	AOJ P2,			; ON BOTH OF THEM
	AOJ Q3,			;Next adjacency slot
	SOJGE Q1,RTRBS4		;LOOP FOR THE NEXT NODE

RTRBS6:	LOAD AJ,AJNXT,(AJ)	;GET THE NEXT ADJACENCY
	JUMPN AJ,RTRBS2		;AND CHECK IT OUT
RTRBS7:	LOAD RC,RCNXT,(RC)	;Get next circuit block
	JUMPN RC,RTRBS1		; if there is one
	RET
	SUBTTL RTRBNV - Build the normal vector from scratch vector
;Here to go through and compare the routing vectors.  We also
;look for local users in the "normal" routing vector as we go
;through.  With local users, RTRNOV has the address of the vector entry
;to that "NSP", therefore it is left alone.

RTRBNV:	STKVAR <TCIFLG>
	SETZM TCIFLG		;Initialize topology change interrupt flag
	MOVN Q3,RTRMXN		;Number of nodes in reach vector
	HRLZI Q3,-1(Q3)		;Make AOBJN pointer and include node 0
	MOVE P1,RTRSRV		;POINTER TO SCRATCH ROUTING VECTOR
	MOVE P2,RTRNRV		;POINTER TO NORMAL ROUTING VECTOR
	SETZB Q1,Q2		;Q1 := CHECKSUM, Q2:= # OF UPDATES

RTRBN1:	MOVE T1,(P2)		;GET THE NORMAL ENTRY FOR NODE
	TMNN RNLCL,+T1		;Is this the local node?
	IFSKP.
	  MOVEM T1,(P1)		;IF ITS A LOCAL NODE,
	  MOVE T1,P2		;GET COPY OF NRV ENTRY
	  ADD T1,RTROFS		;FIND THE OUTPUT VECTOR ENTRY
	  MOVE T1,(T1)		;GET THE OUTPUT CIRCUIT
	  ADD P1,RTROFS		;FIND THE OUTPUT VECTOR ENTRY
	  MOVEM T1,(P1)		;STORE THE OUTPUT CIRCUIT
	  SUB P1,RTROFS		;POINT BACK TO THE OUTPUT VECTOR
	  JRST RTRBN2		;JUST UPDATE THE LOCAL ENTRY IN SCRATCH
	ENDIF.
	ANDI T1,<RNHOP!RNCST>	;Get only cost and hops for the normal vector
	MOVE T2,(P1)		; and only cost and hops for
	ANDI T2,<RNHOP!RNCST>	; the scratch vector
	CAMN T1,T2		;Any differences?
	IFSKP.
	  SETONE RNCHG,(P1) 	;Yes, set change bit in vector
	  AOJ Q2,		; and increment count of differences
	  MOVE T1,(P2)		;Get normal vector entry for node again
	  XOR T1,(P1)		;We want to know if RNRCH has changed
	  TMNN RNRCH,+T1	;Were reachabilty bits different?
	  IFSKP.
	    SETOM TCIFLG	;Yes, flag that we had a topology change
	    SETZ T3,		;Assume reachable
	    TMNN RNRCH,(P1)	;If the node is now reachable?
	     MOVEI T3,1		;It is not
	    SKIPN T2,Q3		;Get node number
	    IFSKP.	    
	      MOVE T1,RTRHOM	; and generate a 16 bit address
	      DPB T1,[POINTR (T2,RN%ARE)]
	      EVENT RE.NRC,<Node reachability change>
	    ENDIF.
	  ENDIF.
	ENDIF.
	LDB T1,[POINTR ((P1),<RNHOP!RNCST>)] ;HOP AND COST MUST BE ADJACENT
	ADD Q1,T1		;SUM THE CHECKSUM

RTRBN2:	AOJ P1,			;LOOK AT NEXT "SCRATCH" ENTRY
	AOJ P2,			; AND NEXT "NORMAL" ENTRY
	AOBJN Q3,RTRBN1		;LOOP OVER ALL ENTRIES

	MOVE T1,Q1		;GET COPY OF CHECKSUM
	CALL CKSNRM		;FIXUP THE CHECKSUM
	MOVEM T1,RTRCKS		;DONE, STORE THE CHECKSUM

;Now exchange the newly computed vector for the old normal vector

	D36OFF			;NO INTERRUPTS
	MOVE T1,RTRSRV		;GET POINTER TO SCRATCH REACHABILITY VECTOR
	EXCH T1,RTRNRV		;SWITCH THE SCRATCH AND THE NORMAL
	MOVEM T1,RTRSRV		;USE THE OLD NORMAL VECTOR AS THE SCRATCH

	MOVE T1,RTRSOV		;GET POINTER TO SCRATCH OUTPUT-CIRC VECTOR
	EXCH T1,RTRNOV		;SWITCH THE SCRATCH AND NORMAL
	MOVEM T1,RTRSOV		;USE THE OLD NORMAL VECTOR AS THE SCRATCH
	D36ON			;GIVE UP INTERLOCK

	JUMPE Q2,RTN		;IF NO CHANGES IN COST/HOPS, JUST RETURN
IFN FTOPS20,<
	SKIPGE TCIFLG		;Reachability to some node change?
	 CALLX (MSEC1,NTCIN)	;Invoke network topology change interrupt.
> ;End IFN FTOPS20

	MOVE RC,RTRCBQ		;GET PTR TO FIRST CIRCUIT BLOCK
	JUMPE RC,RTN		;NO CIRCUITS?  JUST RETURN
RTRBN4:	SETONE RCSRM,(RC)	;SET THE "SEND ROUTING MESSAGE" FLAG
	LOAD RC,RCNXT,(RC)	;GET THE NEXT CIRCUIT
	JUMPN RC,RTRBN4		;Go set SRM, if more circuits
	RET			;RETURN

	SUBTTL  RTRBMV - Maybe vector update when running as an endnode


RTRBMV:	CALL DNGTIM		; Get current milliseconds
	CAMG T1,BMVTIM		;  and see if time for another update
	 RET			;  of the maybe vector.
	ADD T1,BMVIVL		; Compute time of next update
	MOVEM T1,BMVTIM
	SKIPN RC,RTRCBQ		; Do we have a circuit
	 RET
	OPSTR <SKIPE AJ,>,RCAJQ,(RC) ; Get the only adjacency
	IFSKP.
	  MOVE T1,RTRNRV 	; Address of vector
	  MOVE T2,RTRMXN	; Number of slots in vector
	  AOJ T2,		;  including node 0
	  DO.
	    SETZRO RNMBY,(T1)	; Clear the "maybe bit"
	    SOJLE T2,RTN	; Exit when all elements done
	    AOJ T1,		; Point to next element
	    LOOP.		; Loop back
	  ENDDO.
	ENDIF.
	LOAD P2,AJRTV,(AJ)	; Get pointer to routing vector
	JUMPE P2,RTN		; Just in case
	ADDI P2,1		; Start with node 1
	SKIPN P1,RTRNRV		; Get reach vector
	 RET
	LOAD T1,RCCST,(RC)	; Get the cost on the Ethernet
	STOR T1,RNCST,(P1)	;  and save it in element 0 of the vector
	MOVEI T1,1		;  and dummy up the hops
	STOR T1,RNHOP,(P1)
	ADDI P1,1		;  Step to node 1
	MOVE Q1,RTRMXN		; Get the maximum number of nodes
RTRBM1:	SETZRO RNMBY,(P1)	; Assume not reachable
	LOAD T2,RNCST,(P2)	; Get the cost
	OPSTR <ADD T2,>,RCCST,(RC) ; Add the circuit cost
	LOAD T1,RNHOP,(P2)	; Get the number of hops
	AOS T1			; Adjust it by us
	CAMGE T2,RTRMXC		; Is the cost within the max?
	CAML T1,RTRMXH		;  How about the hops?
	 JRST RTRBM2		; No, then do the next node
	SETONE RNMBY,(P1)	; Yes, assume reachable
RTRBM2:	AOJ P1,			; Do the next one
	AOJ P2,			;  on both of them
	SOJGE Q1,RTRBM1		; Loop for the next node
	SETZM RTRRCF		; Clear the "recompute-routing" flag
	RET

	SUBTTL RTRUPD - Send routing messages if needed

;RTRUPD - Routine to perform the update process (send routing messages)
;
; Call: 
;	RTRNRV must contain the ptr to the normal routing vector
;	RTRCBQ must contain a ptr to the first circuit block
;
; Return: 
;	RET			;Always
;
; Uses: T1-T4

;Loop through all the circuit blocks and see if the long timer (T2) has
;expired.  If it has we send a routing message, if it hasn't check
;the send routing message flag and if set, send the routing message if
;the short timer has expired. The routing message is built from the
;"normal" routing vector. After the routing message has been queued,
;the circuit block "last routing message sent" timer is updated, and
;the "send routing message" flag is cleared.

RTRUPD:	SKIPGE ENFLG		;If an endnode
	 RET			; then don't send a routing message
	TRVAR <COUNTPOS,NODCNT,TOTALNF>
	STKVAR <EMPTY,MAXNODE,MAXSEG,OVFLG>
	SKIPA RC,RTRCBQ		;GET THE BEGINNING OF THE CIRCUIT QUEUE
UPDLOP:	LOAD RC,RCNXT,(RC)	;GET THE POINTER TO THE NEXT ONE
				;Careful if this call is moved (JRST RTRCHK)
	JUMPE RC,RTRCHK		;IF DONE THEN GO CHECK THE ROUTING VECTOR
	LOAD T1,RCSTA,(RC)	;GET THE STATE OF THIS CIRCUIT
	CAIE T1,RCS.TT		;IS THE STATE IN TEST
	 CAIN T1,RCS.RN		; OR OK STATE
	  TRNA			;YES, SEND ROUTING MESSAGE
	JRST UPDLOP		;NO, LOOK AT NEXT CIRCUIT
	SETZM TOTALNF		;CLEAR OUT TOTAL NODE FLAG
	SETZM EMPTY		;Clear flag saying data in message
	OPSTR <SKIPN T2,>,RCTLR,(RC) ;Have we ever sent an update?
	 JRST RTRSRB		;No, send one now
	CALL DNGTIM		;GET THE CURRENT TIME IN T1
	SUB T1,T2		; Compute the elapsed time since last update
	MOVE T2,RTRTM1		; Get the long timer for point to point 
	TMNE RCBCT,(RC)		; Broadcast circuit?
	 MOVE T2,RTRBT1		; Yes, use the broadcast timer
	CAML T1,T2		; Has the update timer (T1) expired?
	 JRST RTRSRB		; Yes, send all nodes now
	TMNN RCSRM,(RC)		; Forced update?
	 JRST UPDLOP		; No, look at next circuit
	TRNA
RTRSRB:	SETOM TOTALNF		; Indicate we need to send complete topology
	LOAD T1,RCBSZ,(RC)	;GET THE CIRCUIT BLOCK SIZE
	SKIPN T1		;HAVE ONE TO USE?
	 BUG.(CHK,ROUBSZ,ROUTER,SOFT,<Router circuit block size was zero on a running circuit>,,<

Cause:	The blocksize for a circuit is defaulted to RTRBSZ and updated with 
	information from nodes on the circuit to determine a new minimum
	blocksize for the circuit.  Somehow this ended up as zero.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.
>,UPDLOP)
	LOAD AJ,RCAJQ,(RC)	; No, then get pointer to only adjacency for
				;  point-point or any for broadcast
	JUMPE AJ,UPDLOP		; No adjacencies, give up...
	JN RCBCT,(RC),RTRSX1	; If broadcast don't check adjacency state
	LOAD T1,AJSTA,(AJ)	; Get state of adjacency
	CAIE T1,ADJ.UP		; Is it "up"
	 JRST UPDLOP		; No, try next circuit
RTRSX1:	MOVE P1,RTRNRV		;POINT TO NORMAL ROUTING VECTOR
	SETZ P2,		;CLEAR OUT CHECKSUM
	LOAD T1,AJNTY,(AJ)	;GET THE NODE TYPE IN T1
	CAIE T1,ADJ.3F		;IS IT A PHASE III ROUTER?
	 JRST SP4RM		;NO, THEN CHECK FOR PHASE IV
	
	MOVE T1,RTRMX3		;GET THE MAXIMUM NUMBER OF PHASE III NODES
	MOVEM T1,NODCNT		;SAVE AS THE COUNT OF NODES
	LSH T1,1		;TWO BYTES PER NODE
	ADDI T1,2		;ADD IN SPACE FOR CHECKSUM
	CALL DNGMSG		;GET THE MESSAGE BLOCK
	 JRST UPDLOP		;COULDN'T, THEN TRY NEXT CIRCUIT
	MOVE MB,T1		;GET THE MESSAGE BLOCK POINTER
	XMOVEI T1,UD.MSD(MB)	;GET POINTER TO USER DATA MSD
	CALL DNPINI		;INITIALIZE THE MSD AND HEADER

SP3LOP:	AOS P1			;PHASE III STARTS WITH NODE 1
	LDB T1,[POINTR((P1),<RNHOP!RNCST>)] ;GET THE HOP!COST
	ADD P2,T1		;SUM THE CHECKSUM
	CALL DNP2BY		;PLACE BYTES IN ROUTING MESSAGE
	SOSLE NODCNT		;DO IT FOR ALL THE NODES but not zero
	 JRST SP3LOP		;Continue until last node done
	MOVE T1,P2		;Checksum in T1
	CALL RTRSNS		;SEND THE SEGMENT OUT
	 TRN			;ON ERROR TRY NEXT CIRCUIT
	JRST UPDLOP		;AND DO THE NEXT ONE

; Here to handle a Phase IV message, but first we have to check for
; Phase III small nodes.  If it is one then we exit and do the next circuit
; T1 was set up with the node type from the adjacency vector above.


SP4RM:	JN RCBCT,(RC),SP4RM1	;If broadcast don't check adjacency type
	CAIE T1,ADJ.3S		;PHASE III SMALL NODE
	 CAIN T1,ADJ.LN		;OR PHASE IV END NODE
	JRST UPDLOP		;Yes, then no routing update need be sent

SP4RM1:	ADD P1,RTRLMG		;Add in offset so we don't start with the same
				; node in the vector each time
	MOVE T1,RTRMXN		;GET THE MAXIMUM NUMBER OF NODES
	MOVEM T1,MAXNODE	;SAVE AS MAXIMUM TO SEND

SP4RM3:	MOVEI P2,1		;THE CHECKSUM STARTS AT 1 FOR PHASE IV
	LOAD T1,RCBSZ,(RC)	;GET THE NUMBER OF BYTES FOR MESSAGE BLOCK
	CALL DNGMSG		;GET THE MESSAGE BLOCK
	 JRST UPDLOP		;COULDN'T, THEN TRY NEXT CIRCUIT
	MOVE MB,T1		;GET THE MESSAGE BLOCK POINTER
	XMOVEI T1,UD.MSD(MB)	;GET POINTER TO USER DATA MSD
	CALL DNPINI		;INITIALIZE THE MSD AND HEADER
	LOAD T1,RCBSZ,(RC)	;Number of bytes we can fit into one message
	SUBI T1,6		;Minus the header length and checksum
	LSH T1,-1		;Divide by two since all parts of a segment
	MOVEM T1,MAXSEG		; are two bytes in width
SP4RM4:	SETZM NODCNT		;CLEAR OUT THE NODE COUNT FOR THIS SEGMENT
	SETZM OVFLG		;CLEAR THE OVERFLOW FLAG NOW
	SKIPE TOTALNF		;ARE WE TO INCLUDE ALL NODES?
	 JRST SP4RM6		;YES, THEN START WITH THIS ONE

; Here we loop until we get a node which has the CHANGE bit set in the routing
; vector.

SP4RM5:	LOAD T1,RNCHG,(P1)	;GET THE CHANGE BIT
	JUMPN T1,SP4RM6		;When set start with this node
	AOS P1			;INCREMENT THE COUNT
	MOVE T1,P1		;GET THE NODE NUMBER
	SUB T1,RTRNRV		;FROM THE INDEX INTO ROUTING TABLE
	CAMLE T1,RTRMXN		;HAVE WE REACHED THE END OF THE VECTOR?
	 MOVE P1,RTRNRV		;YES, THEN RESET TO THE BEGINNING
	SOSL MAXNODE		;DECREMENT COUNT OF NODES LEFT TO LOOK AT
	 JRST SP4RM5		;LOOP UNTIL WE FIND ONE WITH CHANGE SET
	JRST SP4RM9		;WE HAVE LOOKED AT ALL NODES


;Here to begin a new segment of the routing message

SP4RM6:	MOVE T1,MAXSEG		;Get number of 2-byte fields left in buffer
	CAIGE T1,3		;Is there enough room for a one node segemnt?
	 JRST SP4RM8		;No, then send current message and start anew
	CALL DNRPOS		;READ THE CURRENT POSITION
	MOVEM T1,COUNTPOS	;SAVE THE POSITION FOR COUNT
	SETZ T1,		;GET A ZERO
	CALL DNP2BY		;PUT THE COUNT IN
	MOVE T1,P1		;GET THE NODE NUMBER INDES
	SUB T1,RTRNRV		;MAKE IT A NODE NUMBER
	ADD P2,T1		;ADD INTO THE CHECKSUM
	CALL DNP2BY		;PUT THE 2 BYTES INTO THE MESSAGE
	SOS MAXSEG		;Start-ID = 2 bytes
	SOS MAXSEG		; and count = 2 bytes

SP4RM7:	LDB T1,[POINTR((P1),<RNHOP!RNCST>)] ;Get COST/HOPS for this entry
	ADD P2,T1		;ADD TO CHECKSUM
	AOS NODCNT		;INCREMENT THE COUNT OF NODES IN THIS SEGMENT
	SETOM EMPTY		;Flag to indicate data in message
	CALL DNP2BY		;Put COST/HOPS into the message
	AOS P1			;DO THE NEXT ONE
	MOVE T1,P1		;GET THE NODE NUMBER
	SUB T1,RTRNRV		;FROM THE INDEX INTO ROUTING TABLE
	CAMG T1,RTRMXN		;HAVE WE REACHED THE MAXIMUM YET?
	IFSKP.
	  SETOM OVFLG		;SET THE OVERFLOW FLAG SO WE END THE SEGMENT
	  MOVE P1,RTRNRV	; and reset to the beginning of the vector
	ENDIF.
	SOSG MAXNODE		;DECREMENT TOTAL NODE COUNT
	 JRST SP4RM9		; JUMP IF DONE
	SOSG MAXSEG		; Two COST/HOP bytes and see if more room
	 JRST SP4RM8		; NO, THEN SEND IT AND LOOP BACK

	SKIPE OVFLG		;OVERFLOW SET?
	IFSKP.			; No
	  LOAD T1,RNCHG,(P1)	;GET THE CHANGE BIT FOR NEXT NODE
	  SKIPN TOTALNF		;IS THE TOTAL NODE FLAG SET?
	   SKIPE T1		; or do we have a change bit set?
	  JRST SP4RM7		;  Yes, go do the next entry
	ENDIF.
	CALL CLSSEG		; Close the current segment
	JRST SP4RM4		;  and possibly start a new one

SP4RM8:	CALL CLSSEG		; Close out the current segment
	MOVE T1,P2		; Checksum to T1
	CALL RTRSNS		;SEND THE SEGMENT OUT
	 JRST UPDLOP		;ERROR, THEN GO TO THE NEXT CIRCUIT (MB freed)
	JRST SP4RM3		;SUCCESS, START A NEW MESSAGE

;Here when all nodes in the normal vector have been looked at
;See if we found any and if so send the routing message.

SP4RM9:	SKIPE EMPTY		; Any data in message?
	IFSKP.			; No
	  CALL FREMSG		; Return the message block
	  JRST UPDLOP		; and step to next circuit
	ENDIF.
	SKIPE NODCNT		; Yes, do we have any nodes in this segment?
	 CALL CLSSEG		; Yes, close off the segment
	MOVE T1,P2		; Checksum must be in T1
	CALL RTRSNS		;SEND THE SEGMENT OUT
	 JRST UPDLOP		;ERROR, THEN GO TO THE NEXT CIRCUIT
	MOVE T1,RTRBSZ		;Get the block size
	IDIVI T1,5		; and use it to compute 
	ADD T1,RTRLMG		; a new starting point
	CAML T1,RTRMXN		;HAVE WE GONE TOO FAR?
	 SETZ T1,		; Start over again
	MOVEM T1,RTRLMG		;MAKE THIS NEW START
	JRST UPDLOP		; Now advance to the next circuit

	ENDSV.

;Here because we have reached the end of a segment.  That was determined
;by the absence of a CHANGE flag in the vector for some node, or the end of a
;message, or the end of the reach vector has been reached.  We will now
;close the segment.

CLSSEG:	CALL DNRPOS		;GET OUR CURRENT POSITION
	EXCH T1,COUNTPOS	;Get the previously reverved spot for the count
	CALL DNGOPS		;GO TO THAT POSITION
	MOVE T1,NODCNT		;GET THE NUMBER OF NODES FOR THIS SEGMENT
	ADD P2,T1		;ADD THE COUNT TO THE CHECKSUM
	CALL DNP2BY		;PLACE IT INTO THE MESSAGE
	MOVE T1,COUNTPOS	;GET THE END OF THE MESSAGE BACK
	CALL DNGOPS		;AND GO THERE
	RET

;Here to checksum the routing vector to see if it may be corrupted

RTRCHK:	MOVE T3,RTRMXN		;GET THE MAXIMUM NUMBER OF NODES
	MOVE P1,RTRNRV		;GET THE POINTER TO THE NORMAL ROUTING VECTOR
	SETZ P2,		;CLEAR OUT REG FOR CHECKSUM
RTRCK1:	SETZRO RNCHG,(P1)	;CLEAR OUT CHANGE FLAG
	LDB T1,[POINTR((P1),<RNHOP!RNCST>)] ;GET THE HOPS!COST
	ADD P2,T1		;ADD INTO MESSAGE
	AOJ P1,			;ADD IN THE NEXT ONE
	SOJGE T3,RTRCK1		;LOOP FOR THEM ALL

	MOVE T1,P2		;GET COPY OF CHECKSUM
	CALL CKSNRM		;NORMALIZE THE CHECKSUM
	CAME T1,RTRCKS		;IS IT THE SAME AS THE OLD CHECKSUM?
	SKIPN RTRCKS		; AND DID WE HAVE ONE?
	TRNA			;IT'S OK
	BUG.(CHK,ROUBCD,ROUTER,SOFT,<Bad Checksum detected when building routing msg>,,<

Cause:	Somehow our internal reachability vector has been damaged since the
	last rebuilding.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.
>)
	MOVEM T1,RTRCKS		;STORE THE CHECKSUM
	RET			;RETURN TO CALLER

;
; All Outgoing Routing Messages Both Phase III And Phase IV
; pass through this routine.  It expects the unnormalized checksum
; in P2.

RTRSNS:	MOVE T1,P2		;GET COPY OF CHECKSUM
	CALL CKSNRM		;NORMALIZE THE CHECKSUM
	CALL DNP2BY		; AND WRITE IT IN MESSAGE

;Now we must make up the router header
	
	XMOVEI T1,RM.MSD(MB)	;GET POINTER TO ROUTER'S MSD
	CALL DNPINI		;SET UP TO WRITE HEADER
	SETZ T1,		;BUILD FIRST BYTE IN T1
	MOVX T2,RCM.1R		;TYPE = ROUTING MESSAGE
	STOR T2,CMTYP,+T1	;PLACE IT IN CORRECT FIELD
	SETONE CMCTL,+T1	;INDICATE IT IS A CONTROL MESSAGE
	CALL DNP1BY		;PLACE THE BYTE

	MOVE T1,RTRADR		;GET OUR ADDRESS
	MOVE T3,RTRHOM		; and our area
	TMNE AJPH4,(AJ)		; If Phase IV include the area number
	 DPB T3,[POINTR(T1,RN%ARE)]
	CALL DNP2BY		;PUT ADDRESS IN MESSAGE

	SETZ T1,		;ZERO FOR A RESERVED PHASE IV BYTE
	TMNE AJPH4,(AJ)		; If Phase IV include a reserved byte
	  CALL DNP1BY

	XMOVEI T1,UD.MSD(MB)	;POINT TO USER DATA MSD
	XMOVEI T2,RM.MSD(MB)	;MAKE RTR MSD POINT TO USER DATA MSD
	SETZ T3,		;DON'T CHANGE BYTE POINTERS
	CALL DNLMSS		;LINK IN THE MESSAGE SEGMENT
	TRACE RTR,<Sending routing message>
	JE RCBCT,(RC),RTRSN2	;If not broadcast send packet now
	DMOVE T1,RTRALR		;Sending to "all-routers"
	CALL RTRSNI		;Broadcast set it up differently
	TRNA
RTRSN2:	CALL CALQOB		;OUTPUT THE MESSAGE BLOCK
	 TRN
	SETZRO RCSRM,(RC)	;INDICATE WE HAVE SENT ROUTING MESSAGE
	CALL DNGTIM		;Get current time
	SKIPE TOTALNF		;Was this a complete update?
	 STOR T1,RCTLR,(RC)	;Yes, remember the time we sent it
	RETSKP			;GIVE GOOD RETURN

	ENDTV.

	SUBTTL RTRSNI - Send hello/routing message on the NI

;Call:
;	T1/ Destination address high order
;	T2/ Destination address low order

RTRSNI:	STOR T1,MBDS1,(MB)	; Save address of destination (High-order)
	STOR T2,MBDST,(MB)	; Low order address
	SETZ T4,		; No next hop for broadcast messages
	CALL CALQOB		;
	RET			;AND CONTINUE ON

	SUBTTL CKECTO - Check the cache timer for each node

CKECTO:	SOSLE CCHTIM		; Time to check cache flags?
	 RET			; No
	MOVE T4,RTRMXN		; Count of slots in vector
	MOVE T3,RTRNRV		; Point to the reach vector which contains
				;  the cache flag
CKECT1:	JE RNCCH,(T3),CKECT2	; If cache flag is set check cache timeout
	MOVE T2,T3		; Copy current vector address
	ADD T2,RTROFS		; Add offset to timer value
	CALL DNGTIM		; Get current time
	CAMG T1,(T2)		; Is current time past time out value
	IFSKP.
	  SETZRO RNCCH,(T3)	; Yes, clear the in-cache flag
	ENDIF.
CKECT2:	AOJ T3,			; Step to next node
	SOJGE T4,CKECT1		; More to do?
	MOVE T1,RTRADR		; Get local address
	ADD T1,RTRNRV		;  and index into reach vector slot
	SETONE RNCCH,(T1)	;   and set the in-cache flag
	MOVEI T1,^D120		; Two minutes before we check again
	MOVEM T1,CCHTIM
	RET

	SUBTTL SELDSR - Select a desiginated router

SELDSR:	SKIPA RC,RTRCBQ		; Loop through all circuit blocks
SELDS1:	LOAD RC,RCNXT,(RC)
	 JUMPE RC,R		; If done, just return
	TMNN RCBCT,(RC)		; We only compute a desiginated router for
	 JRST SELDS1		;  for broadcast circuits
	SETZRO RCPRI,(RC)	; Start at lowest priority
	SETZ P1,
	OPSTR <SKIPA AJ,>,RCAJQ,(RC) ;Get pointer to first adjacency
SELDS2:	LOAD AJ,AJNXT,(AJ)	; Step to next
	SKIPN AJ
	IFSKP.
	  LOAD T1,AJSTA,(AJ)	; Get state of adjacency
	  CAIE T1,ADJ.IN	; If state is not initializing
	   CAIN T1,ADJ.UP	;  or up, don't consider it
	    TRNA
	   JRST SELDS2		; [7179]
	  LOAD T1,AJPRI,(AJ)	; Get the adjacency's priority
	  LOAD T3,AJNAH,(AJ)	; Get the address
	  LOAD T4,AJNAL,(AJ)
	ELSE.
	  MOVE T1,RTRPRI	; No more adjacencies, check ourselves
	  MOVE T3,RTRHIO	; Get our address in string format
	  HLRZ T4,RTRLOO
	ENDIF.
	CAIGE T1,(P1)		; Is it greater/equal than what we have so far?
	 JRST SELDS3		; No, step to next
	CAIE T1,(P1)		; Was it the same?
	IFSKP.
	  LOAD T2,RCDSL,(RC)	; Get current designated router's address
	  CAMG T4,T2		; Is new one higher?
	   JRST SELDS3		; No, keep the one we have
	ENDIF.
	MOVE P1,T1		; Save this as the highest
	DMOVE Q1,T3		;  and save address
SELDS3:	JUMPN AJ,SELDS2		; Check next adjacency or ultimately ourselves
	STOR P1,RCPRI,(RC)	; Save new priority
	OPSTR <CAMN Q2,>,RCDSL,(RC) ; Has the designated router changed?
	 RET			; No, then done
	STOR Q2,RCDSL,(RC)	; Save the designated routers address
	HRLZ Q2,Q2		; Reposition low order
	CAME Q2,RTRLOO		; Are we the designated router?
	IFSKP.
	  MOVEI T2,^D5		; Seconds to wait
	  STOR T2,RCDRT,(RC)	;  before we assume DSR role
	ELSE.
	  SETZRO RCDRT,(RC)	; No longer waiting to assume DSR role
	  SETZRO RCDSR,(RC)	; We are not the DSR
	ENDIF.
	STOR Q1,RCDSH,(RC)	; Save high order of address
	JRST SELDS1		;  and check next circuit

	SUBTTL RTRTMR - Routine to perform timer functions

;RTRTMR - Hello, Listener and other timer processes
;
; Call:
;	RTRCBQ must point to the first circuit block
;
; Return:
;	RET			;ALWAYS
;
; Uses: T1-T4
;
;This code implements the Update Process, the Node Talker Process, and the
;Node Listener Process.

;First we do the Node Listener Process.  This consists of ensuring that we
;have heard from all adjacencies within time T3 * T3MULT (or BCT3MULT).  (T3
;is the adjacencies hello timer).  Ie: current_time - AJTLR < AJNHT.  If the
;previous expression is not true, then if the circuit is a:
; point to point -  set off-line
; broadcast (Ethernet) - the adjacency is destroyed.

RTRTMR:	SAVEAC <P1>
	SKIPA RC,RTRCBQ		;GET THE FIRST CIRCUIT BLOCK
RTRTR1:	LOAD RC,RCNXT,(RC)	;GET NEXT CIRCUIT BLOCK
	JUMPE RC,RTRSHM		;Send hellos if necessary

	LOAD P1,RCSTA,(RC)	;Get state of circuit
	CAILE P1,RCS.RJ		;Is state off or rejected?
	 JRST RTRTR2		;No, check TI state
	LOAD T2,RCTIN,(RC)	;Is the timer running?
	JUMPE T2,RTRTR2		;No, look no further (maybe to TR3)

	CALL DNGTIM		;Get the current time in T1
	CAMGE T1,T2		;Has time elapsed?
	IFSKP.			;Yes
	  CALL R2KINI		;Try to reopen circuit
	   TRN
	  JRST RTRTR3		; and move to next circuit
	ENDIF.
RTRTR2:	CAIE P1,RCS.TI		;IS LINK IN TI WAIT?
	 CAIN P1,RCS.TV		;IS IT IN TV WAIT?
	  TRNA			;YES, CHECK OUT TI TIMER
	JRST RTRTR3		;NO, CHECK OUT OTHER TIMERS
	CALL DNGTIM		;GET THE CURRENT TIME
	OPSTR <SUB T1,>,RCTIN,(RC) ;SUBTRACT WHEN WE GOT THE LINE UP
	CAMGE T1,RTRITM		;HAS TIME EXPIRED?
	JRST RTRTR3		;NO, JUST CONTINUE ON

;Here when the time allowed for the response to the RI we sent has expired.

	ETRACE RTR,<Initialization timer expired and is restarting the circuit>
	MOVX T1,RS.VRT		;EVENT REASON: VERIFICATION RECEIVE TIMEOUT
	CALL RTEINL		;REPORT INITIALIZATION FAILURE EVENT
	CALL CIRFAI		;Close the portal and set reopen time
	SETOM RTRRCF		;RECOMPUTE ROUTING LATER
	JRST RTRTR1		; AND TRY THE NEXT CIRCUIT

;Now check the hello and listener timers.

RTRTR3:	CAIE P1,RCS.TT		; Is circuit in test state
	CAIN P1,RCS.RN		;  or is it running?
	TRNA			;YES, OK TO DO THINGS
	JRST RTRTR1		;NO, CHECK OUT THE NEXT CIRCUIT

RTRCHT:	OPSTR <SKIPA AJ,>,RCAJQ,(RC) ;Get pointer to first adjacency
RTRCH1:	LOAD AJ,AJNXT,(AJ)	;Get next adjacency
	JUMPE AJ,[CALL RTRTLK	;Check the hello timer
		  CALL DSRCHK	; and the desiginated router timer
		  JRST RTRTR1]	;Now, step to next circuit
	LOAD T1,AJSTA,(AJ)	;Get the state of the adjacency
	CAIE T1,ADJ.UP		;Is it up?
	 JRST RTRCH1		;No, then don't check further
	CALL DNGTIM		;GET THE CURRENT TIME
	OPSTR <SUB T1,>,AJTLR,(AJ) ;SUBTRACT THE TIME LAST MESSAGE WAS RECEIVED

	OPSTR <CAMGE T1,>,AJNHT,(AJ) ;DID THE LISTENER TIMER EXPIRE?
	 JRST RTRCH1		; No, check the next adjacency

;Here when the listener timer has been exceeded.  The adjacency is declared
;down.  On point to point circuits, the circuit gets recycled.

	LOAD T3,AJADR,(AJ)	;[7176] Get the node address
	INCR RCAJD,(RC)		;Count adjacency down events
	LOAD T2,RCLID,(RC)	;Get the device ID
	EVENT RE.AJD,<Adjacency down-listen timer expired>,
	LOAD T1,AJSTA,(AJ)	;Get the state of the adjacency
	CAXN T1,ADJ.UP		;Was it up?
	 SETOM RTRRCF		; Yes, recompute routing
	JN RCBCT,(RC),RTRCH3	;No circuit down if broadcast
	ETRACE RTR,<Node listener timed out and is rejecting circuit>
	MOVX T1,RS.ALT		;EVENT REASON: ADJACENT NODE LISTENER TIMEOUT
	CALL RTELDL		;REPORT CIRCUIT DOWN - CIRCUIT FAULT EVENT
	CALL CIRFAI		;Close the port and set reopen time
	JRST RTRCH1		; Check next adjacency
RTRCH3:	SKIPN ENFLG		; Endnode?
	IFSKP.
	  MOVX T1,ADJ.UN	; Set adjacency state to unused
	  STOR T1,AJSTA,(AJ)
	  SETZRO RCDSL,(RC)	; Clear DR address
	ELSE.
	  MOVE T1,AJ		;The adjacency to zap
	  MOVE T2,RC		; and the circuit block it belongs to
	  CALL RTRZAB		;Flush the adjacency block
	ENDIF.
	JRST RTRCH1		; down and check next

;This code implements the Node Talker Process.  Loop through all circuits,
;sending hello messages on any circuits that need them.  For point to
;point circuits, a hello message is sent when no other traffic has been sent
;within T3 (the hello timer period for this circuit).
;Ie: current_time - RCTLS >= RCTM3.  For broadcast circuits, a hello message
;is sent when when T3 seconds have elapsed since the last hello message
;(current_time - RCTLH >= RCTM3).

RTRTLK:	CALL DNGTIM		;Get the time again
	LOAD T3,RCTLS,(RC)	;Assume point to point for a moment
	TMNE RCBCT,(RC)		;Broadcast circuit?
	 LOAD T3,RCTLH,(RC)	; Yes, then compare against last hello time
	SUB T1,T3		;Compute amount of elapsed time
	MOVX T2,RCSHM		;Get the send hello message flag
	OPSTR <CAML T1,>,RCTM3,(RC) ;Have we been quiet for too long??
	 IORM T2,$RCSHM(RC)	; Yes, set send Hello message flag
	RET

; Here to send hello messages to all circuits that have RCSHM set

RTRSHM:	SKIPA RC,RTRCBQ		;Point to first circuit block
RTRSH1:	LOAD RC,RCNXT,(RC)	;Get next circuit block
	JUMPE RC,RTN		;And return when done...

	TMNN RCSHM,(RC)		;Do we need to send a hello message?
	 JRST RTRSH1		; Nope, try again

;We have just found a circuit that needs a hello message, determine what type
;of circuit it is, send the appropriate message.

	JN RCBCT,(RC),RTREHM	; Broadcst circuit?
	MOVX T1,NO.HEL+1	;LENGTH OF DATA SEGMENT
	CALL DNGMSG		;GET THAT MANY BYTES
	 JRST RTRSH1		;RESOURCE FAILURE, TRY NEXT CIRCUIT
	MOVE MB,T1		;SET UP MB WITH MESSAGE BLOCK POINTER
	XMOVEI T1,UD.MSD(MB)	;INITIALIZE THE USER DATA SEGMENT
	CALL DNPINI		;DO IT

	MOVX T1,NO.HEL		;GET THE NUMBER OF HELLOS IN MESSAGE
	CALL DNP1BY		;PLACE THE IMAGE COUNT IN THE MESSAGE

	MOVX T3,NO.HEL		;GET THE COUNT FOR LOOP
RTRSH2:	MOVX T1,HEL.LO		;WORD THAT GOES IN HELLO MESSSAGE
	CALL DNP1BY		;PUT ONE IN
	SOJG T3,RTRSH2		; AND DO ANOTHER ONE IF NEEDED

;Make up the router header.

	XMOVEI T1,RM.MSD(MB)	;POINT TO THE ROUTER PORTION OF MESSAGE
	CALL DNPINI		;INITIALIZE IT

	SETZ T1,		;BUILD THE BYTE IN T1
	MOVX T2,RCM.TT		;TYPE OF CONTROL MESSAGE IS TEST MESSAGE
	STOR T2,CMTYP,+T1	;PUT IN BYTE
	SETONE CMCTL,+T1	;SAY IT'S A CONTROL MESSAGE
	CALL DNP1BY		;PUT IN THE CTLFLG BYTE

	MOVE T1,RTRADR		;GET OUR LOCAL ADDRESS
	MOVE T3,RTRHOM		;GET MY AREA
	LOAD AJ,RCAJQ,(RC)	;Get the adjacency on this circuit
	TMNE AJPH4,(AJ)		;Phase IV node?
	 DPB T3,[POINTR(T1,RN%ARE)] ; AREA IF PHASE IV
	CALL DNP2BY		;PUT THE SOURCE ADDRESS IN MESSAGE

	XMOVEI T1,UD.MSD(MB)	;LINK THE USER DATA
	XMOVEI T2,RM.MSD(MB)	; TO THE ROUTER HEADER
	SETZ T3,		;DON'T CHANGE ANY POINTERS
	CALL DNLMSS		;LINK THEM

	TRACE RTR,<Sending hello message>
	CALL CALQOB		;QUEUE THE MESSAGE BLOCK
	SETZRO RCSHM,(RC)	;Indicate that we sent the hello
	JRST RTRSH1		; AND DO IT ALL AGAIN FOR THE NEXT CIRCUIT

;Here to send a hello message on a broadcast style circuit

RTREHM:	CALL DNGTIM		;Get the current time
	OPSTR <SUB T1,>,RCTLH,(RC) ;Compute time since the last hello
	CAMG T1,RTRTM2		;Has enough time elapsed?
	 JRST RTRSH1		; Nope, come back later

	SKIPGE ENFLG		; Endnode?
	 JRST RTRENH		; Yes, send endnode hello

	MOVE T1,RTNBRA		;Maximum number of Router BRA's
	ADDI T1,1		; plus one for the reserved
	IMULI T1,7		;Each one takes seven bytes
	OPSTR <CAMLE T1,>,RCBSZ,(RC) ;Will this exceed the minimum block size?
	 JRST RTREH6		;Yes, then don't do it
	CALL DNGMSG		;Get space for message
	 JRST RTRSH1		;Can't, try next circuit block
	MOVE MB,T1		;Set message pointer
	XMOVEI T1,UD.MSD(MB)	;Initialize user data segment
	CALL DNPINI
;
; Now for the 18 bytes of header
;
	SETZ T1,		;Start clean
	MOVX T2,RCM.RH		;Control message type is Router hello
	STOR T2,CMTYP,+T1
	SETONE CMCTL,+T1	;Say type is control
	CALL DNP1BY		;Write byte into message
	CALL RTRCHH		;Build common Hello header
	MOVX T1,IIT.L1		;We are a level 1 router
	CALL DNP1BY		;Write IINFO
	LOAD T1,RCRBS,(RC)	; and the blocksize we advertise
	CALL DNP2BY
	MOVE T1,RTRPRI		;Get our priority to be designated router
	CALL DNP1BY
	SETZ T1,		
	CALL DNP1BY		;Reserved byte (area)
	LOAD T1,RCTM3,(RC)	;Hello timer
	IDIVI T1,^D1000		;Convert it to seconds
	CALL DNP2BY
	SETZ T1,
	CALL DNP1BY		;Reserved (MPD)

;
; Set up E-LIST (List of Ethernet nodes we have heard from recently)
;
	CALL DNRPOS		;Get current position in the message
	STOR T1,RMMK1,(MB)	; and set mark in block
	SETZ T1,		;Reserve a byte for the count
	CALL DNP1BY
	MOVEI T1,^D7		;Write 7 reserved bytes
	CALL DNPZB
	CALL DNRPOS		;Get current position in the block
	STOR T1,RMMK2,(MB)	; and set mark in block
	CALL DNP1BY		;
	MOVEI P1,^D8		;Keep track of number written so far
	OPSTR <SKIPA AJ,>,RCAJQ,(RC) ;Pointer to adjacencies on this circuit
RTREH3:	LOAD AJ,AJNXT,(AJ)	;Step to next adjacency
	JUMPE AJ,RTREH4		;No more try next circuit
	LOAD T2,AJNTY,(AJ)	;Get adjacency's node type
	CAIE T2,ADJ.L2		;Phase IV level 2 router
	 CAIN T2,ADJ.L1		; or plain routing node?
	  TRNA
	JRST RTREH3		;Not a router, don't include it
	LOAD T2,AJSTA,(AJ)	;Get state of this adjacency
	SKIPN T2		;Valid state?
	BUG.(CHK,ROUAWS,ROUTER,SOFT,<Adjacency block in queue when state is unused>,,<

Cause:	An adjacency block has been left in the queue of active adjacencies
	but its state is unused.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.
>,RTREH3)
	LOAD T1,AJNAH,(AJ)	;Hi-order NI address
	LOAD T2,AJNAL,(AJ)	; and the low-order
	HRLZ T2,T2		;Put into string format
	CALL DNPENA		;Put ID into message
	LOAD T1,AJPRI,(AJ)	;Get adjacency's priority
	TRZ T1,200		;Set state to unknown
	LOAD T2,AJSTA,(AJ)	;Get the state of the adjacency
	CAIN T2,ADJ.UP		;Is it up?
	 TRO T1,200		; Yes, then say "known 2-way"
	CALL DNP1BY		;Write into message
	ADDI P1,7		;Account for the 7 bytes just written
	JRST RTREH3		;Check next adjacency

; Here when done with inserting routing adjacencies we know about.  Update
; counts in the message.

RTREH4:	CALL DNRPOS		;Get position at end of message
	OPSTR <EXCH T1,>,RMMK1,(MB) ;Save EOM count, get pos of 1st counter
	CALL DNGOPS		;Repostion to count
	MOVE T1,P1		;Get count
	CALL DNP1BY		;Write it
	SUBI P1,^D8		;Subtract reserved name and count
	LOAD T1,RMMK2,(MB)	;Bytes to second count
	CALL DNGOPS		;Reposition
	MOVE T1,P1		;Get second adjusted count
	CALL DNP1BY		;Write it
	LOAD T1,RMMK1,(MB)	;Get pointer to end of message
	CALL DNGOPS		;Point to the true end of the message
	TMNN RCDSR,(RC)		;[7480]Are we the designated router?
	IFSKP.
	  SETONE RMDRM,(MB)	;Yes, set flag so we resend to "all-endnodes"
	ENDIF.
	TRACE RTR,<Sending Ethernet router hello message>
	DMOVE T1,RTRALR		;Send to "ALL-ROUTERS"
	CALL RTRSNI		;Queue this message

;Send one to all-endnodes

RTREH6:	SETZRO RCSHM,(RC)	;We have sent the Hello
	CALL DNGTIM		;Time stamp
	STOR T1,RCTLH,(RC)	; Bamm!
	JRST RTRSH1		; and onto the next circuit


	SUBTTL RTRENH - Send Ethernet end-node hello

RTRENH:	CALL DNGTIM		;Get the current time
	OPSTR <SUB T1,>,RCTLH,(RC) ;Compute time since the last hello
	CAMG T1,RTRTM2		;Has enough time elapsed?
	 JRST RTRSH1		; Nope, come back later
	MOVEI T1,<NO.NIH+^D32>	;Number of bytes for hello message
	CALL DNGMSG		;Get space for message
	 JRST RTRSH1		;Can't, try next circuit block
	MOVE MB,T1		;Set message pointer
	XMOVEI T1,UD.MSD(MB)	;Initialize user data segment
	CALL DNPINI
;
; Now for the 18 bytes of header
;
	SETZ T1,		;Start clean
	MOVX T2,RCM.EH		;Control message type is Endnode hello
	STOR T2,CMTYP,+T1
	SETONE CMCTL,+T1	;Say type is control
	CALL DNP1BY		;Write byte into message
	CALL RTRCHH		;Build common Hello header
	MOVX T1,IIT.EN		;We are an ethernet endnode
	CALL DNP1BY		;Write IINFO
	LOAD T1,RCRBS,(RC)	;Get the blocksize we will advertise
	CALL DNP2BY
	SETZ T1,		
	CALL DNP1BY		;Reserved byte (area)
	MOVEI T1,^D8		;Write 8 bytes of zeros for the seed
	CALL DNPZB
	LOAD T1,RCDSH,(RC)	;Address of the designated router
	LOAD T2,RCDSL,(RC)	; we believe exists
	LSH T2,^D18		;Position as a string
	CALL DNPENA
	LOAD T1,RCTM3,(RC)	;Hello timer
	IDIVI T1,^D1000		;Convert it to seconds
	CALL DNP2BY
	SETZ T1,
	CALL DNP1BY		;Reserved 
	MOVX T1,NO.NIH		;Send NO.NIH bytes of test message
	CALL DNP1BY		;Place the image count in the message
	MOVX T3,NO.NIH		;Get the count for loop
RTREN2:	MOVX T1,HEL.LO		;Word that goes in hello messsage
	CALL DNP1BY		;Put one in
	SOJG T3,RTREN2		; and do another one if needed
	TRACE RTR,<Sending Ethernet endnode hello message>
	DMOVE T1,RTRALR		;Send to "all-routers"	
	CALL RTRSNI		;Queue this message

	SETZRO RCSHM,(RC)	;We have sent the Hello
	CALL DNGTIM		;Time stamp
	STOR T1,RCTLH,(RC)	; Bamm!
	JRST RTRSH1		; and onto the next circuit

	SUBTTL RTRCHH - Build common part of Ethernet hellos

RTRCHH:
	MOVE T1,RTRVER		;Version number of ROUTER
	CALL DNP1BY		;Stuff it
	SETZ T1,		;ECO # and User ECO # are 0
	CALL DNP2BY		;Stuff them
	MOVE T1,RTRHIO		;High order
	MOVE T2,RTRLOO		; and low order
	CALL DNPENA		;Write the address into the message
	RET
	SUBTTL DSRCHK - Check the DSR timer for each circuit

DSRCHK:	TMNN RCBCT,(RC)		;If not broadcast, we don't care
	 RET
	LOAD T1,RCDRT,(RC)	;Is "wait to be DSR" timer running
	 JUMPE T1,RTN		;If not just exit
	SOJG T1,DSRCK1		;Count down the timer
	SETONE RCDSR,(RC)	; and if it expires set the DSR flag
DSRCK1:	STOR T1,RCDRT,(RC)	;Save the new value
	RET

	SUBTTL Data Link Layer Interface
	SUBTTL Data Link Layer Interface -- RTRDLE - Entry into Router from DLL
; Call: 
;	T1/ Function Code
;	T2/ Router Circuit Block Address (except if DI.CCB)
;	T3/ Data (ususally pointer to message block)
;	T4/ Additional data
;
; Return: 
;	RET			;Always
;
; Uses: T1-T4
;
;We simply check the arguments, set up some arguments for the routines
;which handle the functions and dispatch to those routines.
;
;Note that we decide what to do if DECnet is not running at each
;individual interrupt handler.  For example if DECnet is turned off
;between the buffer request and the input done, we could have problems.
;We do not accept and new buffer requests or protocol ups once DECnet
;has been turned off.

	INTERN RTRDLE
	XRESCD

RTRDLE:
IFN FTPARANOIA,<
	CAXL T1,DI.ODN		;RANGE CHECK THE
	 CAXLE T1,DI.ICB	; FUNCTION CODE
	  BUG.(CHK,ROUIFD,ROUTER,SOFT,<Illegal function code from the DLL>,,<

Cause:	The module DNADLL and ROUTER get their function code from the D36PAR.
	They must have been compiled from different UNVs.

Action:	Compile from the same D36PAR.UNV.
>,RTN)
> ;END IFN FTPARANOIA
	SAVEAC <MB,MS,RC,AJ,P1,P2,Q1,Q2>    ;SAVE SOME AC'S
	STKVAR <DSPWRD>		; Place to save word from dispatch table
	MOVE RC,T2		;GET THE ROUTER CIRCUIT BLOCK
	MOVE P1,RTRDTB-1(T1)	;GET BITS AND DISPATCH FOR THIS FUNCTION.
	HRRM T1,DSPWRD		; Save function in case can't dispatch
	HLLM P1,DSPWRD		; Save function flags

RTRDS2:	TXZN P1,RD.CMB		;SHOULD I CHECK FOR A VALID MB?
	JRST RTRDS4		;NO, THIS FUNCTION DOESN'T HAVE AN MB.
	SKIPN MB,T3		;COPY THE MB
RTRDS3:	BUG.(CHK,ROUBMB,ROUTER,SOFT,<Bad message block pointer>,,<

Cause:	DNADLL has called RTRDLE with a function requiring a message
	block, and the pointer supplied (in T3) is either 0 or out of
	range.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.  Determine why DNADLL gave a 
	bogus pointer since it originally should have obtained it from 
	the monitor.
>,RTRDS9)
IFN FTPARANOIA,<
	CALL DNCHMB##		;ASK D36COM TO CHECK THIS POINTER FOR US
	JRST RTRDS9		;BAD POINTER, FORGET THIS REQUEST.
> ;END IFN FTPARANOIA
RTRDS4:	TXZN P1,RD.CKS		;SHOULD WE CHECK DECNET/CIRCUIT STATE?
	JRST RTRDS6		;DON'T WORRY ABOUT STATE
	MOVE T1,DCNSTA		;Get DECnet state
	CAIE T1,DS.ON		;Is it on?
	 JRST RTRDS7		;NO, RETURN NOW.
	LOAD T2,RCSTA,(RC)	;GET THE CIRCUIT STATE
	CAXE T2,RCS.OF		;If state is off
	 CAXN T2,RCS.RJ		; or rejected
	  TRNA
RTRDS6:	CALLRET (P1)		;NO, CALL APPROPRIATE ROUTINE AND RETURN

RTRDS7:	MOVE P1,DSPWRD		; Recover dispatch flags
	TXNE P1,RD.CMB		; Does this function have an MB?
	 CALL FREMSG		; Yes, dispose of it properly, MB = message
	TLZ P1,-1		; Remove flags
	CAIE P1,DI.ODN		; If output done then...
	 JRST RTRDS9
	DECR RCCMQ,(RC)		;  message no longer queued to the DLL
RTRDS9:	SETZ T1,		;MAKE SURE THAT THE REQUESTOR UNDERSTANDS
	RET			; THAT THE REQUEST FAILED


RD.CRC==1B0			;CHECK RC. MAKE SURE IT IS NON-ZERO, AND IF
				; FTPARANOIA, RANGE CHECK AND FIND ON RTRCBQ
RD.CMB==1B1			;CHECK MB. MAKE SURE IT IS NON-ZERO, AND IF
				; FTPARANOIA, CALL DNCHFB TO ENSURE IT IS GOOD.
RD.CKS==1B2			;CHECK STATES BEFORE CALLING. IF EITHER DECNET
				; OR LINE STATE IS OFF, SIMPLY ZERO T1 AND


				; RETURN.

RTRDTB:	RD.CRC+RD.CKS+RD.CMB+RTIOTC	;OUTPUT DONE
	RD.CRC+RD.CKS+RD.CMB+RTIINC	;INPUT COMPLETE
	       RD.CKS+RD.CRC+RTILSC	;LINE STATE CHANGE
			     RTICCB	;CREATE CIRCUIT

	SUBTTL Data Link Layer Interface -- RTICCB - Create circuit block

;RTICCB - Create a circuit block
;
; Call:
;	T2/ Data Link Block address
;	T3/ Line-ID
;	T4/ Blocksize to advertise for this circuit
;
;	We can not get here if the circuit state is OFF
;
; Return:
;	RET			;Always, returns with T1 containing circuit
;				; block address or zero if it couldn't
;				; allocate a new one
;
; Uses: T1-T4
;

RTICCB:	DMOVE P1,T2		; Save DLB and line ID
	MOVE Q1,T4		;  and blocksize
	MOVE T1,P2		; Get the LINE-ID
	SKIPN ENFLG		; Endnode?
	IFSKP.			; Yes
	  LOAD T2,LIDEV,+T1	; Then get the device type on this line
	  CAIE T2,LD.NI		; Is it an ethernet?
	   JRST RTRCCE		; No, then don't initialize with it
	ENDIF.
	CALL RTRMCB		; Make up the circuit block
	 JRST RTRCCE		;  and return if can't allocate memory
	MOVE RC,T1		; Circuit block pointer we got.
	STOR P1,RCDLB,(RC)	; Save data link block address for later calls
	STOR Q1,RCRBS,(RC)	;  and maximum blocksize we can advertise
	ENDQUE RC,RTRCBQ,RC.NXT,T1 ; Add circuit block to queue
	JN RCBCT,(RC),RTRCC1	; If broadcast don't make adjacency block
	JN RCAJQ,(RC),RTRCC1	; If we have an adjacency block don't make one
	SETO T1,		; Flag to indicate we expect routing adjacency
	CALL RTRMAJ		; Make up the adjacency block
	 JRST RTRCCE		; Error return
RTRCC1:	MOVE T1,RC		; Return circuit block address as callback ID
	RET

RTRCCE:	SETZ T1,		; Indicate failure
	RET

	SUBTTL Data Link Layer Interface -- RTILSC - Process line state change

; RTILSC - "Line state change" interrupt from the DLL
; 
; Call:
;	T2/ Circuit block address
;	T3/ New Line State
;
; Return:
;	RET			;ALWAYS
;
; Uses:

RTILSC:	TRACE RTR,<Received line state change from DLL>
	CAIE T3,LS.OFF		; Is new state off?
	 JRST RTION		; No, must be on

RTIDWN:	MOVX T1,RS.LSL		;EVENT REASON: CIRCUIT SYNCHRONIZATION LOST
;*** Was it ever up ?? No event if not
	CALL RTELDL		;REPORT CIRCUIT DOWN - CIRCUIT FAULT EVENT
	CALL RTRZCB		;CLEAN OUT THE CIRCUIT BLOCK
	CALL RTRSAO		;SET ANY REMAINING ADJACENCIES TO UNUSED
	SETOM RTRRCF		;SET RECOMPUTE TOPOLOGY FLAG
	LOAD T1,RCSTA,(RC)	;Get current state
	MOVX T2,RCS.FA		; Failed state code
	CAIG T1,RCS.RJ		; If off/rejected, don't change state
	IFSKP.
	  STOR T2,RCSTA,(RC)	;STORE AS CURRENT STATE FOR THIS CIRCUIT
	  TMNN RCBCT,(RC)	;If broadcast, then close portal
	  IFSKP.
	    CALL R2KCLS		;Close it
	    CALL DNGTIM		;Get current uptime
	    ADDI T1,^D1000	;Wait a second
	    STOR T1,RCTIN,(RC)	; to reopen the portal
	  ENDIF.
	ENDIF.
	RET

RTION:	LOAD T2,RCSTA,(RC)	;GET CIRCUIT STATE
	CAIN T2,RCS.RN		; Are we already on?
	 RET			; Yes, ignore notification	 
	CAIE T2,RCS.WT		;MAKE SURE WE'RE IN WAITING STATE
	 CAIN T2,RCS.FA		; or failed
	  TRNA
	JRST [ETRACE RTR,<Line state to ON rcv'd in wrong state>
	      CALLRET CIRFAI]	;TRY TO REINITIALIZE THE CIRCUIT
	LOAD T2,RCLID,(RC)	;Get the line-id for the event
	EVENT RE.LUP,<Circuit up> ;Generate the event
	TMNN RCBCT,(RC)		; Is this a broadcast circuit?
	IFSKP.
	  MOVX T1,RCS.RN	; The circuit state is run
	  STOR T1,RCSTA,(RC)	;
	  SETONE RCSHM,(RC)	; Send a hello message to start things off
	ELSE.
	  MOVX T1,RCS.TI	;NEW STATE = TRANSPORT INITIALIZATION WAIT
	  STOR T1,RCSTA,(RC)	;STORE THE NEW CIRCUIT STATE
	  CALL RTRSTI
	ENDIF.
	RET

	SUBTTL Data Link Layer Interface -- RTIOTC - Process Output Complete

;RTIOTC - Routine to process output complete interrupt
;
; Call: 
;	RC/ Circuit block address
;	T3/ Message block address
;	T4/ Status
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1-T3

RTIOTC:	TRACE RTR,<Output Complete>
	MOVE MB,T3		;GET THE MESSAGE BLOCK ADDRESS
	MOVE T1,MB		;ARG FOR DNLENG
	CALL DNLENG		;FIGURE OUT THE LENGTH OF THE MESSAGE
	DECR RCCMQ,(RC)	 	;DECREMENT MESSAGES QUEUED COUNT

	CALL DNGTIM		;Get the current time
	STOR T1,RCTLS,(RC)	;Update time last sent.  It is ok to do this on
				; ethernets for "all-routers & "all-endnodes"
				; since they use TLH for the "talker" process.
	TMNN RMDRM,(MB)		;Should this be resent to "all-endnodes"?
	IFSKP.
	  SETZRO RMDRM,(MB)	;Yes, but resend it only once
	  DMOVE T1,RTRAEN	;Set "all-endnodes" address
	  CALLRET RTRSNI	
	ENDIF.
	TMNN RMICP,(MB)		;Is this from the local node?
	IFSKP.
	  INCR RCCTS,(RC)	;No, increment the transit count
    IFN FTRTST,<
	  MOVEI P1,TSTBLK
	  CALL TSTTIM
	  STOR T1,TRTOC,(P1)
	  LOAD T2,TRTAF,(P1)
	  SUB T1,T2
	  STOR T1,TRTFD,(P1)
    >
	  CALLRET FREMSG	;  and discard the packet
	ENDIF.
	INCR RCCLC,(RC)		;OTHERWISE, INCREMENT THE LOCAL COUNT
	CALLRET FREMSG		;GIVE PACKET TO BACK TO NSP, OR FREE IT

	SUBTTL Data Link Layer Interface -- RTIINC - Process Input Complete

;RTIINC - Process input complete interrupt
;
; Call: 
;	RC/ Circuit block pointer
;	T3/ Pointer to message block
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1-T3

RTIINC:	TRACE RTR,<Input Complete>
	MOVE MB,T3		;GET POINTER TO MESSAGE BLOCK
	STOR RC,RMICP,(MB)	;STORE THE INPUT CIRCUIT ADDRESS

;****************************************
	TORESCD
RTRITR::TRN			;Label for DNSNUP to find input messages
	TOXRESCD
;****************************************
	LOAD AJ,RCAJQ,(RC)	;Get first adjacency in queue
	JE RCBCT,(RC),RTRIN4	;If point-to-point be satisfied with it
	LOAD T1,MBSRC,(MB)	;Yes, get address of sender
	CALL RTRGAJ		;Look for adjacency with this address...
	 SETZ AJ,		;[7397]Not in our area, clear AJ
RTRIN4:	STOR AJ,RMIAP,(MB)	; and store it for the forwarding routine
	SETZRO RMOAP,(MB)	;SO WE DON'T CONFUSE OURSELVES
	SETZRO RMOCP,(MB)

	MOVE T1,MB		;COPY POINTER TO MESSAGE BLOCK
	CALL DNLENG		;SIZE OF THIS MESSAGE
	SKIPGE ENFLG		;Endnode?
	IFSKP.
	  CALL DNGTIM		; NO, GET THE CURRENT TIME
	  SKIPE AJ		; Skip if this adjacency is not initialized
	  STOR T1,AJTLR,(AJ)	;STORE TIME WE LAST HEARD FOR NEIGHBOR
	ENDIF.
	CALL RTRHDP		;PARSE THE HEADER
	 JSP T1,RTEMFE		;REPORT THE MESSAGE FORMAT ERROR EVENT
	JE RMCTL,(MB),RTIIN1	;IF IT'S A DATA MESSAGE, PROCESS IT

;We have a control message here, find the type and dispatch

	LOAD T1,RCSTA,(RC)	;GET THE CIRCUIT'S STATE
	LOAD T2,RMCTY,(MB)	;GET THE CONTROL MESSAGE TYPE
	CALL @RTIIND(T2)	; AND DISPATCH ON THAT TYPE
	RET			;RETURN TO SENDER

RTIIND:	IFIW <RTCINI&777777>	;ROUTER INITIALIZATION (0)
	IFIW <RTCVER&777777>	;ROUTER VERIFICATION (1)
	IFIW <RTCTST&777777>	;ROUTER TEST MESSAGE (2)
	IFIW <RTCRTE&777777>	;ROUTER ROUTING MESSAGE (3)
	IFIW <RTCL2M&777777>	;ROUTER LEVEL 2 ROUTING MESSAGE (4)
	IFIW <RTCERH&777777>	;NI ROUTER HELLO MESSAGE (5)
	IFIW <RTCNIE&777777>	;NI ENDNODE HELLO MESSAGE (6)
	IFIW <RTCILL&777777>	;Illegal message type

;Here with a data message.

RTIIN1:
IFN FTRTST,<
	LOAD T1,MBSRC,(MB)		; Get source node
	LOAD T2,MBDST,(MB)		;  and destination
	CAMN T1,T2			; The same?
	 JRST [SETONE RMTST,(MB)	; Yes, assume this is a test message
	       MOVEI P1,TSTBLK		; Get address of test data block
	       LOAD T1,TRTND,(P1)	; Get the loop node address
	       STOR T1,MBDST,(MB)	; Save that as the destination
	       CALL TSTTIM		; Get the uptime in ms.
	       STOR T1,TRTIC,(P1)	; Save it as time received here
	       LOAD T2,TRTAF,(P1)	;
	       SUB T1,T2		; Compute elapsed time
	       STOR T1,TRTTA,(P1)	; Save for interested parties
	       CALL TSTTIM		; Get time again
	       STOR T1,TRTAF,(P1)	;  and save it as time at RTRFWD
	       JRST .+1]
>
	TMNE MBEBF,(MB)		;IS THIS MESSAGE IN AN EMERGENCY BUFFER?
	JRST RTIINF		;YES, HANDLE IT DIFFERENTLY

RTIIN2:	LOAD T1,RCSTA,(RC)	;GET THE STATE OF THE CIRCUIT
	CAIE T1,RCS.TT		;SEE IF THIS IS A GOOD STATE TO BE IN
	CAIN T1,RCS.RN		; FOR RECIEVING DATA
	TRNA			;WE SEEM TO BE OK
	JRST [ETRACE RTR,<Circuit in wrong state for forwarding>
	      CALLRET FREMSG]
	CALLRET RTRFWD		;FORWARD THE MESSAGE


;Here to discard an arriving packet due to congestion.

RTIINF:	OPSTR <SKIPGE T2,>,MBDST,(MB) ;GET THE DESTINATION
	 CALLRET RTRFOR		;DESTINATION IS OUT-OF-RANGE
	LDB T2,[POINTR(T2,RN%NOD)] ;GET THE NODE NUMBER
	CAMLE T2,RTRMXN		;RANGE CHECK IT
	 CALLRET RTRFOR		;DESTINATION IS OUT-OF-RANGE
	ADD T2,RTRNRV		;GET THE NODE'S ROUTING VECTOR ENTRY
	TMNE RNLCL,(T2)		;IF IT WAS SUPPOSED TO COME TO US
	IFSKP.
	  INCR RCCAL,(RC)	;REPORT IT AS ARRIVED CONGESTION LOSS
	ELSE.
	  INCR RCCTL,(RC)	; else increment the transit congestion loss
	ENDIF.
	CALLRET FREMSG		;FREE MSG BLK & RETURN

	SUBTTL RTRSTI - Send routing intitialization message

RTRSTI:	MOVX T1,TI.MXL		;MAX LENGTH OF A TI MESSAGE
	CALL DNGMSG		; USER MESSAGE AREA
	 CALLRET CIRFAI		;CAN'T DO IT, Close the port and try again
	MOVE MB,T1		;MAKE MB POINT TO MESSAGE
	XMOVEI T1,UD.MSD(MB)	;POINT TO THE USER-DATA MSD
	CALL DNPINI		;INITIALIZE MS & THE MSD

	SETZ T1,		;MAKE UP FIRST BYTE IN T1/ 0
	SETONE CMCTL,+T1	;TURN ON THE CONTROL MESSAGE BIT
	MOVX T2,RCM.TI		;TYPE IS ROUTER INIT
	STOR T2,CMTYP,+T1	;AND STORE THAT IN THE TYPE FIELD
	CALL DNP1BY		;WRITE THE FIRST BYTE

	LOAD AJ,RCAJQ,(RC)	;GET THE ADJACENCY
	JUMPE AJ,CIRFAI		;If we don't have one reinitialize
	MOVE T1,RTRADR		;GET OUR ADDRESS
	MOVE T2,RTRHOM		;GET MY AREA
	LOAD T3,RCLID,(RC)	;Get circuit identifier
	LOAD T3,LIDEV,+T3	;Get line type
	CAIE T3,LD.DTE		;If DTE don't include the area number
	 DPB T2,[POINTR(T1,RN%ARE)]
	CALL DNP2BY		;STORE THE NODE ADDRESS
	
;Build TIINFO.

	SETZ T1,		;START BUILDING TIINFO FIELD
	MOVEI T2,ANT.RT		; Assume we are a routing node
	MOVEI T3,RNT.L1		; See what type of node we are this time
	CAME T3,RTRNTY		; Are we a routing node?
	 MOVEI T2,ANT.NR	; No, then say we are non-routing
	STOR T2,TINTY,+T1	;STORE THE NODE TYPE
	TMNE AJVRQ,(AJ)		;IS VERIFICATION REQUIRED?
	TXO T1,TIVER		;YES, TELL HIM ABOUT IT
	CALL DNP1BY		;PUT THE BYTE IN

;Give a blocksize.

	LOAD T1,RCRBS,(RC)	;GET THE BLOCKSIZE
	CALL DNP2BY		;TWO BYTES WORTH

;Fill in version, etc.

	LOAD T1,AJVER,(AJ)	;GET THE ADJACENCY ROUTING VERSION
	CAMN T1,RTRVER		;IS IT THE SAME AS OURS?
	 JRST FILVER		;YES, THEN FILL IN THE VERSION NUMBER
	ADDI T1,1		;SEE IF ITS ONE MINUS OURS
	CAMN T1,RTRVER		;IS IT?
	 JRST [LOAD T1,AJVER,(AJ) ;THEN USE HIS VERSION NUMBER
	       JRST FILVR1]	;STORE IN THE MESSAGE

FILVER:	MOVE T1,RTRVER		;VERSION OF RTR
FILVR1:	CALL DNP1BY		;PUT IT IN MESSAGE
	LOAD T1,AJECO,(AJ)	;GET THE ECO LEVEL
	CALL DNP1BY		;PUT IT IN, ALSO

	MOVE T1,RTRCUS		;CUSTOMER ARGUMENT NUMBER
	CALL DNP1BY		;AND STORE THAT ALSO

;Now for the HELLO timer

	LOAD T1,RCTM3,(RC)	;GET TIMER VALUE FOR THIS CIRCUIT
	IDIVI T1,^D1000		;SEND TIMER AS SECONDS
	CALL DNP2BY		;TWO BYTES WORTH

;Now fill in one reserved byte

	SETZ T1,		;USE A ZERO
	CALL DNP1BY		;PUT IN THE BYTE

;Here we give the message to the DLL to send.

	TRACE RTR,<Sending Router Init message>
	CALL CALQOB		;OUTPUT THE MESSAGE
	CALL DNGTIM		;GET THE CURRENT TIME
	STOR T1,RCTIN,(RC)	;RECORD THE TIME THAT WE SENT THE TI
	RET

	SUBTTL Control Message Processors -- RTCINI - Inititialization Messages

;RTCINI - Process Incoming Router Init Message
;
; Call: 
;	T1/ Circuit State
;	RC/ Ptr to Circuit Block
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1-T4

RTCINI:	TRACE RTR,<Processing Router Init message>
	CAIE T1,RCS.TI		;ARE WE IN RTR INIT WAIT STATE?
	JRST [ETRACE RTR,<RTR Init message rcvd in wrong state>
	      MOVX T1,RS.UPT	;EVENT REASON: UNEXPECTED PACKET LOSS
	      CALLRET RTELDS]	;REPORT THE CIRCUIT DOWN - SOFTWARE FAULT EVENT
	LOAD T1,MBSRC,(MB)	;GET THE SOURCE NODE
	LDB T2,[POINTR(T1,RN%ARE)] ;GET THE AREA NUMBER
	LDB T1,[POINTR(T1,RN%NOD)] ;GET THE NODE NUMBER
	SKIPN T2		; If Phase III...
	 MOVE T2,RTRHOM		;  then default the area
	CAME T2,RTRHOM		;MY AREA?
	 JRST RTCNHA		;NO, THEN DON'T DO IT
RTCI9N:	CAIL T1,1		;CHECK NODE ADDRESS
	CAMLE T1,RTRMXN		; FOR REASONABLENESS
RTCNHA:	JRST [MOVX T1,RS.ANO	;REASON: ADJACENT NODE ADDRESS OUT OF RANGE
	      CALLRET RTEINO]	;REPORT THE INITIALIZATION FAILURE EVENT

	STOR T1,AJNAN,(AJ)	;Store the node's number
	STOR T2,AJNAA,(AJ)	; and node's area

	MOVX T1,ADJ.UP		;SAY THE ADJACENCY IS NOW UP
	STOR T1,AJSTA,(AJ)

	MOVE T1,MB		;POINT TO INPUT MESSAGE
	CALL DNLENG		;CALCULATE THE LENGTH
	CAIL T1,^D6		;IS IT THE CORRECT LENGTH FOR RTR INIT MSGS?
	 CALL DNG1BY		;GET THE INITINFO FIELD
	  JSP T1,RTEMFE		;++MESSAGE FORMAT ERROR
;	TXNE T1,TIRSV		;IS THE RESERVED FIELD ZERO?
;	 JSP T1,RTEMFE		;++MESSAGE FORMAT ERROR EVENT

	MOVX T2,AJVRQ		;GET THE VERFIFY AND REQUIRED BIT
	ANDCAM T2,AJ.VRQ(AJ)	;ASSUME THAT VERIFICATION ISN'T REQUIRED
	TXNE T1,TIVER		;IS IT REALLY REQUIRED?
	 IORM T2,AJ.VRQ(AJ)	;YES, SET IT

	MOVX T2,AJBLO		;GET THE BLOCKING REQUESTED BIT
	ANDCAM T2,AJ.VRQ(AJ)	;ASSUME THAT BLOCKING WAS NOT REQUESTED
	TXNE T1,TIBLO		;BLOCKING REQUESTED?
	 IORM T2,AJ.VRQ(AJ)	;YES, THEN SET IT

	LOAD T2,TINTY,+T1	;GET NODE TYPE FROM BYTE
	STOR T2,AJNTY,(AJ)	;STORE THE NODE TYPE IN CIRCUIT BLOCK
  ;Get the blocksize

	CALL DNG2BY		;GET TWO BYTE BLOCKSIZE
	 JSP T1,RTEMFE		;++MESSAGE FORMAT ERROR EVENT
	CAMGE T1,RTRBSZ		;IS THE BLOCKSIZE REASONABLE
	JRST [MOVX T1,RS.ABS	;EVENT REASON: Adjacency block size too small
	      CALLRET RTEINO]	;REPORT THE INITIALIZATION FAILURE EVENT
	STOR T1,RCBSZ,(RC)	;Save for use when building routing updates
	STOR T1,AJBSZ,(AJ)	; and here for network management

;Next comes the Version number, ECO number and Customer args.

	CALL DNG1BY		;GET THE VERSION NUMBER
	 JSP T1,RTEMFE		;++MESSAGE FORMAT ERROR EVENT
	STOR T1,AJVER,(AJ)	;STORE IN IN CIRCUIT BLOCK
	CAIE T1,1		;IS THE ADJACENCY PHASE III OR IV?
	IFSKP.
	  LOAD T2,AJNTY,(AJ)	;(III) GET THE NODE TYPE FROM ABOVE (TIINFO)
	  SETO T1,		;Use T1 to hold node type for adjacency block
	  CAIN T2,ANT.RT	;IS IT A ROUTING NODE?
	   MOVX T1,ADJ.3F	;YUP, MUST BE A PHASE III FULL NODE
	  CAIN T2,ANT.NR	;IS IT A NON-ROUTING NODE?
	   MOVX T1,ADJ.3S	;YES, WELL ITS A PHASE III SMALL NODE
	  SKIPGE T1		;DID WE GET ONE?
	   JSP T1,RTEMFE	;++MESSAGE FORMAT ERROR EVENT
	  STOR T1,AJNTY,(AJ)	;SAVE IT
	  SETZRO AJPH4,(AJ)	;Note that this node is not a PH4 node
	ELSE.
	  LOAD T2,AJNTY,(AJ)	; (IV) GET THE NODE TYPE FROM ABOVE (TIINFO)
	  SETO T1,		;Use -1 as a flag
	  CAXN T2,ANT.L1	;IS IT A LEVEL 1 ROUTER
	   MOVX T1,ADJ.L1	;SAY SO
	  CAXN T2,ANT.L2	;LEVEL 2
	   MOVX T1,ADJ.L2	;SAY SO
	  CAXN T2,ANT.NR	;NON-ROUTING
	   MOVX T1,ADJ.LN	;SAY SO
	  SKIPGE T1		;HAVE ONE?
	   JSP T1,RTEMFE	;NO, THEN WE HAVE AN ERROR
	  STOR T1,AJNTY,(AJ)	;SAVE IT
	  SETONE AJPH4,(AJ) 	;Indicate we have a Phase IV node
	ENDIF.

RTCIN0:	CALL DNG1BY		;GET THE ECO NUMBER
	 JSP T1,RTEMFE		;++MESSAGE FORMAT ERROR EVENT
	STOR T1,AJECO,(AJ)	;STORE IT
	CALL DNG1BY		;ALSO THE CUSTOMER ARGUMENT
	 JSP T1,RTEMFE		;++MESSAGE FORMAT ERROR EVENT
	STOR T1,AJCUS,(AJ)	;STORE IT ALSO

; Get the hello timer from the router init message, there is one

	TMNN AJPH4,(AJ)		;Phase IV node?
	 JRST RTCIN1		;NO, THEN HELLO TIMER IS NOT THERE
	CALL DNG2BY		;GET THE HELLO TIMER NOW
	 JSP T1,RTEMFE		;MESSAGE FORMAT ERROR+++
	IMULI T1,%RTT3M*^D1000	;Hello timer multiplier and convert to ms.
	STOR T1,AJNHT,(AJ)	;SAVE AS NEIGHBOR'S HELLO TIMER

;Now we have read the whole message, next send a verification if necessary.

RTCIN1:	CALL DNG1BY		;Now get the reserved field
	 JSP T1,RTEMFE		;None, bum message
	SKIPE T1		;It must be zero
	 JSP T1,RTEMFE		;We can't understand non-zero
	TMNE AJVRQ,(AJ)		;DOES HE WANT VERIFICATION?
	IFSKP.			; No, he doesn't
	  SETZRO RCTIN,(RC)	;ZERO THE TIME WE SENT TI TIMER
	  CALL FREMSG		; FREE MESSAGE
	ELSE.
	  MOVE T1,MB		;PASS PTR TO MSG BLK TO DNMINI
	  SETZ T2,		;ZERO LENGTH USER DATA SPACE FOR PSWD
	  CALL DNMINI		;FIX UP THE MSG BLK
	   RET			;PROPOGATE ERROR RETURN
	  XMOVEI T1,RM.MSD(MB)	;GET ADDR OF ROUTER MSD
	  CALL DNPINI		;GET READY TO STICK BYTES IN MESSAGE

	  SETZ T1,		;BUILD FIRST BYTE IN T1
	  MOVX T2,RCM.TV	;TYPE = ROUTER VERIFICATION
	  STOR T2,CMTYP,+T1	;FILL IN FIELD IN AC
	  SETONE CMCTL,+T1	;TV MESSAGE IS A CONTROL MESSAGE
	  CALL DNP1BY		;STORE IN MESSAGE

	  MOVE T1,RTRADR	;GET OUR (ROUTER'S) ADDRESS
	  MOVE T3,RTRHOM	;GET MY AREA
	  TMNE AJPH4,(AJ)	;Phase IV node?
	   DPB T3,[POINTR(T1,RN%ARE)] ; AREA IF PHASE IV
	  CALL DNP2BY		;STORE THAT

;Put a zero length password at the end of the verification msg

	  SETZ T1,		;MAKE A ZERO COUNT FIELD
	  CALL DNP1BY		;TELL MSG ABOUT IT

	  TRACE RTR,<Sending Router Verification message>
	  CALL CALQOB		;OUTPUT THE MESSAGE

	  CALL DNGTIM		;GET CURRENT TIME
	  STOR T1,RCTIN,(RC)	;REGISTER THE TIME THAT WE SENT THE TV
	ENDIF.

;	MOVX T1,RCS.TV		;ASSUME THAT WE REQUIRE VERIFICATION
;	SKIPN RTRVRQ		;DO WE REQUIRE VERIFICATION?
	MOVX T1,RCS.RN		;NO, WE'RE NOW IN RUN STATE
	STOR T1,RCSTA,(RC)	;INDICATE THAT IN THE CIRCUIT BLOCK
	MOVX T1,ADJ.UP		;SAY THE ADJACENCY IS UP NOW
	STOR T1,AJSTA,(AJ)	; AND RUNNING
	LOAD T2,RCLID,(RC)	;Get the device ID
	LOAD T3,AJADR,(AJ)	;Address needed for the event
	EVENT RE.AUP,<Adjacency up>
	SETOM RTRRCF		;Recompute routing
	MOVN T1,RTRTM1		;Reset the time of last routing
	STOR T1,RCTLR,(RC)	; message
	RET			; AND RETURN

	SUBTTL Control Message Processors -- RTCVER - Verification Messages

;RTCVER - Routine to handle verification messages
;
; Call: 
;	T1/ Circuit State
;	RC/ Pointer to Circuit Block
;	MB/ Pointer to Message Block
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1-T4

RTCVER:	TRACE RTR,<Processing Router Verification message>
	CAIE T1,RCS.TV		;ARE WE WAITING FOR A VERIFICATION
	JRST [ETRACE RTR,<RTR Verification message rcvd in wrong state>
	      MOVX T1,RS.UPT	;EVENT REASON: UNEXPECTED PACKET type
	      CALLRET RTELDS]	;REPORT CIRCUIT DOWN - SOFTWARE ERROR EVENT
	CALL DNG1BY		;GET FIRST BYTE (IMAGE COUNT)
	 JSP T1,RTEMFE		;++MESSAGE FORMAT ERROR EVENT
	MOVE P1,T1		;PRESERVE IT FOR A WHILE
	MOVE T1,MB		;POINT TO MESSAGE
	CALL DNLENG		;CALCULATE LENGTH
	CAMLE P1,T1		;DOES IT LOOK LIKE A REASONABLE LENGTH?
	CALLRET RTEVRJ		;++VERIFICATION REJECT

	MOVX T1,RCS.RN		;IF WE GOT THIS FAR,
	STOR T1,RCSTA,(RC)	; WE DESERVE TO BE IN A GOOD STATE
	CALLRET FREMSG		;TOSS MESSAGE AND RETURN
	SUBTTL Control Message Processors -- RTCRTE - Routing Messages

;RTCRTE - Routine to handle incoming routing message
;
; Call: 
;	T1/ State of circuit
;	AJ/ Pointer to adjacency block
;	RC/ Pointer to circuit block
;	MB/ Pointer to message block
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1-T4

RTCRTE:	TRACE RTR,<Processing Routing message>
	CAIE T1,RCS.TT		;CHECK OUR STATE FOR EITHER TEST OR
	CAIN T1,RCS.RN		; OK STATE
	TRNA			;WE SEEM ALRIGHT
	JRST [ETRACE RTR,<Routing message rcvd in wrong state>
	      MOVX T1,RS.UPT	;EVENT REASON: UNEXPECTED PACKET RECEIVED
	      CALLRET RTELDS]	;REPORT CIRCUIT DOWN - SOFTWARE FAULT EVENT
	SKIPN ENFLG		; Endnode?
	IFSKP.
	  CALL DNG1BY		; Get reserved byte	  
	   CALLRET FREMSG	; Forget any error
	  LOAD T1,MBSRC,(MB)	; Get the source address
	  LDB T2,[POINTR (T1,RN%ARE)] ; Get the area number
	  LDB T3,[POINTR(T1,RN%NOD)] ; Get the node number
	  LOAD T4,RCAJQ,(RC)
	  LOAD T4,AJNAN,(T4)	; Get DSR low order address
	  CAIE T3,(T4)		; Same as the sender of message?
	   JRST FREMSG		; No, then don't bother processing
	  SKIPN T2		; Phase IV area number there?
	   CALLRET FREMSG
	  CAME T2,RTRHOM	; Is packet from our area
	   CALLRET FREMSG
	  LOAD AJ,RCAJQ,(RC)	; Get our only adjacency
	  JUMPE AJ,FREMSG
	ELSE.
	  JUMPE AJ,FREMSG	; If no adjacency, toss message
	  CALL CK2WAY		;Do we have a known two-way adjacency?
	   CALLRET FREMSG 	;No, can't accept this message
	  TMNN AJPH4,(AJ)	; Phase 4 node?
	  IFSKP.
	    LOAD T1,AJNTY,(AJ)	;Get type
	    CAXE T1,ADJ.LN	;Is it non-routing?
	    IFSKP.
	      LOAD T1,AJNAN,(AJ) ;Get address and give a buginf
	      BUG.(INF,ROURFN,ROUTER,SOFT,<Routing message received from non-routing node>,<<T1,ADDRESS>>,<

Cause:	The monitor has received a routing message from a node the monitor 
	believe to be an endnode so the monitor has no vector to store it in.

Action:	Check the address of the node and then see if it thinks it is a
	routing/non-routing node.

Data:	ADDRESS - Address of node
>,FREMSG)
	    ENDIF.
	    CALL DNG1BY		; Get expected reserved byte
	     JSP T1,RTEMFE	;++Message format error
	  ENDIF.
	  LOAD T1,MBSRC,(MB)	;GET THE SOURCE ADDRESS
	  LDB T2,[POINTR (T1,RN%ARE)] ;GET THE AREA NUMBER
	  LDB T1,[POINTR(T1,RN%NOD)] ;GET THE NODE NUMBER
	  SKIPN T2		;Phase IV area number there?
	   MOVE T2,RTRHOM	;No, then supply a default
	  OPSTR <CAMN T1,>,AJNAN,(AJ) ;Is that the number we expected?
	   CAME T2,RTRHOM	;Is packet from our area
	    JRST [MOVX T1,RS.ANA ;EVENT REASON: ADJACENT NODE ADDRESS CHANGE
		  CALLRET RTEADO] ;REPORT ADJACENCY DOWN - OPERATOR FAULT EVENT
	ENDIF.
	MOVE T1,MB		;POINT TO INPUT MESSAGE
	CALL DNLENG		;GET ITS LENGTH
	TXNE T1,1B35		;SEE IF IT'S AN EVEN LENGTH
	CALLRET RTCRME		;++MESSAGE FORMAT ERROR EVENT

	SUBI T1,2		;GET COUNT WITHOUT CHECKSUM
	ASH T1,-1		;MAKE IT ENTRY COUNT
				;  EXACTLY THE LENGTH THAT WE ARE EXPECTING
	MOVE P2,T1		;GET COPY OF ENTRY COUNT
	CALL DNRPOS		;READ THE POSTION IN MESSAGE
	STOR T1,RMMK2,(MB)	;STORE THE ROUTING MESSAGE POSITION

;RTCRTE - Continued from previous page

;Here to read the message, while summing the checksum.

	SETZ P1,		;A PLACE FOR THE CHECKSUM
	TMNE AJPH4,(AJ)		;Phase 4 node?
	 AOJ P1,		;YES, THEN START WITH 1

RTCRT2:	CALL DNG2BY		;GET A BYTE OF THE ROUTING MESSAGE
	 CALLRET RTCRME		;++MESSAGE FORMAT ERROR EVENT
	ADD P1,T1		;SUM THE CHECKSUM
	SOJG P2,RTCRT2		;SKIM THROUGH IT

;Get the checksum in the message and verify it.

	CALL DNG2BY		;GET THE CHECKSUM FROM THE MESSAGE
	 JRST [MOVX T1,RS.RUC	;EVENT ERROR: CHECKSUM ERROR DETECTED
	       CALLRET RTELDS]	;REPORT THE CIRCUIT DOWN - SOFTWARE ERROR EVENT
	EXCH T1,P1		;EXCHANGE THE CHECKSUMS
	CALL CKSNRM		;NORMALIZE THE ONE WE FIGURED OUT
	CAME T1,P1		;BETTER BE THE SAME
	 CALLRET RTCRME		;++MESSAGE FORMAT ERROR EVENT
;*** Bugchk here??? ***** if no RTV
	CALLRET RTRBAV		; Build routing data into adjacency's vector

	SUBTTL Control Message Processors -- RTCTST - Test or Hello Messages

;RTCTST - Routine to handle the hello and test messages
;
; Call: 
;	T1/ State of Circuit
;	RC/ Pointer to Circuit Block
;	MB/ Pointer to Message Block
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1-T4
;
;Router Hello and Test messages consist of a image count followed by that
;count of bytes filled with some constant (HEL.LO).

RTCTST:	TRACE RTR,<Processing test or hello message>
	CAIE T1,RCS.TT		;ARE WE IN TEST OR
	CAIN T1,RCS.RN		; OK MODE?
	TRNA			;YES
	JRST [ETRACE RTR,<Test or Hello message rcvd in wrong state>
	      MOVX T1,RS.UPT	;REASON: UNEXPECTED PACKET RECEIVED
	      CALLRET RTELDS]	;REPORT CIRCUIT DOWN - CIRCUIT FAULT EVENT
	LOAD T1,MBSRC,(MB)	;GET THE SOURCE ADDRESS
	LDB T2,[POINTR (T1,RN%ARE)] ;GET THE AREA NUMBER
	JUMPE T2,RTCTS1		; Phase III nodes don't supply area numbers
	CAME T2,RTRHOM
	 CALLRET FREMSG		;NOT FROM OUR AREA, PUNT IT THEN
RTCTS1:	LDB T1,[POINTR(T1,RN%NOD)] ;GET THE NODE NUMBER
	OPSTR <CAMN T1,>,AJNAN,(AJ) ;IS IT WHAT WE EXPECTED?
	IFSKP.
	  MOVX T1,RS.ANA	;REASON: ADJACENT NODE ADDRESS CHANGED
	  CALL RTEADO		;REPORT ADJACENCY DOWN - OPERATOR FAULT EVENT
	  CALLRET CIRFAI	;Close the circuit and restart it
	ENDIF.
	CALL RTRCTD		;Check the test bytes
	 TRN
	RET

	SUBTTL Control Message Processors -- RTCL2M - Level 2 Routing Messages
RTCL2M:
	CALLRET FREMSG		;Free message and return since we can not be
				;a level 2 router

	SUBTTL Control Message Processors -- RTCERH - Ethernet Router Hello

RTCERH:	STKVAR	<<RSID,2>>	;STORAGE FOR CURRENT RS LIST ID
	TRACE RTR,<Processing Ethernet Router Hello message>
	CAIE T1,RCS.TT		;ARE WE IN TEST OR
	CAIN T1,RCS.RN		; OK MODE?
	TRNA			;YES
	JRST [ETRACE RTR,<Test or Hello message rcvd in wrong state>
	      MOVX T1,RS.UPT	;REASON: UNEXPECTED PACKET RECEIVED
	      CALLRET RTELDS]	;REPORT CIRCUIT DOWN - CIRCUIT FAULT EVENT

	SKIPN ENFLG		; Endnode?
	 CALLRET RHMASR		; No
	CALLRET RHMASE


	SUBTTL Control Message Processors -- RHMASE - Hello message if Endnode

;Process a hello message from a routing node if we are an endnode

RHMASE:	LOAD T1,MBSRC,(MB)	;[7437]Yes, get address of sender
	CALL RTRGAJ		;[7437](T1,RC/AJ)In our area?
	 JRST FREMSG		;[7437]No. Drop it
	LOAD AJ,RCAJQ,(RC)	; Get our only adjacency - maybe
	CAME T4,RTRAEN		; Sent to multicast "all endnodes"?
	 JRST FREMSG		; No, don't want it
	CALL RTRRCV		; Yes, read and check version
	 JSP T1,RTEMFE		; Bad version  **EVENT??**
	CALL DNGENA		; The the 6 byte address of transmitting node
	 JSP T1,RTEMFE		; ++MESSAGE FORMAT ERROR++
	CAME T1,RTRHIO		; HIORD?
	 JSP T1,RTEMFE		; No, we don't want it
	HLRZ P1,T2		; Repostion address and save it
	STOR T1,RCDSH,(RC)	; Save this address as the designated router
	LOAD T3,RCDSL,(RC)	; Current designated router address
	SKIPE AJ		; Do we have an adjacency?
	IFSKP.
	  SETO T1,		; No, make a "routing" adjacency block
	  CALL RTRMAJ		;  so we can eavesdrop on routing messages
	   CALLRET FREMSG
	  MOVE AJ,T1
	  INCR RCNRO,(RC)	; Count a router adjacency on this circuit
	  AOS RTRBRA		;  and this node
	ELSE.
	  SKIPN T3		; Yes, do we have a DR?
	  IFSKP.
	    CAME T3,P1		; Yes, is it the same as address just received?
	    IFSKP.
	      CALL DNGTIM	; Get the current time
	      STOR T1,AJTLR,(AJ) ; Store time we last heard from DR
	      CALLRET FREMSG	;   and nothing more to do
	    ELSE.
	      LOAD T2,RCLID,(RC) ; No, get device ID
	      LOAD T3,AJADR,(AJ) ; Node's address		
	      EVENT RE.AJD,<Adjacency down> ;Signal address change as 
	      CALL RTRSAO	; adjacency off-line. Set the adjacency offline
	    ENDIF.		;  and reuse the adjacency
	  ENDIF.
	ENDIF.
	STOR P1,RCDSL,(RC)	; Save address of designated router
	CALL PSINFO		; Get information in the IINFO field
	 JSP T1,RTEMFE
	CALL DNGTIM		; Get the current time
	STOR T1,AJTLR,(AJ)	; Time last heard from designated router
	MOVX T1,ADJ.UP		; Set the adjacency state to up
	STOR T1,AJSTA,(AJ)
	LOAD T2,RCLID,(RC)	; Get device ID
	LOAD T3,MBSRC,(MB)	; Get address of sender
	STOR T3,AJNAN,(AJ)
	LDB T1,[POINTR(T3,RN%ARE)] ;Get the area number
	STOR T1,AJNAA,(AJ)
	STOR P1,AJNAL,(AJ)	; Save low order address in string format
	CALL DNG2BY		; Get the block size
	 JSP T1,RTEMFE		;  None, bad message
	STOR T1,AJBSZ,(AJ)	; Save the block size requested
	LOAD T2,RCLID,(RC)	; No, get device ID
	LOAD T3,AJADR,(AJ)	; Node's address		
	EVENT RE.AUP,<Adjacency up>
	CALLRET FREMSG

	SUBTTL Control Message Processors -- RHMASR - Hello message if Router

;Process a hello message from a routing node if we are a routing node

RHMASR:	SETO T1,		;Flag to indicate that this is a router hello
	CALL RTRPNI		;PARSE OFF THE COMMON HEADER
	 CALLRET FREMSG		;ERROR
	CALL DNG1BY		;GET THE ROUTER PRIORITY
	 JSP T1,RTEMFE		; ++MESSAGE FORMAT ERROR
	STOR T1,AJPRI,(AJ)	;SAVE IT
	CALL DNG1BY		;GET THE ROUTER AREA
	 JSP T1,RTEMFE		; ++MESSAGE FORMAT ERROR++
	STOR T1,AJARE,(AJ)	;SAVE IT
	CALL DNG2BY		;GET THE HELLO TIMER IN SECONDS
	 JSP T1,RTEMFE		; ++MESSAGE FORMAT ERROR++
	IMULI T1,%RTB3M*^D1000	;Broadcast multiplier & convert to milliseconds
	STOR T1,AJNHT,(AJ)	;SAVE THE HELLO TIMER
	CALL DNGTIM		;Get the current time
	STOR T1,AJTLR,(AJ)	;Save it for timeout processing
	CALL DNG1BY		;GET THE RESERVED BYTE
	 JSP T1,RTEMFE		; ++MESSAGE FORMAT ERROR++
	STOR T1,AJMPD,(AJ)	;SAVE MPD
	CALL DNG1BY		;GET THE COUNT OF NI-LIST NODES
	 JSP T1,RTEMFE		;RETURN IF NONE
	CAIL T1,8		;IS IT .GE. TO 8
	 CAILE T1,^D244		; .AND. .LE. 244?
	  JSP T1,RTEMFE		;  NO TO EITHER
	MOVE P1,T1		;SAVE THE COUNT
	CALL DNGENA		;GET THE FIRST 6 BYTES 
	 JSP T1,RTEMFE		; ++MESSAGE FORMAT ERROR++
	SKIPN T1		; Must be zero
	 SKIPE T2		; Just feeling paranoid
	  JSP T1,RTEMFE		; ++MESSAGE FORMAT ERROR++
	CALL DNG1BY		; Which is really 7 bytes
	 JSP T1,RTEMFE		; ++MESSAGE FORMAT ERROR++
	SKIPE T1		; Should be zero
	 JSP T1,RTEMFE		; ++MESSAGE FORMAT ERROR++
	SUBI P1,7		;WE REMOVED 7 BYTES
	CALL DNG1BY		;GET THE COUNT FOR THE SECOND LIST
	 JSP T1,RTEMFE		; ++Message Format Error++
	CAIE P1,1(T1)		;DO THE COUNTS TALLY?
	 JSP T1,RTEMFE		; NOPE, INNER COUNT SHOULD BE .LT. OUTER
	JUMPE T1,RHMNSD		;IF ADJACENCY LIST IS 0, Node is shutting down
	IDIVI T1,7		;DIVIDE BY SIZE OF ENTRIES
	SKIPE T2		;An even multiple of seven
	 JSP T1,RTEMFE		; NO
	MOVE P1,T1		;SAVE THE COUNT
	CAILE T1,^D236		;NUMBER MAKE SENSE
	 BUG.(INF,ROURCE,ROUTER,SOFT,<Bad NI Router list message format>,,<

Cause:	The monitor has received a router hello message with more than 256 
	known 2-way adjacencies.
>,FREMSG)

; RHMASR  continued
; Now peruse the ROUTER/STATE list looking for ourselves.  If we find ourself
; this means that the other node knows about us.

	STKVAR <SELF>
	SETZM SELF		;Initialize to zero
RHMAR1:	CALL DNGENA		; Get the six bytes of node id
	 JSP T1,RTEMFE		; ++MESSAGE FORMAT ERROR++
	CAME T1,RTRHIO		;IS IT HIORD (HIGH PART OF NODE ADDRESS)
	 JRST RHMAR3		;NOPE, THEN SKIP IT
	MOVE T3,RTRLOO		;GET MY ADDRESS
	CAME T2,T3		;IS IT ME?
	 JRST RHMAR3		;NOPE, THEN SKIP IT
	SETOM SELF		;We have seen ourselves!
	LOAD T1,AJSTA,(AJ)	;Yes, get the adjacency state
	CAXN T1,ADJ.UP		;Is it up?
	 JRST RHMAR3		;Yes, then don't generate adjacency up event
	MOVX T1,ADJ.UP		;Set the state to "up"
	STOR T1,AJSTA,(AJ)	; in the adjacency block
	SETONE RCSRM,(RC)	;Send a routing update on this circuit
	LOAD T2,RCLID,(RC)	;Get device ID
	LOAD T3,AJADR,(AJ)	;Get node address for the event
	EVENT RE.AUP,<Adjacency up> ; and send the event
	SETOM RTRRCF		;Recompute routing
	MOVN T1,RTRBT1		;Reset the time of last routing
	STOR T1,RCTLR,(RC)	; message

RHMAR3:	CALL DNG1BY		;GET PRISTATE
	 JSP T1,RTEMFE		; ++MESSAGE FORMAT ERROR++
	SOJG P1,RHMAR1		;AND GET THE NEXT ONE
	SKIPE SELF		;Did we find ourselves?
	 CALLRET FREMSG		;Yes, !!Success!!
	MOVX T1,ADJ.IN		;No, then set adjacency state to initializing
	TRNA 
RHMNSD:	MOVX T1,ADJ.UN		;Set state to unused
	LOAD T2,AJSTA,(AJ)	;Get the state of the adjacency
	CAXE T2,ADJ.UP		;Was it up?
	 CALLRET FREMSG		;No, then done
	STOR T1,AJSTA,(AJ)	;Save new state
	MOVE P1,T1		;Save for later check
	INCR RCAJD,(RC)		;Count adjacency down events
	LOAD T2,RCLID,(RC)	;Get the device ID
	LOAD T3,AJNAN,(AJ)	;Get the node address
	EVENT RE.ADO,<Adjacency down-operator initiated>,
	SETOM RTRRCF		; Recompute routing
	CAIE P1,ADJ.UN		;Is new state unused?
	 CALLRET FREMSG		;No, then done
	MOVE T1,AJ
	MOVE T2,RC
	CALL RTRZAB		;Yes, release the adjacency
	CALLRET FREMSG

	SUBTTL Control Message Processors -- RTCNIE - NI Endnode Hello message

RTCNIE:	TRACE RTR,<Processing NI Endnode hello and test message>
	SKIPGE ENFLG		;Endnode?
	 CALLRET FREMSG		;  Yes, don't process this
	CAIE T1,RCS.TT		;Are we in test or
	CAIN T1,RCS.RN		; run mode?
	TRNA			;Yes
	JRST [ETRACE RTR,<Test or Hello message received in wrong state>
	      MOVX T1,RS.UPT	;REASON: UNEXPECTED PACKET RECEIVED
	      CALLRET RTELDS]	;REPORT CIRCUIT DOWN - CIRCUIT FAULT EVENT

	SETZ T1,		;Flag to say this is an endnode hello
	CALL RTRPNI		;Parse off common header and set up AJ if
	 CALLRET FREMSG		; we have not exceeded maximum adjacencies
	CALL DNG1BY		;Get the area (reserved)
	 JSP T1,RTEMFE		;Bad packet if not there
	MOVEI T1,^D14		;Skip over the next 14 bytes which include
	CALL DNSKBY		; the seed (8 bytes) & the neighbors system ID
	 JSP T1,RTEMFE		; ++Bad packet++
	CALL DNG2BY		;Hello timer in seconds
	 JSP T1,RTEMFE
	IMULI T1,%RTB3M*^D1000	;Broadcast multiplier & convert to milliseconds
	STOR T1,AJNHT,(AJ)	;Save the hello timer
	CALL DNG1BY		;MPD (reserved)
	 JSP T1,RTEMFE
	CALL RTRCTD		;Now, check the test data
	 RET			;Bad test data
	CALL DNGTIM		;Time stamp this
	STOR T1,AJTLR,(AJ)	; as time last heard from adjacency
	LOAD T1,AJSTA,(AJ)	;Get adjacency state
	CAIN T1,ADJ.UP		;If it was up then done
	 RET
	SETOM RTRRCF		;Set recompute flag
	MOVX T1,ADJ.UP		;Set the adjacency state to up
	STOR T1,AJSTA,(AJ)
	LOAD T2,RCLID,(RC)	;Get device ID
	LOAD T3,AJADR,(AJ)	;Needed for the event
	EVENT RE.AUP,<Adjacency up>
	RET
	
	SUBTTL RTCILL - Illegal message received

RTCILL:	MOVE T1,MB		; Setup for DNFMSG 
	BUG.(CHK,ROUBMT,ROUTER,SOFT,<Bad message type received from the DLL>,,<

Cause:	The DLL received a bad message from another node or incorrectly copied
	a message into the message block.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.
>,DNFMSG)
	
	SUBTTL RTRBAV - Build adjacency's routing vector from routing update


RTRBAV:	STKVAR <MSGLEN,VECMAX>
	SETZM HIADDR		;Initialize highest address in case of P.R.U.L.
	MOVE T1,MB		;POINT TO THE MESSAGE BLOCK
	CALL DNGINI		;GET UP TO GET BYTES
	LOAD T1,RMMK2,(MB)	;GET THE ROUTING DATA'S POSITION
	CALL DNGPOS		; AND GO TO IT
	MOVE T1,MB		;POINT TO MESSAGE BLOCK AGAIN
	CALL DNLENG		;GET THE LENGTH OF THE MESSAGE
	SUBI T1,2		;ACCOUNT FOR CHECKSUM
	ASH T1,-1		;MAKE IT AN ENTRY (NODE) COUNT
	MOVEM T1,MSGLEN		;SAVE THE LENGTH OF THE WHOLE MESSAGE
	TMNN AJPH4,(AJ)		;Phase IV node?
	 JRST RTRBA4		;NO, THEN USE THIS LENGTH
RTRBA3:	CALL DNG2BY		;YES, THEN GET THE COUNT OF ENTRIES
	 BUG. (CHK,ROUUOC,ROUTER,SOFT,<Unable to obtain count of nodes in Phase IV message>,,<

Cause:	The monitor has received a routing message that DNLENG indicates has 
	more bytes than has been read.  When another read is attempted, DNLENG
	indicates the count is exhausted.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.
>,RTRBA9)
	MOVE P2,T1		;SAVE THE COUNT
	CALL DNG2BY		;Get two bytes of starting node ID
	 CALLRET RTCRME		;Message format error
	CAILE T1,RTRMXN		;Is starting node address larger than we handle
	 BUG. (CHK,ROUATL,ROUTER,SOFT,<A routing message contains a start ID greater than we can handle>,,<

Cause:	An adjacent node has sent a routing message with the start ID
	that would cause indexing into the per adjacency vector past
	the end of the vector.
>,RTRBA9)
	MOVNI T2,2		;Account for the bytes we just read
	ADDM T2,MSGLEN		; 4 bytes = 2 entries


;[9171] Get the address of the routing vector for the Phase IV router.  If a
;node was a non-routing node and now is a routing node, there will not be a
;adjacency routing vector pointer, so we have to allocate one now.  Nonskip
;from RTRBAU means there is no vector Victor (what's the clearance Clarence?)

	CALL RTRBAU		;[9171] (/P1) Get the adjacency routing vector
	 JRST RTRBA9		;[9171] Owie, bugchk issued
	MOVE T3,P1		;Compute the last address in the
	ADD T3,RTRMXN		; per adjacency vector that we can
	MOVEM T3,VECMAX		; use
	ADD P1,T1		;ADD IN THE STARTING NODE NUMBER
	JRST RTRBA5		;SKIP PHASE III CODE

;[9171] Get the address of the routing vector for the Phase III router.

RTRBA4:	MOVE P2,MSGLEN		;GET THE MESSAGE LENGTH BACK
	CALL RTRBAU		;[9171] (/P1) Get the adjacency routing vector
	 JRST RTRBA9		;[9171] Wow, not enough freespace 
	MOVE T3,P1		;Compute the last address in the
	ADD T3,RTRMXN		; per adjacency vector that we can use
	MOVEM T3,VECMAX
	AOJ P1,			; Increment it to node 1

;[9171] Validate the number of nodes in update.

RTRBA5:	MOVE T1,P2		; Number of nodes in message or segment
	TMNE AJPH4,(AJ)		; Phase IV node?
	 SOS T1			; Yes, account for node 0, the area router
	SKIPGE T1		; Negative count of entries is not good
;	CAMLE T1,RTRMXN		; More than we care to know about?
	BUG.(CHK,ROURML,ROUTER,SOFT,<Stored routing message format error in RTRBAV>,<<T1,COUNT>>,<

Cause:	The monitor has received a P3 routing message with a negative count 
	of nodes in it or no checksum or a P4 routing message with a negative 
	segment count.

Data:	COUNT - Count or checksum
>,RTRBA9)


;At this point P2 contains the number of entries in the routing message for
;Phase III messages or the number of entries in the segment for Phase IV.

RTRBA6:	CALL DNG2BY		;GET THE BYTE FOR A NODE
	 BUG.(CHK,ROUUER,ROUTER,SOFT,<Unexpected end of routing message>,,<

Cause:	The number of bytes in the routing message did not correspond
	to the length expected. This may be caused by reading too many 
	bytes out of the message without decrementing the count of bytes 
	read or caused by an improper routing message.
>,RTRBA9)
	CAMG P1,VECMAX		; Have we stepped past the end of the vector?
	IFSKP.			;  A CAMG because vector size is RTRMXN+1
	  CAMLE P1,HIADDR	; Is this the highest address so far?
	   MOVEM P1,HIADDR	; Yes, save new high and use as a flag in-
				; dicating address higher than our maximum
	ELSE.			; address
	  LOAD T2,RGCST,+T1	; GET THE COST FROM THE BYTE
	  LOAD T1,RGHOP,+T1	; GET THE HOP COUNT
	  LOAD T3,RNCST,(P1)	; Get previous cost
	  CAIE T2,(T3)		; Different?
	   SETOM RTRRCF		; Flag we have to recompute topology
	  STOR T2,RNCST,(P1)	; Save both as new cost/hops
	  STOR T1,RNHOP,(P1)	;
	ENDIF.
	AOJ P1,			; INCREMENT THE POINTER
	SOS MSGLEN		; DECREMENT THE COUNT OF ENTRIES
	SOJG P2,RTRBA6		;  AND LOOP UNTIL FINISHED WITH THEM ALL

RTRBA8:	SKIPLE MSGLEN		; HAVE ANY MORE SEGMENTS TO THIS MESSAGE?
	 JRST RTRBA3		; YES, THEN GET THEIR INFO
RTRBA9:	SKIPN HIADDR		; Any overflows?
	IFSKP.
	  OPSTR <MOVN T1,>,AJRTV,(AJ) ; Get start of vector
	  ADDM T1,HIADDR	; Compute highest address for the event
	  CALL RTCRTF		; Yes, EVENT - Partial routing update loss
	ENDIF.
	CALLRET FREMSG		; Return message block

;[9171] Here from RTRBAV to get the address of the routing vector.  If a node
;was a non-routing node and now is a routing node, there will not be a
;adjacency routing vector pointer.  DECrouter-2000s come up as end nodes then
;change to routers.  If there is none, we have to allocate one now.
;Call only from RTRBAV with AJ/ set up
;Returns +1 if there is no vector (Victor) and none was allocated
;Returns +2 if RTV (now) exists with P1/ address

RTRBAU:	LOAD P1,AJRTV,(AJ)	;[9171] Get adjacency routing vector pointer
	JUMPN P1,RSKP		;[9171] Return now if we have one
	SAVET			;[9171] Save the temps for a moment please
	MOVE T1,RTRMXN		;[9171] Get the maximum node number
	ADDI T1,1		;[9171] Add one for node zero 
	CALL DNGWDZ		;[9171] (T1/T1) Get that many words
	 BUG.(CHK,ROUNAV,ROUTER,SOFT,<An adjacency has no routing vector>,<<AJ,Adjacency block>>,<

Cause:	A routing vector is built for each routing adjacency when the adjacency
	block is created if the node is a router.  The monitor has discovered
	that a routing node has supplied a routing update but there is no
	routing vector.  This can happen if a node comes up as an endnode and
	later changes to a router (DECrouter-2000s do this).  The monitor
	attempted to create a routing vector but none could be created,
	probably due to a lack of freespace.  The routing update is ignored.

Action:	Reloading the system should clear up this problem.  It may be that
	there is not enoug DECnet free space on the system.  If this BUG
	persists and is reproducible, set this BUG dumpable and submit an SPR
	with the dump, a copy of MONITR.EXE, and details about the local DECnet
	configuration and DECnet applications.  Include any known method for
	reproducing the problem and/or loading and state of the system at the
	time the BUG was observed.

Data:	AJ - Adjacency block
>,RTN)				;[9171] Not much we can do but return +1
	MOVE P1,T1		;[9171] Copy the address of the block
	STOR P1,AJRTV,(AJ)	;[9171] Store the address of the routing vector
	MOVE T2,RTRMXN		;[9171] Get the maximum number of nodes
	ADD T2,T1		;[9171] For end of smear
	MOVX T3,RNCHG!RNHOP!RNCST ;[9171] Get infh and infc and change flag
	CALL DNSWDS		;[9171] (T1,T2,T3/) Smear the vector
	LOAD T2,AJNAA,(AJ)	;[9171] Get area number of sender
	LOAD T3,AJNAN,(AJ)	;[9171] Get node number of sender
	BUG.(INF,ROUTEU,ROUTER,SOFT,<Endnode upgraded to router>,<<T2,AREA>,<T3,NODE>>,<

Cause:	A routing vector is built for each routing adjacency when the adjacency
	block is created if the node is a router.  The monitor has discovered
	that a routing node has supplied a routing update but there is no
	routing vector.  A routing vector has been created for this node.

Data:	AREA - DECnet area number of node sending routing update
	NODE - DECnet node number of node sending routing update
>)				;[9171] Tell Greg something happened
	RETSKP			;[9171] Return +2 with P1/ address

;Here to report the partial routing update loss.

RTCRTF:	SKIPGE ENFLG		; Non-routing?
	 RET			; Yes, then no event
	LOAD T2,RCLID,(RC)	; Get the entity ID
	LOAD T3,AJADR,(AJ)	; Get address of sender
	EVENT RE.PRL,<Partial routing update loss event>,MB
	AOS RTRCPR		; Increment the counter
	RET

	SUBTTL RTCRME - Routing message error processor

RTCRME:	SKIPGE ENFLG		; Non-routing
	 JRST FREMSG		; Yes, just dispose of message
	JSP T1,RTEMFE		; No, generate an event

	SUBTTL RTRPNI - Parse a  Message Header for NI Hello messages

;RTRPNI - Parse Router Header on Incoming Message
;
; Call: 
;	RC/ Pointer to circuit block
;	MB/ Pointer to Input message
;
; Return: 
;	RET			;IF BAD HEADER
;	RETSKP			;ON SUCCESS
;
; Uses: T1-T2,AJ
;
; This routine parses off the common header from the NI Endnode hello message
;and the NI Router hello message and stores the correct information in the
;adjacency block.

RTRPNI:	SAVEAC P1
	STKVAR <HELTYP,LOSADR>	;Hello type flag and string format node address
	MOVEM T1,HELTYP		;Save hello type
	CALL RTRRCV		;Read and check the version of the Router
	 RET
	CALL DNGENA		;GET THE 6 BYTE SYSTEM ID IN T1 AND T2
	 RET
	CAME T1,RTRHIO		;Do we have HIORD?
	 RET			; No
	STOR T1,MBSR1,(MB)	;Save the source high order
	HLRZM T2,LOSADR		;We will need this later
	CALL CVTSTN		; (T2) Convert string address to 16 bit address
	STOR T1,MBSRC,(MB)	; Stuff it into the MB
	HRRZ T2,T1		; Get the node address in a scratch AC
	TXZ T2,RN%ARE		;  and get only the number
	CAMLE T2,RTRMXN		; Within our allowed maximum?
	 RET			; No, don't make an adjacency
	CALL RTRGAJ		; Find the adjacency associated w/this node
	 RET			; Not in my area, drop the message
	JUMPN AJ,RTRPN3		; Jump if an adjacency exists
	SKIPN HELTYP		; Router hello?
	 JRST RTRPN1		; No, then assume endnode
	MOVE P1,RTRBRA		; Number of router adjacencies that are up
	CAMLE P1,RTNBRA		; Have we exceeded the maximum?
	 JRST RTRPN4		; yes, allow no more
	LOAD T1,RCNRO,(RC)	; Get number of Routers on this circuit
	OPSTR <CAML T1,>,RCMXR,(RC) ;  see if maximum exceeded
	 JRST RTRPN4		; Yes, don't allow it
	SETO T1,		; Flag to indicate routing adjacency
	CALL RTRMAJ		; Make an adjacency
	 RET			; Can't, must be out of memory
	MOVE AJ,T1		; Get adjacency address
	ADDI P1,1		; Account for it
	MOVEM P1,RTRBRA		; Save new count of routers
	INCR RCNRO,(RC)
	JRST RTRPN2		; Rejoin common code
RTRPN1:	MOVE P1,RTRBEA		; Number of endnode adjacencies that are up
	CAMLE P1,RTNBEA		; Have we exceeded the maximum?
	 JRST RTRPN4		; Yes, allow no more
	SETZ T1,		; Flag to indicate endnode adjacency
	CALL RTRMAJ		; Make an adjacency block
	 RET			; Error return
	MOVE AJ,T1		; Get adjacency address
	ADDI P1,1		; Increment number of endnode adjacencies
	MOVEM P1,RTRBEA		; Save new count
RTRPN2:	LOAD T1,MBSR1,(MB)	; Get the high order address
	STOR T1,AJNAH,(AJ)	; Put it into the AJ block
	MOVE T1,LOSADR		; Get the low order string address
	STOR T1,AJNAL,(AJ)	;  and save address in string format
	LOAD T1,MBSRC,(MB)	; Get the low order node address
	STOR T1,AJNAN,(AJ)	; Stuff it
	LDB T1,[POINTR(T1,RN%ARE)] ; Get the area number
	STOR T1,AJNAA,(AJ)	; Save that too

RTRPN3:	LOAD T1,AJCBP,(AJ)	; Get the circuit block pointer
	CAME T1,RC		; Same as one it came in on
	 RET			; Error return
	CALL PSINFO		; Save infomation in the IINFO field
	 RET
	CALL DNG2BY		;GET THE BLOCK SIZE
	 RET
	CAMGE T1,RTRBSZ		;Is it at least as large as ours?
;*** Should we do more?
	 RET
	LOAD T2,AJNTY,(AJ)	;Get the adjacency type
	CAIN T2,ADJ.LN		;Is it an endnode?
	IFSKP.			;No, check the blocksize
	  LOAD T2,RCBSZ,(RC)	;Get block size currently used on this circuit
;*** What if little guy goes away?
	  CAIGE T1,(T2)		;Is the new one smaller
	   STOR T1,RCBSZ,(RC)	;Yes, then use it
	ENDIF.
	STOR T1,AJBSZ,(AJ)	;SAVE THE BLOCK SIZE REQUESTED
	RETSKP			;RETURN SUCCESS TO CALLER

RTRPN4: MOVE T3,T2		; Get adjacency's address
	LOAD T2,RCLID,(RC)	; Get the entity ID
	EVENT RE.ARJ,<Adjacency rejected>
	RET			; Yes, then don't make an adjacency

	ENDSV.

	SUBTTL	PSINFO - Parse the info field of Ethernet router hello

;Call:
;	AJ/ Adjacency block
;
;Return:
;	 RET			;On error in info field of message
;	RETSKP			;Info parsed and entered into the
;				; adjacency block

PSINFO:	CALL DNG1BY		; Get the IINFO field
	 RET
	LOAD T2,IITYP,+T1	; Get routing type
	SETO T3,		; Put a funny value in receiving AC
	CAXN T2,IIT.L1		; Is it a level one router?
	 MOVX T3,ADJ.L1		;  Yes
	CAXN T2,IIT.L2		; Is it a level 2 router?
	 MOVX T3,ADJ.L2		;  Yes
	CAXN T2,IIT.EN		; Is it an endnode?
	 MOVX T3,ADJ.LN		;  Yes
	JUMPL T3,R		; Strange value
	STOR T3,AJNTY,(AJ)	; Tell the Adjacency about it
	SETONE AJPH4,(AJ)	;  and set the Phase IV flag
	LOAD T2,IIVRQ,+T1	;GET THE VERICATION REQUIRED FLAG
	STOR T2,AJVRQ,(AJ)	;STOR IT IN THE ADJACENCY BLOCK
	LOAD T2,IIRJF,+T1	;GET THE REJECT FLAG
	STOR T2,AJRJF,(AJ)	;SAVE IT
	LOAD T2,IIMTA,+T1	;GET THE NO MULTICAST TRAFFIC ACCEPTED FLAG
	STOR T2,AJMTA,(AJ)	;SAVE IT
	LOAD T2,IIBRQ,+T1	;GET THE BLOCKING REQUESTED FLAG
	STOR T2,AJBLO,(AJ)	;SAVE IT
	RETSKP


	SUBTTL RTRRCV - Read version information from message

RTRRCV:	CALL DNG1BY		;GET THE VERSION NUMBER
	 JSP T1,RTEMFE		; ++MESSAGE FORMAT ERROR++
	CAME T1,RTRVER		;IS IT THE CORRECT VERSION?
	 RET			;NO, THEN JUST RETURN
	CALL DNG2BY		;GET THE ECO AND USER ECO
	 JSP T1,RTEMFE		; ++MESSAGE FORMAT ERROR++
	RETSKP

	SUBTTL RTRHDP - Parse a Input Router Message Header

;RTRHDP - Parse Router Header on Incoming Message
;
; This routine will skip over leading padding, and parse the first control byte
; of the routing packet.  For Short Data Packets, and Long Data Packets, this
; routine will also completely parse their headers.
;
; Call: 
;	MB/ Pointer to Input message
;
; Return: 
;	RET			;IF BAD HEADER
;	RETSKP			;ON SUCCESS
;
; Uses: T1-T2
;
;Note that DNGINI is called here and should not be recalled afterwards
;for the Router MSD.

RTRHDP:	MOVE T1,MB		;POINT TO THE MESSAGE BLOCK
	CALL DNGINI		;SET UP FOR CALLS TO DNGxBY
	CALL DNRPOS		;GET OUR POSITION
	STOR T1,RMMK1,(MB)	;STORE IT FOR EVENT PROCESSING
	CALL DNG1BY		;Try to read message flags
	 RET			;RAN OUT, GIVE ERROR RETURN
	TXZN T1,RM%MZ1		;IS THE PAD FLAG SET?
	IFSKP.
	  CALL PADSKP		;Skip over any pad bytes (NI) and return with
	   RET			; first byte of message.  Error if PADSKP fails
	ENDIF.
	STOR T1,RMFST,(MB)	;Store message flags for later use
	TXNN T1,RM%CTL		;Is this a control packet?
	 JRST RTRHD1		; No, go parse a data packet

;Here with a control message. Check the type and return.

	TXNE T1,^-<CMTYP!CMCTL>	;MAKE SURE THE RESERVED BITS ARE ZERO
	 RET			;NOPE, GIVE BAD RETURN
	LOAD T2,CMTYP,+T1	;GET THE CONTROL MESSAGE TYPE
	STOR T2,RMCTY,(MB)	;STORE THAT IN MESSAGE BLOCK
	CAIL T2,RCM.RH		;Is this an ethernet only message?
	 RETSKP			;Yes, then don't look for source node addr
	CALL DNG2BY		;Get the node address of the sender
	 RET			;If none, then error
	STOR T1,MBSRC,(MB)	;Save in MB's public section
	RETSKP			;RETURN TO SENDER WITH GOOD RETURN

;Here with a data packet.  Parse it w/regards to Ethernet vs. point to point

RTRHD1:	JN RCBCT,(RC),RTRHNI	;If NI, handle differently

	TXNE T1,RM%EVL		;IS THE EVOLUTION BIT SET?
	JRST RTRHD2		;YES, IT HAS A PHASE II ROUTING HEADER

;Check all the fields in the packet route header and store pertinent fields
;in the message block.

	TXNN T1,RM%MB1		;IF LOW TWO ORDER BYTES ARE 00, THIS
				; MESSAGE IS A PHASE II WITHOUT A ROUTING
				; HEADER
	JRST RTRHD2		;IT IS, RETURN, INDICATING PHASE II MESSAGE

	TXNE T1,RM%MZ1!RM%MZ2!RM%MZ3 ;MAKE SURE THESE FIELDS ARE ZERO
	RET			;THEY'RE NOT, GIVE ERROR RETURN

	TXNE T1,RM%RQR		;IS RQR ON?
	TXNN T1,RM%RTS		; AND RTS
	TRNA			;NO, OK
	RET			;YES, THAT'S A PROBLEM
;Now parse the source, destination and visits fields of packet route header.

	CALL RTRGNA		;GET THE DESTINATION ADDRESS
	 RET			;OUT OF BYTES, GIVE BAD RETURN
	STOR T1,MBDST,(MB)	;STORE IT

	CALL RTRGNA		;GET THE SOURCE ADDRESS
	 RET			;RAN OUT, GIVE BAD RETURN
	STOR T1,MBSRC,(MB)	;STORE THAT, TOO

	CALL DNG1BY		;GET THE "FORWARD" BYTE
	 RET			;RAN OUT, GIVE BAD RETURN
	TXNE T1,^-FWVST		;MAKE SURE IT'S NOT TOO BIG
	RET			;IT'S TOO BIG

	STOR T1,MBVST,(MB)	;STORE IT IN THE MESSAGE BLOCK
	RETSKP			;LOOKS GOOD, RETURN

;Here we have a Phase II message.  Set the Phase II flag in the message
;block and return.

RTRHD2:	SETONE RMPH2,(MB)	;SAY THIS IS A PHASE II MESSAGE
	RETSKP			; AND GIVE GOOD RETURN

;Parse an Ethernet style (Long Data Packet) header

RTRHNI:	CALL DNG1BY		;GET D-AREA
	 RET			;NOTHING
	CALL DNG1BY		;GET D-SUBAREA
	 RET			;ERROR IF NOTHING
	CALL DNGHIO		;Ethenet hi-order address
	 RET			;RETURN IF NOTHING THERE
	STOR T1,MBDS1,(MB)	;SAVE FIRST PART OF DESTINATION
	CALL DNG2BY		; get low order node address
	 RET
	STOR T1,MBDST,(MB)	;AND NORMAL DECNET-NODE STUFF
	CALL DNG1BY		;GET THE S-AREA
	 RET			;ERROR
	CALL DNG1BY		;GET THE S-SUBAREA
	 RET			;ERROR
	CALL DNGHIO		;GET THE SOURCE ID
	 RET			; Error
	STOR T1,MBSR1,(MB)	;SAVE THE SOURCE
	CALL DNG2BY		;[7177] Get low order of node address
	 RET			;[7177]
	STOR T1,MBSRC,(MB)	;[7177]  and save that
	SKIPN ENFLG		; Endnode?
	IFSKP.
	  LOAD T2,MBDST,(MB)	; [7177]
	  CAME T2,RTRNAD	; [7177] Destined for us?
	   RET			; No, then bad message - We don't do routing
;[7177] If we are an endnode, see if we should enter this node into the cache
	  TMNN RMMZ2,(MB)	; Intra-NI flag set?
	  IFSKP.		; Yes, see if we should enter it into cache
	    LDB T2,[POINTR(T1,RN%ARE)] ; Get the area number
	    TXZ T1,RN%ARE	;  and only the node number
	    CAME T2,RTRHOM	; In our home area?
	    IFSKP.		; Find our slot in vector
	      CAMLE T1,RTRMXN	;[7177] Higher than our maximum address?
	       RET		;[7177]  Yes, drop it
	      EXCH T1,T2
	      ADD T2,RTRNRV	; Offset into vector
	      SETONE RNCCH,(T2)	; Set the on-ethernet cache bit
	      ADD T2,RTROFS	; Step to cache timer vector(same as OA vector)
	      CALL DNGTIM	; Get current time
	      ADD T1,RTRCTO	; Add the in-cache time
	      MOVEM T1,(T2)	; Save the time when cache bit is flushed
	    ENDIF.
	  ENDIF.
	ENDIF.
	CALL DNG1BY		;GET THE NEXT LEVEL 2 ROUTER
	 RET			;NOT THERE
	CALL DNG1BY		;GET THE VISIT COUNT
	 RET			;NOT THERE
	TXNE T1,^-FWVST		;MAKE SURE IT'S NOT TOO BIG
	 RET			;IT'S TOO BIG
	STOR T1,MBVST,(MB)	;STORE IT IN THE MESSAGE BLOCK
	CALL DNG1BY		;GET THE SERVICE CLASS
	 RET			;ERROR IF NOT THERE
	CALL DNG1BY		;GET THE PROTOCAL TYPE
	 RET			;ERROR IF NOT THERE
	RETSKP			;GIVE GOOD RETURN

	SUBTTL RTRCTD - Check for valid test pattern in Hello/Test message

RTRCTD:	SAVEAC <P1>
	CALL DNG1BY		;GET THE IMAGE COUNT OF TEST MESSAGE
	 JSP T1,RTEMFE		;++MESSAGE FORMAT ERROR EVENT
	CAILE T1,^D128		;IS THE LENGTH WITHIN REASON
	BUG.(INF,ROUBTF,ROUTER,SOFT,<Bad Test message format>,,<

Cause:	We received a hello message from a P3 node or a P4 endnode
	that contained too many bytes of test data.
>,FREMSG)

;Check to see if the test data is ok.

	MOVE P1,T1		;PRESERVE IT SORT OF
	SOJGE P1,[CALL DNG1BY	;GET A BYTE OF THE TEST
		   JRST [MOVX T1,RS.ALI ;REASON: INVALID TEST DATA
			 CALLRET RTELDS] ;REPORT THE CIRCUIT DOWN EVENT
		  CAIE T1,HEL.LO ;IS IT EQUAL TO THE MAGIC NUMBER
		  BUG.(INF,ROUBTM,ROUTER,SOFT,<Bad Hello or Test message>,,<

Cause:	We have received bad test data in a hello message.
>,FREMSG)
		  JRST .]	;LOOK AT ALL THE BYTES
	CALL FREMSG		;FREE THE MESSAGE AND RETURN
	RETSKP


	SUBTTL RTRGNA - Get node address from message header



RTRGNA:	CALL DNG2BY		;Read expected node address
	 RET			;Pass on the error
	LDB T2,[POINTR (T1,RN%ARE)] ;Get the area number if any
	JUMPN T2,RSKP		;We got one use it
	MOVE T2,RTRHOM		;None given use our home area
	DPB T2,[POINTR (T1,RN%ARE)] ;Put ours into the node address
	JRST RSKP		; and return a success

	SUBTTL PADSKP - Skip over pad bytes in an Ethernet message header

;Call:
;	T1/ First byte in input MSD

;Return:
;	T1/ First byte in message header (having skipped over any pad bytes)

PADSKP:	SAVEAC <P1>
	SOSGE P1,T1		;Account for this byte
	 RET			;Pad with count of zero
PADSK1:	CALL DNG1BY		;Get one more byte (Lastly the control byte)
	 RET
	SOJGE P1,PADSK1		;Loop for all the pads
	TXNE T1,RM%MZ1		;Did we get a second pad flag?
	 RET			; Yes, that is illegal
	RETSKP			;Successful

	SUBTTL	Network Management -- RTRNMX - Entry into Router

;RTRNMX - Entry point for network management functions
;
;Call
;	T1/ Function code
;	T2/ NM block address
;Return
;	RET		; Error - Reason in T1
;	RETSKP		; Request complete

	INTERN RTRNMX
	XSWAPCD

RTRNMX:
IFN FTPARANOIA,<
	CAIL T1,NF.SET		; Range check the function code
	 CAILE T1,NF.RET	;
	BUG.(CHK,RTRIFN,ROUTER,SOFT,<Illegal function code from NTMAN>,,<

Cause:	The function code supplied by NTMAN is out of range of functions
	supported by Router.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.  Find routine in NTMAN supplying 
	illegal function code and correct it.
>,RNMXER (NF.MPE))
>
	SAVEAC <P1,P2,RC,AJ>
	MOVE T1,NMXDSP(T1)	; Routine to do processing
	CALLRET (T1)		; Go to it
NMXDSP:
	IFIW!<NMXSET&777777>	; Set Parameter
	IFIW!<NMXCLR&777777>	; Clear Parameter
	IFIW!<NMXRED&777777>	; Read Parameter
	IFIW!<NMXSHC&777777>	; Show Counters
	IFIW!<NMXSZC&777777>	; Show and Zero Counters
	IFIW!<NMXRET&777777>	; Return list of Entity Ids

NMXILL:	RNMXER (NF.FNS)		; Function not supported

	XRESCD
	SUBTTL Network Management -- Read/Set/Clear a parameter

;NMXRED - called to read a network management parameter

;Call:	T2/ address of NM block
;	CALL NMXRED
;	 +1 on error with code in T1
;	+2 on success
;
;Context: Jsys

	XSWAPCD
NMXRED:	MOVX T3,NF.RED		;Load function code
	CALLRET NMXPCM		;Join common code
	XRESCD


;NMXSET - called to set a network management parameter

;Call:	T2/ address of NM block
;	CALL NMXSET
;	 +1 on error with code in T1
;	+2 on success
;
;Context: Jsys

	XSWAPCD
NMXSET:	MOVX T3,NF.SET		;Load function code
	CALLRET NMXPCM		;Call common code
	XRESCD


;NMXCLR - called to clear a network management parameter

;Call:	T2/ address of NM block
;	CALL NMXCLR
;	 +1 on error with code in T1
;	+2 on success
;
;Context: Jsys

	XSWAPCD
NMXCLR:	MOVX T3,NF.SET		;Load function code
	CALLRET NMXPCM		;Call common code
	XRESCD

	SUBTTL Network management -- Common routine for parameters

;NMXPCM - Performs common processing for parameter read, set, and clear

;Call:
;	T2/ address of NM block
;	T3/ Function (read,set,clear)
;	CALL NMXPCM
;	 +1 on error with code in T1
;	+2 on success
;
;Context: Jsys

	XSWAPCD
NMXPCM:	MOVE P1,T2		;Move NF pointer to where it should be
	LOAD T1,NFETY,(P1)	;Get the entity type
	CAIE T1,.NTNOD		;Is request for a node entity?
	IFSKP.
	  LOAD P2,NFEID,(P1)	;Yes, get node address
	  LDB T2,[POINTR (P2,RN%ARE)] ;Get the area number
	  TXZ P2,RN%ARE		;Clear the area number
	  CAME T2,RTRHOM	;Is it same as ours?
	   SETZ P2,		;No, select the area router
	  ADD P2,RTRNRV		;Add in the vector address
	  TMNN RNLCL,(P2)	;Is it local?
	  IFSKP.
	    XMOVEI T1,EXPTAB	;Yes, use executor parameter table
	    MOVEI T2,EXPTBL	; and its length
	  ELSE.
	    MOVE T2,RTRNTY	;Get routing type for later checking
	    LOAD T1,NFPRM,(P1)	;Get requested parameter
	    CAIE T1,0		;Is it state?  <0 = hack for now>
	    IFSKP.	  
	      CAMN P2,RTRNRV	;Have we selected the area router?
	       RNMXND		;Yes, then we have no data to return
	      CAIN T2,RNT.NR	; or if we are an endnode there is no
	       RNMXND		; no state information
	    ELSE.		;Not state
	      CAIE T2,RNT.NR	;Are we an endnode?
	      IFSKP.
		CALL ENPARM	; Yes, set up parameter pointers
		 RET
	      ELSE.
		CALL RNPARM	; Set up parameter pointers
		 RET
	      ENDIF.
	    ENDIF.
	    XMOVEI T1,NDPTAB	;Node parameter table
	    MOVEI T2,NDPTBL
	  ENDIF.
	ELSE.
	  CAIE T1,.NTCKT	;No, maybe circuit
	  IFSKP.
	    LOAD T1,NFEID,(P1)	;Get circuit identifier
	    CALL RTRGCB		;Get the circuit block (RC)=circuit block
	     RNMXER (NF.URC)
	    XMOVEI T1,CCPTAB	;Address of circuit parameter table
	    MOVEI T2,CCPTBL	; and its length
	  ELSE.
	    RNMXER (NF.FNS)	;We don't do any others
	  ENDIF.
	ENDIF.
	
;Call NTPARM to do the real work

	CALLRET NTPARM		; and call common function to do work

	SUBTTL Network management -- Setup for loading parameter data

;Here for all parameters except state.  State needs only to have P2 setup

ENPARM:	MOVE RC,RTRCBQ		; Get only circuit and
	LOAD AJ,RCAJQ,(RC)	;  possibly our desiginated router
	LOAD T1,NFPRM,(P1)	; Get requested parameter
	CAIN T1,^D810		; Is requested parameter routing type?
	 SETZ AJ,		; Yes, don't supply it	
	CAIE T1,^D2503		;  or NODE JSYS reachability?
	 MOVE P2,RTRNRV		; Use kludged up cost/hops in vector(0)
	RETSKP

RNPARM: TMNN RNRCH,(P2)		;Is it reachable?
	 RNMXND			;No, then no data
	SETZ AJ,		;Start with no adjacency
	CAMN P2,RTRNRV		;Have we selected the area router?
	IFSKP.
	  SKIPA RC,RTRCBQ	;No, a local area node, see if adjacent
	  DO.
	    LOAD RC,RCNXT,(RC)	;Get next circuit for RTRGAJ
	    JUMPE RC,ENDLP.
	    LOAD T1,NFEID,(P1)	;Get the node's address
	    CALL RTRGAJ		;See if an adjacency exists
	     RNMXER (NF.OPF)	;Not in our area, an error
	    JUMPE AJ,TOP.	;Didn't find one, try next circuit
	  ENDDO.
	ENDIF.
	MOVE T1,P2		;No, get the address we selected
	ADD T1,RTROFS		;Now point to output adjacency vector
	MOVE T1,(T1)		;Get the output adjacency pointer
	SKIPE AJ		;Did we find an adjacency?
	IFSKP.
	  LOAD T2,NFPRM,(P1)	;No, then get parameter requested
	  CAIE T2,^D810		;Is it routing type?
 	   MOVE AJ,T1		;No, then load AJ with output adjacency
	ENDIF.
	LOAD RC,AJCBP,(T1)	;Now the output circuit pointer
	RETSKP

	SUBTTL Network Management -- Qualified parameters

;Call:
;	RC/ circuit block
;	P1/ NMX function block
;
;	CALL NMXQPS
;	CALL NMXQPT
;	RET	T1/ Error code if error, 0 if no data, .GT. 0 if success
;		T2/ Datum
;
;Context: Jsys

NMXQPS:	SKIPA T1,[-1]		; Adjacent node block size
NMXQPT:	SETZ T1,		; Adjacent node hello timer
	STKVAR <FUNC>
	MOVEM T1,FUNC		; Save parameter requested
	TMNN NFQUF,(P1)		; Do we have a qualifier?
	 RNMXER (NF.MPE)	; It is required
	LOAD T1,NFQUA,(P1)	; Get qualifier - a node address
	CALL RTRGAJ		; Look for the adjacency
	 RNMXER (NF.MPE)	; Not in this area!
	JUMPE AJ,[RNMXND]	; Not reachable
	LOAD T2,AJNHT,(AJ)	; Get hello timer datum
	IDIVI T2,TIMBAS		; Convert to seconds
	SKIPE FUNC		; Is that what was requested?
	 LOAD T2,AJBSZ,(AJ)	; No, then get the block size
	RNMXOK			;  and return success

	ENDSV.

	SUBTTL Network Management -- READ node/executor state

;Call:
;	P2/ Reachability vector pointer
;
;	CALL NMXRNS
;	RET  T1/ contains error code if error else unchanged
;	     T2/ contains state
;
;Context: Jsys

NMXRNS:	TMNN RNLCL,(P2)		; Yes, for the local node?
	IFSKP.
	  MOVE T2,DCNSTA	; Get DECnet state
	ELSE.
	  MOVX T2,RM.UNR	; Assume unreachable
	  SKIPN ENFLG		; Endnode?
	  IFSKP.
	    TMNE <RNMBY,RNCCH>,(P2) ; Maybe reachable?
	     MOVX T2,RM.REA	; Yes
	  ELSE.
	    TMNE RNRCH,(P2)	; Is it reachable?
	     MOVX T2,RM.REA	; Yes, say so
	  ENDIF.
	ENDIF.
	RNMXOK

	SUBTTL Network Management -- Read circuit state

;Call:	T1/ Default success flag
;	RC/ Circuit block
;	CALL NMXRCS
;	RET  T1/contains error code if error else unchanged
;
;Use: Only T1,T2 (must preserve all others)
;Context: Jsys

NMXRCS:	LOAD T2,RCSTA,(RC)	; Get circuit state
	MOVE T2,[RNS.OF		; Off is off
		 RNS.ST		; Rejected is starting
		 RNS.ST		; Failed is starting
		 RNS.ST		; Wait is starting
		 RNS.ST		; Init wait is starting
		 RNS.ST		; Verification wait is also
		 RNS.ST		; I guess testing is too
		 RNS.ON](T2)	;  and running is on		     
	RNMXOK

	SUBTTL Network Management -- Set/Clear executor state

;Call:	T1/ Default success flag
;	T2/ New value
;	P2/ Reachability vector
;	CALL NMXSES
;	RET  T1/contains error code if error else unchanged
;
;Use: Only T1,T2
;Context: Jsys

NMXSES:	TMNN RNLCL,(P2)		; Is this for the executor
	 RNMXER (NF.PNA)	; No, can't do it then
	MOVE T1,DCNSTA		; Get DECnet state
	CAIE T1,(T2)		; State changing?
	 RNMXOK			; No, just a NOP
	SKIPE T2		; Is new state off?
	IFSKP.			; Yes
	  CALL RTROFF		; Then turn off DECnet
	ELSE.
	  CALL RTRON		;  else turn it on
	ENDIF.
	RNMXOK			; Indicate success

	SUBTTL Network Management -- Set/Clear circuit state

;Call:	T1/ Default success flag
;	T2/ New value
;	RC/ Circuit block
;	CALL NMXSCS
;	RET  T1/contains error code if error else unchanged
;
;Use: Only T1,T2 (must preserve all others)
;Context: Jsys

NMXSCS:	LOAD T1,RCSTA,(RC)	; Get current state
	CAIE T2,NCK.OF		; Is new state off?
	IFSKP.
	  CAIN T1,RCS.OF	; Is current state off?
	   RNMXOK		; Yes, just a NOP
	  SETZ T1,		; **** Error type? ***
	  CALL RTRZCB		; Clean out the circuit block
	  CALL RTRSAO		; Set any remaining adjacencies to unused
	  SETOM RTRRCF		; Set recompute topology flag
	  CALL R2KCLS		; Shut the circuit down
	ELSE.
	  CAIE T1,RCS.OF	; Current state off?
	  IFSKP.
	    CALL R2KINI		; Attempt to start circuit
	    IFNSK.
	      SETZRO RCTIN,(RC)	; Clear restart timer
	      RNMXER (NF.OPF)	;  Failed!
	    ENDIF.
	  ENDIF.
	ENDIF.
	RNMXOK			; Indicate success

	SUBTTL Network Management -- Show counters
	SUBTTL Network Management -- Show and zero counters

;NMXSHC - called to show counters

;Call:	T2/ address of NF block
;	CALL NMXSHC
;	 +1 on error with code in T1
;	+2 on success
;
;Context: Jsys

;NMXSZC - called to show and zero counters

;Call:	T2/ address of NF block
;	CALL NMXSZC
;	 +1 on error with code in T1
;	+2 on success
;
;Context: Jsys

	XSWAPCD
NMXSHC:	SKIPA T3,[NF.COU]	;Load function code and skip
NMXSZC:	MOVX T3,NF.SZC		;Load function code
	STKVAR <FUNC>
	MOVEM T3,FUNC
	MOVE P1,T2		;Move NF pointer to where it should be
	LOAD T1,NFETY,(P1)	;Get the entity type
	CAIE T1,.NTNOD		;Is request for a node entity?
	IFSKP.
	  LOAD T1,NFEID,(P1)	;Get the entity ID
	  CAME T1,RTRNAD	;Is it us?
	   RNMXND		;No, then nothing to return
	  XMOVEI T1,EXCTAB	;Address of executor counter table
	  MOVEI T2,EXCTBL	; and its length
	ELSE.
	  CAIE T1,.NTCKT	;No, maybe circuit
	  IFSKP.
	    LOAD T1,NFEID,(P1)	;Get circuit identifier
	    CALL RTRGCB		;Get the circuit block
	     RNMXER (NF.URC)
	    XMOVEI T1,CICTAB	;Address of circuit counter table
	    MOVEI T2,CICTBL	; and its length
	  ELSE.
	    RNMXER (NF.FNS)	;We don't do any others
	  ENDIF.
	ENDIF.

;Call NTCTRS to do the real work

	MOVE T3,FUNC		;Get function to do
	CALLRET NTCTRS		;Read the counters and return

	ENDSV.

	SUBTTL Network Management -- Return list

;NMXRET  - Return list of entities

;Call	T2/ Address of NM block

NMXRET:	MOVE P1,T2		; Save address of NM block
	TMNN NFBFF,(P1)		; Buffer present?
	 RNMXER (NF.MPE)	;  Must have one for this stuff
	LOAD T1,NFBLN,(P1)	; Get the buffer length
	SKIPG T1
	 RNMXER (NF.MPE)	; NTMAN/NML screwed up	
	LOADE T2,NFSEL,(P1)	; Get the selector type
	CAXL T2,.NTSGN		; Range check the selection criteria
	 CAXLE T2,.NTKNO	; If not between SIGNIFICANT & KNOW
	  RNMXER (NF.MPE)	;  we don't do it
	LOAD T1,NFETY,(P1)	; Get entity type
	CAIE T1,.NTNOD		; Is this a node entity request?
	IFSKP.
	  CALLRET <-.NTSGN>+@[
		IFIW <NMXILS&777777> ; SIGNIFICANT nodes not supported
		IFIW <NMXSAN&777777> ; ADJACENT nodes
		IFIW <NMXILS&777777> ; LOOP Nodes
		IFIW <NMXSAX&777777> ; ACTIVE Nodes
		IFIW <NMXSKN&777777>](T2) ; KNOWN Nodes
	ELSE.
	CAIE T1,.NTCKT		; Is the entity circuit?
	  IFSKP.
	  CALLRET <-.NTSGN>+@[
		IFIW <NMXILS&777777> ; SIGNIFICANT nodes not supported
		IFIW <NMXILS&777777> ; ADJACENT circuits
		IFIW <NMXILS&777777> ; LOOP circuits
		IFIW <NMXSAC&777777> ; ACTIVE circuits
		IFIW <NMXSKC&777777>](T2) ; KNOWN circuits
	  ELSE.
	    RNMXER (NF.FNS)	; We don't do any others
	  ENDIF.
	ENDIF.

NMXILS:	RNMXER (NF.MPE)		; Error on NTMAN's part

	SUBTTL Network Management -- Show known/active nodes

;Call:	P1/ NF block
;	P2/ Scratch

NMXSAX:	TDZA T1,T1		; "Active nodes"
NMXSKN:	MOVEI T1,1		; "Known nodes"
	STKVAR <FUNC>
	MOVEM T1,FUNC
	LOAD T4,NFBUF,(P1)	; Get the buffer address
	LOAD T1,NFBLN,(P1)	; Get length of buffer
	CAMGE T1,RTRMXN		; Is it big enough?
	 RNMXER (NF.MPE)	; NTMAN got it wrong
	SKIPE FUNC
	 AOS T4			; Starting at node 1 position for "known"
	MOVE T3,RTRNRV		; Address of reach vector
	AOS T3			; Start at node 1
	MOVEI T1,1		; Start loop at 1 (this will be node number)
	MOVE T2,RTRHOM		; Get the local area number
	LSH T2,^D10		; Position to area field
	SETZ P2,		; Count is zero
	DO.
	  TMNN RNRCH,(T3)	; Is this node reachable?
	  IFSKP.
	    MOVEM T1,(T4)	; Put address into buffer
	    IORM T2,(T4)	; Set the area number
	    AOJ P2,		; Count it
	    AOJ T4,		; Advance buffer pointer
	  ELSE.
	    SKIPE FUNC
	     AOJ T4,		; Advance pointer if "known"
	  ENDIF.
	  AOJ T1,		; Advance node number
	  AOJ T3,		; Step to next node in vector
	  CAMG T1,RTRMXN	; Have we reached the top of the vector?
	  LOOP.			; No, loop until done
	  STOR P2,NFBLN,(P1)	; Save count for NTMAN
	  RETSKP		; Yes, return success
	ENDDO.
	ENDSV.

	SUBTTL Network Management -- Show adjacent nodes

;Call:	P1/ NF block

NMXSAN:	SAVEAC <Q1,Q2>		; We need more than the temps
	SETZ P2,		; Count starts at 0
	LOAD T2,NFBLN,(P1)	; Get length of buffer
	LOAD T4,NFBUF,(P1)	; Get buffer address
	ADD T2,T4		; Compute end of buffer
	SKIPA Q1,RTRCBQ		; Point to first circuit
NMXSN1:	LOAD Q1,RCNXT,(Q1)	; Get next circuit
	JUMPE Q1,NMXSN4		; Finished, return success
	LOAD T1,RCSTA,(Q1)	; Get circuit state
	CAIN T1,RCS.OF 		; Is state "off"?
	 JRST NMXSN1		; Yes, step to next circuit
	LOAD Q2,RCAJQ,(Q1)	; Get first in queue of adjacencies
NMXSN2:	JUMPE Q2,NMXSN1		; None, try next circuit
	LOAD T1,AJSTA,(Q2)	; Get adjacency state
	CAIE T1,ADJ.UP		; Is it up?
	 JRST NMXSN3		; No, skip it then
	CAML T4,T2		; Check to be sure we don't run off end
	 RNMXER (NF.MPE)	; NTMAN error if not enough room
	LOAD T1,AJADR,(Q2)	; Get node address
	MOVEM T1,(T4)		; Save into buffer
	AOJ T4,			; Advance buffer
	AOJ P2,
NMXSN3:	LOAD Q2,AJNXT,(Q2)	; Step to next adjacency
	JRST NMXSN2		; Try next
NMXSN4:	STOR P2,NFBLN,(P1)	; Save count
	SKIPN T1,P2
	 RET
	RETSKP

	SUBTTL Network Management -- Show active circuits

;Call:	P1/ NF block

NMXSAC:	LOAD T2,NFBLN,(P1)	; Get length of buffer
	LOAD T4,NFBUF,(P1)	; Get buffer address
	ADD T2,T4		; Compute end of buffer
	SETZ P2,		; Intialize count
	SKIPA T3,RTRCBQ		; Point to first circuit
NMXSA1:	LOAD T3,RCNXT,(T3)	; Get next circuit
	JUMPE T3,NMXSA2		; Finished, return success
	LOAD T1,RCSTA,(T3)	; Get circuit state
	CAIN T1,RCS.OF 		; Is state "off"?
	 JRST NMXSA1		; Yes, step to next circuit
	CAML T4,T2		; Check to be sure we don't run off end
	 RNMXER (NF.MPE)	; NTMAN error if not enough room
	LOAD T1,RCLID,(T3)	; Get circuit ID
	MOVEM T1,(T4)		; Save into buffer
	AOS P2
	AOJA T4,NMXSA1		; Advance buffer and try another
NMXSA2:	STOR P2,NFBLN,(P1)	; Save count
	SKIPN T1,P2
	 RET
	RETSKP

	SUBTTL Network Management -- Show known circuits

;Call:	P1/ NF block

NMXSKC:	LOAD T2,NFBLN,(P1)	; Get length of buffer
	LOAD T4,NFBUF,(P1)	; Get buffer address
	ADD T2,T4		; Compute end of buffer
	SETZ P2,
	SKIPA T3,RTRCBQ		; Point to first circuit
NMXSK1:	LOAD T3,RCNXT,(T3)	; Get next circuit
	JUMPE T3,NMXSK2		; Finished, return success
	CAML T4,T2		; Check to be sure we don't run off end
	 RNMXER (NF.MPE)	; NTMAN error if not enough room
	LOAD T1,RCLID,(T3)	; Get circuit ID
	MOVEM T1,(T4)		; Save into buffer
	AOJ P2,			; Count it
	AOJA T4,NMXSK1		; Advance buffer and try another
NMXSK2:	STOR P2,NFBLN,(P1)	; Save count
	SKIPN T1,P2
	 RET
	RETSKP

	SUBTTL Network Management -- Return list of adjacencies on a circuit

NMXRAL:	SAVEAC <Q1,Q2>		; We need more than the temps
	LOAD T2,NFBLN,(P1)	; Get length of buffer
	LOAD Q2,NFBUF,(P1)	; Get buffer address
	ADD T2,Q2		; Compute end of buffer
	LOAD T1,NFEID,(P1)	; Get circuit identifier
	SETZ T3,		; Count of entries written to buffer
	LOAD Q1,RCAJQ,(RC)	; Get first in queue of adjacencies
NMXRA1:	JUMPE Q1,NMXRA3		; None, then done
	LOAD T1,AJSTA,(Q1)	; Get adjacency state
	CAIE T1,ADJ.UP		; Is it up?
	 JRST NMXRA2		; No, skip it then
	CAML Q2,T2		; Check to be sure we don't run off end
	 RNMXER (NF.MPE)	; NTMAN error if not enough room
	LOAD T1,AJADR,(Q1)	; Get node address
	MOVEM T1,(Q2)		; Save into buffer
	ADDI T3,1		; Count as written
	AOJ Q2,			; Advance buffer
NMXRA2:	LOAD Q1,AJNXT,(Q1)	; Step to next adjacency
	JUMPN Q1,NMXRA1		; Try next
NMXRA3:	STOR T3,NFBLN,(P1)	; Save count of number written for NTMAN
	MOVE T1,T3		; T1 is a success flag
	RET

	XRESCD

	SUBTTL Network Management Event Interface -- Router Event Types

;These are the various events that occur in router which are reported
;to network management.

DEFINE EVENTS,<
	RE APL,0, NON,<RTEPKH,RTENOD> ;AGED PACKET LOSS
	RE NUR,1, CKT,<RTEPKH,RTENOD> ;NODE UNREACHABLE PACKET LOSS
	RE NOR,2, CKT,<RTEPKH,RTENOD> ;NODE OUT-OF-RANGE PACKET LOSS
	RE OPL,3, CKT,<RTEPKH,RTENOD> ;OVERSIZED PACKET LOSS
	RE PFE,4, CKT,<RTEPKB,RTENOD> ;PACKET FORMAT ERROR
	RE PRL,5, CKT,<RTEPKH,RTENOD,RTEHIA> ;PARTIAL ROUTING UPDATE LOSS
	RE VRJ,6, CKT,RTENOD	;VERIFICATION REJECT
	RE LDL,7, CKT,RTEREA	;CIRCUIT DOWN, CIRCUIT FAULT
	RE ADS,8, CKT,<RTEREA,RTEPKH> ;ADJACENCY DOWN, SOFTWARE FAULT
	RE ADO,9, CKT,<RTEREA,RTEPKH,RTEEXN> ;ADJACENCY DOWN, OPERATOR FAULT
	RE LUP,10,CKT		;CIRCUIT UP
	RE IFL,11,CKT,RTEREA	;INITIALIZATION FAILURE, CIRCUIT FAULT
	RE IFS,12,CKT,<RTEREA,RTEPKH> ;INITIALIZATION FAILURE, SOFTWARE FAULT
	RE IFO,13,CKT,<RTEREA,RTEPKH> ;INITIALIZATION FAILURE, OPERATOR FAULT
	RE NRC,14,NOD,RTESTA	;NODE REACHABILITY CHANGE
	RE AUP,15,CKT,RTENOD	;ADJACENCY UP
	RE ARJ,16,CKT,RTENOD	;ADJACENCY REJECT
	RE ARC,17,ARE,RTENOD	;AREA REACHABILITY CHANGE
	RE AJD,18,CKT,RTENOD	;Adjacency down - Address change
	RE ADO,19,CKT,RTENOD	;Adjacency down, operator initiated
>


DEFINE RE(EVENT,TYPE,ENTTYP,PARAMS),<
	RE.'EVENT==^D<TYPE>>	;DEFINE THE RE MACRO

;Now expand the symbols.

	EVENTS
;Now define the processor macro.

DEFINE RE(PREFIX,VALUE,ENTTYP,PARAMS),<
	IFIW [MOVX T1,.NT'ENTTYP
	      STOR T1,NEETP,(P1)
	      SETZ T4,		;;INITIALIZE THE COUNT
	IRP <PARAMS>,<
	      CALL PARAMS	;;STICK ON THE PARAMETER DATA
	>
	      STOR T4,NEDLN,(P1) ;;GIVE ARG BLOCK THE LENGTH
	      RET]
>

;Make a table of event processors.

RTETAB:	EVENTS
	RET.LN==.-RTETAB
	RET.MX==<.-RTETAB>-1

	SUBTTL Network Management Event Interface -- Event Reason Definitions

;These are the various reasons which may be put in the reason field of
;events that include REASON as a event parameter.

	DEFINE REASON(SUFFIX,VALUE),<
	XP RS.'SUFFIX,^D'VALUE>

	REASON LSL,0		;Circuit synchronization lost
	REASON DTE,1		;Data errors
	REASON UPT,2		;Unexpected packet type
	REASON RUC,3		;Routing update checksum error
	REASON ANA,4		;Adjacent node address change
	REASON VRT,5		;Verification receive timeout
	REASON VSK,6		;Version skew
	REASON ANO,7		;Adjacency address out of range
	REASON ABS,8		;Adjacent node block size too small
	REASON IVS,9		;Invalid verification seed value
	REASON ALT,10		;Adjacent node listener receive timeout
	REASON ALI,11		;Adjacent node listener received invalid data
	REASON CFD,12		;Call failed
	REASON VPR,13		;Verification password required from P3 node
	REASON DBA,14		;Dropped by adjacent node

	PURGE REASON

	SUBTTL Network Management Event Interface -- RTNEVT - Event Reporter

;RTNEVT - Report Router event
;
; Call:
;	T1/ Event type
;	T2/ Entity ID (we know the entity type from RTETAB)
;	T3/ Event specific word (REASON, STATUS, etc.)
;	T4/ Message Block Pointer or zero if none given
;		(Message Block must be DNGINIized before this is called)
;
; Return:
;	RET			;ALWAYS
;
; Uses: T1-T4
;
;This calls something which will call network management to log this event
;which has taken place.  This routine is called by the EVENT macro.

	EVTMLN==^D50		;MAXIMUM LENGTH OF EVENT PARAMETER DATA (BYTES)

RTNEVH:	SKIPA CX,[^D96]		;Special event class
RTNEVT:  SETZ CX,
	MOVEM CX,ECLASS
	SAVEAC <P1,P2,MB,MS>	;SAVE SOME ACS
	STKVAR <EVTSIG>		;Flag if we should use signal processor
	SETZM EVTSIG		;Initialize to "not a signal"
	SKIPL P2,T1		;RANGE CHECK THE
	CAILE P2,RET.MX		;EVENT TYPE
	BUG.(CHK,ROUUET,ROUTER,SOFT,<Unknown event type in RTNEVT>,,<

Cause:	The monitor supplied us with a bad event code.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.  Look for someone smashing T1 or 
	a problem with the EVENTS macro.
>,RTN)

	MOVE P1,T2		;SAVE THE ENTITY-ID
	MOVEM T3,RTREVW		;SAVE THE EVENT ARGUMENT
	MOVE MB,T4		;Presumed MB pointer to MB
;Check if event should be thrown away
	CAIE P2,RE.LDL		;Is this a line down event?
	 JRST RTNEV2		;No, then filter it
	LOAD T1,LIDEV,+P1	;Get the device type
	CAIN T1,LD.DTE		;DTE device?
	 JRST RTNEV4		;No filtering for DTE's

RTNEV2:	MOVX T1,.NCRTR		;ROUTER event class
	STOR T1,FACCL,+T2
	STOR P2,FACTY,+T2	; and event type to T2
	MOVX T1,EV.FIL		;Function code "filter event"
	CALL NMXEVT
	  RET			;  -throw it away
	TRNA	

RTNEV4:	SETOM EVTSIG		;Send to signal processor

	SKIPN RTRECP		;Verify that EC pointer is non-zero
	  RET			;  -was zero, must have failed to initialize
;Ok, log event
	SKIPN MB		;SET UP MESSAGE BLOCK (IF ANY)
	JRST RTNEV5		;NOT THERE, DON'T TRY TO SET POSITION

	MOVE T1,MB		;PASS POINTER TO MESSAGE BLK TO DNGINI
	CALL DNGINI		;SET UP FOR GETTING BYTES OUT OF MSG BLK
	CALL DNRPOS		;GET OUR CURRENT POSITION IN MESSAGE
	OPSTRM <EXCH T1,>,RMMK1,(MB) ;EXCHANGE WITH TOP OF MESSAGE POSITION
	CALL DNGPOS		;GO TO THAT POSITION

RTNEV5:	MOVX T1,NE.LEN+<<EVTMLN+3>/4> ;GET ENOUGH FOR ARG BLOCK AND
				; MAXIMUM AMOUNT OF EVENT PARAMETER DATA
	CALL DNGWDZ		;GET THE WORDS
	 BUG.(INF,ROUCGV,ROUTER,SOFT,<Couldn't get memory for event arg block>,,<

Cause:	DECnet has exhausted its free space.

Action:	This BUG is informational and no action is required.  However, you may
	wish to investigate why there is no more DECnet free space.
>,RTN,<DB%NND>)			;[7.1210]
	STOR P1,NEEID,(T1)	;PUT ENTITY-ID IN EVENT BLOCK
	MOVE P1,T1		;SAVE THE POINTER TO THE BLOCK
	MOVE T1,RTRECP		;Get EC pointer
	STOR T1,NEECP,(P1)	; and store it in NE block
	STOR P2,NECTY,(P1)	;PUT THE EVENT TYPE IN THE ARG BLOCK
	SKIPN T1,ECLASS		;Special event class is 96. If 0 use Router's
	 MOVX T1,.NCRTR		;THE EVENT CLASS IS ROUTER
	STOR T1,NECCL,(P1)	;PUT IN NE ARG BLOCK
	XMOVEI T1,NE.LEN(P1)	;MAKE A FULLWORD POINTER TO DATA
	STOR T1,NEDAT,(P1)	;STORE POINTER TO IT IN ARG BLOCK
	MOVE T1,[POINT 8,NE.LEN(P1)] ;MAKE UP BYTE POINTER TO PARAMETER DATA
	EXCH T1,P2		;SWITCH FUNCTION AND POINTER
	CALL @RTETAB(T1)	;CALL THE PARAMETER PROCESSOR

	JUMPE MB,RTNEV6		;DON'T REPOSITION IN NO-EXISTANT MESSAGE
	LOAD T1,RMMK1,(MB)	;GET OUR LAST MESSAGE POSITION
	CALL DNGPOS		;GO TO THERE

RTNEV6:	MOVX T1,EV.LOG		;Assume function code "log an event"
	SKIPE EVTSIG		;Should this be sent to the signal processor?
	 MOVX T1,EV.SIG		;Do a signal since it is guaranteed to get thru
	MOVE T2,P1		; and NE pointer in T2
	CALL NMXEVT		;CALL THE EVENT PROCESSOR
	 TRN
	RET			;Return, NTMAN will deallocate NE block

	SUBTTL Network Management Event Interface -- Event Parameter Processors

;Put a packet header in the NE argument block string.  This corresponds to
;parameter 0 for circuit events.


RTEPKH:	STKVAR <MSGFLG>
	SKIPN MB		;MUST HAVE A MESSAGE BLOCK HERE
	BUG.(CHK,ROUEHM,ROUTER,SOFT,<No Message Block for Event data>,,<

Cause:	We are attempting to read data from an MB to report in an event but
	the caller failed to supply a message address.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.  Check caller and see why it didn't 
	supply a message block address.
>,RTN)
	MOVEI T1,0		;GET PARAMETER NUMBER
	MOVEI T2,2		;GET NUMBER OF BYTES
	CALL PUTNBT		;INSTALL THE BYTES SWAPPED

	CALL DNG1BY		;GET THE "FIRST" BYTE FROM RTR MESSAGE
	 RET			;COULND'T GET IT, JUST RETURN
	TXZN T1,RM%MZ1		;IS THE PAD FLAG SET?
	IFSKP.
	  CALL PADSKP		;Skip over any pad bytes (NI) and return with
	   RET			; first byte of message.  Error if PADSKP fails
	ENDIF.
	MOVEM T1,MSGFLG		;SAVE MESSAGE FLAGS FOR LATER
	TMNN T1,RM%CTL		; Is this a control message?
	 TXNN T1,RM%MZ3		; No, is it a long format data header?
	IFSKP.
	  MOVEI T1,313		;Yes, then a coded multiple with 11 fields
	  CALL PUTBYT
	  MOVEI T1,041		;Data type = HEX image - one byte
	  CALL PUTBYT
	  MOVE T1,MSGFLG	;Recover message flags
	  CALL PUTBYT
	  CALL PUTENA		;Put in destination address
	   RET
	  CALL PUTENA		; and the source address
	   RET
	  CALL PUTDU1		;Next area router
	   RET
	  CALL PUTDU1		;Visit count
	   RET
	  MOVEI T1,041		;Data type = Hex number - one byte
	  CALL PUTBYT
	  CALL DNG1BY
	   RET
	  CALL PUTBYT		;Service class
	  CALL PUTDU1		; and finally the protocol type
	   TRN
	ELSE.			;Here if control or short format data
	  TXNE T1,RM%CTL	;WAS IT A CONTROL MESSAGE?
	   SKIPA T1,[302]	;YES, CODED MULTIPLE, TWO FIELDS
	  MOVEI T1,304		; NO, CODED MULTIPLE, FOUR FIELDS
	  CALL PUTBYT		;INSTALL DATA TYPE
	  MOVEI T1,041		;NOT CODED, HEX NUMBER OF 1 BYTE
	  CALL PUTBYT		;INSTALL IT
	  MOVE T1,MSGFLG	;Recover message flag byte
	  CALL PUTBYT		;OUTPUT IT
	  TXNE T1,RM%CTL	;IS IT A CONTROL MESSAGE???
	  IFSKP.
	    CALL PUTDU2		;Destination address
	     RET
	  ENDIF.
	  CALL PUTDU2		;Source address
	   RET
	  MOVE T1,MSGFLG	;GET BACK MESSAGE HEADER
	  TXNE T1,RM%CTL	;IS IT A CONTROL MESSAGE
	   RET			;YES, SKIP THIS ONE TOO
	  CALL PUTDU1		;No, include the the visit count
	   TRN
	ENDIF.
	RET

;Put a packet beginning in the NE argument block string.

RTEPKB:	SKIPN MB		;MUST HAVE A MESSAGE BLOCK HERE
	BUG.(CHK,ROUEHB,ROUTER,SOFT,<No Message Block for Event data>,,<

Cause:	We are attempting to read data from an MB to report in an event but
	the caller failed to supply a message address.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.  Check caller and see why it didn't 
	supply a message block address.
>,RTN)
	MOVEI T1,1		;GET PARAMETER NUMBER
	MOVEI T2,2		;GET NUMBER OF BYTES
	CALL PUTNBT		;INSTALL THE BYTES SWAPPED
	CALL DNG1BY		;GET THE FIRST BYTE
	 RET			;RAN OUT, GIVE ERROR RETURN
	TXZN T1,RM%MZ1		;IS THE PAD FLAG SET?
	IFSKP.
	  CALL PADSKP		;Skip over any pad bytes (NI) and return with
	   RET			; first byte of message.  Error if PADSKP fails
	ENDIF.
	MOVEI T1,1		;Back up a byte so we are pointing to byte
	CALL DNBKBY		; containing the message flags again
	CALL PUTIMG		;And now the first 6 bytes of the message
	 TRN			;Ignore erorrs here
	RET

;Put the Highest Address in the NE argument block string.

RTEHIA:	MOVEI T1,2		;GET PARAMETER NUMBER
	MOVEI T2,2		;GET NUMBER OF BYTES
	CALL PUTNBT		;INSTALL THE BYTES SWAPPED
	MOVEI T1,002		;Data type - decimal unsigned, two bytes
	CALL PUTBYT
	MOVE T1,HIADDR		;Get highest address
	MOVEI T2,2		;Number of bytes to transfer
	CALL PUTNBT		;Put data into event buffer
	 TRN
	RET

;Put a node address in the NE argument block string.

RTENOD:	MOVEI T1,3		;GET PARAMETER NUMBER
RTEEX1:	MOVEI T2,2		;GET NUMBER OF BYTES
	CALL PUTNBT		;INSTALL THE BYTES SWAPPED

	MOVEI T1,301		;CODED MULTIPLE, ONE FIELD
	CALL PUTBYT		;INSTALL DATA TYPE
	MOVEI T1,002		;DECIMAL UNSIGNED, TWO BYTES
	CALL PUTBYT		;INSTALL SUB-DATA TYPE
	MOVE T1,RTREVW		;GET THE NODE NUMBER
	MOVEI T2,2		;NODE NUMBER IS TWO BYTES
	CALLRET PUTNBT		;PUT THE NUMBER IN THE MESSAGE

;Put the Expected Node in the NE argument block string.

RTEEXN:	MOVEI T1,4		;GET PARAMETER NUMBER
	JRST RTEEX1		;OTHEWISE, SAME AS NODE

;Put the REASON type in the NE argument block string.

RTEREA:	MOVEI T1,5		;GET PARAMETER NUMBER
RTEST1:	MOVEI T2,2		;GET NUMBER OF BYTES
	CALL PUTNBT		;INSTALL THE BYTES SWAPPED

	MOVEI T1,201		;CODED, SINGLE FIELD, LENGTH 1 BYTE
	CALL PUTBYT		;STUFF IT

	MOVE T1,RTREVW		;GET THE REASON
	CALLRET PUTBYT		;STUFF IT AND RETURN

;Put the status in the NE argument block.  This is a one byte field
;which we have in RTREVW, so just use RTEREA.

RTESTA:	MOVEI T1,7		;GET PARAMETER NUMBER
	JRST RTEST1		;STATUS PARAM IS JUST LIKE REASON


	SUBTTL Network Management Event Interface -- Event Processor Subroutines

;Put n (in T2) bytes in the string pointed to by the NE argument block.
;It also updates T4, which is the count of bytes put in so far.

PUTNBY:	JUMPE T2,RSKP		;RETURN IF NO MORE BYTES LEFT
	CALL DNG1BY		;GET ONE BYTE FROM THE MESSAGE BLOCK
	 RET			;PROPAGATE FAILURE
	IDPB T1,P2		;STORE THE BYTE IN SOME SPACE
	ADDI T4,1		;UPDATE THE GLOBAL COUNT
	SOJA T2,PUTNBY		;SEE IF WE HAVE TO PUT IN MORE

;Put n (in T2) bytes of the number in T1.

PUTNBT:	JUMPE T2,RTN		;RETURN IF NOTHING LEFT
	IDPB T1,P2		;PUT THE BYTE IN THE MESSAGE
	LSH T1,-^D8		;SHIFT OVER TO THE NEXT BYTE
	ADDI T4,1		;UPDATE THE COUNT
	SOJA T2,PUTNBT		;DO THE REST

;Put one byte (in T1) into the data string for network management

PUTBYT:	IDPB T1,P2		;INSTALL THE BYTE
	AOJA T4,RTN		;INCREMENT THE NUMBER OF BYTES


PUTENA:	CALL PUTDU1		;Area
	 RET
	CALL PUTDU1		;Sub-area
	 RET
	CALLRET PUTIMG		;Now insert the Ethernet address as a HEX
				; image of 6 bytes

PUTDU1: MOVEI T1,001		;Put data type and data into event buffer
	CALL PUTBYT
	CALL DNG1BY		;Read a byte from the message
	 RET
	CALL PUTBYT		; and put it into the event buffer
	RETSKP

PUTDU2:	MOVEI T1,002		;Data type - decimal unsigned, two bytes
	CALL PUTBYT
	MOVEI T2,2		;Number of bytes to transfer
	CALL PUTNBY		;Put data into event buffer
	 RET
	RETSKP

PUTIMG:	MOVEI T1,040		;NOT CODED, HEX IMAGE
	CALL PUTBYT		;INSTALL DATA TYPE
	MOVEI T1,6		;LENGTH OF DATA IS ALWAYS 6 BYTES
	CALL PUTBYT		;INSTALL LENGTH OF DATA
	MOVX T2,6		;WE ALWAYS WANT SIX BYTES
	CALLRET PUTNBY		; PUT THEM IN THE NE BLOCK

	SUBTTL Network Management Event Interface -- Miscellaneous Event Processors

;These are a bunch of routines to report different events.  The events
;here are common to more than one routine, so they are collected
;together in this section.

;RTEMFE - Report Message Format Error Event

RTEMFE:	MOVEM T1,MFEWHO		;Remember who gave us this event
	MOVEM MB,MFEMSG		; and the MB being processed
	LOAD T2,RCLID,(RC)	;GET THE LINE ID FOR ENTITY ID
	SETZ T3,		;Default address to nothing
	SKIPE AJ
	 LOAD T3,AJNAN,(AJ)	;Get address of sender
	EVENT RE.PFE,<Packet format error event>,MB
	AOS RTRCPF		;Count number of errors
	CALLRET FREMSG		;FREE MSG BLK AND RETURN


;RTEVRJ - Report Verficiation Reject Event

RTEVRJ:	LOAD T2,RCLID,(RC)	;GET THE ENTITY ID (CIRCUIT)
	LOAD T3,AJADR,(AJ)	; AND THE NEIGHBOR'S ADDRESS
	MOVE T4,RTRHOM		;GET THE HOME AREA
	DPB T4,[POINTR (T3,RN%ARE)] ;STORE IT IN T3
	EVENT RE.VRJ,<Verification reject event>
	AOS RTRCVR		; Count occurences
	CALLRET FREMSG		;FREE MSG BLK AND RETURN

;RTELDL - Report Circuit Down, Hard Circuit Fault Event

RTELDL:	MOVE T3,T1		;GET THE REASON
	LOAD T2,RCLID,(RC)	;GET THE LINE ID
	EVENT RE.LDL,<Circuit down, circuit fault>
	INCR RCCCD,(RC)		;INCREMENT THE CIRCUIT DOWN COUNTER
	RET			;RETURN, NO MSG TO FREE HERE

;RTELDS - Report Circuit Down, Software Fault Event

RTELDS:	MOVE T3,T1		;GET THE REASON
	LOAD T2,RCLID,(RC)	;GET THE LINE ID
	EVENT RE.ADS,<Adjacency down, software fault>,MB
	SETOM RTRRCF		;Set recompute topology flag
	JN RCBCT,(RC),RTELD1
	INCR RCCCD,(RC)		;Increment the circuit down counter
	CALL RTRZCB		;Clean out the circuit block
	CALL RTRSAO		;Set any remaining adjacencies to unused
	CALLRET FREMSG		;FREE MSG BLK AND RETURN
RTELD1:	SKIPN ENFLG		; Endnode?
	IFSKP.
	  MOVX T1,ADJ.UN	; Set adjacency state to unused
	  STOR T1,AJSTA,(AJ)
	  SETZRO RCDSL,(RC)	; Clear DR address
	ELSE.
	  MOVE T1,AJ		;The adjacency to zap
	  MOVE T2,RC		; and the circuit block it belongs to
	  CALL RTRZAB		;Flush the adjacency block
	ENDIF.
	CALLRET FREMSG		;FREE MSG BLK AND RETURN

;RTELDO - Report Circuit Down, Operator Fault Event

RTELDO:	MOVE T3,T1		;GET THE REASON
	LOAD T2,RCLID,(RC)	;GET THE LINE ID
	EVENT RE.ADS,<Adjacency down, operator fault>,MB
	INCR RCCCD,(RC)		;INCREMENT THE CIRCUIT DOWN COUNTER
	RET


;RTEADO - Report Adjacency Down, Operator Fault Event

RTEADO:	MOVE T3,T1		;GET THE REASON
	LOAD T2,RCLID,(RC)	;GET THE LINE ID
	EVENT RE.ADO,<Adjacency down, operator fault>,MB
	INCR RCAJD,(RC)		;Increment the adjacency down counter
	LOAD T1,AJSTA,(AJ)	;Get the state of the adjacency
	CAXN T1,ADJ.UP		;Was it up?
	 SETOM RTRRCF		; Yes, recompute routing
	JN RCBCT,(RC),RTEAD1	;No circuit down if broadcast
	MOVX T1,RS.ANA		;Event reason: Adjacent node address change
	CALL RTELDO		;Report circuit down - Circuit fault event
	CALL CIRFAI		;Close the port and set reopen time
	CALLRET FREMSG		; and return message

RTEAD1:	SKIPN ENFLG		; Endnode?
	IFSKP.
	  MOVX T1,ADJ.UN	; Set adjacency state to unused
	  STOR T1,AJSTA,(AJ)
	  SETZRO RCDSL,(RC)	; Clear DR address
	ELSE.
	  MOVE T1,AJ		;The adjacency to zap
	  MOVE T2,RC		; and the circuit block it belongs to
	  CALL RTRZAB		;Flush the adjacency block
	ENDIF.
	CALLRET FREMSG		;FREE MSG BLK AND RETURN

;Event Processors - Continued from last page

;RTEINL - Report Initialization Failure, Hard Circuit Fault Event

RTEINL:	MOVE T3,T1		;GET THE REASON
	LOAD T2,RCLID,(RC)	;GET THE LINE ID
	EVENT RE.IFL,<Initialization failure, circuit fault>
	INCR RCCCD,(RC)		;INCREMENT THE CIRCUIT DOWN COUNTER
	RET			;RETURN, NO MSG BLK TO FREE HERE

;RTEINS - Report Initialization Failure, Software Fault Event

RTEINS:	MOVE T3,T1		;GET THE REASON
	LOAD T2,RCLID,(RC)	;GET THE LINE ID
	EVENT RE.IFS,<Initialization failure, software fault>,MB
	INCR RCCCD,(RC)		;INCREMENT THE CIRCUIT DOWN COUNTER
	CALL FREMSG		;FREE MSG BLK AND RETURN
	CALLRET CIRFAI		;RE-INITIALIZE THE DLL

;RTEINO - Report Initialization Failure, Operator Fault Event

RTEINO:	MOVE T3,T1		;GET THE REASON
	LOAD T2,RCLID,(RC)	;GET THE LINE ID
	EVENT RE.IFO,<Initialization failure, operator fault>,MB
	INCR RCCCD,(RC)		;INCREMENT THE CIRCUIT DOWN COUNTER
	CALL FREMSG		;FREE MSG BLK AND RETURN
	CALLRET CIRFAI		;RE-INITIALIZE THE DLL

	SUBTTL Miscellaneous Routines -- RTRSAO - Set Adjacency off line

;RTRSAO - Set all adjacencies associated with a circuit block off line.
;
; Call:
;	RC/ Pointer to circuit block
;
;	RET			;With ADJ(RC) set to unused
;
; Uses: T1,T2,T3

RTRSAO:	SAVEAC AJ
	OPSTR <SKIPA AJ,>,RCAJQ,(RC)	;Get the first adjacency block
RTRSO2:	LOAD AJ,AJNXT,(AJ)	;Get the next one
	JUMPE AJ,RTN
	SETZ T1,
	STOR T1,AJFLA,(AJ)	;CLEAR OUT ALL FLAGS
	STOR T1,AJADR,(AJ)	;CLEAR OUT THE NODE ADDRESS
	MOVX T1,ADJ.UN		;Set adjacency to unused
	STOR T1,AJSTA,(AJ)	;Set it
	LOAD T1,AJRTV,(AJ)	;Get the address of the routing vector
	JUMPE T1,RTRSO2		;If no vector don't smear it
	MOVE T2,RTRMXN		;Get the maximum number of nodes
	ADD T2,T1		;For end of smear
	MOVX T3,RNCHG!RNHOP!RNCST ;Get INFH and INFC and set them in the
	CALL DNSWDS		; vector
	JRST RTRSO2		;Try for another


	SUBTTL Miscellaneous Routines -- RTRZCB - Zap Circuit Block

;RTRZCB - Zap circuit block and report circuit down event
;
; Call: 
;	RC/ Pointer to circuit block
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1

RTRZCB:	TMNE RCBCT,(RC)		;If point-to-point don't free adjacency
	CALL RTRZAA		;Zap all the adjacencies
	SETZ T1,		;Clear some fields
	STOR T1,RCTLS,(RC)	;Time last message sent
	STOR T1,RCTLR,(RC)	; and the time we sent last routing message
	SETZRO <RCSRM,RCSHM>,(RC) ;Clear some flags
	SETZRO RCDSL,(RC)	;Clear address of desiginated router
	RET			;Return to sender

	SUBTTL Miscellaneous Routines -- RTRZAA - Zap all Adjacancies associated with RC

;RTRZAA - Zap all adjacency blocks associated with a circuit block in RC
;
; Call: 
;	RC/ Router circuit block
;
; 	RET			; Return with all adjacencies freed
;
RTRZAA:	LOAD T1,RCAJQ,(RC)	; Pointer to adjacencies
	JUMPE T1,RTN		; None left
	MOVE T2,RC		; Circuit block	
	CALL RTRZAB		; Adjacency must go
	JRST RTRZAA		; Do the next one
	SUBTTL Miscellaneous Routines -- RTRZAB - Zap an adjacency block

;RTRZAB - Zap an adjacency block - Returns adjacency block to DNFWDS
;
; Call: 
;	T1/ Adjacency to zap
;	T2/ Circuit block adjacency belongs to
;
; 	RET			;Return with adjacency cleared out
;				; and adjacency in the off-line queue

RTRZAB:	SAVEAC <P1,P2>
	DMOVE P1,T1
	LOAD T1,AJNTY,(P1)	;Get the adjacency type
	CAIE T1,ADJ.LN		;It it an endnode?
	 JRST RTRZB1		; No
	SOS RTRBEA		;Yes, decrement count of endnode adjacencies
	JRST RTRZB2
RTRZB1:	OPSTR <SKIPE T1,>,AJRTV,(P1) ;Get the adjacencies routing vector
	CALL DNFWDS		;Return it
	SOS RTRBRA		;Decrement count of router adjacencies
	DECR RCNRO,(RC)		; and count of the number on this Ethernet
RTRZB2:	RMVQUE P1,<RC.AJQ(P2)>,AJ.NXT,T1 ;Dequeue the adjacency
	SETZRO AJNXT,(P1)	; Clear next adjacency pointer
	SKIPE T1,AJOFLQ		; Anything in the off-line queue?
	 STOR T1,AJNXT,(P1)	; Yes, link it to this one
	MOVEM P1,AJOFLQ		;  and make this one the first
	MOVEI T1,ADJ.OL		; New state is off-line
	STOR T1,AJSTA,(P1)	;  and set it
	RET	

	SUBTTL Miscellaneous Routines -- RTRMAJ - Make an Adjacency Block

;RTRMAJ - Allocate an adjacency block 
;
; Call:
;	T1/ Flag indicating routing/non-routing node (0=non-routing)
;	RC/ Circuit block
;
; Return:
;	RET			;Couldn't allocate block
;	RETSKP			;Everything worked, (T1) = Adjacency block
;
; Uses: T1-T4

RTRMAJ:	SAVEAC <P1,P2>		;SAVE A PEA OR TWO
	MOVE P2,T1		;Save adjacency type
	MOVX T1,AJ.LEN		;GET THE LENGTH OF AN ADJACENCY BLOCK
	CALL DNGWDZ		;GET THAT MANY WORDS
	 RET			;RETURN A FAILURE
	MOVE P1,T1		;SAVE THE POINTER TO THE ADJACENCY
	JUMPE P2,RTRMA1		;DON'T MAKE ROUTING VECTOR FOR NON-ROUTING NODE
	MOVE T1,RTRMXN		;GET THE MAXIMUM NODE NUMBER
	ADDI T1,1		;ADD ONE FOR NODE ZERO (Nearest area router)
	CALL DNGWDZ		;GET THAT MANY WORDS
	 JRST [MOVE T1,P1	;GET THE ADDRESS OF THE ADJACENCY BLOCK
	       CALLRET DNFWDS]	;FREE THE WORDS AND GIVE ERROR RETURN
	STOR T1,AJRTV,(P1)	;YES, STORE THE ADDRESS OF THE ROUTING VECTOR
	MOVE T2,RTRMXN		;GET THE MAXIMUM NUMBER OF NODES
	ADD T2,T1		;FOR END OF SMEAR
	MOVX T3,RNCHG!RNHOP!RNCST ;GET INFH AND INFC AND CHANGE FLAG
	CALL DNSWDS		;SMEAR THE VECTOR

RTRMA1:	STOR RC,AJCBP,(P1)	;SAVE THE ADDRESS OF HIS CIRCUIT BLOCK
	MOVX T2,ADJ.IN		;THIS IS INITIALIZING
	STOR T2,AJSTA,(P1)	;SAVE IT
	MOVX T2,%RTTM4		;GET THE DEFAULT LISTENER TIME-OUT VALUE
	STOR T2,AJNHT,(P1)	;STORE IT IN THE ADJACENCY BLOCK
	ENDQUE P1,<RC.AJQ(RC)>,AJ.NXT,T1 ;Add adjacency to the queue
	MOVE T1,P1		;GET THE ADDRESS OF THE ADJACENCY BLOCK IN T1
	RETSKP			;RETURN SUCCESS

	SUBTTL Miscellaneous Routines -- RTRMCB - Make a Circuit Block

;RTRMCB - Make a new circuit block and store the defaults
;
; Call:
;	T1/ Line id
;
; Return:
;	RET			;COULDN'T ALLOCATE BLOCK
;	RETSKP			;EVERYTHING WORKED, T1 CONTAINING CIRCUIT BLOCK
;				; POINTER
; Uses: T1-T4

RTRMCB:	SAVEAC P1		;SAVE A PEA
	MOVE P1,T1		;SAVE THE LINE ID
	MOVX T1,RC.LEN		;GET THE LENGTH OF A CIRCUIT BLOCK
	CALL DNGWDZ		;GET THAT MANY WORDS
	 RET			;RETURN A FAILURE

	STOR P1,RCLID,(T1)	;STORE THE LINE ID

	LOAD T2,LIDEV,+RC.LID(T1) ;GET THE TYPE OF DEVICE
	CAIE T2,LD.NI		;Is it for the NI?
	 JRST RTRMC1		;No, must something else
	SETONE RCBCT,(T1)	;Mark as broadcast
	MOVEI T3,%RTMXR		; Set default maximum number of routers
	STOR T3,RCMXR,(T1)	;  for this circuit
RTRMC1:	MOVE T2,KONCST(T2)	;GET DEFAULT COST FOR THIS TYPE OF LINE
	STOR T2,RCCST,(T1)	;STORE IT IN THE CIRCUIT BLOCK
	MOVX T2,RCS.OF		;INITIAL STATE WILL BE "OFF"
	STOR T2,RCSTA,(T1)	;STORE STATE CODE
	MOVE T2,RTRBSZ		; Start with our block size as the minimum
	STOR T2,RCBSZ,(T1)
	MOVX T2,%RTTM3		;GET THE DEFAULT HELLO MESSAGE TIMER VALUE
	STOR T2,RCTM3,(T1)	;STORE IT IN THE CIRCUIT BLOCK

	MOVE P1,T1		;SAVE THE CIRCUIT BLOCK POINTER
	AOS RTRNLN		;INCREMENT THE NUMBER OF CIRCUITS
	CALL DNGTIM		;GET CURRENT TIME OF DAY
	STOR T1,RCSLZ,(P1)	;STORE FOR USE BY SECONDS SINCE LAST ZEROED
	MOVE T1,P1		;RETURN THE CIRCUIT BLOCK POINTER IN T1
	RETSKP			;RETURN SUCCESS

	SUBTTL Miscellaneous Routines -- RTRGCB - Get Circuit Block Pointer

;RTRGCB - Get circuit block pointer from line id
;
; Call:
;	T1/ Line id
;
; Return:
;	RET			;WHEN WE COULDN'T FIND A MATCH
;	RETSKP			;WHEN SUCCESSFUL, WITH RC POINTING TO THE
;				; CIRCUIT BLOCK
;
; Uses: T1,T2
;
;There aren't that many circuits, so a simple search is not too bad.

RTRGCB:	SKIPN RC,RTRCBQ		;START LOOKING AT FIRST CIRCUIT
	RET			;NONE THERE, JUST RETURN
RTRGC1:	LOAD T2,RCLID,(RC)	;GET IT'S LINE ID
	CAMN T1,T2		;IS IT THE ONE WE'RE LOOKING FOR?
	RETSKP			;GOOD RETURN (I SKIP OVER RETSKPS
				; IF YOU DON'T LIKE THAT CHANGE IT)
	LOAD RC,RCNXT,(RC)	;GET THE NEXT CIRCUIT BLOCK
	JUMPN RC,RTRGC1		;GO CHECK IT OUT
	RET			;COULDN'T FIND IT, OH WELL

;RTRGAJ - Find the adjacency associated with a given node
;
; Call:
;	T1/ 16 bit node number
;	RC/ Circuit owning adjacency
;
; Return:
;	RET			; Node is not in our area
;	RETSKP			; Success with AJ pointing to adjacency
;				; block, or 0 if no such adjacency
;
; Uses: T1,T2,AJ

RTRGAJ:	LDB T2,[POINTR(T1,RN%ARE)] ;Get the area number
	CAME T2,RTRHOM		;Is it the same as mine?
	 RET			; No, can't be an adjacency
	LDB T1,[POINTR(T1,RN%NOD)] ;GET JUST THE NODE NUMBER
	OPSTR <SKIPA AJ,>,RCAJQ,(RC) ;Get first adjacency
RTRGJ2:	 LOAD AJ,AJNXT,(AJ)	;Ckeck next adjacency if any
	JUMPE AJ,RSKP		;No more, try next circuit block
	LOAD T2,AJNAN,(AJ)	;Get the node address of this adjacency
	CAME T1,T2		;Do we have a match?
	 JRST RTRGJ2		; Nope. Try again
	RETSKP			;Yes, give good return

; This routine will check the adjacency pointed to by AJ to determine if it is
; a known two-way adjacency.

CK2WAY:	JUMPE AJ,RTN		;Give non-skip if no such adjacency
	LOAD T1,AJSTA,(AJ)	;Get the state
	CAXE T1,ADJ.UP		;Is this a known two-way?
	 RET			; Nope
	RETSKP			;Yes.


;	SUBTTL	Miscellaneous Routines -- CVTSTN

;Convert low order of Ethernet address to 16 bit format

;Call:
;	T2/ Low order (16 bits) of Ethernet address left justified in
;	    string format
;
;Ret:	
;	T1/ 16 bit address
;	T2/ 16 Bit address

CVTSTN:	SETZ T1,		; Address we want is in T2 left justified
	LSHC T1,^D8		; in string format.  Shift nn-2 into T1
	LSH T2,-^D20		; Right justify the area+2
	IORB T1,T2		;  and include the number
	RET

	SUBTTL Miscellaneous Routines -- CPYMSG - Copy all MSDs together

;CPYMSG - Gather all the MSDs into one (IN.MSD) in a new message block
;
; Call:
;	MB/ Pointer to message block to make a copy of
;
; Return:
;	RET			;ON FAILURE
;	RETSKP			;DONE, WITH T1 POINTING TO THE NEW MESSAGE
;
; Uses: T1-T4
;
;Only the portions of the message block which are relavent to Router
;are copied, because the copied message will be sent to NSP, which
;believes that the message has come in over the network.

CPYMSG:	CALL DNCPMS		;COPY MB'S MSDs INTO A NEW BLOCK
	  RET			;PROPOGATE ERROR
				;T1 POINTS TO NEW MSG BLK

;Now copy all the relavent fields.

	LOAD T2,RMFST,(MB)	;GET THE FIRST BYTE
	STOR T2,RMFST,(T1)	; AND COPY IT
	LOAD T2,MBLCL,(MB)	;GET THE COPY OF THE LOCAL BIT
	STOR T2,MBLCL,(T1)	; AND COPY IT
	LOAD T2,RMOAP,(MB)	;GET THE OUTPUT ADJACENCY POINTER
	STOR T2,RMOAP,(T1)	; AND COPY IT
	LOAD T2,RMIAP,(MB)	;GET THE INPUT ADJACENCY POINTER
	STOR T2,RMIAP,(T1)	; AND COPY IT
	LOAD T2,RMICP,(MB)	;GET THE INPUT CIRCUIT
	STOR T2,RMICP,(T1)	; AND COPY IT (MONOTONOUS, ISN'T IT)
	LOAD T2,MBSRC,(MB)	;GET SOURCE NODE ADDRESS
	STOR T2,MBSRC,(T1)	; AND COPY IT INTO THE NEW COPY
	LOAD T2,MBDST,(MB)	;GET THE DESTINATION NODE ADDRESS
	STOR T2,MBDST,(T1)	; AND COPY IT INTO THE NEW COPY
	RETSKP			;RETURN SUCCESS, T1 PTS TO NEW MSG BLK

	SUBTTL Miscellaneous Routines -- RTRGBS - Get maximum blocksize

;RTRGBS - Called by SCLINK to get the maximum blocksize supported
; between this node and the requested node.

;Call:
;	T1/ Node address (16 bit format)

;Return:
;	T1/ Blocksize to use

	INTERN RTRGBS
	XRESCD

RTRGBS:	LDB T2,[POINTR(T1,RN%ARE)] ; Extract the area number
	TXZ T1,RN%ARE		; Clear the area number
	CAME T1,RTRADR		; Local connection?
	IFSKP.
	  LOAD T1,IBBSZ,+IBBLK	; Yes, use requested blocksize
	  RET
	ENDIF.
	SKIPN ENFLG		; Endnode?
	IFSKP.
	  MOVE T1,RTRBSZ	; Then supply default
	  SKIPE T3,RTRCBQ	;  unless the only circuit
	   LOAD T1,RCRBS,(T3)	;  is initialized
	  RET
	ENDIF.
	CAME T2,RTRHOM		; Is it in our area?
	IFSKP.
	  MOVE T2,T1		; Yes, get the number
	  ADD T2,RTRNRV		; Add in the offset to routing vector
	  TMNN RNRCH,(T2)	; Is it reachable?
	  IFSKP.
	    ADD T2,RTROFS	; Yes, index into the output adjacency vector
	    MOVE T2,(T2)	; Get adjacency
	    OPSTR <CAME T1,>,AJNAN,(T2) ; Is it our adjacency?
	    IFSKP.
	      LOAD T1,AJBSZ,(T2); Yes, use its blocksize
	      OPSTR <CAMLE T1,>,IBBSZ,+IBBLK ; If it exceeds our capabilities
	       LOAD T1,IBBSZ,+IBBLK ; return only what we can
	      RET
	    ENDIF.
	  ENDIF.
	ENDIF.
	MOVE T1,RTRBSZ		; No, use default
	RET

	SUBTTL Miscellaneous Routines -- RTRCBS - Get useable blocksize

;Call:
;	T1/ Node address
;	T2/ Suggested blocksize

;Return:
;	T1/ Blocksize we believe will work

	INTERN RTRCBS
	XRESCD

RTRCBS:	STKVAR <NODADR,BSZ>
	MOVEM T1,NODADR		; Save address
	MOVEM T2,BSZ		; Save suggested blocksize
	SKIPN ENFLG		; Endnode?
	IFSKP.
	  TXZ T1,RN%ARE		; Yes, remove area number
	  ADD T1,RTRNRV         ; Add address of cache vector
	  TMNN RNCCH,(T1)	; See if in cache
	  IFSKP.
	    MOVE T1,NODADR	; In cache, get address
	    CALL RTRGBS		; (T1) Get maximum we can handle
	  ELSE.
	    MOVE T1,RTRBSZ	; Not in cache, use default block size
	  ENDIF.
	ELSE.                   ; This is a routing node, so
	  CALL RTRGBS		; (T1) see what segsize we can use
	ENDIF.
	CAMLE T1,BSZ            ; Was what we were given too large?
	MOVE T1,BSZ             ; No, OK to use what we were given
	RET

	ENDSV.

	SUBTTL Miscellaneous Routines -- FREMSG - Toss a Message

;FREMSG - Return an unwanted message to rightful sink
;
; Call: 
;	MB/ Pointing to Message Block
;
; Return: 
;	RET			;ALWAYS
;
; Uses: T1-T4

FREMSG:	SKIPN T1,MB		;GET POINTER TO MESSAGE BLOCK
	BUG.(CHK,ROUZXT,ROUTER,SOFT,<Tried to free msg with MB=0>,,<

Cause:	FREMSG called to free an MB but was given a zero pointer.

Action:	If this BUG persists, make it dumpable and submit an SPR with the
	dump and a copy of MONITR.EXE.  If possible, include any known
	method for reproducing the problem and/or the state of the system
	at the time the BUG was observed.  Check caller and see why no MB 
	address was supplied.
>,RTN)

	TMNE RMODN,(MB)		;DOES NSP WANT THIS BACK?
	CALLRET R2NODN		;YES, GO GIVE "OUTPUT DONE"
				;NO, GIVE MSG TO MEMORY MANAGER
	TRASH MB,		;JUST CAREFUL
	CALLRET DNFMSG		;FREE MESSAGE T1 POINTS TO
	SUBTTL Miscellaneous Routines -- CKSNRM - Normalize Checksum

;CKSNRM - Make full word checksum into 16 bit checksum
;
; Call: 
;	T1/ Full word checksum
;
; Return: 
;	RET			;WITH T1 CONTAINING THE 16 BIT CHECKSUM
;
; Uses: T1-T2

CKSNRM:	MOVE T2,T1		;GET A COPY OF THE CHECKSUM
	TDZE T2,[EXP ^-177777]	;IF ANY OVERFLOW, CLEAR IT
	JRST [LSH T1,-^D16	;ADD OVERFLOW BACK INTO
	      ADDB T2,T1	; THE LOW ORDER BYTES
	      JRST .-1]		;LOOP UNTIL DONE
	RET			;RETURN

;Here to get the uptime in jiffies for the message looper
;This is a separate routine so we don't have switch to section 1
;in so many places.

TSTTIM:	TORESCD
	CALL UPDTCK		; Must be executed in section 1
	TOXRESCD
	RET



	SUBTTL Local Router Storage

	RESDT			;IMPURE STORAGE

IFN FTOPS20,<			;TOPS20 CALLS RTRSEC 10 TIMES A SECOND
SECCNT:	EXP 0			;COUNT-DOWN 100 MS CALLS AT RTRSEC
>				;END IFN FTOPS20
CCHTIM: EXP 0			;INTERVAL COUNTER FOR CACHE FLUSHING (ENDNODE)
RTRCTO:	%RTCTO			;Time we can spend in cache till flushed
RTRNTY:	BLOCK 1			;NODE TYPE FOR LOCAL NODE
ENFLG:	EXP 0			;Endnode (non-routing) flag
RTRNRV:	BLOCK 1			;"NORMAL" ROUTING VECTOR
RTRNOV:	BLOCK 1			;"NORMAL" OUTPUT-CIRCUIT VECTOR
RTROFS:	BLOCK 1			;OFFSET FROM NRV TO NOV
RTNBRA:	%RTBRA			;MAXIMUM NUMBER OF BROADCAST ROUTER ADJACENCIES
RTNBEA:	%RTBEA			;MAXIMUM NUMBER OF BROADCAST ENDNODE ADJACENCIES
RTRPRI:	%RTPRI			;Our priority to be the designated router
RTRSRV:	BLOCK 1			;"SCRATCH" ROUTING VECTOR
RTRSOV:	BLOCK 1			;"SCRATCH" OUTPUT-CIRCUIT VECTOR
RTRMCN:	^D20			;Maximum number of circuits (default)
RTRCBQ:	BLOCK QH.LEN		;CIRCUIT BLOCK QUEUE HEADER
AJOFLQ: 0			;Queue of offline adjacencies to be freed
				; after routing update
RTRNLN:	BLOCK 1			;Number of circuits in use
RTRMXC:	%RTMXC			;Maximum circuit cost
RTRMXH:	%RTMXH			;Maximum hops
RTRMXV:	%RTMXV			;Maximum visits
RTRBRA:	0			;Number of broadcast router adjacencies
RTRBEA:	0			;Number of broadcast endnode adjacencies
RTRRCF:	BLOCK 1			;RECOMPUTE ROUTING FLAG
;RTRVRQ:BLOCK 1			;VERIFICATION REQUIRED FLAG
RTRNAD: BLOCK 1			;Our address in 16 bit format
RTRCKS: BLOCK 1			;CHECKSUM OF ROUTING MESSAGE
RTRLMG:	BLOCK 1			; OFFSET TO LAST ROUTING MESSAGE SENT
				;TO ALLOW US TO SEND OUT THE SEGMENTS
				;IN A DIFFERENT ORDER EACH TIME
RTRTYP:	EXP 4			;OUR TYPE OF NODE IS ROUTING.
RTRTM1:	%RTTM1			;ROUTING MESSAGE TIMER (P-P)
RTRBT1:	%RTBT1			;ROUTING MESSAGE TIMER (BROADCAST)
RTRTM2:	DEC 1000		;Minimum time between routing updates, and
				; Ethernet hello messages.
RTRITM:	%RTITM			;MAX TIME ALLOWED FROM PROTOCOL UP AND TI RCVD 
RTRCRT:	EXP <^D60*^D1000>	;Circuit re-open timer value
BMVTIM: BLOCK 1			;Time of next maybe vector update
BMVIVL: DEC 15000		;Interval between maybe vector updates
RTRALR:	EXP %RTRMA,0		;ID ALL-ROUTERS
RTRAEN:	EXP %RTEMA,0		;ID ALL END-NODES
RTRPRO::EXP 60003	 	;PROTOCOL-TYPE FOR ALL ROUTERS

RTRRSQ: BLOCK QH.LEN		;RESEND QUEUE HEADER
IFN FTOPS20,<
;RTRLOK:	EXP -1			;THE ROUTER "INTERLOCK"
;RTRLKO:	EXP -1			;INTERLOCK OWNER
>
;RTRSSV:	BLOCK 1			;ONCE-A-SEC SERVICE NEEDED FLAG
MFEWHO:	BLOCK 1			; PC of routine detecting message format error
MFEMSG:	BLOCK 1			; MB containing bogus message
HIADDR:	BLOCK 1			; Argument for P.R.U.L. event
RTREVW: BLOCK 1			;EVENT WORD (PLACE TO KEEP REASON, NODE, ETC.)
RTRECP:	EXP 0			;Event communication pointer
ECLASS: EXP 0			;Event class
				;NODE COUNTERS:
RTRCAP:	BLOCK 1			; (900) AGED PACKET LOSS
RTRCNU:	BLOCK 1			; (901) NODE UNREACHABLE PACKET LOSS
RTRCNO:	BLOCK 1			; (902) NODE OUT-OF-RANGE PACKET LOSS
RTRCOP:	BLOCK 1			; (903) OVERSIZED PACKET LOSS
RTRCPF:	BLOCK 1			; (910) PACKET FORMAT ERROR
RTRCPR:	BLOCK 1			; (920) PARTIAL ROUTING UPDATE LOSS
RTRCVR:	BLOCK 1			; (930) VERIFICATION REJECT
IFN FTRTST,<
TSTFLG:	Z
TSTBLK::BLOCK TR.LEN
>
	XRESCD			;BACK TO THE PURE SEGMENT
	SUBTTL End of ROUTER

IFN FTOPS10, .XCMSY             ;.XCREF SOME MACSYM SYMBOLS
IFN FTOPS20, TNXEND		;TOPS-20 ENDING

	END
