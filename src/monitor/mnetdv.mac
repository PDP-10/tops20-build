; Edit= 9178 to MNETDV.MAC on 7-Aug-90 by GSCOTT
;Change one line missed in edit 9177. 
; Edit= 9177 to MNETDV.MAC on 10-Jul-90 by GSCOTT
;Check PRFADR not DEFADR in ADDHO1, allow DBUGIP/2 to always bring up IP.
; Edit= 9170 to MNETDV.MAC on 6-Jun-90 by GSCOTT
;CVHST% should call LCKGTH and ULKGTH so that the host table lock doesn't get
;smashed when DNSRCV relocks the lock after waiting for an answer.
; Edit= 9168 to MNETDV.MAC on 4-May-90 by GSCOTT
;Fix undeserved DNS failures, caused by lots of authority and additional
;records, by increasing the DNS reply buffer size from 512 octets to 1280.
; Edit= 9157 to MNETDV.MAC on 7-Mar-90 by GSCOTT
;Rearrange host tables so that we can remove that gross edit 8828.
; Edit= 9156 to MNETDV.MAC on 7-Mar-90 by GSCOTT
;Implement DNS resolver, including support to read file
;SYSTEM:INTERNET.NAMESERVERS, use of monitor's host tables as a cache of data,
;new IPOPR% function .IPDNS, extend GTHST% functions .GTHSN and .GTHNS, and
;new GTHST% functions .GTHPN, .GTHMX, .GTHAA, .GTHVN, .GTHOS, and .GTHDN.
; Edit= 9135 to MNETDV.MAC on 28-Nov-89 by GSCOTT
;Allow alternate IP address using "IPNIA" interface in INTERNET.ADDRESS. 
; Edit= 9132 to MNETDV.MAC on 26-Oct-89 by GSCOTT
;Allow dot between octets and range check octets in INTERNET.ADDRESS file.
; Edit= 9128 to MNETDV.MAC on 20-Oct-89 by GSCOTT
;Make TCP/IP subnetting work by making the LOGCIAL-HOST-MASK keyword in the
;INTERNET.ADDRESS file work properly.
; Edit= 9111 to MNETDV.MAC on 22-Jun-89 by WONG (TCO none)
;Change RETERR to RETBAD in routines GTHHNN and GTHNUM so that we can return
;back to the .GTHST% to unlock GTHLCK and not back to the user without
;unlocking GTHLCK.
; Edit= 9108 to MNETDV.MAC on 14-Jun-89 by GSCOTT
;MNTSET should do work directly rather than depending on the internet fork and
;add code to have a reasonable interlock on the host tables. 
; Edit= 9037 to MNETDV.MAC on 29-Nov-88 by LOMARTIRE
;Fix bug in .GTHHN function of GTHST% and use a better error code
; Edit= 9006 to MNETDV.MAC on 8-Nov-88 by LOMARTIRE
;Merge Production changes to BUG text
; Edit= 8982 to MNETDV.MAC on 13-Oct-88 by GSCOTT
;Prevent "[Internet Network ...]" messages from being split up on the CTY. 
; Edit= 8975 to MNETDV.MAC on 30-Sep-88 by GSCOTT
;Speed up reading HOSTS.TXT file by a factor of 10, include rewrite of ADRINI
;as well as HSTINI and better error recovery for both routines.
; Edit= 8969 to MNETDV.MAC on 13-Sep-88 by GSCOTT
;Prevent ILLUUO and ILMNRF BUGHLTs when there is a bad format to HOSTS.TXT or
;INTERNET.ADDRESS files. Fix up some error messages that report format errors
;in these files.
; Edit= 8926 to MNETDV.MAC on 22-Aug-88 by LOMARTIRE
;Improve BUG. documentation
; Edit= 8828 to MNETDV.MAC on 13-Apr-88 by RASPUZZI
;Prevent SKDPF1s and PITRAPs the right way now. HSTSTS is now greater than
;400000 and HOSTNN will be soon. Add them directly to the hash block address
;instead of using them in effective address calculation. Gross but it will
;hopefully work.
; Edit= 8806 to MNETDV.MAC on 18-Mar-88 by GSCOTT (TCO 7.1261)
;Install TCO 7.1261 in autopatch sources. 
; UPD ID= 8689, RIP:<7.MONITOR>MNETDV.MAC.6,  18-Mar-88 10:52:50 by GSCOTT
;TCO 7.1261 - Set NOADDR to be not normally dumpable.
; UPD ID= 8670, RIP:<7.MONITOR>MNETDV.MAC.5,  26-Feb-88 10:36:52 by GSCOTT
;TCO 7.1243 - Use SYSTEM:HOSTS.DEBUG if DBUGSW is greater than one.
; UPD ID= 8554, RIP:<7.MONITOR>MNETDV.MAC.4,  11-Feb-88 11:03:14 by GSCOTT
;TCO 7.1218 - Update copyright date.
; UPD ID= 8425, RIP:<7.MONITOR>MNETDV.MAC.3,   4-Feb-88 13:29:58 by GSCOTT
;TCO 7.1210 - Set NOHSTN normally not dumpable.
; UPD ID= 2123, SNARK:<6.1.MONITOR>MNETDV.MAC.11,   5-Jun-85 09:58:02 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 1957, SNARK:<6.1.MONITOR>MNETDV.MAC.10,  12-May-85 14:54:53 by PAETZOLD
;TCO 6.1.1380 - Make HOSTN larger.
; UPD ID= 1608, SNARK:<6.1.MONITOR>MNETDV.MAC.9,   8-Mar-85 11:53:53 by PAETZOLD
;Document BUGxxx's
; UPD ID= 1570, SNARK:<6.1.MONITOR>MNETDV.MAC.8,  26-Feb-85 17:17:32 by PAETZOLD
;document BUGxxx's
; UPD ID= 1235, SNARK:<6.1.MONITOR>MNETDV.MAC.7,  22-Dec-84 11:43:29 by PAETZOLD
;More TCO 6.1.1079 - Make the XJRST conditional based on REL6 switch for 5.4.
; UPD ID= 1178, SNARK:<6.1.MONITOR>MNETDV.MAC.6,  11-Dec-84 13:15:23 by PAETZOLD
;TCO 6.1.1079 - Use an XJRST referecing TVTJFN in ATNVT.
; UPD ID= 1038, SNARK:<6.1.MONITOR>MNETDV.MAC.5,  12-Nov-84 15:25:34 by PAETZOLD
;TCO 6.1041 - Move ARPANET to XCDSEC
; UPD ID= 999, SNARK:<6.1.MONITOR>MNETDV.MAC.4,   7-Nov-84 14:46:40 by PRATT
;TCO 6.1.1030 - Add IPCI to INTNAM for communicating over the CI
; UPD ID= 917, SNARK:<6.1.MONITOR>MNETDV.MAC.3,  23-Oct-84 19:49:20 by PAETZOLD
; UPD ID= 312, SNARK:<TCPIP.5.4.MONITOR>MNETDV.MAC.11,  18-Oct-84 15:41:24 by PAETZOLD
;TCO 6.1.1024 - Add .GTHLA function to GTHST%.
; UPD ID= 304, SNARK:<TCPIP.5.4.MONITOR>MNETDV.MAC.10,  15-Oct-84 14:46:20 by PAETZOLD
;Fix alphabetical order problem in OPSTAB.
; UPD ID= 287, SNARK:<TCPIP.5.4.MONITOR>MNETDV.MAC.9,  24-Sep-84 13:55:04 by PURRETTA
;Update copyright notice.
; UPD ID= 163, SNARK:<TCPIP.5.4.MONITOR>MNETDV.MAC.8,   3-Jun-84 17:26:35 by PAETZOLD
;Make  MNTHLT  reset  NETON  for  each interface so that it stays down. 
;Clean up MNTHLT in general.  Remove MNTKIL since no one uses it.
;Add VMS, TACs, and MSDOS to OPSTAB.
; UPD ID= 159, SNARK:<TCPIP.5.4.MONITOR>MNETDV.MAC.7,   1-Jun-84 11:35:17 by PAETZOLD
;AOS INTFLG in MNTSET.
; UPD ID= 156, SNARK:<TCPIP.5.4.MONITOR>MNETDV.MAC.6,  31-May-84 11:25:18 by PAETZOLD
;Use indirects in MNTRSV
; UPD ID= 155, SNARK:<TCPIP.5.4.MONITOR>MNETDV.MAC.5,  31-May-84 10:58:54 by PAETZOLD
;Add MNTRSV.  Add some ENDSV.'s.
; UPD ID= 129, SNARK:<TCPIP.5.4.MONITOR>MNETDV.MAC.4,  14-May-84 16:13:25 by PAETZOLD
;MNTHLT needs an EA.ENT.
; UPD ID= 33, SNARK:<TCPIP.5.4.MONITOR>MNETDV.MAC.3,   7-Apr-84 13:15:19 by PAETZOLD
;Remove some spaces in initial HSTINI message.
; UPD ID= 31, SNARK:<TCPIP.5.4.MONITOR>MNETDV.MAC.2,   5-Apr-84 22:46:02 by PAETZOLD
;Add IPNI to INTNAM. Change SITE-ADDRESS.TXT to INTERNET.ADDRESS. Clean
;up  MNTSTS  output.  Use  NETPRT  to  print  out  network numbers. Add
;informational message during startup when calling HSTINI.
; UPD ID= 4022, SNARK:<6.MONITOR>MNETDV.MAC.13,  31-Mar-84 16:20:59 by PAETZOLD
;TCO 6.2019 - Use ADJSPs
; UPD ID= 3941, SNARK:<6.MONITOR>MNETDV.MAC.12,  18-Mar-84 13:15:57 by PAETZOLD
;More TCO 6.1733 - Do not check for dots in GTHSIL.
; UPD ID= 3935, SNARK:<6.MONITOR>MNETDV.MAC.11,  17-Mar-84 13:01:33 by PAETZOLD
;More TCO 6.1733 - Add Fuzzballs to OPSTAB
; UPD ID= 3921, SNARK:<6.MONITOR>MNETDV.MAC.10,  14-Mar-84 10:17:06 by PAETZOLD
;More TCO 6.1733 - Add Foonex to OPSTAB as Tenex
; UPD ID= 3901, SNARK:<6.MONITOR>MNETDV.MAC.9,  11-Mar-84 14:28:21 by PAETZOLD
;More TCO 6.1733 - 5.3 needs a EA.ENT in MNTINI
; UPD ID= 3894, SNARK:<6.MONITOR>MNETDV.MAC.8,  11-Mar-84 10:36:16 by PAETZOLD
;More TCO 6.1733 - Allow  JFNs in ATNVT%. New HSTINI preference scheme.
;Make HSTINI set  up gateway (HS%GAT)  and  network  (HS%NET)  entries.
;Make  RDFLD fold case to upper. Add TAC and WAITS to OPSTAB. Check and
;dispatch for Pup JFN in .ATNVT.
; UPD ID= 3826, SNARK:<6.MONITOR>MNETDV.MAC.7,  29-Feb-84 18:15:40 by PAETZOLD
;More TCO 6.1733 - ANBSEC and MNTSEC removal.  Bug fixes.  Cleanup.
;<TCPIP.5.3.MONITOR>MNETDV.MAC.4,  6-Dec-83 23:53:55, Edit by PAETZOLD
;Call CHKI7 from MNTCHK
;TCO 6.1867 - Use SAVEAC and not SAVP1
;Add subtitles.  Make code that was RSCOD SWAPCD.
;More TCO 6.1733 - Fix day one off by one bug with NUMOPS
;More TCO 6.1733 - NCPFRK has gone away.  HSTLUK Changes.  HSTINI changes.
;<TCPIP.5.1.MONITOR>MNETDV.MAC.42,  5-Jul-83 08:28:09, Edit by PAETZOLD
;New host table support
;IP debuging switch support
;Use ANAUNV as the universal

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1983, 1990.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


	SEARCH ANAUNV,PROLOG
	TTITLE (MNETDV,MNETDV,< - Internet Multinet Interface>)
	.DIREC FLBLST		;[8975] First line binary listing only please
	Subttl	Table of Contents

;		     Table of Contents for MNETDV
;
;				  Section		      Page
;
;
;    1. MNTINI - Initialization  . . . . . . . . . . . . . . .   5
;    2. Interface States
;        2.1    MNETON - Turn Networks On  . . . . . . . . . .   8
;        2.2    CHKR Fork Routines
;            2.2.1    MNTCHK - Periodic Check  . . . . . . . .   9
;            2.2.2    MNTSTS - Report Network State Changes  .  10
;        2.3    Routines Dealing With Network Shutdown . . . .  12
;        2.4    Routines Dealing With Network States . . . . .  13
;        2.5    Routine to Resolve Interface State . . . . . .  14
;    3. Packet Queues
;        3.1    Low and High Priority Packet Output Queueing .  15
;        3.2    NTWPKT - Packet Queueing Routine . . . . . . .  16
;        3.3    NTSNDI - Queue an Internet Packet  . . . . . .  17
;    4. Multinet Interface
;        4.1    FNDNCT and NETACT - Routines to Find NCTs  . .  18
;        4.2    Network Interface Checks . . . . . . . . . . .  19
;        4.3    Local Net and Local Address Checks . . . . . .  20
;    5. Host File Routines . . . . . . . . . . . . . . . . . .  21
;        5.1    Read SYSTEM:HOSTS.TXT  . . . . . . . . . . . .  22
;            5.1.1    Initialization . . . . . . . . . . . . .  23
;            5.1.2    Read Entry . . . . . . . . . . . . . . .  24
;            5.1.3    Add Host . . . . . . . . . . . . . . . .  27
;            5.1.4    Error Handlers . . . . . . . . . . . . .  28
;        5.2    Read SYSTEM:INTERNET.NAMESERVERS . . . . . . .  29
;            5.2.1    Initialization . . . . . . . . . . . . .  30
;            5.2.2    Process  . . . . . . . . . . . . . . . .  31
;            5.2.3    Error Handlers . . . . . . . . . . . . .  32
;        5.3    File Reading
;            5.3.1    Open File  . . . . . . . . . . . . . . .  33
;            5.3.2    Close File . . . . . . . . . . . . . . .  34
;            5.3.3    Read Line from File  . . . . . . . . . .  35
;            5.3.4    Read Character from File . . . . . . . .  36
;            5.3.5    Read Field from File . . . . . . . . . .  37
;            5.3.6    Read Decimal Number  . . . . . . . . . .  40
;            5.3.7    Read Host Number . . . . . . . . . . . .  41
;            5.3.8    Error Handlers . . . . . . . . . . . . .  42
;            5.3.9    Error Printout . . . . . . . . . . . . .  43
;    6. Address File Routines
;        6.1    Read SYSTEM:INTERNET.ADDRESS . . . . . . . . .  44
;        6.2    Get To Beginning Of Line . . . . . . . . . . .  51
;        6.3    Read Character from File . . . . . . . . . . .  52
;        6.4    Read Field from File . . . . . . . . . . . . .  53
;        6.5    Read Four Decimal Bytes  . . . . . . . . . . .  54
;        6.6    Error Handlers . . . . . . . . . . . . . . . .  55
;        6.7    Print bad line on CTY  . . . . . . . . . . . .  57
;        6.8    Tables . . . . . . . . . . . . . . . . . . . .  58
;    7. CVHST% JSYS - Convert Host Number to String  . . . . .  59
	Subttl	Table of Contents (page 2)

;		     Table of Contents for MNETDV
;
;				  Section		      Page
;
;
;    8. GTHST% JSYS  . . . . . . . . . . . . . . . . . . . . .  60
;        8.1    Common Routines
;            8.1.1    Exit routines  . . . . . . . . . . . . .  62
;            8.1.2    Host address to host name routine  . . .  63
;            8.1.3    Host name to host address routine  . . .  64
;            8.1.4    Move string from user space  . . . . . .  67
;            8.1.5    Move string to user space  . . . . . . .  68
;        8.2    (0) Name table size  . . . . . . . . . . . . .  69
;        8.3    (1) Return name string associated with host  .  70
;        8.4    (2) Convert number to string . . . . . . . . .  71
;        8.5    (3) Convert string to number . . . . . . . . .  72
;        8.6    (4) Status by host index . . . . . . . . . . .  73
;        8.7    (5) Status by host address . . . . . . . . . .  74
;        8.8    (6) Get hostnumber on a network  . . . . . . .  75
;        8.9    (7) Get status of a network  . . . . . . . . .  76
;        8.10   (10) Get local network addresses . . . . . . .  77
;        8.11   (14) Get primary name and IP address . . . . .  78
;        8.12   (15) Get MX data . . . . . . . . . . . . . . .  79
;        8.13   (16) Authenticate address  . . . . . . . . . .  82
;        8.14   (20) Validate name . . . . . . . . . . . . . .  83
;        8.15   (23) Operating System  . . . . . . . . . . . .  85
;        8.16   (24) Get DNS host addresses and timeouts . . .  87
;    9. Host Table Routines
;        9.1    Host Table Organization  . . . . . . . . . . .  88
;        9.2    Host Table Storage . . . . . . . . . . . . . .  89
;        9.3    Host Table Lock Routines . . . . . . . . . . .  90
;        9.4    Find Host Table Entries  . . . . . . . . . . .  91
;        9.5    Lookup Host Names  . . . . . . . . . . . . . .  92
;        9.6    String match routine . . . . . . . . . . . . .  94
;        9.7    Operating System match routine . . . . . . . .  95
;        9.8    Convert host number to new format  . . . . . .  97
;        9.9    Compute masks for IP addresses . . . . . . . .  98
;        9.10   Add Host to Tables . . . . . . . . . . . . . .  99
;        9.11   Add Host Name to HSTNAM  . . . . . . . . . . . 105
	Subttl	Table of Contents (page 3)

;		     Table of Contents for MNETDV
;
;				  Section		      Page
;
;
;   10. DNS Resolver . . . . . . . . . . . . . . . . . . . . . 106
;       10.1    Definitions
;           10.1.1    DNS Protocol . . . . . . . . . . . . . . 107
;           10.1.2    DNS Header . . . . . . . . . . . . . . . 108
;           10.1.3    DNS Question Section . . . . . . . . . . 109
;           10.1.4    DNS Resource Record  . . . . . . . . . . 110
;           10.1.5    DNS Field Values . . . . . . . . . . . . 111
;           10.1.6    Pure Data  . . . . . . . . . . . . . . . 112
;           10.1.7    Storage  . . . . . . . . . . . . . . . . 113
;       10.2    GTHST% Interface
;           10.2.1    Number to String . . . . . . . . . . . . 115
;           10.2.2    String to Number . . . . . . . . . . . . 116
;           10.2.3    Inverse Query  . . . . . . . . . . . . . 117
;           10.2.4    Mail Exchange  . . . . . . . . . . . . . 118
;           10.2.5    Validate Name  . . . . . . . . . . . . . 119
;           10.2.6    Operating System . . . . . . . . . . . . 120
;       10.3    Resolver Top Level . . . . . . . . . . . . . . 121
;       10.4    Construct Question
;           10.4.1    Begin Question . . . . . . . . . . . . . 123
;           10.4.2    Number to String . . . . . . . . . . . . 125
;           10.4.3    Inverse Query  . . . . . . . . . . . . . 126
;           10.4.4    Name Query Types . . . . . . . . . . . . 127
;           10.4.5    Finish Question  . . . . . . . . . . . . 128
;           10.4.6    Subroutines  . . . . . . . . . . . . . . 129
;       10.5    Send Question  . . . . . . . . . . . . . . . . 130
;       10.6    Receive Answer . . . . . . . . . . . . . . . . 131
;       10.7    Parse DNS Reply
;           10.7.1    Parse Header . . . . . . . . . . . . . . 133
;           10.7.2    Parse Question . . . . . . . . . . . . . 134
;           10.7.3    Parse Answer Type A and CNAME  . . . . . 135
;           10.7.4    Parse Answer Type PTR  . . . . . . . . . 137
;           10.7.5    Parse Answer Type MX . . . . . . . . . . 139
;           10.7.6    Parse Specified Answer Type  . . . . . . 141
;           10.7.7    Parse Host Information Type  . . . . . . 142
;           10.7.8    Add Host Name  . . . . . . . . . . . . . 143
;           10.7.9    Return Error Code  . . . . . . . . . . . 145
;           10.7.10   Extract Domain Name  . . . . . . . . . . 146
;           10.7.11   Extract Domain Name  . . . . . . . . . . 148
;           10.7.12   Extract Integers . . . . . . . . . . . . 149
;   11. ATNVT% JSYS - Attach connection to NVT . . . . . . . . 150
;   12. NETRDY GETAB Table . . . . . . . . . . . . . . . . . . 151
;   13. End of MNETDV  . . . . . . . . . . . . . . . . . . . . 152
	SUBTTL MNTINI - Initialization

	XSWAPCD

;Called at system startup, initializes tables and storage needed by Multinet.

XNENT (MNTINI,G)		;MNTINI::
	CALL NETINI		; initialize the 1822 buffers
	MOVEI T1,BMNTLK		; Beginning of pages needed to lock down
	SETSEC T1,INTSEC	; In proper section
	MOVEI T2,EMNTLK		; End of area to lock
	SETSEC T2,INTSEC	; Same section
	CALL LKSTOR		; Lock storage
	SETZM DEFADR		; Clear default address field
	SETZM PRFADR		; Clear preferred address field
	SETZM PRFNFD		; Also clear preferred shifted network
	SETZM PRFNET		; And preferred network
	SETZM NETSUP		; Networks not yet up

	MOVSI T1,-%NETS		; Get number of networks we handle
	SKIPA P1,NCTVT		; get link to the first NCT
MNTIN0:	LOAD P1,NTLNK,(P1)	; get next on list
	MOVE T2,NCTVT+1(T1)	; Get next pointer
	STOR T2,NTLNK,(P1)	; Link it to this one
	AOBJN T1,MNTIN0		; Loop through all
	SETZRO NTLNK,(P1)	; Clear last pointer (End of list)

;[8975] Read SYSTEM:INTERNET.ADDRESS file.

	CALL ADRINI		;(/) Get our address read
	 BUG.(INF,NOADDR,MNETDV,SOFT,<Failed to find SYSTEM:INTERNET.ADDRESS file>,,<

Cause:	The SYSTEM:INTERNET.ADDRESS file was either not found or is corrupted.

Action:	Insure that the file is in SYSTEM: and is valid.
>,,<DB%NND>)			;[8969][7.1261] 

;Load the internet host names file

	TMSG <
[Loading Internet host names]>	;[8975] Tell CTY what is happening
	CALL HSTINI		;[8975] (/) Get the system to know site names
	IFSKP.			;[8975] If it worked
	  TMSG < [OK]
>				;[8975] Tell me it worked
	ELSE.			;[8975] So, HSTINI didn't skip return
	  BUG.(INF,NOHSTN,MNETDV,SOFT,<Failed to find host name file SYSTEM:HOSTS.TXT>,,<

Cause:	The SYSTEM:HOSTS.TXT file was not found.  The file SYSTEM:HOSTS.DEBUG
	is used if DBUGSW is 2 or greater.

Action:	Insure that the appropriate file is in SYSTEM: and is valid.
>,,<DB%NND>)			;[7.1261] 
	ENDIF.			;[8969]
	CALL NETHSI		;(/) Initialize the network hash table

;[9156] Read the SYSTEM:INTERNET.NAMESERVERS file.

	CALL DNSINI		;[9156] (/) Read the file internet.nameservers
	 JFCL			;[9156] Ignore errors as this is option file

;Enable networks if needed.
;[9177] DBUGIP/0 means turn on nets iff not standalone
;[9177] DBUGIP/1 means turn on nets iff standalone
;[9177] DBUGIP/2 means turn on nets always

	MOVE T1,DBUGSW		; Get system switch
	CAILE T1,1		;[9178] Are we stand alone?
	 TDZA T1,T1		; we are not stand alone
	  MOVEI T1,1		; we are stand alone
	XOR T1,DBUGIP		;[9177] Consider this per DBUGIP
	SKIPE T1		;[9177] Skip if not turning on nets today
	 SKIPN DEFADR		; Did addresses initialize properly?
	  JRST MNTINX		; No, return now
	JRST MNTON1		; Go turn on networks

;LKSTOR - Lock down a region of core
;Call with 1/ Xtended address of start
;	   2/ Xtened address of end
;Returns +1 always

LKSTOR:	TRZ T1,777		; Round down to nearest page

LKST1:	PUSH P,T1		; Save start
	PUSH P,T2		; and end
	CALLX (MSEC1,MLKMA)	; Lock down the page
	POP P,T2		; Restore ACs
	POP P,T1		; ...
	ADDI T1,PGSIZ		; Increment to next page
	CAMG T1,T2		; Past last address?
	JRST LKST1		; Loop
	RET
	SUBTTL Interface States -- MNETON - Turn Networks On 

;Turn networks on if NETSUP has been off.  Called by CALL MNETON$X or by MNTINI

XNENT (MNETON,G)		;MNETON::

MNTON1:	SKIPA P1,NCTVT		; Point to vector table
MNTON2:  LOAD P1,NTLNK,(P1)	; get next in list
	JUMPE P1,MNTINY		; Return when done
	MNTCALL NTINI		; Initialize network device
	SETOM NETON(P1)		; Turn it on
	SETZM NTPRIO(P1)	; Clear priority cell
	MNTCALL NTRSRT		; get it going
	JRST MNTON2		; and loop
MNTINY:	SETOM NETSUP		; Networks are now initialized
MNTINX:	RET			; And return

	SUBTTL Interface States -- CHKR Fork Routines -- MNTCHK - Periodic Check

;CHKR Fork routine for keeping things going on all nets. Called every
;four minutes or whenever JB0FLG is non-zero.

XNENT (MNTCHK,G)		;MNTCHK::, XMNTCH::
	SKIPA P1,NCTVT		; Point to the vector table
MNTCH0:	 LOAD P1,NTLNK,(P1)	; Get next in list
	JUMPE P1,MNTCH2		; Go check the rest 
	SKIPE NTSTCH(P1)	; Change of state?
	 CALL MNTSTS		; Yes
	SKIPN NETON(P1)		; If network off
	 JRST MNTCH0		; Loop
				; Want net on
	MNTCALL NTSCHK		; Check status, keep stuff consistent
	 JFCL			; Ignore error return
	SKIPG NETON(P1)		; If needs restarting
	 SKIPL NTRDY(P1)	; Or isn't ready
	  MNTCALL NTRSRT	; Restart it
	MOVE T1,TODCLK		; Get time now
	CAML T1,NTTOUT(P1)	; Output timed out?
	 SKIPN NTTOUT(P1)	; Output actually going?
	  JRST MNTCH1		; No timeout
	BUG.(INF,NTOHNG,MNETDV,SOFT,<Network output hung>,<<P1,ENTRY>>,<

Cause:	Multinet has declared the output interface for a network hung.
	The network interface is reset.

Data:	ENTRY - Entry into NCT Vector table of hung interface
>)
	MNTCALL NTRSRT		; If timeout, reset net
MNTCH1:	MNTCALL NTISRT		; Make sure input is happening
	MOVE T1,SCTLW		; System shutdown?
	TXNN T1,<1B3>
	 JRST MNTCH0		; No, loop through all
				; System shutdown
	SETZM NTRDY(P1)		; Imp off
	SETZM NETON(P1)		; Net off
	SETZM NTORDY(P1)	; output off
	SETO T1,		; Abort entry
	MNTCALL NTKILL		; Drop ready line
	JRST MNTCH0		; and loop through the rest

MNTCH2:
	SKIPE IMPGDM		; Any "imp going down" messages?
	 CALL CHKI7		; Yes, go print it
	RET			; And return

	SUBTTL Interface States -- CHKR Fork Routines -- MNTSTS - Report Network State Changes
       
;[8982] Here to log network change of state, returns +1 always
;Call with P1/ NCT index
;Returns +1 always

MNTSTS:	SKIPGE NTLADR(P1)	;Is there an address set?
	RET			;Don't report if no address set
	STKVAR <<MNTMSG,40>>	;Place to build message
	SETZM NTSTCH(P1)	;Reset the state change time
	MOVEI T1,MNTMSG		;Point to the message area
	HRLI T1,(Point 7)	;Make a byte pointer into it
	HRROI T2,[ASCIZ/
[Internet Network /]		;Load initial part of message
	CALL MNTSTO		;(T1,T2/T1) Copy a part of the string
	CALL NETPRT		;(T1,P1/T1) Print out the network number
	HRROI T2,[ASCIZ / on/]	;Assume it is on
	SKIPN NETON(P1)		;Is it on?
 	HRROI T2,[ASCIZ / off/] ;No
	CALL MNTSTO		;(T1,T2/T1) Copy a part of the string
	HRROI T2,[ASCIZ /, Output on /] ;Assume on
	SKIPN NTORDY(P1)	;Is output on?
        HRROI T2,[ASCIZ /, Output off /] ;Nope, its off today
	CALL MNTSTO		;(T1,T2/T1) Copy a part of the string
	SETO T2,		;Use current time
	MOVX T3,OT%SCL		;Suppress columnation on the time
	ODTIM%			;Output the time that this is occuring
	 ERJMP .+1		;Avoid MONNEJ if no date and time set
	HRROI T2,[ASCIZ/]
/]				;Point to cleanup hitter
	CALL MNTSTO		;(T1,T2/T1) Store final string 
	IDPB T3,T1		;Insure null at end of string
	MOVE T1,JB0TT		;Load CTY terminal number
	HRROI T2,MNTMSG		;Point to message
	TTMSG%			;Send that to the CTY
	 ERJMP .+1		;No MONNEJs please

	SKIPN NTORDY(P1)	;Did the hardware come up?
	CALLRET INTDWN		;No, signal it's down
	CALLRET	INTUP		;Signal that it's available for use

	ENDSV.			;End of STKVAR for MNTSTS

;Local routine to print the network number for current NCT
;Call with P1/ NCT index and T1/ output pointer
;Returns +1 always, T1 updated

NETPRT:	STKVAR <NPRTX,NPRBP,NPRPTR> ;[8982] Local storage
	MOVEM T1,NPRPTR		;[8982] Save output pointer
	MOVE T1,NTNET(P1)	; Get the network number
	LSH T1,10		; Move it over one byte
	CAMG T1,[BYTE (4)0(8)0,377,377,377] ; Class A or B?
	LSH T1,10		; yes move it over one more byte
	CAMG T1,[BYTE (4)0(8)0,377,377,377] ; Class A?
	LSH T1,10		; yes move it over one more byte
	MOVEM T1,NPRTX		; save it
	MOVEI T1,.GTHNS		; Get host name function
	MOVE T2,NPRPTR		;[8982] Restore output pointer
	MOVE T3,NPRTX		; Get the network number
	GTHST%			; Output the network number
	 ERJMP NETPR1		; on error assume no name
	MOVE T1,T2		;[8982] Return pointer in T1
	RET 			; and return

NETPR1:	MOVX T1,<POINT 8,NPRTX,3> ;No net name, get the octet pointer
	MOVEM T1,NPRBP		; and save it
	MOVEI T4,4		; four octets
	MOVE T1,NPRPTR		;[8982] Reload output pointer
	MOVEI T3,12		;[8982] Output in decimal

NETPR2:	ILDB T2,NPRBP		; get a byte
	NOUT%			; output the octet
	 ERJMP .+1		; handle errors
	SOJE T4,R		; on the last one return
	MOVEI T2,"."		;[8982] Otherwise get a dot
	IDPB T2,T1		;[8982] Store that please
	JRST NETPR2		; and do the rest
	ENDSV.

;[8982] Local routine to append to a string 
;Call T1/ destination pointer, T2/ source pointer (-1,,addr)
;Returns +1 always, T1 and T2 updated, T3/ 0

MNTSTO:	TLC T2,-1		;Is the source
	TLCN T2,-1		; minus one?
	HRLI T2,(POINT 7)	;Yes, make a byte pointer
MNTST1:	ILDB T3,T2		;Get a source byte
	JUMPE T3,R		;Return if null
	IDPB T3,T1		;Store it
	JRST MNTST1		;Get another character
	SUBTTL Interface States -- Routines Dealing With Network Shutdown

;T1/ Reason, a la 1822
;T2/ GTAD when back up

XNENT (MNTHLT,G)		;MNTHLT::
				; Tell all interfaces we are going away.
	SAVEAC <P1>
	STKVAR <<MHLTRS,2>>
	DMOVEM T1,MHLTRS	; save the time and reason
	MOVX T1,<377777777777>	; Stop pings
	MOVEM T1,PINGTM		; Save new ping time
				; shutdown each interface
	SKIPA P1,NCTVT		; Get pointer to tables
MNTHL2:	 LOAD P1,NTLNK,(P1)	; Get next NCT
	JUMPE P1,R		; done?
	SETZM NETON(P1)		; No, say that we want this interface off.
	DMOVE T1,MHLTRS		; Get why/when.
	MNTCALL NTKILL		; Do halt instruction
	JRST MNTHL2		; Loop through all

	SUBTTL Interface States -- Routines Dealing With Network States

;MNTSET - Set a network status.
;	T1/	Network number, or host address
;	T2/	value
; Possible values are:  -ive = on
;			zero = off
;			+ive = request cycle

MNTSET::SAVEAC <P1>
	CALL NETNCT		;(T1/P1) Find the NCT
         RET			;Return now if none
	SKIPGE T2		;Skip if -ive argument
	SETO T2,		;Normalize it to -1
	SKIPLE T2		;[9108] Skip if not +ive
	HRRZI T2,-1		;[9108] Insure 0,,-1 for +ive quantity
	MOVEM T2,NETON(P1)	; Set function

	IFE. T2			;[9108] Turn interface off?
	  SETOB T1,T2		;[9108] Load -1 arguments
	  MNTCALL NTKILL	;[9108] (T1,T2,P1/) Kill interface
	ELSE.			;[9108] Not turning off
	  IFG. T2		;[9108] Is a cycle requested?
	    SETOB T1,T2		;[9108] Load arguments
	    MNTCALL NTKILL	;[9108] (T1,T2,P1/) Kill interface
	  ENDIF.		;[9108] End of cycle requested code
	  MNTCALL NTRSRT	;[9108] (P1/) Restart the hardware
	  MNTCALL NTISRT	;[9108] (P1/)  and start input
	ENDIF.			;[9108] End of action code

	AOS INTFLG		; Ask for the internet fork
	RETSKP			; Success return

MNTRED::			; ROUTINE TO RETURN NETWORK STATE
	SAVEAC <P1>
	SETZ T2,		; ASSUME NET IS DOWN
	CALL NETNCT		; GET THE NCT
         RET			; NO NCT
	MOVE T2,NETON(P1)	; GET THE STATE
	RETSKP			; SUCCESS RETURN

	SUBTTL Interface States -- Routine to Resolve Interface State

MNTRSV::			; Resolve interface state (P1/ NCT)
	SKIPL NETON(P1)		; do we want it up?
	 JRST MNTRS2		; no
	SKIPE NTRDY(P1)		; yes. is it up?
	 RET			; want up and is up so return.
	CALL @NTRSRT(P1)	; want up and is down so make it up.
	RET			; and return

MNTRS2:				; Here when not wanted up.
	SKIPE NETON(P1)		; want it down?
	 JRST MNTRS3		; no must want it cycled.
	SKIPN NTRDY(P1)		; is it down?
	 RET			; want down and is down so return.
	CALL @NTKILL(P1)	; want down and is up so take it down.
	RET			; and return to caller

MNTRS3:				; here when we want to cycle
	SKIPE NTRDY(P1)		; is it up now?
	 CALL @NTKILL(P1)	; yes so make it down
	SETOM NETON(P1)		; and say that we want it up
	RET			; and return to caller

	SUBTTL Packet Queues --  Low and High Priority Packet Output Queueing

;NTHSND - Put packet on High priority Q.
;T2/ packet pointer
;P1/ NCT address
;Returns+1	Refused
;Returns+2	Packet succesfully queued

	XRESCD

NTSNDX:	BUG.(CHK,BADADR,MNETDV,SOFT,<No NCT for address>,<<T1,ADR>>,<

Cause:	The multinet output queuing mechanism was called for a local
	address that has not been defined.

Data:	ADR - Host address
>)
	RET			; return

NTHSND::SAVEAC <P1>
	CALL FNDNCT
         JSP CX,NTSNDX		; Nope
	XMOVEI T1,NTHOBO(P1)	; Point to Q
	JRST NTQPKT		; And queue it

;NTLSND - Put packet on low priority Q
;T2/ packet pointer
;P1/ NCT address
;Returns+1	Refused
;Returns+2	Packet succesfully queued

NTLSND::SAVEAC <P1>
	CALL FNDNCT
         JSP CX,NTSNDX		; Not found
	XMOVEI T1,NTLOBO(P1)
	JRST NTQPKT

	SUBTTL Packet Queues --  NTWPKT - Packet Queueing Routine

;NTWPKT - Put packet on FIFO Q
;T1/	pointer to Q head
;T2/	packet pointer
;P1/	NCT address
;Returns+1	Refused
;Returns+2	Packet succesfully queued

NTQPKT:	SKIPN NTORDY(P1)	; Output allowed?
         RET			; No, fail
	TRNN T2,-1		; Is the address good?
	BUG.(HLT,BADBUF,MNETDV,SOFT,<Null buffer address>,,<

Cause:	Multinet has been called to queue an output buffer with a null
	address.
>)
	HRRZS 0(T2)		; Make sure succesor chain is NIL
	PIOFF			; Insure intergrety of queues
	SKIPE T3,1(T1)		; Q empty?
         JRST NTQPK2		; No, put on tail
	MOVEM T2,0(T1)		; Yes, set head pointer
	SKIPA			; Don't chain, no predecessor
NTQPK2:	 STOR T2,NBQUE,(T3)	; Chain from predecessor to new guy
	MOVEM T2,1(T1)		; This is new tail of Q
	PION			; Allow interrupts again
	MNTCALL NTOSRT		; Start output if needed
	RETSKP			; And return succesfully

	SUBTTL Packet Queues --  NTSNDI - Queue an Internet Packet

;NTSNDI - Default routine for enquing an internet packet
;      T1/	Local host
;      T2/	packet pointer
;      P1/	NCT address
;Returns+1	Refused,  T1 has an ICMP error code
;Returns+2	Packet succesfully queued

NTSNDI::MNTCALL NTOTOK		; Can this packet be sent?
         RET			; No, T1 has reason
	MNTCALL NTLLDR		; Make a local header
	XMOVEI T1,NTIOBO(P1)	; Point to right Q
	CALL NTQPKT		; And Q the packet
	 CAIA			; Failed
	  RETSKP		; Success
	MOVX T1,<ICM%SQ>	; Back off a minute, interface unusable
	RET			; return

	SUBTTL Multinet Interface -- FNDNCT and NETACT - Routines to Find NCTs

;FNDNCT - Host number to NCT
;T1/	Host address
;Returns+1	No NCT for that net
;Returns+2	P1/ pointer to the NCT for a (usable) interface on that net

FNDNCT::SAVET			; Save temps
	NETNUM T2,T1		; Get the network number
	CALL NETHSH		; Look it up in the tables
	 RET			; No, knowledge of that net
	SKIPL P1,NETGWY(T2)	; Get the interface
	 RET			; Not directly connected
	RETSKP			; And skip return

;NETNCT - Host or Net to NCT of a (possibly down) interface on that net.

;T1/	Host address or Net number
;Returns+1	No NCT for that net
;Returns+2	P1/ pointer to the NCT for a (usable) interface on that net

NETNCT::SAVET			; Save temps
	TXNN T1,-1B11		; Host address?
	  JRST NETNC0		; No
	NETNUM T1,T1		; Get the network number
NETNC0:	XMOVEI P1,NCTVT		; Point to the table
NETNCL:	LOAD P1,NTLNK,(P1)	; Get net in the chain
	JUMPE P1,R		; No more
	CAMN T1,NTNET(P1)	; Same network?
	  RETSKP		; yes, success
	JRST NETNCL		; else loop

	SUBTTL Multinet Interface -- Network Interface Checks

	XSWAPCD

;NETCHK - Check if our interface on a given net is up
;T1/	Host number
;Returns+1	if interface is down
;Returns+2	if it is up

NETCHK::SAVEAC <P1>
	CALL NETNCT		; Find the NCT
	 TRNA			; No such Net
	SKIPL NTRDY(P1)      	; Network up?
	RET			; No
	RETSKP			; Yes, return good

;NETCMP - Check if a host is on a given interface.

;T1/	Host number
;P1/	Pointer to NCT
;Returns+1	if host is not on that interface
;Returns+2	if it is

NETCMP::SAVET			; Save temps
	NETNUM T1,T1		; Get the net number
	MOVE T2,NTNET(P1)	; And that of this NCT
	CAME T2,T1		; Same?
	 RET			; No
	RETSKP			; Yes

	SUBTTL Multinet Interface -- Local Net and Local Address Checks

;LCLNET - Check if a host address is on a net we're connected to.
;T1/	Host address
;Returns+1	If no intersecting network
;Returns+2	If we have an intersecting network
;(Note that this doesn't mean that the interface is currently usable)

LCLNET::SAVET			; Save temps
	NETNUM T1,T1		; Get the net number
	XMOVEI T3,NCTVT		; Point to the interface table
LCLNT0:	LOAD T3,NTLNK,(T3)	; get the next in the list
	JUMPE T3,R		; end of the list
	CAMN T1,NTNET(T3)	; On this network?
	 RETSKP			; yes, return success
	JRST LCLNT0		; loop through all

;LCLHST 
;Check if a given address is one of ours
;T1/	32 bit address
;Returns+1	if it is not one of ours
;Returns+2	if it is

LCLHST::SAVEAC <P1>
	SKIPA P1,NCTVT		; First interface
LCLHS0:	LOAD P1,NTLNK,(P1)	; Next interface
	JUMPE P1,R		;[9156] Return +1 if not found
	CAME T1,NTLADR(P1)	; Is this one of ours?
        JRST LCLHS0		; No, loop through all
	RETSKP			;[9156] Skip return
	SUBTTL Host File Routines

;The following routines are called by MNTINI at system startup and by the
;IPOPR% JSYS (TCPJFN).  These routines cause configuration files to be loaded
;into the monitor.

;The first entry point to the host file routines is the HSTINI routine.  This
;routine is responsible for reading the SYSTEM:HOSTS.TXT file.  The HSTINI
;routine clears the monitor's host tables and then loads the host tables from
;SYSTEM:HOSTS.TXT or SYSTEM:HOSTS.DEBUG.  The format of the file is documented
;in RFC 952, "DoD Internet Host Table Specification".  Edits [8969] and [8975]
;cleaned up the HSTINI routines quite a bit.  Edit [9108] added the host table
;lock which is now acquired during the time we are playing with the tables.

;The second entry point to the host file routines is the DNSINI routine.  This
;routine reads the SYSTEM:INTERNET.NAMESERVERS file.  The DNSINI routine clears
;the monitor's DNS tables and then loads the SYSTEM:INTERNET.NAMESERVERS file.
;This file contains the list of hosts that are running DNS nameserver software.
;DNSINI was added by edit [9156].  

;See the comments at the start of the host table routines (host table
;organization) for the organization of the host tables, which was changed by
;edit [9157].  Edit [9157] removed the rather gross edit [8828].

;[9156] Define host file routines TRVAR storage.  Upon each entry to these
;routines the TRHOST macro is invoked to reserve the storage defined here.

	TMPBSZ==10		;[8969] Size of TRVAR for temp buffer in words
	LINBSZ==^D80		;[8975] Size of TRVAR of line buffer in words
	NAMNUM==MAXLW		;[9156] Size of TRVAR for NAMLST and NUMLST

	DEFINE TRHOST,<		;[9156]
	TRVAR <<TMPBUF,TMPBSZ>,<LINBUF,LINBSZ>,<NAMLST,NAMNUM+1>,<NUMLST,NAMNUM+1>,SAVPDL,TERM,ENTTYP,HSTFIL,HSTPGC,HSTPAG,HSTPTR,HSTCNT> ;[9156][8969][8975]
>				;[9156] end of DEFINE TRHOST
	SUBTTL Host File Routines -- Read SYSTEM:HOSTS.TXT

;[9156] HSTINI is called to read SYSTEM:HOSTS.TXT to load the host tables.
;
;Returns +1 if some kind of error with either file
;Returns +2 if both files have been read.

HSTINI::TRHOST			;[9156] Allocate TRVAR storage
	SAVEP			;[8975] Save P1-P4

	CALL LCKGTH		;[9108] (/) Lock the host table for us

	CALL HSTIN0		;[9156] (/) Read the host file
	 CALLRET ULKGTH		;[9156] (/) There was a serious error, get out

	CALL ULKGTH		;[9156] (/) Allow access to host table again
	RETSKP			;[9156] It all worked, return now

	SUBTTL Host File Routines -- Read SYSTEM:HOSTS.TXT -- Initialization

;[9156] This routine loads the contents of SYSTEM:HOSTS.TXT
;Returns +1 if some problem doing that
;Returns +2 if no problem doing that

HSTIN0:	MOVEM P,SAVPDL		;[9156] Store the current stack pointer

;Open up the proper HOSTS.TXT or HOSTS.DEBUG file based on DBUGSW.

	MOVE T2,DBUGSW		;[7.1243] Load debug switch
	CAILE T2,1		;[7.1243] Is it 2 or above?
	SKIPA T2,[-1,,[ASCIZ/SYSTEM:HOSTS.DEBUG/]] ;[7.1243] Yes, use debug ver
	HRROI T2,[ASCIZ/SYSTEM:HOSTS.TXT/] ;[7.1243] No, usual filename
	CALL HFILOP		;[9156] (T2/P3) Open up the file
	 RET			;[9156] Could not open that file up

;Initialize table pointers and clear all memory associated with these tables.

	SETZM MHOSTS		;[9156] Clear -number of hosts in HOSTN
	SETZM NAMSPC		;[9156] No words used in HSTNAM

;[9156] Zero all of our tables, most of which are swappable.

	MOVX T1,<HOSTLZ-HOSTFZ> ;[9156] Load number of words to clear
	MOVE T2,[XWD INTSEC,HOSTFZ] ;[9156] Load address of 1st word to zero
	SETZM (T2)		;[9156] Clear first word of that stuff
	MOVE T3,[XWD INTSEC,HOSTFZ+1] ;[9156] Load address of 2nd word to zero
	CALL XBLTA		;[9156] (T1,T2,T3/) Zap all of the memory
	SUBTTL Host File Routines -- Read SYSTEM:HOSTS.TXT -- Read Entry

;[9156] This is the top of the loop to read a line from the host file.  After
;all items are read the information is added to the host tables.

HSTIN6:	SETZM NAMLST		;[9156] No names yet
	SETZM NUMLST		;[9156] No addresses yet
	MOVE P,SAVPDL		;[8975] Reset stack fence

	CALL GLINE		;[8975](P3/P4) Read a (non comment) line in
	 JRST HFILDN		;[8975] Done with file

	CALL RDFLD		;(P4/P4,T1) Read a field from the file
	MOVE T1,TMPBUF		;GET FIRST WORD
	SETZ T2,		;ZERO MEANS UNKNOWN TYPE OF ENTRY
	CAMN T1,[ASCIZ/HOST/]	;HOST?
	MOVX T2,HS%SRV		;YES
	CAMN T1,[ASCIZ/NET/]	;NETWORK?
	MOVX T2,HS%NET		;YES
	CAMN T1,[ASCII/GATEW/]	;[9156] Gateway?
	MOVX T2,HS%GAT		;YES
	JUMPE T2,HSTIE6		;[8975] Owie if not one of the above three
	MOVEM T2,ENTTYP		;SAVE ENTRY TYPE

;[9156] Read in all host numbers, putting them into NUMLST.

HSTIN7:				;LOOP FOR READING IN ALL THE NUMBERS
	CALL RDHNUM		;(P4/P4,T1) Read a host number
	AOS T2,NUMLST		;[9156] Get next index into NUMLST
	CAILE T2,NAMNUM		;[9156] More then NAMNUM of these?
	JRST HSTIEN		;[9156] Yes, give it up
	ADDI T2,NUMLST		;[9156] Have to do this the slow way
	MOVEM T1,(T2)		;[9156] Store the address next
	MOVE T1,TERM		;Get field terminator
	CAIN T1,","		;[8975] Comma terminated this hostnumber?
	JRST HSTIN7		;[8975] Yes, get more host numbers 
	CAIE T1,":"		;End of list?
	JRST HSTIE7		;[8975] Nope

;[9156] Addresses have been read and placed into NUMLST.  Next, read the names,
;copying them to name free space, and saving their indexes on in NAMLST.

HSTIN9:	CALL RDFLDL		;[9156] (P4/P4,T1) Read the next field
	JUMPE T1,HSTIE3		;If no host name read, a format error
	ADDI T1,1		;COUNT THE NULL TERMINATOR
	IDIVI T1,5		;CONVERT CHAR COUNT TO WORD COUNT
	SKIPE T2		;Round up if needed
	ADDI T1,1		;Yes, round up
	XMOVEI T2,TMPBUF	;[9156] Point to temporary buffer area
	CALL ADDNAM		;[9156] (T1,T2/T1,T2,T3,T4) Move to HSTNAM
	 JRST HSTIE4		;[9156] Host could not be added
	AOS T2,NAMLST		;[9156] Get next free one, count this entry
	CAILE T2,NAMNUM		;[9156] Running over?
	JRST HSTIES		;[9156] Yes, forget this one
	ADDI T2,NAMLST		;[9156] Point into the list
	MOVEM T3,(T2)		;[9156] Store the offset to HSTNAM in NAMLST

	MOVE T1,TERM		;Get terminator
	CAIN T1,","		;[8975] Comma terminated this hostnumber?
	JRST HSTIN9		;[8975] Yes, get more host numbers 
	CAIE T1,":"		;End of list?
	JRST HSTIE9		;[8975] Nope, error here

;All names have been read.  If this entry is for a HOST, skip over the machine
;type and get the operating system type.

HSTI10:	MOVE T3,ENTTYP		;[9156] Get entry type
	TXNN T3,HS%SRV		;[9156] Is it a host entry?
	JRST HSTI14		;[9156] Entry for NETs and GWs end after name
	CALL SKPFLD		;(P4/P4) Skip machine type
	CALL RDFLD		;(P4/P4,T1) Read operating system
	MOVEI T1,TMPBUF		;[9156] Point to the field we read in
	HRLI T1,(Point 7)	;[9156] Make a byte pointer to that address
	CALL OMATCH		;[9156] (T1/T3) Get an operating system match
	SUBTTL Host File Routines -- Read SYSTEM:HOSTS.TXT -- Add Host

;[9156] We have read in the entry type, addresses, names, and op sys types, I
;think that it is time to add the host now.  T3 is set up with op sys type and
;entry type.

HSTI14:	MOVEI T1,NAMLST		;[9156] Point to name list
	MOVEI T2,NUMLST		;[9156] Point to address list
	TXO T3,HS%AUT		;[9156] This data is considered authoritative
	MOVX T4,.INFIN		;[9156] Load infinite uptime for TTL
	CALL ADDHOS		;[9156] (T1,T2,T3,T4/) Add host to table
	 JRST HSTIE5		;[9156] It didn't work, host table full
	JRST HSTIN6		;ONWARD
	SUBTTL Host File Routines -- Read SYSTEM:HOSTS.TXT -- Error Handlers

;Error handlers for HSTIN0.

HSTIE3:	JSP T1,HFILER		;[8975] No host name read
	ASCIZ/%Null name not allowed in / ;[8975]

HSTIE4:	JSP T1,HFILER		;[8975] Table out of space
	ASCIZ/%Name table out of space before end of / ;[8975]

HSTIE5:	JSP T1,HFILER		;[8975] We think that name table is full
	ASCIZ/%Host table full before end of /;[9156]

HSTIE6:	JSP T1,HFILER		;[8975] Not HOST, NET, or GATEW
	ASCIZ/%Unknown entry type in / ;[8975]

HSTIE7:	JSP T1,HFILER		;[8975] Not colon or comma after addresses
	ASCIZ/%Illegal character in address field in / ;[8975]

HSTIE9:	JSP T1,HFILER		;[8975] Not colon or comma after addresses
	ASCIZ/%Illegal character in name field in / ;[8975]

HSTIES:	JSP T1,HFILER		;[9156] 
	ASCIZ/%Too many host names on one line in / ;[9156]

HSTIEN:	JSP T1,HFILER		;[9156] 
	ASCIZ/%Too many host addresses on one line in / ;[9156]

	SUBTTL Host File Routines -- Read SYSTEM:INTERNET.NAMESERVERS

;[9156] DNSINI is called to read SYSTEM:INTERNET.NAMESERVERS.
;
;It is assumed that each time that the SYSTEM:HOSTS.TXT file is read that the
;SYSTEM:INTERNET.NAMESERVERS file should be read by calling DNSINI.  During the
;time that the file is being read the process is NOINT, so the user cannot
;interrupt the process preventing resources from being released (JFNs and the
;FPG0 page).  Furthermore, the host table lock (GTHLCK) is owned by the process
;during this time.
;
;Each entry in the file is of the form
;	16.34.0.9,TIMEOUT:5	;bldg19.tops20.dec.com

	DNSDFT==^D20		;[9156] Default timeout if no TIMEOUT keyword
	DNSDFM==^D120		;[9156] Maximum reasonable timeout

;DNSINI accepts no explicit input.
;Returns +1 if some kind of error with either file
;Returns +2 if both files have been read.

DNSINI::TRHOST			;[9156] Set up TRVAR for this
	SAVEP			;[9156] Save P1-P4
	CALL LCKGTH		;[9156] (/) Lock the host table lock

	CALL DNSIN0		;[9156] Read SYSTEM:INTERNET.NAMESERVERS
	 CALLRET ULKGTH		;[9156] Failure

	CALL ULKGTH		;[9156] Unlock the table
	RETSKP			;[9156] Skip return


	SUBTTL Host File Routines -- Read SYSTEM:INTERNET.NAMESERVERS -- Initialization

;[9156] Here to read the file SYSTEM:INTERNET.NAMESERVERS.
;Called NOINT and with the host table lock.
;Returns +1 if some problem finding the file
;Returns +2 with DNSHST and DNSTMO set up for later use.

DNSIN0:	MOVEM P,SAVPDL		;[9156] Store the current stack pointer

;[9156] Clear the current DNS tables.

	SETZM DNSFWZ		;[9156] Clear first word of that table
	MOVE T2,[DNSFWZ,,DNSFWZ+1] ;[9156] Make a pointer to it
	BLT T2,DNSLWZ		;[9156] Zap the all of the DNS host tables

;[9156] Open up the SYSTEM:INTERNET.NAMESERVERS file.

	HRROI T2,[ASCIZ/SYSTEM:INTERNET.NAMESERVERS/] ;[9156] Point to name
	CALL HFILOP		;[9156] (T2/P3) Open up the file
	 RET			;[9156] Could not open that file up

;[9156] Load P1 to point to the DNS tables, and fall through to read the file.

	MOVSI P1,-NDNSH		;[9156] Load AOB pointer to DNSHST/DNSTMO
;	JRST DNSIN1		;[9156] Fall through to read the file

	SUBTTL Host File Routines -- Read SYSTEM:INTERNET.NAMESERVERS -- Process

;[9156] This is the top of the loop to read entries and store them.
;	P1/ -free,,current for DNSHST and DNSNAM

DNSIN1:	MOVE P,SAVPDL		;[9156] Reset stack fence

	CALL GLINE		;[9156] (P3/P4) Read a (non comment) line in
	 JRST HFILDN		;[9156] Done with file, get out of here

;[9156] Read in a host number and save it in the table.

	CALL RDHNUM		;[9156] (P4/P4,T1) Read a host number
	AOBJP P1,DNSIE4		;[9156] Get out if we have too many now
	MOVEM T1,DNSHST-1(P1)	;[9156] Store that IP address
	MOVEI T1,DNSDFT		;[9156] Load default timeout for host
	MOVEM T1,DNSTMO-1(P1)	;[9156] Save it here

;[9156] See if the optional keyword follows.

	MOVE T1,TERM		;[9156] Get terminator to the field
	CAIE T1,","		;[9156] Comma terminated this hostnumber?
	JRST DNSIN1		;[9156] Nope, get another hostnumber

;[9156] Read in optional keyword and check it and its terminator.

	CALL RDFLD		;[9156] (P4/P4,T1) Read a field from the file
	DMOVE T1,TMPBUF		;[9156] Get first two words of keyword
	CAMN T1,[ASCII/TIMEO/]	;[9156] Is the word 
	CAME T2,[ASCIZ/UT/]	;[9156]  TIMEOUT?
	JRST DNSIE1		;[9156] Error!
	MOVE T1,TERM		;[9156] Load the terminator
	CAIE T1,":"		;[9156] Was it a colon?
	JRST DNSIE2		;[9156] Error!

;[9156] Read in the timeout value.  If ok, store it and loop for next line.

	CALL RDNUMB		;[9156] (P4/P4,T1) Load the number
	CAIL T1,1		;[9156] Is the number
	CAILE T1,DNSDFM		;[9156]  within reason?
	JRST DNSIE3		;[9156] Error!
	MOVEM T1,DNSTMO-1(P1)	;[9156] Save the timeout in seconds
	JRST DNSIN1		;[9156] Loop 
	SUBTTL Host File Routines -- Read SYSTEM:INTERNET.NAMESERVERS -- Error Handlers

;Error handlers for DNSIN0.

DNSIE1:	JSP T1,HFILER		;[9156] 
	ASCIZ/%Bad keyword in /	;[9156] 

DNSIE2:	JSP T1,HFILER		;[9156] 
	ASCIZ/%Bad keyword terminator in / ;[9156] 

DNSIE3:	JSP T1,HFILER		;[9156] Change following if DNSDFM changes
	ASCIZ/%Timeout must be between 1 and 120 in / ;[9156] 

DNSIE4:	JSP T1,HFILER		;[9156] 
	ASCIZ/%Too many hosts in / ;[9156] 
	SUBTTL Host File Routines -- File Reading -- Open File

;[9156] Here to open a file for reading by the host routines.
;Call with T2/ pointer to ASCIZ string with filename
;Returns +1 if file not found or couldn't open it
;Returns +2 if file open, HSTPAG/HSTCNT/HSTPGC set up and P3/JFN

HFILOP:	MOVX T1,GJ%SHT!GJ%OLD	;[9156] GTJFN flags, file must exist
	MOVEM T2,HSTFIL		;[9156] Remember the filename we used today
	GTJFN%			;[9156] Look for the file
	 ERJMP R		;[9156] Not found (probably), return +1

	MOVEM T1,P3		;[9156] Save the JFN
	MOVX T2,<FLD(7,OF%BSZ)!OF%RD> ;[9156] We need to read 7 bit bytes
	OPENF%			;[9156] Open up the JFN
	 ERJMP HFILNO		;[9156] Handle errors

	SIZEF%			;[9156] Get size of file
	 ERJMP HFILNO		;[9156] Punt file
	MOVEM T3,HSTPGC		;[9156] Save page count	

	SETOM HSTPAG		;[9156] Start with page 0 of file
	SETZM HSTCNT		;[9156] No characters available to read
	RETSKP			;[9156] Skip return

HFILNO:	MOVE T1,P3		;[9156] Error on OPENF, recover the JFN
	RLJFN%			;[9156] Release the JFN
	 ERJMP .+1		;[9156] Ignore errors
	RET			;[9156] Return +1
	SUBTTL Host File Routines -- File Reading -- Close File

;[9156] Here when we need to close the file.  Reset the stack fence (in case an
;error got us here, close the file, and skip return

HFILDN:	MOVE P,SAVPDL		;[9156] Get back stack fence

	SETZ T1,		;[9156] Indicate no mapping desired
	MOVEI T2,FPG0A		;[9156] Load address (not page number)
	CALL SETMPG		;[9156] (T1,T2/) Unmap old page

	MOVE T1,P3		;[9156] Get back JFN
	CLOSF%			;[9156] Close it
	 ERJMP .+1		;[9156] Avoid MONNEJ

	RETSKP			;[9156]  and skip return

	SUBTTL Host File Routines -- File Reading -- Read Line from File

;[8975] GLINE - Read a line in that isn't a comment line eating nulls
;Call with P3/ JFN of file
;Returns+1 if EOF
;Returns+2 with line read into LINBUF, P4/ pointing into LINBUF

GLINE:	SAVEAC <P1>		;Save the P
	MOVEI P1,<LINBSZ*5>-1	;Load space available in line buffer
	MOVEI P4,LINBUF		;Point to line buffer
	HRLI P4,(POINT 7)	;Make it a byte pointer

GLINE1:	CALL GCHAR		;(P3/T1) Get a character from the file
	 JRST HFILDN		;EOF
	CAIE T1,"!"		;Is it any flavor
	CAIN T1,";"		; of comment line?
	JRST GLINE7		;Yes, eat rest of line
	CAIN T1,.CHLFD		;Is it a line feed?
	JRST GLINE1		;Yes, a blank line was seen here
	CAIE T1,.CHCRT		;Is it a return or 
	CAIN T1,.CHFFD		; is it a form feed?
	JRST GLINE1		;Yes, check next character
	CAIE T1," "		;Space
	CAIN T1,.CHTAB		; or tab?
	JRST GLINE1		;Yep
	JRST GLINE2		;Nope, its a real line!

GLINE7:	CALL GCHAR		;(P3/T1) Get next character to eat
	 RET			;EOF in comment 
	CAIN T1,.CHLFD		;Is it EOL?
	JRST GLINE1		;Yes
	JRST GLINE7		;Nope, eat some more

GLINE3:	CALL GCHAR		;(P3/T1) Get the next character
	 MOVEI T1,.CHLFD	;EOF, load a line feed to tie off buffer

GLINE2:	IDPB T1,P4		;Store character in output buffer
	CAIE T1,.CHLFD		;End of loop?
	SOJG P1,GLINE3		;Nope, get more characters if room

	JUMPE P1,HFILTL		;Error if line too long
	MOVEI P4,LINBUF		;Point to line buffer
	HRLI P4,(POINT 7)	;Make byte pointer to that fine buffer
	RETSKP			;Skip return ourselves
	SUBTTL Host File Routines -- File Reading -- Read Character from File

;Routine to read one non null character from file.
;Returns +1 if EOF or error
;Returns +2 with T1/ character

GCHAR:	SOSGE HSTCNT		;Is there a character available?
	IFSKP.			;If so
	  ILDB T1,HSTPTR	;Get a character
	  JUMPN T1,RSKP		;Skip return for non null
	  JRST GCHAR		;Get next character
	ENDIF.			;End of characters available code

;No characters left, we have to play like we are a PMAP JSYS and get more data.

	SOSGE HSTPGC		;Count down one page
	RET			;End of file
	SETZ T1,		;Indicate no mapping desired
	MOVEI T2,FPG0A		;Load address (not page number)
	CALL SETMPG		;(T1,T2/) Unmap old page
	AOS T1,HSTPAG		;Get page number to map
	MOVE T2,P3		;Get JFN of the file
	IMULI T2,MLJFN		;Compute internal address of it
	HLL T1,FILOFN(T2)	;Get OFN,,pn
	MOVX T2,<PTRW!FPG0A>	;Get access and address of page to map
	CALL SETMPG		;(T1,T2/) Map that page in for us
	SKIP FPG0A		;Page fault it in
	 ERJMP R		;Return now if file damage
	MOVE T1,[POINT 7,FPG0A]	;Point to address we mapped file into
	MOVEM T1,HSTPTR		;Store the pointer to the data
	MOVEI T2,PGSIZ*5	;Load number of 7 bit bytes there
	MOVEM T2,HSTCNT		;Store as bytes available
	JRST GCHAR		;OK, now get a byte
	SUBTTL Host File Routines -- File Reading -- Read Field from File

;[8975] RDFLD - Read next field.  Field is terminated by a comma or colon.
;[9156] RDFLDL - Like RDFLD only don't raise lower case to upper case.
;Leading spaces and tabs are eaten.
;
;Returns+1 always with
;	T1/ number of characters read
;	T2 and TERM/ terminating character
;	T3/ end of string pointer into TMPBUF
;	P4/ updated
;	TMPBUF/ string (Null terminated)
;ACs:
;	T1/ characters read
;	T2/ current character
;	T3/ pointer to TMPBUF (returned)
;	T4/ nonzero to raise lower to upper case
;	P4/ pointer to LINBUF (given)

RDFLDL:	TDZA T4,T4		;[9156] Here to read field allowing lower case
RDFLD:	SETO T4,		;[9156] Raise lower to upper case
	SETZ T1,		;Clear returned field length
	MOVEI T3,TMPBUF		;Point to temp buffer
	HRLI T3,(POINT 7)	;Make that a byte pointer
	SETZM TMPBUF		;First word of buffer must be zero
	MOVSI T2,TMPBUF		;[9156] Get ready to clear the buffer
	HRRI T2,1+TMPBUF	;[9156]  so that the ending word of
	BLT T2,<TMPBSZ-1>+TMPBUF ;[9156]   the string won't have junk in it

;Eat any leading spaces or tabs.

RDFLD1:	ILDB T2,P4		;Load byte from line pointer
	CAIE T2,.CHTAB		;Tab
	CAIN T2," "		; or space?
	JRST RDFLD1		;Yes, ignore it

;Read through and store the field until a comma or colon or space or tab or
;return or line feed is seen.

RDFLD2:	CAIE T2,":"		;Was it a colon
	CAIN T2,","		; or a comma?
	JRST RDFLDX		;Yes, this is the end of the field
	CAIE T2," "		;Was it a space
	CAIN T2,.CHTAB		; or tab?
	JRST RDFLDD		;Yes, eat until terminator seen
	CAIN T2,.CHLFD		;Line feed seen?
	JRST PEOLX		;Yes, error
	IFN. T4			;[9156] If we are raising lower case
	  CAIL T2,"A"+40	;[9156] Is this lower case?
	  SUBI T2,40		;[9156] Yes, raise to upper case
	ENDIF.			;[9156] End of lower case check
	IDPB T2,T3		;Save that character in the temp buffer
	AOS T1			;Count character we just stored
	CAIL T1,<TMPBSZ*5>-1	;Was that the last character?
	JRST PEFLDX		;Yep, this line is in error
	ILDB T2,P4		;Load next character from line
	JRST RDFLD2		;Continue 

;Here if space or tab seen after the field has been read, eat until terminator.

RDFLDD:	ILDB T2,P4		;Load a character from the line
	CAIE T2,","		;Was it a comma?
	CAIN T2,":"		; or a colon?
	JRST RDFLDX		;Yes, field terminator seen
	CAIN T2,.CHLFD		;Is it a line feed?
	JRST PEOLX		;Yes, error
	JRST RDFLDD		;Yes, loop until terminator seen

;Here when terminator seen, store it and return.

RDFLDX:	MOVEM T2,TERM		;Save terminator
	RET			; and return

;[8975] SKPFLD - Skip to next field (next ":").
;Returns +1 always.

SKPFLD:	ILDB T2,P4		;Load a byte from the pointer
	CAIN T2,":"		;Start of new field?
	RET			;Yes, done
	CAIN T2,.CHLFD		;Is it the end of line character?
	JRST PEOLX		;Yes so error
        JRST SKPFLD		;No, continue munching along
	SUBTTL Host File Routines -- File Reading -- Read Decimal Number

;[9156] RDNUMB - Read a decimal number.
;Call with
;	P4/ pointer to line buffer
;Returns +1 always
;	T1/ number
;	P4/ updated count
;	TERM/ terminating character

RDNUMB:	SETZ T1,		;[9156] Clear the returned number
	DO.			;[9156] Loop to read digits
	  ILDB T2,P4		;[9156] Load a character
	  CAIL T2,"0"		;[9156] Is it a
	  CAILE T2,"9"		;[9156]  digit?
	  EXIT.			;[9156] Nope, get out
	  IMULI T1,^D10		;[9156] Shift over previously accumulated 
	  ADDI T1,-"0"(T2)	;[9156] Convert char to binary and add it in
	  LOOP.			;[9156] and then loop some more
	OD.			;[9156] End of loop
	MOVEM T2,TERM		;[9156] Save terminator
	RET			;[9156] Return
	SUBTTL Host File Routines -- File Reading -- Read Host Number

;[8975] RDHNUM - Read a host number.  Attempts to do it quickly since it will
;do it often.
;Returns+1 always, T1/ number
;ACs:
;	T1/ host number returned 
;	T2/ character
;	T3/ current number accumulator
;	T4/ count of octets to read-1 (0 is last one)
;	P4/ pointer to line buffer

RDHNUM:	SETZ T1,		;Clear returned host number
	MOVEI T4,3		;Load the number of numbers to read -1

RDHNU1:	SETZ T3,		;Clear this digit's counter

RDNHU2:	ILDB T2,P4		;Load a character

	CAIE T2,.CHTAB		;I guess we could check for TABs too
	CAIN T2," "		;Is it a message from space?
	JRST RDNHU2		;Yes, eat it
	CAIL T2,"0"		;Is it a
	CAILE T2,"9"		; digit?
	JRST RDNHU3		;[9156] No, end of octet, check terminator

;Appears to be a digit, count it in and continue reading

	IMULI T3,^D10		;Shift over previously accumulated digits
	ADDI T3,-"0"(T2)	;Convert character to binary and add it in
	JRST RDNHU2		; and get another character

;[9156] Here when character is not a digit or space.  Accumulate host number.
;Check if legal terminator (period).  If terminator is a dot and more octets to
;get, loop for more of them.  If non-dot terminator, make sure 4 octets read.

RDNHU3:	EXCH T3,T1		;Get octets read so far
	LSH T3,^D8		;Shift over by one octet
	ADDM T3,T1		;Add in new part of octet
	CAIN T2,"."		;[9156] Was the terminator a dot?
	SOJGE T4,RDHNU1		;Count down and jump if more to read
	JUMPN T4,RDHNE2		;[9156] Error if four octets not read
	MOVEM T2,TERM		;Save terminator for later check
	RET			;And return
	SUBTTL Host File Routines -- File Reading -- Error Handlers

;Error handlers for host file reading subroutines.

RDHNE2:	JSP T1,HFILER		;[8975] Illegal character in host number
	ASCIZ/%Bad host number format in / ;[8975]

PEOLX:	JSP T1,HFILER		;[8975] End of line when reading field
	ASCIZ/%Premature end of line in / ;[8975]

PEFLDX:	JSP T1,HFILER		;[8975] Oops, field too big
	ASCIZ/%Field too long in / ;[8975]

HFILTL:	JSP T1,HFILER		;[8975] Line too long by GLINE's account
	ASCIZ/%Line too long in / ;[8975]
	SUBTTL Host File Routines -- File Reading -- Error Printout

;[8975] HFILER - Error printout routine.  Outputs line from HOSTS.TXT with
;an uparrow at the spot we stopped parsing.  HSTFIL points to hosts filename 
;we are reading.
;Call:	JSP T1,HFILER
;	ASCIZ/%error/
;Returns always to HFILDN

HFILER:	CALL TCRLF		;(/) Output a crlf first
	HRLI T1,(POINT 7)	;Make a byte pointer from the address
	PSOUT%			;Send that to the CTY please
	MOVE T1,HSTFIL		;Point to host filename again
	PSOUT%			;Send that to the CTY
	CALL TCRLF		;(/) Output yet another crlf
	MOVEI T2,LINBUF		;Point to line buffer
	HRLI T2,(POINT 7)	;Make it a byte pointer

HFILE3:	ILDB T1,T2		;Load a character from line buffer
	PBOUT%			;Print on the CTY
	CAIN T1,.CHLFD		;Terminator to this line?
	JRST HFILDN		;Done if end of this line
	CAME T2,P4		;Is it time for the signal character?
	JRST HFILE3		;Nope
	MOVEI T1,"^"		;Load uparrow
	PBOUT%			;Send to the CTY
	JRST HFILE3		;Loop for entire line

;Small routine to print a CRLF on the console terminal preserving T1
;Returns +1 always

TCRLF:	PUSH P,T1		;Save T1
	HRROI T1,CRLF		;Point to CRLF
	PSOUT%			;Send that to the CTY
	POP P,T1		;Restore T1
	RET			;Return to caller

	ENDTV.			;End of HSTINI TRVAR
	SUBTTL Address File Routines -- Read SYSTEM:INTERNET.ADDRESS

;ADRINI
;Reads in the file SYSTEM:INTERNET.ADDRESS and initializes the interface tables
;from it.  Called from MNTINI at system startup, does skip return if
;successful.

;Entries are of the form:
;	AN20#0, 10 0 0 79,NCP,PACKET-SIZE:1004,DEFAULT
;	IPNI#0, 192 5 6 1,PACKET-SIZE:1500,PREFERRED
;	IPCI#0, 192 5 5 4,PACKET-SIZE:632

; AC usage
;	P1/ NCT associated with local address in P2
;	P2/ Local address once read
;	P3/ JFN of input file
;	P4/ Pointer into line buffer

	BUFSIZ==10		;[8969] Size of temp string buffer
	LINSIZ==<^D135/5>	;[8975] Size of line buffer

ADRINI::SAVEPQ			;Watch your Ps and Qs
	TRVAR <<LINBUF,LINSIZ>,<TMPBUF,BUFSIZ>> ;[8975]
	MOVX T1,GJ%OLD!GJ%SHT	;[8975] Old file, short form
	HRROI T2,[ASCIZ /SYSTEM:INTERNET.ADDRESS/] ;The filename desired
	GTJFN			;[8975] Get a JFN on that file please
	 RET			;[8975] Can't, probably file not found
	MOVEM T1,P3		;[8975] Save JFN in P3
	MOVX T2,FLD(7,OF%BSZ)!OF%RD ;[8975] Open for reading
	OPENF			;[8975] Pry it open
	 ERJMP ADRINO		;[8975] Can't open it!

	SETZ T1,		; clear an index
ADRIN1:	SKIPN NLHOST(T1)	; slot used?
	JRST ADRLP0		; no, done with table, enter main loop
	SETOM NLHOST(T1)	; empty that slot
	AOJA T1,ADRIN1		; and loop

;Here to examine next line in file

ADRLP0:	CALL GBOL		;[8975](P3/P4) Read in a non-comment line
	 JRST ADRDUN		; Done with file

;Read in the interface type for keyword match

	CALL GFIELD		;[8975](P4/P4,T2) Read in a field today
	CALL REEAT		;[8975](P4/P4) Back up over the terminator

;The interface type has been read, see if it is in the table.

	MOVEI T1,INTNAM		; point to type table
	HRROI T2,TMPBUF		;[8975] Point to the buffer we use
	TBLUK			; and look it up
	 ERJMP .+1		;[8969] Avoid MONNEJ
	TXNE T2,TL%NOM!TL%AMB	; match?
	JRST ADRUIT		;[8975] Nope, unknown interface type
	HRRZ T4,(T1)		; get entry

;Read in interface number if needed

	CALL GCH		;[8975](P4/P4,T2) Get terminator
	 JRST ADIERR		;[8975] Not EOL here!
	CAIE T2,","		;[8975] Comma?
	IFSKP.			;[8975] If not
	  SETZ T2,		;[8975] Yes, use interface 0 
	ELSE.			;[8975] Not comma, should be number sign
	  CAIE T2,"#"		;[8975] Interface number?
	  JRST ADIERR		;[8975] Nope, error
	  MOVE T1,P4		;[8975] Point to line buffer
	  MOVEI T3,^D10		; read in decimal
	  NIN			;Read number into T2
	   ERJMP ADIERR		;[8969] Error, maybe EOF
	  MOVEM T1,P4		;[8975] Store pointer back
	ENDIF.			;[8975] And continue

	CALL REEAT		;[8975](P4/P4) Backup over terminator
	SETZ P1,		;[8975] In case no particular interface
	CAIN T4,NT.NIN		; No particular interface?
	JRST ADGNUM		; right, No NCT associated with it

; Now find the NCT for the interface
;	T2/ interface number
;	T4/ interface type

	XMOVEI P1,NCTVT		;[8975] Point to vector table
ADFINT:	MOVE P1,(P1)		;[8975] Get next in list
	JUMPE P1,ADIGON		;[8975] Specified interface is not found
	LOAD T1,NTDEV,(P1)	;[8975] Get interface type
	CAIE T1,(T4)		; Same as we're looking for?
	JRST ADFINT		; No, try next
	SOJGE T2,ADFINT		; Try another if not right number

;Read in the address on that interface, hash it into the table

ADGNUM:	CALL GCH		;[8975](P4/T4,T2) Get character
	 JRST ADRNER		;[8975] EOL
	CAIE T2,","		;[8975] Must be comma
	JRST ADRNER		;[8975] It wasn't
	CALL ADG4DB		;(T4,P4/T1) Get 4 decimal bytes into T1
	 JRST ADINER		;[8975] Error!
	MOVEM T1,P2		; Get into right register
	CALL HSTHSH		;(T1/T2) Hash it into table
	 JUMPL T2,NETFUL	; No room for number
	MOVEM P2,HOSTNN(T2)	;[9157] Put number in table
	MOVX CX,HS%UP!HS%SLF!HS%VAL!.HST20 ;[9156] It is me, I'm up, valid
	IORM CX,HSTSTS(T2)	;[9157] Mark it so in status

	SETZ T2,		; clear an index
ADGNM1:	SKIPLE NLHOST(T2)	; anything in this slot?
	AOJA T2,ADGNM1		; No, try next
	SKIPL NLHOST(T2)	; empty?
	JRST NETFUL		; No, table overflow.
	MOVEM P2,NLHOST(T2)	; save number
	JUMPE P1,ADGNM2		;[8975] Skip next if no NCT assoc with number
	MOVEM P2,NTLADR(P1)	;[8975] Set local address
	NETNUM T1,P2		; Get the network number
	MOVEM T1,NTNET(P1)	;[8975] Set it in NCT
ADGNM2:	CALL REEAT		;[8975](P4/P4) Reeat last character

;Now
;	P1/ NCT associated with local address in P2
;	P2/ Local address once read
;	P3/ JFN of input file
;	P4/ Pointer into line buffer

;Time to read in the keywords following the "interface[#n],address".
;Come to the top of this loop with the comma (or eol) next to be read.

ADRLP3:	CALL GCH		;[8975](P4/P4,T1) Check character after address
	 JRST ADRLP0		;[8975] EOF or EOL is OK
	CAIE T2,","		;[8969] Comma?
	JRST ADRKER		;[8969] Nope, format error

	CALL GFIELD		;[8975](P4/P4,T2) Get the next field
	CALL REEAT		;[8975](P4/P4) Backup over the terminator

	MOVEI T1,TYPNAM		; point to type table
	HRROI T2,TMPBUF		;[8975] Point to the buffer in question
	TBLUK			; and look it up in table
	 ERJMP .+1		;[8975] Avoid MONNEJ
	TXNE T2,TL%NOM!TL%AMB	; good name?
	JRST ADRUND		;[8969] No
	MOVE T1,(T1)		; get routine address
	CALL (T1)		; go to it
	JRST ADRLP3		; and loop

;DEFAULT keyword, used to set this address as the primary host name.
;[9156] Sets DEFNET, NETFLD, DEFADR, NOHOST

ADDFLT:	SKIPN PRFNET		; Preferred network set up?
	CALL ADDPRF		;[9156] (P2/) Nope, set PRFxxx
	NETNUM T1,P2		; Get the network number
	MOVEM T1,DEFNET		; Save as default network number
	MOVE T1,P2		;[9156] Get the default address again
	CALL NETMSK		;[9156] (T1/T1,T2,T3) Get the masks for it
	MOVEM T2,NETFLD		; Set as default network field
	MOVEM P2,DEFADR		; Save as default address
				; Kludge up the 8 bit host address
	MOVE T2,P2		; get number again
	ROTC T2,-6		; Save IMP number
	LSH T2,-^D10		; Flush middle bits
	ROTC T2,6		; Combine Host and IMP
	ANDI T2,377		; Round to 8 bits
	MOVEM T2,NOHOST		; Save in proper cell
	RET			; and return

;PREFERRED keyword to set this address as the preferred one for this host.
;[9156] Sets PRFNET, PRFADR, PRFNFD, PRFMSK.

ADDPRF:	NETNUM T1,P2		; Get the network number
	MOVEM T1,PRFNET		; Save as preferred network number
	MOVE T1,P1		;[9156] Load the address
	CALL NETMSK		;[9156] (T1/T1,T2,T3) Return the masks
	MOVEM T2,PRFNFD		; Set as preferred network field
	MOVEM P2,PRFADR		; Save as preferred address
	MOVEM T3,PRFMSK		;[9156] Save the preferred address mask field
	RET			;[9156] Return to get more keywords

;NCP keyword, indicates that this network uses Arpanet NCP protocol

ADNCP:	MOVEI T1,NT.NCP		; get NCP network type
	STOR T1,NTTYP,(P1)	;[8975] Save in NCT
REPEAT 0,<			;[8969] This code is a slow no-op
	MOVE T1,NTNET(P1)	;[8975] Get the network number
	CAILE T1,^D255		; Valid type A address?
	 JFCL			; Error
; once host tables are right, find hosts for this net and set in NCP tables
>				;[8969] end of repeat 0
	RET			; and done

;PACKET-SIZE:n keyword, next parameter is the maximum packet size for this
;interface in decimal bytes.

ADPSIZ:	CALL GCH		;[8975] Read terminator of keyword
	 JRST ADRPER		;[8975] Uh oh
	CAIE T2,":"		;[8975] Must be colon
	JRST ADRPER		;[8975] Nope you lose today
	MOVE T1,P4		;[8975] Get pointer to data
	MOVEI T3,^D10		; decimal
	NIN
	 ERJMP ADRERP		;[8969] Error, invalid packet size
	MOVEM T1,P4		;[8975] Restore the pointer
	JUMPLE T2,ADRERP	;[8969] Jump if zero or -ive size
	MOVEM T2,NTPSIZ(P1)	;[8975] Save the size
	CALLRET REEAT		;[8975] (P4/P4) Reeat terminator and return

;LOGICAL-HOST-MASK keyword, next parameter is the 32-bit mask for this
;interface in decimal bytes.

ADLHM:	CALL GCH		;[8975] Read terminator of keyword
	 JRST ADRLER		;[8975] Uh oh
	CAIE T2,":"		;[8975] Must be colon
	JRST ADRLER		;[8975] Nope you lose today
	CALL ADG4DB		;(P4,T4/P4,T1) Read 4 decimal bytes
	 JRST ADRILH		;[8975] Can't read that logical host mask
	MOVEM T1,NTNLHM(P1)	;[8975] Save the mask
	CALLRET REEAT		;[8975](P4/P4) Reeat terminator and return

;Here when it is time to close the file.
;[9156] Returns +1 if no addresses read.
;[9156] Return +2 to our caller if there was at least one address read.

ADRDUN:	MOVE T1,P3		;[9156] Load the JFN
	CLOSF			; Close the JFN
	 ERJMP .+1		;[8969] Avoid MONNEJ, don't worry if fails
	SKIPG P2,NLHOST+0	;[9156] Skip if there is at least one address
	RET			;[9156] Nope, return +1
	SKIPN DEFADR		; was default address set?
	CALL ADDFLT		;(P2/) No, use this one as default
	RETSKP			; And return succesfully
	SUBTTL Address File Routines -- Get To Beginning Of Line

;[8975] GBOL - Read in a non-comment line for GCH.
;Call with P3/ JFN
;Returns +1 if EOF hit
;Returns +2 with LINBUF/ line read in, P4/ pointer into LINBUF

GBOL:	MOVE T1,P3		;Get JFN
	HRROI T2,LINBUF		;Point to line buffer
	MOVEI T3,<LINSIZ*5>-1	;Load maximum characters to read
	MOVEI T4,.CHLFD		;End of a line feed
	SIN%			;Read in a line of the file
	 ERJMPR GBOL7		;Error, could be EOF, check it out
	JUMPE T3,GBOL6		;Line too long?  This should not happen
	IDPB T4,T2		;Insure a line feed is at end of buffer
	MOVEI P4,LINBUF		;Point to line buffer
	HRLI P4,(POINT 7)	;Make it a byte pointer

;A line as been read into the line buffer.  See if it is a comment line or a
;blank line and if so, read another line.  

GBOL1:	CALL GCH		;(P4/T1) Get non-blank non-comment character
	 JRST GBOL		;Linefeed, nothing on this line
	CALL REEAT		;(P4/P4) Backup the pointer one character
	RETSKP			;Return +2 

;Here if line too long!

GBOL6:	TMSG <%Line too long in SYSTEM:INTERNET.ADDRESS
>
	SETZ P4,		;No pointer to this error
	CALL PERROR		;(P4/) Print this bad line please
	JRST GBOL		;Get another line

;Here when SIN returned an error, it should have been the usual IOX4 error.

GBOL7:	CAIN T1,IOX4		;Should be end of file
	RET			;EOF!
	TMSG <%Error while reading SYSTEM:INTERNET.ADDRESS
>
	RET			;Assume we are at EOF now

;[8975] Small routine to backup the byte pointer in P4
;Call with P4/ byte pointer
;Returns +1 always, P4/ backed up one character

REEAT:	SETO CX,		;Load a -1
	ADJBP CX,P4		;Get the byte pointer backed up one character
	MOVEM CX,P4		;Reload new byte pointer
	RET			;Return +1
	SUBTTL Address File Routines -- Read Character from File

;[8975] GCH - read the next non-comment, non-blank, non-null character
;Call with P4/ line buffer pointer
;Returns +1 if EOF or EOL
;Returns +2 if character T2/ character

GCH:	CALL GCH1		;(P4/T1) Get a byte
	 RET			;Gosh, EOF or EOL
	CAIE T2,"!"		;[8969] Is it a bang?
	CAIN T2,";"		; or a semi?
	JRST GCHSMC		;Yes, ignore it
	CAIE T2,.CHTAB		;Tab?
	CAIN T2," "		; or SPACE?
	JRST GCH		;Yes, skip it
	RETSKP			;Else return+2 with T2/character

GCHSMC:	CALL GBIN		;(P4/T1) Comment seen, get a byte
	 RET			;EOF or EOL
	JRST GCHSMC		;Loop for all characters until EOF or EOL

;Small routine to read characters, eats returns, nulls, and form feeds
;Call with P4/ line buffer pointer
;Returns +1 if EOF
;Returns +2 T1/ JFN, T2/ character

GCH1:	CALL GBIN		;(P4/T1) BIN a byte
	 RET			;Oops, EOF or EOL
	CAIE T2,.CHCRT		;Ignore return
	CAIN T2,.CHFFD		; and form-feed
	JRST GCH1		;It was one, eat it
	RETSKP			; return with T2/ character

;Small routine to do a BIN, eats nulls
;Call with P4/ line buffer pointer
;Returns +1 if EOF or EOL
;Returns +2 T2/ character

GBIN:	ILDB T2,P4		;[8975] Get a character from the line buffer
	CAIN T2,.CHLFD		;[8975] End of line?
	CALLRET REEAT		;[8975] Yep, reeat it and return
	JUMPN T2,RSKP		;Return good if character there
	JRST GBIN		;Flush nulls
	SUBTTL Address File Routines -- Read Field from File

;[8975] Routine to read a string into TMPBUF from the file.
;Call with P4/ pointer to line buffer
;Returns +1 always T2/ terminator which is not reeaten

GFIELD:	SETZM TMPBUF		;First word should be zero
	MOVEI T4,<BUFSIZ*5>-1	;Load total size of buffer
	MOVEI T3,TMPBUF		;Point to temp buffer
	HRLI T3,(POINT 7)	;Make a byte pointer

GFIEL1:	CALL GCH		;(P4/T2) Get character from file
	 JRST GFIEL2		;End of that field
	CAIE T2,"#"		;Is it a legal
	CAIN T2,","		; terminator?
	JRST GFIEL2		;Yep, end of that field
	CAIN T2,":"		;Is it a colon?
	JRST GFIEL2		;Yep, that's a terminator
	IDPB T2,T3		;Store that character in string
	SOJGE T4,GFIEL1		;Loop for all of them
		
GFIEL2:	SETZ T4,		;Load a zero
	IDPB T4,T3		;Store it at end of string
	RET			;Return to caller
	SUBTTL Address File Routines -- Read Four Decimal Bytes

;ADG4DB - Read in 4 decimal bytes from INTERNET.ADDRESS file
;Call:	T4/ String pointer to error message
;	P4/ Pointer to line buffer
;Returns+1 if failure
;Returns+2 Success, T1/ address

ADG4DB:	SETZ T4,		;[8975] Clear the returned mask word
	MOVEI Q1,4		;There are 4 fields to an address
ADG4D2:	MOVE T1,P4		;[8975] Get pointer to data
	MOVX T3,^D10		;Again decimal
	NIN			;Input number from terminal
	 ERJMP R		;[8975] Return +1 if error
	MOVEM T1,P4		;[8975] Restore pointer to data
	JUMPL T2,R		;[9132] Return +1 if -ive number input
	CAILE T2,^D255		;[9132] Is the number of of range?
	RET			;[9132] Nope, its a legal octet
	IORM T2,T4		;[8975] Merge in latest part
	SOJLE Q1,ADG4D8		;Count this digit and jump if 4 octets read
	LSH T4,^D8		;[8975] No shift over part read so far
	MOVE T1,P4		;[9132] Load the pointer to the data again
	ILDB T2,T1		;[9132] Get the next byte
	CAIN T2,"."		;[9132] Allow dot as octet seperator
	MOVEM T1,P4		;[9132] Yes, it was, eat the dot
	JRST ADG4D2		;Loop through all 4 fields

ADG4D8:	MOVEM T4,T1		;[8975] Return full address
	RETSKP			;[8975] Skip return
	SUBTTL Address File Routines -- Error Handlers

;[8975] Here on various format errors in INTERNET.ADDRESS

ADRUIT:	JSP T1,ADRERR		;[8975] TBLUK failed
	ASCIZ /%Unknown interface type/	;[8975]

ADIERR:	JSP T1,ADRERR		;[8975] Error on the NIN
	ASCIZ /%Error in interface number/ ;[8975]

ADIGON:	JSP T1,ADRERR		;[8975] Couldn't find the NCT for interface
	ASCIZ /%Specifed interface was not found/ ;[8975]

ADRNER:	JSP T1,ADRERR		;[8975] 
	ASCIZ /%Comma not after interface type/ ;[8975]

ADINER:	JSP T1,ADRERR		;[8975] Can't read address for this interface
	ASCIZ /%Invalid address/ ;[8975]

ADRUND:	JSP T1,ADRERR		;[8975] TBLUK failed
	ASCIZ /%Unknown network descriptor/ ;[8975]

ADRPER:	JSP T1,ADRERR		;[8975] Colon not after "PACKET-SIZE"
	ASCIZ /%Colon not after PACKET-SIZE/ ;[8975]

ADRERP:	JSP T1,ADRERR		;[8975]
	ASCIZ /%Invalid PACKET-SIZE/ ;[8975]

ADRLER:	JSP T1,ADRERR		;[8975] Colon not after "PACKET-SIZE"
	ASCIZ /%Colon not after LOGICAL-HOST-MASK/ ;[8975]

ADRILH:	JSP T1,ADRERR		;[8975] ADG4DB failed to read LHM
	ASCIZ /%Invalid LOGICAL-HOST-MASK value field/ ;[8975]

ADRKER:	JSP T1,ADRERR		;[8975]
	ASCIZ /%Format error in network interface descriptor list/ ;[8975]

;Here to write error string pointed to by T1, print line in error, and loop.

ADRERR:	HRLI T1,(POINT 7)	;[8975] Insure byte pointer in T1
	PSOUT			;Write error string to the CTY
	HRROI T1,[ASCIZ / in SYSTEM:INTERNET.ADDRESS file
/]				;[8969] Finish the error string
	PSOUT			;[8975] on the CTY
	CALL PERROR		;(P4/) Print offending line
	JRST ADRLP0		; And loop

;Here if EOF in a bad place in INTERNET.ADDRESS file.

ADREOF: HRROI T1,[ASCIZ /%Premature EOF in SYSTEM:INTERNET.ADDRESS

/]				;[8969]
	PSOUT			;Send that to the CTY
	CALL PERROR		;(P4/) Print bad line
	CALL ADRDUN		;[9156] Close the file
	 JFCL			;[9156] Ignore error return
	RET			;[9156] Give +1 (error) return

;[8975] Here when OPENF fails for SYSTEM:INTERNET.ADDRESS

ADRINO:	MOVE T1,P3		;[8975] Load the JFN
	RLJFN			;[8975] Release it
	 ERJMP .+1		;[8975] Avoid the usual MONNEJ
	TMSG <%Can't open SYSTEM:INTERNET.ADDRESS 
>				;[8975] Useful error message
	RET			;[8975] Return +1 (error)

;Here if no room in host table for our host name.

NETFUL:	BUG.(HLT,NORMIA,MNETDV,SOFT,<No room in host tables for local address>,,<

Cause:	The Internet Multinet code is unable to allocate space in the network 
	hash table for a local address from the SYSTEM:INTERNET.ADDRESS file.
>)

	SUBTTL Address File Routines -- Print bad line on CTY

;[8975] PERROR - Print out the erring line in the file.
;Call with LINBUF/ current line, P4/ current pointer

PERROR:	CALL REEAT		;(P4/P4) Back up one character please
	MOVEI T2,LINBUF		;Point to line buffer
	HRLI T2,(Point 7)	;Make a byte pointer out of it

PERLP:	ILDB T1,T2		;Get a character from the line
	PBOUT%			;Print it
	CAIN T1,.CHLFD		;End of string?
	RET			;Yes, return now
	CAME T2,P4		;Point of error?
	JRST PERLP		;Nope
	MOVEI T1,"^"		;Load signal character
	PBOUT%			;Print it
	JRST PERLP		;And loop


	ENDTV.			;End of TRVAR for ADRINI
	SUBTTL Address File Routines -- Tables 

; Tables for address file keywords

; Start a table definition

DEFINE TABLE(NAME)<
NAME:  XWD ..'NAME,..'NAME
..TABLE==0		; Init count
>
DEFINE TABEND(NAME)
< ..'NAME==..TABLE>

DEFINE KEY(NAME,DATA)
< XWD [ASCIZ /NAME/],DATA
  ..TABLE==..TABLE+1		; Increment the count of entries
>

; Table of interface type names

TABLE(INTNAM)
KEY AN20,NT.ANX			; AN20 Interface
KEY IPCI,NT.CIP		  	; KLIPA Interface
KEY IPNI,NT.NIP			; KLNI Interface
KEY IPNIA,NT.NIA		;[9135] IPNI alternate address
TABEND(INTNAM)

; Take of modifiers

TABLE(TYPNAM)
KEY DEFAULT,ADDFLT		; This is the 'primary' address for host
KEY LOGICAL-HOST-MASK,ADLHM	; Logical host mask for this network
KEY NCP,ADNCP			; network uses Arpanet NCP protocal
KEY PACKET-SIZE,ADPSIZ		; Maximum packet size allowed
KEY PREFERRED,ADDPRF		; This is the 'preferred' address for host
TABEND(TYPNAM)

	SUBTTL CVHST% JSYS - Convert Host Number to String

REPEAT 1,<			;THIS JSYS IS VERY TEMPORARY
XNENT (.CVHST,G)		;.CVHST::
	MCENT
	MOVE T1,T2		;GET HOST NUMBER IN RIGHT PLACE
	CALL LCKGTH		;[9170] Lock the host table lock, go noint
	CALL GTHNTS		;CONVERT NUMBER TO STRING
	 EMRETN(CVHST1,<CALL ULKGTH>) ;[9170] Unlock, give error to user
	CALL ULKGTH		;[9170] Unlock the host table lock
	LOAD P3,HSTNMP,(P1)	;[9156] Get the name pointer
	ADD P3,[<OWGP. 7>+<INTSEC,,HSTNAM>] ;[9156] Make a byte pointer to name
	UMOVE T1,1		;GET DESINATION
	CALL GTHSOU		;(T1,P3/T1) Write string to user space
	 EMRETN()		;[9156] Return error in T1
	UMOVEM T1,1		;WRITE UPDATED POINTER TO USER SPACE
	JRST SKMRTN
>

	SUBTTL GTHST% JSYS

;The GTHST% JSYS is used to get information on a host or network.  
;Called as in JSYS documentation.
;The following register conventions are used in GTHST:
;	P1/ Index into Name tables
;	P2/ Index into Hash (status) tables

XNENT (.GTHST,G)		;.GTHST::
	MCENT

	HRRE P3,T1		;[9156] Copy the function code sign extended
	SKIPL P3		;[9156] Check range of
	CAILE P3,GTHMAX		;[9156]  function code
	RETERR (ARGX02)		;"Invalid function"
	SETOB P1,P2		;No number nor name
	CALL LCKGTH		;[9108] (/) Lock the name table

	CALL @GTHDSP(P3)	;[9156] (P1,P2/T1) Do the function
	IFSKP.			;[9156] Successful function return
	  CALL ULKGTH		;[9108] (/) Unlock host table lock
	  UMOVE T2,1		;[9156] Load user's AC1 again
	  MOVEI T1,.GTHVS	;[9156] Total success, load code for that
	  TXNE T2,GH%STA	;[9156] Returning status in AC1?
	  UMOVEM T1,1		;[9156] Return that to user if he asked for it
	  SMRETN		;[9108] Give skip return
	ENDIF.			;[9156] Otherwise the function failed

	CALL ULKGTH		;[9156] (/) Unlock the host table lock
	UMOVE T2,1		;[9156] Load user's T1
	TXNN T2,GH%STA		;[9156] Is the return status bit set?
	RETERR ()		;[9156] Return error in T1
	SETO T2,		;[9156] No code to return yet
	CAIE T1,GTHSX4		;[9156] "Format error in DNS message"?
	CAIN T1,GTHSX7		;[9156] "Server failed to find data"?
	MOVEI T2,.GTHVT		;[9156] Yes, return non-authoritative answer
	CAIN T1,GTHSX8		;[9156] "Data not found in namespace"?
	MOVEI T2,.GTHVF		;[9156] Yes, "Data not found in namespace"
	SKIPGE T2		;[9156] Is there some code to return now?
	RETERR ()		;[9156] Nope, return the error to the user
	UMOVEM T2,1		;[9156] Yes, return status into AC1 for user
	SMRETN			;[9156] Skip return to user

;Table of GTHST function codes.

GTHDSP:	NCTDSP GTHSIZ		;[9108](00) Get name table size
	NCTDSP GTHIDX		;[9108](01) Index into name space
	NCTDSP GTHNUM		;[9108](02) Convert number to string
	NCTDSP GTHSTR		;[9108](03) Convert string to number
	NCTDSP GTHHNN		;[9108](04) Status by number
	NCTDSP GTHHNI		;[9108](05) Status by index
	NCTDSP GTHNHN		;[9108](06) Get local number on a network
	NCTDSP GTHNST		;[9108](07) Get status table of a network
	NCTDSP GTHNLA		;[9108](10) Get local addresses on networks
	NCTDSP [RETBAD(ARGX02)] ;[9156](11) Reserved for GTDOM compatibility
	NCTDSP [RETBAD(ARGX02)] ;[9156](12) Reserved for GTDOM compatibility
	NCTDSP [RETBAD(ARGX02)] ;[9156](13) Reserved for GTDOM compatibility
	NCTDSP GTHDPN		;[9156](14) Get primary name and IP address
	NCTDSP GTHDMX		;[9156](15) Get MX (mail exchange) data
	NCTDSP GTHDAA		;[9156](16) Authenticate address
	NCTDSP [RETBAD(ARGX02)] ;[9156](17) Reserved for GTDOM compatibility
	NCTDSP GTHDVN		;[9156](20) Validate name
	NCTDSP [RETBAD(ARGX02)] ;[9156](21) Reserved for GTDOM compatibility
	NCTDSP [RETBAD(ARGX02)] ;[9156](22) Reserved for GTDOM compatibility
	NCTDSP GTHDOS		;[9156](23) Operating system
	NCTDSP GTHDNS		;[9156](24) Get DNS hosts and timeouts
GTHMAX==.-GTHDSP-1		;[9156] Highest function number
	SUBTTL GTHST% JSYS -- Common Routines -- Exit routines

;[8975] Utility routine to write host string to user space
;Exit routine for functions 1 and 2 to return host string to pointer in user 2.
;Also returns host number in user 2 and status in user 3.
;Called with
; 	P1/ host name index
;	P2/ host status index
;Returns +1 if error, 
;	T1/ error code
;Returns +2 always, with user's
;	AC2/ updated string pointer to host name
;	AC3/ internet host number
;	AC4/ host status

GTHTUS:	LOAD P3,HSTNMP,(P1)	;[9156] Get the name pointer
	ADD P3,[<OWGP. 7>+<INTSEC,,HSTNAM>] ;[9156] Make a byte pointer to name
	UMOVE T1,2		;Get dest
	CALL GTHSOU		;(T1,P3/T1) Write string
	 RETBAD()		;[9156] Return error to user
	UMOVEM T1,2		;Update user's pointer
;	CALLRET GTHSXX		;Common exit routine

;Common exit routine for functions 2, 3, 4.
;Call with
; 	P1/ host name index
;	P2/ host status index
;Returns +2 always, with user's
;	AC3/ internet host number
;	AC4/ host status

GTHSXX:	MOVX T4,HS%NCK		;SET THE NICKNAME FLAG
	SKIPL P1		;NO NAME
	SKIPL HOSTN(P1)		;DID WE HAVE ONE?
	SKIPA T4,HSTSTS(P2)	;[9157] No, we did not have a nickname
	IOR T4,HSTSTS(P2)	;[9157] Yes, return status bits plus nickname 
	UMOVEM T4,4		;Return host status to user
	MOVE T3,HOSTNN(P2)	;[9157] Load the host number
	UMOVEM T3,3		;Return host number to user
	RETSKP			;[9108] Skip return 
	SUBTTL GTHST% JSYS -- Common routines --  Host address to host name routine

;[9156] GTHNTS - Utility routine to convert number to string
;Called from CVHST, GTHNUM, and GTHHNN.
;Call with T1/ number
;Returns +1 if host name not found, with
;	T1/ error code
;Returns +2 if host found, with
;	P1/ host name index
;	P2/ host status index

GTHNTS:	CALL CVNHST		;[9156] (T1/T1) Make host number new format
	MOVEM T1,P3		;[9156] Store the host number in P3
	CALL GTHNT0		;[9156] (T1/T1,P1,P2) Find name for host
	 SKIPA T1,P3		;[9156] Not in table, reload number and skip
	RETSKP			;[9156] Return with P1 and P2 set up
	CALL DNSNTS		;[9156] (T1/T1) Ask them to find it
	 RETBAD()		;[9156] Pass the error back to user
	MOVE T1,P3		;[9156] Reload the host number once again
	CALL GTHNT0		;[9156] (T1/T1,P1,P2) Now try for the name
	 RETBAD()		;[9156] Failed, so return with error code in T1
	RETSKP			;[9156] Return to caller with P1 and P2 set up

;[9156] Local routine called only from GTHNTS to find a host name.
;Call with
;	T1/ address
;Returns +1 if name not found or expired TTL with
;	T1/ error code GTHSX2 (not in tables) or GTHSX3 (no name known)
;Returns +2 if name found and TTL OK with
;	P1/ host name index and P2/ host status index
	
GTHNT0:	CALL HSTHSH		;[9156] (T1/T1,T2) Get its index
	 RETBAD (GTHSX2)	;[9156] Return "Unknown host number" error
	MOVE P2,T2		;[9156] Save index
	SKIPN P1,HOSTPN(P2)	;[9156] Does this host have a name?
	RETBAD (GTHSX3)		;[9156] Return "Unknown host name" error
	SETSEC P1,INTSEC	;[9156] Return proper section
	HLLO T2,HOSTPN(P2)	;[9156] Load TTL for this entry
	CAMGE T2,TODCLK		;[9156] Has the TTL expired for this one?
	RETBAD (GTHSX3)		;[9156] Return "Unknown host name" error
	RETSKP			;[9156]  with P1 and P2 set up
	SUBTTL GTHST% JSYS -- Common routines -- Host name to host address routine

;[9156] GTHSTN - Utility routine to convert host string to a number, called
;from GTHSTR, GTHDPN, and GTHDAA.  Copies string from byte pointer in user 2
;into STKVAR.  If host name is not in tables or cannot be used it makes a DNS
;request and then looks again for the host name.
;Returns +1 if host name not found
;	T1/ error code
;Returns +2 if host found and TTL ok
;	P1/ host name index
;	P2/ host status index

GTHSTN:	STKVAR <<GTHSBF,GTHSBL>> ;[9156] Make place to build strings
	MOVEI T3,GTHSBF		;[9156] Point to buffer
	HRLI T3,(POINT 7)	;[9156]  with a byte pointer
	MOVEM T3,P3		;[9156] Save that pointer
	CALL GTHSIN		;[9156] (T3/T1,T3) Get string from user
	 RETBAD()		;[9156] Return error in T1
	CALL GTHST1		;[9156] (P3/T1,P1,P2) Try to find that host
	 SKIPA T1,P3		;[9156] Not (yet) found, reload pointer to name
	RETSKP			;[9156] Return with P1 and P2 set
	CALL DNSSTN		;[9156] (T1/T1) Try the server
	 RETBAD()		;[9156] It didn't work, return badness to user
	MOVE T1,P3		;[9156] Point to the string again
	CALL GTHST2		;[9156] (P3/T1,P1,P2) Try it again
	 RETBAD()		;[9156] Return error in T1
	RETSKP			;[9156] Return with P1 and T1 or P2 set up
	ENDSV.			;[9156] End of STKVAR at GTHSTN

;[9156] Local routine called only by GTHSTN.  This routine calls the host
;lookup routine to try to find the name in the host tables.  If the supplied
;string is not found in the host tables, and the string does not contain a dot
;(indicating that it is a domain name) then the domain name implied by PRFADR
;is appended to the string and the name is looked up again.  If it is found it
;checks for the bit NS%INA which indicates that the information was from a
;"b.c.b.a.IN-ADDR.ARPA" PTR RR in which case it can't be trusted for the host
;name to host number translation.  If NS%INA is not set it checks the TTL of
;the entry.  Call with
;	P3/ pointer to host name to search for
;Returns +1 if host name not found or from IN-ADDR.ARPA or had expired TTL with
;	T1/ error code	
;Returns +2 if name found, is reliable, TTL ok, with
;	P1/ host name index
;	P2/ host status index

GTHST1:	MOVE T1,P3		;[9156] Copy pointer to host name T1
	CALL HSTLUK		;[9156] (T1/T2,T4) Try to find that one
	JUMPN T2,GTHST3		;[9156] We found it
	CALL GTHST6		;[9156] (P3/) Possibly convert nam to nam.dom

GTHST2:	MOVE T1,P3		;[9156] Reload pointer to that string
	CALL HSTLUK		;[9156] (T1/T2,T4) Try it again
	JUMPN T2,GTHST3		;[9156] It worked, get the information checked
	RETBAD (GTHSX3)		;[9156] Return "Unknown host name" error

GTHST3:	MOVE P1,T2		;[9156] Load host name offset
	SETSEC P1,INTSEC	;[9156] Set the proper section
	LOAD P2,HSTIDX,(P1)	;[9156] Get the host status index
	SETSEC P2,INTSEC	;[9156] In the correct section
	MOVE T2,HSTSTS(P2)	;[9156] Load host status bits
	TXNE T2,HS%INA		;[9156] This info from "d.c.b.a.IN-ADDR.ARPA"?
	RETBAD (GTHSX3)		;[9156] Return "Unknown host name" error
	HLLO T2,HOSTPN(P2)	;[9156] Load the TTL for this host
	CAMGE T2,TODCLK		;[9156] Is this name to address mapping OK?
	RETBAD (GTHSX3)		;[9156] Return "Unknown host name" error
	RETSKP			;[9156] Return with P1 and P2 or T1 set up

;[9156] Local routine called only from GTHST1.  This routine is called to
;change strings of the form "name" to "name.ourdomain".  If the input string
;contains a dot or our preferred host primary name does not contain a dot, no
;action is taken.  If the input string contains a trailing dot it is erased.
;Called with
;	P3/ pointer to beginning of host name string
;Returns +1 always T1-T4,P2/ trash and string pointed to by P3 updated

GTHST6:	MOVE P2,P3		;[9156] Load a poitner to the supplied string
	SETZB T4,T3		;[9156] Clear count of dots and current char
	DO.			;[9156] Loop to look for a dot in name
	  MOVE T2,T3		;[9156] Save previous character examined
	  ILDB T3,P2		;[9156] Load a character from the input string
	  CAIN T3,"."		;[9156] Was it a dot I saw?
	  AOJA T4,TOP.		;[9156] Yes, smells like domain type string
	  JUMPN T3,TOP.		;[9156] Nope, loop if not null
	OD.			;[9156] End of loop to look for a dot

	IFN. T4			;[9156] If it smelled like a domain type string
	  CAIE T2,"."		;[9156]  and the last character was not a dot
	  RET			;[9156] Then return with nothing to do
	  SETO T2,		;[9156] Load number of characters to back up
	  ADJBP T2,P2		;[9156] Point to the trailing dot character
	  DPB T3,T2		;[9156] Erase the trailing dot
	  RET			;[9156]  and return to caller
	ENDIF.			;[9156] So, the string didn't smell like domain

	MOVE T1,PRFADR		;[9156] Load preferred address
	CALL HSTHSH		;[9156] (T1/T1,T2) Get its index
	 RET			;[9156] Not in tables at all, strange
	SKIPN HOSTPN(T2)	;[9156] Do I know my own name?
	RET			;[9156] Not if this word is all zero I don't

	LOAD T2,HSTNDX,(T2)	;[9156] Load the pointer to the name
	SETSEC T2,INTSEC	;[9156] Get offset into HOSTN into address
	LOAD T2,HSTNMP,(T2)	;[9156] Load offset into HSTNAM from there
	ADD T2,[<OWGP. 7>+<INTSEC,,HSTNAM>] ;[9156] Make a byte pointer to name
	DO.			;[9156] Find first dot in our name
	  ILDB T3,T2		;[9156] Load a byte of our name
	  CAIN T3,"."		;[9156] Is it a dot?
	  EXIT.			;[9156] Yes, success is ours now
	  JUMPN T3,TOP.		;[9156] Nope, loop if not end of string
	  RET			;[9156] Couldn't find a dot in our name!
	OD.			;[9156] Now T2/ pointer to domain string

	DPB T3,P2		;[9156] Store dot in output string over null
	DO.			;[9156] Loop to copy the domain part of string
	  ILDB T3,T2		;[9156] Load pointer to rest of our name
	  IDPB T3,P2		;[9156] Store that character in supplied name
	  JUMPN T3,TOP.		;[9156] Loop for all characters in string
	OD.			;[9156] End of loop to copy string

	RET			;[9156] Return to caller with string updated
	SUBTTL GTHST% JSYS -- Common routines -- Move string from user space

; Move string from user space
;Call with
;	user 2/ source designator
;	T3/ pointer to place on stack to store string
;Returns+1 always, with
;	user 2/ updated source designator
;	T1,T2,T4/ trashed
;	T3/ updated pointer

	GTHSBL==^D255/5		;[9156] Number of words for maximum string

GTHSIN:	UMOVE T1,2		; GET POINTER
	MOVE T4,[XCTBU [ILDB T2,T1]]
	TLNN T1,777777		; IF JFN DO THE JSYS
	MOVE T4,[BIN]
	TLC T1,777777		; CHECK FOR LH -1
	TLCN T1,777777
	HRLI T1,(<POINT 7,0>)	; USE STANDARD POINTER
	MOVEI CX,MAXLC		;[9156] Up to 39 characters
GTHSIL:	XCT T4			; DO RIGHT OPERATION
	 ERJMPR R		;[9156] If error, return it in T1
	SOSG CX			;[9156] Is there room for this character?
	MOVEI T2,0		; AFTER MAXLC CHARS FORCE NULL
        CAIG T2,40		; END ON SPACE OR LESS
        MOVEI T2,0		; terminating with null
	IDPB T2,T3		;[9156] Stick it in destination string
	JUMPG T2,GTHSIL		; loop if more to it
	SKIPG CX		;[9156] Was there any more space for string?
	RETBAD (GTHSX9)		;[9156] No, "String argument is too long"
	CAMN T4,[BIN]		;[9156] Don't backup a JFN
	IFSKP.			;[9156] It was a byte pointer, have to back up
	  SETO T2,		;[9156] Load a -1 which is the backup count
	  ADJBP T2,T1		;[9156] Back up the pointer by one
	  MOVEM T2,T1		;[9156] Put the pointer back where we found it
	ENDIF.			;[9156] End of pointer backup code
	UMOVEM T1,2		; restore updated pointer
	RETSKP			;[9156] Skip return
	SUBTTL GTHST% JSYS -- Common routines -- Move string to user space

; Write string to user space
;Call with
;	T1/ Destination designator (in user space if byte pointer)
;	P3/ Byte pointer to string in monitor space
;Returns +1 if error
;	T1/ error code
;Returns +2 if OK
;	T1/ updated pointer to be returned to user space

GTHSOU:	MOVE T4,[XCTBU [IDPB T2,T1]]
	TLNN T1,777777		; IF JFN DO THE JSYS
	MOVE T4,[BOUT]
	TLC T1,777777		; CHECK FOR LH -1
	TLCN T1,777777
	HRLI T1,(<POINT 7,0>)	; USE STANDARD POINTER
GTHSOL:	ILDB T2,P3		; Get next byte
	JUMPE T2,GTHSOX		; If a null
	XCT T4			; DO RIGHT OPERATION
	 ERJMPR R		;[9156] If error, return it in T1
	JRST GTHSOL		; Loop
GTHSOX:	CAMN T4,[BOUT]		; Don't backup a JFN
	RETSKP			;[9156] Return now if a JFN
	XCT T4			; Stick on NULL
	SETO T2,		;[9156] Load a -1 which is the backup count
	ADJBP T2,T1		;[9156] Back up the pointer by one
	MOVEM T2,T1		;[9156] Put the pointer back where we found it
	RETSKP			;[9156]  and return
	SUBTTL GTHST% JSYS -- (0) Name table size

;Function 0 - Get name table size.  No flags in AC1 are checked.
;Called with user's
;	AC1/ .GTHSZ
;Returns +2 always with user's 
;	AC2/ -hostnames,,0
;	AC3/ -NHOSTS,,0
;	AC4/ local host preferred address

GTHSIZ:	HRLZ T2,MHOSTS		;-LENGTH,,1ST INDEX
	UMOVEM T2,2		;RETURN TO USER
	MOVSI T3,-NHOSTS	;NUMBER OF HOST SLOTS
	UMOVEM T3,3		;RETURN TO USER
	MOVE T4,PRFADR		;GET PREFERRED ADDRESS
	UMOVEM T4,4		;RETURN TO USER
	RETSKP			;[9108] Skip return
	SUBTTL GTHST% JSYS -- (1) Return name string associated with host

;Function 1 - Return name string associated with host.  No flags in AC1 are
;checked.
;Call with user's
;	AC1/ .GTHIX
;	AC2/ destination designator
;	AC3/ index into HOSTN
;Returns +1 if error, with user's
;	AC1/ error code
;Returns +2 with user's
;	AC2/ updated destination designator
;	AC3/ host number
;	AC4/ host status

GTHIDX:	MOVN T1,MHOSTS		;GET NUMBER OF HOST NAMES IN USE
	HRRZ P1,T3		;CHECK RANGE OF HOST NAME INDEX
	CAML P1,T1
	RETBAD (GTJIX1)		;[9108] "Invalid index"
	SETSEC P1,INTSEC	;IN THE RIGHT SECTION
	LOAD P2,HSTIDX,(P1)	;GET INDEX INTO HOSTNN
	SETSEC P2,INTSEC	;AND IN THE PROPER SECTION
	JRST GTHTUS		;WRITE THE STRING
	SUBTTL GTHST% JSYS -- (2) Convert number to string

;Function 2 - Convert number to string.  The only flag looked at in AC1 is
;GH%QCL.  The internet class is the only class supported.
;Call with user's
;	AC1/ flags+.GTHNS
;	AC2/ destination designator
;	AC3/ host number
;	AC4/ class if GH%QCL set
;Returns +1 if error with user's
;	AC1/ error code
;Returns +2 with user's
;	AC2/ updated destination designator
;	AC3/ host number
;	AC4/ host status

GTHNUM:	TXNN T1,GH%QCL		;[9156] Is the class bit set?
	IFSKP.			;[9156] It is set
	  CAIE T4,CL.IN		;[9156] Is it internet class?
	  RETBAD(GTHSX6)	;[9156] Return "Invalid class for function"
	ENDIF.			;[9156] End of GTDOM compatibility check
	MOVE T1,T3		;GET HOST NUMBER
	CALL GTHNTS		;(T1/T1,P1,P2) Convert number to string
	 RETBAD (GTHSX2)	;[9156] Return "Unknown host number" error
	CALLRET GTHTUS		;[8975] (P1,P2/) Write to user space and ret
	SUBTTL GTHST% JSYS -- (3) Convert string to number

;Function 3 - Convert string to number.  The only flag looked at in AC1 is
;GH%QCL.  The internet class is the only class supported.
;Call with user's
;	AC1/ flags+.GTHSN
;	AC2/ source designator to host name string
;	AC3/ class if GH%QCL set
;Returns +1 if error, user's
;	AC1/ error code
;Returns +2 with user's
;	AC2/ updated source designator
;	AC3/ host number
;	AC4/ host status

GTHSTR:	TXNN T1,GH%QCL		;[9156] Is the class bit set?
	IFSKP.			;[9156] It is set
	  CAIE T3,CL.IN		;[9156] Is it internet class?
	  RETBAD(GTHSX6)	;[9156] Return "Invalid class for function"
	ENDIF.			;[9156] End of GTDOM compatibility check
	CALL GTHSTN		;[9156] (/T1,P1,P2) Convert string to number
	 RETBAD (GTHSX3)	;[9156] Return "Unknown host name" error 
	CALLRET GTHSXX		;[9156] (P1,P2/) Return status to user

	SUBTTL GTHST% JSYS -- (4) Status by host index

;Function 4 - Status by number.  No flags in AC1 are checked.
;Call with user's
;	AC1/ .GTHHN
;	AC3/ host number
;Returns +1 if error with user's
;	AC1/ error code
;Returns +2 with user's
;	AC3/ host number
;	AC4/ host status

GTHHNN:	MOVE T1,T3		;GET HOST NUMBER
	CALL GTHNTS		;(T1/T1,P1,P2) Convert number to index
	 RETBAD (GTHSX2)	;[9156] Return "Unknown host number" error
	CALLRET GTHSXX		;[9156] (P1,P2/) Return status to user
	SUBTTL GTHST% JSYS -- (5) Status by host address

;Function 5 - Status by index.  No flags in AC1 are checked.
;Call with user's
;	AC1/ .GTHHI
;	AC3/ index into HSTSTS tables
;Returns +1 if error, user's
;	AC1/ error code
;Returns +2 with user's
;	AC3/ host number
;	AC4/ host status

GTHHNI:	HRRZ T1,T3		;GET INDEX
	CAIL T1,NHOSTS		; Compare to table size
	RETBAD (GTJIX1)		;[9108] "Invalid index"
	SETSEC T1,INTSEC	; Put in proper section
	LOAD T1,HSTIDX,(T1)	; get index to tables
	SETSEC T1,INTSEC	; Again in right section
	MOVE T1,HOSTNN(T1)	;[9157] Get 32 bit internet address and skip
	CALL GTHNTS		;(T1/T1,P1,P2) Convert number to index
	 RETBAD (GTHSX2)	;[9156] Return "Unknown host number" error
	CALLRET GTHSXX		;[9156] (P1,P2/) Return status to user
	SUBTTL GTHST% JSYS -- (6) Get hostnumber on a network

;Function 6 -  Get hostnumber on a network.  No flags in AC1 are checked.
;Call with user's
;	AC1/ .GTHLN
;	AC2/ network number, or host number on the net
;Returns +1 if no interface on that network, user's
;	AC1/ error code
;Returns +2 if we have one with user's
;	AC2/ Hostnumber

GTHNHN:	MOVE T1,T2		; Get number
	CALL NETNCT		; Look for an NCT for that net
	 RETBAD (GTHSX5)	;[9108] Return "No interface to that network"
	MOVE T1,NTLADR(P1)	; Get our number there
	UMOVEM T1,T2		; Restore it to user
	RETSKP			;[9108] and do a skip return
	SUBTTL GTHST% JSYS -- (7) Get status of a network

;Function 7 - Get status of a network.  No flags in AC1 are checked.
;Call with user's
;	AC1/ .GTHNT
;	AC2/ Network number or host number on the net
;	AC3/ Pointer to where to store data
;	AC4/ -Number of words,,offset of first
;Returns +1 if no such network or invalid offset, user's
;	AC1/ error code
;Returns +2 if good arguments with data in table

GTHNST:	MOVE T1,T2		; Get number
	CALL NETNCT		; Look it up
	 RETBAD (GTHSX5)	;[9108] Return "No interface to that network"
	HLRE T1,T4		; Get number wanted
	MOVMS T1		; Magnitude
	ADDI T1,(T4)		; Add in first
	CAILE T1,NTXUPP-NTRDY+1	; Size of area
	RETBAD(ARGX04)		;[9156] "Argument block too small" (was GTJIX1)
	XMOVEI P1,NTRDY(P1)	; Point to start of area
	ADDI P1,(T4)		; Add in offset of fist word
	XCTU [HRR T4,T3]	; Setup an AOBJN destination pointer
GTHNS0:	MOVE T1,0(P1)		; get a word
	UMOVEM T1,0(T4)		; Store it
	AOS P1			; Increment source pointer
	AOBJN T4,GTHNS0		; And loop through all desired
	RETSKP			;[9108] Do a skip return at the end

	SUBTTL GTHST% JSYS -- (10) Get local network addresses

;Function 10 - Get Local Network Addresses.  No flags in AC1 are checked.
;Call with user's
;	AC1/ .GTHLA
;	AC3/ Address of where to store data
;	AC4/ Number of words
;Returns +1 if invalid offset, user's
;	AC1/ error code
;Returns +2 if good arguments with data in table and user's
;	AC4/ word count of items returned

GTHNLA:	SKIPG T4		;[9108] Count is positive?
	RETBAD (ARGX24)		;[9108] No, "Invalid count"
	MOVE P1,NCTVT		; Get address of the first NCT
	JRST GTHLA3		; Report on this NCT
GTHLA1:				; Get the next NCT
	LOAD P1,NTLNK,(P1)	; Get address of the next NCT
	JUMPN P1,GTHLA3		; Go report on this NCT
GTHLA2:				; Here when all NCTs examined
	XCTU [SUB T4,4]		; Fix up the count
	XCTU [MOVNM T4,4]	; Save the count for the caller
	RETSKP			;[9108] Success return
GTHLA3:		  		; NCT Chasing loop
	SKIPG T1,NTLADR(P1)	; Get address on this NCT
	JRST GTHLA1		; No address defined.  get next NCT.
	UMOVEM T1,(T3)		; Save interface address for user
	SOJLE T4,GTHLA2		; Count exhausted?
	AOJA T3,GTHLA1 		; No so do the next NCT
	SUBTTL GTHST% JSYS -- (14) Get primary name and IP address

;[9156] Function 14 - Get primary name and IP address.  Like .GTHSN except
;returns canonicalized hostname instead of host status bits.  This function is
;intended primarily for Mark Crispin's excellent MM/MMAILR mail software.
;Call with user's
;	AC1/ flags+.GTHPN
;	AC2/ source designator to host name string
;	AC3/ class if GH%QCL is on in AC1
;	AC4/ destination designator for canonical name string
;Returns +1 if error, user's
;	AC1/ error code
;Returns +2 with
;	AC1/ return code if GH%STS set in call
;	AC2/ updated source designator
;	AC3/ primary host number
;	AC4/ updated destination designator

;Classes other than Internet are not allowed

GTHDPN:	TXNN T1,GH%QCL		;[9156] Check for class bit
	IFSKP.			;[9156] It is set
	  CAIE T3,CL.IN		;[9156] Is it internet class?
	  RETBAD(GTHSX6)	;[9156] Return "Invalid class for function"
	ENDIF.			;[9156] End of GTDOM compatibility check

	CALL GTHSTN		;[9156] (/T1,P1,P2) Convert string to number
	 RETBAD()		;[9156] Return error in T1

	SKIPN HOSTPN(P2)	;[9156] I had better know a name now
	RETBAD(GTHSX7)		;[9156] "Server failed to find data"

	LOAD P1,HSTNDX,(P2)	;[9156] Load the pointer to the name
	SETSEC P1,INTSEC	;[9156] Get offset into HOSTN into address
	LOAD P3,HSTNMP,(P1)	;[9156] Load offset into HSTNAM from there
	ADD P3,[<OWGP. 7>+<INTSEC,,HSTNAM>] ;[9156] Make a byte pointer to name
	UMOVE T1,4		;[9156] Load user's destination pointer
	CALL GTHSOU		;[9156] (T1,P3/T1) Send string to user
	 RETBAD()		;[9156] Return error in T1
	UMOVEM T1,4		;[9156] Update user's pointer

	MOVE T1,HOSTNN(P2)	;[9157] Load host number
	UMOVEM T1,3		;[9156] Return that to the user
	RETSKP			;[9156] Success return
	SUBTTL GTHST% JSYS -- (15) Get MX data

;[9156] Function 15 - Get MX (mail exchange) data.  This function is intended
;primarily for Mark Crispin's MMAILR program.
;Call with user's
;	AC1/ flags+.GTHMX
;	AC2/ source designator
;	AC3/ destination byte pointer 
;	AC4/ pointer to argument block
;	block+.GTHLN/	length of argument block in words including this one
;	block+.GTHMC/	reserved
;	block+.GTHBC/	length of output buffer in bytes pointed to by AC3
;	block+.GTHNM/	0
;Returns +1 if error, user's
;	AC1/ error code
;Returns +2 with user's
;	AC1/ return code if GH%STS set in call
;	AC2/ updated source designator
;	AC3/ updated byte pointer
;	block+.GTHLN/	returned number of words used in this block
;	block+.GTHMC/	0,,class
;	block+.GTHBC/	returned remaining length of output buffer in bytes
;	block+.GTHNM/	returned pointer to first canonicalized name
;	block+.GTHNM+n/ returned pointers to other mail exchanges

GTHDMX:	STKVAR <<GTHSBF,GTHSBL>> ;[9156] Make place to build strings

	MOVSI P2,CL.IN		;[9156] Assume class is internet
	TXNE T1,GH%QCL		;[9156] Check for the class bit
	XCTU [HRLZ P2,.GTHMC(Q2)] ;[9156] Load query class

	MOVEI T3,GTHSBF		;[9156] Point to buffer
	HRLI T3,(<POINT 7,0>)	;[9156]  with a byte pointer
	MOVEM T3,P1		;[9156] Save that pointer
	CALL GTHSIN		;[9156] (T3/T1,T3) Get string from user
	 RETBAD()		;[9156] Return that error to user

	DMOVE T1,P1		;[9156] Load address of user's string and class
	CALL DNSDMX		;[9156] (T1,T2/T1) Do the work for this routine
	 RETBAD()		;[9156] Return error in T1
	RETSKP			;[9156] Success return

	ENDSV.			;[9156] End of STKVAR at GTHDMX

;[9156] This is a local routine that is called by DNSDMX to store data to the
;user from the data acquired from a name server.
;Called with
;	PKT/ address of returned packet
;	Q1/ address of list
;	list/ x number of words to follow this one
;	      x number of byte pointers in RSPBUF to MX names for DNSEXT
;Returns +1 if error, with
;	T1/ error code
;Returns +2 if success, data stored

GTHRMX:	UMOVE Q2,4		;[9156] Load the user's AC4
	UMOVE Q3,.GTHLN(Q2)	;[9156] Load the user's arg block length
	CAIGE Q3,.GTHNM+1	;[9156] Is it large enough?
	RETBAD(ARGX04)		;[9156] Nope, "Argument block too small"
	SUBI Q3,.GTHNM		;[9156] Get the number of MX recs to return
	CAMLE Q3,(Q1)		;[9156] Enough space for all of them?
	MOVE Q3,(Q1)		;[9156] Minimum of what user wanted and we have
	IMUL Q3,[XWD -1,0]	;[9156] Make -number,,0
	HRRI Q3,1(Q1)		;[9156] Now we have -number,,address of ptrs

	MOVE P3,Q2		;[9156] Load address of user's argument block
	ADDI P3,.GTHNM		;[9156] Load address of first word to store

	UMOVE P2,3		;[9156] Load the user's AC3
	TLCN P2,-1		;[9156] Check for JFN instead of pointer
	RETBAD (DESX1)		;[9156] "Invalid source/destination designator"
	TLCN P2,-1		;[9156] Was it -1,,address?
	HRLI P2,(POINT 7)	;[9156] Yes, change to point 7,address

	UMOVE P1,.GTHBC(Q2)	;[9156] Load byte count

;[9156] Now we are ready to store data to user, because we now have
;	Q2/ address of user's argument block
;	Q3/ -count,,addr of list of byte pointers of DNS names to return
;	P1/ count of bytes in string buffer available to return MX records
;	P2/ pointer to user's string buffer to return MX records
;	P3/ address in user's argument block to store pointers into
;	PKT/ address of response packet

	DO.			;[9156] Begin loop to return the MX records
	  MOVE Q1,(Q3)		;[9156] Load pointer to a name
	  CALL DNSEXT		;[9156] (Q1,PKT/Q1,T1,T2,T3) Extract name
	  CAMG P1,T3		;[9156] Enough space for this name with null?
	  EXIT.			;[9156] Nope, return without errors
	  SUB P1,T3		;[9156] Calculate space used 
	  UMOVEM P2,(P3)	;[9156] Store the pointer to this data
	  AOS P3		;[9156] Point to next slot to store data
	  HRLI T2,(POINT 7)	;[9156] Point to the ASCIZ string to copy
	  DO.			;[9156] Loop to copy the string down to user
	    ILDB T1,T2		;[9156] Load a source byte
	    XCTBU [IDPB T1,P2]	;[9156] Store the byte
	     ERJMPR R		;[9156] If error, return it in T1
	    JUMPN T1,TOP.	;[9156] Copy entire string including null
	  OD.			;[9156] That name has been copied now
	  AOBJN Q3,TOP.		;[9156] Loop for all MX RRs
	OD.			;[9156] End of loop to return records

;[9156] We have returned all possible names, update user's pointers and ret OK.

	UMOVEM P2,3		;[9156] Save updated pointer to string buffer
	UMOVEM P1,.GTHBC(Q2)	;[9156] Store updated byte count
	SUB P3,Q2		;[9156] Compute number of words returned
	UMOVEM P3,.GTHLN(Q2)	;[9156] Store number of words used in block
	RETSKP			;[9156] Skip return
	SUBTTL GTHST% JSYS -- (16) Authenticate address

;[9156] Function 16 - Authenticate address.  Checks to see if an address is
;among those associated with the specified name.  This is the right way to
;validate the hostname associated with an open network connection.  The call
;will return +2 if the address matches the hostname.  To see if a particular
;name is a valid name for the local machine, use an "address" of -1 in AC3.
;This function is intended primarily for Mark Crispin's fine mail software.
;Call with user's
;	AC1/ flags+.GTHAA
;	AC2/ source designator
;	AC3/ (numeric) network address
;	AC4/ class (if GH%QCL is on in AC1)
;Returns +1 if error, user's
;	AC1/ error code
;Returns +2 if authenticated, user's
;	AC1/ return code if GH%STS set in call
;	AC2/ updated source designator
;Classes other than Internet are not allowed

GTHDAA:	TXNN T1,GH%QCL		;[9156] Is the class bit set?
	IFSKP.			;[9156] It is set
	  CAIE T4,CL.IN		;[9156] Is it internet class?
	  RETBAD(GTHSX6)	;[9156] Return "Invalid class for function"
	ENDIF.			;[9156] End of GTDOM compatibility check

	CALL GTHSTN		;[9156] (/T1,P1,P2) Try to find that host name
	 RETBAD()		;[9156] Return error in T1

	UMOVE T1,3		;[9156] Load user's address
	CAMN T1,[-1]		;[9156] Is it us?
	MOVE T1,PRFADR		;[9156] Yes, load our address please
	CALL HSTHSH		;[9156] (T1/T1,T2) Try to find that in tables
	IFSKP.			;[9156] That host number not in tables
	  SKIPN HOSTPN(T2)	;[9156] Do I know a name for that number?
	  IFSKP.		;[9156] Yes
	    LOAD T2,HSTNDX,(T2)	;[9156] Load the pointer to the name
	    SETSEC T2,INTSEC	;[9156] Get offset into HOSTN into address
	    CAMN T2,P1		;[9156] Did that address get back to that name?
	    RETSKP		;[9156] Skip return
	  ENDIF.		;[9156] So, the host number didn't have name
	ENDIF.			;[9156]  or the host number wasn't in tables
	MOVE T1,HSTSTS(P2)	;[9156] Load host status bit for resolved name
	TXNN T1,HS%AUT		;[9156] Authoritative answer?
	RETBAD(GTHSX7)		;[9156] "Server failed to find data"
	RETBAD(GTHSX8)		;[9156] "Data not found in namespace"
	SUBTTL GTHST% JSYS -- (20) Validate name

;[9156] Function 20 - Validate name.  Checks to see if a name has RRs matching
;either a particular QTYPE or a list of QTYPEs which represent a particular
;host or zone.  Only GH%QCL and GH%STS flags are checked.  This function is
;intended primarily for Mark Crispin's mail software.
;Call with user's
;	AC1/ flags+.GTHVN
;	AC2/ source designator
;	AC3/ LH: class (if GH%QCL is on in AC1)
;	     RH: type, .GTHVH for host (A,MX,HINFO), or GTHVZ for zone (SOA,NS)
;	AC4/ destination designator for canonical name
;Returns +1 if error with user's
;	AC1/ error code
;Returns +2 if success, with user's
;	AC1/ return code if GH%STS set in call
;	AC2/ updated source designator
;	AC3/ class,,type pair that matched
;	AC4/ updated destination designator

GTHDVN:	STKVAR <<GTHSBF,GTHSBL>> ;[9156] Make place to build strings

	TXNN T1,GH%QCL		;[9156] Was the class supplied?
	HRLI T3,CL.IN		;[9156] No, set class to internet
	MOVEM T3,P2		;[9156] Save type and class argument

	MOVEI T3,GTHSBF		;[9156] Point to buffer
	HRLI T3,(Point 7)	;[9156]  with a byte pointer
	MOVEM T3,P1		;[9156] Save that pointer
	CALL GTHSIN		;[9156] (T3/T1,T3) Get string from user
	 RETBAD()		;[9156] Return that error to user

	DMOVE T1,P1		;[9156] Load arguments for DNSDVN
	CALL DNSDVN		;[9156] (T1,T2/T1) Do the work for routine
	 RETBAD()		;[9156] Return error in T1
	RETSKP			;[9156] Success return

	ENDSV.			;[9156] End of STKVAR at GTHDVN

;[9156] Local routine called from DNSDVN to store data back to user.
;Call with
;	T1/ byte pointer in monitor space to ASCIZ canonical name
;	T2/ class,,type from that record which matched
;Returns +1 if error with
;	T1/ error code
;Returns +2 on success with user's
;	AC3/ class,,type
;	AC4/ updated byte pointer

GTHRVN:	UMOVEM T2,3		;[9156] Save class,,type
	MOVEM T1,P3		;[9156] Save pointer to name
	UMOVE T1,4		;[9156] Load user's output designator
	CALL GTHSOU		;[9156] (T1,P3/T1) Send that name to user
	 RETBAD()		;[9156] Return error to user
	UMOVEM T1,4		;[9156] Return user's output designator
	RETSKP			;[9156] Skip return
	SUBTTL GTHST% JSYS -- (23) Operating System

;[9156] (23) Operating system.  Extracts the operating system name as a string
;from the HINFO RR for a name.  This function is intended primarily for FTP
;programs that want to set defaults based on the foreign host's operating
;system type.
;User calls with 
;	AC1/ flags+.GTHOS
;	AC2/ source pointer to target host name
;	AC3/ destination pointer for opsys name
;	AC4/ class (if GD%QCL is on in AC1)
;Returns +1 with user's
;	AC1/ error code
;Returns +2 with user's
;	AC1/ status code if GH%STS was set on call
;	AC2/ updated source pointer
;	AC3/ updated destination pointer

GTHDOS:	STKVAR <<GTHSBF,GTHSBL>> ;[9156] Make place to build strings

	MOVE P2,[CL.IN,,T.HINFO] ;[9156] Load class and type of RR we desire 
	TXNE T1,GH%QCL		;[9156] Is the class bit set?
	HRL P2,T4		;[9156] Yes, load user's class into safehouse
	
	MOVEI T3,GTHSBF		;[9156] Point to buffer
	HRLI T3,(<POINT 7,0>)	;[9156]  with a byte pointer
	MOVEM T3,P1		;[9156] Save that pointer
	CALL GTHSIN		;[9156] (T3/T1,T3) Get string from user
	 RETBAD()		;[9156] Return that error to user

	DMOVE T1,P1		;[9156] Load address of user's string and class
	CALL DNSDOS		;[9156] (T1,T2/T1) Do the work for this routine
	 RETBAD()		;[9156] Return error in T1
	RETSKP			;[9156] Success return

	ENDSV.			;[9156] End of STKVAR at GTHDOS

;[9156] Local routine called from DNSDOS to store data back to user.
;Call with
;	T1/ byte pointer in monitor space to ASCIZ operating system
;Returns +1 if error with
;	T1/ error code
;Returns +2 if success with user's
;	AC1/ status code if GH%STS was set on call
;	AC2/ updated source pointer
;	AC3/ updated destination pointer

GTHROS:	MOVEM T1,P3		;[9156] Save pointer to name
	UMOVE T1,3		;[9156] Load user's output designator
	CALL GTHSOU		;[9156] (T1,P3/T1) Send that name to user
	 RETBAD()		;[9156] Return error in T1
	UMOVEM T1,3		;[9156] Return user's output designator
	RETSKP			;[9156] Skip return
	SUBTTL GTHST% JSYS -- (24) Get DNS host addresses and timeouts

;[9156] Function 24 - Get DNS Host Addresses and Timeouts
;Call with user's
;	AC1/ .GTHDN
;	AC2/ Index into DNS host table in range 0 to NDNSH-1
;	AC3/ Address of four word block to store data for host
;	AC4/ Number of words to return (1-4)
;Returns +1 if invalid index, user's
;	AC1/ error code
;Returns +2 with user's four word block filled in

GTHDNS:	SKIPL T2		;[9156] Skip if the index
	CAILE T2,NDNSH-1	;[9156]  is within range
	RETBAD (GTJIX1)		;[9156] Return "Invalid index"

	MOVE T1,DNSHST(T2)	;[9156] Load the IP address
	CAILE T4,.GTHDA		;[9156] Return this word?
	UMOVEM T1,.GTHDA(T3)	;[9156] Yes, store that for user enjoyment

	MOVE T1,DNSTMO(T2)	;[9156] Load the timeout in seconds
	CAILE T4,.GTHDT		;[9156] Store the timeout?
	UMOVEM T1,.GTHDT(T3)	;[9156] Yes, he wants it

	MOVE T1,DNSSUC(T2)	;[9156] Load the success count
	CAILE T4,.GTHDS		;[9156] Does he want the success count?
	UMOVEM T1,.GTHDS(T3)	;[9156] Yes, store that back to user

	MOVE T1,DNSFAI(T2)	;[9156] Load the failure count
	CAILE T4,.GTHDF		;[9156] Will we enjoy seeing failures today?
	UMOVEM T1,.GTHDF(T3)	;[9156] Yes, return the failure count

	RETSKP			;[9156] Success return

	SUBTTL Host Table Routines -- Host Table Organization

;The storage in INTSEC after edit [9157] for the host tables
;
;001000	+-----------------------------------------------+
;BF1822:|						|
;	\	BF18SZ*INTBSZ words for 1822 buffers	\
;	|						|
;	+-----------------------------------------------+
;HOSTNN:|						|
;	|	  the 32 bit host address		|
;	|	indexed by the hashed address		|
;	\		NHOSTS words			\
;	|	    locked down by MNTINI		|
;	|						|
;	+-----------------------------------------------+
;HSTSTS:|						|
;	|   status bits (HS%xxx) defined in MONSYM	|
;	|	indexed by the hashed address		|
;	\		NHOSTS words			\
;	|	    locked down by MNTINI		|
;	|						|
;	+-----------------------------------------------+
;HOSTN:	|						|
;	| Each word in this table:			|
;	| <NICNAM>B0  set to 1 if this is a nickname	|
;	| <UNUSED>B1  bit is not used for now		|
;	| <HSTNMP>B17 offset into HSTNAM of name string	|
;	| <HSTIDX>B35 hashed index range 0 to NHOSTS	|
;	|   indexed by the order of names in HSTNAM	|
;	\		NHOSTN words			\
;	|  MHOSTS holds -number of hosts in this table  |
;	|						|
;	+-----------------------------------------------+
;HOSTPN:|						|
;	| Each word in this table:			|
;	| <HSTTTL>B17 lh of TODCLK after which invalid	|
;	| <HSTNDX>B35 index in HOSTN of primary name	|
;	|	 indexed by the hashed address		|	
;	\		NHOSTS words			\
;	|						|
;	+-----------------------------------------------+
;HSTNAM:|						|
;	|      for each host name, ASCIZ \HOST\		|
;	|   each string stored is pointed to by HOSTN	|
;	\		NHSTN words			\
;	|  NAMSPC holds offset of first free word here  |
;	|						|
;	+-----------------------------------------------+
;INTFRE:|						|
;	|     Internet free space managed by IPFREE     |
;	|						|
;777777	+-----------------------------------------------+
	SUBTTL Host Table Routines -- Host Table Storage

;[9156] These three locations are used to keep the time of the last BUGCHK that
;was output indicating one of the host tables was full.  These times are kept
;so that the messages do not come out more than ever BUGFUL minutes.

NDG BUGFUL,5			;[9156] Default is every five minutes

NR NUMFT                        ;[9156] Time of last NUMFUL (HOSTN full)
NR NAMFT                        ;[9156] Time of last NAMFUL (HSTNAM full)
NR STSFT                        ;[9156] Time of last STSFUL (HSTSTS full)

;[9108] Define the lock word, done here because only used here.

RSI GTHLCK,<-1>			;[9108] Host table lock word
	SUBTTL Host Table Routines -- Host Table Lock Routines

;[9108] LCKGTH, routine to lock host table.
;Returns +1 always, table locked, NOINT

LCKGTH:	NOINT			;[9108] Don't allow ^C out
	LOCK GTHLCK		;[9108] Lock it, blocking if not locked 
	RET			;[9108] Return +1 always

;[9108] ULKGTH, routine to unlock host table.
;Returns +1 always, table unlocked and OKINT

ULKGTH:	UNLOCK GTHLCK		;[9108] Unlock the host table
	OKINT			;[9108] Reallow interrupts
	RET			;[9108] Return +1 always
	SUBTTL Host Table Routines -- Find Host Table Entries

;Given a host number in T1 finds entry for that number in host tables.
;Call: T1/ host number
;Returns+1 if not found, T2/ where a new host index would go, -1 if full
;Returns+2 found, T2/ is table index

HSTHSH::
	MOVE T2,T1		;DO A HASH
	IDIVI T2,NHOSTS		;GET INITIAL GUESS, DIV BY PRIME
	EXCH T2,T3		;2/ FIRST GUESS
	IDIVI T3,NHOSTS		;DIV BY PRIME AGAIN
	CAIN T4,0		;GET INCREMENT
         MOVEI T4,1
	MOVEI T3,NHOSTS		;COUNTER FOR GUESSES
	SETSEC T2,INTSEC	;LOOK IN THE RIGHT SECTION
HSTHLP:	SKIPG HOSTNN(T2)	;[9157] No host there?
	RET			;NO, 2/ WHERE TO PUT IT
	CAMN T1,HOSTNN(T2)	;[9157] Did this address match the desired one?
	RETSKP			;[9157] Yes, skip return
	ADDI T2,(T4)		;STEP BY INCREMENT
	CAML T2,[XWD INTSEC,NHOSTS] ;CHECK FOR OVERFLOW
	SUBI T2,NHOSTS		;WRAP AROUND IF NEEDED
	SOJG T3,HSTHLP		;COUNT DOWN GUESSES
	SETO T2,		;-1 TABLE FULL
	RET			;RETURN ERROR

	SUBTTL Host Table Routines -- Lookup Host Names

;HSTLUK - Lookup host names
;Call with T1/ pointer to string of name or number in monitor space
;Returns+1 always with
;	T1/ updated pointer to host string
;	T2/ host name index or 0 if host not found (or host number given)
;	T3/ host status bits if host was found
;	T4/ IP address if host if host name found (or host number given)

HSTLUK:	SAVEP			;[9156] Save P1-P4
	MOVE P3,T1		;Save pointer to host name

repeat 0,<			;[9156] Following code is a slow noop
	MOVEI T3,10		;Load radix for NIN
	NIN			;Try to get a number
	 JRST HSTLKI		;Not there try a name
	MOVE P3,T1		;Save updated pointer to string
	MOVE T1,T2		;Load host number
	CALL CVNHST		;(T1/T1) Convert host number to new format
	MOVE T4,T1		;Return host number in T4
	MOVE T1,P3		;And updated pointer in T1
	SETZ T2,		;Indicate that the host number was found
	RET			;Return to caller
>				;[9156] End of repeat 0 on slow noop code

HSTLKI:	HRLZ P2,MHOSTS		;[9156] Scan the table
	PUTSEC P1,INTSEC	;[9156] In correct section today if you please

;[9156] Loop to check each host in the host table and see if it matches.

HSTLK0:	MOVE T1,P3		;[9156] Point to source string for comparison
	LOAD T2,HSTNMP,(P1)	;[9156] Load a name pointer offset to the data
	ADD T2,[<OWGP. 7>+<INTSEC,,HSTNAM>] ;[9156] Make a byte pointer to name
	CALL SMATCH		;[9156] (T1,T2/T1,T2,T3,T4) Strings match?
	 AOJA P1,HSTLK2		;[9156] No match, keep looking

;[9156] Current entry matched, if it is a host name return+2 with T2 and T4.

	LOAD T4,HSTIDX,(P1)	;[9156] We have a match, get the index
	SETSEC T4,INTSEC	;[9156] In the correct section
	MOVE T3,HSTSTS(T4)	;[9157] Get entry status bits
	TXNN T3,HS%SRV		;[9156] Host name?
	AOJA P1,HSTLK2		;[9156] No, a gateway or net, skip over it
	MOVE T4,HOSTNN(T4)	;[9157] Get the host number
	MOVE T2,P1		;[9156] Get the name string address
	RET			;[9156]  and return to caller

;[9156] Entry did not match, we need to check the next one.

HSTLK2:	AOBJN P2,HSTLK0		;[9156] Step to next host
	SETZB T4,T2		;[9156] No host found
	RET			;Return
	SUBTTL Host Table Routines -- String match routine

;[9156] Routine to see if two strings match, ignoring case differences.
;Call with
;	T1/ pointer to a string
;	T2/ pointer to a string
;Returns +1 if strings didn't match, 
;	T1/ updated pointer to first string
;	T2/ updated pointer to second string
;	T3/ character from first string that didn't match
;	T4/ character from second string that didn't match
;Returns +2 if strings matched, 
;	T1/ pointer to end of first string
;	T2/ pointer to end of second string
;	T3/ 0
;	T4/ 0

SMATCH:	ILDB T3,T1		;[9156] Get a character from first string
	CAIL T3,"A"+40		;[9156] Is this character lower case?
	SUBI T3,40		;[9156] Yes, change it to upper case

	ILDB T4,T2		;[9156] Get a character from second string
	CAIL T4,"A"+40		;[9156] Is this character lower case?
	SUBI T4,40		;[9156] Yes, change it to upper case

	CAME T4,T3		;[9156] Is there a match between these two?
	RET			;[9156] Nope, no match, return +1
	JUMPN T4,SMATCH		;[9156] Matched so far, loop if not null

	RETSKP			;[9156] End of string reached, return +2

	SUBTTL Host Table Routines -- Operating System match routine

;[9156] This routine is called to lookup a operating system type for the host
;tables.  The following code accomplishes much the same work as a TBLUK but it
;is considerably faster to help speed up reading the host file.  An exact match
;or a subset match is considered success, to enable HINFO records with a
;operating system string like "UNIX 4.2" to match "UNIX".
;Call with
;	T1/ pointer to string to check
;Returns +1 always with T1, T2, T4 smashed and
;	T3/ HS%SRV plus .HSxxx if the string matched an operating system type

OMATCH:	SAVEQ			;[9156] Get Q1-Q3 to work with
	MOVEM T1,Q1		;[9156] Save pointer to input string
	MOVSI Q2,-NUMOPS	;[9156] Load AOB pointer to OPSTAB
	DO.			;[9156] Loop to find operating system type
	  MOVE T1,Q1		;[9156] Load pointer to suspect string
	  HLRZ T2,OPSTAB(Q2)	;[9156] Load address of that string
	  HRLI T2,(Point 7)	;[9156] Make a pointer to that string
	  CALL SMATCH		;[9156] (T1,T2/T1,T2,T3,T4) Strings match?
	   SKIPN T4		;[9156] No match, was it a subset string match?
	  EXIT.			;[9156] Exact match or close enough, get out
	  AOBJN Q2,TOP.		;[9156] Try next entry in table
	  MOVX T3,HS%SRV	;[9156] No match, return just the host bit
	  RET			;[9156] Returning T3
	OD.			;[9156] Get out of loop when string match
	HRRZ T3,OPSTAB(Q2)	;[9156] Load the matching op sys type
	TXO T3,HS%SRV		;[9156] Fold in op sys type with server bit
	RET			;[9156] Return T3


;[9156] This is the table for operating system names

OPSTAB:	XWD [ASCIZ/ANTS/],.HSANT
	XWD [ASCIZ/ELF/],.HSELF
	XWD [ASCIZ/FOONEX/],.HS10X
	XWD [ASCIZ/FUZZ/],.HSFUZ
	XWD [ASCIZ/ITS/],.HSITS
	XWD [ASCIZ/MSDOS/],.HSDOS
	XWD [ASCIZ/MTIP/],.HSMTP
	XWD [ASCIZ/MULTICS/],.HSMLT
	XWD [ASCIZ/TAC/],.HSTAC
	XWD [ASCIZ/TENEX/],.HS10X
	XWD [ASCIZ/TIP/],.HSTIP
	XWD [ASCIZ/TOPS10/],.HSDEC
	XWD [ASCIZ/TOPS20/],.HST20
	XWD [ASCIZ/TOPS20AN/],.HST20
	XWD [ASCIZ/TOPS-20/],.HST20 ;[9156]
	XWD [ASCIZ/TOPS-10/],.HSDEC ;[9156]
	XWD [ASCIZ/ULTRIX/],.HSUNX ;[8975]
	XWD [ASCIZ/UNIX/],.HSUNX
	XWD [ASCIZ/VMS/],.HSVMS
	XWD [ASCIZ/WAITS/],.HSDEC
NUMOPS=.-OPSTAB-1
	SUBTTL Host Table Routines -- Convert host number to new format

;CVNHST - Routine to convert host number in T1 to host and network number in T1
;Call with T1/ host number
;Returns +1 always T1/ new format host number with network number applied

CVNHST::CAMN T1,[-1]		;If -1 use local host number
	MOVE T1,PRFADR		;Default local host
	AND T1,[HSTMSK]		;Cut down to size
	TLNE T1,37700		;Any network number stuff?
	RET			;Yes, so return
	ANDI T1,377		;Turn off all other bits
	TRZE T1,100		;Set the host bits
	TRO T1,200000		;Units host bit
	TRZE T1,200		;Twos host bit?
	TRO T1,400000		;Set twos host bit
	JUMPE T1,R		;If zero leave it zero
	IOR T1,NETFLD		;Add default network number
	RET			;Return T1/ address
	SUBTTL Host Table Routines -- Compute masks for IP addresses

;[9156] This routine accepts a 32 bit internet address in T1 and returns the 32
;bit network number and 32 bit network mask based on the network class (A, B,
;or C).  For example if called with address 16.34.0.2, it would return a
;network number of 16.0.0.0 and a network mask of 255.0.0.0.
;
;Call with
;	T1/ IP address
;Returns +1 always with
;	T1/ IP address
;	T2/ IP network number
;	T3/ IP network mask

NETMSK:	MOVE T2,T1		;[9156] Copy the address over for ANDing
	TXNE T1,.NETCA		;[9156] Is this a Class A network?
	IFSKP.			;[9156] Yes, it is a Class A network, lucky us
	  ANDX T2,NETCA		;[9156] Load just the network number in T2
	  MOVX T3,NETCA		;[9156] Load just the network mask in T3
	  RET			;[9156] Return
	ENDIF.			;[9156] So, it isn't a Class A network
	TXNE T1,.NETCB		;[9156] Is this a Class B network?
	IFSKP.			;[9156] Yes, it is a Class A network, lucky us
	  ANDX T2,NETCB		;[9156] Load just the network number in T2
	  MOVX T3,NETCB		;[9156] Load just the network mask in T3
	  RET			;[9156] Return
	ENDIF.			;[9156] So, it must be a class C network
	ANDX T2,NETCC		;[9156] Load the network number in T2
	MOVX T3,NETCC		;[9156] Load the network mask in T3
	RET			;[9156]  and return to caller
	SUBTTL Host Table Routines -- Add Host to Tables

;[9156] This routine adds a host to the host tables.  The host's names must
;have been already read into the freespace known as HSTNAM.  The addresses of
;these strings are usually kept somewhere on that stack and called NAMLST.  The
;first host string is the primary host name.  The host's IP addresses have been
;stored in another list, which is usually kept somewhere on that stack and is
;called NUMLST.
;
;We will add the hosts to the tables, picking the best IP address as the one to
;communicate with that host.  We will always prefer the PRFADR address in the
;event this is our local host.  Failing that, we prefer an address that is on
;PRFADR's network, which is presumably the best network to reach that host.
;The host status index for that host is stored in HBEST.  Failing that, we
;prefer any network we are directly connected to, so we can avoid gateways.
;This host status index is stored in HGOOD.  If all else fails, we'll take the
;first listed address.  This host status index is stored in HFIRST.
;
;Call with
;	T1/ address of NAMLST
;	T2/ address of NUMLST
;	T3/ host status bits (HS%xxx)
;	T4/ TTL in TODCLK format (only left halfword stored in HOSTPN)
;	NAMLST/ x number of words to follow this one
;		+index into NAMLST to create a new HOSTN entry 
;			or
;		-index into HOSTN table to reuse a HOSTN entry
;		the first index is for the primary host name
;	NUMLST/	y number of words to follow this one
;		y internet addresses 
;
;Returns +1 if table is full in some way, some information may have made it
;Returns +2 if all information added to tables,
;	T1/ host status index

ADDHOS:	SAVEP			;[9156] Save the Ps
	STKVAR <HFIRST,HBEST,HGOOD,HSTS,HNAML>	;[9156] Space on the stack too

	MOVEM T1,HNAML		;[9156] Store the NAMLST address
	MOVEM T2,P2		;[9156] Store the NUMLST address
	MOVEM T3,HSTS		;[9156]  and store the host status word
	MOVEM T4,P3		;[9156] Save the TTL into P3

;[9156] Insure that there are one or more names and one or more numbers.

	SKIPLE T3,(T1)		;[9156] If name count is neagtive or zero 
	CAILE T3,NAMNUM		;[9156]  or is greater than reasonable addition
	RET			;[9156]   then the host name count smells bad

	SKIPLE T3,(T2)		;[9156] If number count is neagtive or zero 
	CAILE T3,NAMNUM		;[9156]  or is greater than reasonable number
	RET			;[9156]   then reject this addition

;[9156] The initial loop fills in the HOSTPN table with the TTL and HOSTN
;index of the primary host name.  This value is built here for storage later.

	MOVM T3,MHOSTS		;[9156] Get first free in HOSTN, assuming new
	HRR P3,T3		;[9156] Make the TTL,,index of first free HOSTN
	SKIPL 1(T1)		;[9156] Is the primary name a HOSTN offset?
	IFSKP.			;[9156] Yes, we are reusing an old HOSTN entry
	  MOVM T2,1(T1)		;[9156] Load the +HOSTN offset of primary host
	  HRR P3,T2		;[9156] Set HOSTN offset of primary host name
	  SOS T3		;[9156] Don't count reused entry in space check
	ENDIF.			;[9156] Now P3/ HOSTPN word for all addresses

;[9156] Make sure enough room is available for the hosts in HOSTN to be added
;before we start trying to add them.

	ADD T3,(T1)		;[9156] Add the number of host names to add
	CAILE T3,NHOSTN		;[9156] Is there room for that many hosts?
	JRST ADDHOX		;[9156] Nope, HOSTN is full then

;[9156] The only other table to worry about is the tables of NHOSTN words,
;detected when HSTHSH fails to hash a new address.  Since nothing is ever
;deleted from the host tables, the only way out of a full host table situation
;is to reload the HOSTS.TXT.  The host table will continue to work properly
;when full, but performance may suffer because of the hashing algorithm.  With
;a short HOSTS.TXT and use of the DNS software filling the host tables it seems
;unlikely when NHOSTN is set to a 4 digit prime number.  If the host tables
;ever do fill up, a BUGCHK will be output so that this can be taken care of.


;[9156] This is the loop that fills in HOSTNN and HSTSTS for each host number,
;as well as filling in HBEST, HGOOD, and HFIRST.
;	T1/ internet address for entry in NUMLST
;	T2/ hashed host index
;	P2/ AOBJN pointer to NUMLST
;	P3/ TTL,,offset of primary host in HOSTN (to store in HOSTPN)

	SETZM HBEST		;[9156] Initially no best index
	SETZM HGOOD		;[9156]  nor a good index
	SETZM HFIRST		;[9156]   nor a first one either
	MOVN T1,(P2)		;[9156] Load the negative number of hosts
	HRL P2,T1		;[9156] Make -number,,address of first one

ADDHO1:	MOVE T1,1(P2)		;[9156] Load that internet address please
	CALL HSTHSH		;[9156] (T1/T1,T2) Hash it into the tables
	 JFCL			;[9156] Ignore that it may not be found
	JUMPL T2,ADDHOY		;[9156] Return now if status tables full
	MOVEM T1,HOSTNN(T2)	;[9157] Save 32 bit internet address in table
	HRRZ T3,HOSTPN(T2)	;[9156] Reusing old HOSTPN entry?
	IFN. T3			;[9156] If so, make the old entry a nickname
	  SETSEC T3,INTSEC	;[9156] Proper section for the data tonight
	  MOVX T4,HSTNIC	;[9156] Load nickname flag
	  IORM T4,HOSTN(T3)	;[9156] Set nickname flag for older entry
	ENDIF.			;[9156] End of old HOSTPN entry fixup code
	MOVEM P3,HOSTPN(T2)	;[9156] Save pointer to name in HOSTPN table
	CALL LCLHST		;[9156] (T1/) Is this host number one of ours?
	 TDZA T3,T3		;[9156] This address is not one of ours, skip
	MOVX T3,HS%UP!HS%SLF!HS%VAL!.HST20 ;[9156] It is me, I'm up, valid 
	IOR T3,HSTS		;[9156] Load the op sys type and flags
	MOVEM T3,HSTSTS(T2)	;[9157] Store operating system type
	SKIPN HFIRST		;[9156] Do we have a first guess yet?
	MOVEM T2,HFIRST		;[9156] Save first one, last guess
	CAMN T1,PRFADR		;[9177] Our preferred adr is always our best
	JRST ADDHO2		;[9156] Set it as the best address possible
	SKIPE HBEST		;[9156] Have a best address yet?
	JRST ADDHO4		;[9156] Yup, loop through number list
	MOVE T3,T1		;[9156] Copy address to T2
	AND T3,PRFMSK		;[9156] No, get network bytes only
	CAME T3,PRFNFD		;[9156] Is this address on preferred network?
	JRST ADDHO3		;[9156] Nope, have to look a little bit
ADDHO2:	MOVEM T2,HBEST		;[9156] Yes, consider it best
	JRST ADDHO4		;[9156] Loop through number list
ADDHO3:	SKIPE HGOOD		;[9156] Not on default net, good address yet?
	JRST ADDHO4		;[9156] Loop through number list
	CALL NETNCT		;[9156] (T1/P1,T1) Have an int on that net?
	 JRST ADDHO4		;[9156] Loop through number list
	MOVEM T2,HGOOD		;[9156] Yes, consider it a good address
ADDHO4:	AOBJN P2,ADDHO1		;[9156] Loop for entire list of numbers adding


;[9156] Here when the entire table of addresses we read in have been looked at.
;If we got a best address (on preferred net with us) use that, otherwise use a
;good address if we are on that net, otherwise use the first address specified.

ADDHO5:	SKIPE T1,HBEST		;[9156] Get best number index
	JRST ADDHO6		;[9156] Got one, use it
	SKIPN T1,HGOOD		;[9156] No best index, get a good index
	MOVE T1,HFIRST		;[9156] No good index, use first index

;[9156] Store the address we want to use for each name specified that should be
;added to the HOSTN table.  Because we checked when this routine called, there
;should be room for all of the host name indexes to be added.

ADDHO6:	MOVE P2,HNAML		;[9156] Load address of NAMLST
	MOVN T4,(P2)		;[9156] Load -ive number of host names to add
	HRL P2,T4		;[9156] Make -n,,address-1 
	MOVEM P2,T2		;[9156] Store that for later
	MOVX T4,HSTNIC		;[9156] Load nickname flag for later

;[9156] Fill in HOSTN from NAMLST, with
;	P2/ AOBJN poiner to NAMLST
;	P3/ Index in HOSTN 
;	T1/ "best" host status index
;	T2/ Copy of P2 at start of loop
;	T4/ HSTNIC flag

ADDHO7:	MOVM P3,MHOSTS		;[9156] Load +ive number of hosts
	SETSEC P3,INTSEC	;[9156] Point to the correct section
	SKIPGE T3,1(P2)		;[9156] Load a host name index pointer
	IFSKP.			;[9156] If it was a new host name pointer
	  STOR T3,HSTNMP,(P3)	;[9156] Set name pointer in new HOSTN location
	  STOR T1,HSTIDX,(P3)	;[9156] Save number index of best ip address 
	  SOS MHOSTS		;[9156] Count this host in -ive count of them
	ELSE.			;[9156] Otherwise it was an old index
	  MOVM P3,1(P2)		;[9156] Load the HOSTN index
	  SETSEC P3,INTSEC	;[9156] Point to the HOSTN entry
	ENDIF.			;[9156] Now HOSTN set up except HSTNIC flag
	ANDCAM T4,HOSTN(P3)	;[9156] Assume this is not a nickname
	CAME P2,T2		;[9156] Is this the primary name?
	IORM T4,HOSTN(P3)	;[9156] Nope, so set nickname flag
	AOBJN P2,ADDHO7		;[9156] Loop for all of the hosts

	RETSKP			;[9156] Skip return, T1/ host status index

;[9156] Here if it appears that the HOSTN table would be full with this entry.

ADDHOX: SKIPE T1,NUMFT		;[9156] Save now, get last time bug output
	ADDI T1,[BUGFUL*^D60*^D1000] ;[9156] Get time before another one due
	CAMLE T1,TODCLK		;[9156] Is it time for another announcement?
	RET			;[9156] Nope, just return
	MOVE T1,TODCLK		;[9156] Reload now
	MOVEM T1,NUMFT		;[9156] Store it for later checking
	BUG.(CHK,NUMFUL,MNETDV,SOFT,<Internet host index table full>,,<

Cause:	The monitor wanted to add a host to the internet host table but it
	could not because the HOSTN table is full.  This could happen when the
	file SYSTEM:HOSTS.TXT is loaded, or by the monitor resolving too many
	hosts from the DNS nameservers identified in the file
	SYSTEM:INTERNET.NAMESERVERS.  This BUGCHK only appears only once in any
	5 minutes to prevent too many of them flooding the CTY.

Action:	Rebuild the monitor with a higher value for NHOSTN.  NHOSTN is set to
	twice the size of NHOSTS, so increasing NHOSTS will result in larger
	tables.  If the host name table has been filled by a large number of
	hosts added by the DNS resolver in the monitor, the host table can be
	reloaded with just HOSTS.TXT information by using the IPHOST program's
	LOAD command.
>)				;[9156] Tell the system manager types
	RET			;[9156] Return +1

;[9156] Here if it appears that the HOSTNN/HSTSTS/HOSTPN tables are full.

ADDHOY: SKIPE T1,STSFT		;[9156] Save now, get last time bug output
	ADDI T1,[BUGFUL*^D60*^D1000] ;[9156] Get time before another one due
	CAMLE T1,TODCLK		;[9156] Is it time for another announcement?
	RET			;[9156] Nope, just return
	MOVE T1,TODCLK		;[9156] Reload now
	MOVEM T1,STSFT		;[9156] Store it for later checking
	BUG.(CHK,STSFUL,MNETDV,SOFT,<Internet host status tables full>,,<

Cause:	The monitor wanted to add a host to the internet host table but it
	could not because the host status tables are full.  This could happen
	when the file SYSTEM:HOSTS.TXT is loaded, or by the monitor resolving
	too many hosts from the DNS nameservers identified in the file
	SYSTEM:INTERNET.NAMESERVERS.  This BUGCHK only appears only once in any
	5 minutes to prevent too many of them from flooding the CTY.

Action:	Rebuild the monitor with a higher value for NHOSTS.  Other internet
	host tables in the monitor are related to the value of NHOSTS, so
	increasing NHOSTS will result in several larger tables.  If the host
	name table has been filled by a large number of hosts added by the DNS
	resolver in the monitor, the host table can be reloaded with just
	HOSTS.TXT information by using the IPHOST program's LOAD command.
>)				;[9156] Tell the system manager types
	RET			;[9156] Return +1
	SUBTTL Host Table Routines -- Add Host Name to HSTNAM

;[9156] Routine to copy a host name from the stack into the host name table.
;Call with
;	T1/ size of name in words
;	T2/ section,,address of the name
;Returns +1 if can't move host string because there is no space
;Returns +2 if the host string was moved with
;	T3/ offset in HSTNAM of the planted string

ADDNAM:	ADD T1,NAMSPC		;[9156] Compute the new value of NAMSPC
	CAILE T1,NHSTN		;[9156] Is there room for this host?
	JRST ADDNAX		;[9156] Nope, HSTNAM is full
	SUB T1,NAMSPC		;[9156] Recover the number of words to move
	MOVE T4,NAMSPC		;[9156] Copy index for returning to user
	ADDM T1,NAMSPC		;[9156] Update free space pointer
	MOVE T3,T4		;[9156] Load index of free position
	ADD T3,[INTSEC,,HSTNAM]	;[9156] Get the destination address figured
	CALL XBLTA		;[9156] (T1,T2,T3/) Move the name
	MOVE T3,T4		;[9156] Grab the index where we copied to
	RETSKP			;[9156]  and return +2

;[9156] Here if HSTNAM is full.

ADDNAX:	SKIPE T1,NAMFT		;[9156] Save now, get last time bug output
	ADDI T1,[BUGFUL*^D60*^D1000] ;[9156] Get time before another one due
	CAMLE T1,TODCLK		;[9156] Is it time for another announcement?
	RET			;[9156] Nope, just return
	MOVE T1,TODCLK		;[9156] Reload now
	MOVEM T1,NAMFT		;[9156] Store it for later checking
	BUG.(CHK,NAMFUL,MNETDV,SOFT,<Internet host name table full>,,<

Cause:	The monitor wanted to add a host to the internet host table but it
	could not because the HSTNAM table is full.  This could happen when the
	file SYSTEM:HOSTS.TXT is loaded, or by the monitor resolving too many
	hosts from the DNS nameservers identified in the file
	SYSTEM:INTERNET.NAMESERVERS.  This BUGCHK only appears only once in any
	5 minutes to prevent too many of them flooding the CTY.

Action:	Rebuild the monitor with a higher value for NHSTN. NHSTN is set to six
	times the size of NHOSTS, so increasing NHOSTS will result in larger
	tables.  If the host name table has been filled by a large number of
	hosts added by the DNS resolver in the monitor, the host table can be
	reloaded with just HOSTS.TXT information by using the IPHOST program's
	LOAD command.
>)				;[9156] Tell the system manager types
	RET			;[9156] Return +1

	SUBTTL DNS Resolver

;[9156] The DNS Resolver is called when the GTHST JSYS cannot find a Name to IP
;address or IP address to name translation.

;The DNS Resolver is activated by a file SYSTEM:INTERNET.NAMESERVERS which
;contains the IP addresses of each name server, optionally followed by a
;keyword "TIMEOUT:" and a number of seconds to wait before timing out the
;server.  The entries appear one per line, followed by an optional semicolon
;and comment.

;So, an example file contents might be
;	16.34.0.9,TIMEOUT:10		;bldg19.tops20.dec.com timeout 10 sec
;	16.1.0.1,TIMEOUT:50		;decwrl.dec.com with timeout 50 sec

;The code in this section was oritionally developed for a prototype program
;called NSLOOK.  NSLOOK supports the Inverse Query opcode which is not used in
;the monitor.  Therefore the code the supports Inverse Query is under the
;FTIQUE conditional assembly switch which should be kept 0 in the monitor.

	IFNDEF FTIQUE,FTIQUE==0	;[9156] Kept off in the monitor

	SUBTTL DNS Resolver -- Definitions -- DNS Protocol 

;[9156] Overall message format

;	All messages sent by the domain system are divided into 5 sections
;	(some of which are empty in certain cases) shown below:
;
;	+---------------------+                                   
;	|        Header       |                                   
;	+---------------------+                                   
;	|       Question      | the question for the name server  
;	+---------------------+                                   
;	|        Answer       | answering resource records (RRs)  
;	+---------------------+                                   
;	|      Authority      | RRs pointing toward an authority  
;	+---------------------+                                   
;	|      Additional     | RRs holding pertinent information 
;	+---------------------+                                   
;
;	The header section is always present.  The header includes fields
;	that specify which of the remaining sections are present, and also
;	specify whether the message is a query, inverse query, completion
;	query, or response.
;
;	The question section contains fields that describe a question to a
;	name server.  These fields are a query type (QTYPE), a query class
;	(QCLASS), and a query domain name (QNAME).
;	
;	The last three sections have the same format: a possibly empty
;	list of concatenated resource records (RRs).  The answer section
;	contains RRs that answer the question; the authority section
;	contains RRs that point toward an authoritative name server; the
;	additional records section contains RRs which relate to the query,
;	but are not strictly answers for the question.
	SUBTTL DNS Resolver -- Definitions -- DNS Header

;[9156] The header contains the following fields:
;
;                                           1  1  1  1  1  1 
;             0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5 
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |                      ID                       |
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |QR|   Opcode  |AA|TC|RD|RA|        |   RCODE   |
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |                    QDCOUNT                    |
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |                    ANCOUNT                    |
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |                    NSCOUNT                    |
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |                    ARCOUNT                    |
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

;   Header section format

DEFSTR(HDID,PKTELI+.UDPDA+0,15,16) ;Identification
DEFSTR(HDQR,PKTELI+.UDPDA+0,16,1) ;Response if 1
DEFSTR(HDOC,PKTELI+.UDPDA+0,20,4) ;Opcode
	    OC..QU==0		;A standard query (QUERY)
	    OC..IQ==1		;An inverse query (IQUERY)
	    OC..CM==2		;An completion query allowing multiple 
				;answers (CQUERYM)
	    OC..CU==3		;An completion query requesting a single
				;answer (CQUERYU)
DEFSTR(HDAA,PKTELI+.UDPDA+0,21,1) ;Authoritative answer
DEFSTR(HDTC,PKTELI+.UDPDA+0,22,1) ;Truncation
DEFSTR(HDRD,PKTELI+.UDPDA+0,23,1) ;Recursion Desired
DEFSTR(HDRA,PKTELI+.UDPDA+0,24,1) ;Recursion available
DEFSTR(HDRC,PKTELI+.UDPDA+0,31,4) ;Response code
DEFSTR(HDQDC,PKTELI+.UDPDA+1,15,16) ;Number of entries in question section
DEFSTR(HDANC,PKTELI+.UDPDA+1,31,16) ;Number of entries in answer section
DEFSTR(HDNSC,PKTELI+.UDPDA+2,15,16) ;Number of entries in authority sec
DEFSTR(HDARC,PKTELI+.UDPDA+2,31,16) ;Number of entries in addl rec sect

.HDBEG==PKTELI+.UDPDA+0		;Start of name server protocol header area
.HDQUE==PKTELI+.UDPDA+3		;Start of question area
	SUBTTL DNS Resolver --  Definitions -- DNS Question Section

;[9156] Question section format
;
;      The question section is used in all kinds of queries other than
;      inverse queries.  In responses to inverse queries, this section
;      may contain multiple entries; for all other responses it contains
;      a single entry.  Each entry has the following format:
;
;                                           1  1  1  1  1  1 
;             0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5 
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |                                               |
;           /                     QNAME                     /
;           /                                               /
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |                     QTYPE                     |
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |                     QCLASS                    |
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
	SUBTTL DNS Resolver --  Definitions -- DNS Resource Record

;[9156] Resource record format
;
;      The answer, authority, and additional sections all share the same
;      format: a variable number of resource records, where the number of
;      records is specified in the corresponding count field in the
;      header.  Each resource record has the following format:
;
;                                           1  1  1  1  1  1 
;             0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5 
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |                                               |
;           /                                               /
;           /                      NAME                     /
;           |                                               |
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |                      TYPE                     |
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |                     CLASS                     |
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |                      TTL                      |
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;           |                   RDLENGTH                    |
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
;           /                     RDATA                     /
;           /                                               /
;           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+


	SUBTTL DNS Resolver -- Definitions -- DNS Field Values

;[9156] TYPE values
;
;	TYPE fields are used in resource records.  Note that these types
;	are not the same as the QTYPE fields used in queries, although the
;	functions are often similar.

	T.A==^D1		;A host address
	T.NS==^D2		;An authoritative name server
	T.MD==^D3		;A mail destination
	T.MF==^D4		;A mail forwarder
	T.CNAME==^D5		;The canonical name for an alias
	T.SOA==^D6		;Marks the start of a zone of authority
	T.MB==^D7		;A mailbox domain name
	T.MG==^D8		;A mail group member
	T.MR==^D9		;A mail rename domain name
	T.NULL==^D10		;A null RR
	T.WKS==^D11		;A well known service description
	T.PTR==^D12		;A domain name pointer
	T.HINFO==^D13		;Host information
	T.MINFO==^D14		;Mailbox or mail list information
	T.MX==^D15		;Mail exchange
	T.TXT==^D16		;Text strings

;[9156] QTYPE values
;
;	QTYPE fields appear in the question part of a query.  They include
;	the values of TYPE with the following additions:

;	QT.AXFR==^D252		;A request for a transfer of an entire zone
;	QT.MB==^D253		;A request for mailbox-related (MB, MG or MR)
;	QT.MA==^D254		;A request for mail agent RRs (MD and MF)
      	QT.ALL==^D255		;A request for all records

;[9156] CLASS values
;
;	CLASS fields appear in resource records

	CL.IN==^D1		;The Internet
;	CL.CS==^D2		;The computer science network (CSNET)

;[9156] QCLASS values
;
;	QCLASS fields appear in the question section of a query.  They
;	include the values of CLASS with the following additions:

	QC.ANY==^D255		;Any class
	SUBTTL DNS Resolver -- Definitions -- Pure Data

;[9156] DNS server request number

NR NSREQN			;[9156] A count of the number of ns requests

;[9156] Port number assignment for use with UDP DNS requests.

DOMPRT==^D53			;[9156] Port assigned to domain servers

;[9156] This is the template argument block for the ASNIQ% JSYS.

ASNIQT:	EXP <.UDPFM>B31		;[9156] .IQPRV protocol number
	EXP 0			;[9156] .IQFHV foreign host value
	EXP 0			;[9156] .IQSHV source host value
	EXP <DOMPRT>B31		;[9156] .IQPTV <local>B15+<foreign>b35 ports
	EXP 177B31		;[9156] .IQPRM protocol number mask
	EXP ^-17		;[9156] .IQFHM foreign host value mask
	EXP ^-17		;[9156] .IQSHM source host value mask
	EXP ^-17		;[9156] .IQPTM port value mask
	EXP .IQLEN+1		;[9156] .IQLEN length of argument block
	SUBTTL DNS Resolver -- Definitions -- Storage

;[9156] Define the sizes of certain blocks used in the DNS routines.

	RSPBUL==<^D1280/^D4>+.UDPDA+PKTELI+1 ;[9168] Buffer size UDP DNS reply
	QUEBUL==RSPBUL		;[9156] Buffer size for UDP DNS question
	NAMNUM==MAXLW		;[9156] Size of NAMLST and NUMLST
	NAMBUL==<^D128/5>+1	;[9156] Size of ASCIZ name buffer in words
	INFBUL==MAXLW		;[9156] Size of info string buffer

;[9156] Create a macro to allocate the storage.

DEFINE DNSTRV,<			;[9156] Define a macro to allocate storage
	DNSFSA IQHAND		;[9156] Internet queue handle
	DNSFSA ASNIQB,.IQLEN+1	;[9156] Space to create ASNIQ block
	DNSFSA NAMTTL		;[9156] Temp time to live
	DNSFSA DNSTTL		;[9156] Time to live when adding host
	DNSFSA DNSSTS		;[9156] Host status bits when adding host
	DNSFSA DNSARG,2		;[9156] Arguments given to GTHST interface
	DNSFSA NAMLST,NAMNUM+1	;[9156] List of host name indexes to add
	DNSFSA NUMLST,NAMNUM+1	;[9156] List of host numbers to add
	DNSFSA QCLASS		;[9156] Question Class (CL.xxx)
	DNSFSA QTYPE,2		;[9156] Question Type (T.xxx)
	DNSFSA QUEBUF,0		;[9168] Space to make UDP query
	DNSFSA RSPBUF,RSPBUL	;[9156] Space to receive UDP response
	DNSFSA NAMBWC		;[9156] Word count in NAMBUF
	DNSFSA NAMBCC		;[9156] Character count in NAMBUF
	DNSFSA NAMBUF,NAMBUL	;[9156] Name string buffer
	DNSFSA INFBUF,INFBUL	;[9156] Other info string buffer
>				;[9156] End of DEFINE DNSTRV

;[9156] Now invoke the macro to allocate the storage

DEFINE DNSFSA(NAME,SIZE<1>),<	;[9156] Invoked for each element
	NAME=FPG0A+......	;[9156] Define a macro for it
	......==......+SIZE	;[9156] Point to next free slot
>				;[9156] End of DEFINE DNSFSA
	......==0		;[9156] Free space starts here
	DNSTRV			;[9156] Invoke the macro
	IFG ......-<PGSIZ-1>,<	;[9156] If more than one page allocated
		PRINTX ? More than 1 page of DNS storage requested
	>			;[9156] End if IFLE

;[9156] Now define a macro to make the items useless outside the scope of code.

	DEFINE DNSEND,<		;[9156] Macro to end DNS variables
	DEFINE DNSFSA(NAME,SIZE),<DEFINE NAME,<.....U>> ;[9156]
	DNSTRV			;[9156] Make them go away (well, sort of)
>				;[9156] End of DNSEND macro

;[9156] Create a macro to allocate storage for these routines.

	DEFINE STGDNS,<		;[9156] Make TRVAR and other storage
	JSP T4,DNSSTG		;[9156] Routine to allocate the page
>				;[9156] End of DEFINE STGDNS

;[9156] Routine to get the page at FPG0A, and set up parsing storage. Upon
;return, the page at FPG0A is released.  Used only from STGDNS macro, defined
;above.

DNSSTG:	SAVEPQ			;[9156] Save Ps and Qs
	SKIP FPG0A		;[9156] Cause the page to appear
	SETZM NAMLST		;[9156] No names yet
	SETZM NUMLST		;[9156] No addresses yet
	MOVX CX,.INFIN		;[9156] Load the biggest number we can think of
	MOVEM CX,DNSTTL		;[9156] Store that number as the min TTL seen
	MOVX CX,HS%SRV!HS%DNS	;[9156] Load default status bits
	MOVEM CX,DNSSTS		;[9156] Save the status bits

	CALL (T4)		;[9156] Call the routine to use that page
	 CAIA			;[9156] Caller gave non skip return
	AOS (P)			;[9156] Caller gave skip return

	DMOVEM T1,P1		;[9156] Save T1 and T2 for a moment
	SETZ T1,		;[9156] Indicate no mapping desired
	MOVEI T2,RSPBUF		;[9156] Load address (not page number)
	CALL SETMPG		;[9156] (T1,T2/) Unmap old page and return
	DMOVE T1,P1		;[9156] Restore T1 and T2

	RET			;[9156] Return to caller
	SUBTTL DNS Resolver -- GTHST% Interface -- Number to String

;[9156] Here to perform DNS number to string translation
;Call with T1/ IP address to find host name for
;Returns +1 if host not found
;	T1/ error code
;Returns +2 if host found and added to tables

DNSNTS:	STGDNS			;[9156] Set up storage

;[9156] Don't even try to get a network number resolved.

	CALL NETMSK		;[9156] (T1/T1,T2,T3) Return masked net number
	CAMN T1,T2		;[9156] Asking for a network IP address?
	RETBAD(GTHSX7)		;[9156] "Server failed to find data"

;[9156] Get a reply from the resolver code, and check the data returned.

	XMOVEI T4,DNSBNS	;[9156] Load address code to make question
	CALL DNSRSV		;[9156] (T1,T4/T1,Q1,PKT) Resolve that
	 RETBAD()		;[9156] Return error back to caller
	CALL DNSPRQ		;[9156] (Q1/T1,Q1) Parse the question area
	 RETBAD()		;[9156] It was a bad question area
	CALL DNSPRP		;[9156] (Q1,PKT/T1,Q1) Parse answer PTR records
	 RETBAD()		;[9156] Something smelled bad about it

;[9156] Add the data to the host tables and return.

	MOVEI T1,NAMLST		;[9156] Point to name list
	MOVEI T2,NUMLST		;[9156] Point to address list
	MOVE T3,DNSSTS		;[9156] Host bit, DNS bit, and possibly HS%INA
	MOVE T4,DNSTTL		;[9156] Load the time to live
	CALL ADDHOS		;[9156] (T1,T2,T3,T4/) Add that host
	 RETBAD(GTHX10)		;[9156] Apparently the tables are full
	RETSKP			;[9156] Return +2 
	SUBTTL DNS Resolver -- GTHST% Interface -- String to Number

;[9156] Here to perform DNS string to number translation.
;Call with T1/ pointer to host name string 
;Returns +1 if host not found, with
;	T1/ error code
;Returns +2 if host found and added to tables

DNSSTN:	STGDNS			;[9156] Set up DNS storage, save ACs, etc.
	MOVEM T1,DNSARG		;[9156] Save argument

;[9156] Get any type A and CNAME RRs for string and add them to the host table.

	MOVE T2,[CL.IN,,T.A]	;[9156] Load class,,type for query
	XMOVEI T4,DNSBVN	;[9156] Load routine to construct the question
	CALL DNSRSV		;[9156] (T1,T4/T1,Q1,PKT) Resolve that
	 RETBAD()		;[9156] Return error back to caller
	CALL DNSPRQ		;[9156] (Q1/T1,Q1) Parse the question area
	 RETBAD()		;[9156] It was a bad question area
	CALL DNSPRA		;[9156] (Q1,PKT/T1,Q1) Parse type A records
	 RETBAD()		;[9156] Something smelled bad about it

;[9156] Attempt to make another request to get operating system type for table.

	MOVE T1,DNSARG		;[9156] Load pointer to name once again
	MOVE T2,[CL.IN,,T.HINFO] ;[9156] Load class,,type for op sys query
	HLRZM T2,QCLASS		;[9156] Save class for parsing routine
	XMOVEI T4,DNSBVN	;[9156] Load routine to construct the question
	CALL DNSRSV		;[9156] (T1,T2,T4/T1,Q1,PKT) Resolve that
	IFSKP.			;[9156] If we got a reply
	  CALL DNSPRQ		;[9156] (Q1/T1,Q1) Parse the question area
	  IFSKP.		;[9156] If question parsed
	    CALL DNSPHI		;[9156] (Q1,PKT/T1,Q1) Parse type HINFO records
	    IFSKP.		;[9156] If answer parsed
	      MOVE T1,[POINT 7,NAMBUF] ;[9156] Point to the os type string
	      CALL OMATCH	;[9156] (T1/T3) Match that string
	      IORM T3,DNSSTS	;[9156] Store the operating system type
	    ENDIF.		;[9156] End of answer parsed code
	  ENDIF.		;[9156] End of question parsed
	ENDIF.			;[9156] End of resolver got reply code

;[9156] Now add the host information to the host tables and return.

	MOVEI T1,NAMLST		;[9156] Point to name list
	MOVEI T2,NUMLST		;[9156] Point to address list
	MOVE T3,DNSSTS		;[9156] Host bit, DNS bit, and so on
	MOVE T4,DNSTTL		;[9156] Load the time to live
	CALL ADDHOS		;[9156] (T1,T2,T3,T4/T1) Add that host
	 RETBAD(GTHX10)		;[9156] Apparently the tables are full

	RETSKP			;[9156] Return +2 
	SUBTTL DNS Resolver -- GTHST% Interface -- Inverse Query

IFN FTIQUE,<			;[9156] Only if IQUERY supported (NSLOOK)
;[9156] Here to perform DNS inverse query.
;Call with T1/ IP address to find host name for
;Returns +1 if host not found, with
;	T1/ error code
;Returns +2 if host found and added to tables

DNSIQU: STGDNS			;[9156] Set up storage

;[9156] Get an answer from a nameserver.

	XMOVEI T4,DNSBIQ	;[9156] Load address code to make question
	CALL DNSRSV		;[9156] (T1,T4/T1,Q1,PKT) Resolve that
	 RETBAD()		;[9156] Return error back to caller
	CALL DNSPRQ		;[9156] (Q1/T1,Q1) Parse the question area
	 RETBAD()		;[9156] It was a bad question area
	CALL DNSPRA		;[9156] (Q1,PKT/T1,Q1) Parse type A records
	 RETBAD()		;[9156] Something smelled bad about it

;[9156] Add this to the table and return.

	MOVEI T1,NAMLST		;[9156] Point to name list
	MOVEI T2,NUMLST		;[9156] Point to address list
	MOVE T3,DNSSTS		;[9156] Host bit, DNS bit, and possibly HS%INA
	MOVE T4,DNSTTL		;[9156] Load the time to live
	CALL ADDHOS		;[9156] (T1,T2,T3,T4/) Add that host
	 RETBAD(GTHX10)		;[9156] Apparently the tables are full
	RETSKP			;[9156] Return +2 
>				;[9156] End of IFN FTIQUE
	SUBTTL DNS Resolver -- GTHST% Interface -- Mail Exchange

;[9156] Here to perform DNS MX query.
;This routine calls the GTHRMX routine to return the data to the user.
;Call with
;	T1/ pointer to domain style name for mail destination
;	T2/ class,,0
;Returns +1 if we could not resolve query or some other problem with
;	T1/ error code
;Returns +2 with answer stored back to user

DNSDMX:	STGDNS			;[9156] Set up storage

;[9156] Try to get the MX records for this name.

	HRRI T2,T.MX		;[9156] Make a MX type please
	XMOVEI T4,DNSBVN	;[9156] Load routine to construct the question
	CALL DNSRSV		;[9156] (T1,T4/T1,Q1,PKT) Resolve that
	 RETBAD()		;[9156] Return error back to caller
	CALL DNSPRQ		;[9156] (Q1/T1,Q1) Parse the question area
	 RETBAD()		;[9156] Return error in T1
	CALL DNSPMX		;[9156] (Q1,PKT/T1,Q1) Check the MX records out
	 RETBAD ()		;[9156] Return error back to caller

;[9156] Return the MX records to the user and return.

	MOVEI Q1,NAMLST		;[9156] Point to list of pointers 
	CALL GTHRMX		;[9156] (Q1,PKT/T1) Call routine to store data
	 RETBAD()		;[9156] Return T1/ error
	RETSKP			;[9156] Good return
	SUBTTL DNS Resolver -- GTHST% Interface -- Validate Name

;[9156] Here to perform DNS query to validate a name.
;This routine calls the GTHRVN routine to return the data to the user.
;Call with
;	T1/ byte pointer to name string
;	T2/ class,,type to match on
;Returns +1 if we could not resolve query or some other problem with
;	T1/ error code
;Returns +2 with answer stored back to user

DNSDVN:	STGDNS			;[9156] Set up storage

;[9156] Set class and list of types to match on for parsing routine.

	HLRZM T2,QCLASS		;[9156] Save class for parsing routine
	HRRZM T2,QTYPE		;[9156]  and type for later checks
	HRRZ T3,T2		;[9156] Load the requested type value
	CAIE T3,.GTHVH		;[9156] Validate host?
	CAIN T3,.GTHVZ		;[9156] Validate zone subfunction?
	HRRI T2,QT.ALL		;[9156] Load type "all" for the query

;[9156] Try to get information about this name from a nameserver.

	XMOVEI T4,DNSBVN	;[9156] Load routine to construct the question
	CALL DNSRSV		;[9156] (T1,T2,T4/T1,Q1,PKT) Resolve that
	 RETBAD()		;[9156] Return error back to caller
	CALL DNSPRQ		;[9156] (Q1/T1,Q1) Parse the question area
	 RETBAD()		;[9156] Return error in T1
	MOVE T3,QTYPE		;[9156] Reload the desired class or token
	MOVEI Q2,QTYPE		;[9156] If nothing special its a list of one
	SETZM QTYPE+1		;[9156] Insure the second word is zero
	CAIN T3,.GTHVH		;[9156] Validate host token?
	MOVEI Q2,[EXP T.A,T.MX,T.WKS,T.HINFO,0] ;[9156] Load adr of VH types
	CAIN T3,.GTHVZ		;[9156] Validate zone subfunction?
	MOVEI Q2,[EXP T.SOA,T.NS,0] ;[9156] Load address of VZ types 
	CALL DNSPVN		;[9156] (Q1,Q2,PKT/T1,T2,Q1) Check the RRs out
	 RETBAD ()		;[9156] Bubble error up 

;[9156] Return the matching information to the user.

	CALL GTHRVN		;[9156] (T1,T2/T1) Return that to the user
	 RETBAD()		;[9156] Owie returning the data

	RETSKP			;[9156] Success return
	SUBTTL DNS Resolver -- GTHST% Interface -- Operating System

;[9156] Here to perform query to get host information name.
;This routine calls the GTHROS routine to return the data to the user.
;Call with
;	T1/ byte pointer to name string
;	T2/ class,,T.HINFO
;Returns +1 if we could not resolve query or some other problem with
;	T1/ error code
;Returns +2 with answer stored back to user by calling GTHROS

DNSDOS:	STGDNS			;[9156] Set up storage

;[9156] Ask a nameserver for the host information.

	HLRZM T2,QCLASS		;[9156] Save class for parsing routine
	XMOVEI T4,DNSBVN	;[9156] Load routine to construct the question
	CALL DNSRSV		;[9156] (T1,T4/T1,Q1,PKT) Resolve that
	 RETBAD()		;[9156] Return error back to caller
	CALL DNSPRQ		;[9156] (Q1,PKT/T1,Q1) Parse the question area
	 RETBAD()		;[9156] Return error in T1
	CALL DNSPHI		;[9156] (Q1,PKT/T1,Q1) Check the RRs out
	 RETBAD ()		;[9156] Bubble error up 

;[9156] Return the information to the user.

	CALL GTHROS		;[9156] (T1/T1) Return that to the user
	 RETBAD()		;[9156] Owie returning the data

	RETSKP			;[9156] Success return
	SUBTTL DNS Resolver -- Resolver Top Level

;[9156] Here to perform DNS question and answer processing.
;Called from GTHST% interface routines with
;	T1/ Data for question building routine
;	T2/ Data for question building routine
;	T4/ address of routine to call to build question
;Returns +1 if some error with
;	T1/ error code
;Returns +2 if a response is ready to parse, header checked, with
;	PKT/ address of response buffer packet
;	Q1/ byte pointer to question section

DNSRSV:	SKIPN DNSHST		;[9156] Any nameserver hosts available?
	RETBAD (GTHSX1)		;[9156] "No DNS name servers configured"

	CALL DNSBHD		;[9156] (/P1,P2,PKT) Build header, setup P1, P2
	CALL (T4)		;[9156] (T1,T2,T3,P1,P2,PKT/P1,P2) Make query
	CALL DNSBFN		;[9156] (P1,P2,PKT/) Finish it up

	MOVSI P2,-NDNSH		;[9156] Load -hostcount,,0
	DO.			;[9156] Now loop through all nameservers
	  SKIPN DNSHST(P2)	;[9156] Don't smash T1 but check if host here
	  RETBAD()		;[9156] No more hosts to try, return T1/ error
	  MOVE T1,DNSHST(P2)	;[9156] Load the host address to try
	  MOVE T2,DNSTMO(P2)	;[9156] Load timeout for that host
	  CALL DNSQNA		;[9156] (T1,T2,PKT/T1,Q1,PKT) Ask a server
	  IFSKP.		;[9156] If that worked, we can skip return
	    AOS DNSSUC(P2)	;[9156] Count the success for this DNS server
	    RETSKP		;[9156]  and return success to the caller
	  ENDIF.		;[9156] Otherwise it failed for some reason
	  AOS DNSFAI(P2)	;[9156] Count the failure for this DNS server
	  CAIE T1,GTHSX8	;[9156] "Data not found in namespace"?
	  AOBJN P2,TOP.		;[9156] That one didn't work, try the next one
	OD.			;[9156] End of loop, we must return +1
	RETBAD()		;[9156] Return +1, no one knew, T1/ error

;[9156] Local routine to ask a DNS server and get the reply.
;Call with
;	T1/ IP address to send to
;	T2/ timeout in second
;	PKT/ address of packet
;This routine must preserve P2, and uses P1, P3, Q1, Q2, Q3.
;Returns +1 if error, with
;	T1/ error code
;Returns +2 if some information returned from the DNS host, with
;	Q1/ pointer to question section

DNSQNA:	IMULI T2,^D1000		;[9156] Convert seconds to milliseconds
	ADD T2,TODCLK		;[9156] Get that time in the future
	MOVEM T2,Q3		;[9156] Set UPTIME when we should timeout 

	CALL DNSSND		;[9156] (T1/PKT,T1) Send the message out
	 RETBAD()		;[9156] Something went wrong with the send

	CALL DNSRCV		;[9156] (Q3/PKT,T1) Get answer if possible
	 RETBAD()		;[9156] Timed out or couldn't send it

	CALL DNSPRH		;[9156] (PKT/T1) Check out the header
	 RETBAD()		;[9156] Bad header, can't use this data

	RETSKP			;[9156] Success return
	SUBTTL DNS Resolver -- Construct Question -- Begin Question

;[9156] Construct IP and UDP headers.
;Call with
;	PKT/ pointer to data portion of packet.
;Note that T1 through T4 must be preserved!
;Returns +1 always, with
;	P1/ pointer into QUEBUF,
;	P2/ byte count in QUEBUF
;	PKT/ address of QUEBUF

DNSBHD:	SAVET			;[9156] Save T1-T4

	MOVEI T1,.IQLEN+1	;[9156] Load word count to move
	XMOVEI T2,ASNIQT	;[9156] Point to template for that
	XMOVEI T3,ASNIQB	;[9156] Point to place to make ASNIQs
	CALL XBLTA		;[9156] (T1,T2,T3/) Copy template into block

	SETZM QUEBUF		;[9156] Clear first word
	MOVEI T1,QUEBUL-1	;[9156] Load number of words to move
	XMOVEI T2,QUEBUF	;[9156] Point to first word
	XMOVEI T3,1+QUEBUF	;[9156] Point to second word for zeroing
	CALL XBLTA		;[9156] Clear the question buffer

	MOVEI PKT,QUEBUF	;[9156] Point to first word of user data area

;[9156] Set up the start of the IP header.

	MOVEI T3,.INTVR		;[9156] Load IP version
	STOR T3,PIVER,(PKT)	;[9156] Store in IP header
	MOVEI T3,.IPKDH+1	;[9156] Load offset to data in 32 bit words
	STOR T3,PIDO,(PKT)	;[9156] Save as offset to data
	MOVEI T3,.UDPFM		;[9156] Load UDP protocol number 
	STOR T3,PIPRO,(PKT)	;[9156] Save as protocol type
	MOVEI T3,77		;[9156] Load a goodly time to live
	STOR T3,PITTL,(PKT)	;[9156] Save it

;[9156] Set the "from" address as our preferred address.

	MOVE T3,PRFADR		;[9156] Get preferred address
	LSH T3,4		;[9156] Left justify it today
	MOVEM T3,.IQSHV+ASNIQB	;[9156] Store it
	MOVEM T3,PKTELI+.IPKSH(PKT) ;[9156] Store in IP header

;[9156] Make a unique port number and store it.

	AOS T4,JOBUNI		;[9156] Get next unique number for this job
	ANDI T4,77		;[9156] Only last 6 bits please
	MOVE T3,JOBNO		;[9156] Get my (local) job number
	LSH T3,6		;[9156] Shifted over 6 bits
	IOR T4,T3		;[9156] Fold together job and unique number
	ADDI T4,100000		;[9156] Add in the offsetto get over 256
	DPB T4,[POINT 16,.IQPTV+ASNIQB,15] ;[9156] Store the port number here
	MOVE T3,.IQPTV+ASNIQB	;[9156] Load the port numbers
	MOVEM T3,PKTELI+.UDSDP(PKT) ;[9156] Store the port numbers

;[9156] Start setting up domain server protocol header.

	AOS T3,NSREQN		;[9156] Load a new ID
	STOR T3,HDID,(PKT)	;[9156] Store it
	SETONE HDRD,(PKT)	;[9156] Indicate recursion desired
	MOVEI T3,OC..QU		;[9156] Query is the opcode
	STOR T3,HDOC,(PKT)	;[9156] Store it there
	MOVEI T3,1		;[9156] Load number of questions
	STOR T3,HDQDC,(PKT)	;[9156] There is only one question

;[9156] Set up P1 and P2 for return, then return.

	MOVX P1,<POINT 8,>	;[9156] Make a pointer
	ADDI P1,.HDQUE+QUEBUF	;[9156] Point to the question data area
	MOVEI P2,<.HDQUE-PKTELI>*4 ;[9156] Load size of message so far

	RET			;[9156] Return OK
	SUBTTL DNS Resolver -- Construct Question -- Number to String

;[9156] Construct domain query to find host address from host name.
;Call with
;	T1/ IP address, right justified
;	P1/ Pointer to question buffer
;	P2/ Count of bytes in question buffer
;	PKT/ packet pointer
;Returns +1 always, P1, P2 updated

DNSBNS:	MOVEM T1,P3		;[9156] Save the IP address to ask for

	MOVEI T1,NAMBUF		;[9156] Point to temporary buffer area
	HRLI T1,(POINT 7)	;[9156] Make it a byte pointer
	MOVEI T4,4		;[9156] Load number of octets to translate
	DO.			;[9156] Loop to make reverse order name
	  LDB T2,[POINT 8,P3,35] ;[9156] Load a byte of data
	  CALL DNSNT1		;[9156] (T1,T2/T1,T2) Change number to string
	  MOVEI T2,"."		;[9156] Load a dot
	  IDPB T2,T1		;[9156] Store it in string
	  LSH P3,-8		;[9156] Shift over a byte
	  SOJG T4,TOP.		;[9156] Loop if more work to do
	OD.			;[9156] End of this loop
	MOVE T2,[POINT 7,[ASCIZ/IN-ADDR.ARPA/]]	;[9156] Load special PTR info
	DO.			;[9156] Loop to store pointer info
	  ILDB T3,T2		;[9156] Load a source byte
	  IDPB T3,T1		;[9156] Store it in the temp string
	  JUMPN T3,TOP.		;[9156] Loop until null seen
	OD.			;[9156] Now the string is set up to send

	MOVEI T2,NAMBUF		;[9156] Point to temporary buffer area
	HRLI T2,(POINT 7)	;[9156] Make it a byte pointer
	CALL DNSBSC		;[9156] (P1,P2,T2/P1,P2) Send that string
	
	MOVEI T2,T.PTR		;[9156] Host address is what we want to get
	CALL DNSB2C		;[9156] (P1,P2,T2/P1,P2) Send along QTYPE

	MOVEI T2,CL.IN		;[9156] Internet address please
	CALLRET DNSB2C		;[9156] (P1,P2,T2/P1,P2) Send along QCLASS

DNSNT1:	IDIVI T2,^D10		;[9156] Get the next digit in T3 please
	PUSH P,T3		;[9156] Store that on the stack
	SKIPE T2		;[9156] All done getting numbers?
	CALL DNSNT1		;[9156] (T1,T2/T1,T2) Nope, loop for all
	POP P,T3		;[9156] Restore the number
	ADDI T3,"0"		;[9156] Convert to ASCII
	IDPB T3,T1		;[9156] Store that digit
	RET			;[9156] Return 
	SUBTTL DNS Resolver -- Construct Question -- Inverse Query

IFN FTIQUE,<			;[9156] 
;[9156] Construct domain inverse query to find host name from host address.
;Call with
;	T1/ IP address, right justified
;	P1/ Pointer to question buffer
;	P2/ Count of bytes in question buffer
;	PKT/ packet pointer
;Returns +1 always, P1, P2 updated

DNSBIQ:	MOVEM T1,P3		;[9156] Save the IP address to ask for

	MOVEI T1,OC..IQ		;[9156] Inverse query is the opcode
	STOR T1,HDOC,(PKT)	;[9156] Store it there
	MOVEI T1,1		;[9156] Load number of answers
	STOR T1,HDANC,(PKT)	;[9156] There is only one answer
	SETZRO HDQDC,(PKT)	;[9156] There are no questions now

	MOVEI T1,0		;[9156] Load a zero
	CALL DNSB1C		;[9156] (P1,P2,T1/P1,P2) Send a null name first
	
	MOVEI T2,T.A		;[9156] Address type
	CALL DNSB2C		;[9156] (P1,P2,T2/P1,P2) Send along QTYPE

	MOVEI T2,CL.IN		;[9156] Internet class 
	CALL DNSB2C		;[9156] (P1,P2,T2/P1,P2) Send along QCLASS
	
	MOVEI T2,1		;[9156] Load a TTL
	CALL DNSB4C		;[9156] Send the TTL along

	MOVEI T2,4		;[9156] Load number of data bytes
	CALL DNSB2C		;[9156] (P1,P2,T2/P1,P2) Send numb data bytes

	MOVE T2,P3		;[9156] Load the address
	CALLRET DNSB4C		;[9156] (P1,P2,T2/P1,P2) Send address

>				;[9156] End of IFN FTIQUE
	SUBTTL DNS Resolver -- Construct Question --  Name Query Types

;[9156] Here to construct a query taking a string, class, and type.  Examples
;of these query types are A, CNAME, and MX.
;Call with
;	T1/ pointer to string in monitor space
;	T2/ class,,type for this query
;	P1/ Pointer to question buffer
;	P2/ Count of bytes in question buffer
;	PKT/ packet pointer
;Returns +1 always
;	P1/ updated pointer
;	P2/ updated count

DNSBVN:	MOVEM T2,P3		;[9156] Save the class,,type
	MOVE T2,T1		;[9156] Copy pointer to string
	CALL DNSBSC		;[9156] (P1,P2,T2/P1,P2) Start with QNAME

	HRRZ T2,P3		;[9156] Load the supplied type, often type A
	CALL DNSB2C		;[9156] (P1,P2,T2/P1,P2) Send along QTYPE

	HLRZ T2,P3		;[9156] Load the class, usually Internet
	CALLRET DNSB2C		;[9156] (P1,P2,T2/P1,P2) Send along QCLASS
	SUBTTL DNS Resolver -- Construct Question --  Finish Question

;[9156] Finish up Question section.
;Call with
;	P1/ Pointer to question buffer
;	P2/ Count of bytes in question buffer
;	PKT/ packet pointer
;Returns +1 always, packet ocmplete except for "to" address and checksums

DNSBFN:	STOR P2,PIPL,(PKT)	;[9156] Store length in the IP header
	LOAD T1,PIPL,(PKT)	;[9156] Packet length in bytes
	LOAD T2,PIDO,(PKT)	;[9156] Internet data offset
	ASH T2,2		;[9156] Convert to bytes
	SUB T1,T2		;[9156] Compute length of UDP portion
	STOR T1,UDPLN,(PKT)	;[9156] Store in UDP header

	MOVEI T1,3(P2)		;[9156] Load 3+bytes in header for rounding
	IDIVI T1,4		;[9156] Compute words in the request
	ADDI T1,1		;[9156] Count word count word
	MOVEM T1,PKTELI-1(PKT)	;[9156] Save as word count this buffer
	RET			;[9156] Return
	SUBTTL DNS Resolver -- Construct Question -- Subroutines

;[9156] DNSBSC - Routine to copy a up to 63 byte counted string.
;Call P1/ destination pointer, T2/ source ASCII pointer
;Returns +1 always

DNSBSC:	CALL DNSBSD		;[9156] Copy string to dot or null
	JUMPN T1,DNSBSC		;[9156] Loop until null seen
	CALLRET DNSB1C		;[9156] (T1,P1,P2/P1,P2) Store zero, return

DNSBSD:	SETZB T4,T1		;[9156] Clear counter and byte to store
	MOVE T3,P1		;[9156] Save current copy of pointer
	CALL DNSB1C		;[9156] (T1,P1,P2/P1,P2) Store a byte
	DO.			;[9156] For entire string
	  ILDB T1,T2		;[9156] Load a byte
	  JUMPE T1,ENDLP.	;[9156] Get out if a null
	  CAIN T1,"."		;[9156] Is it a dot?
	  EXIT.			;[9156] Yes
	  CALL DNSB1C		;[9156] (T1,P1,P2/P1,P2) Store a byte
	  AOJA T4,TOP.		;[9156] Loop for all of it
	OD.			;[9156] Here after null seen
	IDPB T4,T3		;[9156] Store the length byte
	RET			;[9156] Return with T1/ last character

;[9156] DNSB4C - here to store four bytes in the request buffer
;[9156] DNSB2C - here to store two bytes in the request buffer.
;Call T2/ right justified bytes, P1/ pointer, P2/ count
;Returns +1 always, P1 and P2 updated

IFN FTIQUE,<			;[9156] 
DNSB4C:	LDB T1,[POINT 8,T2,35-24] ;[9156] Load a byte
	CALL DNSB1C		;[9156] (T1,P1,P2/P1,P2) Copy it
	LDB T1,[POINT 8,T2,35-16] ;[9156] Load a byte
	CALL DNSB1C		;[9156] (T1,P1,P2/P1,P2) Copy it
>				;[9156] End of IFN FTIQUE

DNSB2C:	LDB T1,[POINT 8,T2,35-8] ;[9156] Get the second byte
	CALL DNSB1C		;[9156] (T1,P1,P2/P1,P2) Copy it
	LDB T1,[POINT 8,T2,35]	;[9156] Get the second byte
;	CALLRET DNSB1C		;[9156] (T1,P1,P2/P1,P2) Copy that and return

;[9156] DNSB1C - here to store one counted byte from T1 into the buffer.
;Call T1/ byte, P1/ pointer, P2/ count
;Returns +1 always

DNSB1C:	IDPB T1,P1		;[9156] Store a byte
	AOS P2			;[9156] Count it
	RET			;[9156] Return

	SUBTTL DNS Resolver -- Send Question

;[9156] Here to send the question to a host running a DNS server.
;Call with REQBUF set up except for checksums and destinatoon dest address
;	T1/ IP address to send to
;Returns +1 if error, with
;	T1/ error code
;Returns +2 if success, RSPBUF set up with the response

DNSSND:	MOVEI PKT,QUEBUF	;[9156] Point to first word of user data area

;[9156] Store destination IP address for this attempt.

	LSH T1,4		;[9156] Shift IP address over to proper place
	MOVEM T1,.IQFHV+ASNIQB	;[9156] Store it in the ASNIQ block first
	MOVEM T1,PKTELI+.IPKDH(PKT) ;[9156] Store in IP header as well

;[9156] Clear any old checksums, then compute new ones and store them.

	SETZRO PICKS,(PKT)	;[9156] Clear any stale IP checksum
	SETZRO UDPCK,(PKT)	;[9156]  and any stale UDP checksum as well
	CALL INTCKS		;[9156] (PKT/T1) Do the internet header checksu
	STOR T1,PICKS,(PKT)	;[9156] Store the IP checksum for the packet
	CALL UDPCKS		;[9156] (PKT/T1) Do the checksum for UDP
	STOR T1,UDPCK,(PKT)	;[9156] Store the UDP checksum in the packet

;[9156] Assign internet queue.

	MOVEI T1,ASNIQB		;[9156] Point to the argument block
	SETZB T2,T3		;[9156] These two must be zero
	ASNIQ%			;[9156] Try to get it assigned
	 ERJMPR R		;[9156] Return if owie with T1/ error
	MOVEM T1,IQHAND		;[9156] Save the internet queue handle

;[9156] Echo the question if debugging.

IFN FTIQUE,<			;[9156] Only if iquery support
	SKIPE DEBUG		;[9156] Debugging?
	CALL PRTPKT		;[9156] (PKT/) Type out the packet
>				;[9156] End of IFN FTIQUE

;[9156] Send out the request.

;	MOVE T1,IQHAND		;[9156] Handle is still in T1
	MOVEI T2,PKTELI-1(PKT)	;[9156] Point to query buffer
	SETZ T3,		;[9156] Must be zero
	SNDIN%			;[9156] Send it out please
	 ERJMPR DNSREL		;[9156] Error, release, return +1 with T1/code
	RETSKP			;[9156] It has been sent
	
	SUBTTL DNS Resolver -- Receive Answer

;[9156] Get a response back from the server
;Call with
;	Q3/ TODCLK when we should give up waiting
;Returns +1 if if error, with
;	T1/ error code
;Returns +2 if success, RSPBUF set up with the response

DNSRCV: MOVEI PKT,RSPBUF	;[9156] Point to response packet
	DO.			;[9156] Loop to get response from server
	  HRRZ T1,IQHAND	;[9156] Load queue handle
	  SKIPG INTQSP(T1)	;[9156] Any messages queued for us?
	  IFSKP.		;[9156] Yes, there are some
	    MOVE T1,IQHAND	;[9156] Get the internet queue handle back
	    TXO T1,RIQ%NW	;[9156] Set the no wait bit
	    MOVEI T2,RSPBUL-<PKTELI+1> ;[9156] Load length of buffer-1
	    MOVEM T2,PKTELI-1(PKT) ;[9156] Store it back there
	    MOVEI T2,PKTELI-1(PKT) ;[9156] Point to rec buffer
	    RCVIN%		;[9156] Get something
	    IFNJE.		;[9156] If that worked
IFN FTIQUE,<			;[9156] Only if iquery support (nslook program)
	      SKIPE DEBUG	;[9156] Debugging?
	      CALL PRTPKT	;[9156] (PKT/) Yes type out packet
>				;[9156] End of IFN FTIQUE
	      CALL INTCKS	;[9156] (PKT/T1) Do the internet header checksu
	      JUMPN T1,ENDLP.	;[9156] Get out if bad checksum
	      LOAD T1,UDPCK,(PKT) ;[9156] Get the UDP checksum
	      SKIPE T1		;[9156] Zero means no checksum!
	      CALL UDPCKS	;[9156] (PKT/T1) Do the checksum
	      JUMPN T1,ENDLP.	;[9156] Bad UDP checksum
	      CALL DNSREL	;[9156] Forget the special internet queue
	      RETSKP		;[9156] Skip return to daddy
	    ENDIF.		;[9156] Otherwise there may have been an error
	    CAME T1,[-1]	;[9156] No packet available?
	    JRST DNSREX		;[9168] Real error, and return+1 with T1/ code
	  ENDIF.		;[9156] So, now I lay me down to sleep
	  CAMGE Q3,TODCLK	;[9156] Has TODCLK reached the time to quit?
	  EXIT.			;[9156] Yes, get out of here
	  CALL ULKGTH		;[9156] (/) Unlock the tables, go okint
	  MOVE T2,TODCLK	;[9156] Get current uptime
	  ANDI T2,377777	;[9156] Modulo 377777
	  ADDI T2,^D100		;[9156] Want to rest for a fraction of a second
	  MOVEI T1,BLOCKW	;[9156] Use BLOCKW and HDISMS
	  HRL T1,T2		;[9156] Load data for scheduer test
	  HDISMS (^D100)	;[9156] (T1/) Snooze 100 ms, in balset 
	  CALL LCKGTH		;[9156] (/) Lock it back up again, go noint
	  LOOP.			;[9156] Keep looking
	OD.			;[9156] End of loop
	MOVEI T1,GTHSX7		;[9156] "Server failed to find data"
;	CALLRET DNSREL		;[9156] Fall thru, this timed out

;[9156] Here to release the Special Internet Queue.
;Returns +1 always with internet queue released, preserves T1.

DNSREL:	MOVEM T1,T4		;[9156] Save possible error code
	MOVE T1,IQHAND		;[9156] Load the number of queue
	SETZB T2,T3		;[9156] Clear the MBZ acs
	RELIQ%			;[9156] Release internet queue
	 ERJMP .+1		;[9156] This should work
	MOVE T1,T4		;[9156] Restore error code
	RET			;[9156] Return to caller

;[9168] Here when a real error from the RCVIN.

DNSREX:	BUG.(CHK,DNSURE,MNETDV,SOFT,<DNS UDP receive error>,<<T1,ERROR>>,<

Cause:	When reading a UDP DNS reply from a host, an error was returned from
	the RCVIN% JSYS.  If the error code is SNDIX1 (600732), this indicates
	that the message was too big to fit in the DNS reply buffer of 1280 
	eight bit bytes.

Action:	If the error is SNDIX1, find out why the message is too large and
	have the DNS name server host return less data.  DNS messages can get
	very large when there are a large number of "additional" and
	"authority" records.  If the error is not SNDIX1, and other TCP/IP
	software is functioning normally, and the problem can be reproduced,
	set this BUG dumpable and submit an SPR along with the dump,
	MONITR.EXE, and the system's Internet configuration files.

Data:	ERROR - RCVIN% JSYS error code
>,,<DB%NND>)			;[9168] RCVIN failures are not good
	CALLRET DNSREL		;[9168] Now get out with T1/ error code
	SUBTTL DNS Resolver -- Parse DNS Reply -- Parse Header

;[9156] Routine to scan server response and check out the header.
;Call with
;	PKT/ pointer to IP packet
;Returns +1 if error in the header,
;	T1/ error code
;Returns +2 if the header appears to be OK

DNSPRH:	MOVEI Q1,.HDQUE(PKT)	;[9156] Load address of packet's question area
	HRLI Q1,(POINT 8)	;[9156] Make it a pointer to eat from

;[9156] Examine header for response present bit, success response code bit, no
;truncation bit.

	LOAD T3,HDQR,(PKT)	;[9156] Load the "response present" bit
	JUMPE T3,[RETBAD(GTHSX7)] ;[9156] "Server failed to find data"
	LOAD T3,HDTC,(PKT)	;[9156] Was there truncation of the data?
	JUMPN T3,[RETBAD(GTHSX4)] ;[9156] "Format error in DNS message"
	LOAD T3,HDRC,(PKT)	;[9156] RCODE present, load it, 0 is success
	JUMPN T3,DNSRER		;[9156] (/T1) Return one of the error codes

;[9156] Check the answer count to insure it is valid.  Certain name server
;software returns the answer count in the high order byte, so check for this.

	LOAD T3,HDANC,(PKT)	;[9156] Number of entries in answer section
	TRNN T3,377		;[9156] Could count be in high order byte?
	LSH T3,-8		;[9156] Yes, get the right answer count
	CAILE T3,NAMNUM		;[9156] There can't be too many answers
	RETBAD(GTHSX4)		;[9156] "Format error in DNS message"
	STOR T3,HDANC,(PKT)	;[9156] Store real answer count back there

	RETSKP			;[9156] All done here, header checks out
	SUBTTL DNS Resolver -- Parse DNS Reply -- Parse Question

;[9156] Here to parse the DNS packet's header.  If a normal query, we just want
;to find the end of the question area, and since we have already checked to see
;that there is only one question, all we have to do is eat the name, class, and
;type.  If an inverse query then we want to copy the first name with class IN
;and type A into the question area to NAMLST.
;Call with
;	Q1/ pointer to question area
;Returns +1 if error, with
;	T1/ error code
;Returns +2 if question area OK, Q2 and T1-T4 smashed, with
;	Q1/ updated pointer to question area

DNSPRQ:	LOAD Q2,HDQDC,(PKT)	;[9156] Number of entries in question section
	JUMPE Q2,[RETBAD(GTHSX4)] ;[9156] "Format error in DNS message"
	DO.			;[9156] Looping through all of them to get 1st
	  CALL DNSEXT		;[9156] (Q1,PKT/Q1,T1,T2,T3) Extract name
	  CALL DNS323		;[9156] (Q1/Q1,T3) Eat the class and type
IFN FTIQUE,<			;[9156] Only if IQUERY supported
	  CAME T3,[T.A_^D16+CL.IN] ;[9156] Internet class and address type?
	  IFSKP.		;[9156] Incorrect format, return now
	    LOAD T1,HDOC,(PKT)	;[9156] Load the opcode for this request
	    SKIPN NAMLST	;[9156] Any names yet?
	    CAIE T1,OC..IQ	;[9156] Is inverse query the opcode?
	    IFSKP.		;[9156] Yes, inverse query and 1st question 
	      CALL DNSNAM	;[9156] (/T1) Store this host name from NAMBUF
	        RETBAD()	;[9156] Apparently the tables are full
	    ENDIF.		;[9156]  add first name if inverse query
	  ENDIF.		;[9156] End code for class IN and type A
>				;[9156] End of IFN FTIQUE
	  SOJG Q2,TOP.		;[9156] Loop to eat all answers
	OD.			;[9156] Question area has been parsed
	RETSKP			;[9156] Return 
	SUBTTL DNS Resolver -- Parse DNS Reply -- Parse Answer Type A and CNAME

;[9156] Here to parse type A and type CNAME
;Call with
;	Q1/ pointer to answer section
;	PKT/ address of response buffer
;Uses T1-T4, Q1-Q3, P3
;Returns +1 if some problem with the answers,
;	T1/ error code
;Returns +2 if answer appears ok, with DNSTTL, NAMLST, and NUMLST set up
;	NAMLST/ x number of words to follow this one
;		+index into NAMLST to create a new HOSTN entry 
;			or
;		-index into HOSTN table to reuse a HOSTN entry
;		the first index is for the primary host name
;	NUMLST/	y number of words to follow this one
;		y internet addresses
;	DNSTTL/ lowest value for TTL out of the answer section

DNSPRA:	MOVE Q3,Q1		;[9156] Copy pointer for second pass scan

;[9156] This loop is the first pass through the answers.  Answers which are
;type "A" and class "IN" are validated and added to NAMLST and NUMLST.  

	LOAD Q2,HDANC,(PKT)	;[9156] Number of entries in answer section
	JUMPE Q2,DNSRER		;[9156] (/T1) Return+1 if no answers there
	DO.			;[9156] Looping through all of them to get 1st
	  CALL DNSEXT		;[9156] (Q1,PKT/Q1,T1,T2,T3) Extract name
	  CALL DNS323		;[9156] (Q1/Q1,T3) Get the type and class
	  MOVE P3,T3		;[9156] Save the type for a little bit
	  CALL DNS323		;[9156] (Q1/Q1,T3) Load the TTL word
	  MOVEM T3,NAMTTL	;[9156] Secrete away that TTL for now
	  CALL DNS163		;[9156] (Q1/Q1,T3) Get the rdlength in T3
	  CAMN P3,[T.A_^D16+CL.IN] ;[9156] Internet class and address type?
	  CAIE T3,4		;[9156] Is there only four bytes of ret data?
	  IFSKP.		;[9156] Yes, a good host address today
	    CALL DNS323		;[9156] (Q1/Q1,T3) Get internet address
	    CALL DNSNUM		;[9156] (T3/T3,T4) Add to list of addresses
	     RETBAD()		;[9156] Something wrong here my friends
	    SKIPE NAMLST	;[9156] Have there been any names stored?
	    IFSKP.		;[9156] No names added to host table yet
	      CALL DNSNAM	;[9156] (/T1) Try to copy it to the tables
	       RETBAD()		;[9156] Apparently the tables are full
	    ENDIF.		;[9156] End of good rdata count code
	  ELSE.			;[9156] Not a T.A or not a C.IN or not 4 RDATA 
	    ADJBP T3,Q1		;[9156] So then we want to eat the rdata
	    MOVEM T3,Q1		;[9156]  so we won't get confused in our loop
	  ENDIF.		;[9156] We are now at the end of an answer area
	  SOJG Q2,TOP.		;[9156] Loop until looked at all answers
	OD.			;[9156] End of first pass over all answers

;[9156] The second pass loops through the answers to copy all of the nicknames.
;The nickname is added only of the type is "CNAME" and the class is "IN".

DNSPRB:	MOVEM Q3,Q1		;[9156] Reset pointer for second pass scan
	LOAD Q2,HDANC,(PKT)	;[9156] Number of entries in answer section
	DO.			;[9156] Looping through all of answers
	  CALL DNSEXT		;[9156] (Q1,PKT/Q1,T1,T2,T3) Extract name
	  CALL DNS323		;[9156] (Q1/Q1,T3) Get the type and class
	  MOVEM T3,P3		;[9156] Store type and class 
	  CALL DNS323		;[9156] (Q1/Q1,T3) Load the TTL word
	  MOVEM T3,NAMTTL	;[9156] Secrete away that TTL for now
	  CAME P3,[T.CNAME_^D16+CL.IN] ;[9156] Canonical name type, Internet?
	  IFSKP.		;[9156] Great news today, a nickname
	    CALL DNSNAM		;[9156] (/) Yes, add the name to the table
	     RETBAD()		;[9156] Apparently the tables are full
	  ENDIF.		;[9156] Either we added it ok or didn't want to
	  CALL DNS163		;[9156] (Q1/Q1,T3) Get the rdlength in T3
	  ADJBP T3,Q1		;[9156] Eat the rdata all up 
	  MOVEM T3,Q1		;[9156]  since we don't want to look at it 
	  SOJG Q2,TOP.		;[9156] Loop until done with lists
	OD.			;[9156] End of second pass for nicknames

;[9156] The answer section has been scanned and NAMLST and NUMLST have been
;set up.  Convert the TTL from a delta number of seconds to a TODCLK time.

	CALL DNSTTU		;[9156] (/) Fix up DNSTTL for later use

;[9156] There may be other information after the answer section (such as
;authority) but we are going to ignore the rest of the packet.  However, by now
;we should have at least one entry in NUMLST and one in NAMLST.  If not, ADDHOS
;will refuse to add the stuff.

	RETSKP			;[9156] Return success
	SUBTTL DNS Resolver -- Parse DNS Reply -- Parse Answer Type PTR

;[9156] Here when we want to parse PTR records from the answer area.
;Call with
;	PKT/ address of response buffer
;	Q1/ pointer to answer section
;Uses T1-T4, Q1-Q3, P3
;Returns +1 if some problem with the answers, with
;	T1/ error code
;Returns +2 if answer appears ok, with DNSTTL, NAMLST, and NUMLST set up
;	NAMLST/ x number of words to follow this one
;		+index into NAMLST to create a new HOSTN entry 
;			or
;		-index into HOSTN table to reuse a HOSTN entry
;		the first index is for the primary host name
;	NUMLST/	y number of words to follow this one
;		y internet addresses
;	DNSTTL/ lowest value for TTL out of the answer section

;[9156] Answers which are type "PTR" and class "IN" are validated and added to
;NAMLST and NUMLST.

DNSPRP:	LOAD Q2,HDANC,(PKT)	;[9156] Number of entries in answer section
	JUMPE Q2,DNSRER		;[9156] (/T1) Return+1 if no answers there
	DO.			;[9156] Looping through all of them to get 1st
	  CALL DNSEXT		;[9156] (Q1,PKT/Q1,T1,T2,T3) Extract name
	  CALL DNS323		;[9156] (Q1/Q1,T3) Get the type and class
	  MOVE P3,T3		;[9156] Save the type for a little bit
	  CALL DNS323		;[9156] (Q1/Q1,T3) Load the TTL word
	  MOVEM T3,NAMTTL	;[9156] Secrete away that TTL for now
	  CALL DNS163		;[9156] (Q1/Q1,T3) Get the rdlength in T3
	  CAME P3,[T.PTR_^D16+CL.IN] ;[9156] Is it type PTR class IN?
	  IFSKP.		;[9156] Yes, it is a PTR answer todayP
	    CALL DNSPTR		;[9156] (/T1,T3) Parse d.c.b.a.IN-ADDR.ARPA
	     RETBAD()		;[9156] Fish stinks from the head down
	    CALL DNSNUM		;[9156] (T3/T3,T4) Add that number
	     RETBAD()		;[9156] More than tolerable in a single packet
	    CALL DNSEXT		;[9156] (Q1,PKT/Q1,T1,T2,T3) Extract name
	    CALL DNSNAM		;[9156] (/) Try to add that name
	      RETBAD()		;[9156] Apparently the tables are full
	    MOVX T3,HS%INA	;[9156] Load bit meaning b.c.d.a.IN-ADDR.ARPA
	    IORM T3,DNSSTS	;[9156] Include that as a status bit today
	  ENDIF.		;[9156] End of PTR parsing
	  SOJG Q2,TOP.		;[9156] Loop until looked at all answers
	OD.			;[9156] End of first pass over all answers

;[9156] The answer section has been scanned and NAMLST and NUMLST have been
;set up.  Convert the TTL from a delta number of seconds to a TODCLK time.

	CALL DNSTTU		;[9156] (/) Set up DNSTTL
	RETSKP			;[9156] Return good

;[9156] Local routine to parse records associated with PTR types.
;String input is "d.c.b.a.IN-ADDR.ARPA", output is address "a.b.c.d".
;Call with
;	NAMBUF/ string
;Returns +1 if error parsing the string, with
;	T1/ error code
;Returns +2 if parsed OK, with
;	T3/ 32 bit internet address

DNSPTR:	SAVEQ			;[9156] Get some Qs
	MOVEI Q1,NAMBUF		;[9156] Point to temp buffer
	HRLI Q1,(POINT 7)	;[9156] Make a byte pointer out of that
	MOVSI Q2,-4		;[9156] Load number of octets to build
	SETZ T3,		;[9156] Clear place to return address

	DO.			;[9156] Loop to read four octets
	  SETZ T4,		;[9156] Clear where we are building octet
	  DO.			;[9156] Loop to read "d.c.b.a" part
	    ILDB T2,Q1		;[9156] Load next character
	    CAIN T2,"."		;[9156] Is it a dot?
	    EXIT.		;[9156] Yes, get out of this level
	    CAIL T2,"0"		;[9156] Is it a legal
	    CAILE T2,"9"	;[9156]  digit?
	    RETBAD(GTHSX4)	;[9156] "Format error in DNS message"
	    IMULI T4,^D10	;[9156] Move over previous digits
	    ADDI T4,-"0"(T2)	;[9156] Put in the next digit
	    CAIL T4,0		;[9156] Is the number
	    CAILE T4,^D255	;[9156]  still in range for an octet?
	    RETBAD(GTHSX4)	;[9156] "Format error in DNS message"
	    LOOP.		;[9156] Keep going
	  OD.			;[9156] Here when dot seen
	  LSH T4,(Q2)		;[9156] Shift this octet to is proper position
	  IORM T4,T3		;[9156] Place this octet in the result word
	  ADDI Q2,8-1		;[9156] Compute number of bits to shift left
	  AOBJN Q2,TOP.		;[9156] Loop to get another octet
	OD.			;[9156] End of loop to read four octets

	MOVE Q2,[POINT 7,[ASCIZ/IN-ADDR.ARPA/]]	;[9156] The rest of name
	DO.			;[9156] Loop to check rest of name
	  ILDB T2,Q1		;[9156] Load the next byte of suspect string
	  ILDB T4,Q2		;[9156] Load the next byte of the test string
	  CAME T4,T2		;[9156] Was that a match?
	  RETBAD(GTHSX4)	;[9156] "Format error in DNS message"
	  JUMPN T4,TOP.		;[9156] Loop to check all characters in string
	OD.			;[9156] End of loop to check rest of string

	RETSKP			;[9156] Return with T3/ IP address
	SUBTTL DNS Resolver -- Parse DNS Reply -- Parse Answer Type MX

;[9156] Here to parse type MX records.  Answers which are type "MX" and class
;"IN" are returned to the user based on the preference value.  Lower
;preferences are returned first.
;Call with 
;	Q1/ pointer to answer section
;Uses T1-T4, Q1-Q3, P2-P3
;Returns +1 if some problem with the answers, with
;	T1/ error code
;Returns +2 if answer appears ok, with
;	NAMLST/ x number of words to follow this one
;		x number of byte pointers in RSPBUF to MX names 
;	NUMLST/	0
;		y number of preference values (not used by caller)

DNSPMX:	LOAD Q2,HDANC,(PKT)	;[9156] Number of entries in answer section
	JUMPE Q2,DNSRER		;[9156] (/T1) Return+1 if no answers there
	DO.			;[9156] Outer loop 
	  CALL DNSEXT		;[9156] (Q1,PKT/Q1,T1,T2,T3) Extract name
	  CALL DNS323		;[9156] (Q1/Q1,T3) Get the type and class
	  MOVE P3,T3		;[9156] Save the type for a little bit
	  CALL DNS323		;[9156] (Q1/Q1,T3) Load the TTL word
	  MOVEM T3,NAMTTL	;[9156] Secrete away that TTL for now
	  CALL DNS163		;[9156] (Q1/Q1,T3) Get the rdlength in T3
	  CAME P3,[T.MX_^D16+CL.IN] ;[9156] Is it type MX class IN?
	  IFSKP.		;[9156] Yes, it is a type MX class IN RR
	    CAIGE T3,3		;[9156] There must be at least 3 bytes
	    RETBAD(GTHSX4)	;[9156] "Format error in DNS message"
	    MOVE T1,T3		;[9156] Copy the rdlength to T1
	    CALL DNS163		;[9156] (Q1/Q1,T3) Load the preference 
	    AOS T2,NAMLST	;[9156] Get next free one, count this entry
	    CAILE T2,NAMNUM 	;[9156] Running over?
	    CALLRET DNSRER	;[9156] (/T1) Yes, forget about this one
	    MOVEM T3,NUMLST(T2)	;[9156] Store the preference in NUMLST
	    MOVEM Q1,NAMLST(T2)	;[9156] Store that entry in NAMLST
	    MOVEI T3,-2(T1)	;[9156] Load rdlength-2 to skip over name
	  ENDIF.		;[9156] So, it wasn't type MX class IN
	  ADJBP T3,Q1		;[9156] Eat the rdata all up 
	  MOVEM T3,Q1		;[9156]  since we don't want to look at it now
	  SOJG Q2,TOP.		;[9156] Loop until looked at all RRs in answer
	OD.			;[9156] End of outer loop
	SKIPN NAMLST		;[9156] Did we parse any MX RRs?
	CALLRET DNSRER		;[9156] (/T1) Nope, return error code

;[9156] Now we need to bubble sort the MX RRs so that each host is returned in
;increasing order of preference.  This is done with a cheap bubble sort.
	
DNSPMY:	DO. 			;[9156] Outer loop through all extracted MX RRs
	  MOVE Q1,NAMLST	;[9156] Load count of MX RRs
	  SETO T1,		;[9156] Start with prefernece of -1
	  MOVEI Q2,1		;[9156] Load offset of first data word in list
	  DO.			;[9156] Loop to perform bubble sort
 	    CAMG T1,NUMLST(Q2)	;[9156] Is the current entry out of order?
	    IFSKP.		;[9156] It would appear that we need a swap
	      MOVE T3,NUMLST(Q2) ;[9156] Load preference to swap
	      MOVE T4,NAMLST(Q2) ;[9156]  and pointer to name to swap
	      MOVEM T1,NUMLST(Q2) ;[9156] Store the better (lower) preference
	      MOVEM T2,NAMLST(Q2) ;[9156]  and pointer to its name
	      MOVEM T3,NUMLST(Q3) ;[9156] And store the not as good pref
	      MOVEM T4,NAMLST(Q3) ;[9156]  and pointer to name
	      JRST DNSPMY	;[9156] We swapped something, restart sorting
	    ENDIF.		;[9156] List in order so far (or first entry)
	    MOVE T1,NUMLST(Q2)	;[9156] Load the preference of this entry
	    MOVE T2,NAMLST(Q2)	;[9156]  and pointer to name of this entry
	    MOVE Q3,Q2		;[9156] Save offset to sorted list
	    AOS Q2		;[9156] Point to next one to look at
	    SOJG Q1,TOP.	;[9156] Loop for all of the RRs we extracted
	  OD.			;[9156] Fall through 
	OD.			;[9156]  when list is sorted

;[9156] There may be other information after the answer section (such as
;authority and addtional data) but we are going to ignore the rest of the
;packet.

	RETSKP			;[9156] Return success back to user

	SUBTTL DNS Resolver -- Parse DNS Reply -- Parse Specified Answer Type

;[9156] Here to parse type records for the validate name functions.
;Call with 
;	Q1/ pointer to answer section
;	Q2/ address of list of types to match terminated by a zero
;	QCLASS/ class to match
;Uses T1-T4, Q1-Q3, P2-P3
;Returns +1 if some problem with the answers or returning them with
;	T1/ error code
;Returns +2 if answer appears ok
;	T1/ byte pointer to canonical name string
;	T2/ class,,type that matched

DNSPVN:	LOAD Q3,HDANC,(PKT)	;[9156] Number of entries in answer section
	JUMPE Q3,DNSRER		;[9156] (/T1) Return+1 if no answers there
	DO.			;[9156] Outer loop 
	  CALL DNSEXT		;[9156] (Q1,PKT/Q1,T1,T2,T3) Extract name
	  CALL DNS163		;[9156] (Q1/Q1,T3) Get the type
	  MOVEM T3,T2		;[9156] Save type of this RR
	  CALL DNS163		;[9156] (Q1/Q1,T3) Get the class
	  MOVEM T3,T1		;[9156] Save the class of this RR
	  CALL DNS323		;[9156] (Q1/Q1,T3) Load the TTL word
	  CALL DNS163		;[9156] (Q1/Q1,T3) Get the rdlength in T3
	  CAME T1,QCLASS	;[9156] Does the class match?
	  IFSKP.		;[9156] Yes, it is of the proper type and class
	    MOVE T4,Q2		;[9156] Point to list of types to match
	    DO.			;[9156] See if the type matches any in our list
	      SKIPN (T4)	;[9156] Is this the end of the list?
	      EXIT.		;[9156] Yes, get out, this RR didn't match
	      CAME T2,(T4)	;[9156] So, look at the next type in the list
	      AOJA T4,TOP.	;[9156] Nope, keep looking for match
	      HRL T2,T1		;[9156] Make class,,type that matched
	      MOVE T1,[Point 7,NAMBUF] ;[9156] We got a match, point to name
	      RETSKP		;[9156] Return to caller
	    OD.			;[9156] Here if the type didn't match
	  ENDIF.		;[9156] Here if the class didn't match
	  ADJBP T3,Q1		;[9156] Eat the rdata all up 
	  MOVEM T3,Q1		;[9156]  since we don't want to look at it now
	  SOJG Q3,TOP.		;[9156] Loop until looked at all RRs in answer
	OD.			;[9156] End of outer loop
	SUBTTL DNS Resolver -- Parse DNS Reply -- Parse Host Information Type

;[9156] Here to parse host information type records.
;Call with 
;	Q1/ pointer to answer section
;	QCLASS/ class to match on
;Uses T1-T4, Q1-Q3, P2-P3
;Returns +1 if some problem with the answers or returning them with
;	T1/ error code
;Returns +2 if answer appears ok
;	T1/ byte pointer to operating system type string
;	T2/ byte pointer to cpu type string

DNSPHI:	LOAD Q3,HDANC,(PKT)	;[9156] Number of entries in answer section
	JUMPE Q3,DNSRER		;[9156] (/T1) Return+1 if no answers there
	DO.			;[9156] Outer loop 
	  CALL DNSEXT		;[9156] (Q1,PKT/Q1,T1,T2,T3) Extract name
	  CALL DNS163		;[9156] (Q1/Q1,T3) Get the type
	  MOVEM T3,T1		;[9156] Save type of this RR
	  CALL DNS163		;[9156] (Q1/Q1,T3) Get the class
	  MOVEM T3,T2		;[9156] Save the class of this RR
	  CALL DNS323		;[9156] (Q1/Q1,T3) Load the TTL word
	  CALL DNS163		;[9156] (Q1/Q1,T3) Get the rdlength in T3
	  CAMN T2,QCLASS	;[9156] Does the class match?
	  CAIE T1,T.HINFO	;[9156] Does the type match?
	  IFSKP.		;[9156] Yes, it is of the proper type and class
	    MOVE T1,[Point 7,INFBUF] ;[9156] Load pointer to cpu type storage
	    CALL DNSEXS		;[9156] (T1,Q1/T1,Q1) Extract cpu type
	    MOVE T1,[Point 7,NAMBUF] ;[9156] Load pointer to os type storage
	    CALL DNSEXS		;[9156] (Q1,PKT/Q1,T1,T2,T3) Extract os type
	    DMOVE T1,[EXP <Point 7,NAMBUF>,<Point 7,INFBUF>] ;[9156] Load ptrs
	    RETSKP		;[9156] Return to caller with T1 and T2 set up
	  ENDIF.		;[9156] Here if the class didn't match
	  ADJBP T3,Q1		;[9156] Eat the rdata all up 
	  MOVEM T3,Q1		;[9156]  since we don't want to look at it now
	  SOJG Q3,TOP.		;[9156] Loop until looked at all RRs in answer
	OD.			;[9156] End of outer loop
	CALLRET DNSRER		;[9156] (/T1) Return error code to user
	SUBTTL DNS Resolver -- Parse DNS Reply -- Add Host Name

;[9156] DNSNAM Local routine to add the host name for DNS.
;It moves the host name in NAMBUF to the HSTNAM host table.
;It looks in the host table to see if the string already exists first.
;If NAMTTL is less than DNSTTL it updates DNSTTL with NAMTTL.
;Returns +1 if we could not copy it with
;	T1/ error code
;Returns +2 if the host string was moved and added to NAMLST.

DNSNAM:	MOVEI T1,NAMBUF		;[9156] Point to temp buffer place
	HRLI T1,(POINT 7)	;[9156] Make a pointer to it
	CALL HSTLUK		;[9156] (T1/T2,T4) Look for that host name
	IFE. T2			;[9156] If the name was not found
	  XMOVEI T2,NAMBUF	;[9156] Point to temporary buffer area
	  SKIPE T1,NAMBWC	;[9156] Load the length of this string
	  CALL ADDNAM		;[9156] (T1,T2/T1,T2,T3,T4) Move to HSTNAM
	   RETBAD(GTHX10)	;[9156] Apparently the tables are full
	  TLZ T3,-1		;[9156] Remove section number part
	ELSE.			;[9156] The host was found, HOSTN index in T2
	  MOVNI T3,(T2)		;[9156] Make it -ive index to HOSTN
	ENDIF.			;[9156] Now T3/ +HSTNAM index or -HOSTN index

	AOS T2,NAMLST		;[9156] Get next free one, count this entry
	CAILE T2,NAMNUM 	;[9156] Running over?
	RETBAD(GTHSX4)		;[9156] "Format error in DNS message"
	ADDI T2,NAMLST		;[9156] Point into the list
	MOVEM T3,(T2)		;[9156] Store +HSTNAM index or -HOSTN index

	MOVE T2,NAMTTL		;[9156] Load the TTL associated with name
	CAMG T2,DNSTTL		;[9156] Is this TTL less than the others?
	MOVEM T2,DNSTTL		;[9156] Yes, store this one for return

	RETSKP			;[9156] Give success return

;[9156] DNSNUM - Local routine to add a 32 bit address to NUMLST.
;Call with 
;	T3/ IP address
;Returns +1 if some problem
;	T1/ error code
;Returns +2 with it added, with
;	T3/ IP address
;	T4/ address in NUMLST used

DNSNUM:	JUMPE T3,[RETBAD(GTHSX4)] ;[9156] "Format error in DNS message"
	AOS T4,NUMLST		;[9156] Point to next address in list
	CAILE T4,NAMNUM		;[9156] Only allow NAMNUM
	RETBAD(GTHSX4)		;[9156] "Format error in DNS message"
	ADDI T4,NUMLST		;[9156] Only one index register per instruction
	MOVEM T3,(T4)		;[9156] Store the address
	RETSKP			;[9156] Return to caller

;[9156] Local routine to update DNSTTL.  This routine is called after the
;answer section has been scanned and NAMLST and NUMLST have been set up.
;Convert the TTL from a delta number of seconds to a TODCLK time.

DNSTTU:	MOVE T2,DNSTTL		;[9156] Load the shortest TTL in seconds
	IMULI T2,^D1000		;[9156] Convert that to milliseconds from now
	CAMG T2,[5*^D60*^D1000] ;[9156] Result over 5 minutes (halfword)?
	MOVE T2,[5*^D60*^D1000]	;[9156] Nope, make it 5 minutes 
	ADD T2,TODCLK		;[9156] Get a time in the future for the TTL
	SKIPG T2		;[9156] The result must be positive
	MOVX T2,.INFIN		;[9156] Nope, get +infinity now
	MOVEM T2,DNSTTL		;[9156] Save it for adding to host table

;[9156] Since all of this seems to have gone well, return the authority bit if
;it was set in the packet we just used.

	LOAD T3,HDAA,(PKT)	;[9156] Load the returned authority bit
	DPB T3,[POINTR DNSSTS,HS%AUT] ;[9156] Store authority bit in status 

	RET			;[9156] Return success
	SUBTTL DNS Resolver -- Parse DNS Reply -- Return Error Code

;[9156] Here when we want to return an error code based on the AA bit in the
;DNS packet header.  This is done so that the user can tell the difference
;between an "authoritative no" and a "not found" or "timeout" error.

DNSRER:	LOAD T1,HDAA,(PKT)	;[9156] Load the returned authority bit
	SKIPE T1		;[9156] Was this an authoritative answer?
	RETBAD(GTHSX8)		;[9156] Yes, "Data not found in namespace"
	RETBAD(GTHSX7)		;[9156] "Server failed to find data"

	SUBTTL DNS Resolver -- Parse DNS Reply -- Extract Domain Name

;[9156] Here to extract name from packet and store it.
;Call with
;	PKT/ address of packet
;	Q1/ current pointer to packet
;Returns +1 always
;	T1/ word count (0 if nothing copied)
;	T2/ address of data that was returned
;	T3/ character count including the null byte at the end
;	Q1/ updated pointer

DNSEXT:	SETZM NAMBCC		;[9156] Clear count
	SETZM NAMBUF		;[9156] First word of buffer must be zero
	MOVEI T1,NAMBUL-1	;[9156] Load number of words to move
	XMOVEI T2,NAMBUF	;[9156] Load first word to copy
	XMOVEI T3,1+NAMBUF	;[9156] Load second word to copy to
	CALL XBLTA		;[9156] (T1,T2,T3/) Clear that block out
	MOVEI T1,NAMBUF		;[9156] Point to temp buffer place
	HRLI T1,(POINT 7)	;[9156] Make a pointer to it

	CALL DNSEXR		;[9156] (T1/T1) Call recursive routine 

	AOS T1,NAMBCC		;[9156] Load character count, counting null
	CAILE T1,<NAMBUL*5>-1	;[9156] Did the count of data bytes overflow?
	MOVEI T1,<NAMBUL*5>-1	;[9156] Just the count overflew, not the data
	MOVEM T1,T3		;[9156] Return the character count in T3
	ADDI T1,4		;[9156] Round up to next word
	IDIVI T1,5		;[9156] Compute words used
	MOVEM T1,NAMBWC		;[9156] Save that for later
	MOVEI T2,NAMBUF		;[9156] Return the address of that data
	RET			;[9156] Return +1 always

DNSEXR:	SETZ T4,		;[9156] Clear "parts printer" flag
	DO.			;[9156] Loop to look for labels
	  ILDB T3,Q1		;[9156] Get the length of this field
	  JUMPE T3,R		;[9156] Get out if zero
	  TRC T3,300		;[9156] Complement label bits
	  TRCE T3,300		;[9156] See if significant two bits set to one
	  IFSKP.		;[9156] Label was specified
	    TRZ T3,300		;[9156] Clear those bits please
	    ILDB T2,Q1		;[9156] Load low order count
	    LSH T3,8		;[9156] Shift over high order count
	    ADDI T3,(T2)	;[9156] Add in low order octet
	    MOVEI T2,.HDBEG(PKT) ;[9156] Load address of packet's question area
	    HRLI T2,(POINT 8)	;[9156] Make it a pointer
	    PUSH P,Q1		;[9156] Save pointer on stack
	    MOVE Q1,T3		;[9156] Load number of bytes to adjust ahead
	    ADJBP Q1,T2		;[9156] Point to place where text is found
	    CALL DNSEXD		;[9156] (T1,T4/T1) See if we need a dot
	    CALL DNSEXR		;[9156] (T1/T1) Output name at label
	    POP P,Q1		;[9156] Get old pointer back
	    RET			;[9156] Return
	  ENDIF.		;[9156] No label seen yet
	  CALL DNSEXD		;[9156] (T1,T4/T1) See if we need a dot
	  DO.			;[9156] Loop for these characters
	    ILDB T2,Q1		;[9156] Get a data byte
	    CALL DNSEXW		;[9156] (T1,T2,T4/T1) Write character
	    SOJG T3,TOP.	;[9156] Loop for them
	  OD.			;[9156] End of data loop
	  AOJA T4,TOP.		;[9156] Get next data byte, print a dot next
	OD.			;[9156] End of that mess

DNSEXD:	MOVEI T2,"."		;[9156] Maybe we need a dot next
	JUMPE T4,R		;[9156] First time through here, get out now

DNSEXW:	AOS CX,NAMBCC		;[9156] Count character about to be written
	CAIGE CX,NAMBUL*5	;[9156] Out of space in NAMBUF?
	IDPB T2,T1		;[9156] Nope, store the character
	RET			;[9156] Return
	SUBTTL DNS Resolver -- Parse DNS Reply -- Extract Domain Name

;[9156] Routine to extract a string (as opposed to a domain name) from a DNS
;response packet that is being parsed.
;Call with
;	T1/ pointer into destnation
;	Q1/ pointer into packet
;Returns +1 always, string copied
;	T1/ updated pointer
;	Q1/ updated pointer

DNSEXS:	ILDB T3,Q1		;[9156] Get length byte
	MOVE T4,T3		;[9156] Load a copy of the length
	CAILE T4,MAXLC		;[9156] Is the length too big?
	MOVEI T4,MAXLC		;[9156] Yes, load an alternative
	DO.			;[9156] Loop for string
	  ILDB T2,Q1		;[9156] Get a byte
	  SOSL T4		;[9156] Are we going to store a byte?
	  IDPB T2,T1		;[9156] Store a byte
	  SOJG T3,TOP.		;[9156] Loop for all of it
	OD.			;[9156] End of loop
	IDPB T3,T1		;[9156] Store a 0 at end of the string
	RET			;[9156] Return
	SUBTTL DNS Resolver -- Parse DNS Reply -- Extract Integers

;[9156] DNS323 Fast local routine to grab 32 bits and cram into T3.
;Caution: This routine must preserve all ACs except CX, T3, Q1.
;Call with 
;	Q1/ pointer
;Returns +1 always with
;	Q1/ updated pointer
;	T3/ 4 octets (32 bits) from the message

DNS323:	ILDB T3,Q1		;[9156] Load first byte
	LSH T3,8		;[9156] Shift over
	ILDB CX,Q1		;[9156] Load second byte
	TRO T3,(CX)		;[9156] Combine first and second
	LSH T3,8		;[9156] Shift over for third byte
	ILDB CX,Q1		;[9156] Load third byte
	TRO T3,(CX)		;[9156] Combine first, second, third bytes
	LSH T3,8		;[9156] Shift over first three bytes
	ILDB CX,Q1		;[9156] Load last byte
	TRO T3,(CX)		;[9156] Combine the four bytes
	RET			;[9156]  and return

;[9156] DNS163 Fast local routine to grab two octets from Q1.
;Caution: This routine must preserve all ACs except CX, T3, Q1.
;Call with 
;	Q1/ pointer
;Returns +1 always with
;	Q1/ updated pointer
;	T3/ 2 octets (16 bits) from the message
;Returns +1 always

DNS163:	ILDB T3,Q1		;[9156] Load a byte
	LSH T3,8		;[9156] Shift over
	ILDB CX,Q1		;[9156] Load next char
	TRO T3,(CX)		;[9156] And in the bits
	RET			;[9156] Return

	DNSEND			;[9156] Remove DNS symbols
	SUBTTL ATNVT% JSYS - Attach connection to NVT

; ATtach connection to NVT
; Call:	1	; [Receive] jfn of opened network connection (JCN for TCP)
;	2	; Send jfn of open network connection (NCP only)
;	ATNVT
; Returns
;	+1	; Cannot attach
;	+2	; Ok.  the jfn is released, ac 1 has line number of
;		; Attached pty.

XNENT (.ATNVT,G)		;.ATNVT::
	MCENT
	TXNE T1,AN%TCP		; Attach TCP Virtual Terminal?
         JRST TATNVT		; Yes, go to TCP code
	XJRST [MSEC1,,TVTJFN]	; we were given a JFN
	SUBTTL NETRDY GETAB Table

; GNTRDY
; Get  the  NETRDY  table. Attempts to find the data from the NCT for
; the primary network

XNENT (GNTRDY,G)		;GNTRDY::
	MOVE T1,DEFADR		; get primary address
	CALL NETNCT		; Find an NCT for it
	 RETERR()		; Error
	MOVE T1,@GNTAB(T2)	; get an entry
	RET			; And return

; Indirect table for deriving the data

GNTAB:	IFIW!<P1>B17+NTRDY	; NETRDY From the NCT
	IFIW!<P1>B17+NETON	; As NETON
	IFIW+NETENT		; NETENT has its own cell
	IFIW!<P1>B17+NTIUPT	; NCPUPT
	IFIW+IGDMSG		; Last Imp going down message
	IFIW!<P1>B17+NTXDNT	; Last ready line drop
	IFIW!<P1>B17+NTXUPP	; last ready line up time
	IFIW+IGDTIM		; Last Imp going down message time

	SUBTTL End of MNETDV

	TNXEND
	END




