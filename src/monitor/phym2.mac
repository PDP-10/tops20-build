; UPD ID= 8587, RIP:<7.MONITOR>PHYM2.MAC.6,  11-Feb-88 16:55:31 by GSCOTT
;TCO 7.1218 - Update copyright date.
; UPD ID= 8434, RIP:<7.MONITOR>PHYM2.MAC.5,   4-Feb-88 15:02:06 by GSCOTT
;TCO 7.1210 - Set TM2CCI, TM2HER, TM2N2S, and TM2NUD normally not dumpable.
; UPD ID= 318, RIP:<7.MONITOR>PHYM2.MAC.4,   8-Dec-87 11:24:13 by GSCOTT
;TCO 7.1075 - Add TOC.
; *** Edit 7457 to PHYM2.MAC by GSCOTT on 23-Apr-87, for SPR #21597
; Make SET ONLINE command work for drives connected to TM02/TM03/TM78 
; UPD ID= 2158, SNARK:<6.1.MONITOR>PHYM2.MAC.10,   5-Jun-85 10:41:14 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 1921, SNARK:<6.1.MONITOR>PHYM2.MAC.9,   7-May-85 21:14:49 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1793, SNARK:<6.1.MONITOR>PHYM2.MAC.8,  23-Apr-85 13:14:23 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1744, SNARK:<6.1.MONITOR>PHYM2.MAC.7,   9-Apr-85 15:09:12 by MCCOLLUM
;TCO 6.1.1238 - Fix BUG. documentation
; UPD ID= 4823, SNARK:<6.MONITOR>PHYM2.MAC.6,  17-Sep-84 10:43:05 by PURRETTA
;Update copyright notice
; UPD ID= 3108, SNARK:<6.MONITOR>PHYM2.MAC.5,   7-Nov-83 21:22:55 by MCLEAN
;ADD DISPATCH FOR PORT RELEASE
; UPD ID= 2580, SNARK:<6.MONITOR>PHYM2.MAC.4,  14-Jun-83 10:19:34 by HAUDEL
;TCO 6.1668 - Add SAVEQ at TM2SIO:
; UPD ID= 1606, SNARK:<6.MONITOR>PHYM2.MAC.3,  29-Dec-82 13:48:23 by DONAHUE
;TCO 6.1410 - Change references to MTINDX to STKVAR's
; UPD ID= 903, SNARK:<6.MONITOR>PHYM2.MAC.2,   9-Jun-82 23:25:18 by MURPHY
;TCO 6.1147 - Move bugdefs from BUGS.MAC to here and put them in-line.
; UPD ID= 198, SNARK:<5.MONITOR>PHYM2.MAC.9,  18-Sep-81 11:53:01 by WACHS
;TCO 5.1516 Retry on fake format errors
; UPD ID= 2209, SNARK:<5.MONITOR>PHYM2.MAC.8,  17-Jun-81 20:36:24 by ZIMA
;TCO 5.1372 - fix up error retry count for retry succeeded case.
; UPD ID= 1900, SNARK:<5.MONITOR>PHYM2.MAC.7,  29-Apr-81 07:58:30 by WACHS
; UPD ID= 1859, SNARK:<5.MONITOR>PHYM2.MAC.6,  21-Apr-81 13:50:43 by SCHMITT
;TCO 5.1292 - Reset overdue timer before starting I/O
; UPD ID= 1821, SNARK:<5.MONITOR>PHYM2.MAC.5,  17-Apr-81 09:50:09 by WACHS
;TCO 5.1288 Maintain statistics by recording mode
; UPD ID= 739, SNARK:<5.MONITOR>PHYM2.MAC.4,   7-Jul-80 00:47:37 by DBELL
;TCO 5.1096 - ADD UDSCCK DISPATCH ENTRY
; UPD ID= 504, SNARK:<4.1.MONITOR>PHYM2.MAC.22,   1-May-80 17:40:18 by DBELL
;TCO 4.1.1154 - FIX ANOTHER CAUSE FOR TM2CCI ERRORS FROM TU77 TAPES
; UPD ID= 363, SNARK:<4.1.MONITOR>PHYM2.MAC.21,  26-Mar-80 11:07:07 by DBELL
;TCO 4.1.1119 - MAKE CHANGES REQUIRED FOR RP20 DISKS
;TCO 4.1.1114 - PREVENT TM2CCI AND PH2RAE ERRORS FOR TU77 TAPES
;<4.MONITOR>PHYM2.MAC.20, 20-Sep-79 15:31:29, EDIT BY DBELL
;TCO 4.2476 - ADD DISPATCH FOR UNIT EXISTANCE CHECK
;<4.MONITOR>PHYM2.MAC.19, 13-Sep-79 15:29:49, EDIT BY DBELL
;TCO 4.2465 - MAKE ANSI ASCII MODE ILLEGAL FOR TMO3 CONTROLLER
;<OSMAN.MON>PHYM2.MAC.1, 10-Sep-79 16:00:08, EDIT BY OSMAN
;TCO 4.2412 - Move definition of BUGHLTs, BUGCHKs, and BUGINFs to BUGS.MAC
;<4.MONITOR>PHYM2.MAC.16,  5-Jun-79 17:51:26, EDIT BY BOSACK
;CHANGES FOR PRODUCTION TU77S
;<4.MONITOR>PHYM2.MAC.15,  5-Mar-79 15:51:14, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<2BOSACK>PHYM2.MAC.5, 19-Feb-79 23:56:56, EDIT BY BOSACK
;<2BOSACK>PHYM2.MAC.4, 19-Feb-79 21:18:56, EDIT BY BOSACK
;ADD LOGIC TO DETERMINE ACTUAL DENSITY SELECTED BY TM03
;<2BOSACK>PHYM2.MAC.3, 14-Feb-79 11:04:26, EDIT BY BOSACK
;RECOGNIZE TU77 AS A SPECIFIC DEVICE TYPE, CORRECT CHARS FOR TM03
;<4.MONITOR>PHYM2.MAC.12,  1-Feb-79 23:22:17, Edit by MCLEAN
;<4.MONITOR>PHYM2.MAC.11, 31-Jan-79 01:04:15, Edit by MCLEAN
;FIX PREVIOUS EDIT TO GET CORRECT ADDRESS FOR KDB ENTRY
;<4.MONITOR>PHYM2.MAC.10, 21-Jan-79 17:54:05, Edit by MCLEAN
;ADD SUPPORT FOR .DGPDL
;<4.MONITOR>PHYM2.MAC.9, 30-Aug-78 09:37:50, EDIT BY FORTMILLER
;TOC 4.1998 Set US.REW at Attention Interrupt time instead of
; at Start I/O time
;<4.MONITOR>PHYM2.MAC.8, 23-Aug-78 13:47:52, Edit by MCLEAN
;<4.MONITOR>PHYM2.MAC.7, 21-Aug-78 23:03:04, Edit by MCLEAN
;FIX IT SO REWIND DONE DOES PSI INTERRUPT
;<2MCLEAN>PHYM2.MAC.5, 30-Jul-78 14:55:08, Edit by MCLEAN
;<3A.MONITOR>PHYM2.MAC.18, 30-Jul-78 17:36:11, Edit by MCLEAN
;<4.MONITOR>PHYM2.MAC.4, 28-Jul-78 10:06:53, EDIT BY MILLER
;IFX UP FRAME COUNT ON WRITE
;<4.MONITOR>PHYM2.MAC.3, 26-Jul-78 00:22:24, Edit by MCLEAN
;DECOMMIT US.IDB
;<4.MONITOR>PHYM2.MAC.2, 22-Jul-78 14:05:44, Edit by MCLEAN
;ADD READ/WRITE COUNT TO UDB
;<3A.MONITOR>PHYM2.MAC.17, 14-Jul-78 13:44:18, EDIT BY BOSACK
;DONT IGNORE PRE/POSTAMBLE ERRORS ON PE READ
;<3A.MONITOR>PHYM2.MAC.16,  2-Jun-78 14:58:35, EDIT BY BOSACK
;ENSURE TM2POL ALWAYS LEAVES TM02/3 WITH ERRORS RESET
;<3A-NEW>PHYM2.MAC.15, 31-May-78 09:50:11, Edit by FORTMILLER
;<3A-NEW>PHYM2.MAC.14, 25-May-78 22:20:46, Edit by FORTMILLER
;ADD DX20 SUPPORT
;PUT DENSITYS DRIVE IS CAPABLE OF IN UDBCHR
;CONVERT UDBDSN TO DECIMAL SERIAL NUMBER
;<3A.MONITOR>PHYM2.MAC.13, 18-May-78 13:12:37, EDIT BY BOSACK
;CLEAR ERROR BYTE POINTER AT TERMINATION OF ERROR RECOVERY
;<3A.MONITOR>PHYM2.MAC.12, 29-Mar-78 12:11:03, Edit by MCLEAN
;FIX MTINDX TO POINT TO FREE MTCUTB
;<3A.MONITOR>PHYM2.MAC.11, 29-Mar-78 08:19:07, EDIT BY MILLER
;ADD UNIT,KONTROLLER,CHANNEL INFO TO ALL "HARDWARE" BUG TYPEOUTS
;<3A.MONITOR>PHYM2.MAC.10,  9-Mar-78 00:00:34, Edit by MCLEAN
;<3A.MONITOR>PHYM2.MAC.9,  8-Mar-78 23:56:40, Edit by MCLEAN
;MOVE INIUNI CALL SO IT DOESN'T BREAK MULTIPLE UNITS
;AND ISN'T CALLED AS OFTEN
;<2BOSACK>PHYM2.MAC.53, 24-Feb-78 01:49:19, EDIT BY BOSACK
;<2BOSACK>PHYM2.MAC.52, 24-Feb-78 01:36:56, EDIT BY BOSACK
;REWORK ERROR INTERFACE WRT DATA/DEVICE ERRORS
;<4.MONITOR>PHYM2.MAC.7,  1-Feb-78 14:51:28, Edit by MCLEAN
;FIX FOR NEW PHYALC,PHYUDB CALLING SEQ
;<4.MONITOR>PHYM2.MAC.6, 31-Jan-78 00:16:42, Edit by MCLEAN
;<4.MONITOR>PHYM2.MAC.5, 30-Jan-78 21:31:17, Edit by MCLEAN
;ADD CREATION OF UDB FOR UNIT GOING ON LINE

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


	SEARCH PROLOG,PHYPAR,SERCOD ;SYSTEM PARAMETERS
	TTITLE (PHYM2,,< - Device Dependent Code for TM02/TM03/TU45/TU77>)

	SUBTTL P.KINZELMAN 25 JULY 75
	TM2VER==63		;EDIT VERSION

		ENTRY TM2DSP	;FOR LIBRARY SEARCH
	Subttl	Table of Contents

;		     Table of Contents for PHYM2
;
;				  Section		      Page
;
;
;    1. Parameters . . . . . . . . . . . . . . . . . . . . . .   3
;    2. Device Dependant Table Defs  . . . . . . . . . . . . .   5
;    3. TM02 Error Recovery Defs . . . . . . . . . . . . . . .   6
;    4. Dispatch For TM02  . . . . . . . . . . . . . . . . . .   7
;    5. TM02 Initializing Routine  . . . . . . . . . . . . . .   9
;    6. Start I/O Routine  . . . . . . . . . . . . . . . . . .  12
;    7. RH20 Command Done Interrupt  . . . . . . . . . . . . .  15
;    8. Error Retry Entry Point  . . . . . . . . . . . . . . .  25
;    9. Routine To Poll Slaves To See If Done Rewind . . . . .  30
;   10. TM02 Function Table  . . . . . . . . . . . . . . . . .  33
;   11. End of PHYM2 . . . . . . . . . . . . . . . . . . . . .  36
	SUBTTL Parameters

;DRIVE REGISTERS USED IN DATAO'S

	DO.CS1==0B5		;DRIVE CONTROL REGISTER
	DO.DS==1B5		;STATUS REGISTER
	DO.ER==2B5		;ERROR REGISTER
	DO.MR==3B5		;MAINTENANCE REGISTER
	DO.AS==4B5		;ATTENTION SUMMARY
	DO.FC==5B5		;FRAME COUNTER
	DO.DT==6B5		;DRIVE TYPE
	DO.CK==7B5		;CHECK CHARACTER REGISTER
	DO.SN==10B5		;SERIAL NUMBER
	DO.TC==11B5		;TAPE CONTROL REGISTER

;DRIVE FUNCTIONS LOADED INTO DRIVE CONTROL REGISTER

	DF.NOP==1		;NO-OP
	DF.UNL==3		;UNLOAD (REWIND OFF-LINE)
	DF.REW==7		;REWIND
	DF.CLR==11		;DRIVE CLEAR
	DF.RIPS==21		;READ-IN, PRESET
	DF.ERA==25		;ERASE
	DF.WTM==27		;WRITE TAPE MARK
	DF.SPF==31		;SPACE FORWARD
	DF.SPR==33		;SPACE REVERSE
	DF.WCF==51		;WRITE CHECK FORWARD (READ FWD)
	DF.WCR==57		;WRITE CHECK REVERSE (READ REV)
	DF.WTF==61		;WRITE FORWARD
	DF.RDF==71		;READ FORWARD
	DF.RDR==77		;READ REVERSE


	DXES==200000		;DISABLE XFER ON ERROR STOP BIT

;DRIVE STATUS REGISTER

	DS.ATA==1B20		;ATTENTION
	DS.ERR==1B21		;COMPOSITE ERROR
	DS.PIP==1B22		;POSITIONING IN PROGRESS
	DS.MOL==1B23		;MEDIUM ON LINE
	DS.WRL==1B24		;WRITE LOCKED
	DS.EOT==1B25		;END OF TAPE
				;SPARE
	DS.DPR==1B27		;DRIVE PRESENT
	DS.DRY==1B28		;DRIVE READY (NOT GO)
	DS.SSC==1B29		;SLAVE STATUS CHANGE
	DS.PES==1B30		;PHASE ENCODED STATUS
	DS.SDN==1B31		;SHUTDOWN BIT
	DS.IDB==1B32		;IDENT BURST (FOR PE)
	DS.TM==1B33		;TAPE MARK
	DS.BOT==1B34		;BEGINNING OF TAPE
	DS.SLA==1B35		;SLAVE ATTENTION


;DRIVE ERROR REGISTER

	ER.COR==1B20		;CORRECTABLE DATA/ CRC ERROR
	ER.UNS==1B21		;UNSAFE
	ER.OPI==1B22		;OPERATION INCOMPLETE
	ER.DTE==1B23		;DRIVE TIMING ERROR
	ER.NEF==1B24		;NON-EXISTANT FUNCTION
	ER.CS==1B25		;CORRECTABLE SKEW/ ILLEGAL TAPE MARK
	ER.FCE==1B26		;FRAME COUNT ERROR
	ER.NSG==1B27		;NON-STANDARD GAP (CRAP IN THE GAP)
	ER.LRC==1B28		;LRC ERROR/ FORMAT (PREAMBLE POSTAMBLE) ERROR
	ER.INC==1B29		;INCORRECTABLE DATA/ VERTICAL PARITY ERROR
	ER.DPA==1B30		;DATA BUS PARITY ERROR
	ER.FMT==1B31		;FORMAT ERROR
	ER.CPA==1B32		;CBUS PARITY ERROR
	ER.RMR==1B33		;REGISTER MODIFICATION REFUSED
	ER.ILR==1B34		;ILLEGAL REGISTER ADDRESS
	ER.ILF==1B35		;ILLEGAL FUNCTION

;DRIVE TYPE BITS NEEDED:

	DT.SPR==1B25		;A SLAVE IS SELECTED
	SUBTTL Device Dependant Table Defs

	TM2SLC==4		;[7457] Maximum number of slaves on TM02/03

;****************************
;UDB EXTENSIONS

	TU6HDN==UDBDDM		;HARDWARE DETERMINED DENSITY
				;NOTE: DONT CHANGE WITHOUT FIXING MAGTAP
	TU6EPS==TU6HDN+1	;ERROR POSITION
	TU6EBP==TU6EPS+1	;ERROR BYTE POINTER
	TU6EBC==TU6EBP+1	;ERROR BYTE COUNTER
	TU6ECL==TU6EBC+1	;TAPE CLEANER FLAG

	LU.TM2==TU6ECL+1	;LENGTH OF TM02 UDB


;****************************
;KDB DEVICE DEPENDANT PORTION

	KDBUDB==KDBDDP		;[7457] UDB table (for TM2SLC units)
	TM2ADR==KDBUDB+TM2SLC	;[7457] Massbus address of TM02
	TM.CNI==TM2ADR+1	;CONI OF RH GOES HERE
	TM.CS1==TM.CNI+1	;DATAI RH CONTROL REGISTER
	TM.DBF==TM.CS1+1	;DATAI RH DATA REGISTER

	TM2REG==TM.DBF+1	;DRIVE REGISTERS GO HERE

	DR.CS1==0		;DRIVE CONTROL REGISTER
	DR.DS==1		;STATUS REGISTER
	DR.ER==2		;ERROR REGISTER
	DR.MR==3		;MAINTENANCE REGISTER
	DR.AS==4		;ATTENTION SUMMARY
	DR.FC==5		;FRAME COUNTER
	DR.DT==6		;DRIVE TYPE
	DR.CK==7		;CHECK CHARACTER REGISTER
	DR.SN==10		;SERIAL NUMBER
	DR.TC==11		;TAPE CONTROL REGISTER

	LK.TM2==TM2REG+12	;LENGTH OF KDB
	SUBTTL TM02 Error Recovery Defs

;PRESENTLY, IF YOU BACKSPACE INTO BOT, YOU MUST WAIT 8 SEC
;TO REGAIN CONTROL OF THE DRIVE AGAIN (OPI TIMEOUT) BY GETTING AN INT.
;THE DRIVES WILL HOPEFULLY BE FIXED SOMEDAY. UNTIL THEN,
;THIS HANDLER TRIES VERY HARD TO KEEP FROM HITTING BOT
;ON A TAPE CLEAN SEQUENCE IF OPIFIX = 0. MAKE OPIFIX NOT 0
;WHEN THE DRIVES ARE FIXED TO GIVE AN INTERRUPT AS SOON AS THEY
;HIT BOT. (TAPE WILL CLEAN BETTER IF YOU LET THE DRIVE HIT
;BOT.)
	OPIFIX==0

;RETRY COUNTS:
	CLNREC==5		;SP REVERSE THIS NR RECORDS TO HIT CLEANER
	RTYOP==5		;RETRY OPERATION THIS MANY TIMES BEFORE TAPE CLEAN SEQUENCE
	RTYCLN==5		;RETRY CLEAN SEQUENCE THIS MANY TIMES ON READ
				;BEFORE GIVING UP
				;THE TOTAL NR OF RD RETRIES = RTYOP*(RTYCLN+1)

	RTYWRT==^D20		;# WRITE RETRIES MAXIMUM BEFORE ABORT


;ERROR WORDS

;	TU6EBC		;ERR BYTE COUNTER (USED IF WE HIT BOT
				;DURING TAPE CLEAN SEQUENCE)
;	TU6EBP	;ERR BYTE POINTER
;	TU6ECL	;-1= IN TAPE CLN SEQUENCE, 0= NOT
;	UDBERR(RH)		;CURRENT FUNCTION (1 - 17)
				;ON RETRY OF ORIGINAL OPERATION, THIS LOC
				;MUST BE SET TO THE ORIGINAL OPERATION

;	UDBERC ;RETRY COUNT
				;CONVERTED TO # RETRIES DONE AT END
;	TU6EPS	;WE SHOULD BE HERE WHEN WE'RE
				;READY TO RETRY OPERATION
	SUBTTL Dispatch For TM02

TM2DSP::JRST TM2INI		;0 - INITIALIZATION
	JRST TM2SIO		;1 - START I/O
	JRST TM2INT		;2 - HANDLE INTERRUPT (DATA OPERATION OR SPACE)
	JRST TM2ERR		;3 - ERROR RECOVERY
	JRST TM2HNG		;4 - HUNG DEVICE
	RET			;5 - NOT USED
	RET			;6 - NOT USED
	JRST TM2SIO		;7 - START POSITION OPERATION
	JRST TM2ATN		;10 - ATTENTION INTERRUPT (CALLED AS MANY
				;TIMES AS THERE ARE TM02 DRAS BITS UP)
	JRST TM2PRQ		;11 - SKIP IF POSITION REQUIRED
	RET			;12 - STACK SECOND COMMAND, FAIL FOR TM02/3
	JRST TM2LGL		;[7457] 13 - Check legality of a unit
	RET			;14 - CHECK FOR HALTED CONTROLLER
	RET			;15 - RELEASE PORT

;[7457] TM2LGL - Check legality of a unit
;[7457] Called with:
;[7457] 	Q2/ unit number
;[7457] Returns: RFALSE if unit out of range
;[7457]          to EXTUDB if unit not out of range

TM2LGL:	CAILE Q2,3		;[7457] Only 4 units are legal on TM02/TM03
	JRST RFALSE		;[7457] Return badly if out of range
	CALLRET EXTUDB		;[7457] Let PHYSIO do the rest of the work

;[7457] TM2HNG - Set bits when a drive is hung
;[7457] Called with:
;[7457] 	P4/ pointing to IORB

TM2HNG:	MOVX T1,IS.NRT!IS.ERR!IS.DVE ;SET FATAL BITS
	IORM T1,IRBSTS(P4)	;AND REFRESH IT
	RET

;HERE TO DETERMINE IF THIS REQUEST SHOULD GO ON PWQ OR TWQ

TM2PRQ:	LDB T1,IRYFCN		;GET FUNCTION
	MOVE T1,TM2FTB(T1)	;GET TABLE ENTRY
	TXNN T1,TB.DOP		;DATA OPERATION?
	RETSKP			;NO - POSITION ALWAYS REQUIRED
	HRRZ T2,UDBPWQ(P3)	;YES - ANY PENDING POSITION OPERATIONS?
	JUMPE T2,R		;NONE - APPEND TO TWQ
	CAIN T2,(P4)		;AT HEAD OF PWQ?
	RET			;YES - NEXT TRANSFER
	RETSKP			;APPEND TO PWQ


;ROUTINE TO READ ALL TM02 REGISTERS INTO TM2REG IN THE KDB
TM2RDR:	MOVSI T4,-LK.TM2+TM2REG	;-# REGISTERS
TM2RD1:	SETZM T2		;CLEAR REGISTER ADDRESS
	DPB T4, [POINT 6,T2,5]	;SETUP REGISTER ADDRESS
	CALL RDREG		;READ THE REGISTER
	ADD T4,P2		;POINT TO KDB
	MOVEM T1,TM2REG(T4)	;STORE IT IN THE KDB
	SUB T4,P2		;BACK TO RELATIVE POINTER
	AOBJN T4,TM2RD1		;GO BACK FOR REST OF REGISTERS
	CALL ERRCNI		;GET CONI AND DATAI
	MOVEM T1,TM.CNI(P2)	;SAVE IN KDB
	MOVEM T2,TM.CS1(P2)	; ...
	MOVEM T3,TM.DBF(P2)	; ...
	RET
	SUBTTL TM02 Initializing Routine

;THIS ROUTINE IS CALLED ONCE PER TM02 DRIVE ON THE SYSTEM
;TO SET UP UDB'S - 1 PER DRIVE ON THE TM02
;  P1/	CDB
;  Q2/	TM02 UNIT NUMBER
;  Q3/	ADDRESS TO STORE KDB
;  P5/	UNIT NUMBER TO INITIALIZE, OR -1 FOR ALL UNITS
; OUTPUT P2,P3



TM2INI:	SAVEQ			;SAVE REGISTERS
	JUMPL P5,TM2ALU		;SKIP ON IF WE INIT ALL UNITS
	MOVE P2,CDBIUN(P1)	;GET KDB ADDRESS
	ADD P2,Q2		;POINT TO CORRECT UNIT
	MOVE P2,0(P2)		;GET ENTRY
	SKIPE P3,P2		;FOUND ONE?
	JRST TM2USU		;YES DON'T CREATE A NEW ONE
TM2ALU:	MOVX T1,LK.TM2		;LENGTH OF KDB
	CALL PHYALC		;RESERVE SPACE
	RET			;RETURN IF NO SPACE FOUND
	MOVEM T1,P2		;SAVE ADDRESS IN PROPER AC
	MOVE P3,T1		;COPY KDB
	MOVEI T1,.BTKDB		;MARK AS KDB
	DPB T1,USYBKT		; ...
	MOVX T2,DO.DT		;GET DRIVE TYPE REG
	CALL RDREG3		; ...
	ANDI T1,777		;GET JUST TYPE CODE
	CAIG T1,TY.T2H		;IS THIS A TM02?
	CAIGE T1,TY.T2L		; ???
	SKIPA T1,[EXP .UTTM3]	;NO - IS TM03
	MOVX T1,.UTTM2		;YES - SET UP UNIT TYPE IN KDB
	STOR T1,USTYP,(P2)	;...
UNINI:	MOVSI T1,-TM2SLC	;[7457] Set up AOBJN index to slaves
	HRRI T1,KDBUDB(P2)	;MAKE RH POINT TO UDB ENTRIES IN KDB
	MOVEM T1,KDBIUN(P2)	;INITIAL POINTER
	MOVEM T1,KDBCUN(P2)	;CURRENT POINTER
	HRRZM Q2,TM2ADR(P2)	;SAVE KDB ADDRESS
	MOVEI T1,TM2DSP		;INSERT DISPATCH VECTOR
	MOVEM T1,KDBDSP(P2)	; ...
TM2USU:	SKIPGE Q1,P5		;[7457] Skip loading Q1 if doing a single unit
	MOVSI Q1,-TM2SLC	;[7457] Load AOB pointer for all units
INILP:	CALL INIUNI		;INITIALIZE A SINGLE UNIT
	 JFCL			;IGNORE ERROR RETURN
NODRV:	AOBJN Q1,INILP		;TRY NEXT SLAVE
TOORET:	MOVE T1,P2		;TELL RETURN TO PUT KDB INTO CDB
	RET

;THIS ROUTINE IS CALLED TO INITIALIZE A SPECIFIC SLAVE
;INPUT C(P1)=CDB  C(Q1)=UNIT C(P2)KDB  NR; OUTPUT P3


INIUNI:	STKVAR <MTINDX>		;INDEX TO MTCUTB
	HRRZ T2,Q1		;GET CURRENT SLAVE #
	HRLI T2,(DO.TC)		;SET UP FOR TAPE CNTL REGISTER
	CALL WTREG3		;DO IT
	MOVX T2,DO.DT		;GET DRIVE TYPE
	CALL RDREG3
	TXNN T1,DT.SPR		;DOES IT EXIST?
	RET			;NOPE
	HRLOI T3,-MTAN-1	;IF 1ST TIME THRU
INIUN1:	AOBJP T3, [BUG.(INF,TM2N2S,PHYM2,HARD,<PHYM2 - More drives than table space, excess ignored>,,<

Cause:	The number of tape drives on the system exceeds the value of MTAN.
	All drives after MTAN will be ignored.

Action:	To accommodate more tape drives, the monitor must be rebuilt with a
	larger value of MTAN.
>,,<DB%NND>)			;[7.1210] 
		JRST TOORET]	;DON'T INITIALIZE ANY MORE SLAVES
	SKIPE MTCUTB(T3)	;CHECK TO SEE IF UNIT FREE
	JRST INIUN1		;NOPE TRY NEXT ONE
	MOVEM T3,MTINDX		;SAVE CURRENT LOGICAL INDEX
	MOVE T3,[TM2DSP,,LU.TM2] ;YES, SET UP ADDRESS,,LENGTH
	ADD P2,Q1		;POINT TO PROPER KDB ENTRY
	CALL PHYUDB		;AND ASK FOR UDB ALLOCATION
	RET			;RETURN IF NO SPACE FOUND

	HRRZM P3,KDBUDB(P2)	;SAVE LINK
	SUB P2,Q1		;FUDGE IT BACK
	HRRZM P2,UDBKDB(P3)	;SAVE BKWDS LINK
	MOVE T3,MTINDX		;GET CURRENT LOGICAL INDEX
	HRLZM P1,MTCUTB(T3)	;SAVE LINK TO CDB IN LOGICAL TABLE
	HRRM P3,MTCUTB(T3)	;SAVE LINK TO UDB
	MOVX T2,DO.DS		;GET DRIVE STATUS
	CALL RDREG3
	MOVX T3,US.TAP		;INDICATE A TAPE TYPE DEVICE
	TXNN T1,DS.MOL		;ON LINE?
	TXO T3,US.OFS		;NO, SET OFF LINE BIT
	TXNE T1,DS.WRL		;WRITE LOCKED?
	TXO T3,US.WLK		;YES
	HLLM T3,UDBSTS(P3)	;SAVE UDB STATUS
	SETOM TU6HDN(P3)	;INDICATE UNKNOWN DENSITY
	MOVX T2,DO.DT		;GET DEVICE TYPE AGAIN
	CALL RDREG3		; ...
	ANDI T1,737		;MASK (40 BIT IS ON FOR TM03)
	CAIN T1,TY.T77		;A TU77?
	SKIPA T3,[EXP .UTT77]	;YES, SET CORRECT TYPE
	MOVX T3,.UTT45		;NO - TU45 UNIT TYPE
	STOR T3,USTYP,(P3)	;SAVE IT
	MOVX T3,UC.200!UC.556!UC.800!UC.160!UC.CD!UC.AA!UC.IC ;DENSITYS AND MODES DRIVE IS CAPABLE OF
	LOAD T2,USTYP,(P2)	;GET CONTROLLER TYPE
	CAIE T2,.UTTM2		;A TM02?
	TXZ T3,UC.200!UC.556!UC.AA ;NO - ASSUME NO 200, 556 OR ANSI ASCII
	MOVEM T3,UDBCHR(P3)	; AND PUT THAT INFO INTO THE UDB
	MOVX T2,DO.SN		;NOW SERIAL NR
	CALL RDREG
	CALL PHCVBO		;CONVERT BCD TO OCTAL
	MOVEM T1,UDBDSN(P3)	;STORE IT
	HRRZM Q1,UDBSLV(P3)	;SET UP SLAVE ADDRESS
	AOS JB0FLG		;THIS WILL REQUEST JOB0 INCASE CALLER SETS MTAJB0
	RETSKP			;RETURN
	SUBTTL Start I/O Routine

;C(P4)=IORB C(P1)=CDB C(P2)=KDB C(P3)=UDB
;IF IN ERR RECOVERY, GET FN FROM RH(UDBERR)
;RET MEANS RE-CALL IN 1 MIN TO TRY AGAIN
;PUTS TM02 FN IN Q1, AND DATAO (IF NEEDED) IN T2
;RETSKP (CHSTRT) MEANS OK, IT'S STARTED

TM2SIO:	SAVEQ
	HRRZ Q1,UDBERR(P3)	;GET FUNCTION IF ERROR RECOVERY
	SKIPN Q1		;IN ERROR RECOVERY?
	LOAD Q1,ISFCN,(P4)	;NO, GET FN FROM IORB
	SKIPG Q1,TM2FTB(Q1)	;VALID FN?
	JRST BADSIO		;REFUSE TO START IT

	SKIPGE IRBSTS(P4)	;MAKE SURE PAGEM NOT SET
	JRST BADSIO		;IS SET REFUSE IT
	CALL TM2CON		;CONNECT TO DRIVE (AND CLEAR ERRORS)
	 RET			;ERROR
	MOVX T2,DO.FC		;IN CASE WE DON'T WANT TO LOAD FC
	TXNE Q1,TB.NFC		;DO WE LOAD FC WITH SOMETHING SPECIAL?
	JRST NOFC		;NO- LOAD 0
	TXNN Q1,TB.DOP		;DATA OPERATION?
	JRST TM2NDO		;NO, T2=-#RECORDS ON SPACE
	MOVN T2,IRBCNT(P4)	;BYTE COUNT FROM IORB
	LOAD T1,IRBDM,(P4)	;GET DATA MODE
	HLRZ T1,MTBFMT(T1)	;GET MULTIPLIER
	SKIPE T1		;SAVE TIME IF FRAMES=BYTES
	IMUL T2,T1		;CALCULATE # FRAMES
	JRST TM2DO		;WE'RE A DATA OPERATION

BADSIO:	BUG.(CHK,PM2SIO,PHYM2,HARD,<PHYM2 - Illegal function at start IO>,,<

Cause:	The IORB function code provided to TM2SIO is less than or equal to
	zero or the short form (PAGEM) request bit is set in the IORB.

>)
	MOVX T1,IS.ERR!IS.NRT!IS.DVE	;MARK AN ERROR OCCURED
	IORM T1,IRBSTS(P4)	;IN IORB
	RET

TM2NDO:	SKIPE UDBERR(P3)	;IN ERROR RECOVERY?
	SKIPA T2,[-1]		;YES, SPACE 1 RECORD
	MOVN T2,IRBCNT(P4)	;NO, DO # RECORDS FROM IORB
TM2DO:	ANDI T2,177777		;16 BITS OF FRM COUNT
	HRLI T2,(DO.FC)		;DO FRM COUNT TO FRM COUNT REGISTER
NOFC:	ANDI Q1,77		;6 BITS OF TM02 FN
	HRRZM P3,KDBACT(P2)	;SAVE CURRENT UDB IN KDB
	JRST CHSTRT		;NOW START THINGS MOVING

;ROUTINE TO SELECT A SLAVE, SET UP TCREG
;CHECK FOR NECESSARY STATUS BITS
;CALL IT TO BEGIN AN OPERATION WITH C(Q1)=FN TABLE ENTRY
;RET WITH BITS SET IF NOT RDY (OFF-LINE, ETC.) RETSKP IF ALL OK
TM2CON:	MOVX T2,DO.DS		;READY TO READ STATUS REG
	CALL RDREG		;READ IT
	TXNN T1,DS.ERR!DS.SSC	;IS ERROR IR SSC UP?
	JRST TM2CNO		;NO, DON'T DO DRIVE CLR
	MOVX T2,DO.TC		;YES, DO DRIVE CLR
	HRR T2,UDBSLV(P3)	;BUT FIRST SELECT DRIVE ABOUT TO BE USED
	CALL WTREG		;BECAUSE WE KNOW IT'S NOT BUSY
	MOVEI T4,^D10		;COUNT OF ATTEMPTS TO CLEAR ERR
CON1:	MOVX T2,DF.CLR		;FIRST CLEAR OUT DRIVE
	CALL WTREG		;DO IT
	MOVX T2,DO.DS		;SELECT STATUS
	CALL RDREG
	TXNE T1,DS.ERR		;IS ERROR UP?
	JRST [	SOJG T4,CON1	;RETRY EXHAUSTED?
		RET]		;CANT START IO
	CALL TM2POL		;CHECK FOR REWIND DONE
TM2CNO:	HRRZ T2,UDBSLV(P3)	;GET SLAVE #
	HRLI T2,(DO.TC)		;SELECT TAPE CNTL REGISTER
	LOAD T1,IRBDN,(P4)	;GET DENSITY
	CAIG T1,4		;TOO BIG?
	SKIPGE T1,MTBDEN(T1)	;OR ILLEGAL?
	JRST CONBAD		;YES, GIVE ERROR
	DPB T1,[POINT 3,T2,27]	;SET IN POSITION IN ACC
	LOAD T1,IRBPAR,(P4)	;GET PARITY
	DPB T1,[POINT 1,T2,32]	;SET IN POSITION
	LOAD T1,IRBDM,(P4)	;GET DATA MODE
	CAIN T1,.SJDMA		;ANSI ASCII MODE?
	JRST [	LOAD T3,USTYP,(P2)	;YES, GET CONTROLLER TYPE
		CAIN T3,.UTTM3		;DOING ANSI ASCII ON TMO3?
		JRST CONBAD		;YES, THAT'S NOT POSSIBLE
		JRST .+1]		;OTHERWISE IT'S OK
	CAIG T1,4		;TOO BIG?
	SKIPGE T1,MTBFMT(T1)	;OR ILLEGAL?
	JRST CONBAD		;YES, LOSE
	DPB T1,[POINT 4,T2,31]	;SET FMT
	CALL WTREG		;FIRE 1!

	MOVX T2,DO.DS
	CALL RDREG		;GET STATUS IN T1
	TXNE Q1,TB.WRT		;[7457] Is it a write operation?
	SKIPA T2,[DS.MOL!DS.DRY!DS.WRL] ;[7457] Yes include write lock be 0
	MOVX T2,DS.MOL!DS.DRY	;[7457] No, MOL and DRY should be 1
	TXC T1,DS.MOL!DS.DRY	;[7457] Complement bits to be set to one
	TDNN T1,T2		;[7457] Skip if bits not set right
	RETSKP			;[7457] Return OK if all bits are OK
	TXC T1,DS.MOL!DS.DRY	;[7457] Reset online and ready bits

;[7457] Drive is not in the correct state, update UDB and IORB bits

	MOVX T2,US.WLK		;SET UP THESE BITS
	ANDCAM T2,UDBSTS(P3)	;1ST CLEAR THEM
	TXNE T1,DS.WRL		;[7457] Write locked?
	IORM T2,UDBSTS(P3)	;SET STATUS IN UDB
	MOVE T2,IRBSTS(P4)	;[7457] Load IORB status bits
	TXNE Q1,TB.WRT		;WRITE OPERATION?
	TXNN T1,DS.WRL		;AND WRITE LOCKED?
	SKIPA			;NO
	TXO T2,IS.ERR!IS.NRT!IS.DVE ;YES, SET ERROR BITS
	TXNN T1,DS.WRL		;WRITE LOCKED?
	TXZA T2,IS.WLK		;[7457] Not write locked, clear bit
	TXO T2,IS.WLK		;[7457] Write locked, set bit
	TXNN T1,DS.MOL		;[7457] Is the unit offline?
	TXO T2,IS.ERR!IS.DVE	;[7457] Drive is offline, light error bits
	MOVEM T2,IRBSTS(P4)	;[7457] Store updated status
	CALLRET TM2OFC		;DO ONLINE/OFFLINE CHECK AND RETURN

;HERE IF CAN'T CONNECT BECAUSE OF BAD DENSITY OR MODE:

CONBAD:	MOVX T1,IS.ERR!IS.NRT!IS.DVE	;ILLEGAL, TREAT AS HARD ERR
	IORM T1,IRBSTS(P4)	;STORE THE STATUS
	RET			;RETURN BAD
	SUBTTL RH20 Command Done Interrupt

;C(P1)=CDB  C(P2)=KDB
TM2INT:	PUSH P,Q2		;LATER DON'T SAVE TILL AFTER FTLCHK
	PUSH P,Q1		;LIKEWISE, I'M SURE
	SKIPN P3,KDBACT(P2)	;DO WE HAVE A CURRENT UDB?
	JRST TM2INU		;NO UDB
	SETZM KDBACT(P2)	;CLEAR THE CURRENT UDB
	CALL SETIRB		;GET ACTIVE IORB
	CALL FTLCHK		;CHECK FOR FATAL ERRS AND PUT DRDS REGISTER
	 JRST [POP P,Q1		;INTO Q2, TM2FTB FN ENTRY INTO Q1
		POP P,Q2
		RET]		;FATAL ERR
	TXNN Q1,TB.WRT		;ARE WE READING?
	TXZ T1,ER.NSG		;YES, IGNORE NSG ERR
TMENTY:	TXNE Q1,TB.REV		;ARE WE BACKWARDS?
	SOSA UDBPS2(P3)		;YES, THEN SUBTRACT 1 RECORD
	AOS UDBPS2(P3)		;NO, ADD 1
	HRRM T1,Q1		;SAVE ERROR REGISTER (LH OF Q1 IS FLAGS)
	TXNN Q2,DS.TM		;IS IT TAPE MARK?
	JRST NOTM		;NOT TM
	TXNE Q1,TB.REV		;ARE WE REVERSE
	SOSA UDBPS1(P3)		;YES, BACK UP 1 FILE
	AOS UDBPS1(P3)		;NO, FORWARD 1 FILE
NOTM:	TXNN Q2,DS.BOT		;ARE WE AT BOT?
	JRST NOBOT		;NO
	SETZM UDBPS1(P3)	;YES, FILE 0
	SETZM UDBPS2(P3)	;RECORD 0
	SETOM TU6HDN(P3)	;UNKNOWN DENSITY
NOBOT:	TXNE Q2,DS.PES		;ARE WE IN PE MODE?
	TXNE Q1,TB.WRT		;AND READ?
	SKIPA			;NO
	TXZ Q1,ER.COR!ER.CS	;YES, THESE ARE NOT ERRORS
	TXNE Q1,TB.RD		;ON READ FCE IS LEGAL
	TXZ Q1,ER.FCE
	TXNN Q1,ER.COR!ER.CS!ER.FCE!ER.NSG!ER.LRC!ER.DPA!ER.INC ;RETRY?
	JRST CKCONI		;NO DATA RETRY ERRS HERE
DORTY:	TXNE Q1,TB.RD		;IN READ?
	TXNN Q2,DS.TM		;AND TM?
	SKIPA			;NO
	JRST NODERS		;YES, THEN DON'T RETRY
	MOVX T3,IS.ERR!IS.DTE	;YES, ERROR- DO RETRY
	IORM T3,IRBSTS(P4)	;SET IORB ERR (DATA ERR)
	CALL TM2RDR		;GET DEVICE REGISTERS
	JRST POPPOL		;POP STACK AND POLL SLAVES
				;DON'T BOTHER SETTING UP STATUS BITS

;HERE WHEN DONE INTERRUPT AND NO SAVED UDB

TM2INU:	BUG.(CHK,TM2NUD,PHYM2,HARD,<PHYM2 - Channel Done interrupt but no unit active>,<<P1,CDBADR>,<P2,KDBADR>>,<

Cause:	A command done interrupt was issued by an RH20 channel but there
	was no unit active on that channel.

Data:	CDBADR - CDB address
	KDBADR - KDB address
>,,<DB%NND>)			;[7.1210] 
	JRST POPPOL		;CLEAN UP STACK

CKCONI:	TXNN Q1,TB.DOP		;DATA OPERATION?
	JRST NODERS		;NO - DONT ASK CHANNEL IF ANY ERRS
	CALL CKERR		;SEE IF ANY RETRIABLE ERRS IN CONI
	 JRST DORTY		;YES, RETRY THE TRANSFER
NODERS:	SKIPGE P5,TU6HDN(P3)	;GET DENSITY FROM HARDWARE
	LOAD P5,IRBDN,(P4)	;NOT AVAILABLE, GET IT FROM IORB
	CAIE P5,.SJD16		;1600 BPI (PE MODE)?
	SKIPA P5,P3		;NO, SET TO COUNT NRZI STATISTICS
	MOVEI P5,1(P3)		;YES, ACCUMULATE PE STATS
	TXNN Q1,TB.RD		;ARE WE READING?
	JRST SPENTY		;NO, DON'T TELL ABT FRM COUNT
	MOVSI T1,(US.BOT)	;WERE WE AT BOT?
	TDNE T1,UDBSTS(P3)	; ???
	CALL GTHDEN		;YES - FIGURE OUT HARDWARE
	MOVX T2,DO.FC		;GET FRM COUNT
	CALL RDREG
	ADDM T1,UDBRED(P3)	;ACCUMULATE FRAMES READ
	ADDM T1,UDBRNR(P5)	;ACCUMULATE NRZI/PE FRAMES READ
	AOS UDBRCT(P3)		;INCR READ COUNT
	LOAD T3,IRBDM,(P4)	;GET DATA MODE
	CAIG T3,4		;LEGAL?
	SKIPGE T3,MTBFMT(T3)	;AGAIN?
	JRST [	BUG.(CHK,TM2IDM,PHYM2,HARD,<PHYM2 - Illegal data mode at Done interrupt>,<<T3,MODE>>,<

Cause:	The TM02/3 IORB data mode is invalid or illegal when a done
	interrupt occurs.

Data:	MODE - TM02/3 data mode at done interrupt

>)
		MOVEI T3,0	;ACT LIKE WORDS
		JRST .+1]
	HLRZ T3,T3		;#FRAMES/BYTE
	JUMPE T3,NODIV		;SAVE TIME IF FRAMES=BYTES
	IDIV T1,T3		;CALCULATE # BYTES
	SKIPE T2		;REMAINDER?
	AOS T1			;YES, ANOTHER BYTE
NODIV:	MOVEM T1,IRBCNT(P4)	;TELL HOW MANY FRAMES ON READ

SPENTY:	TXNN Q1,TB.WRT		;WRITE?
	JRST NOTWRT		;NO
	LOAD T3,IRBDM,(P4)	;GET DATA MODE
	HLRZ T3,MTBFMT(T3)	;GET FRAMES/BYTE
	SKIPN T3		;FRAMES=BYTES?
	SKIPA T3,IRBCNT(P4)	;YES. GET COUNT AND SAVE MULTIPLY
	IMUL T3,IRBCNT(P4)	;GET FRAMES
	ADDM T3,UDBWRT(P3)	;ACCUMULATE FRAMES WRITTEN
	ADDM T3,UDBWNR(P5)	;ACCUMULATE NRZI/PE WRITE STATS
	AOS UDBWCT(P3)		;UPDATE READ COUNT
NOTWRT:	MOVX T2,IS.BOT!IS.EOT!IS.TPM!IS.WLK ;ZERO BITS
	ANDCAM T2,IRBSTS(P4)	;DO IT TO IT
	TXNN Q2,DS.BOT		;AT BOT?
	TXZ T2,IS.BOT		;NO
	TXNE Q1,TB.WRT		;ARE WE WRITING?
	TXNN Q2,DS.EOT		;AND AT EOT?
	TXZ T2,IS.EOT		;NO TO EITHER
	TXNN Q2,DS.TM		;TP MK 
	TXZ T2,IS.TPM		;NO, CLEAR TM FLAG
	TXNE Q1,TB.REV		;SPACE REVERSE OR READ REVERSE
	TXNN Q2,DS.BOT		;AND AT BOT?
	SKIPA			;NO TO EITHER
	TXO T2,IS.TPM		;YES TO BOTH, RETURN TAPE MARK
	TXNN Q2,DS.WRL		;WRITE LOCKED?
	TXZ T2,IS.WLK		;NO
	IORM T2,IRBSTS(P4)	;AND SAVE IT (LEAVE ERR SET IF IT WAS SET)
	MOVX T2,US.BOT		;CLEAR THESE BITS
	ANDCAM T2,UDBSTS(P3)	;DO IT
	TXNN Q2,DS.BOT		;AT BOT?
	TXZ T2,US.BOT		;NO, CLEAR BIT
	IORM T2,UDBSTS(P3)	;SAVE IT
	MOVE T1,Q2		;GET ERRORS
	CALL TM2OFC		;DO OFFLINE CHECK
	TXNE Q1,TB.DOP		;IF A DATA  OPERATION,
	AOS -2(P)		;SKIP RETURN TO THE CHANNEL
	JRST POPPOL		;ANYBODY DONE A REWIND?
				;AND THEN A WORD FROM OUR SPONSOR...
;HERE TO DETERMINE WHAT DENSITY THE TAPE HARDWARE REALLY READING AT

;	P1,2,3 SETUP
;	RH(Q2) DRIVE STATUS REGISTER
;	CALL GTHDEN
;RETURNS+1(ALWAYS):
;	DENSITY STORED IN UDB FOR MAGTAP (OR LEFT AS UNKNOWN FOR TM02)

GTHDEN:	LOAD T1,USTYP,(P2)	;DO WE HAVE A TM03?
	CAIE T1,.UTTM3		; ???
	RET			;NO - ASSUME DENSITY AS SET
	MOVEI T1,.SJDN8		;YES - FIRST ASSUME 800BPI
	TRNE Q2,DS.PES		;PHASE ENCODED?
	MOVEI T1,.SJD16		;YES - IS REALLY 1600BPI
	MOVEM T1,TU6HDN(P3)	;STORE FOR MAGTAP
	RET			;RETURN

;COMES HERE ON AN ATA INTERRUPT (INCLUDING SPACING OPS)
;C(P1)=CDB C(P2)=KDB
;WILL SET C(P4)= 0 IF NONE
;SETS C(P3)=UDB
;ALWAYS RET (NEVER SKP RET'S)
;IF ERR, IS.ERR AND EITHER <IS.DVE OR IS.DTE> WILL BE SET
;IF IS.ERR NOT SET, WE ARE FINISHED WITH THIS IORB
TM2ATN:	PUSH P,Q2		;SAVE Q2
	MOVE Q2,TM2ADR(P2)	;GET OUR MASSBUS ADDRESS
	MOVX T2,1
	LSH T2,(Q2)		;MASK TO CLEAR OUR ATTENTION BIT
	HRLI T2,(DO.AS)		;REGISTER ADDRESS
	CALL WTREG3		;CLEAR THE BIT
	PUSH P,Q1
	HRRZ P3,KDBACT(P2)	;GET ACTIVE UDB (IF ANY)
	JUMPE P3,CHKNEW		;IF NO UDB, JUST CHECK FOR REWS AND UNITS ON LINE
	MOVX T1,US.ACT		;UNIT ACTIVE?
	TDNE T1,UDBSTS(P3)	; ??
	JRST CKNDOP		;YES - FINISH UP THEN POLL
	HRRZ Q1,UDBADR(P3)	;GET UNIT ADDRESS
	MOVE P3,TM2ADR(P2)	;GET KONTROLLER ADDRESS
	HRRZ T1,CDBADR(P1)	;GET CHANNEL ADDRESS
	BUG.(INF,TM2UNA,PHYM2,HARD,<PHYM2 - Done interrupt and UDB not active>,<<P3,UDBADR>,<T1,CDBADR>>,<

Cause:	Unit is not active at done interrupt.

Data:	UDBADR - UDB address
	CDBADR - CDB address
>)
	SETZB P3,KDBACT(P2)	;RESET SAVED UDB
	JRST POPPOL		;AND GO POLL
CKNDOP:	CALL SETIRB		;GET CURRENT IORB
	HRRZ Q1,UDBERR(P3)	;GET FUNCTION CODE
	SKIPN Q1		;IN ERROR RECOVERY?
	LOAD Q1,ISFCN,(P4)	;NO, GET IT FROM IORB
	MOVE Q1,TM2FTB(Q1)	;GET FUNCTION ENTRY
	TXNN Q1,TB.DOP		;DATA OPERATION?
	JRST NDOP		;NO
;THE FOLLOWING COMMENTED CODE CAUSES THE 2020 TO GET INTO AN
;INTERRUPT LOOP SINCE THE OPERATION APPEARS NOT TO BE CORRECTLY TERMINATED
;	MOVX T2,DO.DS		;CHECK IF DEVICE STILL ON LINE
;	CALL RDREG		; ...
;	TXNN T1,DS.MOL		;ONLINE?
;	JRST NDOP		;NO - TREAT AS IF TERMINATING NONDATA OP
	MOVEI P4,0		;YES, ENSURE RECALL AT INTERRUPT ENTRY
	JRST TM2ATX		;AND EXIT ATN

NDOP:	SETZM KDBACT(P2)	;CLEAR SAVED UDB
	CALL FTLCHK		;ANY FATAL ERRORS? (PUT DRIVE STATUS IN Q2,
TM2ATX:	 JRST [POP P,Q1		;YES		TM2FTB ENTRY IN Q1)
		POP P,Q2
		RET]		;FATAL ERR

	MOVE P5,P3		;POINT P5 AT UDB TO UPDATE WRITE COUNTERS
	TXNE Q1,TB.TM		;WRITE TM OPERATION?
	JRST TMENTY		;YES, USE DATA ROUTINES
	TXNE Q1,TB.ERA		;ERASE OPERATION?
	JRST SPENTY		;YES, DON'T CHECK TAPE POSITION
	TXNE Q1,TB.REW		;REWIND?
	JRST REWSTA		;YES, CLEAR REC CNTRS
	MOVSI T1,(US.BOT)	;WERE WE AT BOT?
	TDNE T1,UDBSTS(P3)	; ??
	CALL GTHDEN		;YES - FIGURE OUT HARDWARE
	MOVX T2,DO.FC
	CALL RDREG
	MOVN T3,T1		;NEGATE FRM COUNT
	ANDI T3,177777		;ITS ONLY 16 BIT NEG NR
	SKIPE T1,UDBERR(P3)	;ARE WE IN ERR RECOVERY?
	JRST RTYATN		;YES
	EXCH T3,IRBCNT(P4)	;SAVE RESIDUE (# RECORDS NOT SPACED)
	SUB T3,IRBCNT(P4)	;CALCULATE # RECORDS MOVED
	TXNE Q1,TB.REV		;IN REVERSE DIR?
	MOVNS T3		;YES, NEGATE
	ADDM T3,UDBPS2(P3)	;UPDATE REC COUNT
	MOVE T3,IRBCNT(P4)	;GET FRM COUNT AGAIN
	JUMPE T3,NOCKER		;IF ALL RECORDS SPACED, DON'T CHECK ERR
RES1:	TXNN Q2,DS.BOT!DS.EOT!DS.TM ;EARLY TERM OK IF EOT, BOT, OR TM
RESERR:	JRST [	MOVX T1,IS.ERR!IS.DVE!IS.NRT ;INDICATE ERRORS
		IORM T1,IRBSTS(P4)
		CALL TM2RDR	;GET DEVICE REGISTERS
		JRST SPENTY]

	PUSH P,Q2		;MUST EXPLICITLY CLEAR TM02 HERE
	MOVE Q2,TM2ADR(P2)	;GET DEVICE ADDRESS
	MOVX T2,DF.CLR		;CLEAR
	CALL WTREG3		; ...
	POP P,Q2
	; ...

	; ...
;ALL RECORDS SPACED, DON'T BOTHER CHKING ERROR BITS


NOCKER:	TXNN Q2,DS.TM		;TAPE MK?
	JRST NOSTM		;NO
	TXNE Q1,TB.REV		;IN REVERSE DIR?
	SOSA UDBPS1(P3)		;YES, THEN -1
	AOS UDBPS1(P3)		;NO, THEN +1 FILE
NOSTM:	TXNN Q2,DS.BOT		;AT BOT?
	JRST SPENTY		;NO
REWENT:	SETZM UDBPS2(P3)	;YES, ZERO RECORDS
	SETZM UDBPS1(P3)	;ZERO FILES
	SETOM TU6HDN(P3)	;UNKNOWN DENSITY
	JRST SPENTY		;NOW SET STATUS AND RET

REWSTA:	MOVX T1,US.REW		;SET REWINDING
	IORM T1,UDBSTS(P3)	; IN THE UDB
	JRST REWENT		;

POPPOL:	POP P,Q1		;RESTORE REGISTERS
	POP P,Q2
	JRST TM2POL		;AND CHECK FOR REWIND INTERRUPTS

				;COME HERE AT END OF SPACE DURING RETRY
RTYATN:	JUMPN T3,RESERR		;FRAME COUNT 0?
	TXNN Q1,TB.REV		;IN REVERSE DIRECTION?
	AOSA UDBPS2(P3)		;NO FORWARD THE RECORD COUNTER
	SOS UDBPS2(P3)		;YES, BACK IT UP
	TRNN Q2,DS.BOT		;AT BOT?
	JRST NOCKER		;NO, CONT
	JRST RESERR		;CONFUSED ERROR RECOVERY

CHKNEW:	MOVE T4,KDBIUN(P2)	;GET AOBJN POINTER
CHKNW1:	SKIPE (T4)		;EXIST?
	JRST CHKNW2		;YUP DON'T BOTHER WITH IT
	MOVE Q1,T4		;GET UNIT NUMBER
	SUB Q1,KDBIUN(P2)
	HRRZS Q1		;UNIT ONLY
	CALL INIUNI		;INITALIZE UNIT
	SKIPA			;NOT FOUND
	AOS MTAJB0		;TELL JOB0 ABOUT IT
CHKNW2:	AOBJN T4,CHKNW1		;GET NEXT UNIT
	JRST POPPOL		;DO POLLING

;ROUTINE TO CHECK FOR ANY OBVIOUS FATAL ERRORS
;RET IF ERR (WITH IORB STATUS BITS SET)
;SKP RET IF OK
;RETURNS WITH C(T1) THE ERROR REGISTER, C(Q2) DRIVE STATUS REGISTER
;AND C(Q1) THE TABLE ENTRY FOR CURRENT
;FTLCHK MUST NOT BE CALLED UNLESS AN IORB EXISTS FOR THE UNIT

FTLCHK:	MOVX Q1,IS.DVE!IS.DTE	;READY TO CLEAR THESE BITS
	ANDCAM Q1,IRBSTS(P4)	;DO IT TO IT
	HRRZ T4,UDBERR(P3)	;GET FUNCTION IF ERROR RECOVERY
	SKIPN T4		;IN ERROR RECOVERY?
	LOAD T4,ISFCN,(P4)	;GET FN
	SKIPG Q1,TM2FTB(T4)	;VALID?
	JRST [	BUG.(CHK,TM2IF2,PHYM2,HARD,<PHYM2 - Illegal function on command done>,<<Q1,FNC>>,<

Cause:	FTLCHK detected an illegal function code either in the IORB or
	UDBERR at command done.

Data:	FNC - TM02/3 function code
>)
		JRST FTLERR]
	MOVSI T2,(DO.ER)	;GET ERROR REGISTER
	CALL RDREG		; ...
	TXNN T1,ER.RMR!ER.UNS!ER.FMT!ER.DTE!ER.ILR!ER.ILF!ER.CPA ;FATAL ERRS
	JRST DOPCK		;NO FATAL ERRORS HERE
	TXNE T1,ER.FMT		;FORMAT ERROR?
	TXNN T1,ER.COR!ER.CS!ER.FCE!ER.NSG!ER.LRC!ER.INC ;YES. ANY TAPE MOTION?
	JRST FTLERR		;NOT FORMAT ERR, OR FORMAT AND NO TAPE MOTION
	JRST DOPCK		;FAKE FORMAT ERROR, RETRY
FTLERR:	CALL TM2RDR		;READ ALL REGISTERS
	MOVE T1,TM2REG+DR.ER(P2) ;GET ERROR REG AGAIN
	TXNE T1,ER.UNS		;UNS ERR?
	CALL PHYOFL		;DECLARE OFF-LINE
	MOVX T3,IS.NRT!IS.ERR!IS.DVE ;SET BITS
	IORM T3,IRBSTS(P4)	;PUT BITS IN IRBSTS
	HRRZ T1,TM2REG+DR.DS(P2) ;GET STATUS REG
	MOVX T3,IS.WLK		;CLEAR STATUS BIT
	ANDCAM T3,IRBSTS(P4)	;CLEAR WRITE LOCK BIT
	TXNE T1,DS.WRL		;WRITE LOCKED?
	IORM T3,IRBSTS(P4)	;YES, SET THE BIT AGAIN
	LDB T2,USYTYP		;IS THIS A TU77?
	CAIE T2,.UTT77		; ???
	JRST TM2POL		;NO
	MOVSI T2,(DO.TC)	;YES - SELECT SLAVE
	HRR T2,UDBSLV(P3)	; ...
	CALL WTREG
	MOVX T2,DF.CLR		;NOW CLEAR IT
	CALL WTREG
	JRST TM2POL		;REWINDS DONE? (THEN RET)

DOPCK:	MOVE Q2,T1		;SAVE ERROR REGISTER
	MOVSI T2,(DO.DS)	;GET DRIVE STATUS REGISTER
	CALL RDREG		; ...
	EXCH Q2,T1		;PUT DS IN Q2, ER IN T1
	TXNE Q1,TB.RD		;ON READ FCE IS LEGAL (IT IS SHORT RECORD)
	JRST DOPCK1
	TXNE Q1,TB.DOP		;DATA OPERATION?
	TXNE Q2,DS.TM		;EOF ERROR (EOF CAUSES FCE ON RH11)
	JRST DOPCK1		;NON DATA OR EOF -- ALL OK
	TXNE T1,ER.FCE		;FRAME COUNT ERROR CHECK
	JRST FTLERR		;FATAL ERROR ON DATA OPERATIONS
DOPCK1:	CAIE T4,IRFRUN		;UNLOAD FUNCTION?
	TXNE Q2,DS.MOL		;NO, MEDIUM ON LINE?
	SKIPA			;YES, OK
	JRST FTLERR		;NO - QUITE FATAL.
	TXNN T1,ER.OPI!ER.NEF	;OPI OR NEF?
	RETSKP			;OK RET, NO ERR
	TXNE Q1,TB.REV		;IF ERRS, OK IF REVERSE
	TXNN Q2,DS.BOT		;AND AT BOT
	JRST FTLERR		;BAD RET
	RETSKP			;GOOD RET
	SUBTTL Error Retry Entry Point

;P1, P2, P3, P4 SET UP
;ROUTINE PUTS ER BLK ADDRESS IN Q1

TM2ERR:	SAVEQ
	CALL SETIRB		;GET OUR IORB
	HRRZ Q1,UDBERP(P3)	;GET ERROR BLOCK IF PRESENT
	HLLZ T1,IRBSTS(P4)	;GET IORB STATUS
;IF UNS (OFF-LINE ERR), SOMEDAY SHOULD RETRY IN A MIN OR SO.
	HRRZ T4,UDBERR(P3)	;GET FUNCTION IF ERROR RECOVERY
	SKIPN T4		;IN ERROR RECOVERY?
	LOAD T4,ISFCN,(P4)	;NO, GET FN FROM IORB
	MOVE T4,TM2FTB(T4)	;NOW TABLE ENTRY
	TXNN T1,IS.NRT!IS.IER	;FATAL OR INHIBIT ERR RECOVERY?
	JRST TMERTY		;NO, RETRY THE ERROR
	SKIPE TU6EBP(P3)	;WAS FATAL ERR DURING RETRY?
	JRST ABTNOS		;YES, WE ALREADY HAVE BEGIN DATA
	AOS (P)			;SKIP RET FROM LOD1 - DONE WITH IORB
	JRST LOD1		;LOAD UP ERR BLK FOR FATAL ERR

				;DO RETRY
TMERTY:	HLR T4,T4		;COPY LH OF FNTBL
	TRZ T4,777770		;SAVE ONLY RETRY INDEX IN RH
	SKIPE UDBERC(P3)	;1ST TIME FOR HERE?
	JRST NOT1ST		;NO
	SETZM TU6ECL(P3)	;NOT DOING TAPE CLEAN
	SKIPN T1,RTYBPT(T4)	;GET RETRY BYTE POINTER
	JRST [	BUG.(INF,TM2IDX,PHYM2,HARD,<PHYM2 - Illegal retry byte pointer>,<<T1,RTYBPT>>,<

Cause:	An error occured during a TM02/3 operation but the retry type for
	the function code is illegal.

Data:	RTYBPT - Retry byte pointer
>)
		JRST ABTNOS]	;CALL IT FATAL
	MOVEM T1,TU6EBP(P3)	;SAVE IT
	MOVE T1,UDBPS2(P3)	;GET # RECORDS
	SOS T1			;CALCULATE WHERE WE SHOULD BE AFTER REPOS
	TXNE T4,TB.REV		;IF IN FORWARD, WE WANT (CUR POSITION-1)
	ADDI T1,2		;IF REVERSE, WE WANT (CUR POSITION+1)
	MOVEM T1,TU6EPS(P3)	;WHERE WE SHOULD BE SOMEDAY
	MOVEI T1,RTYWRT+1	;ON WRITE, THIS MANY RETRIES
	TXNN T4,TB.WRT		;ARE WE RIGHT (WRITE)?
	MOVE T1,[RTYCLN+1,,RTYOP+1] ;NO, THIS IS FOR READ
	MOVEM T1,UDBERC(P3)	;THE RETRY COUNTER
	CALL LOD1		;LOAD UP ERR BLK WITH BEGIN DATA
	JRST NXTBYT		;1ST TIME THRU TM2ERR

NOT1ST:	MOVE T1,TU6EBP(P3)	;GET RETRY BYTE POINTER
	ILDB T1,T1		;LOOK AT NEXT OPERATION
	CAIE T1,16		;END OF RETRY?
	JRST CKBOT		;NO
	HLLZ T1,IRBSTS(P4)	;GET IORB STATUS
	TXNN T1,IS.DTE		;WAS THERE DATA ERR?
	JRST RTYNOE		;NO, WE'VE RECOVERED!
	MOVE T1,RTYBPT(T4)	;GET BYTE POINTER
	MOVEM T1,TU6EBP(P3)	;RESET IT
	SETZM TU6ECL(P3)	;NOT DOING TAPE CLN SEQUENCE
	HRRZ T1,UDBERC(P3)	;GET ABORT COUNTER
	SOS T1			;ANOTHER RETRY - SEE IF WE'VE LOST
	HRRM T1,UDBERC(P3)	;SAVE IT
	JUMPN T1,NXTBYT		;IF NOT 0, TRY AGAIN
	TXNE T4,TB.DOP		;DATA OP?
	TXNN T4,TB.RD		;WRITE OR READ?
	JRST ABTRTY		;NONDATA OR WRITE - WE'VE FAILED
	HLRZ T1,UDBERC(P3)	;GET TAPE CLNR COUNTER
	SOJE T1,ABTRTY		;RUN OUT OF RETRIES? - YES
	HRLM T1,UDBERC(P3)	;NO, UPDATE CLN COUNTER
	MOVX T1,RTYOP+1		;NOW RESET (RH) COUNTER
	HRRM T1,UDBERC(P3)	;FOR NEXT CLEAN RETRY
	MOVE T1,RTYBPT+1(T4)	;GET CLEANER SEQ BYTE POINTER
	MOVEM T1,TU6EBP(P3)	;SAVE FOR USE LATER
	SETZM TU6EBC(P3)	;RESET COUNT FOR USE IF WE HIT BOT
	SETOM TU6ECL(P3)	;WE ARE DOING A CLEAN
	JRST NXTBYT		;NOW DO NEXT OPERATION

CKBOT:	SKIPN TU6ECL(P3)	;DOING TAPE CLEAN?
	JRST NXTBYT		;NO DON'T CHECK BOT
	HLLZ T1,IRBSTS(P4)	;GET STATUS
IFE OPIFIX,<SKIPE UDBPS2(P3)>;	ARE WE ALMOST AT BOT?
	TXNE T1,IS.BOT		;OR DID WE HIT BOT?
	SKIPA T1,[CLNREC]	;YES, FIGURE OUT HOW TO FUDGE BYTE POINTER
	JRST NXTBYT		;NO, CONTINUE NORM RETRY
	LOAD T3,ISFCN,(P4)	;GET ORIGINAL FN
	MOVE T3, TM2FTB(T3)	;GET FLAGS
	TXNE T3,TB.WRT		;IS IT A WRITE?
	JRST NXTBYT		;WRITE RETRY WON'T EVER HIT BOT SO NO FUDGE
	TXNN T3,TB.REV		;ADD 1 IF FORWARD
	AOS T1			;DO IT ON FORWARD
	SUB T1,TU6EBC(P3)	;SUBT # RECORDS SPACED
	LSH T1,1		;TIMES 2 (COMMENTS ASSUME CLNREC=5)
	AOS T1			;ON FORWARD, SKIP (6-CNT)*2+1 BYTES
	CAIL T1,1		;ON REVERSE, SKIP (5-CNT)*2+1 BYTES
IFN OPIFIX,<CAILE T1,^D9>;	RESULT MUST BE BETWEEN 1 AND 9
IFE OPIFIX,<CAILE T1,^D11>;	BETWEEN 1 AND 11 IF OPI NOT FIXED
	JSP CX,CNFERR		;BAD INCR, WE ARE CONFUSED
IFE OPIFIX,<SKIPE UDBPS2(P3)>;	IF ALMOST AT BOT, FUDGE 1 LESS
IBPLP:	IBP TU6EBP(P3)		;INCR THE POINTER
	SOJG T1,IBPLP		;ANOTHER?

NXTBYT:	AOS TU6EBC(P3)		;ANOTHER BYTE FOR THE COUNTER
	ILDB T3,TU6EBP(P3)	;GET NEXT FUNCTION
	CAIE T3,17		;IS IT CHECK POSITION OPERATION?
	JRST NOTCKP		;NO
	MOVE T1,UDBPS2(P3)	;YES, GET OUR POSITION
	CAMN T1,TU6EPS(P3)	;ARE WE WHERE WE WANT TO BE?
	JRST NXTBYT		;YES, ALL OK
	JSP CX,CNFERR		;POSITION CONFUSED,SIGNAL ERROR
	JRST ABTNOS		;BOMB OUT

NOTCKP:	CAIE T3,16		;END OF RETRY?
	SKIPG T3		;IS FUNCTION VALID?
	JRST [	BUG.(INF,TM2IRF,PHYM2,HARD,<PHYM2 - Illegal function during retry>,<<T3,FNC>>,<

Cause:	An illegal function code was encountered during a TM02/3 retry
	operation.

Data:	FNC - Retry function code
>)
		JRST ABTNOS]	;IMAGINE FATAL
	HRRM T3,UDBERR(P3)	;SAVE FUNCTION
	CALL SETIO		;SET UP FOR I/O
	CALL CDSSIO(T1)		;START IO
;SHOULD RETRY EVERY MIN OR SO
	 JRST ABTNOS		;COULDN'T START UP RETRY OPERATION
	RET			;AND WAIT


RTYNOE:	TXNE T1,IS.NRT		;HARD ERRS SHOULDN'T EVER GET HERE
	BUG.(CHK,TM2HER,PHYM2,HARD,<TM2ERR - IS.HER set on successful retry>,,<

Cause:	A retry operation has been completed succesfully but bit IS.HER
	indicating a hard error was set in the IORB. Error recovery should
	not be done for hard errors.
>,,<DB%NND>)			;[7.1210] 
	MOVX T1,IS.ERR		;WE DID IT! CLEAR ERR BIT
	ANDCAM T1,IRBSTS(P4)	;AND SKP RETURN
	TXNN T4,TB.WRT		;ARE WE WRTING?
	AOSA UDBSRE(P3)		;NO, A SOFT READ ERR
	AOS UDBSWE(P3)		;YES, A SOFT WRITE ERR
	SOS UDBERC(P3)		;FIX UP THE RETRY COUNT
	JRST ABTNOS

;HERE WHEN ERROR RECOVERY GETS CONFUSED(FLAKEY HARDWARE W I L L DO IT)

CNFERR:	HRRZ T1,UDBADR(P3)	;GET UNIT NUMBER
	MOVE Q1,TM2ADR(P2)	;GET KNOTROLLER NUMBER
	HRRZ T3,CDBADR(P1)	;GET CHANNEL NUMBER
	BUG.(CHK,TM2RFU,PHYM2,HARD,<PHYM2 - Error recovery confused>,<<T1,UNIT>,<Q1,CONT>,<T3,CHAN>>,<

Cause:	The error recovery process has become confused. This could be
	caused by a malfunction in the hardware.

Data:	UNIT - Unit number
	CONT - Controller number
	CHAN - Channel number
>)
	MOVSI T1,(IS.ERR!IS.NRT) ;INDICATE RATHER HARD ERR
	IORM T1,IRBSTS(P4)	; ...
	JRST ABTNOS		;AND ABORT
ABTRTY:				;WE RAN OUT OF RETRIES
	TXNN T4,TB.WRT		;ARE WE WRTING?
	AOSA UDBHRE(P3)		;NO, A HARD READ ERR
	AOS UDBHWE(P3)		;YES, A HARD WRITE ERR
ABTNOS:	AOS (P)			;SKIP RET FROM LODE
	HRRZ Q1,UDBERP(P3)	;GET ERROR BLOCK
	SKIPN TU6EBP(P3)	;DONE ANY RETRIES?
	JRST LODE		;NO, LOAD UP ERR BLK WITH END DATA
	TXNN T4,TB.WRT		;YES, IN A WRITE?
	JRST RDCNT		;NO
	MOVEI T1,RTYWRT+1	;YES, CALCULATE # RETRIES DONE
	SUBM T1,UDBERC(P3)	;RESIDUE
	JRST LODE		;NOW LOAD UP ERR BLK

RDCNT:	HLRZ T1,UDBERC(P3)	;GET CLN COUNTER
	IMULI T1,RTYOP		;CONVRT JUST TO # RETRIES
	ADD T1,UDBERC(P3)	;ADD IN REGULAR RETRIES
	MOVEI T2,<RTYCLN+2>*RTYOP+1 ;COUNT AT START
	SUB T2,T1
	HRRZM T2,UDBERC(P3)	;SAVE # RETRIES
	JRST LODE		;NOW LOAD UP ERR BLK

				;LOAD UP ERR BLK AT START OF ERR
				;C(Q1)=ERR BLK

LOD1:	JUMPE Q1,R		;IF NO ERROR BLOCK, PUNT
	MOVE T1,Q1		;COPY ERROR BLOCK
	MOVE T2,[-NITAB,,ITAB]	;POINTER TO INFORMATION TABLE
	CALL SEBCPY		;COPY INFORMATION
	 JFCL
	MOVS T1,UDBPS1(P3)	;GET FILE 
	HRR T1,UDBPS2(P3)	;AND RECORD (JUST AFTER ERROR)
	MOVEM T1,SEBDAT+MB%LOC(Q1) ;AND SAVE AS LOCATION OF ERROR
	MOVEI T1,SEBDAT+MB%REG(Q1) ;MOVE REGISTERS TO HERE
	MOVEM T1,T2		;SAVE FOR RH OF BLT
	ADDI T2,11		;11 WDS
	HRLI T1,TM2REG(P2)	;GET REGISTERS FROM HERE
	HRLI T2,(BLT T1,)	;SET UP INST FIELD
	XCT T2			;DO IT
	RET


				;LOAD UP ERR BLK AT END

LODE:	SETZM TU6EBP(P3)	;RESET ERROR BYTE POINTER
	JUMPE Q1,R		;IF NO ERROR BLOCK, CANT SAVE DATA
	MOVE T3,[-12,,TM2REG]	;CASE FOR START
	ADD T3,P2		;POINTS TO REGISTER DATA
	MOVEI T2,SEBDAT+MB%REG(Q1) ;REGISTER DATA GOES HERE
LDELP:	MOVE T1,(T3)		;GET REGISTER
	HRLM T1,(T2)		;PUT IT
	AOS T2			;NEXT WD
	AOBJN T3,LDELP		;DONE?
	MOVE T1,TM.CNI(P2)	;GET CONI
	MOVEM T1,SEBDAT+MB%CIF(Q1) ;SAVE
	MOVE T1,TM.CS1(P2)	;GET TCR
	MOVEM T1,SEBDAT+MB%D1F(Q1) ;SAVE
	MOVE T1,TM.DBF(P2)	;GET BAR
	MOVEM T1,SEBDAT+MB%D2F(Q1) ;SAVE
	RET


;TABLE OF ITEMS TO COPY INTO ERROR BLOCK

ITAB:	SEBPTR MB%CS0,SBTWD,CDBCS0(P1) ;CHANNEL STATUS 0
	SEBPTR MB%CS1,SBTWD,CDBCS1(P1) ;CHANNEL STATUS 1
	SEBPTR MB%CS2,SBTWD,CDBCS2(P1) ;CHANNEL STATUS 2
	SEBPTR MB%CC1,SBTWD,CDBCC1(P1) ;CCW 1
	SEBPTR MB%CC2,SBTWD,CDBCC2(P1) ;CCW 2
	SEBPTR MB%ICR,SBTWD,CDBICR(P1) ;INITIAL CONTROL REGISTER
	SEBPTR MB%CNI,SBTWD,TM.CNI(P2) ;CONI INITIAL
	SEBPTR MB%D1I,SBTWD,TM.CS1(P2) ;TCR
	SEBPTR MB%D2I,SBTWD,TM.DBF(P2) ;BAR/DBF

NITAB==.-ITAB
	SUBTTL Routine To Poll Slaves To See If Done Rewind

TM2POL:	PUSH P,P4		;SAVE PERMANENT ACCUMULATORS
	MOVEI P4,11		;GUARD AGAINST BROKEN HARDWARE
	PUSH P,Q2		;WE WILL CLOBBER IT
	PUSH P,P3		;IN CASE WE MUST SWITCH UNITS
	PUSH P,[0]		;VARIABLE FOR REWIND DONE
POLAGN:	MOVSI T4,-TM2SLC	;[7457] Load AOBJN for number possible slaves
	SETOM T1		;SAYS THAT WE HAVEN'T READ A REGISTER YET
POLLP:	ADD T4,P2		;BUILD POINTER TO KDB ENTRY
	MOVE P3,KDBUDB(T4)	;GET UDB ADDRESS FOR THIS SLAVE
	SUB T4,P2		;FUDGE IT BACK
	MOVE Q2,TM2ADR(P2)	;GET TM02 ADDRESS
	JUMPE P3,TM2PNO		;UNIT NOT KNOWN
	MOVX T2,DO.TC		;READY TO LOAD TAPE CNTL REGISTER
	TRO T2,(T4)		;SELECT THIS SLAVE
	CALL WTREG3		;...
	MOVX T2,DO.DS		;NOW GET STATUS REGISTER
	CALL RDREG3
	HLLZ T2,UDBSTS(P3)	;GET STATUS OF DRIVE
	MOVX T3,US.BOT!US.REW!US.WLK ;CLEAR THESE BITS
	ANDCAM T3,UDBSTS(P3)	;DO IT
	TXNN T1,DS.BOT		;AT BOT?
	TXZA T3,US.BOT		;NO
	JRST [SETZM UDBPS1(P3)	;YES, ZERO REC CNTRS
		SETZM UDBPS2(P3)
		SETOM TU6HDN(P3)	;UNKNOWN DENSITY
		JRST .+1]
	TXNN T1,DS.PIP		;REWINDING? (PIP=1?)
	TXZ T3,US.REW		;NO, CLEAR BIT
	TXNN T1,DS.WRL		;WRITE LOCKED?
	TXZ T3,US.WLK		;NO
	IORM T3,UDBSTS(P3)	;STORE THE STATUS
	TXNE T2,US.REW		;ARE WE REWINDING?(T2 IS OLD UDBSTS)
	JRST	[MOVX T2,US.REW	;OLD STATUS WAS REWINDING, CHECK
		TDNE T2,UDBSTS(P3) ;NEW STATUS FOR CHANGE
		JRST .+1	;CONTINUE LOOP
		MOVEM P3,(P)	;SAVE UDB WHICH FINISHED REWIND
		MOVX T2,US.PSI	;SET REWIND PSI
		IORM T2,UDBSTS(P3)
		LDB T2,USYTYP	;IS THIS A TU77
		CAIE T2,.UTT77	; ??
		JRST .+1	;NO
		PUSH P,T1	;YES - SAVE T1
		MOVX T2,DF.CLR	;AND CLEAR IT
		CALL WTREG3	; ...
		POP P,T1	;RESTORE
		JRST .+1]	;AND CONTINUE LOOP

	CALL TM2OFC		;DO OFFLINE CHECK
	TXNN T1,DS.SLA!DS.SSC	;SLAVE ATTENTION OR SLAVE STATUS CHANGE?
	JRST TM2PNO		;NO
	LDB T2,USYTYP		;YES - IS IT A TU77?
	CAIE T2,.UTT77		; ??
	JRST TM2PNO		;NO
	PUSH P,T1		;YES - SAVE T1
	MOVX T2,DF.CLR		;MUST CLEAR IT
	CALL WTREG3		; ...
	POP P,T1		;RESTORE
TM2PNO:	AOBJN T4,POLLP		;DO REST OF SLAVES
	JUMPGE T1,TM2NRD	;JUMP IF WE HAVE READ THE STATUS REGISTER
	MOVE Q2,TM2ADR(P2)	;IF NOT, READ IT NOW
	MOVX T2,DO.DS
	CALL RDREG3		;READ THE DRIVE STATUS REGISTER
TM2NRD:	TRNE T1,DS.SSC!DS.ERR	;IS SSC OR ERR UP?
	JRST FNDCLR		;YES, FIND AN INACTIVE DRIVE FOR DRIVE CLEAR
TM2BCK:	POP P,P3		;RECOVER POSSIBLE REWIND DONE UDB
	JUMPE P3,TM2NR1		;IS THERE ONE?
	SKIPN -2(P)		;YES, IS IT LEGAL TO START UP
	CALL PHYRWD		;YES, NOTIFY PHYSIO, MAY START IO
TM2NR1:	POP P,P3
	POP P,Q2
	POP P,P4
	RET

FNDCLR:	MOVE T2,KDBIUN(P2)	;GET AOBJN POINTER
FNDLP:	SKIPN P3,(T2)		;IS ENTRY 0?
	JRST RDYCLR		;YES, DO DRIVE CLEAR HERE
	MOVE T3,UDBSTS(P3)	;GET UDB STATS
	TXNE T3,US.REW		;ARE WE REWINDING?
	AOBJN T2,FNDLP		;YES, TRY NEXT DRIVE
RDYCLR:	SUB T2,KDBIUN(P2)	;SUBT AOBJN POINTER BASE
	HRLI T2,(DO.TC)		;IF ALL REWINDING, DO IT TO 7
	CALL WTREG3		;SELECT IT
	MOVX T2,DF.CLR		;SET UP TO DO CLEAR
	CALL WTREG3		;LOAD IT INTO CONTRL REGISTER (0)
	SOJN P4,POLAGN		;BEGIN POLL AGAIN (THANX TO MATEL ENG)
	BUG.(CHK,TM2CCI,PHYM2,HARD,<PHYM2 - TM02 SSC or SLA won't clear>,,<

Cause:	11 (octal) attempts to clear a TM02 SSC or SLA have failed.
>,,<DB%NND>)			;[7.1210] 
	JRST TM2BCK		;HOPE AND HOPE

;HERE TO CHECK IF ONLINE/OFFLINE STATUS CHANGE

TM2OFC:	SAVET			;SAVE TEMPS
	HLLZ T2,UDBSTS(P3)	;GET CURRENT STATUS
	TXNN T2,US.OFS		;IS IT OFFLINE?
	JRST TM2ONC		;YES CHECK TO SEE IF DRIVE WENT ONLINE
	TXNN T1,DS.MOL		;IS DRIVE ONLINE
	RET			;NO STILL OFFLINE
	CALLRET	PHYONL		;CHANGE OF STATUS SET IT ONLINE

TM2ONC:	TXNE T1,DS.MOL		;CURRENT STATE IS ONLINE IS IT REALLY
	RET			;YES ALL OK
	CALLRET PHYOFL		;NO DECLARE OFFLINE

	SUBTTL TM02 Function Table

;EACH ENTRY MUST BE NON-0

;1B0			;ILLEGAL FUNCTION
	TB.WRT==1B1		;THIS FUNCTION WRITES ON TAPE
	TB.REV==1B2		;THIS OPERATION MOVES TAPEIN REVERSE DIRECTION
	TB.DOP==1B3		;THIS IS A DATA OPERATION
	TB.SPC==1B4		;THIS IS A SPACE OPERATION
	TB.RD==1B5		;THIS IS A READ
	TB.ERA==1B6		;ERASE OPERATION
	TB.TM==1B7		;WRITE TAPE MARK
	TB.NFC==1B8		;DON'T LOAD FRM COUNT WHEN DOING OPERATION
	TB.REW==1B9		;OPERATION IS A REWIND


;BITS 15,16,17 CONTAIN AN INDEX TO RTYBPT TO TELL US HOW
;TO RETRY AN OPERATION (0 IF NO RETRY)

;BITS 30-35 CONTAIN THE EQUIVALENT TM02 FUNCTION

TM2FTB:	1B0			;0- ILLEGAL
	TB.DOP!TB.RD!TB.NFC!2B17!DF.RDF ;1- READ FORWARD (IRFRED)
	1B0			;2- ILL (RD FMT)
	TB.WRT!TB.DOP!1B17!DF.WTF ;3- WRITE FORWARD (IRFWRT)
	1B0			;4- ILL (WRT FMT)
	1B0			;5- ILL (SEEK)
	TB.SPC!DF.SPF 		;6- SPCE FORWARD
	TB.REV!TB.SPC!DF.SPR	 ;7- SPCE REVERSE
	TB.WRT!TB.TM!6B17!DF.WTM ;10- WRITE TM
	TB.WRT!TB.ERA!TB.NFC!DF.ERA ;11- ERASE
	TB.NFC!TB.REW!DF.REW 	;12- REWIND
	TB.NFC!DF.UNL		 ;13- UNLOAD
	TB.REV!TB.DOP!TB.RD!TB.NFC!4B17!DF.RDR ;14- READ REVERSE
	1B0			;15- ILL (RECOVERY RD)
	1B0			;16- ILL (USED FOR END OF RECOVERY ACTION)
	1B0			;17- ILL (USED FOR CHECK POSITION ACTION)


;CONVT SOFTWARE MODE CODE TO TM02/3 FMT CODE (1B0 IS ILLEGAL)
;LH IS #FRAMES/BYTE (0 MEANS FRAMES=BYTES), RH IS TM02 FORMAT TYPE
MTBFMT:	1B0			;0 - ILLEGAL FMT
	5,,0			;1 - COR DMP (LH MEANS 5 FRAMES PER BYTE)
	1B0			;2 - SIXBIT (7TRK) ILLEGAL
	2			;3 - 7-BIT (ASCII)
	3			;4 - 8-BIT (COMPAT)

;CONVT SOFTWARE DENS CODE TO TM02/3 DENSITY CODE (1B0 IS ILLEGAL)
MTBDEN:	1B0			;0 - ILLEGAL DEN
	0			;1 - 200BPI
	1			;2 - 556BPI
	2			;3 - 800BPI
	4			;4 - 1600BPI

;RETRY TABLES TO TELL HOW TO RETRY

RTYBPT:	0			;ILLEGAL RETRY
	POINT 4,TBRWRT		;WRITE RETRY
	POINT 4,TBRRF		;READ FORWARD RETRY
	POINT 4,TBRRFC		;READ FORWARD TAPE CLEAN
	POINT 4,TBRRR		;READ REVERSE RETRY
	POINT 4,TBRRRC		;READ REVERSE TAPE CLEAN
	POINT 4,TBRWTM		;WRITE TAPE MARK
	0			;ILLEGAL

;THE FOLLOWING MACROS HELP ME GET AROUND SOME SHORTCOMINGS IN MACRO:
;NOTE: THE MACRO'S MUST BE FIXED IN THE UNLIKELY EVENT THAT
;SOMEBODY WANTS TO CHANGE TO A BYTE SIZE WHICH DOESN'T GO
;EVENLY INTO 36(10). RIGHT NOW IT'S 4.

	DEFINE FOO (XXA) <
		WD==0
		BYC==0
		ZZ==0		;FLIP-FLOP
	IRP XXA,<
	IFE ZZ,<RP==XXA>
	IFN ZZ,<FOO1 RP,XXA>
	ZZ==ZZ+1
	IFE ZZ-2,<ZZ==0>>
	IFN BYC,<EXP WD>>

	DEFINE FOO1 (A1,A2) <
	REPEAT A1,<
		WD==WD+<A2>B<4*BYC+3>
		BYC==BYC+1
	IFGE BYC-^D9, <
			EXP WD
			WD==0
			BYC==0>>>

TBRWRT:	BYTE (4) IRFBSB,IRFERG,17,IRFWRT,16
				;WRITE RETRY - SPACE REVERSE, ERASE, CHECK POSITION, WRITE
TBRWTM:	BYTE (4) IRFBSB,IRFERG,17,IRFWTM,16
			;WTM RETRY - SPACE REVERSE, ERASE, CHECK POS, WTM, EOR
TBRRF:	BYTE (4) IRFBSB,17,IRFRED,16
				;READ FORWARD RETRY - SPACE REVERSE, CHECK POSITION, READ FORWARD
TBRRR:	BYTE (4) IRFFSB,17,IRFRDR,16
				;READ REVERSE RETRY - SPACE FORWARD, CHECK POSITION, READ REVERSE

TBRRFC:	FOO<CLNREC+1,IRFBSB, CLNREC,IRFFSB, 1,17, 1,IRFRED, 1,16>
				;RD FORWARD TAPE CLEAN: 6 SP REVERSE, 5 SP FORWARD, CHECK POSITION, RD FORWARD
TBRRRC:	FOO<CLNREC,IRFBSB, CLNREC+1,IRFFSB, 1,17, 1,IRFRDR, 1,16>
				;RD REVERSE TAPE CLEAN: 5 SP REVERSE, 6 SP FORWARD, CHECK POSITION, RD REVERSE
	SUBTTL End of PHYM2

	TNXEND
	END
