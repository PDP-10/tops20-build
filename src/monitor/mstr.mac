; UPD ID= 8556, RIP:<7.MONITOR>MSTR.MAC.14,  11-Feb-88 11:03:34 by GSCOTT
;TCO 7.1218 - Update copyright date.
; UPD ID= 8426, RIP:<7.MONITOR>MSTR.MAC.13,   4-Feb-88 13:32:04 by GSCOTT
;TCO 7.1210 - Set STROFF normally not dumpable.
; UPD ID= 8402, RIP:<7.MONITOR>MSTR.MAC.12,   2-Feb-88 15:04:03 by RASPUZZI
;TCO 7.1206 - Redo part of TCO 7.1030. Make new TRVAR variables be last.
; UPD ID= 284, RIP:<7.MONITOR>MSTR.MAC.11,  11-Nov-87 10:59:59 by MCCOLLUM
;TCO 7.1129 - Save UDB address at MSTRS2 to prevent ILMNRFs.
; UPD ID= 280, RIP:<7.MONITOR>MSTR.MAC.10,  10-Nov-87 16:45:48 by MCCOLLUM
;TCO 7.1122 - Fix up TRVAR variables for call to DISMES in MSTD50
; UPD ID= 250, RIP:<7.MONITOR>MSTR.MAC.9,   4-Nov-87 16:42:52 by MCCOLLUM
;TCO 7.1112 - Fix MSTDIS to disallow dismount of Login Structure.
;             Make DEVSTR global. Fix MSTSSS to check against LGSIDX.
;             Return right bits for system structure in MSTGSS.
;             Set right bits for system structure in SNDUSG
; UPD ID= 216, RIP:<7.MONITOR>MSTR.MAC.8,  27-Oct-87 15:27:31 by MCCOLLUM
;More of TCO 7.1079 - Change a CAIN to a CAIE
; UPD ID= 205, RIP:<7.MONITOR>MSTR.MAC.7,  23-Oct-87 15:30:40 by GSCOTT
;TCO 7.1081 - Run SETSPD if structure set dumpable, return MS%DMP, change
; name of routine FNDSTR to FNDSTD so that it can be made globular.
; UPD ID= 178, RIP:<7.MONITOR>MSTR.MAC.6,  21-Oct-87 17:02:01 by MCCOLLUM
;TCO 7.1079 - Move the STROFF BUGCHK back to STROFL from CKSTOF
; UPD ID= 139, RIP:<7.MONITOR>MSTR.MAC.5,  25-Sep-87 10:27:51 by MCCOLLUM
;More of TCO 7.1063 - Load SDB address from STRTAB in STROFL.
; UPD ID= 131, RIP:<7.MONITOR>MSTR.MAC.4,  23-Sep-87 15:45:41 by MCCOLLUM
;TCO 7.1063 - Check for STRX10 in .MSHOM and .MSIMC. Return STRX10 in
;             .MSGSS. Add routine CKSTOF and modify STROFL.
; UPD ID= 59, RIP:<7.MONITOR>MSTR.MAC.3,   3-Aug-87 10:28:02 by RASPUZZI
;TCO 7.1030 - Have SNDUSG and SNDEND use global job numbers when sending
;and IPCF message to MOUNTR.
; *** Edit 7464 to MSTR.MAC by LOMARTIRE on 29-Apr-87, for SPR #21438
; Rework CFS structure tokens and structure create/mount handling 
; *** Edit 7430 to MSTR.MAC by MCCOLLUM on 31-Mar-87
; If the structure limit has been reached in MAKSDB, return the MSTX51 error. 
; *** Edit 7359 to MSTR.MAC by LOMARTIRE on 25-Aug-86
; Fix minor bug in edit 7352 
; *** Edit 7337 to MSTR.MAC by LOMARTIRE on 23-Jul-86, for SPR #21239
; Prevent MDDJFN BUGHLTs 
; *** Edit 7312 to MSTR.MAC by LOMARTIRE on 3-Jun-86
; Take MS%SVD out from under DEBUG conditional 
; *** Edit 7216 to MSTR.MAC by GRANT on 23-Dec-85, for SPR #20902
; Even if home blocks are not good, have MSTR% return the data anyway 
; *** Edit 7190 to MSTR.MAC by GRANT on 12-Nov-85
; Within MSTR%, use TTMSG% instead of SOUT% to prevent blocking forever 
; UPD ID= 2125, SNARK:<6.1.MONITOR>MSTR.MAC.72,   5-Jun-85 09:59:10 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 1962, SNARK:<6.1.MONITOR>MSTR.MAC.71,  13-May-85 09:16:39 by LOMARTIRE
;TCO 6.1.1373 - Record new MID in the UDB and SDB when homeblocks are changed
; UPD ID= 1822, SNARK:<6.1.MONITOR>MSTR.MAC.70,  24-Apr-85 20:00:47 by MCCOLLUM
;TCO 6.1.1238 - Fix BUG. documentation
; UPD ID= 1681, SNARK:<6.1.MONITOR>MSTR.MAC.69,  25-Mar-85 12:05:00 by LOMARTIRE
;TCO 6.1.1286 - Return new MS%IAC if offline due to homeblock checking
; UPD ID= 1586, SNARK:<6.1.MONITOR>MSTR.MAC.68,   5-Mar-85 10:43:36 by GRANT
;More TCO 6.1.1220 - Put check for MS%SVD under debug
; UPD ID= 1564, SNARK:<6.1.MONITOR>MSTR.MAC.67,  25-Feb-85 12:32:04 by GRANT
;TCO 6.1.1220 - In MSTRS2, check for MS%SVD
; UPD ID= 1532, SNARK:<6.1.MONITOR>MSTR.MAC.66,  19-Feb-85 10:11:12 by LOMARTIRE
;TCO 6.1.1194 - Do not return MSTX44 for failing mount - use what is returned
; UPD ID= 1281, SNARK:<6.1.MONITOR>MSTR.MAC.65,   7-Jan-85 08:35:24 by GRANT
;TCO 6.1.1116 - In MSTRS2, don't check for PS:, use MS%2PT returned by PHYSIO.
; UPD ID= 1001, SNARK:<6.1.MONITOR>MSTR.MAC.64,   7-Nov-84 15:05:28 by MOSER
;MORE 6.2196 - MAKE IT WORK FOR .MSRUS TOO!
; UPD ID= 5043, SNARK:<6.MONITOR>MSTR.MAC.63,  30-Oct-84 21:41:01 by MOSER
;TCO 6.2196 - SAVE MITANENCE ID FOR MSRUS/MSRNU
; UPD ID= 4936, SNARK:<6.MONITOR>MSTR.MAC.62,  15-Oct-84 13:07:34 by GRANT
;The assembly switch CFSCOD has been eliminated
; UPD ID= 4859, SNARK:<6.MONITOR>MSTR.MAC.61,  20-Sep-84 11:14:11 by MCLEAN
;FIX PROBLEM WITH STROF BUGCHK
; UPD ID= 4739, SNARK:<6.MONITOR>MSTR.MAC.60,  24-Aug-84 09:41:31 by PAETZOLD
;TCO 6.2191 - Change unsafe SETJSB calls to MAPJSB.
; UPD ID= 4545, SNARK:<6.MONITOR>MSTR.MAC.59,  15-Jul-84 21:34:01 by PURRETTA
;Update copyright notice
; UPD ID= 4333, SNARK:<6.MONITOR>MSTR.MAC.58,  13-Jun-84 21:28:06 by MCLEAN
;FIX CALLS TO ASCSIX SO THAT YOU CAN'T HAVE A NULL NAME
; UPD ID= 4330, SNARK:<6.MONITOR>MSTR.MAC.57,  13-Jun-84 14:17:01 by MCLEAN
;tco 6.2096 FIX MSTX36 ERRORS THAT ARE BOGUS BECAUSE JFN ISN'T ASSIGNED
; UPD ID= 4276, SNARK:<6.MONITOR>MSTR.MAC.56,  30-May-84 21:34:54 by MCLEAN
;ADD SUPPORT FOR TRECPP
; UPD ID= 4222, SNARK:<6.MONITOR>MSTR.MAC.55,  15-May-84 16:26:13 by MOSER
;TCO 6.2038 - ALLOW PROPER STORING OF HOMSER FOR MULTI-PACK PS
; UPD ID= 4139, SNARK:<6.MONITOR>MSTR.MAC.54,  25-Apr-84 14:49:49 by MCLEAN
;TCO 6.2048 ITRAP ON FAILURE OF MSTRHB AT MSTRS4 SO YOU DON'T
;GET A GOOD RETURN
; UPD ID= 3960, SNARK:<6.MONITOR>MSTR.MAC.53,  23-Mar-84 13:05:30 by PAETZOLD
;More TCO 6.1989 - .MSINI length is different
; UPD ID= 3932, SNARK:<6.MONITOR>MSTR.MAC.52,  14-Mar-84 20:05:41 by PAETZOLD
;TCO 6.1989 - Check arg block length in MSTMNT.
; UPD ID= 3803, SNARK:<6.MONITOR>MSTR.MAC.51,  29-Feb-84 01:44:31 by TGRADY
;IMPLEMENT GLOBAL JOB NUMBERS
; -IN MSTJOB, ALWAYS RETURN LOCAL INDEX FOR GLOBAL JOB NUMBER, CONVERT GLOBALS
;  VIA GL2LCL FOR NON-SELF JOBS.
; -In MSGU10, return the Global job number for each job that has a structure
;  Mounted, is connected, or accessing it.  Since we already have the other
;  Job's JSB mapped, cheat by getting the global job number from there,
;  rather than using the porker LCL2GL.
; UPD ID= 3499, SNARK:<6.MONITOR>MSTR.MAC.50,  20-Jan-84 16:12:44 by MOSER
;TCO 6.1944 ADD .MSDSH AND .MSDSN TO .MSRUS AND .MSRNU
; UPD ID= 3319, SNARK:<6.MONITOR>MSTR.MAC.49,  14-Dec-83 17:16:28 by MILLER
;TCO 6.1452. Use MSTX44 when CFSSMT fails
; UPD ID= 3248, SNARK:<6.MONITOR>MSTR.MAC.48,   4-Dec-83 19:55:26 by MILLER
;Code clean up around MSTM70
; UPD ID= 3246, SNARK:<6.MONITOR>MSTR.MAC.47,   3-Dec-83 20:13:12 by MILLER
;TCO 6.1452. Shuffle CFS code in MOUNT code to cover INIT case
; UPD ID= 3226, SNARK:<6.MONITOR>MSTR.MAC.46,  28-Nov-83 20:33:41 by TBOYLE
;TCO 6.1876. MSTR: New parameters for .MSTRUS: .MSRLS and .MSRSS
; UPD ID= 3093, SNARK:<6.MONITOR>MSTR.MAC.45,   3-Nov-83 08:09:09 by MILLER
;TCO 6.1452. Fix typeo in MSTCSM code
; UPD ID= 2977, SNARK:<6.MONITOR>MSTR.MAC.44,   4-Oct-83 07:17:10 by GRANT
;Typo in previous edit
; UPD ID= 2967, SNARK:<6.MONITOR>MSTR.MAC.43,   3-Oct-83 08:23:48 by MILLER
;TCO 6.1814. Bypass OFN update during dismount if structure off-line
; UPD ID= 2956, SNARK:<6.MONITOR>MSTR.MAC.42,  28-Sep-83 16:39:37 by MOSER
;TCO 6.1727 - FIX MSTR HANG
; UPD ID= 2785, SNARK:<6.MONITOR>MSTR.MAC.41,   2-Aug-83 15:50:11 by WEETON
;TCO 6.1611 - Make MSTR return MSTX43 if attempting to dismount a DA%INI str.
; UPD ID= 2541, SNARK:<6.MONITOR>MSTR.MAC.40,  31-May-83 14:03:03 by MILLER
;Fix errors in structure creates
; UPD ID= 2419, SNARK:<6.MONITOR>MSTR.MAC.39,   4-May-83 12:04:14 by MILLER
;TCO 6.1620. Don't set MS%2PT for PS:
; UPD ID= 2385, SNARK:<6.MONITOR>MSTR.MAC.38,  29-Apr-83 15:10:02 by MAYO
;TCO 6.1622 - Fix STOSTR's handling of bytepointers that aren't -1,,foo
; UPD ID= 2328, SNARK:<6.MONITOR>MSTR.MAC.36,  22-Apr-83 04:28:43 by WACHS
;TCO 6.1620 - Light MS%2PT
; UPD ID= 1645, SNARK:<6.MONITOR>MSTR.MAC.35,  12-Jan-83 15:22:41 by MILLER
;TCO 4.1452. .MSCSM is a privileged function
; UPD ID= 1643, SNARK:<6.MONITOR>MSTR.MAC.34,  12-Jan-83 08:11:54 by MILLER
;TCO 6.1452 some more. Fix some typeos
; UPD ID= 1641, SNARK:<6.MONITOR>MSTR.MAC.33,  11-Jan-83 19:57:36 by MILLER
;TCO 6.1452. Add .MSCSM to MSTR
; UPD ID= 1640, SNARK:<6.MONITOR>MSTR.MAC.32,  11-Jan-83 17:53:12 by MILLER
;TCO 6.1094. Return MS%EXC in status
; UPD ID= 1626, SNARK:<6.MONITOR>MSTR.MAC.31,   6-Jan-83 16:42:49 by MILLER
;Undo prevsious edit. Do the check in CFSSRV instead!
; UPD ID= 1623, SNARK:<6.MONITOR>MSTR.MAC.30,   6-Jan-83 16:08:28 by MILLER
;TCO 6.1094. Check if this node must do exclusive mounts
; UPD ID= 1614, SNARK:<6.MONITOR>MSTR.MAC.29,   4-Jan-83 11:05:57 by MILLER
;TCO 6.1094. Do CFS exclusive mount on either MS%EXL or MS%XCL
; UPD ID= 1522, SNARK:<6.MONITOR>MSTR.MAC.28,   8-Dec-82 17:17:57 by MOSER
;TCO 6.1408 - ALLOW MOUNT IF BACKUP ROOT-DIRECTORY BAD AND MS%IGN
; UPD ID= 1499, SNARK:<6.MONITOR>MSTR.MAC.27,   1-Dec-82 12:06:28 by MOSER
;TCO 6.1174 - PREVENT MAPBT1 BUGHLT
; UPD ID= 1410, SNARK:<6.MONITOR>MSTR.MAC.26,   3-Nov-82 16:37:02 by MOSER
;TCO 6.1330 - RETURN MS%PS WHEN APPROPRIATE
; UPD ID= 1314, SNARK:<6.MONITOR>MSTR.MAC.25,   9-Oct-82 13:14:07 by MILLER
;More TCO 6.1094. Move call to CFSSDM to before call to CLRSTR
; UPD ID= 1238, SNARK:<6.MONITOR>MSTR.MAC.24,  24-Sep-82 12:32:45 by LEACHE
; TCO 6.1273 Add MS%ASG
; UPD ID= 1199, SNARK:<6.MONITOR>MSTR.MAC.23,  20-Sep-82 14:58:10 by MILLER
;TCO 6.1094. Store alias name in SDBALS is appropriate
; UPD ID= 1171, SNARK:<6.MONITOR>MSTR.MAC.22,  13-Sep-82 19:49:15 by MILLER
;TCO 6.1094. Add CFS resource management
; UPD ID= 1156, SNARK:<6.MONITOR>MSTR.MAC.21,   8-Sep-82 13:20:54 by HAUDEL
;MORE TCO 6.1256 - CORRECT TYPO
; UPD ID= 1154, SNARK:<6.MONITOR>MSTR.MAC.20,   7-Sep-82 14:16:49 by HAUDEL
;TCO 6.1256 - ADD STROFF BUGCHK 
; UPD ID= 98, SNARK:<5.MONITOR>MSTR.MAC.19,  12-Aug-81 13:31:59 by PAETZOLD
;TCO 5.1446 - FIX COPYING OF HOME BLOCKS
; UPD ID= 2194, SNARK:<5.MONITOR>MSTR.MAC.18,  12-Jun-81 12:20:28 by MOSER
;TCO 5.1369 Assign a structure to the mounting job when MS%XCL is specified
; on a mount rather than leaving the structure in initialize mode.
; UPD ID= 1977, SNARK:<5.MONITOR>MSTR.MAC.17,  11-May-81 13:36:08 by MOSER
; TCO 5.1320 - Don't crash if a bad job number is specified on .MSIMC
; UPD ID= 1815, SNARK:<5.MONITOR>MSTR.MAC.16,  16-Apr-81 16:56:14 by MOSER
;TCO 5.1285 - CORRECTLY SEND STRUCTURE STATUS TO DEVICE ALLOCATOR.
; UPD ID= 1021, SNARK:<5.MONITOR>MSTR.MAC.15,  16-Sep-80 15:44:31 by GRANT
;Change MONX01 to MONX05 in MAKSDB routine
; UPD ID= 1009, SNARK:<5.MONITOR>MSTR.MAC.14,  11-Sep-80 18:31:13 by GRANT
;Change many MONX01 to MONX02
; UPD ID= 995, SNARK:<5.MONITOR>MSTR.MAC.13,   9-Sep-80 12:19:43 by MOSER
;TCO 5.1141 - SEND STRUCTURE STATUS BITS TO MOUNTR
; UPD ID= 966, SNARK:<5.MONITOR>MSTR.MAC.12,  25-Aug-80 16:28:30 by ENGEL
;TCO 5.1136 - ADD DEVLKK
; UPD ID= 707, SNARK:<5.MONITOR>MSTR.MAC.11,  26-Jun-80 13:38:41 by SCHMITT
;TCO 5.1083 - UNLOCK JSSTLK AFTER ERROR RETURNS FROM GTSTOF
; UPD ID= 665, SNARK:<5.MONITOR>MSTR.MAC.7,  16-Jun-80 18:36:19 by LYONS
;BUG: IF ACJ REFUSES STRUCTURE MOUNT, STRUCTURE IS NOT UNLOCKED
; UPD ID= 663, SNARK:<5.MONITOR>MSTR.MAC.6,  16-Jun-80 17:23:35 by KONEN
;TCO 5.1063 - REMOVE REQUIREMENT OF PS: NAME ON SYSTEM STRUCTURE
; UPD ID= 619, SNARK:<5.MONITOR>MSTR.MAC.5,   9-Jun-80 18:00:30 by LYONS
;TCO 5.1062 Add MS%RWS and MS%RWD to the .MSSSS and .MGSSS calls
; UPD ID= 613, SNARK:<5.MONITOR>MSTR.MAC.3,   6-Jun-80 16:34:29 by KONEN
;TCO 5.1061 -- Add STROFL subroutine which checks for structure off-line
; UPD ID= 360, SNARK:<4.1.MONITOR>MSTR.MAC.45,  26-Mar-80 11:06:50 by DBELL
;TCO 4.1.1119 - MAKE CHANGES NECESSARY TO SUPPORT RP20 DISKS
;<4.MONITOR>MSTR.MAC.44, 30-Oct-79 13:41:01, Edit by KONEN
;CORRECT STRUCTURE ACCOUNTING RECORD
;<4.MONITOR>MSTR.MAC.43, 29-Oct-79 15:26:18, Edit by KONEN
;BAD IDEA, CHANGE TIMES BACK TO GTAD UNITS
;<4.MONITOR>MSTR.MAC.42, 20-Sep-79 17:07:41, EDIT BY HALL
;MSTMNT,MSTRUS,MSTGSS - CALL BLTMU1/BLTUM1 TO APPLY PCS IF NECESSARY
;<4.MONITOR>MSTR.MAC.41, 13-Sep-79 09:16:30, Edit by KONEN
;CHANGE TIMES FOR USAGE TO MILLISECONDS, RATHER THAN GTAD UNITS
;<4.MONITOR>MSTR.MAC.40, 11-Sep-79 10:39:01, Edit by KONEN
;CORRECT TCO 4.2431
;<4.MONITOR>MSTR.MAC.39,  7-Sep-79 04:52:52, EDIT BY R.ACE
;ADD COMMENT IN MSTDIS
;<4.MONITOR>MSTR.MAC.38, 30-Aug-79 14:22:50, EDIT BY SCHMITT
;TCO 4.2431 - CHANGE STRST CALL TO DEVST IN MSTDIS
;<4.MONITOR>MSTR.MAC.37, 27-Aug-79 16:02:22, EDIT BY ZIMA
;TCO 4.2423 - INCLUDE MS%LIM IN MSGMSK TO ALLOW RETURNING IT
;<4.MONITOR>MSTR.MAC.36, 23-Jul-79 16:51:00, Edit by KONEN
;ALLOW DISMOUNT OF REGULATED STRUCTURE EVEN IF USER ACCESS'ING IT
;<4.MONITOR>MSTR.MAC.35,  7-Jul-79 18:46:49, Edit by KONEN
;REMOVE NOSKED DURING SETTING UP OF DIRECTORIES
;<4.MONITOR>MSTR.MAC.34, 30-May-79 11:00:59, Edit by LCAMPBELL
; Check for C(FILSTS)=0, not just presence of NAMEF or ASGF
;<4.MONITOR>MSTR.MAC.33, 29-May-79 14:10:42, Edit by LCAMPBELL
; When decr mount count, only check JFNs with NAMEF or ASGF on
;<4.monitr>mstr.mac.32, 15-may-79 9:20:32, edit by schmitt
;fix for illegal read when .msrnu arg blk is less than 6 words
;<4.MONITOR>MSTR.MAC.29, 26-Apr-79 11:19:57, Edit by KONEN
;<4.MONITOR>MSTR.MAC.28, 23-Apr-79 16:46:17, Edit by KONEN
;CHANGE INITING JOB IN SDB TO INITING FORK, REMOVE DEVLCK IN STRINI
;<4.MONITOR>MSTR.MAC.26, 16-Apr-79 11:55:36, Edit by KONEN
;SEND STRUCTURE REMOVAL INFO CORRECTLY TO DEVICE ALLOCATOR
;<4.MONITOR>MSTR.MAC.25,  5-Apr-79 11:05:53, Edit by MCLEAN
;REMOVE FIRST ARGUMENT FROM GTOKM MACRO
;<4.MONITOR>MSTR.MAC.24, 29-Mar-79 09:03:06, Edit by KONEN
;<4.MONITOR>MSTR.MAC.23, 21-Mar-79 14:06:04, EDIT BY KIRSCHEN
;ADD TEMPORARY FIX FOR DEADLY EMBRACE IN STRINI
;<4.MONITOR>MSTR.MAC.22, 19-Mar-79 13:32:56, EDIT BY KIRSCHEN
;DO NOT PERMIT INTERRUPTS WITH FREE SPACE ASSIGNED IN MSTMNT
;<4.MONITOR>MSTR.MAC.21, 12-Mar-79 10:33:05, Edit by KONEN
;SEND ALL USAGE INFO TO DEVICE ALLOCATOR
;<4.MONITOR>MSTR.MAC.20,  7-Mar-79 15:32:18, Edit by MCLEAN
;FIX GETOK FOR INCREMENT STRUCTURE COUNT TO GIVE DEVICE DESIG CORRECTLY
;<4.MONITOR>MSTR.MAC.19,  4-Mar-79 18:34:48, EDIT BY KONEN
;UPDATE COPYRIGHT FOR RELEASE 4
;<4.MONITOR>MSTR.MAC.18,  8-Feb-79 13:42:29, Edit by KONEN
;PROHIBIT MOUNT OF STR WITH ALIAS WHICH IS IN SYSTEM LOGICAL NAMES TABLE
;<4.MONTOR>MSTR.MAC.17, 17-Jan-79 23:45:54, Edit by MCLEAN
;FIX GETOK SO IT IS DEVICE DESIGNATOR
;<4.MONITOR>MSTR.MAC.16, 15-Jan-79 22:33:38, EDIT BY GILBERT
;FIX VERSION SKEW BETWEEN MCLEAN AND KONEN.
;<4.MONITOR>MSTR.MAC.15, 15-Jan-79 14:08:52, Edit by KONEN
;ADD .MSIIC FUNCTION
;<4.MONITOR>MSTR.MAC.14, 14-Jan-79 20:02:09, Edit by MCLEAN
;FIX GETOK SO IT ONLY HAS ONE ARGUMENT
;<4.MONITOR>MSTR.MAC.13, 10-Jan-79 12:59:45, EDIT BY MILLER
;MAKE SIXASC INTERNAL (USED BY TAPE)
;<4.MONITOR>MSTR.MAC.12,  8-Jan-79 06:52:07, EDIT BY GILBERT
;TCO 4.2155 - Implement hidden symbol tables:
;	Change the JSVAR macro to JSBVAR.
;<4.MONITOR>MSTR.MAC.11,  5-Jan-79 12:49:03, Edit by KONEN
;FIX SECG37 FROM MSTRUS
;<4.MONITOR>MSTR.MAC.10, 21-Dec-78 10:18:03, Edit by KONEN
;<4.MONITOR>MSTR.MAC.9,  16-Nov-78 14:13:46, Edit by KONEN
;ADD MOUNT/DISMOUNT CODE AS ARGUMENT TO DISMES CALL
;<KONEN>MSTR.MAC.4, 11-Aug-78 12:06:49, Edit by KONEN
;<KONEN>MSTR.MAC.38,  2-Aug-78 18:17:27, Edit by KONEN
;ALLOW OPERATOR OR WHEEL TO INCREMENT MOUNT COUNT. ALLOW SETTING OF
; PUBLIC BIT OF STRUCTURE STATUS. DISALLOW DECREMENT OF MOUNT COUNT
; WHILE JFN'S ASSIGNED, CONNECTED OR ACCESSING THE STRUCTURE.
;<4.MONITOR>MSTR.MAC.7, 16-Sep-78 14:30:32, EDIT BY MILLER
;RELEASE STRLOK AS SOON AS SDB IS CLEANED UP ON A DISMOUNT
;<4.MONITOR>MSTR.MAC.6, 15-Sep-78 13:43:25, Edit by MCLEAN
;ANOTHER NOINT/NOSKED
;<4.MONITOR>MSTR.MAC.5, 15-Sep-78 13:39:27, Edit by MCLEAN
;INSERT MOUNT COUNT INCREMENT/DECREMENT GETOK
;<4.MONITOR>MSTR.MAC.4, 15-Sep-78 13:34:19, Edit by MCLEAN
;REMOVE EXTRANEOUS NOINT/OKINT IN INCMNT
;<4.MONITOR>MSTR.MAC.3, 14-Aug-78 16:39:37, Edit by HEMPHILL
;TCO 1984 -- FIX SECNX B PROCESSOR BUG
;<4.MONITOR>MSTR.MAC.2, 10-Jul-78 18:56:30, Edit by HEMPHILL
;TCO 1935--MAKE .MSRNU REPORT SWAPPING PAGES FOR STRUCTURE, NOT
; SWAPPING SECTORS PER UNIT
;<4.MONITOR>MSTR.MAC.1, 22-Jun-78 15:52:09, EDIT BY MILLER
;LOCK STRLOK DURING A DISMOUNT

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


	SEARCH MONSYM,PROLOG,PHYPAR
	TTITLE (MSTR,,< - MOUNTABLE STRUCTURE MONITOR CALL>)
	SWAPCD

; THIS FILE CONTAINS THE CODE TO IMPLEMENT THE MSTR JSYS
; NO SPECIAL AC DEFINITIONS ARE REQUIRED FOR THIS MODULE.

EXTN <HOMRXB,HOMSNM,HM1BLK,HM2BLK>

; MSTR - STRUCTURE MANIPULATION CALL


.MSTR::	MCENT			;MONITOR CONTEXT ENTRY

; GET AND VERIFY FUNCTION CODE, AND DISPATCH

	XCTU [ HRRZ T1,1 ]	;GET FUNCTION CODE FROM USER
	CAIL T1,0		;MAKE SURE FUNCTION IN RANGE
	CAILE T1,HGHFCN		; AND .LE. HIGHEST VALID FUNCTION CODE ?
	ITERR (MSTRX1)		;NO, RETURN "INVALID FUNCTION"
	HRRZ T2,MSTRTB(T1)	;YES, GET DISPATCH ADDRESS
	CALL (T2)		;GO PROCESS REQUESTED FUNCTION
	 ITERR ()		;FAILED, RETURN ERROR CODE TO USER
	MRETNG			;SUCCESS, RETURN TO USER

; TABLE OF DISPATCH ADDRESSES

MSTRTB:
%%X==.
	MSTRUS		;READ STATUS OF NEXT UNIT
	MSTRUS		;READ STATUS OF A UNIT
	MSTMNT		;MOUNT A STRUCTURE
	MSTDIS		;DISMOUNT A STRUCTURE
	MSTGSS		;GET STATUS OF A STRUCTURE
	MSTSSS		;SET STATUS OF A STRUCTURE
	MSTMNT		;INITIALIZE A STRUCTURE
	MSTIMC		;INCREMENT MOUNT COUNT FOR THE JOB
	MSTDMC		;DECREMENT MOUNT COUNT FOR THE JOB
	MSTGSU		;GET STRUCTURE USERS
	MSTHOM		;MODIFY HOME BLOCK
	MSTICF		;INCREMENT MOUNT COUNT FOR A FORK
	MSTDCF		;DECREMENT MOUNT COUNT FOR A FORK
	MSTOFL		;ALLOWS MDA TO REQUEST INTERRUPT ON A CHANNEL
	MSTIIC		;IGNORE MOUNT COUNT CHECK
	MSTCSM		;Change structure mount attribute
HGHFCN==.-%%X-1		;HIGHEST DEFINED FUNCTION
; .MSMNT/.MSINI - MOUNT/INITIALIZE A FILE STRUCTURE


; LOCAL VARIABLES --

MSTMNP==1		;PHYSICAL PAGE # OF PAGE USED TO READ HOME BLOCKS
MSTMNA==2		;VIRTUAL ADDRESS OF PAGE USED TO READ HOME BLOCKS
MSTMNE==3		;TEMPORARILY HOLDS CODE ON ERRORS, USED AS A LOCAL FLAG
MSTMNS==4		;STRUCTURE NUMBER
MSTMNB==5		;ADDRESS OF STRUCTURE DATA BLOCK
MSTMND==6		;SIXBIT STRUCTURE NAME
MDATSZ==7		;SIZE OF FREE BLOCK USED FOR LOCAL STORAGE

; ACCUMULATOR USAGE --
;
; Q1/ ADDRESS OF USER'S ARGUMENT BLOCK IN USER SPACE
; Q2/ FUNCTION TO PERFORM (.MSMNT OR .MSINI)
; Q3/ ADDRESS OF BLOCK HOLDING LOCAL VARIABLES
; P3/ ADDRESS OF USER'S ARGUMENT BLOCK IN MONITOR SPACE
; P4/ SIZE OF USER'S NON-OPTIONAL ARGUMENT BLOCK

; VERIFY THAT USER HAS REQUIRED CAPABILITIES ENABLED

MSTMNT:	STKVAR <NEWMID,BLADDR>		;Word to hold new media ID if created
	MOVE T1,CAPENB		;GET ENABLED CAPABILITIES
	TXNN T1,SC%WHL!SC%OPR	;WHEEL OR OPERATOR ENABLED NOW ?
	RETBAD (MSTRX2)		;NO, RETURN "WHEEL OR OPERATOR REQUIRED"

; COPY USER ARGUMENT BLOCK INTO MONITOR SPACE

	XCTU [ HLRZ P2,1 ]	;GET SIZE OF USER'S ARGUMENT BLOCK
	CAIN T2,.MSMNT		;ARE WE JUST MOUNTING?
	 CAIG P2,<<HOMTBL*<.MSTUN-.MSTCH+1>>+.MSTFL+1> ;LEGAL LENGTH?
	  SKIPA			;NOT .MSMNT OR LENGTH OK
           RETBAD (ARGX05)	;NO GIVE AN ERROR
	CAIN T2,.MSINI		;ARE WE INITIALIZING?
	 CAIG P2,<<.MSIFL-.MSINM+1>+<HOMTBL*<.MSIUN-.MSICH+1>>+<.MSISN-.MSIST+1>>
	  SKIPA			;NOT .MSINI OR LENGTH OK
           RETBAD (ARGX05)	;NO GIVE AN ERROR
	MOVEI T2,1(P2)		;ALLOW ONE WORD FOR FREE BLOCK HEADER
	NOINT			;PREVENT INTERRUPTS WITH SPACE ASSIGNED
	CALL ASGJFR		;ASSIGN FREE SPACE TO HOLD BLOCK
	 RETBAD (MONX02,<OKINT>) ;RETURN "INSUFFICIENT RESOURCES" - JSB FULL
	MOVEM T1,P1		;SAVE ADDRESS OF FREE BLOCK
	MOVEI P3,1(T1)		;COMPUTE STARTING ADDRESS OF ARG BLOCK
	UMOVE T2,T2		;GET ADDRESS OF ARG BLOCK IN USER SPACE (SOURCE)
	XMOVEI T3,0(P3)		;GET ADDRESS OF ARG BLOCK IN MONITOR (DEST)
	MOVE T1,P2		;GET COUNT TO TRANSFER
	CALL BLTUM1		;COPY USER'S ARGUMENT BLOCK INTO MONITOR SPACE
	; ..
	; ..

; CHECK SIZE OF ARGUMENT BLOCK

	XCTU [HRRZ Q2,1]	;GET FUNCTION TO PERFORM FROM THE USER
	UMOVE Q1,2		;GET ADDRESS OF USER ARGUMENT BLOCK
	HRRZ P4,.MSTNU(P3)	;GET NUMBER OF UNITS IN STRUCTURE
	SKIPG P4		;AT LEAST ONE UNIT SPECIFIED ?
	JRST [	MOVX T1,MSTRX3	;NO, GET "ARG BLOCK TOO SMALL" ERROR CODE
		JRST MNTER1 ]	;GO RELEASE ARG BLOCK SPACE AND RETURN ERROR
	CAILE P4,HOMTBL		;REASONABLE # OF UNITS?
	JRST [	MOVEI T1,MSTX35	;NO. GIVE ERROR
		JRST MNTER1]
	IMULI P4,.MSTNO		;COMPUTE LENGTH OF UNIT SPECIFIC INFO
	ADDI P4,.MSTUI		;ADD NUMBER OF OTHER WORDS
	CAIN Q2,.MSINI		;INITIALIZING THIS STRUCTURE ?
	JRST [	LOAD T4,MS%FCN,.MSTFL(P3) ;YES, GET REQUESTED FUNCTION
		CAIE T4,.MSCRE	;CREATING NEW FILE SYSTEM ?
		CAIN T4,.MSWHB	; OR WRITING HOME BLOCKS ?
		ADDI P4,.MSISN-.MSIST+1 ;YES, INCLUDE ID INFO IN COMPARISON
		JRST .+1]	;CONTINUE
	CAMGE P2,P4		;IS USER ARGUMENT BLOCK BIG ENOUGH ?
	JRST [	MOVX T1,MSTRX3	;NO, GET "ARG BLOCK TOO SMALL" ERROR CODE
		JRST MNTER1 ]	;GO RELEASE ARG BLOCK SPACE AND RETURN ERROR

; IF INITIALIZING, CHECK REQUESTED FUNCTION

	CAIE Q2,.MSINI		;INITIALIZING ?
	JRST MSTM10		;NO, GO ALLOCATE SPACE FOR LOCAL VARIABLES
	LOAD T1,MS%FCN,.MSIFL(P3) ;YES, GET FUNCTION REQUESTED
	CAIL T1,.MSCRE		;IS REQUESTED FUNCTION WITHIN
	CAILE T1,.MSRIX		; VALID RANGE ?
	JRST [	MOVX T1,MSTRX1	;NO, GET "INVALID FUNCTION" ERROR CODE
		JRST MNTER1 ]	;GO RELEASE ARG BLOCK SPACE AND RETURN ERROR

; CHECK THAT MOUNT IS EXCLUSIVE IF ERRORS WILL BE IGNORED

MSTM10:	MOVE T1,.MSTFL(P3)	;GET FLAGS FROM USER ARGUMENT BLOCK
	TXNE T1,MS%IGN		;IGNORING ERRORS ?
	TXNE T1,MS%XCL		; BUT NOT MOUNTED EXCLUSIVE ?
	SKIPA			;NO, PROCEED
	JRST [	MOVX T1,MSTRX1	;YES, GET "ILLEGAL FUNCTION" ERROR CODE
		JRST MNTER1]	;GO RELEASE SPACE AND RETURN ERROR

; ALLOCATE SPACE FOR LOCAL VARIABLES

	MOVEI T2,MDATSZ		;GET SIZE OF DATA BLOCK REQUIRED
	CALL ASGJFR		;ASSIGN JSB FREE SPACE
	 JRST [	MOVX T1,MONX02	;NO, GET "INSUFFICIENT RESOURCES" - JSB FULL
		JRST MNTER1 ]	;GO RELEASE ARG BLOCK SPACE AND RETURN ERROR
	MOVEM T1,Q3		;SAVE ADDRESS OF BLOCK RETURNED
	; ..
	; ..

; CHECK FOR A VALID STRUCTURE NAME

	CALL LCKDVL		;LOCK DEVICE LOCK UNTIL DEVICE TABLES MODIFIED
	SKIPN T1,.MSTAL(P3)	;GET ALIAS FOR STRUCTURE
	MOVE T1,.MSTNM(P3)	;NO ALIAS, GET STRUCTURE ID
	CALL CHKNAM		;GO CHECK NAME AND CONVERT TO SIXBIT
	 JRST MNTER3		;FAILED, RETURN ERROR
	MOVEM T1,MSTMND(Q3)	;SAVE SIXBIT DEVICE NAME

	CALL UNICHK		;GO CHECK THE UNIT SPECIFICATIONS
	 JRST MNTER3		;FAILED, UNLOCK DEVICE TABLE LOCK, RETURN ERROR

;[7464] If CFS, register the mount

;   IFN CFSCOD,<
	SETZM T2		;[7464]Shared
	MOVE T3,.MSTFL(P3)	;[7464]Get user's flags
	TXNE T3,MS%EXL!MS%XCL	;[7464]Exclusive?
	MOVEI T2,1		;[7464]
	MOVE T1,P3		;[7464]Get address of parameter block
	MOVEM Q3,BLADDR		;[7464]Save Local variable address 
	MOVE Q3,MSTMND(Q3)	;[7464]Get Alias
	CALL CFSSMI		;[7464](T1,T2,Q3/)Register it
	IFNSK.			;[7464] Failed
	 MOVE Q3,BLADDR		;[7464]Restore Q3
	 JRST MNTER3		;[7464]Rejected
	ENDIF.			;[7464]
	MOVE Q3,BLADDR		;[7464] Restore Q3
;   >	;IFN CFSCOD

	SETZM NEWMID		;Assume we are not creating new home blocks
	CAIE Q2,.MSINI		;ARE WE INITIALIZING THIS STRUCTURE ?
	JRST MSTM30		;NO, GO CHECK THE HOME BLOCKS
	LOAD T1,MS%FCN,.MSIFL(P3) ;YES, GET PARTICULAR FUNCTION REQUESTED
	CAIE T1,.MSCRE		;CREATING NEW FILE SYSTEM ?
	CAIN T1,.MSWHB		; OR WRITING NEW HOME BLOCKS ?
	JRST [	CALL MAKHOM	;YES, GO CREATE A PAIR OF NEW HOME BLOCKS
		 JRST MNTR4 	;[7464] Failed, return error
		MOVEM T1,NEWMID	;Success, save new media ID of new home blocks
		JRST .+1 ]	;NOW CHECK THE NEW HOME BLOCKS
MSTM30:	CALL HOMCHK		;GO READ THE HOME BLOCKS, FIX UP IF NEEDED
	 JRST MNTR4		;[7464] Failed, unlock device table lock, return ERROR
	MOVEM T1,MSTMNS(Q3)	;SAVE STRUCTURE NUMBER
	MOVE T2,STRTAB(T1)	;GET ADDRESS OF SDB OF THIS STRUCTURE
	MOVEM T2,MSTMNB(Q3)	;SAVE ADDRESS OF SDB
	SKIPE T1,NEWMID		;Did we create new home blocks?
	STOR T1,STRMI,(T2)	;Yes, save new media ID in SDB

; SET UP THE UNIQUE CODE FOR THIS STRUCTURE

	CALL LGTAD		;GET TIME AND DATE
	LSH T1,-8		;RIGHT JUSTIFY 5 DATE BITS, 10 TIME BITS
	SKIPN UCSEED		;IS THERE A SEED FOR THIS UNIQUE CODE ?
	HRRZM T1,UCSEED		;NO, STORE AN INITIAL UNIQUE CODE SEED
	AOS T1,UCSEED		;INCREMENT UNIQUE CODE
	LSH T1,STRNS		;SHIFT TO CORRECT POSITION
	ANDI T1,37777		;INSURE CODE IS LESS THAN 40000
				; (CODES ABOVE 40000 ARE FOR STRUCTURES MOUNTED
				;  AT SYSTEM STARTUP TIME)
	TRO T1,500000		;ADD "5B2" FIELD TO UNIQUE CODE
	MOVE T2,MSTMNB(Q3)	;GET ADDRESS OF SDB FOR THIS STRUCTURE
	STOR T1,STRUC,(T2)	;STORE UNIQUE CODE IN SDB
	MOVE T1,MSTMNS(Q3)	;GET THE STR NUMBER
	STOR T1,STRUS,(T2)	;PUT THE STRUCTURE NUMBER INTO STRUC ALSO
	; ..
	; ..

; ADD STRUCTURE TO DEVICE TABLES

	MOVEI T1,DVXST0		;GET OFFSET TO STRUCTURE PART OF TABLES
	ADD T1,MSTMNS(Q3)	;COMPUTE OFFSET FOR THIS STRUCTURE
	MOVX T3,D1%INI		;INDICATE STRUCTURE BEING INITED
	IORM T3,DEVCH1(T1)	;MARK THIS TEMPORARY STATUS OF STRUCTURE
	MOVE T3,MSTMND(Q3)	;GET SIXBIT STRUCTURE NAME
	MOVEM T3,DEVNAM(T1)	;STORE STRUCTURE NAME
	CAME T3,SDBNAM(T2)	;Mounted with an alias?
	MOVEM T3,SDBALS(T2)	;yes. Store alias name
	MOVE T3,MSTMNS(Q3)	;GET STRUCTURE NUMBER
	HRRM T3,DEVUNT(T1)	;SAVE "UNIT" NUMBER
	MOVX T3,D1%NIU		;CLEAR INDICATOR THAT THIS SLOT IS NOT
	ANDCAM T3,DEVCH1(T1)	;  NOW IN USE
	MOVE T3,FORKX		;GET CURRENT FORK NUMBER
	STOR T3,STRJB,(T2)	;INDICATE INITING FORK
	MOVE T3,.MSTFL(P3)	;[7464]Get user flag		
	TXNN T3,MS%EXCL!MS%XCL	;[7464]Exclusive?
	IFSKP.			;[7464] 
	 SETONE STEXL,(T2)	;[7464]Set exclusive in SDB
	ENDIF.			;[7464] 
	; ..


; IF INITIALIZING, ASSIGN THE INDEX BLOCK ADDRESSES AND GET ROOT-DIR OFN

	CAIE Q2,.MSINI		;INITIALIZING THIS STRUCTURE ?
	JRST MSTM50		;NO, GO GET AN OFN FOR THE ROOT-DIRECTORY
	LOAD T1,MS%FCN,.MSIFL(P3) ;YES, GET PARTICULAR FUNCTION REQUESTED
	CAIN T1,.MSRRD		;RECONSTRUCT ROOT-DIRECTORY ?
	JRST [	MOVE T1,MSTMNS(Q3) ;YES, GET STRUCTURE NUMBER
		CALL FILREC	;GO RECONSTRUCT THE ROOT-DIR
		 JRST [MOVX T1,MSTX29 ;FAILED, GET ERROR CODE
			JRST MNTER4 ] ;GO RETURN ERROR TO USER
		JRST MSTM50]	;GO FINISH MOUNTING STRUCTURE
	CAIE T1,.MSCRE		;CREATE NEW FILE-SYSTEM ?
	JRST MSTM50		;NO, GO FINISH MOUNTING STRUCTURE
	HRRZ T3,.MSINU(P3)	;YES, GET # OF UNITS IN STRUCTURE
	MOVEI T4,-1(T3)		;GET # OF UNITS - 1
	IMULI T4,.MSINO		;COMPUTE # OF ADDITIONAL PER-UNIT WORDS
	ADDI T4,.MSIFE(P3)	;ADD BASE OFFSET TO FE FILE SYSTEM ARGUMENT
	MOVE T2,(T4)		;GET # OF PAGES TO ALLOCATE FOR FE FILE SYSTEM
	MOVE T3,P4		;FIND NON-OPTIONAL PARAMTERE SIZE
	ADDI T3,.MSIFB-.MSIFI-2	;CHECK TO SEE IF BOOTSTRAP.BIN LIVES
	CAMGE P2,T3
	SKIPA T3,[NPGSBT]	;NOT SPECIFIED -- GET DEFAULT
	MOVE T3,.MSIFB-.MSIFE-2(T4) ;SPECIFIED GET USER'S REQUESTED SIZE
	MOVE T1,MSTMNS(Q3)	;GET THE STRUCTURE NUMBER
	CALL STRINI		;GO SET UP DIRECTORIES AND BIT TABLE ON NEW STR
	 JRST MNTER4		;FAILED, GO RELEASE SDB AND RETURN ERROR CODE
	JRST MSTM70		;GO GET A HANDLE ON THE INDEX TABLE
	; ..
	; ..

; GET AN OFN FOR THE ROOT-DIRECTORY ON THIS STRUCTURE

MSTM50:	MOVE T1,MSTMNS(Q3)	;GET STRUCTURE NUMBER
	CALL SETRDO		;GET AN OFN FOR THE ROOT-DIRECTORY
	 JRST [	MOVX T1,MSTRX8	;ERROR, GET "CANNOT GET OFN" ERROR CODE
		JRST MNTER4 ]	;GO RELEASE SDB AND RETUURN ERROR TO USER
	MOVE T1,MSTMNS(Q3)	;GET STRUCTURE NUMBER
	CALL MNTBTB		;OPEN THE BIT TABLE FILE
	 JRST [	MOVE T1,.MSTFL(P3) ;GET USER'S FLAGS
		TXNN T1,MS%IGN	;MOUNT DESPITE ERRORS ?
		JRST [	MOVX T1,MSTX12 ;GET "CANNOT OPEN BIT TABLE" ERROR CODE
			JRST MNTER5] ;RELEASE OFN OF ROOT-DIR AND RETURN ERROR
		MOVE T1,MSTMNS(Q3) ;YES, GET STRUCTURE NUMBER
		HRRZ T2,STRTAB(T1) ;POINT TO ITS SDB
		MOVX T4,MS%ASG	;FORBID ASSIGNING PAGES UNTIL CHECKD CAN
		IORM T4,SDBSTS(T2) ; RUN AND REBUILD THE BIT TABLE
		JRST .+1]	;CONTINUE TO MOUNT STRUCTURE

;IF IDXTAB EXISTS, GET AN OFN ON IT.  OTHERWISE, CREATE ONE AND
;GET AN OFN ON IT

MSTM70:	MOVE T1,MSTMNS(Q3)	;GET THE STRUCTURE NUMBER
	XMOVEI T4,FNDIDX	;Assume IDXTAB exists
	CAIN Q2,.MSINI		;ARE WE INITIALIZING THE STRUCTURE?
	JRST [	LOAD T2,MS%FCN,.MSIFL(P3) ;YES. WHAT ARE WE DOING?
		CAIE T2,.MSRIX	;REBUILDING IDXTAB?
		CAIN T2,.MSCRE	;NO. CREATING NEW FILE SYSTEM?
		XMOVEI T4,MAKIDX ;yes, create new IDXTAB
		JRST .+1]
	CALL 0(T4)		;GET OR CREATE IDXTAB FILE
	 JRST MNTER6		;FAILURE. GO RETURN ERROR TO CALLER

;CHECK ROOT-DIRECTORY

	MOVEI T1,ROOTDN		;GET NUMBER OF ROOT-DIRECTORY
	MOVE T2,MSTMNB(Q3)	;GET ADDRESS OF SDB FOR THIS STRUCTURE
	LOAD T3,STRUC,(T2)	;GET UNIQUE CODE
	HRL T1,T3		;BUILD DIR NUMBER
	CALL SETDIR		;MAP IN THE ROOT-DIRECTORY
	 JRST [	MOVX T1,MSTRX9	;COULD NOT MAP DIRECTORY, GET ERROR CODE
		JRST MNTER7 ]	;GO RELEASE SDB AND RETURN ERROR TO USER
	CALL BLKSCN		;CHECK DIRECTORY FOR CONSISTENCY
	 JRST [	CALL USTDIR	;ROOT-DIRECTORY BAD, UNLOCK THE DIRECTORY
		MOVX T1,MSTX10	;GET ERROR CODE
		JRST MNTER7 ]	;GO CLEAN UP AND RETURN ERROR TO USER
	CALL USTDIR		;GO UPDATE AND UNLOCK THE DIRECTORY

; SET UP THE INDEX TABLE

	CAIE Q2,.MSINI		;ARE WE INITIALIZING THE STRUCTURE?
	JRST MSTM75		;NO. SKIP THIS
	LOAD T1,MS%FCN,.MSIFL(P3) ;YES. SEE WHAT WE ARE DOING
	CAIE T1,.MSRIX		;REBUILDING IDXTAB?
	CAIN T1,.MSCRE		;NO. CREATING A NEW FILE SYSTEM?
	SKIPA			;REBUILD IDXTAB OR REFRESH
	JRST MSTM75		;NEITHER. DON'T INITIALIZE IDXTAB
	MOVE T1,MSTMNS(Q3)	;GET STRUCTURE NUMBER
	CALL IDXINI		;INITIALIZE INDEX TABLE
	 JRST [	MOVX T1,MSTX11	;COULD NOT INITIALIZE INDEX TABLE
		JRST MNTER7 ]	;RELEASE SDB AND RETURN ERROR CODE TO USER
	;..
	;..

; CHECK THE BIT TABLE, THE BACKUP ROOT-DIRECTORY, AND THE BAT BLOCKS

MSTM75:	MOVE T1,MSTMNS(Q3)	;GET STRUCTURE NUMBER
	MOVE T2,MSTMNB(Q3)	;ADDR OF SDB
	LOAD T3,STRBTB,(T2)	;OFN OF BITTABLE
	MOVEI T2,0		;NO FLAGS (DON'T TYPE CTY MESSAGES)
	SKIPE T3		;IF NO BITTABLE
	CALL CHKBT		;GO CHECK THE BIT TABLE
	JRST [	MOVX T1,MSTX30	;GET "BIT-TABLE-ERRORS" ERROR CODE
		MOVE T4,.MSTFL(P3) ;GET FLAGS FROM USER ARGUMENT BLOCK
		TXNN T4,MS%IGN	;IGNORE NON-FATAL ERRORS ?
		JRST MNTER7	;NO, RETURN ERROR CODE TO USER
		JRST .+1]	;YES, CONTINUE WITH MOUNT
	CAIE Q2,.MSINI		;ARE WE INITIALIZING THIS STR IN SOME WAY ?
	JRST MSTM80		;NO, GO CHECK THE BACKUP ROOT-DIR
	LOAD T1,MS%FCN,.MSIFL(P3) ;YES, GET THE PARTICULAR FUNCTION REQUESTED
	CAIN T1,.MSRRD		;RECONSTRUCTING ROOT-DIR ?
	JRST MSTM90		;YES, DO NOT CHECK BACKUP ROOT-DIR (NOT THERE!)
MSTM80:	MOVE T1,MSTMNS(Q3)	;GET STRUCTURE NUMBER
	CALL CHKBAK		;CHECK BACKUP COPY OF ROOT-DIRECTORY
	 JRST [	MOVX T1,MSTX13	;GET "BAD BACKUP ROOT-DIRECTORY" ERROR CODE
		MOVE T4,.MSTFL(P3) ;GET FLAGS FROM USER ARGUMENT BLOCK
		TXNN T4,MS%IGN	;IGNORE NON-FATAL ERRORS ?
		JRST MNTER7	;NO, RETURN ERROR CODE TO USER
		JRST .+1]	;YES, CONTINUE WITH MOUNT
MSTM90:	CALL ASGPAG		;GET A PAGE FOR READING BAT BLOCKS
	 JRST [	MOVX T1,MONX02	;GET "INSUFFICIENT RESOURCES" - JSB FULL
		JRST MNTER7 ]	;GO RELEASE BIT TABLE OFN AND RETURN ERROR
	MOVEM T1,MSTMNA(Q3)	;SAVE ADDRESS OF BAT BLOCK PAGE
	MOVE T2,T1		;COPY ADDRESS OF BAT BLOCK PAGE
	MOVE T1,MSTMNS(Q3)	;GET STRUCTURE NUMBER
	MOVE T3,.MSTFL(P3)	;GET FLAGS FROM USER ARGUMENT BLOCK
	AND T3,[MS%NFB]		;KEEP ONLY THE NO-FIX-BAT-BLOCK BIT IF SET
	CALL CHKBAT		;GO CHECK THE BAT BLOCKS
	MOVE T1,MSTMNA(Q3)	;GET ADDRESS OF BAT BLOCK PAGE
	CALL RELPAG		;RELEASE THE BAT BLOCK PAGE

; IF ONLY ACTION WAS TO WRITE HOME BLOCKS, GO INSERT FE-FILE SYSTEM POINTER

	CAIE Q2,.MSINI		;ARE WE INITIALIZING THE STR ?
	JRST MSTM92		;NO, GO FIX UP DEVICE TABLES
	LOAD T1,MS%FCN,.MSIFL(P3) ;YES, GET REQUESTED FUNCTION
	CAIE T1,.MSWHB		;WAS REQUEST TO WRITE HOME BLOCKS ONLY ?
	JRST MSTM92		;NO, GO FIX UP DEVICE TABLES
	MOVE T1,MSTMNS(Q3)	;YES, GET STRUCTURE NUMBER
	CALL FIXFES		;GO ADD FE-FILESYSTEM POINTER TO HOME BLOCKS
	 JFCL			;FAILED, OR NO FE FILE SYSTEM ON STR
	MOVE T1,MSTMNS(Q3)	;GET STRUCTURE NUMBER
	CALL FIXBOT		;GO ADD BOOTSTRAP.BIN POINTER TO HOME BLOCKS
	JFCL			;FAILED, OR NO BOOTSTRAP.BIN ON STR

; MARK THAT THE STRUCTURE IS NOW AVAILABLE FOR USE

MSTM92:	MOVE T4,.MSTFL(P3)	;GET FLAGS FROM USER ARG BLOCK
	MOVE T1,MSTMNS(Q3)	;GET STRUCTURE NUMBER
	ADDI T1,DVXST0		;GET OFFSET TO START OF STR INFORMATION
	MOVX T2,D1%INI		;GET "STRUCTURE BEING INITED" FLAG
	MOVE T3,MSTMNB(Q3)	;GET STRUCTURE DATA BLOCK ADDRESS
	ANDCAM T2,DEVCH1(T1)	;MARK THAT STRUCTURE NOT BEING INITED
	SETZRO STRJB,(T3)	;ZERO INITING FORK
	HRROS DEVUNT(T1)	;ASSUME STRUCTURE AVAILABLE TO ALL JOBS
	MOVE T3,JOBNO		;GET OUR JOB INDEX
	TXNE T4,MS%XCL		;EXCLUSIVE?
	HRLM T3,DEVUNT(T1)	;YES, SAVE JOB INDEX.
	UNLOKK DEVLKK		;UNLOCK THE DEVICE TABLE LOCK
	TXNN T4,MS%XCL		;IS STRUCTURE MOUNTED FOR EXCLUSIVE USE ?
	JRST MSTM95		;NO, GO RELEASE FREE SPACE AND RETURN
	MOVE T1,MSTMNB(Q3)	;YES, GET ADDRESS OF SDB FOR THIS STRUCTURE
	LOAD T1,STRUC,(T1)	;GET UNIQUE CODE FOR THE STRUCTURE
	CALL GTSTOF		;GET STRUCTURE OFFSET IN JSB BLOCKS
	 JRST MSTM95		;FAILED, JUST GO ON
	SETONE JSXCL,(T2)	;NOTE THAT THIS JOB MOUNTED STR EXCLUSIVELY
MSTM95:	MOVEI T1,JSBFRE		;GET FREE HEADER
	MOVE T2,Q3		;GET ADDRESS OF FREE BLOCK
	CALL RELFRE		;RELEASE FREE SPACE FOR LOCAL VARIABLES
	MOVEI T1,JSBFRE		;GET FREE HEADER
	MOVE T2,P1		;GET ADDRESS OF FREE BLOCK
	CALL RELFRE		;RELEASE FREE SPACE HOLDING USER ARG BLOCK
	OKINT			;PERMIT INTERRUPTS AGAIN
	RETSKP			;RETURN TO USER

; HERE ON ERROR TO RELEASE OFNS AND SDB, AND RETURN ERROR TO USER

MNTER7:	MOVEM T1,MSTMNE(Q3)	;SAVE ERROR CODE
	MOVE T1,MSTMNB(Q3)	;GET ADDRESS OF SDB
	LOAD T1,STRIDX,(T1)	;GET OFN OF INDEX TABLE FILE
	CALL RELOFN		;GO RELEASE THE ROOT-DIRECTORY OFN
	MOVE T1,MSTMNE(Q3)	;RESTORE ERROR CODE
				;FALL INTO MNTER6 TO RELEASE THE BIT TABLE OFN

MNTER6:
				;FALL INTO MNTER5 TO RELEASE OFN AND SDB

MNTER5:
	MOVEM T1,MSTMNE(Q3)	;SAVE ERROR CODE
	CALL UNMAPD		;GO UNMAP CURRENTLY MAPPED DIRECTORY
	MOVE T1,MSTMNB(Q3)	;GET ADDRESS OF SDB
	LOAD T1,STRRDO,(T1)	;GET OFN OF ROOT-DIRECTORY
	CALL RELOFN		;GO RELEASE THE ROOT-DIRECTORY OFN
	MOVE T1,MSTMNB(Q3)	;GET ADDRESS OF SDB
	LOAD T1,STRBTB,(T1)	;GET OFN OF BIT TABLE FILE
	SKIPE T1		;Do we have one?
	CAIL T1,NOFN		;And is it an OFN?
	IFSKP.			;[7337] 
	  CALL DSKUGT		;[7337] (T1/) Yes, so release cached disk pages
	  CALL RELOFN 		;[7337] (T1/T1) Then, release (and cache) OFN
	ENDIF.  		;[7337] 
	MOVE T1,MSTMNE(Q3)	;RESTORE ERROR CODE

; HERE ON ERROR TO RELEASE OFN OF ROOT-DIRECTORY, FREE SDB, AND RETURN

MNTER4:	MOVEM T1,MSTMNE(Q3)	;[7464]Save error code
	MOVE T1,MSTMNS(Q3)	;GET STRUCTURE NUMBER
	CALL DEVSTR		;GO FIX UP DEVICE TABLES
	MOVE T1,MSTMNS(Q3)	;GET STRUCTURE NUMBER
	CALL MRKOFN		;MARK OFN'S ON THIS STR AS ON A DISMOUNTED STR
	SKIPE T1,MSTMNB(Q3)	;GET ADDRESS OF SDB
	CALL CLRSTR		;GO CLEAR STRUCTURE INFO IN UDB'S
	MOVE T1,MSTMNS(Q3)	;GET STRUCTURE NUMBER
	CALL CLRSTB		;CLEAR THE STRTAB ENTRY
	MOVE T1,MSTMNE(Q3)	;GET ERROR CODE AGAIN

;[7464] HERE ON ERROR TO RELEASE THE TOKEN AND RETURN ERROR CODE TO USER

MNTR44:
;   IFN CFSCOD,<
	MOVEM T1,MSTMNE(Q3)	;[7464]Stash the error
	MOVE T1,MSTMNS(Q3)	;[7464]Get structure number
	CALL CFSSDM		;[7464](T1/)Release resource
	MOVE T1,MSTMNE(Q3)	;[7464]Recover the error code
;   >	;IFN CFSCOD

MNTER3:	MOVEM T1,MSTMNE(Q3)	;SAVE ERROR CODE
	UNLOKK DEVLKK		;UNLOCK THE DEVICE TABLE LOCK
	MOVE T1,MSTMNE(Q3)	;GET ERROR CODE AGAIN

MNTER2:	EXCH T1,Q3		;SAVE ERROR CODE IN Q3, GET ADR OF BLOCK
	MOVE T2,T1		;GET ADDRESS OF BLOCK TO RELEASE
	MOVEI T1,JSBFRE		;GET FREE HEADER
	CALL RELFRE		;RELEASE FREE BLOCK
	MOVE T1,Q3		;GET ERROR CODE BACK AGAIN

MNTER1:	MOVEM T1,Q3		;SAVE ERROR CODE
	MOVEI T1,JSBFRE		;GET FREE HEADER
	MOVE T2,P1		;GET ADDRESS OF FREE BLOCK
	CALL RELFRE		;RELEASE FREE BLOCK
	OKINT			;PERMIT INTERRUPTS AGAIN
	MOVE T1,Q3		;RESTORE ERROR CODE
	RETBAD ()		;ERROR, CODE IS STILL IN T1

MNTR4:	MOVEM T1,MSTMNE(Q3)	;[7464] Save error code
	MOVEM Q3,BLADDR		;[7464] Save Q3
	MOVE T1,P3		;[7464] Get Param block address
	MOVE Q3,MSTMND(Q3)	;[7464] Get Alias
	CALL CFSSDI		;[7464] (T1,Q3/)Undo Mount
	MOVE  Q3,BLADDR		;[7464] Restore Q3
	MOVE T1,MSTMNE(Q3)	;[7464] Get error again
	JRST MNTER3		;[7464] Continue error processing

	ENDSV.			

;CHKNAM - ROUTINE TO VALIDATE THE ALIAS FOR THE STRUCTURE AND CONVERT THE
;	  ASCIZ STRING TO SIXBIT FOR INSERTION INTO THE DEVICE TABLES.
;
;ACCEPTS IN T1/	POINTER TO ASCIZ STRING IN USER SPACE
;		CALL CHKNAM
;RETURNS: +1	 FAILURE, ERROR CODE IN T1
;	  +2	SUCCESS, T1/ SIXBIT STRUCTURE ALIAS FOR DEVNAM TABLE

CHKNAM:	STKVAR <CKNERR,CKNBLK,CKNNAM>
	SETZM CKNERR		;INITIALIZE ERROR FLAG
	CALL CPYFUS		;COPY STRING FROM USER SPACE
	 RETBAD (MONX02)	;FAILED, RETURN "INSUFFICIENT RESOURCES" - JSB FULL
	MOVEM T1,CKNBLK		;SAVE ADDRESS OF BLOCK CONTAINING ASCIZ STRING
	CALL ASCSIX		;GO CONVERT THE ASCIZ INTO SIXBIT
	 JRST [	SETOM CKNERR	;FAILED, INVALID SIXBIT NAME. SET ERROR FLAG
		JRST CKNM30 ]	;GO RELEASE FREE BLOCK AND RETURN ERROR CODE
	MOVEM T1,CKNNAM		;SAVE SIXBIT ALIAS
	JUMPE T1,[SETOM CKNERR	;NULL NAME, SET ERROR FLAG
		  JRST CKNM30]	;GO RELEASE FREE BLOCK AND RETURN ERROR
	HRRZ T2,CKNBLK		;GET ADDRESS OF BLOCK CONTAINING ASCIZ NAME
	HRLI T2,(POINT 7,0,35)	;FORM POINTER TO ASCIZ STRING

CKNM10:	ILDB T1,T2		;GET A CHARACTER FROM THE STRUCTURE NAME STRING
	JUMPE T1,CKNM20		;END, SEE IF NAME ALREADY IN DEVICE TABLE
	CALL CHRCHK		;GO CHECK THIS  CHARACTER
	 SETOM CKNERR		;FAILED, BAD CHARACTER. SET ERROR FLAG
	JRST CKNM10		;GO CHECK NEXT CHARACTER IN STRING

; HERE TO SEE IF THE NAME IS ALREADY IN THE DEVICE OR LOGICAL NAME TABLES

CKNM20:	HRRZ T1,CKNBLK		;GET ADDRESS OF BLOCK CONTAINING ASCIZ STRING
	CALL DEVLUX		;CHECK DEVICE TABLES
	 SKIPA			;OK, NAME NOT YET IN TABLES
	JRST [ SETOM CKNERR	;NAME IN DEVICE TABLES. SET ERROR FLAG.
		JRST CKNM30]	;GO RELEASE FREE BLOCK AND RETURN ERROR
	MOVE T1,CKNBLK		;GET ADDRESS OF BLOCK CONTAINING ASCIZ NAME
	MOVEI T2,1		;LOOK FOR SYSTEM-WIDE LOGICAL NAME
	CALL LNMLUK
	 JRST CKNM30		;OK, NO SUCH LOGICAL NAME
	SETOM CKNERR		;NAME IS LOGICAL NAME. SET ERROR FLAG.

; HERE TO RELEASE FREE BLOCK AND RETURN TO CALLER

CKNM30:	MOVEI T1,JSBFRE		;GET FREE HEADER
	MOVE T2,CKNBLK		;GET ADDRESS OF FREE BLOCK
	CALL RELFRE		;RELEASE THE FREE BLOCK
	SKIPE CKNERR		;ANY ERRORS FOUND ?
	RETBAD (MSTRX7)		;YES, RETURN ERROR CODE
	MOVE T1,CKNNAM		;NO, GET SIXBIT NAME
	RETSKP			;RETURN SUCCESS

;MAKHOM - ROUTINE TO CREATE THE HOME BLOCKS FOR ONE UNIT OF A STRUCTURE
;
;ACCEPTS IN P3/	ADDRESS OF USER ARGUMENT BLOCK IN MONITOR SPACE
;		CALL MAKHOM
;RETURNS: +1	 FAILURE, ERROR CODE IN T1
;	  +2	 Success, Home Blocks created; T1 contains new media ID

IDLEN== .MSIFI-.MSIUI		;LENGTH OF ID INFO FIELDS IN HOME BLOCK

MAKHOM:	SAVEP
	JSBVAR <MKHERR,MKHNAM,MKHNUM,MKHBLK,MKHMID,<MKHINF,IDLEN>,MKHUSB>,R
	CALL LGTAD		;GET THE CURRENT TIME AND DATE
	MOVEM T1,MKHMID		;SAVE TIME AND DATE AS MEDIA ID
	SETZM MKHERR		;INITIALIZE ERROR REGISTER

; SET UP TO LOOP OVER ALL UNITS IN STRUCTURE

	MOVEI P5,.MSTUI(P3)	;COMPUTE ADDRESS OF INFO FOR FIRST UNIT
	HRRZ T1,.MSTNU(P3)	;GET NUMBER OF UNITS IN STRUCTURE
	MOVN T1,T1		;GET -<NUMBER OF UNITS IN STRUCTURE>
	MOVSI P4,(T1)		;FORM AOBJN POINTER

; COPY ASCIZ STRUCTURE ID FROM USER SPACE

	MOVE T1,.MSINM(P3)	;GET POINTER TO STRUCTURE NAME IN USER SPACE
	CALL CPYFUS		;COPY STRING FROM USER SPACE
	 RETBAD (MONX02)	;RETURN "INSUFFICIENT RESOURCES" - JSB FULL
	MOVEM T1,MKHBLK		;SAVE ADDRESS OF BLOCK HOLDING STRING
	CALL ASCSIX		;CONVERT NAME TO SIXBIT
	 SETOM MKHERR		;FAILED, NOTE THAT AN ERROR OCCURRED
	MOVEM T1,MKHNAM		;SAVE SIXBIT STRUCTURE ID
	SKIPN T1		;CHECK FOR ZERO NAME
	SETOM MKHERR		;NONE NOT LEGAL

; RELEASE FREE BLOCK AND RETURN FAILURE IF AN ERROR OCCURRED

	MOVEI T1,JSBFRE		;GET FREE HEADER
	MOVE T2,MKHBLK		;GET ADDRESS OF BLOCK HOLDING ASCIZ STRING
	CALL RELFRE		;RELEASE FREE BLOCK
	SKIPE MKHERR		;ANY ERRORS DETECTED ?
	RETBAD (MSTX23)		;YES, RETURN "ERROR WRITING HOME BLOCKS"

; CONVERT ID FIELDS FROM ASCII TO PDP-11 "REVERSED-ASCII"

	HRRZ T1,.MSINU(P3)	;GET NUMBER OF UNITS IN STRUCTURE
	IMULI T1,.MSINO		;COMPUTE NUMBER OF PER-UNIT WORDS IN ARG BLOCK
	ADDI T1,.MSIUI-.MSINO(P3) ;FORM SOURCE ADDRESS OF 12 ASCII CHARACTERS
	MOVEI T2,MKHINF		;GET DESTINATION FOR PDP-11 ASCII
	CALL CNVINF		;GO CONVERT UNIT ID INTO PDP-11 ASCII
	HRRZ T1,.MSINU(P3)	;GET NUMBER OF UNITS IN STRUCTURE
	IMULI T1,.MSINO		;COMPUTE NUMBER OF PER-UNIT WORDS IN ARG BLOCK
	ADDI T1,.MSIOI-.MSINO(P3) ;FORM SOURCE ADDRESS OF 12 ASCII CHARACTERS
	MOVEI T2,.MSIOI-.MSIUI+MKHINF ;GET DESTINATION FOR PDP-11 ASCII
	CALL CNVINF		;GO CONVERT UNIT ID INTO PDP-11 ASCII
	; ..
	; ..

; GET # OF PAGES TO ALLOCATE FOR SWAPPING FROM USER ARGUMENT BLOCK

	HRRZ T3,.MSINU(P3)	;GET # OF UNITS IN STRUCTURE
	IMULI T3,.MSINO		;COMPUTE # OF PER-UNIT WORDS
	ADDI T3,.MSISW-.MSINO(P3) ;ADD OFFSET TO SWAPPING SPACE ARGUMENT
	MOVE P1,(T3)		;GET # OF PAGES TO ALLOCATE FOR SWAPPING

; SET UP TO CREATE THE HOME BLOCKS ON THIS UNIT (P1 IS ALREADY SET UP)

MKHOM1:	HRL T4,.MSINU(P3)	;GET NUMBER OF UNITS IN STRUCTURE
	HRR T4,P4		;GET UNIT # WITHIN STRUCTURE
	DMOVE T1,.MSICH(P5)	;GET CHANNEL AND CONTROLLER NUMBERS
	MOVE T3,.MSIUN(P5)	;ALSO GET UNIT NUMBER
	CALL CKUPAK		;CREATE THE CKU NUMBER FROM THEM
	MOVEM P3,MKHUSB		;STORE USER BLOCK ADDRESS
	HRRZ T3,.MSINU(P3)	;GET NUMBER OF UNITS IN STRUCTURE
	IMULI T3,.MSINO		;COMPUTE # OF PER-UNIT WORDS
	ADDI T3,.MSISN-.MSINO(P3) ;ADD OFFSET OF SERIAL NUMBER ARGUMENT
	MOVE P3,(T3)		;GET SERIAL NUMBER OF CPU FOR BOOTING
	MOVE T3,T1		;PUT INTO RIGHT AC
	MOVE T2,MKHNAM		;GET SIXBIT STRUCTURE ID
	MOVEI T1,MKHINF		;GET ADDRESS OF ID INFO
	MOVE P2,MKHMID		;GET MEDIA ID (PACK UNIQUE CODE)
	CALL CRTHOM		;CREATE THE HOME BLOCKS
	 JRST [ MOVE P3,MKHUSB	;FAILED, RESTORE P3
		 RETBAD (MSTX23)] ;RETURN "ERROR WRITING HOME BLOCKS"

; GO BACK AND WRITE THE HOME BLOCKS FOR THE NEXT UNIT

	MOVE P3,MKHUSB		;RESTORE P3
	ADDI P5,.MSTNO		;POINT TO NEXT SET OF PER-UNIT ARGUMENTS
	AOBJN P4,MKHOM1		;LOOP OVER ALL UNITS IN THE STRUCTURE
	MOVE T1,MKHMID		;Put the ID in T1 upon success return
	RETSKP			;RETURN SUCCESS

;CNVINF - ROUTINE TO CONVERT 12 ASCII CHARACTERS TO PDP-11 ASCII
;
;ACCEPTS IN T1/	ADR OF SOURCE (12 ASCII CHARACTERS)
;	    T2/	ADR OF DESTINATION FOR PDP-11 ASCII
;		CALL CNVINF
;RETURNS: +1	ALWAYS, PDP-11 ASCII PLACED AT DESTINATION

CNVINF:	STKVAR <CNVCHR>
	MOVSI T4,<-^D12/4>	;ID INFO FIELDS CONTAIN 12 CHARACTERS
	SUBI T1,1		;POINT TO <SOURCE-ADDRESS>-1
	HRLI T1,(POINT 7,0,35)	;FORM ILDB POINTER TO SOURCE ASCII CHARACTERS

; LOOP OVER EACH WORD IN THE DESTINATION AREA

CNVIN2:	HRLI T2,(POINT 8,0,9)	;FORM POINTER TO FIRST PDP-11 CHAR IN WORD
	ILDB T3,T1		;GET A CHARACTER FROM ASCII SOURCE STRING
	MOVEM T3,CNVCHR		;SAVE CHARACTER
	ILDB T3,T1		;GET NEXT CHARACTER FROM SOURCE STRING
	DPB T3,T2		;STORE FIRST CHARACTER INTO DESTINATION STRING
	MOVE T3,CNVCHR		;RESTORE FIRST SOURCE CHARACTER
	IDPB T3,T2		;STORE NEXT PDP-11 CHARACTER INTO DESTINATION
	HRLI T2,(POINT 8,0,27)	;FORM POINTER TO THIRD CHARACTER IN DEST WORD
	ILDB T3,T1		;GET NEXT CHARACTER FROM SOURCE STRING
	MOVEM T3,CNVCHR		;SAVE CHARACTER
	ILDB T3,T1		;GET NEXT CHARACTER FROM SOURCE STRING
	DPB T3,T2		;STORE THIRD CHARACTER IN DESTINATION WORD
	MOVE T3,CNVCHR		;RESTORE FIRST SOURCE CHARACTER
	IDPB T3,T2		;STORE FOURTH (LAST) CHARACTER IN DEST WORD
	ADDI T2,1		;POINT TO NEXT WORD IN DESTINATION
	AOBJN T4,CNVIN2		;LOOP OVER ALL WORDS IN DESTINATION
	RET			;RETURN

;STRINI - SET UP DIRECTORIES, BIT TABLE, AND FRONT-END FILE-SYSTEM FOR
;	  A STRUCTURE BEING INITIALIZED.
;ACCEPTS IN T1/	STRUCTURE NUMBER
;	    T2/	# OF PAGES TO ALLOCATE FOR THE FE FILE-SYSTEM
;	    T3/ # OF PAGES TO ALLOCATE FOR THE BOOTSTRAP.BIN FILE
;		CALL STRINI
;RETURNS: +1	 FAILURE, ERROR CODE IN T1
;	  +2	SUCCESS

STRINI:	SAVEP
	STKVAR <STINIS,STINIB,STINIF,STINIE,STINIT>
	MOVEM T1,STINIS		;SAVE STRUCTURE NUMBER
	MOVEM T2,STINIF		;SAVE # OF PAGES FOR FE FILE-SYSTEM
	MOVEM T3,STINIT		;SAVE # OF PAGES FOR BOOTSTRAP.BIN
	MOVE T3,STRTAB(T1)	;GET ADDRESS OF SDB FOR THIS STRUCTURE
	MOVEM T3,STINIB		;SAVE SDB ADDRESS
	MOVE T1,STINIS		;YES, GET THE STRUCTURE NUMBER
	CALL CRTBTB		;GO CREATE THE BIT TABLE FOR THIS STRUCTURE
	 RETBAD (MSTX12)	;FAILED, RETURN ERROR
	MOVE T1,STINIB		;GET ADDRESS OF SDB FOR THIS STRUCTURE
	LOAD T1,STRRXB,(T1)	;GET DISK ADDRESS OF ROOT-DIRECTORY INDEX BLOCK
	MOVE T2,STINIS		;GET THE STRUCTURE NUMBER
	CALL NEWIB		;GO SET UP A NEW ROOT-DIRECTORY INDEX BLOCK
	 RETBAD (MSTRX8)	;FAILED, COULD NOT GET OFN FOR ROOT-DIRECTORY
	CALL RELOFN		;RELEASE THE OFN
	MOVE T3,STINIB		;GET ADDRESS OF SDB
	LOAD T1,STRBXB,(T3)	;GET THE BACKUP ROOT-DIR INDEX BLOCK ADDRESS
	MOVE T2,STINIS		;GET THE STRUCTURE NUMBER
	CALL NEWIB		;ASSIGN THE BACKUP ROOT-DIR INDEX BLOCK ADDRESS
	 JRST [	MOVX T1,MSTX13	;FAILED, GET "BAD BACKUP ROOT-DIR" ERROR CODE
		JRST STIER1 ]	;GO RELEASE ROOT-DIR OFN AND RETURN ERROR
	CALL RELOFN		;RELEASE THE OFN OF THE BACKUP ROOT-DIR
	MOVE T1,STINIS		;GET THE STRUCTURE NUMBER
	CALL SETRDO		;GO GET AN OFN FOR THE ROOT-DIRECTORY
	 RETBAD (MSTRX8)	;FAILED, COULD NOT GET AN OFN FOR ROOT-DIRECTORY
	CALL ASGPAG		;GET PAGE
	JRST [	MOVX T1,MSTX11	;CAN'T INIT INDEX TABLE
		JRST STIER1]
	MOVEM T1,FKXORA		;SET NEW ORIGIN FOR IDXORA
	MOVEI T4,ROOTDN		;SUPERIOR DIR IS SELF
	MOVE T3,STINIB		;YES, GET ADDRESS OF SDB
	LOAD T3,STRRXB,(T3)	;GET ADDRESS OF ROOT-DIR INDEX BLOCK
	MOVEI T2,0		;NO FDB ADDRESS YET
	MOVEI T1,ROOTDN		;GET ROOT-DIRECTORY DIRECTORY NUMBER
	CALL SETIDX		;GO SET UP ENTRY FOR ROOT-DIR  IN INDEX TABLE
	 JRST [	MOVX T1,MSTX11	;COULD NOT SET UP INDEX TABLE
		JRST STIER2 ]	;RETURN ERROR TO USER
	MOVEI T1,ROOTDN		;GET ROOT-DIRECTORY NUMBER
	MOVE T2,STINIS		;GET STRUCTURE NUMBER
	CALL DIRINI		;GO INITIALIZE THE ROOT-DIRECTORY
	 JRST [	MOVX T1,MSTX10	;ROOT-DIRECTORY BAD
		JRST STIER2 ]	;GO RETURN ERROR CODE TO USER
	MOVE T1,STINIS		;GET THE STRUCTURE NUMBER
	CALL FILCRD		;GO SET UP THE STANDARD SYSTEM DIRECTORIES
	MOVE T1,STINIS		;GET THE STRUCTURE NUMBER
	CALL WRTBTB		;GO SET UP THE BIT TABLE
	 JRST [ MOVX T1,MSTX12	;ERROR, GET CODE
		JRST STIER2]	;RETURN ERROR CODE TO USER
	MOVE T1,STINIS		;GET STRUCTURE NUMBER
	MOVE T2,STINIF		;GET # OF PAGES FOR FE FILE-SYSTEM
	CALL FEFSYS		;IF A PUBLIC STRUCTURE, SET UP FRONT-END STUFF
	 JFCL			;FAILED, IGNORE FAILURE
	MOVE T1,STINIS		;GET STRUCTURE NUMBER
	MOVE T2,STINIT		;GERT # OF PAGES FOR BOOTSTRAP.BIN
	CALL BOTSYS		;SET UP BOOTSTRAP.BIN
	JFCL			;FAILED? IGNORE?
	MOVE T1,STINIB		;SDB ADDRESS
	LOAD T1,STRRDO,(T1)	;GET OFN OF <ROOT-DIRECTORY>
	HRLZS T1		;OFN,,0
	MOVEI T2,1000
	CALL UPDPGS		;UPDATE FILE PAGES
	MOVE T1,STINIB		;SDB ADDRS
	LOAD T1,STRRDO,(T1)	;OFN AGAIN
	CALL UPDOFN		;FIX INDEX BLOCK ALSO
	MOVE T1,FKXORA		;IDX ORIGIN
	CALL RELPAG		;FREE PAGE
	SETZM FKXORA		;ZERO SPECIAL FORK IDXORA
	RETSKP			;RETURN SUCCESS


; HERE ON AN ERROR TO RELEASE OFN OF ROOT-DIR AND RETURN ERROR CODE

STIER2:	MOVEM T1,STINIE		;SAVE ERROR CODE
	MOVE T1,FKXORA		;IDX ORIGIN
	CALL RELPAG		;FREE PAGE
	SETZM FKXORA		;ZERO SPECIAL FORK IDXORA
	SKIPA			;DON'T RESAVE ERROR CODE
STIER1:	MOVEM T1,STINIE		;SAVE ERROR CODE
	MOVE T1,STINIB		;GET ADDRESS OF SDB
	LOAD T1,STRRDO,(T1)	;GET OFN OF ROOT-DIRECTORY
	CALL RELOFN		;RELEASE THE OFN
	MOVE T1,STINIE		;RESTORE THE ERROR CODE
	RETBAD			;GIVE FAIL RETURN

; ROUTINE TO RELEASE IDX TABLE PAGE


;UNICHK - ROUTINE TO CHECK THAT EACH UNIT SPECIFIED AS PART OF THE STRUCTURE
;	  IS OF THE CORRECT TYPE.
;
;ACCEPTS IN P3/	ADDRESS OF USER'S ARGUMENT BLOCK IN MONITOR SPACE
;		CALL UNICHK
;RETURNS: +1	 FAILED, ONE OF THE UNITS SPECIFIED IS INVALID
;	  +2	SUCCESS, ALL OF THE CHANNEL, CONTROLLER, AND UNIT #'S ARE OK

UNICHK:	SAVEP
	STKVAR <UCKTYP>		;UNIT TYPE
	MOVEI P2,.MSTUI(P3)	;COMPUTE ADDRESS OF INFO FOR FIRST UNIT
	HRRZ T1,.MSTNU(P3)	;GET NUMBER OF UNITS IN STRUCTURE
	MOVN P1,T1		;GET -<NUMBER OF UNITS IN STRUCTURE>
	MOVSI P1,(P1)		;FORM AOBJN POINTER

; TOP OF LOOP OVER ALL UNIT SPECIFICATIONS

UNICK1:	DMOVE T1,.MSTCH(P2)	;GET CHANNEL AND CONTROLLER NUMBERS FROM USER
	MOVE T3,.MSTUN(P2)	;ALSO GET UNIT NUMBER FROM USER
	CALL CHKCKU		;VERIFY THEM AND RETURN UDB IN T1
	 RETBAD ()		;THEY'RE BAD, RETURN ERROR CODE
	TRNN P1,-1		;DOING FIRST UNIT IN THE STRUCTURE ?
	JRST UNICK2		;YES, DO NOT CHECK UNIT TYPE, JUST SAVE IT
	CAME T2,UCKTYP		;NO, IS UNIT TYPE CORRECT ?
	 RETBAD (MSTX17)	;NO, RETURN "MIXED UNITS IN STRUCTURE" ERROR
UNICK2:	MOVEM T2,UCKTYP		;SAVE UNIT TYPE
	CALL GETSTR		;GET STRUCTURE INFORMATION FOR UNIT
	 JRST [	MOVE T2,T1	;FAILED, COPY ERROR FLAGS
		TXNE T2,MS%OFL	;IS UNIT OFF-LINE ?
		RETBAD (MSTRX5)	;YES, RETURN "UNIT OFF LINE" ERROR
		RETBAD (MSTX15)] ;RETURN "UNIT BEING DIAGNOSED" ERROR
	TXNE T3,MS%WLK		;UNIT WRITE LOCKED ?
	RETBAD (MSTX34)		;YES, RETURN "WRITE LOCKED UNIT" ERROR
	CAME T1,[-1]		;IS UNIT ALREADY PART OF A STRUCTURE ?
	RETBAD (MSTX19)		;YES, RETURN "UNIT ALREADY IN STRUCTURE" ERROR
	ADDI P2,.MSTNO		;POINT TO NEXT BLOCK OF PER-UNIT INFORMATION
	AOBJN P1,UNICK1		;LOOP OVER ALL UNITS IN STRUCTURE

; HERE IF ALL UNIT SPECIFICATIONS CHECKED OUT OK - RETURN SUCCESS

	RETSKP			;RETURN SUCCESS, ALL UNITS OK

;HOMCHK - ROUTINE TO CHECK AND, IF NECESSARY, FIX THE HOME BLOCKS
;
;ACCEPTS IN Q1/	ADDRESS OF USER'S ARGUMENT BLOCK IN USER SPACE
;	    Q2/	FUNCTION CODE (.MSMNT OR .MSINI)
;	    P3/ ADDRESS OF USER'S ARGUMENT BLOCK IN MONITOR SPACE
;		CALL HOMCHK
;RETURNS: +1	 FAILURE, ERROR CODE IN T1
;	  +2	SUCCESS, T1/ STRUCTURE NUMBER

HOMCHK:	SAVEP
	STKVAR <HCKSTR,HCKSDB,HCKADR,HCKPAG,HCKUNI,HCKBLK,HCKERR>
	SETZM HCKSDB		;INITIALIZE ADDRESS OF SDB
	MOVEI P2,.MSTUI(P3)	;COMPUTE ADDRESS OF INFO FOR FIRST UNIT
	HRRZ T1,.MSTNU(P3)	;GET NUMBER OF UNITS IN STRUCTURE
	MOVN P1,T1		;GET -<NUMBER OF UNITS IN STRUCTURE>
	MOVSI P1,(P1)		;FORM AOBJN POINTER

; HERE TO READ AND CHECK THE HOME BLOCKS FOR THE CURRENT UNIT

HOMCK1:	DMOVE T1,.MSTCH(P2)	;GET CHANNEL AND CONTROLLER NUMBERS FROM USER
	MOVE T3,.MSTUN(P2)	;GET UNIT NUMBER FROM USER
	STOR T1,DOP%C2,HCKUNI	;REMEMBER CHANNEL NUMBER FOR LATER
	STOR T2,DOP%K2,HCKUNI	;AND CONTROLLER NUMBER (MAYBE -1)
	STOR T3,DOP%U2,HCKUNI	;AND UNIT NUMBER
	CALL MSTRHB		;GO READ THE HOME BLOCKS FOR THIS UNIT
	 JRST HCKER2		;FAILED, GO RETURN ERROR CODE
	MOVEM T1,HCKADR		;SUCCESS, SAVE VIRTUAL ADDRESS OF HOME BLOCKS
	MOVEM T2,HCKPAG		;SAVE PHYSICAL PAGE NUMBER OF HOME BLOCKS
	;..
	;..

; CHECK THE HOME BLOCKS FOR THIS UNIT

	CALL MSTHBC		;GO CHECK THE HOME BLOCKS
	MOVE Q1,T1		;COPY FLAGS INDICATING GOOD HOME BLOCKS
	MOVE T1,.MSTNM(P3)	;GET STRUCTURE NAME FROM USER
	CALL CPYFUS		;COPY STRING FROM USER SPACE
	 JRST [	MOVX T1,MSTRX4	;FAILED, GET "INSUFFICIENT RESOURCES" ERROR
		JRST HCKER1 ]	;GO RELEASE HOME BLOCK PAGE AND RETURN ERROR
	MOVEM T1,HCKBLK		;SAVE ADDRESS OF BLOCK HOLDING STRING
	CALL ASCSIX		;CONVERT ASCIZ STRING TO SIXBIT
	 JRST [	MOVE T2,HCKBLK	;FAILED, GET ADDRESS OF BLOCK
		MOVEI T1,JSBFRE	;GET FREE HEADER
		CALL RELFRE	;RELEASE FREE BLOCK
		MOVX T1,MSTRX7	;GET "INVALID STRUCTURE NAME" ERROR
		JRST HCKER1 ]	;GO RETURN ERROR TO USER
	JUMPE T1,.-1		;ERROR IF NO NAME
	MOVE T2,HCKADR		;GET VIRTUAL ADDRESS OF FIRST HOME BLOCK
	HRLZ T3,.MSTNU(P3)	;GET NUMBER OF UNITS IN STRUCTURE
	HRR T3,P1		;GET LOGICAL UNIT NUMBER OF THIS UNIT IN STR
	CAMN T3,HOMLUN(T2)	;CORRECT LOGICAL UNIT ?
	CAME T1,HOMSNM(T2)	;STRUCTURE NAME OK FOR HOME BLOCK 1 ?
	TXZ Q1,HB%1OK		;NO, MARK THAT FIRST HOME BLOCK IS BAD
	SKIPN HOMRXB(T2)	;IS THERE A DISK ADDRESS FOR THE ROOT-DIR XB ?
	TXZ Q1,HB%1OK		;NO, FIRST HOME BLOCK IS BAD
	ADDI T2,HBLEN		;GET ADDRESS OF SECOND HOME BLOCK
	CAMN T3,HOMLUN(T2)	;CORRECT LOGICAL UNIT NUMBER ?
	CAME T1,HOMSNM(T2)	;STRUCTURE NAME OF SECOND HOME BLOCK OK ?
	TXZ Q1,HB%2OK		;NO, MARK SECOND HOME BLOCK IS BAD
	SKIPN HOMRXB(T2)	;IS THERE A DISK ADDRESS FOR THE ROOT-DIR XB ?
	TXZ Q1,HB%2OK		;NO, SECOND HOME BLOCK IS BAD
	MOVE T2,HCKBLK		;GET ADDRESS OF BLOCK HOLDING STRING
	MOVEI T1,JSBFRE		;GET FREE HEADER
	CALL RELFRE		;RELEASE BLOCK HOLDING NAME STRING
	JUMPE Q1,[MOVX T1,MSTRX6 ;IF BOTH HOME BLKS BAD, GET ERROR CODE
		JRST HCKER1 ]	;GO RELEASE HOME BLOCK PAGE AND RETURN ERROR

; CHECK FOR ONE BAD HOME BLOCK, FIX UP IF NEEDED

	TXNE Q1,HB%1OK		;FIRST HOME BLOCK OK ?
	TXNN Q1,HB%2OK		;  AND ALSO SECOND HOME BLOCK ?
	SKIPA			;NO, AT LEAST ONE IS BAD
	JRST HOMCK4		;YES, GO ON TO NEXT UNIT
	MOVE T1,.MSTFL(P3)	;GET FLAGS FROM USER
	TXNE T1,MS%NFH		;USER WANT A BAD HOME BLOCK REPAIRED ?
	JRST [ MOVX T1,MSTRX6	;NO, GET "BAD HOME BLOCKS" ERROR CODE
		JRST HCKER1 ]	;RELEASE HOME BLOCK PAGE AND SDB, RETURN ERROR
	HRRZ T1,HCKADR		;GET VIRTUAL ADDRESS OF FIRST HOME BLOCK
	HRRZ T2,HCKPAG		;GET PHYSICAL PAGE NUMBER OF HOME BLOCK PAGE
	LSH T2,PGSFT		;FORM PHYSICAL ADDRESS OF FIRST HOME BLOCK
	MOVE T3,HCKUNI		;GET CKU NUMBERS FOR THE UNIT
	MOVE P5,HCKSTR		;GET STRUCTURE NUMBER
	MOVE P4,HCKSDB		;GET ADDRESS OF SDB FOR THIS STRUCTURE
	ADDI P4,SDBUDB(P1)	;FORM SDBUDB POINTER
	TXNN Q1,HB%1OK		;IS HOME BLOCK 1 THE GOOD ONE ?
	JRST HOMCK3		;NO, GO COPY SECONDARY TO PRIMARY
	CALL CPYH1		;YES, COPY PRIMARY HOME BLOCK TO SECONDARY
	 JRST HCKER1		;FAILED, RETURN ERROR TO USER
	JRST HOMCK4		;SUCCESS, HOME BLOCK FIXED. GO ON TO NEXT UNIT
HOMCK3:			;HERE TO COPY SECONDARY TO PRIMARY
	CALL CPYH2		;COPY SECONDARY HOME BLOCK OVER PRIMARY
	 JRST HCKER1		;FAILED, RETURN ERROR TO USER
	; ..
	; ..

; SET UP AND CHECK STRTAB AND SDB FOR THIS STRUCTURE

HOMCK4:	TRNE P1,-1		;IS THIS FIRST UNIT IN STRUCTURE ?
	JRST HOMCK2		;NO, GO ADD THIS UNIT TO STRUCTURE
	MOVE T1,HCKADR		;YES, GET ADDRESS OF HOME BLOCK PAGE
	MOVE T2,HCKUNI		;GET CHANNEL, CONTROLLER, AND UNIT NUMBERS
	CALL MAKSDB		;GO CREATE AN SDB FOR THIS STRUCTURE
	 JRST HCKER1		;FAILED, NO STRTAB SLOTS LEFT
	MOVEM T1,HCKSDB		;SAVE ADDRESS OF SDB
	MOVEM T2,HCKSTR		;SAVE STRUCTURE NUMBER
HOMCK2:	MOVE T1,HCKUNI		;GET CHANNEL, CONTROLLER, AND UNIT NUMBERS
	MOVE T2,HCKADR		;GET ADDRESS OF HOME BLOCK PAGE
	MOVE T3,HCKSDB		;GET ADDRESS OF SDB
	CALL BLDSDB		;GO ADD THIS UNIT TO THE STRUCTURE
	 JRST HCKER1		;FAILED,  RELEASE PAGE AND RETURN ERROR

; SET UP UDBSTR AND SDBUDB WORDS FOR UNIT AND STRUCTURE

	MOVE T1,HCKUNI		;GET CKU NUMBERS
	HRR T2,HCKSTR		;GET STRUCTURE NUMBER
	HRL T2,P1		;GET UNIT IN STRUCTURE,,STRUCTURE NUMBERS
	MOVE T3,HCKSDB		;GET SDB ADDRESS
	CALL SETSTR		;GO SETUP UDBSTR AND SDBUDB WORDS
	;..
	;..

; UNLOCK AND RELEASE THE PAGE USED FOR READING THE HOME BLOCKS

	MOVE T1,HCKPAG		;GET ADDRESS OF HOME BLOCK PAGE
	CALL MULKCR		;UNLOCK THE PAGE
	MOVE T1,HCKADR		;GET ADDRESS OF PAGE AGAIN
	CALL RELPAG		;RELEASE THE PAGE

; LOOP BACK TO PROCESS ALL UNITS IN THE STRUCTURE

	ADDI P2,.MSTNO		;STEP TO NEXT CHANNEL, CONTROLLER, AND UNIT
	AOBJN P1,HOMCK1		;LOOP OVER ALL UNITS IN STRUCTURE
	MOVE T1,HCKSTR		;GET STRUCTURE NUMBER
	RETSKP			;RETURN SUCCESS

; HERE ON AN ERROR TO RELEASE HOME BLOCK PAGE AND RETURN ERROR

HCKER1:	MOVEM T1,HCKERR		;SAVE ERROR CODE
	MOVE T1,HCKPAG		;GET PHYSICAL PAGE NUMBER NOW LOCKED
	CALL MULKCR		;GO UNLOCK THE PAGE
	MOVE T1,HCKADR		;GET ADDRESS OF HOME BLOCK PAGE
	CALL RELPAG		;RELEASE THE PAGE
	MOVE T1,HCKERR		;RESTORE ERROR CODE AGAIN
				;FALL INTO HCKER2

HCKER2:	MOVEM T1,HCKERR		;SAVE ERROR CODE
	SKIPE T1,HCKSDB		;IS THERE AN SDB YET ?
	CALL CLRSTR		;YES, GO REMOVE PHYSIO POINTERS IN UDB'S
	MOVE T1,HCKSTR		;GET STRUCTURE NUMBER
	SKIPE HCKSDB		;WAS STRTAB SET UP YET ?
	CALL CLRSTB		;CLEAR THE STRTAB ENTRY
	MOVE T1,HCKERR		;GET ERROR CODE BACK
	RETBAD ()		;RETURN ERROR CODE TO CALLER

;MAKSDB - ROUTINE TO CREATE A NEW SDB FOR A STRUCTURE
;
;ACCEPTS IN T1/	ADDRESS OF PAGE CONTAINING HOME BLOCKS FOR THIS UNIT
;	    T2/	CKU NUMBERS (CHAN, CTRL, AND UNIT NUMBER)
;		CALL MAKSDB
;RETURNS: +1	 FAILURE, ERROR CODE IN T1 (I.E., NO SDB'S AVAILABLE)
;	  +2	SUCCESS, WITH:
;		T1/ ADDRESS OF SDB
;		T2/ STRUCTURE NUMBER

MAKSDB:	STKVAR <MKSHOM,MKSSTR,MKSCKU>
	MOVEM T1,MKSHOM		;SAVE HOME BLOCK PAGE ADDRESS
	MOVEM T2,MKSCKU		;AND THE CKU NUMBER
	MOVSI T3,-STRN		;SET UP TO LOOP THROUGH STRTAB
	NOSKED			;INSURE THAT STRTAB IS NOT CHANGED WHILE WE LOOK
	SKIPE STRTAB(T3)	;FOUND A FREE SDB ?
	AOBJN T3,.-1		;NO, KEEP LOOKING
	JUMPGE T3,MKSDB5	;[7430]FAIL IF NO FREE SDB SLOTS
	MOVEM T3,MKSSTR		;SAVE STRUCTURE NUMBER
	MOVE T2,MKSHOM		;GET ADDRESS OF HOME BLOCK PAGE
	MOVE T1,MKSCKU		;GET CKU NUMBERS
	CALL BLDNEW		;GO CREATE THE SDB FOR THE NEW STRUCTURE
	 JRST MKSDB6		;FAILED, GO OKSKED AND RETURN ERROR
	HRRZ T2,MKSSTR		;GET STR NUMBER AGAIN (SDB ADR ALREADY IN T1)
	OKSKED			;PERMIT SCHEDULING AGAIN
	RETSKP			;RETURN

;[7430]Here if an SDB could not be build

MKSDB5:	SKIPA T1,[MSTX51]	;[7430]STRUCTURE LIMIT EXCEEDED
MKSDB6:	MOVEI T1,MONX05		;[7430]NO RESIDENT FREE SPACE
	OKSKED			;[7430]PERMIT SCHEDULING AGAIN
	RETBAD ()		;[7430]INSUFICIENT RESOURCES - NO RESIDENT FREE SPACE
; .MSDIS - DISMOUNT A FILE STRUCTURE

; LOCAL VARIABLE USAGE --
;
; MSTDMS - STRUCTURE NUMBER OF STRUCTURE BEING DISMOUNTED
; MSTDMB - ADDRESS OF SDB FOR STRUCTURE BEING DISMOUNTED
; MSTDMN - ASCIZ STRUCTURE NAME STRING FOR USE IN MESSAGES
; MSTDME - TEMPORARILY HOLDS ERROR CODE
; MSTDMU - STRUCTURE UNIQUE CODE

MSTDIS:	STKVAR <MSTDMS,MSTDMB,MSTDME,<MSTDMN,2>,MSTDMU>

; VERIFY THAT THE USER HAS THE REQUIRED CAPABILITIES TO DISMOUNT THE STRUCTURE

MSTD00:	MOVE T1,CAPENB		;GET CURRENTLY ENABLED CAPABILITIES
	TXNN T1,SC%WHL!SC%OPR	;WHEEL OR OPERATOR ?
	RETBAD (MSTRX2)		;NO, RETURN ERROR CODE TO USER

; CHECK THE SIZE OF THE ARGUMENT BLOCK

	XCTU [HLRZ T1,1]	;GET SIZE OF BLOCK FROM USER
	CAIGE T1,1		;AT LEAST ONE WORD SPECIFIED ?
	RETBAD (MSTRX3)		;NO, RETURN "ARG BLOCK TOO SMALL" ERROR CODE

; VERIFY THAT THE SPECIFIED STRUCTURE IS MOUNTED

	UMOVE T1,2		;GET ADDRESS OF ARGUMENT BLOCK FROM USER
	UMOVE T1,.MSDNM(T1)	;GET NAME OF STRUCTURE TO DISMOUNT
	CALL FNDSTD		;[7.1081](T1/T1) Is structure now mounted?
	 RETBAD (MSTX21)	;NO, RETURN "STRUCTURE NOT MOUNTED" ERROR CODE
	MOVEM T1,MSTDMS		;YES, SAVE STRUCTURE NUMBER
	CAIE T1,PSNUM		;[7.1112]Dismounting the boot structure?
	CAMN T1,LGSIDX		;[7.1112]Or the Login Structure
	IFNSK.			;[7.1112]If yes to either...
	  MOVX T1,MSTX24	;[7.1112]Return "Illegal to dismount system structure"
	  JRST MSDER1		;[7.1112]Unlock the structure and return error
	ENDIF.			;[7.1112]
	MOVE T2,T1		;use T2 instead of T1
	ADDI T2,DEVCH1+DVXST0	;compute address in DEVCH1
	MOVE T3,(T2)		;get device characterists
	TXNE T3,D1%INI		;device being initialized?
	 JRST [	MOVX T2,MSTX43	;yes, get "illegal to dismount while INITing"
		JRST MSDER1]	;go unlock the structure and return error
	MOVE T2,STRTAB(T1)	;GET ADDRESS OF SDB FOR THIS STRUCTURE
	MOVEM T2,MSTDMB		;SAVE ADDRESS OF SDB
	MOVE T1,MSTDMS		;GET STRUCTURE NUMBER
	CALL STRCNV		;GET UNIQUE CODE FOR THIS STRUCTURE
	 JFCL			;CANNOT FAIL WHILE STRUCTURE IS LOCKED
	MOVEM T1,MSTDMU		;STORE STRUCTURE UNIQUE CODE

; SAVE THE STRUCTURE NAME FOR LATER USE IN ADVISORY MESSAGE

	MOVE T2,T1		;GET STRUCTURE UNIQUE CODE
	HRLI T2,.DVDES+.DVDSK	;GET DEVICE TYPE
	HRROI T1,MSTDMN		;GET POINTER TO WHERE NAME WILL GO
	DEVST			;GET STRUCTURE NAME
	 JRST [	MOVX T1,MSTX21	;FAILED, GET "STRUCTURE NOT MOUNTED" ERROR
		JRST MSDER1 ]	;GO UNLOCK STRUCTURE AND RETURN
	MOVE T1,MSTDMU		;GET STRUCTURE UNIQUE CODE
	MOVEI T2,MSTDMN		;GET ADDRESS OF STRUCTURE NAME
	CALL FIXJOB		;GO FIX JSB'S OF ALL JOBS ON SYSTEM
	; ..
	; ..

; THE DATABASE PERTINENT TO THE STRUCTURE TO BE DISMOUNTED MAY CURRENTLY
; BE IN USE, E.G. BY ANOTHER JSYS.  IT IS NECESSARY TO WAIT UNTIL THE
; STRUCTURE IS AVAILABLE (THE LOCK IS FREE), AND THEN TO PREVENT ANY
; ADDITIONAL USE OF THE STRUCTURE.  THIS IS DONE NOSKED TO PREVENT RACES.
; NOTE: SINCE THIS JSYS HAS LOCKED THE STRUCTURE, THE LOCK WILL BE 'FREE'
;	WHEN THE LOCK COUNT IS 1, NOT 0.

MSTD10:	CALL LCKDVL		;LOCK THE DEVICE TABLE LOCK
	LOCK STRLOK,<JRST MSTD11> ;LOCK DISMOUNT LOCK
	NOSKED			;DO NOT PERMIT DATABASE TO CHANGE
				; DURING THIS TEST !
	MOVE T1,MSTDMB		;GET ADDRESS OF SDB FOR THIS STRUCTURE
	LOAD T2,STRLK,(T1)	;GET THE LOCK COUNT
	CAIN T2,1		;IS THE LOCK FREE ?
	JRST MSTD20		;YES, GO PREVENT FURTHER ACCESS TO THE STR
	UNLOCK STRLOK
	UNLOKK DEVLKK		;UNLOCK THE DEVICE TABLE LOCK
	OKINT			;[7.1081] Undo NOINT (from FNDSTD)
	MOVE T1,MSTDMS		;GET STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK THE STRUCTURE WHILE WE WAIT
	OKSKED			;OK FOR OTHERS TO RUN NOW
	HRLZ T1,MSTDMS		;SET UP FOR SCHEDULER TEST - STR NUMBER
	HRRI T1,STRTST		;GO OKSKED AND WAIT UNTIL THE LOCK BECOMES FREE
	MOVEI T2,^D200		;HOLD TIME
	HDISMS			;BYE BYE
	JRST MSTD00		;START OVER

; HERE WHEN WE CAN'T GET BOTH THE DEVICE AND STRUCTURE LOCKS

MSTD11:	UNLOKK DEVLKK		;UNLOCK THE DEVICE TABLE LOCK
	OKINT			;[7.1081] Undo NOINT from FNDSTD
	MOVE T1,MSTDMS		;GET STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK THE STRUCTURE
	MOVEI T1,^D200		;WAIT FOR A LITTLE BIT
	DISMS
	JRST MSTD00		;AND START OVER

; SCHEDULER TEST TO SEE IF THE STRUCTURE LOCK IS FREE
; 1/ ADDRESS OF SDB FOR THIS STRUCTURE

	RESCD
STRTST:	SKIPN T2,STRTAB(T1)	;GET SDB ADDRESS IF ANY
	JRST 1(4)		;NONE. ALREADY GONE.
	JE STRLK,(T2),1(4)	;FREE, SUCCEED
	JRST 0(4)		;LOCK STILL INCREMENTED, FAIL
	SWAPCD

; HERE WHEN THE LOCK IS FREE - CLEAR THE UNIQUE CODE TO PREVENT FURTHER ACCESS

MSTD20:	MOVE T2,MSTDMB		;GET ADDRESS OF SDB FOR THIS STRUCTURE
	SETZRO STRUC,(T2)	;CLEAR THE UNIQUE CODE FOR THIS STRUCTURE
	SETONE STDIS,(T2)	;MARK THAT STRUCTURE IS BEING DISMOUNTED
	MOVE T1,MSTDMS		;GET STRUCTURE NUMBER
	CALL DEVSTR		;FIX DEVICE TABLES AS THEY WERE PRIOR TO MOUNT
	OKSKED			;PERMIT SCHEDULING AGAIN
	UNLOKK DEVLKK		;UNLOCK THE DEVICE TABLE LOCK
	UNLOCK STRLOK		;RELEASE DISMOUNT LOCK AS WELL
	; ..
	; ..

; UNMAP CURRENTLY MAPPED DIRECTORY AND RELEASE STRUCTURE-RELATED OFN'S

	CALL UNMAPD		;UNMAP CURRENTLY MAPPED DIRECTORY
	MOVE T1,MSTDMS		;Get structure number again
	CALL STROFL		;See if it is on-line
	IFSKP.			;If so
	 MOVE T1,MSTDMB		;GET ADDRESS OF SDB FOR THIS STRUCTURE
	 CALL MSTUPO		;UPDATE ALL OF THE OFNS
	ENDIF.
	MOVE T1,MSTDMS		;GET STRUCTURE NUMBER
	CALL MRKOFN		;GO MARK OFN'S ON THIS STRUCTURE
	MOVE T1,MSTDMB		;GET SDB ADDRESS FOR THIS STRUCTURE
	CALL MSTRLO		;RELEASE ALL OF THE OFN'S

; RETURN THE PHYSIO DATABASE TO ITS ORIGINAL STATE, BREAK PATH TO THIS SDB

MSTD50:
;   IFN CFSCOD,<
	MOVE T1,MSTDMS		;Get structure number
	CALL CFSSDM		;Release resource
;   >	;IFN CFSCOD
	MOVE T1,MSTDMB		;GET ADDRESS OF SDB
	OKINT			;[7.1081] Undo NOINT from FNDSTD
	CALL CLRSTR		;FIX UP POINTERS IN UDB'S
	MOVE T1,MSTDMS		;GET STRUCTURE NUMBER
	CALL CLRSTB		;CLEAR THE STRTAB ENTRY

; DATABASE IS NOW CONSISTENT AGAIN

	MOVE T1,MSTDMU		;[7.1122]GET STRUCTURE UNIQUE CODE
	TRVAR <MSTHDR,<MSTRPC,3>>
	MOVEM T1,1+MSTRPC	;[7.1122]SAVE STRUCTURE UNIQUE CODE
	MOVEI T3,4		;LENGTH OF ARG BLOCK
	HRLI T3,.IPCRS		;SET UP STR REMOVAL CODE
	MOVEM T3,MSTHDR
	SETO T3,
	HLLZM T3,MSTRPC		;SET JOB NUMBER TO -1 & MOUNT COUNT TO 0
	CALL LGTAD		;GET TIME AND DATE
	MOVEM T1,2+MSTRPC
	CALL DISMES		; THAT STRUCTURE IS BEING DISMOUNTED
	 JFCL			;FAILED

;RETURN TO USER

	OKINT			;PERMIT INTERRUPTS AGAIN
	RETSKP			;RETURN TO USER


; HERE ON ERRORS FOR WHICH THE STRUCTURE IS LOCKED

MSDER1:	MOVEM T1,MSTDME		;SAVE ERROR CODE
	MOVE T1,MSTDMS		;GET STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK THE STRUCTURE
	MOVE T1,MSTDME		;GET ERROR CODE BACK
	RETBAD ()		;FAIL

;LOCAL ROUTINE TO UPDATE OR RELEASE ALL OF THE OFN'S POINTED TO
;BY AN SDB.
;	T1/ ADDRESS OF SDB
;RETURNS +1 ALWAYS

MSTUPO:	XMOVEI T2,[HRLZS T1	;MAKE OFN.PN
		MOVEI T2,PGSIZ	;DO ALL PAGES
		CALLRET UPDPGS] ;AND GO DO THE UPDTAE
	SKIPA
MSTRLO:	XMOVEI T2,RELOFN	;ENTRY TO RELEASE OFN'S
	ASUBR <MSTDB1,MSTRTN>	;SAVE SDB ADDRESS AND ROUTINE
	LOAD T1,STRIDX,(T1)	;GET OFN FOR INDEX TABLE
	CALL @MSTRTN		;DO THE ROUTINE
	MOVE T1,MSTDB1		;GET ADDRESSS OF SDB
	LOAD T1,STRBTB,(T1)	;GET OFN OF BIT TABLE FILE
	SKIPE T1		;IF NONE DON'T
	CALL @MSTRTN		;DO THE ROUTINE
	MOVE T1,MSTDB1		;GET ADDRESS OF SDB
	LOAD T1,STRRDO,(T1)	;GET OFN OF ROOT-DIRECTORY FILE
	CALLRET @MSTRTN		;DO THE ROUTINE AND RETURN
;FIXJOB - ROUTINE TO PURGE STR INFO FROM ALL JSB'S, AND TO
;	   ISSUE A MESSAGE TO ALL USERS WHO HAVE:
;	1.	ACCESS'ED THIS STRUCTURE
;	2.	MOUNTED THIS STRUCTURE
;	3.	CONNECTED TO A DIRECTORY ON THIS STRUCTURE
;
;ACCEPTS IN T1/	STRUCTURE UNIQUE CODE
;	    T2/	ADDRESS OF ASCIZ STRUCTURE NAME
;		CALL FIXJOB
;RETURNS: +1 ALWAYS, STR INFO PURGED AND REQUIRED MESSAGES ISSUED

FIXJOB:	STKVAR <FXJOBC,FXJOBN>
	SAVEP
	MOVEM T1,FXJOBC		;SAVE STRUCTURE UNIQUE CODE
	MOVEM T2,FXJOBN		;SAVE ADDRESS OF STRUCTURE NAME STRING
	MOVSI P1,-NJOBS		;SET UP TO LOOP OVER ALL JOBS IN SYSTEM

; TOP OF LOOP OVER ALL JOBS - MAP THE NEXT JOB'S JSB IF THE JOB EXISTS

FXJB10:	SKIPGE JOBRT(P1)	;DOES THIS JOB EXIST ?
	JRST FXJB60		;NO, GO CHECK NEXT JOB
	HRRZ T1,P1		;YES, GET JOB NUMBER
	CALL MAPJSB		;MAP THE OBJECT JOB'S JSB
	 JRST FXJB60		;JOB DISAPPEARED.  GO CHECK NEXT JOB.
	MOVEM T1,P2		;SAVE OFFSET TO JOB'S JSB
	SETZM P3		;INITIALIZE "MESSAGE-NEEDED" FLAG
	LOCK JSSTLK(P2)		;LOCK THE STRUCTURE INFO BLOCKS IN JSB
	MOVE T1,FXJOBC		;GET STRUCTURE NUMBER
	MOVE T2,P2		;GET OFFSET TO JSB FOR OBJECT JOB
	CALL FNDSTM		;GO GET OFFSET TO BLOCK FOR THIS STRUCTURE
	 JRST FXJB40		;NOT USING THAT STR, GO CHECK CONNECTED DIR

; HERE TO SEE IF A MESSAGE IS NEEDED DUE TO A MOUNT OR ACCESS COMMAND

	SETONE JSSDM,(T2)	;MARK THAT STRUCTURE IS DISMOUNTED
	JE JSADN,(T2),FXJB20	;WAS ANY DIRECTORY ON THIS STR ACCESSED ?
	SETOM P3		;YES, MARK THAT A MESSAGE IS NEEDED
	LOAD T1,JSADN,(T2)	;GET DIRECTORY NUMBER THAT WAS ACCESSED
	LOAD T2,JSSTN,(T2)	;GET STRUCTURE UNIQUE CODE
	HRL T1,T2		;FORM DIRECTORY DESIGNATOR
	CALL SETDIR		;MAP THE ACCESSED DIRECTORY
	 JRST FXJB40		;FAILED, GO UNMAP JSB AND GO ON TO NEXT JOB
	MOVE T1,P2		;GET OFFSET TO MAPPED JSB
	CALL UNACC		;GO "UN-ACCESS" THE DIRECTORY
	 JFCL			;SHOULD NOT FAIL
	CALL USTDIR		;UNLOCK THE DIRECTORY
FXJB20:	JE JSMCI,(T2),FXJB25	;WAS THIS STRUCTURE MOUNTED ?
	SETOM P3		;YES, MARK THAT A MESSAGE IS NEEDED
	SETZRO <JSMCI,JSXCL>,(T2) ;CLEAR STATUS FLAGS
	;..

; CHECK IF ANY FORKS HAD STRUCTURE MOUNTED

FXJB25:	JE JSFMT,(T2),FXJB30	;DID FORK MOUNT STRUCTURE
	SETOM P3		;YES, MARK THAT A MESSAGE IS NEEDED
	SETZM JSFKMT(T2)	;ZERO FORK USERS

; HERE TO SEE IF THE SLOT FOR THIS STRUCTURE IN THIS JSB MAY BE FREED

FXJB30:	MOVE T1,FXJOBC		;GET UNIQUE CODE
	MOVE T2,P2		;GET OFFSET TO MAPPED JSB
	CALL FRJSSO		;GO FREE STR BLOCK IN JSB IF NOW FREE
FXJB40:	UNLOCK JSSTLK(P2)	;UNLOCK STRUCTURE INFO BLOCK LOCK IN JSB

; SEE IF MESSAGE NEEDED BECAUSE JOB CONNECTED TO STRUCTURE

	MOVE T1,P2		;GET OFFSET TO JSB OF OBJECT JOB
	CALL GTOJCD		;GET CONNECTED STR UNIQUE CODE FOR THIS JOB
	HLRZ T1,T1		;KEEP JUST THE STRUCTURE UNIQUE CODE
	CAMN T1,FXJOBC		;WAS USER CONNECTED TO A DIRECTORY ON THIS STR ?
	SETOM P3		;YES, MARK THAT A MESSAGE IS NEEDED
FXJB50:	CALL CLRJSB		;UNMAP THE JSB FOR THE OBJECT JOB

; ISSUE A MESSAGE IF NECESSARY

	SKIPN P3		;IS A MESSAGE REQUIRED ?
	JRST FXJB60		;NO, GO CHECK NEXT JOB
	HLRE T1,JOBPT(P1)	;YES, GET CONTROLLING LINE #
	JUMPL T1,FXJB60		;DETACHED, SKIP MESSAGE
	TXO T1,.TTDES		;FORM DEVICE DESIGNATOR
	HRROI T2,[ASCIZ/[Structure /]
	TTMSG%			;[7190] OUTPUT FIRST PART OF MESSAGE
	 ERJMP .+1		;[7190] 
	HRRO T2,FXJOBN		;[7190] GET POINTER TO ASCIZ STRUCTURE NAME
	TTMSG%			;[7190] OUTPUT STRUCTURE NAME
	 ERJMP .+1		;[7190] 
	HRROI T2,[ASCIZ/ has been dismounted]
/]				;[7190] GET REMAINDER OF MESSAGE
	TTMSG%			;[7190] OUTPUT FINAL PART OF MESSAGE
	 ERJMP .+1		;[7190] 

FXJB60:	AOBJN P1,FXJB10		;LOOP OVER ALL JOBS
	RET			;RETURN


;DEVSTR - ROUTINE TO INITIALIZE DEVICE TABLES FOR A FILE STRUCTURE
;
; ACCEPTS IN T1/ STRUCTURE #
;		CALL DEVSTR
; RETURNS: +1 ALWAYS
; NOTE: DEVLKK IS ASSUMED TO BE LOCKED BY CALLER.

DEVSTR::STKVAR <DVSSTR>		;[7.1112]
	MOVEM T1,DVSSTR		;SAVE STRUCTURE NUMBER
	MOVSI T4,'STR'		;INITIALIZE FIRST PART OF DEVICE NAME
	IDIVI T1,100		;ISOLATE HIGH ORDER DIGIT OF STRUCTURE NUMBER
	ADDI T1,'0'		;CONVERT DIGIT TO SIXBIT
	LSH T1,^D12		;POSITION DIGIT IN HIGH ORDER POSITION
	IOR T4,T1		;ADD HIGH ORDER DIGIT TO DEVICE NAME
	MOVE T1,T2		;GET REMAINDER (SECOND, THIRD DIGITS)
	IDIVI T1,10		;ISOLATE SECOND AND THIRD DIGITS
	ADDI T1,'0'		;CONVERT SECOND  DIGIT TO SIXBIT
	LSH T1,6		;MOVE DIGIT TO MIDDLE POSITION
	IOR T4,T1		;ADD SECOND DIGIT TO NAME
	ADDI T2,'0'		;CONVERT LOW ORDER DIGIT TO SIXBIT
	IOR T4,T2		;ADD THIRD DIGIT TO NAME
	MOVE T1,DVSSTR		;GET STRUCTURE NUMBER AGAIN
	MOVEM T4,DEVNAM+DVXST0(T1) ;SAVE INITIAL STRUCTURE NAME
	MOVX T2,D1%NIU		;GET "STRUCTURE NOT IN USE" FLAG
	IORM T2,DEVCH1+DVXST0(T1) ;MARK THAT STRUCTURE IS NOT IN USE
	RET			;RETURN
; .MSRUS/.MSRNU - READ STATUS OF A UNIT

; ARGUMENT BLOCK DEFINITIONS

MSKSTR (MSTYP,.MSRST,MS%TYP)	;UNIT TYPE IN STATUS WORD

MSTRUS:	STKVAR <MSTRSA,MSTRSP,MSTRSS,<MSTRSB,.MSRLN>,<MSTRSN,2>,MSTUDB>

; LOCAL VARIABLES --
;
; MSTRSA - VIRTUAL ADDRESS OF PAGE USED FOR READING HOME BLOCKS
; MSTRSP - PHYSICAL PAGE NUMBER OF PAGE USED FOR READING HOME BLOCKS
; MSTRSS - STRUCTURE NUMBER
; MSTRSB - ARGUMENT BLOCK TO BE RETURNED TO THE USER
; MSTRSN - ASCIZ STRUCTURE NAME
; MSTUDB - Address of UDB

; ACCUMULATOR USAGE --
;
; P1/ ADDRESS OF ARGUMENT BLOCK IN USER SPACE
; P2/ ADDRESS OF ARGUMENT BLOCK IN MONITOR SPACE
; P3/ STATUS TO BE RETURNED

; VERIFY THAT THE USER HAS THE REQUIRED CAPABILITIES ENABLED

	MOVE T1,CAPENB		;GET ENABLED CAPABILITIES
	TXNN T1,SC%WHL!SC%OPR!SC%MNT	;IS USER CURRENTLY A WHEEL, OR OPERATOR OR MAINT?
	RETBAD (CAPX2)		;NO, RETURN ERROR CODE

; CHECK SIZE OF ARGUMENT BLOCK

	XCTU [ HLRZ T1,1 ]	;GET SIZE OF BLOCK FROM USER
	SKIPG T1		;AT LEAST ONE ITEM REQUESTED ?
	RETBAD (MSTRX3)		;NO, RETURN "ARG BLOCK TOO SMALL" ERROR

; INITIALIZE THE ARGUMENT BLOCK TO BE RETURNED

	MOVEI T2,MSTRSB		;GET ADDRESS OF ARGUMENT BLOCK
	MOVEI T1,1(T2)		;GET DESTINATION ADDRESS
	HRLI T1,(T2)		;GET SOURCE ADDRESS
	SETZM MSTRSB		;CLEAR FIRST WORD OF BLOCK
	BLT T1,.MSRLN-1(T2)	;INITIALIZE ARGUMENT BLOCK

; SET UP CHANNEL, CONTROLLER, AND UNIT NUMBERS IN ARG BLOCK TO BE RETURNED

	UMOVE P1,2		;GET ADDRESS OF ARGUMENT BLOCK IN USER SPACE
	MOVEI P2,MSTRSB		;GET ADDRESS OF ARGUMENT BLOCK IN MONITOR SPACE
	UMOVE T1,.MSRCH(P1)	;GET CHANNEL NUMBER FROM USER
	UMOVE T2,.MSRCT(P1)	;GET CONTROLLER NUMBER FROM USER
	UMOVE T3,.MSRUN(P1)	;GET UNIT NUMBER FROM USER
	DMOVEM T1,.MSRCH(P2)	;STORE INITIAL CHANNEL AND CONTROLLER NUMBERS
	MOVEM T3,.MSRUN(P2)	;STORE INITIAL UNIT NUMBER
	;..
	;..

; DETERMINE IF IT IS NECESSARY TO STEP TO THE NEXT UNIT

	XCTU [HRRZ T4,1]	;GET FUNCTION CODE FROM USER
	CAIN T4,.MSRNU		;IS FUNCTION READ STATUS OF NEXT UNIT ?
	JRST MSTSTP		;YES, GO STEP TO NEXT ONE
	CALL CHKCKU		;SEE IF SPECIFIED UNIT EXISTS
	 RETBAD ()		;NOPE, ERROR
	JRST MSTRS2		;IT'S OK, PROCEED

MSTSTP:	SETCM T4,T1		;GET COMPLEMENT OF T1
	ORCM T4,T2		;THEN OR WITH COMPLEMENT OF T2
	ORCM T4,T3		;ALSO OR WITH COMPLEMENT OF T3
	JUMPE T4,MSTSTY		;IF ALL ARGS WERE -1, THEN SKIP VALIDITY CHECK
	CALL CHKCKU		;MAKE SURE STEPPING FROM A VALID UNIT
	 RETBAD ()		;NOPE, ERROR
	DMOVE T1,.MSRCH(P2)	;YES, RESTORE CHANNEL AND CONTROLLER NUMBERS
	MOVE T3,.MSRUN(P2)	;AND UNIT NUMBER

MSTSTY:	CALL ADVCKU		;ADVANCE TO NEXT DISK UNIT IN SYSTEM
	 RETBAD (MSTX18)	;NO MORE UNITS
	DMOVEM T1,.MSRCH(P2)	;REMEMBER NEW CHANNEL AND CONTROLLER NUMBERS
	MOVEM T3,.MSRUN(P2)	;AND REMEMBER NEW UNIT NUMBER
	MOVE T1,T4		;PUT UDB POINTER IN RIGHT AC

; CHECK TO SEE IF UNIT IS OFF-LINE OR IN MAINTENANCE MODE

MSTRS2:	MOVEM T1,MSTUDB		;[7.1129]SAVE UDB ADDRESS
	MOVE T2,UDBDSH(T1)	;[7.1129]GET HIGH ORDER SERIAL #
	MOVEM T2,.MSDSH(P2)	;SAVE IT
	MOVE T2,UDBDSN(T1)	;GET LOW ORDER SERIAL #
	MOVEM T2,.MSDSN(P2)	;SAVE IT
	MOVE T2,UDBMID(T1)	;GET MAINTANCE ID
	MOVEM T2,.MSMID(P2)	;SAVE IT
	SETZM P3		;INITIALIZE STATUS TO BE RETURNED
	CALL GETSTR		;GET THE STRUCTURE NUMBER FOR THIS UNIT
	 JRST [	IOR P3,T1	;FAILED, UNIT OFFLINE OR USED FOR MAINTENANCE
		JRST MSTRS3]	;GO COPY DISK TYPE INFO
	MOVEM T1,MSTRSS		;SAVE UNIT IN STRUCTURE,,STRUCTURE NUMBER
	CAME T1,[-1]		;IS THIS UNIT IN A STRUCTURE ?
	TXO P3,MS%MNT		;YES, MARK THAT THIS UNIT IS PART OF A STRUCTURE
	TXNE T3,MS%2PT		;DUAL-PORTED BETWEEN 2 KLS?
	TXO P3,MS%2PT		;YES. MARK STATUS
	TXNE T3,MS%SVD		;SERVED?
	TXO P3,MS%SVD		;YES, MARK IT
 	TXNE T3,MS%IAC		;Is the unit in special homeblock check?
 	TXO P3,MS%IAC		;Yes, mark it as inaccessible then

	;..
	;..

; HERE TO COPY THE DISK SIZE TABLE FOR THIS DISK TYPE

MSTRS3:	STOR T2,MSTYP,(P2)	;SAVE UNIT TYPE FOR USER
	MOVSI T1,-NDSKUT	;PREPARE TO FIND TYPE IN DSKUTP
MSTRS4:	CAME T2,DSKUTP(T1)	;FOUND IT?
	AOBJN T1,MSTRS4		;NO, KEEP LOOKING (SURE TO FIND IT)
	MOVE T1,DSKSIZ(T1)	;GET ADDRESS OF DISK SIZE TABLE
	MOVE T2,LPPCYL(T1)	;GET LOST SECTORS/CYL
	MOVEM T2,.MSRLS(P2)	;COPY FOR USER
	MOVE T2,SECSRF(T1)	;GET SECTORS/SURFACE
	MOVEM T2,.MSRSS(P2)	;COPY FOR USER
	MOVE T2,TRECPP(T1)	;GET TRUE SECTORS/PAGE
	MOVEM T2,.MSTSP(P2)	;COPY FOR USER
	HRLI T1,SECPAG(T1)	;GET SOURCE ADDRESS FOR COPY
	HRRI T1,.MSRSP(P2)	;GET DESTINATION (ARG BLOCK)
	BLT T1,.MSRBT(P2)	;COPY SIZE DATA FOR USER
	TXNE P3,MS%OFL!MS%DIA!MS%IAC  ;Is unit unavailable or inaccessible?
	JRST MSTRS6		;YES, JUST GO STORE WHAT WE HAVE

; HERE TO READ THE HOME BLOCKS FOR THE SPECIFIED UNIT

	DMOVE T1,.MSRCH(P2)	;GET CHANNEL AND CONTROLLER NUMBERS
	MOVE T3,.MSRUN(P2)	;GET UNIT NUMBER
	CALL MSTRHB		;GO READ THE HOME BLOCKS
	 JRST [	CAIN T1,MSTRX5	;UNIT OFF-LINE ?
		TXO P3,MS%OFL	;YES, MARK STATUS
		MOVE T2,MSTUDB	;Get back address of UDB
		MOVE T2,UDBST1(T2)  ;Get secondary status word
		TXNE T2,U1.OFS	;Did TOPS-20 force the disk offline?
		TXO P3,MS%IAC	;Yes, mark it inaccessible
		CAIN T1,MSTX20	;DATA ERROR READING HOME BLOCKS ?
		TXO P3,MS%ERR	;YES, MARK STATUS
		CAIN T1,MSTRX4	;IS THIS NO FREE SPACE?
		RETBAD ()	;YES QUIT AND GIVE THIS ERROR CODE
		JRST MSTRS6 ]	;GO RETURN VALUES TO USER
	MOVEM T1,MSTRSA		;SAVE VIRTUAL ADDRESS OF HOME BLOCK PAGE
	MOVEM T2,MSTRSP		;SAVE PHYSICAL PAGE NUMBER

; CHECK THE HOME BLOCKS FOR THIS UNIT

	CALL MSTHBC		;GO CHECK THE HOME BLOCKS
	SKIPN T1		;[7216] EVERYTHING OK?
	TXO P3,MS%HBB		;[7216] NO, BAD HOME BLOCKS
	;..
	;..

; GET THE STRUCTURE NAME AND UNIT INFO FROM THE HOME BLOCK

	MOVE T2,MSTRSA		;GET VIRTUAL ADDRESS OF FIRST HOME BLOCK
	TXNN T1,HB%1OK		;IS THE FIRST HOME BLOCK OK ?
	ADDI T2,HBLEN		;NO, USE THE SECOND HOME BLOCK
	MOVS T3,HOMLUN(T2)	;GET UNIT INFO FROM HOME BLOCK
	MOVEM T3,.MSRNS(P2)	;SAVE UNIT INFO IN ARG BLOCK TO BE RETURNED
	XCTU [HLRZ T1,1]	; GET ARG BLK LENGTH
	CAIGE T1,.MSRSN+1	; DOES ARG BLK HAVE .MSRSN WORD?
	  JRST MSTRS7		; NO! SKIP STR NAME STRING XFER
	MOVE T1,HOMSNM(T2)	;GET STRUCTURE NAME FROM HOME BLOCK
	MOVEI T2,MSTRSN		;GET ADDRESS DESTINATION FOR STRING
	CALL SIXASC		;CONVERT STRING TO SIXBIT
	MOVEI T1,.MSRSN(P1)	;GET ADDRESS IN USER SPACE OF PTR TO DESTINATION
	MOVEI T2,MSTRSN		;GET ADDRESS OF STRUCTURE NAME STRING
	CALL STOSTR		;STORE NAME STRING IN USER SPACE
	MOVEM T1,.MSRSN(P2)	;SAVE UPDATED POINTER IN ARGUMENT BLOCK

; COPY THE UNIT-, OWNER-, AND FILE-SYSTEM-ID FIELDS FROM THE HOME BLOCK
;  AND THE SERIAL NUMBER, ALSO

MSTRS7:	MOVE T2,MSTRSA		;GET START ADR OF HOME BLOCK PAGE
	HRLI T1,HOMUID(T2)	;GET SOURCE ADDRESS
	HRRI T1,.MSRUI(P2)	;GET DESTINATION ADDRESS
	BLT T1,.MSRFI+2(P2)	;COPY ID DATA FROM HOME BLOCK
	MOVE T1,HOMSER(T2)	;GET CPU SERIAL NUMBER
	MOVEM T1,.MSRSE(P2)	; AND COPY IT

; CHECK THE BAT BLOCKS ON THIS UNIT

MSTRS5:	DMOVE T1,.MSRCH(P2)	;GET CHANNEL AND CONTROLLER NUMBERS
	MOVE T3,.MSRUN(P2)	;GET UNIT NUMBER
	HRL T4,MSTRSA		;GET VIRTUAL ADDRESS OF HOME BLOCK PAGE
	HRR T4,MSTRSP		;GET PHYSICAL PAGE NUMBER OF BAT BLOCK PAGE
	CALL UNIBAT		;CHECK THE BAT BLOCKS FOR THIS UNIT
	 TXO P3,MS%BBB		;BAT BLOCKS BAD, MARK STATUS

; UNLOCK THE HOME BLOCK PAGE AND RELEASE THE PAGE

	MOVE T1,MSTRSP		;GET PHYSICAL CORE PAGE NUMBER
	CALL MULKCR		;UNLOCK THE HOME BLOCK PAGE
	MOVE T1,MSTRSA		;GET VIRTUAL ADDRESS OF HOME BLOCK PAGE
	CALL RELPAG		;RELEASE THE PAGE
	OKINT			;PERMIT INTERRUPT AGAIN
	;..
	;..

; COPY STRUCTURE INFORMATION FROM THE SDB

	HRRZ T1,MSTRSS		;GET STRUCTURE NUMBER
	CAIN T1,-1		;IS UNIT PART OF A STRUCTURE ?
	JRST MSTRS6		;NO, IGNORE STRUCTURE INFORMATION
	MOVE T2,STRTAB(T1)	;GET ADDRESS OF SDB FOR THIS STRUCTURE
	LOAD T1,STRNSS,(T2)	;GET NUMBER OF SECTORS FOR SWAPPING
	LSH T1,-2		;CONVERT TO PAGES
	LOAD T3,STRNUM,(T2)	;GET NUMBER OF UNITS IN STRUCTURE
	IMUL T1,T3		;NUMBER OF SWAPPING PAGES ON STRUCTURE
	MOVEM T1,.MSRSW(P2)	;SAVE NUMBER OF SWAPPING SECTORS
	XCTU [HLRZ T1,1]	; GET ARG BLK SIZE
	CAIGE T1,.MSRSA+1	; DOES IT HAVE .MSRSA WORD
	  JRST MSTRS6		; NO- SKIP ALIAS STRING XFER
	HRRZ T1,MSTRSS		;GET STRUCTURE NUMBER
	MOVE T1,DEVNAM+DVXST0(T1) ;GET ALIAS OF THIS STRUCTURE
	MOVEI T2,MSTRSN		;GET ADDRESS OF DESTINATION OF ASCIZ STRING
	CALL SIXASC		;CONVERT SIXBIT TO ASCIZ
	MOVEI T1,.MSRSA(P1)	;GET ADR IN USER SPACE OF POINTER TO DESTINATION
	MOVEI T2,MSTRSN		;GET ADDRESS OF ASCIZ STRUCTURE NAME
	CALL STOSTR		;GO STORE THE STRUCTURE NAME
	MOVEM T1,.MSRSA(P2)	;STORE UPDATED POINTER IN ARGUMENT BLOCK

; RETURN ARGUMENTS TO THE USER ARGUMENT BLOCK

MSTRS6:	IORM P3,.MSRST(P2)	;STORE STATUS IN ARGUMENT BLOCK
	MOVE T3,P1		;COPY ADDRESS OF USER ARGUMENT BLOCK
	MOVE T2,P2		;GET SOURCE
	XCTU [ HLRZ T1,1 ]	;GET SIZE OF USER ARGUMENT BLOCK
	CAILE T1,.MSRLN		;BIGGER THAN MAX ALLOWED ?
	MOVEI T1,.MSRLN		;YES, RETURN ONLY MAX # OF WORDS
	CALL BLTMU1		;COPY RESULTS TO USER SPACE
	RETSKP			;RETURN TO USER

; .MSSSS - SET STRUCTURE STATUS

; MASK OF BITS WHICH USER IS PERMITTED TO CHANGE --

MSTMSK==MS%DIS!MS%DOM!MS%NRS!MS%RWD!MS%RWS!MS%DMP ;[7.1081] 

MSTSSS:	MOVE T1,CAPENB		;GET ENABLED CAPABILITIES
	TXNN T1,SC%WHL!SC%OPR	;REQUIRED PRIVILEGES ENABLED ?
	RETBAD (MSTRX2)		;NO, RETURN "INSUFFICIENT CAPABILITIES" ERROR

; CHECK SIZE OF ARGUMENT BLOCK

	XCTU [ HLRZ T1,1 ]	;GET SIZE OF USER'S ARGUMENT BLOCK
	CAIGE T1,.MSSLN		;BLOCK BIG ENOUGH ?
	RETBAD (MSTRX3)		;NO, RETURN "ARG BLOCK TOO SMALL" ERROR

; GET STRUCTURE NUMBER AND SDB ADDRESS

	UMOVE P1,2		;GET ADDRESS OF USER'S ARGUMENT BLOCK
	UMOVE T1,.MSSSN(P1)	;GET STRUCTURE NAME FROM ARGUMENT BLOCK
	CALL FNDSTD		;[7.1081] (T1/T1) Get the structure number
	 RETBAD (MSTX21)	;STRUCTURE NOT MOUNTED WITH THAT NAME
	MOVE P2,STRTAB(T1)	;GET ADDRESS OF SDB FOR THIS STRUCTURE

; SET REQUESTED STATUS BITS

	UMOVE T3,.MSSST(P1)	;GET NEW STATUS BITS
	UMOVE T4,.MSSMW(P1)	;GET MASK WORD FROM ARGUMENT BLOCK
	CAIE T1,PSNUM		;[7.1112]Changing status of boot structure?
	CAMN T1,LGSIDX		;[7.1112]Or the Login Structure?
	TXZA T4,MSTMSK&<^-<MS%DOM!MS%DIS!MS%NRS>> ;YES, DO NOT ALLOW SYSTEM STR TO BE DISMOUNTED
	TXZ T4,MSTMSK		;CLEAR BITS WHICH USER IS ALLOWED TO CHANGE
	JUMPN T4,[CALL ULKSTR	;IF CHANGING ILLEGAL BITS, UNLOCK THE STRUCTURE
		  RETBAD (MSTX22)] ;RETURN "ILLEGAL TO CHANGE SPECIFIED BITS"
	UMOVE T4,.MSSMW(P1)	;GET MASK WORD AGAIN
	AND T3,T4		;GET JUST THE BITS TO BE SET
	IORM T3,SDBSTS(P2)	;SET THE BITS
	UMOVE T3,.MSSST(P1)	;GET THE STATUS AGAIN
	ANDCA T3,T4		;GET JUST THE BITS TO BE CLEARED
	ANDCAM T3,SDBSTS(P2)	;CLEAR THE BITS
	CALL ULKSTR		;UNLOCK THE STRUCTURE
	UMOVE T1,.MSSST(P1)	;[7.1081] Get the new status again
	UMOVE T2,.MSSMW(P1)	;[7.1081] Get the mask of bits being changed
	TXNE T2,MS%DMP		;[7.1081] Are we changing the dumpable status?
	TXNN T1,MS%DMP		;[7.1081] Yes - did we just set it?
	RETSKP			;[7.1081] No need to run SETSPD, return to user
	AOS DOBJB0		;[7.1081] We added a dumpable structure, 
	AOS JB0FLG		;[7.1081]  request SETSPD to copy dumps if any
	RETSKP			;[7.1081] Return to user

; .MSHOM - MODIFY HOME BLOCK

MSTHOM:	STKVAR <HSTRNM,MSHERR>
	MOVE A,CAPENB		;MAKE SURE USER PRIVILEGED
	TXNN A,SC%WHL!SC%OPR
	RETBAD (MSTRX2)		;"INSUFFICIENT PRIVS"
	XCTU [HLRZ A,1]		;GET USER'S ARG BLOCK LENGTH
	CAIGE A,4		;ENOUGH INFO SUPPLIED?
	RETBAD (MSTRX3)		;NO, "ARG BLOCK TOO SMALL"
	UMOVE P1,2		;GET ADDRESS OF ARGUMENT BLOCK
	UMOVE A,.MSHNM(P1)	;GET DESIGNATOR FOR STRUCTURE
	CALL FNDSTD		;[7.1081] (T1/T1) Locate the structure
	 RETBAD (MSTX21)	;"STRUCTURE NOT MOUNTED"
	MOVEM A,HSTRNM		;REMEMBER STRUCTURE NUMBER
	CALL CKSTOF		;[7.1063](T1/T1)IS THIS STRUCTURE OFFLINE?
	 JRST MSH1		;[7.1063]RETURN "STRUCTURE IS OFFLINE"
	UMOVE B,.MSHOF(P1)	;GET OFFSET INTO HOMEBLOCK
	UMOVE C,.MSHVL(P1)	;GET NEW DATA
	UMOVE D,.MSHMK(P1)	;GET MASK SHOWING WHICH PARTS OF WORD ARE TO CHANGE
	CALL MODHOM		;MODIFY HOME BLOCKS
	 JRST MSH1		;FAILED
	MOVE A,HSTRNM		;SUCCEEDED, GET STR NUMBER AGAIN
	CALL ULKSTR		;RELEASE THE STRUCTURE
	RETSKP			;GIVE GOOD RETURN

MSH1:	MOVEM A,MSHERR		;REMEMBER ERROR CODE
	MOVE A,HSTRNM		;GET STRUCTURE NUMBER
	CALL ULKSTR		;RELEASE STRUCTURE
	MOVE A,MSHERR		;GET REASON FOR FAILURE
	RETBAD			;ANNOUNCE FAILURE

; .MSSGS - GET STRUCTURE STATUS

; BITS WHICH CAN BE OBTAINED BY THE USER --

MSGMSK==MS%EXC!MS%INI!MS%PPS!MS%PS!MS%DIS!MS%DOM!MS%NRS!MS%LIM!MS%RWD!MS%RWS!MS%OFS!MS%DMP ;[7.1063][7.1081]

MSTGSS:	STKVAR <MSGSTR,<MSTGSB,.MSGLN>,<MSTGSI,2>>

; CHECK SIZE OF ARGUMENT BLOCK

	XCTU [HLRZ P4,1]	;GET SIZE OF USER'S ARGUMENT BLOCK
	CAIGE T1,1		;AT LEAST THE STRUCTURE NAME GIVEN ?
	RETBAD (MSTRX3)		;NO, RETURN "ARG BLOCK TOO SMALL" ERROR

; SEE IF DESIRED STRUCTURE IS MOUNTED

	UMOVE P1,2		;GET ADDRESS OF USER'S ARGUMENT BLOCK
	MOVEI P2,MSTGSB		;GET ADDRESS OF ARGUMENT BLOCK IN MONITOR SPACE
	SETZM P2,.MSGSI(P2)	;INITIALIZE POINTER TO STR NAME STRING
	UMOVE T1,.MSGSN(P1)	;GET STRUCTURE NAME FROM USER
	MOVEM T1,.MSGSN(P2)	;SAVE STRUCTURE NAME IN BLOCK TO BE RETURNED
	CALL FNDSTD		;[7.1081] (T1/T1) See if structure is mounted
	 RETBAD (MSTX21)	;NO STRUCTURE WITH THAT NAME IS MOUNTED
	MOVEM T1,MSGSTR		;SAVE STRUCTURE NUMBER

; GET THE STATUS BITS FOR THE STRUCTURE

	MOVE T2,STRTAB(T1)	;GET ADDRESS OF SDB FOR THIS STRUCTURE
	MOVX P3,MSGMSK		;GET MASK OF BITS THAT CAN BE RETURNED
	AND P3,SDBSTS(T2)	;GET STRUCTURE STATUS TO RETURN
	CAIN T1,PSNUM		;[7.1112]Getting status of the boot structure?
	TXO P3,MS%PPS!MS%BS!MS%NRS ;[7.1112]Yes. Turn on special bits
	CAMN T1,LGSIDX		;[7.1112]Getting status of Login Structure?
	TXO P3,MS%PPS!MS%PS!MS%NRS ;[7.1112]Yes. Turn on special bits
	MOVEM P3,.MSGST(P2)	;SAVE STATUS IN ARGUMENT BLOCK

; GET STRUCTURE INFORMATION

	LOAD T4,STRNUM,(T2)	;GET NUMBER OF UNITS IN STRUCTURE
	MOVEM T4,.MSGNU(P2)	;SAVE NUMBER OF UNITS IN ARG BLOCK TO RETURN
	LOAD T4,STRMC,(T2)	;GET MOUNT COUNT FOR THIS STRUCTURE
	MOVEM T4,.MSGMC(P2)	;SAVE MOUNT COUNT IN ARGUMENT BLOCK
	LOAD T4,STROF,(T2)	;GET OPEN FILE COUNT
	MOVEM T4,.MSGFC(P2)	;SAVE OPEN FILE COUNT IN ARGUMENT BLOCK
	LOAD T1,STRNAM,(T2)	;GET SIXBIT STRUCTURE NAME
	MOVEI T2,MSTGSI		;GET ADDRESS WHERE ASCIZ NAME WILL GO
	CALL SIXASC		;CONVERT SIXBIT TO ASCII
	MOVEI T1,.MSGSI(P1)	;GET ADDRESS OF USER'S POINTER
	MOVEI T2,MSTGSI		;GET ADDRESS OF ASCIZ STR NAME IN MONITOR SPACE
	CAILE P4,.MSGSI		;USER PROVIDE ENOUGH SPACE FOR STR NAME PTR ?
	CALL STOSTR		;YES, USE POINTER TO STORE STRUCTURE NAME
	XCTU [SKIPE .MSGSI(P1)]	;DID USER SUPPLY A POINTER ?
	MOVEM T1,.MSGSI(P2)	;YES, SAVE POINTER TO NAME IN ARG BLOCK
	; ..
	; ..

; RETURN ARGUMENT BLOCK TO THE USER

	MOVE T3,P1		;COPY ADDRESS OF USER ARGUMENT BLOCK
	MOVE T2,P2		;GET SOURCE
	CAILE P4,.MSGLN		;BIGGER THAN MAX ALLOWED ?
	MOVEI P4,.MSGLN		;YES, RETURN ONLY MAX # OF WORDS
	MOVE T1,P4		;GET LENGTH
	CALL BLTMU1		;COPY RESULTS TO USER SPACE
	MOVE T1,MSGSTR		;GET THE STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK THE STRUCTURE
	RETSKP			;RETURN TO USER

; .MSIMC/.MSDMC - INCREMENT/DECREMENT MOUNT COUNT

;ACCEPTS: SAME AS .MSTR

;RETURNS +1: FAILED, ERROR CODE IN AC1
;	 +2: SUCCEEDED
;REGISTER USAGE:
;	P1/ ADDRESS OF USER'S ARGUMENT BLOCK
;	P2/ STRUCTURE NUMBER
;	P3/ STRUCTURE UNIQUE CODE
;	P4/ JOB NUMBER
;	P5/ JSB OFFSET


MSTIMC:	TDZA T1,T1		;MARK THAT COUNT SHOULD BE INCREMENTED
MSTDMC:	SETOM T1		;MARK THAT COUNT SHOULD BE DECREMENTED
	ASUBR <MSTMCF>

; CHECK SIZE OF USER ARGUMENT BLOCK

	XCTU [HLRZ P4,1]	;GET SIZE OF USER ARGUMENT BLOCK
	CAIGE P4,1		;AT LEAST ONE ITEM SPECIFIED ?
	RETBAD (MSTRX3)		;NO, ARGUMENT BLOCK TOO SMALL

; CHECK THAT THE STRUCTURE IS MOUNTED

	UMOVE P1,2		;GET ADDRESS OF USER'S ARGUMENT BLOCK
	UMOVE T1,.MSDEV(P1)	;GET DEVICE DESIGNATOR OF STRUCTURE
	CALL FNDSTD		;[7.1081] (T1/T1) Go see if structure mounted
	 RETBAD ()		;FAILED, STRUCTURE NOT MOUNTED
	MOVEM T1,P2		;SAVE STRUCTURE NUMBER
	CALL STRCNV		;GET STRUCTURE UNIQUE CODE
	 JRST MCTERR		;FAILED, UNLOCK STRUCTURE AND RETURN
	MOVEM T1,P3		;SAVE UNIQUE CODE
	HRLI T1,.DVDES+.DVDSK	;SET DEVICE DESIGNATOR
	GTOKM (.GOSMT,<T1>,MCTNOK) 	;GETOK FOR MOUNT/DISMOUNT

;CHECK IF USER WANTS TO CHANGE MOUNT COUNT FOR ANOTHER JOB

	SETZ P5,		;SET JSB OFFSET TO ZERO
	CAILE P4,.MSJOB		;HAS ANOTHER JOB BEEN SPECIFIED
	JRST [ CALL MSTJOB	;YES, SEE IF VALID (OFFSET TO JSB IN T1)
		JRST MCTERR	;NOT A VALID REQUEST
		MOVE P5,T1	;STORE JSB OFFSET
		MOVE P4,T2	;SAVE JOB INDEX
		JRST .+1]
	SKIPN P5		;IF THERE IS NO JSB OFFSET
	MOVE P4,JOBNO		; SET JOB INDEX TO BE 'THIS JOB'

		; ...

		; ...

; INCREMENT OR DECREMENT THE MOUNT COUNT AS APPROPRIATE

	LOCK JSSTLK(P5)		;LOCK THE STRUCTURE INFO LOCK IN THE JSB
	MOVE T1,P3		;GET UNIQUE CODE AGAIN
	MOVE T2,P5		;GET OFFSET TO JSB
	CALL GTSTOJ		;GET OFFSET FOR THIS STRUCTURE IN JSB
	 JRST [	UNLOCK JSSTLK(P5) ;UNLOCK THE STRUCTURE INFO LOCK IN JSB
	 	JRST MCTERR]	; UNLOCK STRUCTURE AND RETURN ERROR
	MOVE T1,P2		;GET STRUCTURE NUMBER AGAIN
	MOVE T3,P4		;GET JOB # FOR WHICH THIS IS BEING DONE
	MOVE T4,MSTMCF		;GET INCREMENT/DECREMENT FLAG
	ADDI T4,1		;FORM OFFSET TO PROPER CALL INSTRUCTION
	XCT [CALL DECMNC	;GO INCREMENT THE MOUNT COUNT
	     CALL INCMNC](T4)	;GO DECREMENT THE MOUNT COUNT
	 JRST [	UNLOCK JSSTLK(P5) ;UNLOCK THE JSB STRUCTURE LOCK
		JRST MCTERR ]	;GO UNLOCK STRUCTURE AND RETURN ERROR
	MOVE T1,P3		;GET UNIQUE CODE AGAIN
	MOVE T2,P5		;GET JSB OFFSET AGAIN
	CALL FRJSSO		;FREE JSB STR STORAGE IF NOW UNUSED
	UNLOCK JSSTLK(P5)	;UNLOCK THE STRUCTURE INFO LOCK
	MOVE T1,P2		;GET THE STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK THE STRUCTURE
	SKIPN P5		;WAS THIS WORK FOR SOMEONE ELSE
	RETSKP			;NO, RETURN
	CALL CLRJSB		;UNMAP THE OBJECT JSB
	HLRE T1,JOBPT(P4)	;GET TTY OF OBJECT JOB
	SKIPGE T1		;IS IT DETACHED?
	RETSKP			;YES, FORGET MESSAGE

;SEND MESSAGE OF STRUCTURE MOUNT TO TTY, IF DONE TO ANOTHER JOB

	TXO T1,.TTDES		;[7190] MAKE LINE NUMBER INTO DESIGNATOR
	HRROI T2,[ASCIZ /
[/]				;[7190] 
	TTMSG%			;[7190] 
	 ERJMP .+1		;[7190] 
	MOVE T2,P2		;GET STRUCTURE NUMBER
	CALL MSTOUT		;OUTPUT STRUCTURE NAME
	HRROI T2,[ASCIZ / Mounted]
/]
	SKIPE MSTMCF		;IF STRUCTURE IS BEING DISMOUNTED,
	HRROI T2,[ASCIZ / Dismounted]
/]				; SAY SO
	TTMSG%			;[7190] 
	 ERJMP .+1		;[7190] 
	RETSKP			;SUCCESSFUL RETURN

; HERE ON AN ERROR

MCTNOK:	CALL MCTERR		;HERE ON GETOK FAILURE TO UNLOCK STRUCTURE
	ITERR ()		;RETURN ACJ ERROR 

MCTERR:	EXCH P2,T1		;SAVE ERROR CODE, GET STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK THE STRUCTURE
	SKIPE P5		;WAS THIS WORK FOR SOMEONE ELSE?
	CALL CLRJSB		;YES, CLEAR MAPPED JSB
	MOVE T1,P2		;RESTORE THE ERROR CODE
	RETBAD ()			;RETURN ERROR TO USER

;Set structure mount attribute .MSCSM
;	Returns
;		+1 failed. Code in T1
;		+2 OK
;register usage
;	P1 Structure number
;	P2 requested status
;	P3 SDB address

;   IFN CFSCOD,<			;If CFS stuff
MSTCSM:	TMNN SC%WHL!SC%OPR,CAPMSK ;Is this user privileged?
	RETBAD(MSTRX2)		;No. Error!
	XCTU [HLRZ T2,T1]	;Get count
	CAIG T2,.MSCST		;Need at least two words
	RETBAD (MSTRX3)		;Not.

	UMOVE T1,2		;Get address of block
	XCTU [DMOVE P1,.MSCDV(T1)] ;Get args
	ANDX P2,MS%EXC		;Only this bit, please
	MOVE T1,P1
	CALL FNDSTD		;[7.1081] (T1/T1) Get and lock structure
	 RETBAD()		;Something amiss here
	MOVE P1,T1
	MOVE P3,STRTAB(T1)	;Get SDB
	MOVE T2,SDBSTS(P3)	;Get the status
	ANDX T2,MS%EXC		;Isolate the exclusive bit
	CAMN T2,P2		;Same?
	IFSKP.			;If not
	 LOCK STRLOK		;Single thread this
	 SKIPN P2		;Want exclusive or shared?
	 TDZA T2,T2		;Shared
	 MOVEI T2,1		;Exclusive
	 CALL CFSSUG		;Do it.
	 IFNSK.			;if failed
	  UNLOCK STRLOK
	  EXCH T1,P1
	  CALL ULKSTR		;Unlock the structure
	  MOVE T1,P1		;Error code
	  RETBAD()
	 ENDIF.
	 SETZRO STEXL,(P3)	;Clear this bit
	 IORM P2,SDBSTS(P3)	;Set new value
	 UNLOCK STRLOK
	ENDIF.
	MOVE T1,P1
	CALL ULKSTR		;Free the structure lock
	RETSKP			;And success!
;   >	;IFN CFSCOD
   REPEAT 0,<			;CFSCOD NO LONGER USED
   IFE CFSCOD,<
MSTCSM:	RETBAD(MSTRX1)		;Illegal in this case
   >	;IFE CFSCOD
   >				;END REPEAT 0

;MSTJOB - ROUTINE TO SET UP MOUNT COUNT CHANGE FOR ANOTHER JOB
;
;ACCEPTS:
;	P1/ ADDRESS OF USER'S ARGUMENT BLOCK
;	CALL MSTJOB
;RETURNS: +1	FAILED, ERROR CODE IN T1
;	  +2	SUCCESS, JSB STRUCTURE FOR OTHER JOB SET UP
;			T1/ OFFSET TO JSB OR ZERO FOR THIS JOB
;			T2/ Local Job Index
;NOTE:THIS ROUTINE RETURNS THE LOCAL JOB INDEX, NOT THE GLOBAL NUMBER.

MSTJOB:	STKVAR<MSTT2>
	UMOVE T1,.MSJOB(P1)	;GET JOB # FOR WHICH THIS IS TO BE DONE
	CAME T1,[-1]		;DID USER SPECIFY 'THIS JOB'
	CAMN T1,GBLJNO		; OR JOB # SAME AS USER'S?
	JRST [ MOVE T2,JOBNO	;YES, GET JOB # IN T2
		SETZ T1,	; THERE IS NO JSB OFFSET
		RETSKP]	
	MOVE T2,CAPENB		;GET ENABLED CAPABILITIES
	TXNN T2,SC%WHL!SC%OPR	;WHEEL OR OPERATOR?
	RETBAD (CAPX1)		;NO. REQUIRED FOR THIS FUNCTION
	CALL GL2LCL		;CONVERT GLOBAL JOB NUMBER TO A LOCAL
	 RETBAD(ARGX07)		;NO, ILLEGAL JOB NUMBER
	MOVEM T1,MSTT2		;STORE JOB INDEX
	CALL MAPJSB		;MAP JOB'S JSB (OFFSET IN T1)
	 RETBAD	(ARGX08)	;JOB DOESN'T EXIST
	MOVE T2,MSTT2
	RETSKP			;SUCCESS


;INCMNT - ROUTINE TO INCREMENT THE MOUNT COUNT FOR A STRUCTURE
;
;ACCEPTS IN T1/	STRUCTURE NUMBER
;	    T2/ OFFSET TO JSB DATA FOR THIS STRUCTURE
;	    T3/ JOB # FOR WHICH INCREMENT BEING DONE(IF CALLING INCMNC)
;		CALL INCMNT/INCMNC
;RETURNS: +1	 FAILED, ERROR CODE IN T1
;	  +2	SUCCESS, COUNT INCREMENTED IF NOT PREVIOUSLY INCREMENTED
;			 BY THIS JOB.
;
; NOTE: STRUCTURE MUST BE LOCKED DURING THIS ROUTINE

INCMNT::MOVE T3,JOBNO		;INCREMENT FOR THIS JOB
INCMNC:	JN JSMCI,(T2),[RETBAD (MSTX31)]	;YES, RETURN IF ALREADY INCREMENTED BY THIS JOB
	CALL CKSTOF		;[7.1063](T1/T1)IS STRUCTURE OFFLINE?
	 RETBAD ()		;[7.1063]RETURN "STRUCTURE IS OFFLINE"
	MOVE T4,STRTAB(T1)	;GET ADDRESS OF STRUCTURE DATA BLOCK TO THIS STR
	JE STDIS,(T4),INCMN2	;IS STRUCTURE BEING DISMOUNTED ?
	RETBAD (MSTX33)		;YES, ALLOW NO FURTHER INCREMENTS
INCMN2:				;DON'T PERMIT INTERRUPTS WHEN CHANGING DATA BASE
	NOSKED			;MUST CHANGE JSB AND SDB "SIMULTANEOUSLY"
	SETONE JSMCI,(T2)	;MARK THAT COUNT HAS BEEN INCREMENTED
	JN JSFMT,(T2),INCMN3	;HAS A FORK ALREADY INCREMENTED COUNT
	INCR STRMC,(T4)		;BUMP THE MOUNT COUNT
	MOVE T1,T4		;SET UP SDB FOR CALL TO DISMES
	SETZ T4,		;SET FLAG THAT MESSAGE NEEDS TO BE SENT
INCMN3:	OKSKED			;BOTH CHANGED, PERMIT SCHEDULING AGAIN
	JUMPN T4,RSKP		;DOES A MESSAGE NEED TO BE SENT?
	SUBI T2,JSSTRT		;SET UP T2 TO CONTAIN THE JSB OFFSET
	TRZ T2,777
	CALL SNDUSG		;YES, SEND USAGE INFO TO DEVICE ALLOCATOR
	RETSKP			;RETURN SUCCESS

;DECMNC - ROUTINE TO CHECK LEGALITY OF DECREMENTING COUNT
;	  AND CALL DECMNT, IF LEGAL
;
;ACCEPTS IN T1/ STRUCTURE NUMBER
;	    T2/ OFFSET TO JSB DATA FOR THIS STRUCTURE
;	    T3/ JOB # FOR WHICH DECREMENT BEING DONE
;	    P3/ STRUCTURE UNIQUE CODE
;	    P5/ OFFSET TO JSB OBTAINED FROM SETJSB
;		CALL DECMNC
;RETURNS: +1	FAILED, ERROR CODE IN T1
;	  +2	SUCCESS, DECREMENT LEGAL AND DONE
;
;NOTE: STRUCTURE MUST BE LOCKED DURING THIS ROUTINE

;A USER IS PROHIBITED FROM DOING THE DECREMENT FUNCTION IF HE IS STILL
;CONNECTED TO THE STRUCTURE, OR IF ANY JFN'S ARE STILL IN USE FOR THAT
;STRUCTURE

DECMNC:	JUMPE T1,DECCAL		;FORGET CHECK IF THIS IS PS
	MOVE T4,STRTAB(T1)	;IS THIS STRUCTURE PUBLIC?
	JN STPS,(T4),DECCAL	;SKIP CHECKING IF STRUCTURE IS PUBLIC
	JN STNRS,(T4),DECCAL	; OR IF STRUCTURE IS NOT REGULATED
	LOAD T4,JSUC,(P5)	;GET CONNECTED STR UNIQUE CODE
	CAMN T4,P3		;IS STR BEING DECREMENTED SAME?
	RETBAD (MSTX37)		;YES, RETURN
	LOCK JFNLCK(P5)		;LOCK JFN'S WHILE CHECKING DEVICES
	MOVN T4,MAXJFN(P5)	;GET # OF USED JFN'S
	JUMPE T4,DECMN2		;JUMP IF NONE USED
	HRLZ T4,T4		;SET UP INDEX TO JFN'S
	HRR T4,P5		;GET JSB OFFSET
	STKVAR <MSTT3>
	MOVEM T3,MSTT3		;SAVE JOB #
DECMN1:	HRRZ T3,FILDEV(T4)	;CHECK TO SEE THIS IS  A DISK
	CAIE T3,DSKDTB		;CHECK FOR DISK DTBICE
	JRST DECMN3		;NOT A DISK PROCEED
	LOAD T3,STR,(T4)	;GET JFN'S STRUCTURE CODE
	SKIPE FILSTS(T4)	;JFN in use?
	CAME T3,T1		;yes, is it this structure?
	SKIPA			;no to either, OK
	JRST [ UNLOCK JFNLCK(P5) ;YES, UNLOCK JFN'S
		RETBAD (MSTX36)]  ; AND RETURN
DECMN3:	ADDI T4,MLJFN-1		;GET NEXT JFN BLOCK
	AOBJN T4,DECMN1		;CHECK NEXT JFN
	MOVE T3,MSTT3		;RESTORE JOB #
DECMN2:	CALL DECMNT		;DO ACTUAL DECREMENT
	 JRST [ UNLOCK JFNLCK(P5)
		RETBAD]
	UNLOCK JFNLCK(P5)	;PERMIT MODIFICATION OF JFN'S
	RETSKP			;SUCCESSFUL RETURN

;CALL DECMNT WITHOUT UNLOCKING JFNLCK AT FINISH

DECCAL:	CALL DECMNT		;DO ACTUAL DECREMENT
	RETBAD
	RETSKP			;SUCCESS


;DECMNT - ROUTINE TO DECREMENT THE MOUNT COUNT FOR A STRUCTURE
;
;ACCEPTS IN T1/	STRUCTURE NUMBER
;	    T2/ OFFSET TO JSB DATA FOR THIS STRUCTURE
;	    T3/ JOB # FOR WHICH DECREMENT BEING DONE
;		CALL DECMNT
;RETURNS: +1	 FAILED, ERROR CODE IN T1
;	  +2	SUCCESS, MOUNT COUNT DECREMENTED IF PREVIOUSLY INCREMENTED
;			 BY THIS JOB, AND A MESSAGE SENT TO THE MOUNTABLE
;			 DEVICE ALLOCATOR.
;
; NOTE: STRUCTURE MUST BE LOCKED DURING THIS ROUTINE

; THIS ROUTINE IS CALLED FROM BOTH THE MSTR AND LGOUT JSYS'ES

DECMNT::JE JSMCI,(T2),[RETBAD (MSTX32)]	;RETURN IF THE COUNT HAS NEVER BEEN INCREMENTED
	MOVE T4,STRTAB(T1)	;GET ADDRESS OF STRUCTURE DATA BLOCK
	NOINT			;DO NOT PERMIT INTERRUPTS
	NOSKED			;JSB AND SDB MUST BE CHANGED "SIMULTANEOUSLY"
	SETZRO JSMCI,(T2)	;MARK THAT MOUNT COUNT CAN BE INCREMENTED AGAIN
	JN JSFMT,(T2),DECM1	;DOES A FORK STILL HAVE STR MOUNTED
	DECR STRMC,(T4)		;NO, DECREMENT THE MOUNT COUNT 
	MOVE T1,T4		;SET UP SDB FOR CALL TO DISMES
	SETZ T4,		;SET FLAG SAYING MESSAGE NEEDED
DECM1:	OKSKED			;BOTH CHANGED, PERMIT SCHEDULING AGAIN
	JUMPN T4,DECM2		;IS A MESSAGE NEEDED?
	MOVE T2,T3		;GET JOB INDEX IN T2
	CALL SNDEND		;TELL DEVICE ALLOCATOR OF DECREMENT
DECM2:	OKINT			;PERMIT INTERRUPTS AGAIN
	RETSKP			;RETURN SUCCESS
; .MSGSU - GET STRUCTURE USERS

MSTGSU:	STKVAR <MSUBLK,MSUSTR>

; CHECK THE SIZE OF THE ARGUMENT BLOCK

	XCTU [HLRZ Q1,1]	;GET SIZE OF ARGUMENT BLOCK FROM USER
	CAIG Q1,.MSUJ1		;ROOM FOR AT LEAST ONE JOB NUMBER ?
	RETBAD (MSTRX3)		;NO, ARGUMENT BLOCK TOO SMALL

; CHECK FOR A VALID FUNCTION CODE

	UMOVE P1,2		;GET ADDRESS OF USER'S ARGUMENT BLOCK
	UMOVE Q2,.MSUFL(P1)	;GET THE FLAGS FROM THE USER
	TXNN Q2,MS%GTA!MS%GTC!MS%GTM ;VALID FUNCTION REQUESTED ?
	RETBAD (MSTRX1)		;NO, RETURN INVALID FUNCTION

; GO CHECK THE STRUCTURE NAME AND GET THE UNIQUE CODE

	UMOVE T1,.MSUAL(P1)	;GET POINTER TO NAME STRING IN USER SPACE
	CALL FNDSTD		;[7.1081] (T1/T1) Go check the structure name
	 RETBAD ()		;FAILED, STRUCTURE NOT MOUNTED
	MOVEM T1,Q3		;SAVE STRUCTURE NUMBER
	CALL STRCNV		;GET THE UNIQUE CODE FOR THIS STRUCTURE
	 JRST [	MOVE T1,Q3	;GET STRUCTURE NUMBER
		CALL ULKSTR	;UNLOCK THE STRUCTURE
		RETBAD (STRX01)] ;RETURN ERROR TO USER
	MOVEM T1,MSUSTR		;SAVE UNIQUE CODE
	MOVE T1,Q3		;RESTORE STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK THE STRUCTURE

; SET UP TO CHECK EACH JOB ON THE SYSTEM

	ADDI Q1,-1(P1)		;COMPUTE HIGHEST ADR TO STORE INTO IN USER SPACE
	MOVEI P4,.MSUJ1(P1)	;GET USER ADDRESS OF NEXT WORD TO STORE INTO
	MOVSI P2,-NJOBS		;SET UP AOBJN POINTER TO LOOP OVER ALL JOBS
	;..
	;..

; TOP OF LOOP OVER ALL JOBS - IF JOB EXISTS, MAP IT'S JSB

MSGU10:	HRRZ T1,JOBDIR(P2)	;GET RIGHT HALF OF USER NUMBER
	JUMPE T1,MSGU70		;DO NOT CONSIDER JOBS NOT LOGGED IN
	HRRZ T1,P2		;YES, GET THE JOB NUMBER
	CALL MAPJSB		;MAP THE JSB FOR THAT JOB
	 JRST MSGU70		;JOB MUST HAVE LOGGED OUT, GO ON
	MOVEM T1,P3		;SAVE OFFSET TO MAPPED JSB
	MOVE T2,T1		;GET OFFSET TO WHERE JSB IS MAPPED
	HRRZ T1,MSUSTR		;GET UNIQUE CODE FOR THIS STRUCTURE
	CALL FNDSTM		;FIND THE OFFSET IN JSB FOR THIS STRUCTURE
	 TDZA T1,T1		;STRUCTURE NOT IN USE BY THIS JOB
	SETO T1,		;MARK THAT STR IS IN USE
	MOVE T3,GBLJNO(P3)	;CHEAT - GET GLOBAL JOB NUMBER FROM OTHER JSB
	JUMPE T1,MSGU40		;IF STR NOT IN USE, ONLY LOOK AT CONNECTION
	JE MS%GTM,Q2,MSGU20	;USER ASKING FOR LIST OF JOBS THAT MOUNTED STR ?
	JE JSMCI,(T2),MSGU20	;YES. DID THIS JOB MOUNT THE STRUCTURE ?
	TXO T3,MS%GTM		;YES, SET THIS BIT FOR USER
MSGU20:	JE MS%GTA,Q2,MSGU40	;USER WANT LIST OF JOBS THAT ACCESSED STR ?
	JE JSADN,(T2),MSGU40	;YES. DID THIS JOB ACCESS THE STRUCTURE ?
	TXO T3,MS%GTA		;YES, GIVE BIT TO USER
MSGU40:	JE MS%GTC,Q2,MSGU50	;NO. USER WANT LIST OF JOBS CONNECTED TO STR ?
	LOAD T4,JSUC,(P3)	;GET CONNECTED STRUCTURE UNIQUE CODE
	CAMN T4,MSUSTR		;SAME AS REQUESTED STRUCTURE ?
	TXO T3,MS%GTC		;YES, GIVE BIT TO USER
MSGU50:	TLNN T3,-1		;ANY BITS ON?
	JRST MSGU60		;NO, DONT GIVE THIS TO USER
	CAMLE P4,Q1		;ENOUGH ROOM TO STORE ANOTHER JOB # ?
	JRST [	CALL CLRJSB	;NO- UNMAP THE JSB NOW MAPPED
		JRST MSGU80]	;GO RETURN # OF JOB NUMBERS STORED
	UMOVEM T3,0(P4)		;STORE THIS JOB NUMBER AND FLAGS
	ADDI P4,1		;POINT TO NEXT ENTRY IN USER ARG BLOCK
MSGU60:	CALL CLRJSB		;UNMAP THE CURRENTLY MAPPED JSB
MSGU70:	AOBJN P2,MSGU10		;GO CHECK NEXT JOB

; DONE STORING INDIVIDUAL JOB NUMBERS - RETURN # OF ITEMS STORED

MSGU80:	SUBI P4,.MSUJ1(P1)	;COMPUTE # OF ITEMS STORED
	XCTU [HRRM P4,.MSUFL(P1)] ;STORE # OF ITEMS RETURNED
	RETSKP			;RETURN TO USER

; .MSICF/.MSDCF - INCREMENT/DECREMENT MOUNT COUNT FOR FORK

;ACCEPTS: SAME AS .MSTR

;RETURNS +1: FAILED, ERROR CODE IN AC1
;	 +2: SUCCEEDED
;REGISTER USAGE:
;	P1/ STRUCTURE UNIQUE CODE
;	P2/ STRUCTURE NUMBER

MSTICF: TDZA T1,T1		;MARK THAT COUNT SHOULD BE INCREMENTED
MSTDCF:	SETOM T1		;MARK THAT COUNT SHOULD BE DECREMENTED
	ASUBR<MSTCF>

;CHECK SIZE OF USER ARGUMENT BLOCK

	XCTU [HLRZ T1,1]	;GET SIZE OF USER ARGUMENT BLOCK
	CAIGE T1,1		;AT LEAST ONE ITEM SPECIFIED?
	RETBAD (MSTRX3)		;NO, ARGUMENT BLOCK TOO SMALL

;CHECK THAT THE STURCTURE IS MOUNTED

	UMOVE T1,2		;GET ADDRESS OF USER'S ARGUMENT BLOCK
	UMOVE T1,.MSDEV(T1)	;GET DEVICE DESIGNATOR OF STRUCTURE
	CALL FNDSTD		;[7.1081] (T1/T1) Go see if structure mounted
	 RETBAD			;FAILED, STURCTURE NOT MOUNTED
	MOVEM T1,P2		;SAVE STRUCTURE NUMBER
	CALL STRCNV		;GET STRUCTURE UNIQUE CODE
	 JRST MCTERR		;FAILED, UNLOCK STRUCTURE AND RETURN
	MOVEM T1,P1		;SAVE UNIQUE CODE

;INCREMENT OR DECREMENT THE MOUNT COUNT AS APPROPRIATE

	LOCK JSSTLK		;LOCK THE STRUCTURE INFOR LOCK IN JSB
	CALL GTSTOF		;GET OFFSET FOR THIS STRUCTURE IN JSB
	 JRST [	UNLOCK JSSTLK	;FAILED, UNLOCK THE STRUCTURE INFO LOCK
		JRST MCTERR]	;AND UNLOCK STRUCTURE AND RETURN ERROR
	MOVE T1,P2		;GET STRUCTURE NUMBER AGAIN
	MOVE T4,MSTCF		;GET INCREMENT/DECREMENT FLAG
	ADDI T4,1		;FORM OFFSET TO PROPER CALL INSTRUCTION
	XCT [ CALL DECFC	;GO DECREMENT FORK MOUNT COUNT
	      CALL INCFC](T4)	;GO INCREMENT FORK MOUNT COUNT
	 JRST [ UNLOCK JSSTLK	;UNLOCK THE JSB STRUCTURE LOCK
		JRST MCTERR]	;GO UNLOCK STRUCTURE AND RETURN ERROR
	MOVE T1,P1		;GET UNIQUE CODE AGAIN
	CALL FRJSST		;FREE JSB STR STORAGE IF NOW UNUSED
	UNLOCK JSSTLK		;UNLOCK THE STRUCTURE INFO LOCK
	MOVE T1,P2		;GET THE STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK THE STRUCTURE
	RETSKP


;INCFC - ROUTINE TO INCREMENT STRUCTURE MOUNT COUNT FOR A FORK
;
;ACCEPTS IN T1/ STRUCTURE NUMBER
;	    T2/ OFFSET TO JSB DATA FOR THIS STRUCTURE
;	CALL INCFC
;RETURNS: +1	FAILED, ERROR CODE IN T1
;	  +2	SUCCESS, COUNT INCREMENTED IF NOT PREVIOUSLY INCREMENTED
;			 BY THIS FORK.
;
;NOTE: STRUCTURE MUST BE LOCKED DURING THIS ROUTINE

INCFC:	STKVAR<INCF1,INCF2>
	MOVE T4,STRTAB(T1)	;GET ADDRESS OF STRUCTURE DATA BLOCK
				; TO THIS STR
	JE STDIS,(T4),INCFC2	;IS STRUCTURE BEING DISMOUNTED?
	RETBAD (MSTX33)		;YES, ALLOW NO FURTHER INCREMENTS
INCFC2:	MOVEM T2,INCF1		;SAVE JSB OFFSET
	MOVEM T4,INCF2		;SAVE SDB ADDRESS
	CALL FRKSTO		;SEE IF FORK ALREADY MOUNTED STRUCTURE
	 SKIPA			;NO, CONTINUE
	RETBAD (MSTX31)		;FINDING STRUCTURE IS ERROR
	MOVE T2,INCF1		;RESTORE JSB OFFSET
	MOVE T4,INCF2		;RESTORE SDB ADDRESS

;SET MOUNT FOR THIS FORK, AND INCREMENT SYSTEM MOUNT COUNT IF NOT DONE
; BY THIS JOB PREVIOUSLY

				;DON'T PERMIT INTERRUPTS WHEN CHANGING 
				; DATA BASE
	NOSKED			;MUST CHANGE SDB,JSB "SIMULTANEOUSLY"
	JN JSFMT,(T2),INCF4	;SKIP SDB INCREMENT IF FORK FLAG ALREADY SET
	JN JSMCI,(T2),INCF4	;SKIP SDB INCREMENT IF JOB FLAG SET
	INCR STRMC,(T4)		;BUMP SDB MOUNT COUNT
	SETZ T4,		;MARK THAT WE NEED TO SEND MSSG
INCF4:	MOVEM T1,INCF1		;STORE STRUCTURE NUMBER
	MOVE T1,FORKN		;GET JOB RELATIVE FORK NUMBER
	MOVEI T3,1		;SET UP MASK FOR SETTING FORK
	LSH T3,(T1)		; MOUNT IN STRUCTURE
	MOVE T1,JSFKMT(T2)	;GET FORK MOUNT FLAG WORD
	TDO T1,T3		;SET THIS STRUCTURE IN USE
	MOVEM T1,JSFKMT(T2)	; AND REPLACE IN JSB
	INCR NOSTR		;INCREMENT NUMBER OF STRUCTURES MOUNTED

;IF INCREMENTING SYSTEM MOUNT COUNT WAS DONE, SEND MSSG TO MDA

	OKSKED			;PERMIT SCHEDULING AGAIN
	JUMPN T4,RSKP		;SKIP SENDING MSSG IF SDB NOT INCREMENTED
	MOVE T1,INCF2		;RESTORE STRUCTURE NUMBER
	MOVE T3,JOBNO		;GET OUR JOB NUMBER
	SUBI T2,JSSTRT		;SET UP T2 TO CONTAIN THE JSB OFFSET
	TRZ T2,777
	CALL SNDUSG		;SEND A MESSAGE TO THE DEVICE ALLOCATOR
	RETSKP			;RETURN SUCCESS


;DECFC - ROUTINE TO DECREMENT MOUNT COUNT FOR A FORK
;
;ACCEPTS IN T1/ STRUCTURE NUMBER
;	    T2/ OFFSET TO JSB DATA FOR THIS STRUCTURE
;	CALL DECFC
;RETURNS: +1	FAILED, ERROR CODE IN T1
;	  +2	SUCCESS, DECREMENT DONE
;
; NOTE: STRUCTURE MUST BE LOCK DURING THIS ROUTINE

;A USER IS PROHIBITED FROM DOING THIS FUNCTION IF ANY JFN'S FOR THIS
;FORK ARE FROM THE STRUCTURE

DECFC:	STKVAR<DECF1>
	JUMPE T1,DECFC3		;FORGET CHECK IF THIS IS PS
	MOVE T4,STRTAB(T1)	;IS THIS STRUCTURE PUBLIC?
	JN STPS,(T4),DECFC3	;SKIP CHECKING IF STRUCTURE IS PUBLIC
	LOCK JFNLCK		;LOCK JFN'S WHILE CHECKING DEVICES
	MOVN T4,MAXJFN		;GET # OF USED JFN'S
	JUMPE T4,DECFC2		;JUMP IF NONE USED
	HRLZ T4,T4		;SET UP INDEX TO JFN'S
	MOVEM T2,DECF1		;SAVE OFFSET
	HRRZ T2,FORKN		;GET THIS FORK NUMBER RELATIVE TO JOB
DECFC1:	HRRZ T3,FILDEV(T4)	;CHECK FOR DISK DEVICE
	CAIE T3,DSKDTB
	JRST DECFC4		;NO MUST BE OK
	LOAD T3,STR,(T4)	;GET JFN'S STRUCTURE CODE
	CAMN T3,T1		;IS IT THIS STRUCTURE?
	JRST [ LOAD T3,ORG,(T4)
		CAME T3,T2	;DOES IT BELONG TO THIS FORK
		JRST .+1	;NO, CONTINUE
		UNLOCK JFNLCK	;YES, UNLOCK JFN'S 
		RETBAD (MSTX36)] ; AND RETURN
DECFC4:	ADDI T4,MLJFN-1		;GET NEXT JFN BLOCK
	AOBJN T4,DECFC1		;CHECK NEXT JFN
	MOVE T2,DECF1		;GET OFFSET TO JSB DATA
DECFC2:	CALL DECFMC		;DO DECREMENT
	 JRST [UNLOCK JFNLCK
		RETBAD]
	UNLOCK JFNLCK		;PERMIT MODIFICATION OF JFN'S
	RETSKP			;SUCCESSFUL RETURN

;CALL DECFMC WITHOUT UNLOCKING JFNLCK AT FINISH

DECFC3:	CALL DECFMC		;DO DECREMENT
	RETBAD
	RETSKP			;SUCCESS


;DECFMC - ROUTINE TO DECREMENT STRUCTURE MOUNT COUNT FOR A FORK
;
;ACCEPTS IN T1/ STRUCTURE NUMBER
;	    T2/ OFFSET TO JSB DATA FOR THIS STRUCTURE
;	CALL DECFMC
;RETURNS: +1	FAILED, ERROR CODE IN T1
;	  +2	SUCCESS, MOUNT COUNT DECREMENT IF PREVIOUSLY INCREMENTED
;		T1 AND T2 RETURN UNCHANGED
;
; NOTE: STRUCTURE MUST BE LOCKED DURING THIS ROUTINE

;THIS ROUTINE IS CALLED FROM THE MSTR JSYS AND THE KSELF CODE

DECFMC::ASUBR<DEC1,DEC2>
	JE JSFMT,(T2),[RETBAD (MSTX32)] ;RETURN IF NEVER INCREMENTED
	CALL FRKSTO		;SEE IF THIS FORK INCREMENTED COUNT
	 RETBAD (MSTX32)	;NO
	MOVE T2,DEC2		;RESTORE JSB OFFSET
	MOVEI T1,1		;SET UP MASK TO REMOVE STR FROM FORK
	MOVE T3,FORKN		;GET RELATIVE JOB FORK NUMBER
	LSH T1,(T3)
	MOVE T4,DEC1		;RESTORE STRUCTURE #
	MOVE T4,STRTAB(T4)	; IN ORDER TO GET ADDRESS OF SDB
	MOVEM T4,DEC1		;STORE SDB ADDRESS
	NOINT			;DO NOT PERMIT INTERRUPTS
	NOSKED			;JSB,SDB CHANGED SIMULTANEOUSLY
	MOVE T3,JSFKMT(T2)	;GET FORK FLAG WORD
	TDZ T3,T1		;REMOVE FORK
	MOVEM T3,JSFKMT(T2)	;PLACE WORD INTO JSB AGAIN
	DECR NOSTR		;DECREMENT NUMBER OF STRUCTURES MOUNTED
	JUMPN T3,DECFM1		;DO ANY MORE FORKS HAVE STR MOUNTED
	JN JSMCI,(T2),DECFM1	;NO, IS THERE A JOB-WIDE MOUNT IN EFFECT
	DECR STRMC,(T4)		;NO, DECREMENT SDB MOUNT COUNT
	SETZ T4,		;INDICATE A MESSAGE IS NEEDED
DECFM1:	OKSKED			;ALL CHANGED, PERMIT SCHEDULING AGAIN
	JUMPN T4,DECFM2		;SKIP MESSAGE IF NOT NEEDED
	MOVE T1,DEC1		;RESTORE STRUCTURE NUMBER
	MOVE T2,JOBNO		;GET OUR JOB NUMBER
	CALL SNDEND		;SEND A MESSAGE TO THE DEVICE ALLOCATOR
DECFM2:	DMOVE T1,DEC1
	OKINT			;PERMIT INTERRUPTS AGAIN
	RETSKP			;RETURN SUCCESS


;MSTOFL - ROUTINE TO ENABLE ONLINE/OFFLINE PSI INTERRUPTS

MSTOFL:	MOVX T1,SC%WHL!SC%OPR	;CHECK PRIVS
	TDNN T1,CAPENB
	RETBAD (CAPX2)		;NOT ENOUGHT CAPABILITIES
	XCTU [HLRZ T1,1]	;GET SIZE OF USER ARGUMENT BLOCK
	CAIGE T1,1		;AT LEAST ONE ITEM SPECIFIED?
	RETBAD (MSTRX3)		;NO, ARGUMENT BLOCK TOO SMALL

;CHECK THAT THE CHANNEL IS VALID

	UMOVE T1,2		;GET ADDRESS OF USER'S ARGUMENT BLOCK
	UMOVE T1,.MSCHN(T1)	;GET CHANNEL NUMBER FOR INTERRUPTS
	CAMN T1,[-1]		;CHECK FOR -1 (CLEAR)
	JRST [ SETZM DSPSFK	;CLEAR PSI
		RETSKP]		;QUIT
	CAIL T1,0		;CHECK THAT GIVEN PSI CHANNEL IS
	CAILE T1,5		; ASSIGNABLE CHANNEL
	JRST [ CAIL T1,^D24	;CONTINUE CHECKING
		CAILE T1,^D35
		RETBAD (MSTX40)	;BAD PSI CHANNEL NUMBER GIVEN
		JRST .+1]	;PSI CHANNEL OK

;SET UP INTERRUPT WORD IN STG

	HRRM T1,DSPSFK		;SAVE PSI
	MOVE T1,FORKX		;GET FORK NUMBER
	HRLM T1,DSPSFK		;SAVE FORK NUMBER
	RETSKP			;SUCCESS RETURN

;KSELF CONTAINS CODE TO CLEAR INTERRUPT WORD WHEN FORK DIES


;MSTIIC - ROUTINE TO SET PSB FLAG BIT TO IGNORE MOUNT COUNT CHECK

MSTIIC:	MOVX T1,SC%WHL!SC%OPR	;CHECK PRIVS
	TDNN T1,CAPENB
	RETBAD (CAPX2)		;NOT ENOUGH CAPABILITIES
	LOAD T1,STRFLG		;GET STRUCTURE FLAGS
	TRO T1,ST%IMC		;SET IGNORE MOUNT COUNT FLAG
	STOR T1,STRFLG		;STORE FLAGS
	RETSKP

; ROUTINE TO READ THE HOME BLOCKS ON A UNIT AND RETURN THE UNIT TYPE
;
; ACCEPTS:	T1/ CHANNEL NUMBER
;		T2/ CONTROLLER NUMBER
;		T3/ UNIT NUMBER
;		CALL MSTRHB
; RETURNS: +1	 FAILED,  RETURNS OKINT WITH ERROR CODE IN T1
;	   +2	SUCCESS, RETURNS NOINT WITH:
;		T1/ VIRTUAL ADDRESS OF HOME BLOCK PAGE
;		T2/ PHYSICAL CORE PAGE NUMBER OF HOME BLOCK PAGE
;
; NOTE: RETURNS NOINT ON SUCCESS, WITH HOME BLOCK PAGE LOCKED

MSTRHB:	ASUBR <RHBCHN,RHBCTL,RHBUNI>
	STKVAR <RHBADR,RHBPAG,RHBERR>
	NOINT			;DO NOT PERMIT INTERRUPTS WITH SPACE ASSIGNED
	CALL ASGPAG		;ASSIGN A JSB PAGE FOR READING HOME BLOCKS
	 RETBAD (MSTRX4,<OKINT>) ;FAILED, RETURN "INSUFFICIENT RESOURCES" ERROR
	MOVEM T1,RHBADR		;SAVE VIRTUAL ADDRESS OF HOME BLOCK PAGE
	CALL MLKMA		;LOCK DOWN THE PAGE SO THAT I/O CAN BE DONE
	MOVEM T1,RHBPAG		;SAVE PHYSICAL PAGE NUMBER OF HOME BLOCK PAGE
	DMOVE T1,RHBCHN		;GET CHANNEL AND CONTROLLER NUMBERS
	MOVE T3,RHBUNI		;AND UNIT NUMBER
	CALL CKUPAK		;PACK THEM INTO ONE WORD
	MOVE T2,RHBPAG		;GET PHYSICAL PAGE NUMBER
	LSH T2,PGSFT		;COMPUTE PHYSICAL ADDRESS
	MOVEI T3,HM1BLK		;GET BLOCK NUMBER OF FIRST HOME BLOCK
	MOVE T4,RHBADR		;GET VIRTUAL ADDRESS OF HOME BLOCK PAGE
	CALL REDHOM		;READ THE TWO HOME BLOCKS
	 JRST [	MOVEM T1,RHBERR	;FAILED, SAVE ERROR BITS
		MOVE T1,RHBPAG	;GET PHYSICAL PAGE NUMBER BACK
		CALL MULKCR	;UNLOCK THE PAGE
		MOVE T1,RHBADR	;GET VIRTUAL ADDRESS OF PAGE
		CALL RELPAG	;RELEASE THE PAGE
		SKIPL RHBERR	;[7359] Was unit offline?
		RETBAD (MSTX20,<OKINT>) ;NO, RETURN DATA ERROR CODE
		RETBAD (MSTRX5,<OKINT>) ] ;YES, RETURN "DRIVE OFF LINE" ERROR
	MOVE T1,RHBADR		;SUCCESS, GET VIRTUAL ADDRESS OF HOME BLOCKS
	MOVE T2,RHBPAG		;GET PHYSICAL PAGE NUMBER OF HOME BLOCK PAGE
	RETSKP			;RETURN (NOINT)

; ROUTINE TO CHECK THE HOME BLOCKS
;
; ACCEPTS IN T1/ VIRTUAL ADDRESS OF HOME BLOCK PAGE
;		CALL MSTHBC
; RETURNS: +1 ALWAYS, WITH P3/ FLAGS:
;		HB%1OK IF FIRST HOME BLOCK IS OK
;		HB%2OK IF SECOND HOME BLOCK IS OK

MSTHBC:	SAVEP			;SAVE PRESERVED AC'S
	ASUBR <HBCVIR>		;SAVE VIRTUAL ADDRESS OF HOME BLOCK PAGE
	SETZM P3		;INITIALIZE FLAGS FOR THIS UNIT
	MOVE T1,HBCVIR		;GET VIRTUAL ADDRESS OF FIRST HOME BLOCK
	MOVEI T2,HM1BLK		;GET # OF THIS HOME BLOCK
	CALL HBCCHK		;CHECK FIRST HOME BLOCK
	 TXZA P3,HB%1OK		;FIRST HOME BLOCK IS NO GOOD
	TXO P3,HB%1OK		;FIRST HOME BLOCK IS FINE AND DANDY
	MOVE T1,HBCVIR		;GET VIRTUAL ADDRESS OF FIRST HOME BLOCK
	ADDI T1,HBLEN		;FORM ADDRESS OF SECOND HOME BLOCK
	MOVEI T2,HM2BLK		;GET BLOCK ADDRESS OF SECOND HOME BLOCK
	CALL HBCCHK		;GO CHECK SECOND HOME BLOCK
	 TXZA P3,HB%2OK		;MARK THAT SECOND HOME BLOCK IS NO GOOD
	TXO P3,HB%2OK		;INDICATE SECOND HOME BLOCK IS FINE
	MOVE T1,P3		;COPY FLAGS TO RETURN
	RET			;RETURN


;SIXASC - ROUTINE TO CONVERT SIXBIT TO ASCII
;
;ACCEPTS IN T1/	SIXBIT "NAME"
;	    T2/	ADDRESS OF DESTINATION FOR ASCIZ STRING
;		CALL SIXASC
;RETURNS: +1	ALWAYS

SIXASC::MOVEI T3,-1(T2)		;GET ADDRESS PRECEDING DESTINATION
	HRLI T3,(POINT 7,0,35)	;FORM IDPB POINTER TO DESTINATION
	MOVE T2,T1		;COPY SIXBIT NAME
	MOVSI T4,-6		;GET MAX # OF CHARACTERS TO CONVERT
SIXAS1:	SETZM T1		;INITIALIZE WORK AC
	LSHC T1,6		;GET ONE SIXBIT CHARACTER
	JUMPE T1,SIXAS2		;IF END OF NAME GO DEPOSIT A NULL
	ADDI T1,"A"-'A'		;CONVERT CHARACTER TO ASCII
	IDPB T1,T3		;STORE CHARACTER IN DESTINATION
	AOBJN T4,SIXAS1		;LOOP OVER ALL CHARACTERS IN NAME
SIXAS2:	MOVEI T1,.CHNUL		;GET A NULL
	IDPB T1,T3		;TERMINATE THE ASCIZ STRING
	RET			;RETURN

; Routine to find a file structure in the device tables
; Accepts in T1/ Pointer to ASCIZ structure name in user space
;		CALL FNDSTD
; Returns: +1	 Failed, structure not mounted with that alias
;	   +2	Success, with T1/ Structure number
;		Returns NOINT, with structure locked!

FNDSTD::SAVEP			;[7.1081] Make globular, change name
	STKVAR <FSTERR,FSTBLK,FSTSTR>
	SETZM FSTERR		;INITIALIZE ERROR FLAG
	SETZM FSTBLK		;INITIALIZE ADR OF FREE BLOCK
	MOVE T2,T1		;COPY DEVICE DESIGNATOR
	TLC T2,-1		;SEE IF LH = -1
	TLCN T2,-1
	HRLI T2,(<POINT 7,0>)	;YES, SET UP BYTE POINTER
	HLRZ T3,T2		;GET LEFT HALF OF DESIGNATOR OR POINTER
	CAIL T3,.DVDES		;WAS A DESIGNATOR PROVIDED ?
	JRST FNDST1		;YES, SKIP STDEV, JUST GO CHECK DESIGNATOR
	CALL CPYFUS		;COPY STRUCTURE NAME STRING FROM USER SPACE
	 RETBAD (MONX02)	;FAILED, RETURN "INSUFFICIENT RESOURCES" - JSB FULL
	MOVEM T1,FSTBLK		;SAVE ADDRESS OF BLOCK
	HRROI T1,1(T1)		;FORM POINTER TO NAME STRING
	STDEV			;TRNASLATE STRING TO DEVICE DESIGNATOR
	 JRST [	MOVEM T2,FSTERR	;FAILED, SAVE ERROR CODE
		JRST FNDST2 ]	;GO RELEASE SPACE AND RETURN ERROR
FNDST1:	MOVEM T2,FSTSTR		;SAVE DEVICE DESIGNATOR
	HRRZ T4,T2		;GET UNIQUE CODE PART OF DESIGNATOR TO CHECK
	CAIN T4,-1		;IS DESIGNATOR TO BE CHECKED FOR "DSK:" ?
	JRST [	CALL GTCSCD	;YES, GET CONNECTED STRUCTURE UNIQUE CODE
		HLRM T1,FSTSTR	;SAVE UNIQUE CODE FOR CONNECTED STRUCTURE
		JRST .+1]	;CONTINUE
	HLRZ T3,FSTSTR		;GET DEVICE-TYPE PORTION OF DESIGNATOR
	CAIE T3,.DVDES+.DVDSK	;IS THIS A DISK ?
	JRST [	MOVX T1,ARGX18	;NO, GET ERROR CODE
		MOVEM T1,FSTERR	;SAVE ERROR CODE
		JRST FNDST2 ]	;GO RELEASE SPACE AND RETURN ERROR CODE
	MOVE T1,FSTSTR		;COPY DEVICE DESIGNATOR FOR CHKDEV
	CALL CHKDEV		;GO CHECK DEVICE DESIGNATOR
	 JRST [	MOVX T1,STRX01	;GET ERROR CODE
		MOVEM T1,FSTERR	;SAVE ERROR CODE
		JRST FNDST2 ]	;GO RELEASE SPACE AND RETURN ERROR CODE TO USER
	HRRZ T1,FSTSTR		;GET UNIQUE CODE FOR THIS STRUCTURE
	CALL CNVSTR		;CONVERT UNIQUE CODE TO A STRUCTURE NUMBER
	 JRST [	MOVEM T1,FSTERR	;SAVE ERROR CODE
		JRST FNDST2 ]	;GO RELEASE SPACE AND RETURN ERROR CODE
	MOVEM T1,FSTSTR		;SAVE STRUCTURE NUMBER
FNDST2:	MOVEI T1,JSBFRE		;GET FREE HEADER
	SKIPE T2,FSTBLK		;GET ADDRESS OF BLOCK CONTAINING NAME
	JRST [CALL RELFRE	;RELEASE FREE SPACE IF ANY
	      OKINT		;UNDO INT FROM ASGRES
	      JRST .+1]		;CONTINUE
	MOVE T1,FSTSTR		;GET STRUCTURE NUMBER
	SKIPN FSTERR		;ANY ERRORS ?
	RETSKP			;NO, RETURN SUCCESS (NOINT)
	MOVE T1,FSTERR		;YES, GET ERROR CODE
	RETBAD ()		;RETURN ERROR CODE

;STOSTR - ROUTINE TO STORE A STRUCTURE NAME STRING INTO USER SPACE
;
;ACCEPTS IN T1/	ADDRESS OF POINTER TO DESTINATION (ADR IN USER SPACE)
;	    T2/	ADDRESS OF STRUCTURE NAME STRING IN MONITOR SPACE
;		CALL STOSTR
;RETURNS: +1 ALWAYS, T1/ UPDATED POINTER INTO USER SPACE

STOSTR:	UMOVE T4,(T1)		;GET POINTER TO DESTINATION FROM USER
	TLCN T4,-1		;CHECK FOR -1 LH BYTEPOINTER
	JRST R			;THE LH WAS 0, NO REAL BYTE PNTR
	TLCN T4,-1		;CONVERT BACK; WAS IT -1?
	HRLI T4,(POINT 7)	;YES, MAKE A PROPER BYTE POINTER
	HRLI T2,(POINT 7)	;MAKE T2 PROPER AS WELL

STOST2:	ILDB T3,T2		;GET A CHARACTER FROM THE NAME STRING
	MOVEM T4,T1		;SAVE UPDATED POINTER
	XCTBU [IDPB T3,T4]	;STORE CHARACTER IN USER SPACE
	JUMPN T3,STOST2		;IF NOT NULL, GO COPY NEXT CHARACTER
	RET			;RETURN


; ROUTINE TO CHECK A CHARACTER OF A STRUCTURE NAME FOR VALIDITY
;
; ACCEPTS IN T1/ ASCII CHARACTER
;		CALL CHRCHK
; RETURNS: +1	 FAILED, CHARACTER IS ILLEGAL
;	   +2	SUCCESS, CHARACTER IS LEGAL

; MASK OF VALID CHARACTER CLASSES--

CHDASH==30			;DASH
CHUCA==24			;UPPER CASE A
CHUPCH==0			;UPPER CASE CHARACTERS IN GENERAL
CHUCP==23			;UPPER CASE P
CHUCT==22			;UPPER CASE T
CHDIG==21			;DIGITS

CHRMSK==1B<CHDASH>!1B<CHUCA>!1B<CHUPCH>!1B<CHUCP>!1B<CHUCT>!1B<CHDIG>

CHRCHK:	SAVET			;PRESERVE THE TEMPORARY AC'S
	MOVE T2,T1		;GET CHARACTER TO CHECK
	CALL GTCODE		;GET THE CHARACTER CLASS CODE
	 RETBAD ()		;FAILED, RETURN ILLEGAL CHARACTER
	MOVEI T1,1		;GET A BIT TO SHIFT INTO POSITION
	MOVEI T4,^D35		;GET NUMBER OF BITS/WORD - 1
	SUB T4,T2		;COMPUTE SHIFT REQUIRED
	LSH T1,(T4)		;POSITION BIT FOR THIS CHARACTER CLASS
	TXNN T1,CHRMSK		;IS THIS A VALID CHARACTER ?
	RETBAD ()		;NO, RETURN ILLEGAL CHARACTER
	RETSKP			;YES, RETURN SUCCESS


;ROUTINE TO TRANSFER SIXBIT STRUCTURE NAME TO SEVENBIT
;
;ACCEPTS: T1/ BYTE POINTER TO 7-BIT ASCII AREA
;	  T2/ STRUCTURE NUMBER
;		CALL MSTOUT
;RETURNS: +1  ALWAYS, T1 UPDATED

MSTOUT: SAVEQ
	MOVE T2,STRTAB(T2)	;GET STRUCTURE BLOCK ADDRESS
	MOVEI T2,SDBNAM(T2)	;GET ADDRESS OF STRUCTURE NAME
	HRLI T2,440600		;SET UP 6-BIT POINTER
	MOVE T3,[440700,,Q1]	;SET UP BYTE PTR TO Q REGISTERS
	MOVEI T4,6		;THERE IS A MAXIMUM OF 6 BYTES
	SETZB Q1,Q2		;ZERO THE STRING AREA
MSTOU1:	ILDB Q3,T2		;GET 6-BIT CHARACTER
	JUMPE Q3,MSTOU2		;GET OUT OF LOOP IF ZERO BYTE
	ADDI Q3,40		;CONVERT IT TO 7-BIT
	IDPB Q3,T3		;PUT IT IN TEMPORARY LOCATION
	SOJG T4,MSTOU1		;LOOP IF MORE CHARACTERS
MSTOU2:	HRROI T2,Q1		;GET POINTER TO TEMP LOC
	TTMSG%			;[7190] OUTPUT IT
	 ERJMP .+1		;[7190]
	RET


;SNDUSG - ROUTINE TO SEND USAGE ACCOUNTING INFORMATION FOR STR MOUNTS
;
;ACCEPTS: T1/	STRUCTURE INDEX
;	  T2/	JSB OFFSET
;	  T3/	JOB NUMBER
;		CALL SNDUSG
;RETURNS: +1 ALWAYS, MESSAGE SENT TO DEVICE ALLOCATOR

;[7.1206] Milestone - If anything needs to be added to the following
;TRVAR, please add them at the end as routine DISMES (in IPCF) depends
;on the order of this TRVAR.

SNDUSG:	TRVAR <MSTHDI,<MSTIPC,17>,TMPT1> ;[7.1030][7.1206]
	MOVEM T1,TMPT1		;[7.1030] Save this for later
	MOVEI T4,20		;ARG BLOCK IS 20 WORDS LONG
	HRLI T4,.IPCMS		;SET UP MOUNT CODE
	MOVEM T4,MSTHDI
	MOVE T1,T3		;[7.1030] Get local job number in good AC
	CALL LCL2GL		;[7.1030] (T1/T1) Get global job number
	 NOP			;[7.1030] Failure, what failure?
	HRLM T1,MSTIPC		;[7.1030] Store global job number
	MOVE T1,TMPT1		;[7.1030] Restore T1
	HLR T4,JOBPT(T3)
	HRRM T4,MSTIPC		;STORE LINE NUMBER
	HRR T4,JOBDIR(T3)
	HRLI T4,USRLH		;SET UP USER NUMBER SYMBOL
	MOVEM T4,6+MSTIPC	;STORE USER NUMBER
	LOAD T3,STRUC,(T1)
	HRRM T3,1+MSTIPC	;STORE STR UNIQUE CODE
	LDB T3,[POINT STRNS,T3,35] ;GET STRUCTURE INDEX
	LOAD T4,STRMC,(T1)
	SOS T4
	HRLM T4,2+MSTIPC	;STORE PREVIOUS MOUNT COUNT
	MOVE T4,SDBSTS(T1)	;GET STATUS
	CAIN T3,PSNUM		;[7.1112]Is it the boot structure?
	TXO T4,MS%PPS!MS%BS!MS%NRS!MS%DOM ;[7.1112]Yes. Mark it so
	CAMN T3,LGSIDX		;[7.1112]Is it the Login Structure?
	TXO T4,MS%PPS!MS%PS!MS%NRS!MS%DOM ;[7.1112]Yes. Mark it so
	HLRM T4,2+MSTIPC	;STORE STR STATUS
	MOVE T4,SDBNUM(T1)
	HRLM T4,3+MSTIPC	;STORE NUMBER OF UNITS
	HRRZ T4,SDBUDB(T1)
	LOAD T4,USTYP,(T4)
	HRRM T4,3+MSTIPC	;STORE DRIVE TYPE
	MOVE T4,SDBNAM(T1)
	MOVEM T4,4+MSTIPC	;STORE STR NAME
	MOVEI T4,7+MSTIPC
	HRLI T4,ACCTSR(T2)
	BLT T4,16+MSTIPC	;STORE ACCOUNT STRING
	CALL LGTAD
	MOVEM T1,5+MSTIPC	;STORE TIME AND DATE
	CALL DISMES		;SEND A MESSAGE TO THE DEVICE ALLOCATOR
	 JFCL			;IGNORE IF MESSAGE FAILED
	RET


;SNDEND - ROUTINE TO SEND MESSAGE TO DEVICE ALLOCATOR FOR STR DECREMENT
;
;ACCEPTS: T1/	STRUCTURE INDEX
;	  T2/	JOB NUMBER
;		CALL SNDEND
;RETURNS  +1,	ALWAYS

;[7.1206] Milestone - If anything needs to be added to the following
;TRVAR, please add them at the end as routine DISMES (in IPCF) depends
;on the order of this TRVAR.

SNDEND:	TRVAR <MSTHDD,<MSTPC,3>,SAVT1> ;[7.1030][7.1206]
	MOVEM T1,SAVT1		;[7.1030] Quick, before the cops come
	MOVEI T3,4		;LENGTH OF ARG BLOCK
	HRLI T3,.IPCDS		;SET UP DISMOUNT CODE
	MOVEM T3,MSTHDD
	MOVE T1,T2		;[7.1030] Get local job number in correct AC
	CALL LCL2GL		;[7.1030] (T1/T1) Get global job
	 NOP			;[7.1030] Confused? Of course you're enthused
	HRLM T1,MSTPC		;[7.1030] Store global job number
	MOVE T1,SAVT1		;[7.1030] Get original T1 back
	LOAD T3,STRMC,(T1)
	HRRM T3,MSTPC		;STORE MOUNT COUNT
	LOAD T3,STRUC,(T1)
	MOVEM T3,1+MSTPC	;STORE STRUCTURE UNIQUE CODE
	CALL LGTAD
	MOVEM T1,2+MSTPC	;STORE TIME OF DAY
	CALL DISMES		;SEND MESSAGE TO DEVICE ALLOCATOR
	 JFCL			;IGNORE IF MESSAGE FAILED
	RET

;[7.1063]
; STROFL - Routine to check if a structure is offline or if any
;          of the disks which comprise the structure are
;          unusable.
;
;Accepts: T1/   Structure index
;               CALL STROFL
;Returns  +1:   Structure is offline or a disk is unusable
;         +2:   Structure is online

STROFL::CALL CKSTOF		;[7.1063](T1/T1)Check the structure index
	IFNSK.			;[7.1079]If CKSTOF failed...
	  CAIE T1,STRX10	;[7.1079]Structure offline?
	  BUG.(CHK,STROFF,MSTR,SOFT,<OFN on mounted structure but STRTAB entry is zero>,,<

Cause:	The SPTH table has the N+1 through NOFN number of files on a particular
	structure marked as being on a mounted structure, but the STRTAB entry 
	for this structure is zero. This BUGCHK can also happen if the
	structure index passed to CKSTOF if out of the range 0 to STRN-1.

Action:	The table should be corrected in a few seconds. However, there may
	be flurry of BUGCHKs, depending upon how many files are open on the 
	structure. If the BUGCHKs persist, check for improperly dismounted
	or spun down drives. 
>,,<DB%NND>)			;[7.1210][7.1079]
	  RET			;[7.1079]Return failure
	ENDIF.			;[7.1079]
	MOVE T1,STRTAB(T1)	;[7.1063]Get SDB address
	HRLI T1,-MXSTRU		;GET NUMBER OF POSSIBLE UNITS
STROF1:	MOVE T2,SDBUDB(T1)	;GET UDB ADDRESS
	JUMPE T2,RSKP		;FINISHED IF ZERO
	MOVE T2,UDBSTS(T2)	;GET UDB STATUS
	TXNE T2,US.CHB!US.OIR!US.OMS!US.OFS ;CHECK FOR HOME BLOCK,
				; OPERATOR ACTION REQUEST, OFF-LINE
	RET			;PROBLEM WITH STRUCTURE
	AOBJN T1,STROF1		;LOOP FOR ALL
	RETSKP

;[7.1063]
;CKSTOF - Routine to check if a structure is offline
;
;Accepts: T1/   Structure number
;               CALL CKSTOF
;
;Returns  +1:   Structure is offline (STRX10 in T1) or bad index
;         +2:   Structure is online (T1 unchanged)

CKSTOF::SAVEAC <T2>		;Save T2
	SKIPL T1		;Is structure index negative?
	CAIL T1,STRN		;Or too large?
	RETBAD (STRX11)		;[7.1079]Yes. Invalid structure number
	SKIPN T2,STRTAB(T1)	;Get SDB address
	RETBAD (STRX11)		;[7.1079]Zero ,Invalid structure number
CKSTF1:	MOVE T2,SDBSTS(T2)	;Get SDB flags
	TXNE T2,MS%OFS		;Is the structure offline?
	RETBAD (STRX10)		;Yes
	RETSKP			;No

	TNXEND

	END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           