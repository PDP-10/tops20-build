; UPD ID= 8705, RIP:<7.MONITOR>JSYSM.MAC.95,  21-Apr-88 16:11:20 by GSCOTT
;TCO 7.1279 - Don't validate the job number passed to the USAGE JSYS if the 
; entry type is .USENT.  This is so that MOUNTR has no problem writing tape
; and disk mount records created when the user logs out with things mounted.
; Also change several occurances of "PS:[ACCOUNTS]" to "ACCOUNT:" in BUGs.
; UPD ID= 8697, RIP:<7.MONITOR>JSYSM.MAC.94,  12-Apr-88 14:55:00 by GSCOTT
;TCO 7.1272 - Fix bad accouting records from ATACH when AT%TRM is used and my
; own job is specified as the target job.
; UPD ID= 8688, RIP:<7.MONITOR>JSYSM.MAC.93,  18-Mar-88 10:30:22 by GSCOTT
;TCO 7.1260 - Fix TCO 6.1.1092, AC1 not set up for CFOBF at LOG2 after SOBE
; loop and call TTCOBF after call to ELOGOO to catch jobs stuck in TCOTST.
; UPD ID= 8653, RIP:<7.MONITOR>JSYSM.MAC.92,  18-Feb-88 20:46:31 by GSCOTT
;TCO 7.1230 - Add routine BLINKS which breaks links and advice and defaults
; the CTY to type contained in CTYTY if SAVTRE is nonzero.
; UPD ID= 8536, RIP:<7.MONITOR>JSYSM.MAC.90,   9-Feb-88 16:24:46 by GSCOTT
;TCO 7.1218 - Update copyright date.
; UPD ID= 8421, RIP:<7.MONITOR>JSYSM.MAC.89,   4-Feb-88 12:29:15 by GSCOTT
;TCO 7.1210 - Set USGHOL, UXXCL1, UXXCL2, UXXCL3, UXXFIT, and UXXWER
; normally not dumpable.  Also correct module name on other BUGs.
;TCO 7.1200 - Split MEXEC into MEXEC and JSYSM, moving all JSYS code here.
;Change FX to Q3.  Move GJINF, TIME, RUNTM, GTRPI, GTDAL, SYSGT, GETAB, SETSN,
;SETNM, GETNM, GETJI, SWTCH, LITES, USRIO, PEEK, and XPEEK JSYSes to XCDSEC.
;Move CRJOB, LOGIN, and USAGE here from JSYSA.  See JSYSA for the revision
;history for CRJOB, LOGIN, and USAGE.  As is customary, the old MEXEC revision
;history is included here for reference.
; UPD ID= 272, RIP:<7.MONITOR>MEXEC.MAC.24,   6-Nov-87 15:06:52 by GSCOTT
;TCO 7.1119 - Replace occurances of [ASCIZ/<crlf>/] with CRLF, remove ASZSIX
; UPD ID= 265, RIP:<7.MONITOR>MEXEC.MAC.23,   6-Nov-87 11:53:26 by GSCOTT
;TCO 7.1117 - Remove code that is a slow no-op in CHKR having to do with drums.
; UPD ID= 249, RIP:<7.MONITOR>MEXEC.MAC.22,   4-Nov-87 16:42:11 by MCCOLLUM
;TCO 7.1112 - Fix STCRJB, EXEC2, and .GETJI to use LGSIDX.
;             Make system-wide expunge work for Boot Structure
;             Look for IPALOD and IPADMP on BS:
; UPD ID= 239, RIP:<7.MONITOR>MEXEC.MAC.21,   3-Nov-87 13:18:46 by GSCOTT
;TCO 7.1075 - Update TOC, repaginate.
; UPD ID= 237, RIP:<7.MONITOR>MEXEC.MAC.20,   2-Nov-87 11:43:28 by GSCOTT
;TCO 7.1107 - Don't hang in a DOBE at LOGDES
; UPD ID= 217, RIP:<7.MONITOR>MEXEC.MAC.19,  27-Oct-87 15:52:39 by RASPUZZI
;TCO 7.1086 - Broadcast system going down messages to all systems in the
;             cluster. Also, add system name to the System going down string.
; UPD ID= 204, RIP:<7.MONITOR>MEXEC.MAC.18,  23-Oct-87 15:24:50 by GSCOTT
;TCO 7.1081 - Call DOBINI during system startup, run SETSPD to copy DOB dumps
; UPD ID= 193, RIP:<7.MONITOR>MEXEC.MAC.17,  21-Oct-87 20:24:47 by RASPUZZI
;More of TCO 7.1076 - This time really put the changes in!
; UPD ID= 180, RIP:<7.MONITOR>MEXEC.MAC.16,  21-Oct-87 17:05:23 by RASPUZZI
;TCO 7.1076 - Start up the CLUDGR fork and make GETRTL global.
; UPD ID= 163, RIP:<7.MONITOR>MEXEC.MAC.15,  19-Oct-87 17:15:38 by LOMARTIRE
;TCO 7.1072 - Create the two new ENQ forks for cluster-wide ENQ
; UPD ID= 149, RIP:<7.MONITOR>MEXEC.MAC.14,  29-Sep-87 18:20:17 by MCCOLLUM
;More of TCO 7.1063 - Fix accidental register change in GTDAL%
; UPD ID= 130, RIP:<7.MONITOR>MEXEC.MAC.13,  23-Sep-87 15:45:15 by MCCOLLUM
;TCO 7.1063 - Check for STRX10 in CHKAC% and GTDAL%
; UPD ID= 104, RIP:<7.MONITOR>MEXEC.MAC.12,   8-Sep-87 17:24:06 by GSCOTT
;TCO 7.1051 - Implement two new GETAB words called ACTJOB and WHOJOB.
; UPD ID= 101, RIP:<7.MONITOR>MEXEC.MAC.11,   4-Sep-87 10:55:19 by MCCOLLUM
;TCO 7.1050 - Call RESLCI instead of RESLCK in RUNDD
; UPD ID= 73, RIP:<7.MONITOR>MEXEC.MAC.10,  12-Aug-87 14:47:43 by MCCOLLUM
;TCO 7.1037 - SC.ALM in SCAMPI is now SC.MAL
; UPD ID= 63, RIP:<7.MONITOR>MEXEC.MAC.9,  10-Aug-87 14:12:21 by RASPUZZI
;TCO 7.1034 - Move IPCF to XCDSEC. Change call to LOGOMO to call KJOMO.
; UPD ID= 45, RIP:<7.MONITOR>MEXEC.MAC.7,  17-Jul-87 12:45:58 by RASPUZZI
;TCO 7.1022 - Prevent ILMNRFs during JOBCOF at LDTACH when the controlling
;terminal disappears on us before we expect it to.
; UPD ID= 37, RIP:<7.MONITOR>MEXEC.MAC.6,   9-Jul-87 16:13:32 by RASPUZZI
;TCO 7.1019 - Fix mistake in TCO 7.1003 and then castrate engineer.
; UPD ID= 17, RIP:<7.MONITOR>MEXEC.MAC.5,   5-Jun-87 11:44:31 by MCCOLLUM
; TCO 7.1010 - Fix up ENACT to check for a null file and return an
;  error. Fix RUNDI1 to display a more useful error message.
; UPD ID= 15, RIP:<7.MONITOR>MEXEC.MAC.4,   2-Jun-87 15:30:28 by GSCOTT
;TCO 7.1006 - Repair various accounting problems - put back lost autopatch 
;  edit 7477, install autopatch edits 7484 to 7488.
; UPD ID= 13, RIP:<7.MONITOR>MEXEC.MAC.3,  28-May-87 16:25:08 by RASPUZZI
;TCO 7.1003 - Put a timeout restriction on the questions "Why Reload?"
;  and "Run CHECKD?" so that the system will boot if they are not
;  answered in a reasonable amount of time.
; *** Edit 7479 to MEXEC.MAC by MCCOLLUM on 12-May-87, for SPR #21607
; Turn of LAT lines when shuting down system at CHKHS4: 
; *** Edit 7456 to MEXEC.MAC by GSCOTT on 23-Apr-87, for SPR #19597
; Write session records properly when a job is attached, detached, or its
; session remark is changed. Also make sure session start time is correct. 
; *** Edit 7432 to MEXEC.MAC by MCCOLLUM on 1-Apr-87, for SPR #21552
; Rearrange code and define dummy routine XCKNI so building monitors with
; KNIN=0 will work 
; *** Edit 7414 to MEXEC.MAC by RASPUZZI on 10-Feb-87
; Make the LGOUT% JSYS obey ACJ's wishes
; *** Edit 7316 to MEXEC.MAC by RASPUZZI on 11-Jun-86, for SPR #20381
; Change MEXEC to start SETSPD at entry vector plus 1 when setting terminal
; lines, etc for system startup. 
; *** Edit 7279 to MEXEC.MAC by MRASPUZZI on 31-Mar-86, for SPR #20779
; Make MEXEC setup a PRARG block when CJ%FIL is set for an EXEC besides the
; system EXEC
; *** Edit 7259 to MEXEC.MAC by WONG on 14-Mar-86, for SPR #18580
; Add batch info to Usage Session Record.
; *** Edit 7247 to MEXEC.MAC by LOMARTIRE on 19-Feb-86
; Implement OFN caching 
;Edit 7247 - Add CHKOFN for OFN caching cleanup
; *** Edit 7211 to MEXEC.MAC by GRANT on 18-Dec-85
; Add CI counters for WATCH 
; Edit 7173 to MEXEC.MAC by PALMIERI on 23-Oct-85 (TCO 6.1.1542)
; Move modules NIUSR and LLMOP to an extended section. This required the
; changing of some global routine names in LLMOP; Therefor the changes to
; MEXEC, JSYSA, and FORK. 
; Edit 7160 to MEXEC.MAC by WAGNER on 16-Oct-85
; Modify JOBCOF code to respect ACJs wishes regarding logout of jobs even if
; detached job timeout has expired. 
;Edit 7160 Fix Logout of detached jobs to obey ACJ even if it denies
; request to logout. If ACJ denies, wait COFTIM and ask again.
; UPD ID= 2290, SNARK:<6.1.MONITOR>MEXEC.MAC.284,  29-Jun-85 22:38:22 by GRANT
;TCO 6.1.1477 - IPALOD has new entry point for monitor
; UPD ID= 2238, SNARK:<6.1.MONITOR>MEXEC.MAC.283,  19-Jun-85 10:57:37 by GROSSMAN
;TCO 6.1.1461 - Add call to LLMJB0 to CHKR.
; UPD ID= 2220, SNARK:<6.1.MONITOR>MEXEC.MAC.282,  12-Jun-85 17:45:43 by GRANT
;Change IPAFOO back to IPALOD
; UPD ID= 2120, SNARK:<6.1.MONITOR>MEXEC.MAC.281,   5-Jun-85 09:55:21 by MCCOLLUM
;TCO 6.1.1406  - Update copyright notice.
; UPD ID= 2026, SNARK:<6.1.MONITOR>MEXEC.MAC.280,  28-May-85 16:34:16 by MCCOLLUM
;Add ERJMPs
; UPD ID= 1965, SNARK:<6.1.MONITOR>MEXEC.MAC.279,  13-May-85 10:11:15 by GRANT
;TCO 6.1.1377 - Load CI ucode into resident memory during system startup. CIFORK
;no longer does loading of CI ucode.
; UPD ID= 1890, SNARK:<6.1.MONITOR>MEXEC.MAC.278,   4-May-85 15:14:42 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1862, SNARK:<6.1.MONITOR>MEXEC.MAC.277,   2-May-85 15:02:58 by GROSSMAN
;TCO 6.1.1354 - Fix CRJOB hangs when created job gets logged out too soon.
; UPD ID= 1858, SNARK:<6.1.MONITOR>MEXEC.MAC.276,  30-Apr-85 15:58:06 by LOMARTIRE
;TCO 6.1.1350 - Set local time from cluster first, then local system
; UPD ID= 1838, SNARK:<6.1.MONITOR>MEXEC.MAC.275,  26-Apr-85 15:09:38 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1837, SNARK:<6.1.MONITOR>MEXEC.MAC.274,  26-Apr-85 15:06:45 by MCCOLLUM
;TCO 6.1.1238 - Fix more BUG. documentation
; UPD ID= 1768, SNARK:<6.1.MONITOR>MEXEC.MAC.273,  22-Apr-85 09:02:38 by GRANT
;More 6.1.1284 - CALL CFSKPR should have been removed
; UPD ID= 1711, SNARK:<6.1.MONITOR>MEXEC.MAC.272,   5-Apr-85 13:47:27 by MCCOLLUM
;TCO 6.1.1238 - Fix BUG. documentation
; UPD ID= 1672, SNARK:<6.1.MONITOR>MEXEC.MAC.271,  25-Mar-85 08:20:11 by GRANT
;TCO 6.1.1284 - Change TEFORK to CIFORK and keep it around to do CI stuff
; UPD ID= 1643, SNARK:<6.1.MONITOR>MEXEC.MAC.270,  18-Mar-85 08:10:03 by GRANT
;More TCO 6.1.1245 - Minor enhancement
; UPD ID= 1624, SNARK:<6.1.MONITOR>MEXEC.MAC.269,  12-Mar-85 15:57:06 by LOMARTIRE
;TCO 6.1.1247 - Remove the extra wait after call to CFSJYN
; UPD ID= 1613, SNARK:<6.1.MONITOR>MEXEC.MAC.268,  11-Mar-85 09:54:05 by GRANT
;TCO 6.1.1245 - Broadcast cease, shutdown canceled, and timesharing is over.
;Add a check for cluster ceases in CHKR.
; UPD ID= 1581, SNARK:<6.1.MONITOR>MEXEC.MAC.267,   4-Mar-85 08:00:58 by LOMARTIRE
;TCO 6.1.1227 - Move the starting of TEFORK earlier to help insure CFS joining
; UPD ID= 1283, SNARK:<6.1.MONITOR>MEXEC.MAC.266,   7-Jan-85 11:03:26 by HAUDEL
;TCO 6.1.1115 - Add ERJMPs after a few JSYSes in logout,attach,and detach code
; Fix typo in UPD ID=1249.
; UPD ID= 1270, SNARK:<6.1.MONITOR>MEXEC.MAC.264,   4-Jan-85 15:01:26 by MCCOLLUM
;TCO 6.1.1111 - Get JFN's for job 0 forks with GJ%ACC on
; UPD ID= 1249, SNARK:<6.1.MONITOR>MEXEC.MAC.263,  31-Dec-84 13:12:53 by MCCOLLUM
;TCO 6.1.1112 - In GETAB%, translate local job number to global for DEVUNT table.
; UPD ID= 1230, SNARK:<6.1.MONITOR>MEXEC.MAC.262,  19-Dec-84 18:35:28 by GRANT
;Move SAVTRE to STG.MAC
; UPD ID= 1218, SNARK:<6.1.MONITOR>MEXEC.MAC.261,  18-Dec-84 12:48:47 by TBOYLE
;TCO 6.1.1092 - Fix jobs hung in LOGOUT - Put CFOBF at LOG2 after SOBE loop
; UPD ID= 1018, SNARK:<6.1.MONITOR>MEXEC.MAC.260,   9-Nov-84 13:25:40 by GRANT
;TCO 6.2278 - fix BUGxxx output
; UPD ID= 944, SNARK:<6.1.MONITOR>MEXEC.MAC.259,   4-Nov-84 15:25:06 by GLINDELL
;More TCO 6.1.1021 - Change MDDTP to reflect MDDT's new position in XCDSEC
; UPD ID= 5050, SNARK:<6.MONITOR>MEXEC.MAC.258,  31-Oct-84 18:08:38 by MOSER
;TCO 6.2256 - FIX CRJOB IF CJ%WTA SPECIFIED
; UPD ID= 5038, SNARK:<6.MONITOR>MEXEC.MAC.257,  30-Oct-84 13:55:40 by MCLEAN
;FIX LOGOUT
; UPD ID= 5037, SNARK:<6.MONITOR>MEXEC.MAC.256,  30-Oct-84 09:59:56 by PAETZOLD
;TCO 6.2267 - Save CX in JOBCOF.
; UPD ID= 5003, SNARK:<6.MONITOR>MEXEC.MAC.255,  24-Oct-84 20:15:31 by GLINDELL
;Put in a call to DCNJB0 in CHKR
; UPD ID= 4974, SNARK:<6.MONITOR>MEXEC.MAC.254,  22-Oct-84 16:31:20 by GRANT
;Remove references to FTCI
; UPD ID= 4965, SNARK:<6.MONITOR>MEXEC.MAC.253,  19-Oct-84 14:46:22 by GLINDELL
;More TCO 6.1.1021 - clear T3 before SOUT in LOGBUG
; UPD ID= 4964, SNARK:<6.MONITOR>MEXEC.MAC.252,  19-Oct-84 13:42:26 by GLINDELL
;More TCO 6.1.1021 - get only section-relative address of BUG. for compare
; UPD ID= 4948, SNARK:<6.MONITOR>MEXEC.MAC.251,  17-Oct-84 15:17:44 by HAUDEL
;TCO 6.2250 - Add an ERJMP after an ODTIM% in LOGJ2 code.
; UPD ID= 4947, SNARK:<6.MONITOR>MEXEC.MAC.250,  17-Oct-84 13:58:59 by HAUDEL
;TCO 6.2249 - Add some ERJMPs after a few JSYSes.
; UPD ID= 4945, SNARK:<6.MONITOR>MEXEC.MAC.249,  17-Oct-84 11:57:16 by TGRADY
; TCO 6.2247 (QAR 706189) Print proper job number in ATTACH JSYS.
; TCO 6.2214 (QAR 706279) Fix up STCRJB and ELOGO to understand that JOBONT
; contains GLOBAL job numbers, not local.  Oversight in edit 4785.
; UPD ID= 4944, SNARK:<6.MONITOR>MEXEC.MAC.248,  17-Oct-84 10:55:47 by HAUDEL
;TCO 6.2246 - Add ERJMP .+1 after BOUTs in LOGTIM: code.
; UPD ID= 4935, SNARK:<6.MONITOR>MEXEC.MAC.247,  15-Oct-84 13:06:30 by GRANT
;The assembly switch CFSCOD has been eliminated
; UPD ID= 4915, SNARK:<6.MONITOR>MEXEC.MAC.246,  10-Oct-84 17:13:06 by GLINDELL
;TCO 6.1.1021 - 6.1 address space
;	BGPTR entries are now two words long (full 30-bit addresses)
; UPD ID= 4884, SNARK:<6.MONITOR>MEXEC.MAC.245,  26-Sep-84 16:40:18 by GRANT
;In CHKR, CALL KLPRCT
; UPD ID= 4882, SNARK:<6.MONITOR>MEXEC.MAC.244,  26-Sep-84 15:59:55 by GRANT
;TCO 6.2225 - Add "save a tree" option to LOGBUG
; UPD ID= 4863, SNARK:<6.MONITOR>MEXEC.MAC.243,  23-Sep-84 15:24:41 by TBOYLE
;Clear output buffer during LOGOUT after STPAR in LOG1
; UPD ID= 4813, SNARK:<6.MONITOR>MEXEC.MAC.242,  17-Sep-84 10:13:22 by PURRETTA
;Update copyright notice
; UPD ID= 4785, SNARK:<6.MONITOR>MEXEC.MAC.241,  31-Aug-84 14:29:47 by TGRADY
;TCO 6.2214 (QAR 706071) Fix up use of CRJONJ and JOBONT for CRJOB'ed jobs.
; UPD ID= 4777, SNARK:<6.MONITOR>MEXEC.MAC.240,  30-Aug-84 10:48:24 by PAETZOLD
;TCO 6.2211 - Carrier off needs to preserve KIMUFL and KIMUPC.
; UPD ID= 4771, SNARK:<6.MONITOR>MEXEC.MAC.239,  29-Aug-84 13:57:18 by TGRADY
;TCO 6.2201 (QAR 706198) - Remove edit 4444 (TCO 6.2121) and fix the
;general problem of needing a local job index in the USAGE record.
; UPD ID= 4743, SNARK:<6.MONITOR>MEXEC.MAC.238,  24-Aug-84 09:43:58 by PAETZOLD
;TCO 6.2191 - Change unsafe SETJSB calls to MAPJSB.
; UPD ID= 4702, SNARK:<6.MONITOR>MEXEC.MAC.237,  16-Aug-84 13:28:15 by GROSSMAN
;More TCO 6.2176 - Reverse order of IPALOD and KNIJB0.
; UPD ID= 4698, SNARK:<6.MONITOR>MEXEC.MAC.236,  15-Aug-84 18:51:40 by GROSSMAN
;TCO 6.2176 - Add call to KNIJB0 in CHKR.
; UPD ID= 4677, SNARK:<6.MONITOR>MEXEC.MAC.235,  13-Aug-84 10:26:47 by GLINDELL
;Type out the full 30-bit address on entry to the MX
; UPD ID= 4676, SNARK:<6.MONITOR>MEXEC.MAC.234,  11-Aug-84 00:54:45 by TBOYLE
;TCO 6.2171 Save all registers at JOBCOF.
; UPD ID= 4620, SNARK:<6.MONITOR>MEXEC.MAC.233,  28-Jul-84 15:58:40 by MOSER
;TCO 6.2083 - ENHANCE MONBK - ADD MONBKX
; UPD ID= 4610, SNARK:<6.MONITOR>MEXEC.MAC.232,  27-Jul-84 14:51:19 by TBOYLE
;New SYSERR - At LOGBF6-1 use XMOVEI.
; UPD ID= 4507, SNARK:<6.MONITOR>MEXEC.MAC.231,  12-Jul-84 21:55:51 by TGRADY
;TCO 6.2126 Use Global job number as argument to GTOKM .GOATJ function
; UPD ID= 4455, SNARK:<6.MONITOR>MEXEC.MAC.230,  12-Jul-84 10:43:05 by CDUNN
;More TCO 6.1127 Add call to SCSLGO at FLOGO to delete SCS% data on top 
;fork kill
; UPD ID= 4444, SNARK:<6.MONITOR>MEXEC.MAC.229,   6-Jul-84 16:54:45 by TBOYLE
;TCO 6.2121 - Make UCKSET convert jobno to local before mapping checkpoint pg.
; UPD ID= 4418, SNARK:<6.MONITOR>MEXEC.MAC.228,   2-Jul-84 13:46:13 by TGRADY
;TCO 6.2114 - Fix typo in TTY2GL to return waiting fork number...
; UPD ID= 4364, SNARK:<6.MONITOR>MEXEC.MAC.227,  20-Jun-84 15:59:58 by TBOYLE
;TCO 6.2104 - Fix session start and end times at USGSEN.
; UPD ID= 4363, SNARK:<6.MONITOR>MEXEC.MAC.226,  20-Jun-84 15:10:36 by TGRADY
;TCO 6.2103 (QAR 706052) - Fix ATACH% to prevent 'Wheel or Opr required' error
; UPD ID= 4358, SNARK:<6.MONITOR>MEXEC.MAC.225,  18-Jun-84 15:48:47 by TGRADY
;TCO 6.2077 (QAR 706022) Make GETAB% return a -1 for non-existant jobs.
; UPD ID= 4356, SNARK:<6.MONITOR>MEXEC.MAC.224,  18-Jun-84 14:13:38 by GRANT
;TCO 6.2102 (QAR 706050) - During system shutdown disallow incoming nvt
;(ARPANET and DECnet) logins.
; UPD ID= 4300, SNARK:<6.MONITOR>MEXEC.MAC.223,   4-Jun-84 23:01:34 by MOSER
;TCO 6.2059 - ALLOW EXEC XCT ONLY - FIX CRJOB - CHANGES FOR NON WHEEL STARTUP
; UPD ID= 4219, SNARK:<6.MONITOR>MEXEC.MAC.222,  14-May-84 18:55:34 by WEISBACH
;~6.0 - Add call to LAT host initialization (LATINI)
; UPD ID= 4211, SNARK:<6.MONITOR>MEXEC.MAC.221,  11-May-84 12:15:11 by GRANT
;In RUNDD2, add call to SRVCFS (moved here from CFSJYN in CFSSRV)
; UPD ID= 4207, SNARK:<6.MONITOR>MEXEC.MAC.220,  11-May-84 08:18:39 by GRANT
;In EGET, ERJMP after the GET%
; UPD ID= 4128, SNARK:<6.MONITOR>MEXEC.MAC.219,  25-Apr-84 11:07:42 by LOMARTIRE
;TCO 6.2046 - Record fork number for various job 0 forks created in RUNDD
; UPD ID= 4115, SNARK:<6.MONITOR>MEXEC.MAC.218,  24-Apr-84 12:59:05 by TGRADY
;TCO 6.2042 - Fix CFSILJ BUGCHK's from GETJI% called with .TTDES+n
; UPD ID= 4069, SNARK:<6.MONITOR>MEXEC.MAC.217,  11-Apr-84 19:12:50 by MOSER
;TCO 6.2023 - REMOVE ALL ERCAL INSTRUCTIONS
; UPD ID= 4062, SNARK:<6.MONITOR>MEXEC.MAC.215,  11-Apr-84 14:47:35 by GRANT
;In IPACHK, more graceful handling of no IPALOD or IPADMP
; UPD ID= 4012, SNARK:<6.MONITOR>MEXEC.MAC.214,  31-Mar-84 08:10:17 by GRANT
;Remove SEARCH of SCAPAR
; UPD ID= 4001, SNARK:<6.MONITOR>MEXEC.MAC.213,  28-Mar-84 20:46:37 by GRANT
;In IPACHK, look on PS:<SYSTEM> instead of SYSTEM:
; UPD ID= 3998, SNARK:<6.MONITOR>MEXEC.MAC.212,  28-Mar-84 17:22:15 by GUNN
;Revoke UPD ID 3741 - Put under FTNSPSRV conditional.
; UPD ID= 3946, SNARK:<6.MONITOR>MEXEC.MAC.211,  19-Mar-84 16:57:31 by MOSER
;TCO 6.2003 - ADD .JILJI FUNCTION OF GETJI
; UPD ID= 3924, SNARK:<6.MONITOR>MEXEC.MAC.210,  14-Mar-84 10:51:46 by TGRADY
;TCO 6.1998 - Fix ELOGO to compare user-specified job number to GBLJNO,
;   not JOBNO
;
; UPD ID= 3869, SNARK:<6.MONITOR>MEXEC.MAC.209,   7-Mar-84 11:30:21 by LEACHE
;More TCO 6.1969 - move init of SWPMWF from MEXEC to PAGUTL
; UPD ID= 3850, SNARK:<6.MONITOR>MEXEC.MAC.207,   5-Mar-84 12:12:38 by GRANT
;In IPACHK, do dumping as well as loading.
; UPD ID= 3816, SNARK:<6.MONITOR>MEXEC.MAC.206,  29-Feb-84 17:04:39 by LEACHE
;TCO 6.1969 Change swappable monitor load to reflect single-pass load
; UPD ID= 3802, SNARK:<6.MONITOR>MEXEC.MAC.205,  29-Feb-84 01:44:07 by TGRADY
; Implement Global Job Numbers
; - In SYSINE, assign a Global Job number from CFS, and save it in GBLJNO
; - In STCRJB, return Global job number to CRJOB creator, put index in JOBONT
; - In RUNDD3, Initialize CFS Global Job Number database...
; - In HSYS41:, convert local job index to global job number for LGOUT Jsys
; - In LOG2, call JBAVAL to release Global job number just before HLTJB call.
; - In LOGJOB, Print Global job number during logout.
; - In ELOGO, translate user-specified global job number into local index
; - In .GJINF, use GBLJNO to return user's own job number, instead of JOBNO
; - In .GETAB, overhaul GTTAB table to use new GTJOB routine to translate
;   user-specified Global Job number into local job index.  Make the tables'
;   'size' be the highest legal Global Job number, MXGLBS, for range checking
;   instead of NJOBS, which is only the highest index value.
;   Also, create jacket routine TTY2GL to convert job index returned by
;   GTBTTF to a global job number
; - In .GETJI, translate user-specified global job number into local index
; - In GETJI4, translate job index into Global job number before returning it.
; - In GETJIT table, return other jobs Global Job number (from JSB)
; - In ATACH1, same as .GETJI
;
; UPD ID= 3741, SNARK:<6.MONITOR>MEXEC.MAC.204,  22-Feb-84 17:27:14 by PAETZOLD
;Revoke previous edit until he gets it right.  
; UPD ID= 3725, SNARK:<6.MONITOR>MEXEC.MAC.203,  22-Feb-84 11:39:52 by GUNN
;~6.0 - Add call to initialize Ethernet LLMOP Protocol Servers
; UPD ID= 3721, SNARK:<6.MONITOR>MEXEC.MAC.202,  22-Feb-84 05:36:57 by GRANT
;Call CFSJ0 from CHKR
; UPD ID= 3698, SNARK:<6.MONITOR>MEXEC.MAC.201,  15-Feb-84 21:28:14 by MURPHY
;Make definition of MDDT include section number so MDDT$G always works.
; UPD ID= 3741, SNARK:<6.MONITOR>MEXEC.MAC.204,  22-Feb-84 17:27:14 by PAETZOLD
;Revoke previous edit until he gets it right.  
; UPD ID= 3725, SNARK:<6.MONITOR>MEXEC.MAC.203,  22-Feb-84 11:39:52 by GUNN
;~6.0 - Add call to initialize Ethernet LLMOP Protocol Servers
; UPD ID= 3721, SNARK:<6.MONITOR>MEXEC.MAC.202,  22-Feb-84 05:36:57 by GRANT
;Call CFSJ0 from CHKR
; UPD ID= 3698, SNARK:<6.MONITOR>MEXEC.MAC.201,  15-Feb-84 21:28:14 by MURPHY
;Make definition of MDDT include section number so MDDT$G always works.
; UPD ID= 3656, SNARK:<6.MONITOR>MEXEC.MAC.200,   4-Feb-84 10:32:35 by MILLER
;Call BRDTIM if CFS stuff is around
; UPD ID= 3648, SNARK:<6.MONITOR>MEXEC.MAC.199,   2-Feb-84 14:35:36 by MURPHY
;Ditto - fix bugs.
; UPD ID= 3640, SNARK:<6.MONITOR>MEXEC.MAC.198,   2-Feb-84 11:53:23 by MURPHY
;Different way of getting to BOOT to load swap mon.
; UPD ID= 3633, SNARK:<6.MONITOR>MEXEC.MAC.197,   1-Feb-84 22:08:42 by MURPHY
;Reference bug strings and pointers in symsec.
; UPD ID= 3565, SNARK:<6.MONITOR>MEXEC.MAC.196,  27-Jan-84 13:34:03 by PAETZOLD
;More TCO 6.1954 - Make CHKPER and DDPPER resident.  Fix DDPWAT bug.
; UPD ID= 3557, SNARK:<6.MONITOR>MEXEC.MAC.195,  26-Jan-84 13:56:47 by PAETZOLD
;More TCO 6.1954 - Make CHKPER and DDPPER global.  Make DDPDUE force DDMP.
; UPD ID= 3539, SNARK:<6.MONITOR>MEXEC.MAC.194,  25-Jan-84 15:14:38 by PAETZOLD
;TCO 6.1954 - Add code for DDPDUE and CHKDUE.
; UPD ID= 3510, SNARK:<6.MONITOR>MEXEC.MAC.193,  23-Jan-84 09:44:12 by PRATT
;TCO 6.1924 - Use "display type" block with "msg" block in WROPER
; UPD ID= 3490, SNARK:<6.MONITOR>MEXEC.MAC.192,  20-Jan-84 11:09:27 by CDUNN
;More TCO 6.1127 - Add new "temp" fork at startup to handle SCA buffer deferal
;requests until after DDMP has mounted PS.
; UPD ID= 3456, SNARK:<6.MONITOR>MEXEC.MAC.191,  13-Jan-84 17:16:14 by TBOYLE
;TCO 6.1933 - (RUNDD4) Do processing if SPRCNT not reset, and start 
;SYSERR queue
; UPD ID= 3449, SNARK:<6.MONITOR>MEXEC.MAC.190,  12-Jan-84 14:22:41 by PAETZOLD
;TCO 6.1929 - Change FKJOBN to FKJBN
; UPD ID= 3420, SNARK:<6.MONITOR>MEXEC.MAC.189,   6-Jan-84 18:13:00 by MILLER
;Add CFSCOD conditional around call to CFTADC
; UPD ID= 3418, SNARK:<6.MONITOR>MEXEC.MAC.188,   6-Jan-84 09:07:27 by PRATT
;TCO 6.1912 - In WROPER, QU%NRS should be set in the arg block, not ac 1 
; UPD ID= 3310, SNARK:<6.MONITOR>MEXEC.MAC.187,  13-Dec-83 18:16:03 by PAETZOLD
;TCO 6.1906 - Add code to update DDPTIM
; UPD ID= 3270, SNARK:<6.MONITOR>MEXEC.MAC.186,   7-Dec-83 09:06:17 by MILLER
;TCO 6.1806. Add calls to DTTIME
; UPD ID= 3192, SNARK:<6.MONITOR>MEXEC.MAC.185,  18-Nov-83 11:01:36 by PAETZOLD
;Do not call CHKIMP
; UPD ID= 3183, SNARK:<6.MONITOR>MEXEC.MAC.184,  17-Nov-83 14:15:55 by PRATT
;TCO 6.1796 - Lots of ERJMPs after TTMSGs in case of refusals
; UPD ID= 3151, SNARK:<6.MONITOR>MEXEC.MAC.183,  15-Nov-83 09:47:34 by PAETZOLD
;TCO 6.1862 - Fix problem with incorrect .XPCN2 word being returned in XPEEK
; UPD ID= 3114, SNARK:<6.MONITOR>MEXEC.MAC.182,   8-Nov-83 09:01:15 by MCINTEE
;~6.0 Remove NSP% jsys
; UPD ID= 3095, SNARK:<6.MONITOR>MEXEC.MAC.181,   3-Nov-83 23:37:50 by GROSSMAN
;TCO 6.1849 - Reset CRJTTY to a value of -1 only during CRJOB startup.
; UPD ID= 3084, SNARK:<6.MONITOR>MEXEC.MAC.180,  28-Oct-83 15:54:56 by HAUDEL
;TCO 6.1840 - Add an ERJMP .+1 after TTMSG 
; UPD ID= 3004, SNARK:<6.MONITOR>MEXEC.MAC.179,   7-Oct-83 17:55:34 by GUNN
;~6.0 Add call to LLMRSJ from FLOGO to clean up LLMOP resources at logout.
; UPD ID= 2993, SNARK:<6.MONITOR>MEXEC.MAC.178,   5-Oct-83 14:49:33 by PAETZOLD
;More TCO 6.1733 - Remove call to IMPBEG.  NCPFRK has gone away.
; UPD ID= 2978, SNARK:<6.MONITOR>MEXEC.MAC.177,   4-Oct-83 08:07:04 by MILLER
;TCO 6.1806 Once again.
; UPD ID= 2944, SNARK:<6.MONITOR>MEXEC.MAC.176,  27-Sep-83 20:35:08 by MILLER
;MORE TCO 6.1806. CHECK ON TAD IN CHKR
; UPD ID= 2930, SNARK:<6.MONITOR>MEXEC.MAC.175,  23-Sep-83 14:00:41 by MILLER
;More TCO 6.1806. Output date and time so operator knows
; UPD ID= 2926, SNARK:<6.MONITOR>MEXEC.MAC.174,  23-Sep-83 10:37:51 by MILLER
;TCO 6.1806. Try to get TAD from CFS
; UPD ID= 2914, SNARK:<6.MONITOR>MEXEC.MAC.173,  20-Sep-83 15:33:39 by LOMARTIRE
;TCO 6.1791 - Do not allow ATACH from batch unless WHEEL or OPR enabled
; UPD ID= 2842, SNARK:<6.MONITOR>MEXEC.MAC.172,  17-Aug-83 21:41:01 by MURPHY
;More 6.1525 - Separate section 0/1 maps.  Remove NRCOD from sec 0 map.
; UPD ID= 2807, SNARK:<6.MONITOR>MEXEC.MAC.171,   9-Aug-83 11:46:15 by MURPHY
;Move MOVCST from here to PAGUTL.
; UPD ID= 2797, SNARK:<6.MONITOR>MEXEC.MAC.170,   4-Aug-83 00:30:32 by LEACHE
;TCO 6.1641  Change swappable freespace initialization
; UPD ID= 2768, SNARK:<6.MONITOR>MEXEC.MAC.169,  25-Jul-83 17:48:48 by MCCOLLUM
;TCO 6.1743 - Add XPEEK% JSYS
; UPD ID= 2749, SNARK:<6.MONITOR>MEXEC.MAC.168,  22-Jul-83 16:38:22 by PAETZOLD
;TCO 6.1733 - Reflect that NCP has gone away.
; UPD ID= 2745, SNARK:<6.MONITOR>MEXEC.MAC.167,  22-Jul-83 16:33:16 by MURPHY
;More 6.1568 - Make COFTIM settable by SMON.
;TCO 6.1719 - Customer-selectable hangup action.
; UPD ID= 2673, SNARK:<6.MONITOR>MEXEC.MAC.166,   5-Jul-83 16:04:54 by MILLER
;Various changes for CFS CI error recovery
; UPD ID= 2669, SNARK:<6.MONITOR>MEXEC.MAC.165,   5-Jul-83 15:48:20 by MOSER
;TCO 6.1568 - USE COFMIN AS VALUE FOR CARRIER OFF WAIT BEFORE LOGOUT
; UPD ID= 2667, SNARK:<6.MONITOR>MEXEC.MAC.164,   5-Jul-83 13:32:48 by MURPHY
;More 6.1525 - Remove hidden symbol table, add symtab in separate section.
; UPD ID= 2602, SNARK:<6.MONITOR>MEXEC.MAC.163,  20-Jun-83 15:40:03 by HALL
;TCO 6.1689 - Move fork tables to extended section
;	Reference FKINT bits via DEFSTR
; UPD ID= 2577, SNARK:<6.MONITOR>MEXEC.MAC.162,  10-Jun-83 17:39:29 by PAETZOLD
;TCO 6.1680 - Turn on QU%NRS in WROPR0
; UPD ID= 2546, SNARK:<6.MONITOR>MEXEC.MAC.161,  31-May-83 16:44:49 by MURPHY
;TCO 6.1525 - Move subsys names tables to ext section.
; UPD ID= 2382, SNARK:<6.MONITOR>MEXEC.MAC.160,  29-Apr-83 15:03:02 by MCINTEE
;TCO 6.1630 - MONBK/PSIMB fix
; UPD ID= 2286, SNARK:<6.MONITOR>MEXEC.MAC.158,  16-Apr-83 19:14:33 by PAETZOLD
;TCO 6.1557 - TCP Merge - Delete old edit history - Update copyright.
; UPD ID= 2245, SNARK:<6.MONITOR>MEXEC.MAC.157,  12-Apr-83 13:15:09 by MCINTEE
;Remove IFNDEF FTNSPSRV
; UPD ID= 2219, SNARK:<6.MONITOR>MEXEC.MAC.156,   8-Apr-83 13:06:09 by MILLER
;TCO 6.1602 again. Fix call to RUNDII in IPACHK
; UPD ID= 2218, SNARK:<6.MONITOR>MEXEC.MAC.155,   8-Apr-83 12:29:03 by MILLER
;Fix IPACHK some
; UPD ID= 2216, SNARK:<6.MONITOR>MEXEC.MAC.154,   8-Apr-83 09:37:05 by MILLER
;Once more. Wait for KLIPA reload at system start-up
; UPD ID= 2215, SNARK:<6.MONITOR>MEXEC.MAC.153,   8-Apr-83 08:36:24 by MILLER
;TCO 6.1602. Load KLIPA microcode when needed
; UPD ID= 2205, SNARK:<6.MONITOR>MEXEC.MAC.152,   8-Apr-83 05:58:57 by WACHS
;TCO 6.1604 - Call KLIPA initialization late
; UPD ID= 2130, SNARK:<6.MONITOR>MEXEC.MAC.151,   2-Apr-83 22:46:44 by LEACHE
;TCO 6.1247 Add centralized penalties for bad passwords
; UPD ID= 2111, SNARK:<6.MONITOR>MEXEC.MAC.149,  28-Mar-83 19:43:31 by MILLER
;TCO 6.1094. Get rid of GETALF
; UPD ID= 2102, SNARK:<6.MONITOR>MEXEC.MAC.148,  28-Mar-83 17:43:19 by MURPHY
;TCO 6.1472 - Minor cleanup re. LSTERR.
; UPD ID= 1995, SNARK:<6.MONITOR>MEXEC.MAC.147,  15-Mar-83 10:58:40 by MILLER
;TCO 6.1544. Call MAPPHQ when mapping BOOT
; UPD ID= 1967, SNARK:<6.MONITOR>MEXEC.MAC.146,  10-Mar-83 17:57:28 by CDUNN
;More TCO 6.1127 - Add lost edit to call SC.RAP to clean up SCA data as
;needed.
; UPD ID= 1929, SNARK:<6.MONITOR>MEXEC.MAC.145,   7-Mar-83 21:02:14 by CDUNN
;Change default to include KLIPA code
; UPD ID= 1913, SNARK:<6.MONITOR>MEXEC.MAC.144,   3-Mar-83 13:05:37 by MCINTEE
;TCO 6.1532 - Remove SE1ENT & SE0ENT in routine STCJB2. Put in a TSTMS0.
; UPD ID= 1908, SNARK:<6.MONITOR>MEXEC.MAC.143,   2-Mar-83 17:30:32 by MILLER
;TCO 6.1094 again. CALL CFSJYN
; UPD ID= 1904, SNARK:<6.MONITOR>MEXEC.MAC.142,   2-Mar-83 15:44:36 by MILLER
;TCO 6.1094 again. Move MNTPS yet again, and call FILRST with it
; UPD ID= 1888, SNARK:<6.MONITOR>MEXEC.MAC.141,   1-Mar-83 10:37:34 by MILLER
;TCO 6.1094. Move call to MNTPS
; UPD ID= 1880, SNARK:<6.MONITOR>MEXEC.MAC.140,  27-Feb-83 22:05:25 by MURPHY
;More TCO 6.1514 and 6.1142 - Use ERJMPS after DIRST in LOGBUG.
;TCO 6.1525 - Get rid of unneeded XJRSTs.
; UPD ID= 1860, SNARK:<6.MONITOR>MEXEC.MAC.139,  22-Feb-83 20:24:48 by MILLER
;TCO 6.1520.  Enable disk preallocation after CHECKD runs
; UPD ID= 1858, SNARK:<6.MONITOR>MEXEC.MAC.138,  22-Feb-83 14:12:36 by MILLER
;TCO 6.1094. Add call to MNTPS during start-up
; UPD ID= 1847, SNARK:<6.MONITOR>MEXEC.MAC.137,  21-Feb-83 16:21:26 by MURPHY
;More 6.1507 - JOBCOF should jump to FLOGO1 not FLOGO after UPDL reset.
; UPD ID= 1842, SNARK:<6.MONITOR>MEXEC.MAC.136,  20-Feb-83 22:17:36 by MURPHY
;TCO 6.1514 - Use ITERX instead of JRST ITRAP.
; and revise the fixup to the fix to the fix to 6.1142 now that DIRST works.
; UPD ID= 1821, SNARK:<6.MONITOR>MEXEC.MAC.135,  18-Feb-83 07:32:51 by MCINTEE
;FIXUP THE FIX TO THE FIX TO 6.1142 - USE A TRVAR, NOT THE STACK
; UPD ID= 1814, SNARK:<6.MONITOR>MEXEC.MAC.134,  16-Feb-83 15:03:35 by MCINTEE
;FIX THE FIX TO 6.1142
; UPD ID= 1810, SNARK:<6.MONITOR>MEXEC.MAC.133,  15-Feb-83 14:22:21 by MILLER
;TCO 6.1094. Improve call to GETALF
; UPD ID= 1809, SNARK:<6.MONITOR>MEXEC.MAC.132,  15-Feb-83 10:16:24 by MURPHY
;TCO 6.1472 - Clean up uses of MCENTR.
;TCO 6.1506 - BUGCHK on unexpected job 0 interrupts.
;TCO 6.1507 - Fix MONPDL in JOBCOF.
;Fix to 6.1142 - Pointer clobbered if DIRST fails in LOGBUG.
; UPD ID= 1773, SNARK:<6.MONITOR>MEXEC.MAC.131,   5-Feb-83 18:55:25 by MILLER
;TCO 6.1094. Use DDMPF to flush pages for CFS
; UPD ID= 1768, SNARK:<6.MONITOR>MEXEC.MAC.130,   4-Feb-83 11:18:53 by MILLER
;TCO 6.1094. Distinguish DDMP for CFS from regular cycle
; UPD ID= 1745, SNARK:<6.MONITOR>MEXEC.MAC.129,   2-Feb-83 18:44:23 by MILLER
;TCO 6.1142. Some code clean ups. More to come...
; UPD ID= 1707, SNARK:<6.MONITOR>MEXEC.MAC.128,  27-Jan-83 20:06:53 by MILLER
;TCO 6.1094.CFS "get directory allocation".
; UPD ID= 1700, SNARK:<6.MONITOR>MEXEC.MAC.127,  26-Jan-83 14:25:30 by WEETON
;TCO 6.1401 - Fix ITRLGO BUGCHKs and WAITNI BUGHLTs
; UPD ID= 1680, SNARK:<6.MONITOR>MEXEC.MAC.126,  19-Jan-83 15:40:31 by MCINTEE
;TCO 6.1471 - MOVE SEBINI FROM EXEC0
; UPD ID= 1661, SNARK:<6.MONITOR>MEXEC.MAC.125,  15-Jan-83 16:45:12 by CHALL
;REMOVE RS(SWPMBP,1), WHICH IS DUPLICATED IN STG
; UPD ID= 1650, SNARK:<6.MONITOR>MEXEC.MAC.124,  13-Jan-83 17:10:37 by CHALL.WIZARD
;Add call to .NSPRS at SJLGO4 (to clean up NSP% DECnet lines for top fork)
; UPD ID= 1630, SNARK:<6.MONITOR>MEXEC.MAC.123,   7-Jan-83 12:39:46 by MCINTEE
;TCO 6.1445 - Monitor version number in SYSJOB.EXE
; UPD ID= 1619, SNARK:<6.MONITOR>MEXEC.MAC.122,   5-Jan-83 10:27:35 by HALL
;TCO 6.1000 and 6.1094
;	Fix code at RUNDE1 to set up context correctly for all processors
;	Clean up the comments a bit. Move JB0INT to be near CHKR
; UPD ID= 1615, SNARK:<6.MONITOR>MEXEC.MAC.121,   4-Jan-83 11:30:55 by MILLER
;TCO 6.1094. Set up MONBK for new CHKR fork
; UPD ID= 1550, SNARK:<6.MONITOR>MEXEC.MAC.120,  21-Dec-82 09:16:12 by MILLER
;TCO 6.1094. Enhance DDMP error code by creating routine DDMPER
; UPD ID= 1539, SNARK:<6.MONITOR>MEXEC.MAC.119,  20-Dec-82 17:27:55 by NICHOLS
;Add FTNSPSRV to distinguish between release 6.0 and 6.1
;Make SYSJOB.EXE into 6-1-SYSJOB.EXE for 6.1 monitors
;Add initialization of CTERM host and other DECnet-36 features
;TCO 6.1030 - DAPLGO added to logout code (McIntee)
; UPD ID= 1511, SNARK:<6.MONITOR>MEXEC.MAC.118,   2-Dec-82 15:17:55 by MOSER
;TCO 6.1110 - CHECK CHKAC ARGUMENT BLOCK LENGTH CORRECTLY
; UPD ID= 1491, SNARK:<6.MONITOR>MEXEC.MAC.117,  30-Nov-82 14:59:23 by MOSER
;TCO 6.1109 - LET CHKAC SUCCEED IF CONNECTED DIRECTORY WRONG BUT ACCESS OK
; UPD ID= 1490, SNARK:<6.MONITOR>MEXEC.MAC.116,  30-Nov-82 12:32:58 by HAUDEL
;More TCO 6.1357
; UPD ID= 1486, SNARK:<6.MONITOR>MEXEC.MAC.115,  29-Nov-82 14:19:55 by GRANT
;TCO 6.1010 - Remove EA.ENT at USGINI, startup runs totally in section 1 now
; UPD ID= 1479, SNARK:<6.MONITOR>MEXEC.MAC.114,  29-Nov-82 09:26:47 by GRANT
;TCO 6.1010 - In EXEC0, add call to MOVCST
; UPD ID= 1466, SNARK:<6.MONITOR>MEXEC.MAC.113,  18-Nov-82 13:59:16 by MOSER
;TCO 6.1380 - PREVENT HUNG JOBS AT LOGOUT
; UPD ID= 1461, SNARK:<6.MONITOR>MEXEC.MAC.112,  18-Nov-82 12:59:42 by MOSER
;TCO 6.1353 - PASS CORRECT ARGS TO ACJ FOR ATACH
; UPD ID= 1454, SNARK:<6.MONITOR>MEXEC.MAC.111,  17-Nov-82 14:15:54 by COBB
;TCO 5.1.1107 - Don't PUSH in STKVAR context at LDTACH+10 or so
; UPD ID= 1452, SNARK:<6.MONITOR>MEXEC.MAC.110,  17-Nov-82 08:23:57 by HAUDEL
;More TCO 6.1357
; UPD ID= 1432, SNARK:<6.MONITOR>MEXEC.MAC.109,  10-Nov-82 10:21:04 by HAUDEL
;TCO 6.1357 - CHANGE SHUTDOWN MESSAGE,ADD CTY MESSAGE
; UPD ID= 1430, SNARK:<6.MONITOR>MEXEC.MAC.108,   9-Nov-82 16:34:53 by WEETON
;Fix TCO 6.1344
; UPD ID= 1426, SNARK:<6.MONITOR>MEXEC.MAC.107,   8-Nov-82 13:52:49 by WEETON
;TCO 6.1344 - Allow enabled WHEEL or OPERATORs to load any program in top fork
; UPD ID= 1405, SNARK:<6.MONITOR>MEXEC.MAC.106,   3-Nov-82 07:00:12 by GRANT
;More TCO 6.1010 - Make RUNDD start in section 1, make USGINI run in section 1.
;Also, print out RUNNING DDMP sooner.
; UPD ID= 1400, SNARK:<6.MONITOR>MEXEC.MAC.105,   2-Nov-82 01:42:01 by CDUNN
;More TCO 6.1127 - Make KACCHG reflect the new keep alive scheme for the
;CI emulator
; UPD ID= 1397, SNARK:<6.MONITOR>MEXEC.MAC.104,   1-Nov-82 14:42:46 by LEACHE
;TCO 6.1342 Add MONVER
; UPD ID= 1386, SNARK:<6.MONITOR>MEXEC.MAC.103,  27-Oct-82 23:07:58 by CDUNN
;More TCO 6.1127 - Add further support for CI emulator keep alive
; UPD ID= 1379, SNARK:<6.MONITOR>MEXEC.MAC.102,  25-Oct-82 14:40:02 by MILLER
;TCO 6.1094. Create CFS section at system start up
; UPD ID= 1366, SNARK:<6.MONITOR>MEXEC.MAC.101,  22-Oct-82 03:52:48 by CDUNN
;More TCO 6.1127, add short routine to job init code to update the CI
;emulation keep alive boundries...
; UPD ID= 1348, SNARK:<6.MONITOR>MEXEC.MAC.99,  18-Oct-82 13:27:46 by COBB
;TCO 6.1315 - Clear CRJTTY after assignment to prevent 2 jobs on 1 tty bug
; UPD ID= 1345, SNARK:<6.MONITOR>MEXEC.MAC.98,  18-Oct-82 11:53:09 by MILLER
;TCO 6.1094. Enhance DDMPA some more
; UPD ID= 1335, SNARK:<6.MONITOR>MEXEC.MAC.97,  13-Oct-82 17:22:13 by MILLER
;Rerun DDMP right away if need be
; UPD ID= 1330, SNARK:<6.MONITOR>MEXEC.MAC.96,  12-Oct-82 17:50:23 by MILLER
;Restart DDMP soon if someone needed it while it was running
; UPD ID= 1301, SNARK:<6.MONITOR>MEXEC.MAC.95,   8-Oct-82 14:35:14 by MILLER
;Put DDMP in its own fork for CFS (TCO 6.1094)
; UPD ID= 1259, SNARK:<6.MONITOR>MEXEC.MAC.94,  29-Sep-82 20:20:00 by MILLER
;Make sure time is not negative
; UPD ID= 1251, SNARK:<6.MONITOR>MEXEC.MAC.93,  27-Sep-82 23:38:29 by MILLER
;Make sure job 0 wakes up in time to run DDMP
; UPD ID= 1247, SNARK:<6.MONITOR>MEXEC.MAC.92,  27-Sep-82 22:24:26 by MILLER
;CFS --  Fix DDMP restart
; UPD ID= 1240, SNARK:<6.MONITOR>MEXEC.MAC.91,  24-Sep-82 14:58:10 by MILLER
;Make DDMP retry wait a bit before trying again
; UPD ID= 1237, SNARK:<6.MONITOR>MEXEC.MAC.90,  24-Sep-82 12:27:19 by LEACHE
;TCO 6.1273 Add MS%ASG
; UPD ID= 1230, SNARK:<6.MONITOR>MEXEC.MAC.89,  24-Sep-82 11:48:26 by MOSER
;TCO 5.1614 MAKE CJ%ETF WORK WITH CJ%FIL.
; UPD ID= 1226, SNARK:<6.MONITOR>MEXEC.MAC.88,  23-Sep-82 23:44:50 by MILLER
;Handle failure from DDMP
; UPD ID= 1178, SNARK:<6.MONITOR>MEXEC.MAC.87,  14-Sep-82 11:07:46 by MOSER
;TCO 6.1264 - CORRECT ARGS TO ACJ AT JOBCF1
; UPD ID= 1159, SNARK:<6.MONITOR>MEXEC.MAC.86,  10-Sep-82 13:30:19 by MILLER
;tco 6.1259. Make JOBCOF go to FLOGO whnever it wants to LOGOUT
; UPD ID= 1151, SNARK:<6.MONITOR>MEXEC.MAC.85,   7-Sep-82 11:10:27 by MILLER
;TCO 6.1255. Suppress start-up dialog if DBUGSW = 3
; UPD ID= 1139, SNARK:<6.MONITOR>MEXEC.MAC.84,   3-Sep-82 15:13:55 by MCINTEE
;More TCO 6.1184 - Eliminate unwanted OKSKED from ATACH code
; UPD ID= 1097, SNARK:<6.MONITOR>MEXEC.MAC.83,  19-Aug-82 13:36:37 by MCINTEE
;TCO 6.1030 - Add call to DAPLGO during logout
; UPD ID= 1075, SNARK:<6.MONITOR>MEXEC.MAC.82,  10-Aug-82 14:19:26 by LEACHE
;TCO 6.1223 - Make "WHY RELOAD" accept a lowercase answer.
; UPD ID= 1009, SNARK:<6.MONITOR>MEXEC.MAC.81,  28-Jul-82 08:21:04 by COBB
;MORE TCO 6.1193 - Fix typo in previous edit...
; UPD ID= 1008, SNARK:<6.MONITOR>MEXEC.MAC.80,  27-Jul-82 15:19:05 by COBB
;TCO 6.1193 - ZERO out count of NOSKED p-faults after startup complete AND...
;TCO 6.1194 - Add call to ENQFKR when killing top fork to release ENQ locks
; UPD ID= 984, SNARK:<6.MONITOR>MEXEC.MAC.79,  12-Jul-82 13:52:05 by CDUNN
;TCO 6.1184 Fix ATACH JSYS to allow attach to terminal assigned by calling job
; UPD ID= 980, SNARK:<6.MONITOR>MEXEC.MAC.78,   7-Jul-82 16:16:30 by COBB
;TCO 6.1183 - Change SYSTEM:EXEC.EXE to DEFAULT-EXEC:
; UPD ID= 859, SNARK:<6.MONITOR>MEXEC.MAC.77,   7-Jun-82 09:39:33 by MURPHY
;TCO 6.1147 - Move bugdefs from BUGS.MAC to here and put them in-line.
; UPD ID= 779, SNARK:<6.MONITOR>MEXEC.MAC.76,  24-May-82 09:12:23 by HALL
;TCO 6.1144 - REMOVE "BLT SWAPPABLE MONITOR"
; UPD ID= 777, SNARK:<6.MONITOR>MEXEC.MAC.75,  21-May-82 11:41:57 by CDUNN
;TCO 6.1127 - Add code to call CISRV for a periodic check from job 0.
; UPD ID= 763, SNARK:<6.MONITOR>MEXEC.MAC.74,  19-May-82 10:09:54 by MILLER
;;TCO 6.1142. Send system messages to ORION
; UPD ID= 719, SNARK:<6.MONITOR>MEXEC.MAC.73,  11-May-82 02:15:55 by CDUNN
;More TCO 6.127 - Add free space assurance for SCA in CHKR routine
; UPD ID= 707, SNARK:<6.MONITOR>MEXEC.MAC.72,   9-May-82 13:02:19 by HALL
;TCO 6.1000- Support the 2080
;	Make flags word for user mode include user AC block (EXEC0, EXECI1,
;		EXBUGH, HSYS4, EXPAL0, JOBCOF
;	At EXECI, preserve full word of flags instead of left half only
;	Make CHKR use XJRST to get to section 1
; UPD ID= 540, SNARK:<6.MONITOR>MEXEC.MAC.71,  20-Mar-82 19:42:50 by PAETZOLD
;TCO 5.1766 - Turn on FH%EPN in PMAP call in SJLGO4.  PM%EPN does not work.
; UPD ID= 471, SNARK:<6.MONITOR>MEXEC.MAC.70,  12-Mar-82 14:41:32 by PAETZOLD
;TCO 5.1753 - Turn on PM%EPN in PMAP call in logout code.  Prevents PAGLCKs
; UPD ID= 433, SNARK:<6.MONITOR>MEXEC.MAC.69,   4-Mar-82 13:59:51 by MURPHY
;TCO 5.1744 - Refers to changes made approx June, 1980.  Make default
;  settings of system messages more like release 4.
; UPD ID= 379, SNARK:<6.MONITOR>MEXEC.MAC.68,   4-Feb-82 09:55:41 by HALL
;TCO 6.1000 - Support the 2080
;	Remove call to KDPINI. Don't need it now that KS isn't supported
; UPD ID= 347, SNARK:<6.MONITOR>MEXEC.MAC.67,  24-Jan-82 23:50:20 by MURPHY
;TCO 5.1697 - XSSEV%, etc.  Move GETPAT and GETDMS to FORK.MAC
; UPD ID= 313, SNARK:<6.MONITOR>MEXEC.MAC.66,  18-Jan-82 10:50:17 by MILLER
; UPD ID= 407, SNARK:<5.MONITOR>MEXEC.MAC.64,  18-Jan-82 10:37:36 by MILLER
;TCO 5.1678 again. Enhance check in ATACH for specific TTY designator
; UPD ID= 305, SNARK:<6.MONITOR>MEXEC.MAC.65,  15-Jan-82 16:27:34 by MILLER
;More TCO 5.1678. Check for same job number
; UPD ID= 302, SNARK:<6.MONITOR>MEXEC.MAC.64,  15-Jan-82 14:04:49 by MILLER
;TCO 5.1678. Make detach of object job in ATACH race-free.
; UPD ID= 386, SNARK:<5.MONITOR>MEXEC.MAC.60,   9-Jan-82 18:30:36 by MILLER
;TCO 5.1661. Unlatch MOS cotrollers after TGHA runs
;MORE OF TCO 6.1054
; UPD ID= 278, SNARK:<6.MONITOR>MEXEC.MAC.61,   6-Jan-82 10:11:09 by MILLER
;TCO 6.1054. ADD GTOKM IN ATTACH.
; UPD ID= 191, SNARK:<6.MONITOR>MEXEC.MAC.60,   6-Nov-81 13:39:04 by MURPHY
;Make monitor forks start in section 1
; UPD ID= 162, SNARK:<6.MONITOR>MEXEC.MAC.59,  23-Oct-81 15:23:34 by COBB
; UPD ID= 247, SNARK:<5.MONITOR>MEXEC.MAC.58,   6-Oct-81 15:21:24 by MOSER
;MORE TCO 5.1512 FIX A BUG.
; UPD ID= 222, SNARK:<5.MONITOR>MEXEC.MAC.57,  28-Sep-81 16:20:34 by PAETZOLD
;TCO 5.1544 - CORRECT CALCULATION FOR UPPER LIMIT OF VBOOT GROUP IN GSMDSK
; UPD ID= 209, SNARK:<5.MONITOR>MEXEC.MAC.56,  23-Sep-81 13:41:05 by MURPHY
;DITTO
; UPD ID= 187, SNARK:<5.MONITOR>MEXEC.MAC.55,  16-Sep-81 17:50:34 by MURPHY
;TCO 5.1514 - Start SYSERR fork earlier in RUNDD so messages from FE don't pile up.
; UPD ID= 184, SNARK:<5.MONITOR>MEXEC.MAC.54,  16-Sep-81 12:09:35 by SCHMITT
;More TCO 4.1051 - Remove definition of USGMUP, it is in STG
; UPD ID= 182, SNARK:<5.MONITOR>MEXEC.MAC.53,  15-Sep-81 16:51:13 by SCHMITT
;TCO 4.1.1051 - Make system restart entry include Monitor uptime
; UPD ID= 179, SNARK:<5.MONITOR>MEXEC.MAC.52,  15-Sep-81 16:26:04 by MOSER
;TCO 5.1512 ADD SE1ENT TO JOBCOF.
; UPD ID= 134, SNARK:<5.MONITOR>MEXEC.MAC.51,   1-Sep-81 16:22:40 by GRANT
;Fix the check for DETACHed before CALL TTHNGU in LOG1 - dataset line was not
;being hung up if user was not logged in
; UPD ID= 57, SNARK:<5.MONITOR>MEXEC.MAC.50,  21-Jul-81 15:22:56 by GRANT
;Change "PS:" to "system structure"
;TCO 5.1375 - Fix bugs in ATACH JSYS
; UPD ID= 19, SNARK:<5.MONITOR>MEXEC.MAC.49,  12-Jul-81 15:44:27 by PAETZOLD
;Replace .FHSLF with .TTDES at DETMS3+3
; UPD ID= 18, SNARK:<5.MONITOR>MEXEC.MAC.48,  11-Jul-81 17:45:10 by PAETZOLD
;TCO 5.1407 - Make sure we dont ask to lock more memory than is on
; replacable queue in GSMD2
; UPD ID= 2289, SNARK:<5.MONITOR>MEXEC.MAC.47,   2-Jul-81 13:36:37 by PAETZOLD
;TCO 5.1393 - Change reference of BUGINT from immediate to full word
; UPD ID= 2265, SNARK:<5.MONITOR>MEXEC.MAC.46,  26-Jun-81 18:07:46 by MURPHY
;TCO 5.1376 - JOBCOF, FLOGO, FRKNOP
; UPD ID= 2125, SNARK:<5.MONITOR>MEXEC.MAC.45,   4-Jun-81 10:11:31 by GRANT
;Make sure all 23 bits of address get returned in GETSEG
; UPD ID= 2069, SNARK:<5.MONITOR>MEXEC.MAC.44,  22-May-81 16:48:23 by ZIMA
;TCO 5.1344 - Correct ATACH and DTACH privilege checking for batch jobs.
; UPD ID= 2056, SNARK:<5.MONITOR>MEXEC.MAC.43,  21-May-81 10:46:10 by SCHMITT
;More of TCO 5.1308
; UPD ID= 1967, SNARK:<5.MONITOR>MEXEC.MAC.42,   8-May-81 14:24:43 by SCHMITT
;More of TCO 5.1308 - Check for system shutdown in CHKR loop
; UPD ID= 1941, SNARK:<5.MONITOR>MEXEC.MAC.41,   5-May-81 17:06:32 by SCHMITT
;TCO 5.1308 - Latch HSYST1 to -1 when system shutdown
; UPD ID= 1921, SNARK:<5.MONITOR>MEXEC.MAC.40,   1-May-81 11:33:52 by PAETZOLD
;TCO 5.1301 add SCOUNT to GETAB tables, also bump SCOUNT in SETSN
; UPD ID= 1910, SNARK:<5.MONITOR>MEXEC.MAC.39,  30-Apr-81 16:29:05 by CHALL
;Inform the victim of a LOGOUT about the killer and his terminal
; UPD ID= 1817, SNARK:<5.MONITOR>MEXEC.MAC.38,  17-Apr-81 09:42:10 by WACHS
;TCO 5.1287 Restrict the possible answers to Why Reload question
; UPD ID= 1778, SNARK:<5.MONITOR>MEXEC.MAC.37,  31-Mar-81 17:43:13 by MURPHY
;Default is shutdown messages at 5 and 1 min
; UPD ID= 1719, SNARK:<5.MONITOR>MEXEC.MAC.36,  16-Mar-81 16:37:05 by MURPHY
;Add "PS:" to system expunge message
; UPD ID= 1569, SNARK:<5.MONITOR>MEXEC.MAC.35,  19-Feb-81 14:07:50 by HALL
;TCO 5.1180 - Move DST to non-zero section
; Fix EXEC0 so that it can run in section 1, because call to SETMPG
;  can get to GDSTX
; BSRAD - Use extra stack location and avoid clobbering PC
; GOTSWM - Change BLT to initialize SYSFK table
; UPD ID= 1496, SNARK:<5.MONITOR>MEXEC.MAC.34,  26-Jan-81 13:25:47 by ENGEL
;GET RID OF THE LCS CALLS. NOT PART OF NEXT RELEASE ANYMORE
; UPD ID= 1485, SNARK:<5.MONITOR>MEXEC.MAC.33,  24-Jan-81 23:20:07 by ZIMA
;TCO 5.1240 - Fix connect time calculation in CPGCON checkpoint routine.
; UPD ID= 1479, SNARK:<5.MONITOR>MEXEC.MAC.32,  22-Jan-81 12:37:41 by ZIMA
;TCO 5.1238 - expunge properly on logout.
; UPD ID= 1292, SNARK:<5.MONITOR>MEXEC.MAC.31,  18-Nov-80 18:11:05 by MURPHY
;FIX BUG IN JOBCOF - MAKE DETACH HAPPEN BEFORE LOGOUT
; UPD ID= 1286, SNARK:<5.MONITOR>MEXEC.MAC.30,  18-Nov-80 14:40:13 by OSMAN
; UPD ID= 1248, SNARK:<5.MONITOR>MEXEC.MAC.29,   7-Nov-80 15:01:32 by SCHMITT
;TCO 5.1194 - Fix code at USGIN7 to not cause CHKPNT errors
; UPD ID= 1221, SNARK:<5.MONITOR>MEXEC.MAC.28,   2-Nov-80 11:48:37 by HALL
;TCO 5.1180 - MOVE THE DST TO NON-ZERO SECTION
;	CHKR - RUN IN SECTION 1
;	GSMDX - RUN IN SECTION 1
;tco 5.1189 - Make entry vector two words
; UPD ID= 1221, SNARK:<5.MONITOR>MEXEC.MAC.28,   2-Nov-80 11:48:37 by HALL
;TCO 5.1180 - MOVE THE DST TO NON-ZERO SECTION
;	CHKR - RUN IN SECTION 1
;	GSMDX - RUN IN SECTION 1
; UPD ID= 1143, SNARK:<5.MONITOR>MEXEC.MAC.27,   8-Oct-80 15:14:08 by MURPHY
;BUG IN JOBCOF
; UPD ID= 1103, SNARK:<5.MONITOR>MEXEC.MAC.26,   2-Oct-80 09:28:08 by MURPHY
;DITTO
; UPD ID= 1081, SNARK:<5.MONITOR>MEXEC.MAC.25,   1-Oct-80 11:53:31 by MURPHY
;FIX ACVAR, ETC.
; UPD ID= 975, SNARK:<5.MONITOR>MEXEC.MAC.24,  29-Aug-80 08:41:47 by ENGEL
;ADD LCS INITIALIZATION CALL
; UPD ID= 972, SNARK:<5.MONITOR>MEXEC.MAC.23,  25-Aug-80 16:53:39 by HALL
;TCO 5.1139 - ADD FAILING PC AND LSTERR TO OUTPUT WHEN FORK 0 CRASHES
; UPD ID= 965, SNARK:<5.MONITOR>MEXEC.MAC.22,  25-Aug-80 16:28:07 by ENGEL
;TCO 5.1136 - ADD DEVLKK
; UPD ID= 932, SNARK:<5.MONITOR>MEXEC.MAC.21,  20-Aug-80 14:59:31 by LYONS
;TCO 5.1062 WRITE VERIFICATION ON WRITE FOR DISKS
; UPD ID= 841, SNARK:<5.MONITOR>MEXEC.MAC.20,   5-Aug-80 16:20:06 by OSMAN
;tco 5.1109 - Add PDV support to SSAVE and GET
; UPD ID= 812, SNARK:<5.MONITOR>MEXEC.MAC.19,  30-Jul-80 11:03:46 by MURPHY
;WEFLAG - DON'T WRITE-PROTECT MONITOR IF NON-0
; UPD ID= 789, SNARK:<5.MONITOR>MEXEC.MAC.18,  23-Jul-80 17:20:10 by R.ACE
;TCO 5.1112 - REMOVE VESTIGIAL "MOVE T1,FORKX" AT JOBCF1+2
; UPD ID= 747, SNARK:<5.MONITOR>MEXEC.MAC.17,   8-Jul-80 17:50:12 by HALL
;FIX LYONS' EDIT TO CHKUM1
; UPD ID= 723, SNARK:<5.MONITOR>MEXEC.MAC.15,   2-Jul-80 11:28:18 by LYONS
;Fix ILMNRF in SAVE% JSYS by maping read only page to non-existant page
; with no access, and fooling SAVEB1 into thinking page is really there
;Fix missing checks for tty detached when we get CTRLTT in LOG1
;Fix time race in CHKUM1 that can cause J0NRUN
;Fix reason why system down as told to IMP
;Fix CTY login after ^ECEASE if it was prohibited before
;ARPAnet can cause UPDL overflows if user in JSYS which locks tty data
;A job with PSI for carrier off does not get it until reattach time.
; UPD ID= 703, SNARK:<5.MONITOR>MEXEC.MAC.14,  26-Jun-80 09:52:06 by LYONS
;Add code to call ACJ on an implicit logout (i.e. thru a hangup of a dataset)
; UPD ID= 700, SNARK:<5.MONITOR>MEXEC.MAC.13,  25-Jun-80 17:26:40 by MURPHY
;FIRST SHUTDOWN MESSAGE CONTROLLED BY SF%MS1
; UPD ID= 698, SNARK:<5.MONITOR>MEXEC.MAC.12,  25-Jun-80 17:05:46 by GRADY
;TCO 5.1079 - FIX RACE AT LDTAC2, BUT UNLOKK DEVLKK AND GO OKINT TOO.
; UPD ID= 666, SNARK:<5.MONITOR>MEXEC.MAC.10,  16-Jun-80 19:06:25 by LYONS
;FIX RACE AT LDTAC2, WHERE CTRLTT MAY NOT BE RIGHT
; UPD ID= 662, SNARK:<5.MONITOR>MEXEC.MAC.9,  16-Jun-80 17:23:27 by KONEN
;TCO 5.1063 - REMOVE PS: AS NAME OF PRIMARY STRUCTURE
; UPD ID= 597, SNARK:<5.MONITOR>MEXEC.MAC.8,   3-Jun-80 17:45:02 by MURPHY
;FACTSW BITS TO CONTROL SYSTEM MESSAGES
; UPD ID= 498, SNARK:<5.MONITOR>MEXEC.MAC.7,  30-Apr-80 15:06:35 by GRANT
;TCO 5.1030 - Add description to ?FULL
; UPD ID= 468, SNARK:<5.MONITOR>MEXEC.MAC.6,  23-Apr-80 15:52:58 by LYONS
;pushed literals as PC dont allow for non zero sections
; UPD ID= 445, SNARK:<5.MONITOR>MEXEC.MAC.5,  15-Apr-80 11:01:18 by HALL
;MOVE LOGDES AND JB0TT INTO RSDAT
; UPD ID= 401, SNARK:<5.MONITOR>MEXEC.MAC.4,   2-Apr-80 15:52:50 by HALL
;FIX LOWER CASE IN PREVIOUS EDIT
; UPD ID= 394, SNARK:<5.MONITOR>MEXEC.MAC.3,   1-Apr-80 15:44:01 by HALL
;MAKE JB0TT AND USGMUP BE PART OF RSVAR PSECT
; UPD ID= 374, SNARK:<5.MONITOR>MEXEC.MAC.2,  26-Mar-80 13:36:09 by ENGEL
;STOP EDDT SYMBOL FROM PRINTING
; UPD ID= 288, SNARK:<4.1.MONITOR>MEXEC.MAC.447,  21-Feb-80 10:58:17 by MURPHY
;NEW FKINT DEFS
; UPD ID= 266, SNARK:<4.1.MONITOR>MEXEC.MAC.446,  15-Feb-80 17:39:58 by MURPHY
;PROPER LENGTH FOR QTIMES TABLE IN GETAB
; UPD ID= 240, SNARK:<4.1.MONITOR>MEXEC.MAC.445,   1-Feb-80 14:40:27 by ENGEL
; UPD ID= 110, SNARK:<4.1.MONITOR>MEXEC.MAC.444,   7-Dec-79 16:30:00 by SCHMITT
;TCO 4.1.1051 - CALC. MONITR UPTIME IN SEC AND GIVE TO USAGE JSYS FOR RESTART
; UPD ID= 106, SNARK:<4.1.MONITOR>MEXEC.MAC.443,   7-Dec-79 09:34:57 by R.ACE
;TCO 4.2591 - SECTION-0 PAGE TABLE SHARE COUNT PROBLEM FROM SSAVE
;ADD ERJMP AFTER SOUT IN LITERAL AFTER SSAVB4
; UPD ID= 91, SNARK:<4.1.MONITOR>MEXEC.MAC.442,   5-Dec-79 09:13:00 by OSMAN
;tco 4.1.1044 - Make EXEC command in mini-exec do implicit RESET
;<4.1.MONITOR>MEXEC.MAC.441, 16-Nov-79 13:47:41, EDIT BY MILLER
;PREVIOUS CHANGES UNDER TCO 4.1.1021
;<4.1.MONITOR>MEXEC.MAC.440, 16-Nov-79 13:00:38, EDIT BY MILLER
;ADD TTFSMS BUGINF
;<4.1.MONITOR>MEXEC.MAC.439, 16-Nov-79 11:46:24, EDIT BY MILLER
;CHANGE ALLMSG TO TIME-OUT TTMSG

;	COPYRIGHT (c) DIGITAL EQUIPMENT CORPORATION 1976, 1988.
;	ALL RIGHTS RESERVED.
;
;	THIS SOFTWARE IS FURNISHED UNDER A  LICENSE AND MAY BE USED AND  COPIED
;	ONLY IN  ACCORDANCE  WITH  THE  TERMS OF  SUCH  LICENSE  AND  WITH  THE
;	INCLUSION OF THE ABOVE  COPYRIGHT NOTICE.  THIS  SOFTWARE OR ANY  OTHER
;	COPIES THEREOF MAY NOT BE PROVIDED  OR OTHERWISE MADE AVAILABLE TO  ANY
;	OTHER PERSON.  NO  TITLE TO  AND OWNERSHIP  OF THE  SOFTWARE IS  HEREBY
;	TRANSFERRED.
;
;	THE INFORMATION IN THIS  SOFTWARE IS SUBJECT  TO CHANGE WITHOUT  NOTICE
;	AND SHOULD  NOT  BE CONSTRUED  AS  A COMMITMENT  BY  DIGITAL  EQUIPMENT
;	CORPORATION.
;
;	DIGITAL ASSUMES NO  RESPONSIBILITY FOR  THE USE OR  RELIABILITY OF  ITS
;	SOFTWARE ON EQUIPMENT THAT IS NOT SUPPLIED BY DIGITAL.


	SEARCH PROLOG,MONSYM,SERCOD,ACTSYM
	TTITLE JSYSM,,< - JSYS Code from MEXEC   >
	Subttl	Table of Contents

;		     Table of Contents for JSYSM
;
;				  Section		      Page
;
;
;    1. Local Definitions  . . . . . . . . . . . . . . . . . .   4
;    2. MDDT JSYS  . . . . . . . . . . . . . . . . . . . . . .   5
;    3. HSYS JSYS  . . . . . . . . . . . . . . . . . . . . . .   6
;        3.1    Job 0 Routine to Check System Shutdown . . . .   9
;        3.2    Job 0 Fork to Shutdown System  . . . . . . . .  11
;        3.3    Routine to Send Shutdown Message . . . . . . .  13
;    4. CHKAC JSYS . . . . . . . . . . . . . . . . . . . . . .  16
;    5. GJINF JSYS . . . . . . . . . . . . . . . . . . . . . .  21
;    6. TIME/RUNTM JSYSes  . . . . . . . . . . . . . . . . . .  22
;    7. GTRPI JSYS . . . . . . . . . . . . . . . . . . . . . .  23
;    8. GTDAL JSYS . . . . . . . . . . . . . . . . . . . . . .  24
;    9. HPTIM JSYS . . . . . . . . . . . . . . . . . . . . . .  25
;   10. SYSGT JSYS . . . . . . . . . . . . . . . . . . . . . .  26
;   11. GETAB JSYS . . . . . . . . . . . . . . . . . . . . . .  27
;   12. SETSN JSYS . . . . . . . . . . . . . . . . . . . . . .  33
;   13. SETNM/GETNM JSYSes . . . . . . . . . . . . . . . . . .  34
;   14. GETJI JSYS . . . . . . . . . . . . . . . . . . . . . .  35
;   15. SWTCH/LITES/USRIO JSYSes . . . . . . . . . . . . . . .  41
;   16. PEEK JSYS  . . . . . . . . . . . . . . . . . . . . . .  42
;   17. XPEEK% JSYS  . . . . . . . . . . . . . . . . . . . . .  43
;   18. CRJOB JSYS . . . . . . . . . . . . . . . . . . . . . .  45
;   19. LOGIN JSYS . . . . . . . . . . . . . . . . . . . . . .  51
;   20. DTACH JSYS . . . . . . . . . . . . . . . . . . . . . .  56
;   21. ATACH JSYS . . . . . . . . . . . . . . . . . . . . . .  62
;   22. LGOUT JSYS . . . . . . . . . . . . . . . . . . . . . .  70
;       22.1    Logout Another Job . . . . . . . . . . . . . .  71
;       22.2    Set PSI to Logout Another Job  . . . . . . . .  73
;       22.3    Perform Logout . . . . . . . . . . . . . . . .  74
;       22.4    Perform GETOK for LGOUT  . . . . . . . . . . .  79
;       22.5    Decrement Mount Counts . . . . . . . . . . . .  80
;   23. Session Logging Functions  . . . . . . . . . . . . . .  81
;   24. Routine To Break Links . . . . . . . . . . . . . . . .  93
	Subttl	Table of Contents (page 2)

;		     Table of Contents for JSYSM
;
;				  Section		      Page
;
;
;   25. USAGE JSYS . . . . . . . . . . . . . . . . . . . . . .  94
;       25.1    SYSTEM-DATA.BIN Format . . . . . . . . . . . .  95
;       25.2    Record Definitions . . . . . . . . . . . . . .  96
;       25.3    Functions Performed by Job 0 Fork  . . . . . . 100
;       25.4    Set Checkpoint Interval  . . . . . . . . . . . 101
;       25.5    Make Usage or Session Entry  . . . . . . . . . 102
;       25.6    Fill Record From Table . . . . . . . . . . . . 103
;       25.7    Fill Arbitrary Record  . . . . . . . . . . . . 106
;       25.8    Fill In Usage Entry Header . . . . . . . . . . 108
;       25.9    Compute Length of User Entry . . . . . . . . . 113
;       25.10   Copy String to Usage Block . . . . . . . . . . 115
;       25.11   Get Length of Disk Usage Block . . . . . . . . 116
;       25.12   Find and Fetch Entry In Caller's List  . . . . 117
;       25.13   Wait For Free Space  . . . . . . . . . . . . . 118
;       25.14   Get/Put Message on Job 0 Queue . . . . . . . . 119
;       25.15   Enable Account Validation  . . . . . . . . . . 120
;       25.16   Set/Read Accounting Shift Change . . . . . . . 122
;   26. Usage Support Routines
;       26.1    Initialization . . . . . . . . . . . . . . . . 124
;       26.2    Checkpoint File  . . . . . . . . . . . . . . . 131
;       26.3    Queued Message Handler . . . . . . . . . . . . 135
;       26.4    Checkpoint/Shift Change Timing . . . . . . . . 136
;       26.5    Write Usage File . . . . . . . . . . . . . . . 139
;       26.6    Update Checkpoint File . . . . . . . . . . . . 141
;   27. End of JSYSM . . . . . . . . . . . . . . . . . . . . . 145
	SUBTTL Local Definitions

;This file contains JSYS and job 0 level code removed from the MEXEC and JSYSA
;modules to make them smaller.  For the most part this code deals with job
;creation, destruction, and accounting.  This code does not require any special
;AC definitions.

;Things that need to be defined in this module for later use follow.  All of
;the conditional assembly is from the splitup of MEXEC and is included for
;historical reasons.

IFNDEF FTKLIPA,<FTKLIPA==-1>	;Default is include KLIPA support code
IFNDEF FTMSCP,<FTMSCP==0>	;Default is no MSCP

IFN <FTKLIPA!FTMSCP>,<EXTERN SCSLGO>	;[7.1200] Release SCS stuff upon logout

IFE FTNSPSRV,<EXTERN LLMRJB>	;[7.1200] Release LLMOP blocks upon logout

	SUBTTL MDDT JSYS

	SWAPCD			;[7.1200] 

;JSYS TO ENTER MDDT

.MDDT::	MCENT
	MOVEI 1,SC%WHL+SC%OPR
	TDNN 1,CAPENB
	ITERR(WHELX1)		;[7.1200] Wheel or Operator capability required
				;[7.1200] Fall through to TODDT

;Here from mini-exec to enter MDDT (do not move from SWAPCD)

TODDT::	GTOKM (.GOMDD,)		;[7.1200] Ask ACJ if this is OK
				;[7.1200] Fall through to LMDDT
;LINKAGE TO MDDT

MDDT=:<MSEC1,,LMDDT>		;SO MDDT$G ALWAYS GOES TO KNOWN SECTION
LMDDT::	XJRST MDDTP		;BE SURE TO CHANGE SECTIONS
  IFN FTNSPSRV < ;[6.0]
MDDTP::	SYMSEC,,MDDTX		;IN SYMBOL SECTION
  >
  IFE FTNSPSRV < ;[6.1]
MDDTP:: MDDTX			;MDDTX has section # in 6.1
  >

	RESCD

;HERE WHEN USER TYPES "EDDT$G" IN MDDT.  DON'T GO TO EDDT UNLESS IT
;IS LOADED AND LOCKED DOWN.  USERS WHO WANT TO ANYWAY CAN TYPE "DDTX$G".

EDDT=:<MSEC1,,.>		;START IN SECTION 1 ON EDDT$G FROM MDDT

	SKIPE DDTPRS		;IS EDDT PRESENT AND LOCKED?
	JRST @[SYMSEC,,DDTX]	;YES, GO TO IT
	TMSG <
? EDDT is not locked down - call LCKINI from MDDT first
>
	JRST LMDDT		;RETURN TO MDDT

	SWAPCD
	SUBTTL HSYS JSYS

;HALT SYSTEM - REQUIRES SC%MNT (OR SC%WHL ETC.) CAPABILITY
;ACCEPTS TIME OF SYSTEM SHUTDOWN AND INITIATES SHUTDOWN PROCESS,
;INCLUDING NOTIFYING USERS, ETC.  ALSO ACCEPTS TIME WHEN SYSTEM
;WILL BE BACK UP WHICH IS AVAILABLE FOR USER INFORMATION ONLY.
; 1/ SHUTDOWN TIME (GTAD FORMAT)
; 2/ EXPECTED UP TIME (GTAD FORMAT)
;	HSYS
; RETURNS +1: ERROR
; RETURNS +2: SUCCESS

.HSYS::	MCENT
	MOVE 2,CAPENB		;CHECK USER CAPABILITIES
	TXNN 2,SC%WHL+SC%OPR+SC%MNT ;USER ALLOWED TO DO HALT?
	RETERR(CAPX2)		;NO, RETURN BAD
	JUMPG 1,HSYS1		;JUMP UNLESS ABORTING SHUTDOWN
	MOVE T1,HSYST1		;GET OLD TIME
	JUMPE T1,HSYS0		;IF NONE, DONT TYPE MESSAGE
	SETZM HSYST1		;CLEAR OLD TIME
	CALL TADDIF		;GET MILLISECONDS TO SHUTDOWN
	HRROI T2,[ASCIZ/
[Shutdown canceled]
/]
	MOVX T3,SF%MS1
	TDNE T3,FACTSW		;WANT LEVEL 1 MESSAGES?
	SKIPGE HSYST3		;WAS A MESSAGE EVER PRINTED
	SKIPA
	CALL ALLMSG		;YES, INFORM USERS OF CANCELLATION
	CALL MSSSVD		;(/) ANY DISKS SERVED?
	IFSKP.
	   CALL CFCBRD		;(/) TELL OTHER SYSTEMS
	    NOP			;NO ONE ELSE OUT THERE
	ENDIF.
HSYS0:	SMRETN			;SUCCESSFUL RETURN

HSYS1:	PUSH P,1		;HOLD THE DESIRED SHUTDOWN
	CALL TADDIF		;COMPUTE MILLISECONDS TO SHUTDOWN
	TLNE 1,770000		;OVER A WEEK AHEAD, OR NEGATIVE?
	RETERR(TIMEX2)		;YES, GIVE BAD TIME FAILURE
	POP P,2			;RECOVER SHUTDOWN TIME
	MOVEM 2,HSYST1		;STORE FOR EXEC TO SEE
	SETOM HSYST3		;FLAG FOR FIRST MESSAGE
	UMOVE 2,2		;GET EXPECTED UP TIME
	CAMG 2,HSYST1		;CHECK RANGE
	SETZ 2,			;JUNK, ASSUME UNKNOWN
	MOVEM 2,HSYST4		;SAVE FOR EXEC TO TELL USERS
	AOS JB0FLG		;POKE JOB 0 TO DO MSG
	SMRETN

;COMPUTE TIME UNTIL SHUTDOWN IN MILLISECONDS
; A/ TAD OF SHUTDOWN
;	CALL TADDIF
; RETURN +1, A/ MILLISECONDS TO SHUTDOWN

TADDIF:	PUSH P,1
	CALL LGTAD		;GET CURRENT TIME AND DATE
	POP P,2
	SUBM 2,1		;GET POSITIVE DIFFERENCE OF TIMES
	CAML T1,[^D8,,0]	;WITHIN 8 DAYS?
	JRST [	MOVSI T1,377777	;NO, RETURN VERY LARGE NUMBER
		RET]
	MUL T1,[^D<24*3600*1000>]	;MILLISECONDS/DAY
	DIV T1,[1B17]		;SHIFT BINARY POINT
	RET

;HSYST1 AND HSYST4 ARE A GETAB TABLE

NHSYST==2			;NUMBER OF VALUES IN GETAB TABLE
NR HSYST1,1			;SYSTEM SHUTDOWN TIME OR 0
NR HSYST4,1			;EXPECTED UP TIME

NR HSYST2,1			;INTERVAL (IN MS) TO NEXT MSG TIME
NR HSYST3,1			;TIME OF NXT MSG IN MS BEFORE SHUTDOWN

;POINTS (IN MINUTES BEFORE SHUTDOWN) AT WHICH TO DO NOTIFICATION

CTIMS:	^D<BYTE (9) 60,30,15,10>
	^D<BYTE (9) 5,1,0>
	SUBTTL HSYS JSYS -- Job 0 Routine to Check System Shutdown

;ROUTINE TO TYPE SYSTEM SHUTDOWN MESSAGE IF NECESSARY.
;CALLED ONLY BY JOB 0 CHKR.

CHKHSY::SKIPE A,HSYST1		;[7.1200] Shutdown aborted?
	CAMN A,[-1]		;OR IS SYSTEM SHUTDOWN?
	RET			;YES
	CALL TADDIF		;COMPUTE TIME UNTIL SHUTDOWN
	MOVE 3,HSYST3		;DUE TIME FOR MESSAGE
	CAMN 3,[-1]		;FIRST TIME HERE?
	JRST CHKHS3		;YES - GIVE MESSAGE ANYWAY
	CAMLE 1,HSYST3		;NO - MESSAGE DUE NOW?
	JRST [	SUB 1,HSYST3	;NO, COMPUTE INTERVAL TO NEXT MSG
		MOVEM 1,HSYST2	;LEAVE IT FOR CHKR
		RET]		;RETURN QUIETLY
CHKHS3:	ADDI 1,^D30000		;ROUND TO NEAREST MINUTE
	IDIVI 1,^D60000		;CONVERT TO INTEGER MINUTES
	JUMPLE 1,CHKHS4		;IF NO TIME LEFT, GO KILL SYSTEM
	CALL THSYS		;SEND MSG TO ALL TTYS
	CAILE 1,^D60		;LESS THAN AN HOUR?
	JRST [	MOVEI 2,^D60	;NO - SET NEXT MESSAGE FOR 1 HOUR NOW
		CAILE 1,^D120	;BETWEEN 1 AND 2 HOURS
		MOVEI 2,^D120	;MAKE FIRST NOTICE BE AT 1 HOUR
		JRST CHKHS5]
	MOVE 3,[POINT 9,CTIMS]	;SETUP TO FIND NEXT NOTIFY TIME
	ILDB 2,3		;GET A TIME FROM LIST
	CAMG 1,2		;SHORTER THAN ACTUAL TIME REMAINING?
	JRST .-2		;NO, KEEP LOOKING
CHKHS5:	IMULI 2,^D60000		;CONVERT MINUTES TO MILLISECONDS
	MOVEM 2,HSYST3		;SET AS NEXT MESSAGE TIME
	JRST CHKHSY		;FINAL CHECK AND RETURN

;SHUTDOWN TIME HAS ARRIVED, COMMENCE SHUTDOWN.

CHKHS4:	MOVX T1,SF%RMT!SF%LCL!SF%PTY!SF%MCB!SF%NVT!SF%LAT ;[7479]
	ANDCAM T1,FACTSW	;ONLY ALLOW CTY TO LOGIN
	MOVX T1,SF%CTY		;MAKE SURE CTY CAN LOG IN
	IORM T1,FACTSW		;EVEN IF HE COULD NOT DO IT BEFORE
	CALL DWNMSG		;SEND LAST MESSAGE
	SETOM HSYST1		;CLEAR FLAGS IN CASE RESTARTED
	MOVE T1,CTYLNO		;SET UP CTY MESSAGE
	TXO T1,.TTDES
	HRROI T2,[ASCIZ/
	OPERATOR - Wait for the message "Shutdown complete" before
	entering commands to PARSER.
/]				;[7.1200] Sometimes this never happens
	SETZ T3,		;STOP ON ZERO BYTE
	SOUT			;SEND MESSAGE TO CTY
;...
;...
	CALL MSSSVD		;(/) ANY SERVED DISKS?
	IFSKP.
	   MOVE T1,CTYLNO	;YES, SET UP CTY MESSAGE
	   TXO T1,.TTDES
	   HRROI T2,[ASCIZ/
	Also, make sure other systems in the cluster have completed all
	necessary structure dismounts before this system is shutdown.

/]				;[7.1200] Structures will usually go offline
	   SETZ T3,
	   SOUT
	   CALL CFCBRD		;(/) TELL OTHER SYSTEMS
	    NOP			;NO ONE ELSE OUT THERE
	ENDIF.
	MOVSI T1,(1B1)		;CREATE FORK WITH SAME CAPS
	CFORK
	 BUG.(HLT,HSYFRK,JSYSM,SOFT,<HSYS - Job 0 CFORK failed>,,<

Cause:	This will occur if the CFORK JSYS fails to create a fork for
	shutting down the system.

	This failure will occur if the forks are totally used up, or if job
	0 has used the maximum number of forks permitted.  NUFKS contains this
	maximum number.
>)
	MOVE T2,[MSEC1,,HSYS4]	;SET IT TO START NEXT SHUTDOWN PHASE
	MSFRK			;START FORK IN MONITOR MODE
	RET
	SUBTTL HSYS JSYS -- Job 0 Fork to Shutdown System

;FORK STARTED AT SHUTDOWN TIME
;COMMENCE SHUTDOWN. PREVENT NEW JOBS, LOGOUT EXISTING JOBS, HALT.

HSYS4:	MOVX T1,USRCTX		;USER MODE FLAGS WORD
	MOVEM 1,FFL		;ESTABLISH USUAL JSYS CONTEXT
	SETZM FPC		;SET PC
	MCENTR
	MOVX T1,SF%RMT!SF%LCL!SF%PTY!SF%MCB!SF%NVT
	ANDCAM T1,FACTSW	;ONLY ALLOW CTY TO LOGIN
	MOVE 6,[XWD -NJOBS+1,1]	;START WITH JOB 1
	SKIPGE JOBRT(6)		;LOOK FOR EXISTING JOB
HSYS41:	AOBJN 6,.-1
	JUMPGE 6,HSYS7		;JUMP IF DONE
	HLRZ 1,JOBPT(6)		;CHECK CTRLTT FOR JOB
	CAMN 1,CTYLNO		;CTY?
	JRST HSYS41		;YES, DON'T FLUSH
	MOVEI 1,0(6)		;GET JOB NUMBER
	CALL LCL2GL		;CONVERT LOCAL JOB INDEX TO GLOBAL JOB #
	 JRST HSYS41		;NOT THERE?
	LGOUT			;LOG IT OUT
	 JFCL
	JRST HSYS41

HSYS7:	MOVEI 5,^D120000	;MAX TIME TO WAIT FOR JOBS TO FINISH
	ADD 5,TODCLK		;LOGGING OUT
HSYS8:	CAMG 5,TODCLK		;WAITED MAX TIME?
	JRST HSYS9		;YES, PROCEED WITH SHUTDOWN
	MOVE T2,HSYST4		;GET TIME BACK UP
	MOVEI T1,^D12		;SHOULD BE CODE FOR REASON FOR HALT
				;BUT FOR NOW, JUST SAY "SCHEDULED DOWN"
	CALL MNTHLT		;TELL THE NETWORK WE ARE GOING AWAY
	MOVE 6,[XWD -NJOBS+1,1]	;START WITH JOB 1
	SKIPGE JOBRT(6)		;SEE IF ANY JOBS STILL EXIST
HSYS81:	AOBJN 6,.-1
	JUMPGE 6,HSYS9		;NONE FOUND, PROCEED
	HLRZ 1,JOBPT(6)		;CHECK FOR CTY JOB
	CAMN 1,CTYLNO
	JRST HSYS81		;YES, IGNORE
	MOVEI 1,^D1000		;NO, WAIT 1 SEC., THEN CHECK AGAIN
	DISMS
	JRST HSYS8
	;...
	;...

HSYS9:	CALL PHYLOG		;LOG DISK, TAPE STATISTICS
	SETZM DDTIME		;POKE DDMP
	AOS JB0FLG
	MOVEI 5,^D10		;WAIT 10 SEC MAX FOR JOB 0
HSYS91:	MOVEI 1,^D1000		;WAIT 1 SEC
	DISMS
	SKIPN DDTIME		;DDMP FINISHED?
	SOJG 5,HSYS91		;NO, WAIT MORE
	JUMPLE 5,HSYS9		;IF TIMED OUT, TRY AGAIN
	SKIPE IOIP		;WRITES IN PROGRESS?
	JRST .-1		;YES, WAIT FOR COMPLETION
	MOVE T1,CTYLNO
	TXO T1,.TTDES		;MAKE VALID DESIGNATOR
	HRROI T2,[ASCIZ /
Shutdown complete
/]
	TTMSG			;NOTIFY OPERATOR
	 ERJMP .+1		;IN CASE OF REFUSALS
	MOVEI T1,^D15000
	DISMS
	HALTF
	SUBTTL HSYS JSYS -- Routine to Send Shutdown Message

;ROUTINE TO SEND GOING DOWN MESSAGE TO ALL LINES

THSYS:	STKVAR <TIM,<MSG,^D30>,CFBRD,CSBRD,CSTTY> ;[7.1086]
	SETZM CSBRD		;[7.1086] Assume no cluster sendall
	SETZM CFBRD		;ASSUME NO CLUSTER BROADCAST
	MOVEM T1,TIM		;SAVE NUMBER OF MINUTES
	HRROI T1,MSG		;INIT PTR TO MSG
	HRROI T2,[ASCIZ /
[System /]		;[7.1086]
	SETZ T3,
	SOUT
	 ERJMP .+1		;[7.1086] Not when SOUTing to memory
	HRROI T2,OURNAM		;[7.1086] Get our node name
	SOUT%			;[7.1086] Put node name in string
	 ERJMP .+1		;[7.1086] Shouldna happen
	HRROI T2,[ASCIZ / going down/] ;[7.1086] Finish header
	SOUT%			;[7.1086] Stick it in
	 ERJMP .+1		;[7.1086]
	MOVE T2,TIM		;GET TIME
	CAILE T2,^D60		;LESS THAN ONE HOUR?
	JRST THSYS1		;NO - SPECIAL MESSAGE
	CAIE T2,^D60		;[7.1086] Only send cluster messages at 60 min
	CAIN T2,^D5		;[7.1086] And at 5 min mark
	SETOM CSBRD		;[7.1086] Note that cluster send is to be done
	CAIN T2,^D1		;[7.1086] And at 1 minute
	SETOM CSBRD		;[7.1086] Mark cluster send
THSYS0:	SETOM CFBRD		;YES, NEED CLUSTER BROADCST
	HRROI T2,[ASCIZ / in /]
	SETZ T3,
	SOUT
	MOVE T2,TIM		;GET TIME
	CAIN T2,1		;THE 'ONE' CASE?
	JRST [	HRROI T2,[ASCIZ /one minute!!]
/]
		JRST HSYS51]	;SPECIAL MESSAGE
	MOVEI T3,^D10
	NOUT
	 JFCL
	HRROI T2,[ASCIZ / minutes/]
	SETZ T3,
	SOUT			;APPEND TO MESSAGE
	;...
	;...

THSYS1:	HRROI T2,[ASCIZ / at /]
	SETZ T3,0
	SOUT
	MOVE T2,HSYST1		;TELL ACTUAL TIME
	MOVEI T3,0
	ODTIM			;IN MESSAGE
	HRROI T2,[ASCIZ /]
/]
HSYS51:	SETZ T3,
	SOUT
	HRROI T2,MSG		;POINT TO CONSTRUCTED MSG
	MOVE T3,FACTSW
	MOVE T4,TIM
	SKIPL HSYST3		;THE FIRST TIME? OR...
	CAIG T4,5		;5 MIN OR LESS?
	CAIA			;YES, ALWAYS SEND
	TXNE T3,SF%MS1		;[7.1086] Want level 1 messages?
	IFNSK.			;[7.1086] If so,
	  SKIPN CSBRD		;[7.1086] Want to do cluster broadcast?
	  IFSKP.		;[7.1086] If so,
	    MOVX T1,<TT%REM+.CSALL+.TTTTY> ;[7.1086] All nodes, all lines
	    MOVEM T1,CSTTY	;[7.1086] Save destination
	    CALL SC.PRT 	;[7.1086] (/T1) Do we have a CI?
	     SETOM CSTTY	;[7.1086] If not, just send to all local TTYs
	    MOVE T1,CSTTY	;[7.1086] Restore destination
	    TTMSG%		;[7.1086] Here's the message
	     ERCAL MESFAL	;[7.1086] Say it failed, FE probably messed up
	  ELSE.			;[7.1086] If not cluster, then just do local
	    CALL ALLMSG		;[7.1086] (T2/) Send to all lines locally
	  ENDIF.		;[7.1086]
	ENDIF.			;[7.1086]
;...
;...
	SKIPN CFBRD		;CLUSTER BROADCAST?
	IFSKP.
	   CALL MSSSVD		;(/) YES, ANY DISKS SERVED?
	   ANSKP.
	      CALL CFCBRD	;(/) TELL OTHER SYSTEMS ABOUT OUR SHUTDOWN
	      ANSKP.
	         HRROI T1,MSG	;INFORM OUR OPERATORS
	         HRROI T2,[ASCIZ/

Check other cluster systems for structure dismount instructions.

/]				;[7.1200]
	         SETZ T3,
	         SOUT
	         MOVEI T2,MSG	;RETRIEVE MESSAGE ADDRESS
	         MOVEI T3,.QBSYS ;TYPE IS "SYSTEM MESSAGE"
	         CALL WROPR0	;(T1,T2,T3/) TELL OPERATORS
	ENDIF.
	MOVE T1,TIM		;RESTORE TIME
	RET

	ENDSV.
;ROUTINE TO SEND LAST MESSAGE, INCLUDING EXPECTED UPTIME.

DWNMSG:	STKVAR <<MSG,20>>
	HRROI T1,MSG
	HRROI T2,[ASCIZ /
[Timesharing is over/]
	SETZ T3,
	SOUT
	SKIPN HSYST4		;HAVE AN UPTIME?
	JRST DWNMS1		;NO
	HRROI T2,[ASCIZ /, up again at /]
	SOUT
	MOVE T2,HSYST4		;GET UPTIME
	MOVEI T3,0		;STANDARD FORMAT
	ODTIM			;CONVERT TIME TO TEXT
DWNMS1:	HRROI T2,[ASCIZ /]
/]
	SETZ T3,
	SOUT
	HRROI T2,MSG		;HAVE TEXT, NOW SEND IT TO ALL LINES
	CALL ALLMSG
	RET
	SUBTTL CHKAC JSYS

;THE CHKAC JSYS - CHECK THE ACCESSABILITY OF A FILE OR DIRECTORY

;ACCEPTS IN 1/	COUNT OF ARGUMENTS
;	    2/	LOCATION OF ARGUMENT BLOCK
;	CHKAC
;RETURNS +1:	ERROR - ERROR CODE IN AC 1
;	 +2:	AC 1 = 0	ACCESS NOT ALLOWED
;		AC 1 = -1	ACCESS IS ALLOWED

;ARGUMENT BLOCK:
;	.CKAAC	DESIRED ACCESS CODE
;	.CKALD	LOGGED IN USER NUMBER OF THE USER DOING THE ACCESSING
;	.CKACD	CONNECTED STRUCTURE,,DIRECTORY OR POINTER TO STRUCTURE/
;		DIRECTORY STRING
;	.CKAEC	ENABLED CAPABILITIES OF THE USER
;	.CKAUD	STRUCTURE,,DIRECTORY OR POINTER TO STRUCTURE/DIRECTORY STRING
;		FOR FILE BEING ACCESSED
;		IF CK%JFN IS SET IN AC1, THIS IS JFN FOR FILE
;	.CKAPR	PROTECTION OF FILE BEING ACCESSED

.CHKAC::MCENT			;ENTER JSYS
	STKVAR <<SVT3T4,2>>
	UMOVE Q1,2		;GET LOCATION OF ARGUMENT BLOCK
	XCTU [HRRZ T1,1]	;GET LENGTH OF ARGUMENT BLOCK
	XCTU [HLL Q1,1]		;GET THE FLAGS
	TXNN Q1,CK%JFN		;SPECIFIING A JFN?
	CAILE T1,.CKAPR		;NO, MUST INCLUDE PROTECTION
	CAIGE T1,.CKAPR		;YES, PROTECTION NOT NEEDED
	RETERR (CKAX1)		;LENGTH IS TOO SHORT
	XCTU [MOVE T1,.CKAEC(Q1)] ;LENGTH IS OK, GET CAPABILITIES
	TRNE T1,SC%WHL!SC%OPR	;IS THIS USER A WHEEL?
	JRST CHKACT		;YES, ACCESS IS LEGAL ALWAYS
	XCTU [HRRZ P1,.CKAAC(Q1)] ;GET ACCESS CODE
	UMOVE T1,.CKAUD(Q1)	;GET THE JFN OR DIRECTORY DESIGNATOR
	TXNE Q1,CK%JFN		;IS USER GIVING A JFN?
	JRST CHKAC2		;YES
	CALL CNVSTD		;CONVERT TO A DIRECTORY NUMBER
	 RETERR ()		;ILLEGAL FORMAT OF STRING
	MOVE P2,T1		;[7.1063]Save directory number in P2
	LDB T1,[POINT 6,T1,17]	;[7.1063]Get the structure number
	CALL CKSTOF		;[7.1063](T1/T1)Is the structure offline?
	 RETBAD ()		;[7.1063]Yes
	SKIPA			;[7.1063]Join common code
CHKAC2:	MOVE P2,T1		;[7.1063]Save JFN in P2
	UMOVE T1,.CKALD(Q1)	;GET THE LOGGED IN USER NUMBER
	LOAD T2,NMFLG,T1	;GET BITS 0-2
	CAIN T2,NUMVAL		;IS THIS A NUMBER?
	JRST CHKAC3		;YES, DONT NEED TO CONVERT THE STRING
	CALL CNVSTU		;CONVERT STRING TO USER NUMBER
	 RETERR ()		;FAILED

CHKAC3:	CALL CNVDIR		;CONVERT IT TO A DIR NUMBER
	MOVE P3,T1		;SAVE DIRECTORY # IN P3
	UMOVE T1,.CKACD(Q1)	;GET CONNECTED DIR # INTO P4
	CALL CNVSTD		;GET DIR NUMBER FROM STRING
	 SETZ T1,		;FAILED TO GET A DIRECTORY NUMBER
	MOVE P4,T1		;SAVE DIR NUMBER FOR LATER
	TXNN Q1,CK%JFN		;GIVING A JFN?
	XCTU [HRLZ P5,.CKAPR(Q1)] ;NO, GET PROTECTION
	TXNE Q1,CK%JFN		;USER GIVING A JFN?
	JRST [	HRRZ T1,P2	;YES, GET IT
		CALL GETFPD	;GET PROT AND DIR #
		 RETERR (CKAX4)	;BAD JFN
		MOVE P2,T1	;SAVE DIR #
		HRLZ P5,T2	;SAVE PROTECTION
		JRST .+1]
	MOVE T1,P2		;MAP IN DIRECTORY OF FILE
	CALL SETDIR		;FIRST CHECK LEGALITY OF DIR #
	 RETERR (CKAX2)		;ILLEGAL DIR #
	ULKDIR			;UNLOCK DIR, BUT STAY NOINT
	CAIL P1,.CKADR		;IS THIS A DIRECTORY ACCESS CHECK?
	JRST CHKDIR		;YES, GO SET UP DIR PROTECTION VALUE
	MOVEI T4,<DP%RD>B35	;MUST ALSO CHECK READ ACCESS TO DIR
CHKAC0:	MOVSI Q2,40		;SET UP MASK WORD
	MOVN T1,P1		;GET CODE
	LSH Q2,0(T1)		;FORM THE ACCESS CHECK MASK
	TDNE Q2,P5		;IS THIS MODE ALLOWED FOR WORLD?
	JRST [	MOVE T1,DIRORA	;YES, NOW SEE IF LEGAL TO REF DIR
		LOAD T1,DRPRT,(T1) ;GET DIRECTORY PROTECTION
		TDNE T4,T1	;LEGAL TO REFERENCE IT?
		JRST CHKACT	;YES, THIS IS LEGAL THEN
		JRST .+1]	;NO, GO SEE IF THIS IS OWNER OR GROUP
	HLLZ T1,P5		;MAKE OWNER SUPERSET OF GROUP
	LSH T1,6
	IORM T1,P5		;DONT ALLOW GROUP MORE PRIVS THAN OWNER
	LSH Q2,^D12		;NOW SEE IF LEGAL FOR OWNER
	LSH T4,^D12		;DO SAME FOR DIR PROTECTION MASK
	MOVE T3,DIRORA		;GET BASE ADR OF MAPPED DIR
	LOAD T3,DRPRT,(T3)	;GET DIR PROTECTION
	MOVE T2,T3
	LSH T2,6		;MAKE OWNER SUPERSET OF GROUP
	IORM T2,T3		;T3 = DIR PROTECTION
	TDNE T4,T3		;LEGAL ACCESS FOR OWNER IN DIRECTORY?
	TDNN Q2,P5		;YES, IS FILE ACCESS LEGAL?
	JRST CHKACF		;IF NOT LEGAL FOR OWNER, THEN FALSE

	CAME P3,P2		;IS THIS FILE IN SAME DIR AS USER?
	CAMN P4,P2		;EITHER LOGGED IN OR CONNECTED
	JRST CHKACT		;YES, RETURN TRUE
	DMOVEM T3,SVT3T4	;SAVE T3 AND T4
	SETZ P4,		;FLAG FOR DIFFERENT STRUCTURES
	HLRZ T1,P2		;GET STRUCTURE TO ACCESS
	HLRZ T2,P3		;GET LOGGED IN STRUCTURE UNIQUE CODE
	CAMN T1,T2		;ARE THEY THE SAME?
	JRST CHKAC4		;YES, FORGET DOMESTIC STR TEST
	HLRZ T1,P2		;GET STRUCTURE UNIQUE CODE
	CALL CNVSTR		;GET STRUCTURE NUMBER
	 RETERR ()		;COULDN'T FIND STRUCTURE
	MOVE T2,T1		;SAVE STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK STRUCTURE FROM CNVSTR
	MOVE T2,STRTAB(T2)	;GET STRUCTURE DATA BLOCK ADDRESS
	MOVE T1,SDBSTS(T1)	;GET STATUS OF STRUCTURE
	TXNN T1,MS%DOM		;IS IT DOMESTIC?
	JRST CHKACF		;NO, RETURN FALSE
	MOVEI T2,MAXLW+1	;GET SOME JSB FREE SPACE
	CALL ASGJFR		; IN WHICH TO STORE USER NAME
	 RETERR (SACTX2)	;INSUFFICIENT RESOURCES
	MOVE P4,T1		;STORE FREE SPACE BLOCK ADDRESS
	AOS T1			;DON'T STEP ON HEADER
	HRLI T1,-1		;MAKE IT A POINTER
	MOVE T2,P3		;GET LOGGED IN DIRECTORY
	HRLI T2,USRLH		;MAKE IT A USER NUMBER
	DIRST			;GET USER NAME
	 JRST [ MOVEI T1,JSBFRE	;RELEASE FREE SPACE
		MOVE T2,P4
		CALL RELFRE
		RETERR ()]
	MOVE T1,P4		;GET ADDRESS OF NAME
	HLRZ T2,P2		;GET STUCTURE UNIQUE CODE
	CALL DIRLKX		;DOES USER HAVE A DIRECTORY ON THIS STR?
	 JRST [ MOVEI T1,JSBFRE	;NO DIRECTORY ON THAT STRUCTURE
		MOVE T2,P4	;RELEASE FREE SPACE
		CALL RELFRE
		JRST CHKACF]	;RETURN FALSE
	MOVE T2,P4		;GET ADDRESS OF JSB SPACE
	MOVE P4,T1		;STORE DIRECTORY NUMBER
	MOVEI T1,JSBFRE
	CALL RELFRE		;RETURN JSB SPACE
	HLL P4,P2		;ADD STR UNIQUE CODE TO DIR NUMBER
	CAMN P2,P4		;TRYING TO ACCESS OUR OWN DIRECTORY?
	JRST CHKACT		;YES, RETURN SUCCESS
	MOVE T1,P2		;MAP IN DESIRED DIRECTORY AGAIN
	CALL SETDIR
	 RETERR ()
	ULKDIR			;UNLOCK DIRECTORY

CHKAC4:	DMOVE T3,SVT3T4		;RESTORE T3 AND T4
	LSH Q2,-6		;NO, NOW SEE IF THIS IS SAME GROUP
	LSH T4,-6		;SAME FOR GROUP
	TDNE T4,T3		;LEGAL ACCESS TO DIR BY GROUPS?
	TDNN Q2,P5		;YES, LEGAL FOR GROUP?
	JRST CHKACF		;NO, RETURN FALSE
	CALL CPYDGP		;COPY DIR GROUPS INTO JSB
	 JRST CHKACF		;NO GROUPS
	MOVE P6,T1		;SAVE THE JSB POINTER
	SKIPN T1,P4		;TRYING TO ACCESS DIR ON PRIMARY STRUCTURE?
	MOVE T1,P3		;YES, GET LOGGED IN DIRECTORY
	CALL SETDIR		;GET INFO ABOUT THIS USER
	 RETERR (CKAX2)		;ILLEGAL DIRECTORY NUMBER
	ULKDIR			;UNLOCK THE DIRECTORY LOCK FROM GETDDB
	MOVE Q1,P6		;GET AOBJN POINTER TO DIR GROUP LIST
CHKAC1:	HLRZ T1,0(Q1)		;GET FIRST MEMBER OF GROUP
	CALL CHKUGP		;CHECK IT AGAINST USER GROUPS
	 SKIPA			;NO MATCH
	JRST [	MOVE A,P6	;MATCH FOUND
		CALL RELGRP	;RELEASE THE SPACE IN THE JSB
		JRST CHKACT]	;RETURN TRUE
	HRRZ T1,0(Q1)		;GET NEXT MEMBER OF GROUP
	CALL CHKUGP		;CHECK FOR MATCH
	 SKIPA			;NO MATCH
	JRST [	MOVE A,P6	;MATCHED!
		CALL RELGRP	;RELEASE THE JSB SPACE
		JRST CHKACT]	;RETURN TRUE
	AOBJN Q1,CHKAC1		;LOOP UNTIL LIST IS FINISHED
	MOVE A,P6		;RELEASE THE SPACE IN JSB
	CALL RELGRP

CHKACF:	TDZA T1,T1		;RETURN FALSE
CHKACT:	SETO T1,		;TRUE
	UMOVEM T1,1		;STORE ANSWER
	SMRETN			;AND RETURN

CHKDIR:	CAIL P1,.CKADR		;IS THIS A LEGAL FUNCTION CODE
	CAILE P1,.CKACF
	RETERR (CKAX3)		;NO, ILLEGAL ACCESS CODE
	SUBI P1,.CKADR		;SET UP FOR MASK BUILDING
	MOVE T4,DIRORA		;GET BASE OF DIR AREA
	LOAD T4,DRPRT,(T4)	;GET DIR PROTECTION
	HRL P5,T4		;ONLY WANT 18 BITS
	MOVEI T4,77		;DONT CARE ABOUT DIR PROTECTION CHECK
	JRST CHKAC0		;GO FINISH JSYS

;ROUTINE TO COPY A LIST OF GROUPS TO THE JSB
;	CALL CPYDGP	OR	CALL CPYUGP
;RETURNS +1:	NO GROUPS
;	 +2:	AOBJN POINTER TO LIST IN JSB RETURNED IN T1

CPYDGP::EA.ENT			;ENTER SEC 1
	MOVE D,DIRORA		;GET BASE OF DIR AREA
	LOAD D,DRDGP,(D)	;GET DIR GROUP LIST
	JRST CPYUG0		;ENTER COMMON CODE

CPYUGP::EA.ENT			;ENTER SEC 1
	MOVE D,DIRORA		;GET BASE OF DIR AREA
	LOAD D,DRUGP,(D)	;GET USER GROUP LIST
CPYUG0:	JUMPE D,R		;IF 0, NO LIST
	STKVAR <CPYUGA>
	ADD D,DIRORA		;GET ABS ADR OF LIST
	LOAD C,BLKTYP,(D)	;GET TYPE OF THIS BLOCK
	CAIE C,.TYGDB		;MUST BE A DIRECTORY GROUP BLOCK
	RET			;DIR IS SCREWED UP
	LOAD B,BLKLEN,(D)	;GET LENGTH OF BLOCK
	SOS B			;SKIP OVER HEADER
	MOVEM D,CPYUGA		;SAVE ADR OF LIST
	CALL ASGJFR		;GET A BLOCK FROM JSB
	 RET			;NO ROOM
	MOVE D,CPYUGA		;GET BACK ADR OF LIST
	HRRZ B,0(A)		;GET LENGTH OF DIR LIST
	MOVNS B			;SET UP AN AOBJN POINTER TO JSB
	HRL A,B
	MOVE C,A		;LEAVE POINTER IN A
CPYUGL:	MOVE B,1(D)		;GET NEXT ELEMENT IN LIST
	MOVEM B,0(C)		;STORE IN JSB
	AOS D			;STEP TO NEXT ELEMENT IN LIST
	AOBJN C,CPYUGL		;LOOP TIL LIST IS COPIED
	RETSKP			;RETURN SUCCESSFUL WITH POINTER IN A


;ROUTINE TO RELEASE A GROUP LIST FROM JSB
;ACCEPTS IN A/	POINTER TO LIST
;	CALL RELGRP
;RETURNS +1:	ALWAYS

RELGRP::HLRE B,A		;GET LENGTH OF BLOCK
	HRRZS	A		;INSURE IN THIS SECTION
	MOVNM B,(A)		;STORE LENGTH IN BLOCK
	HRRZ B,A		;GET ADR OF BLOCK
	MOVEI A,JSBFRE
	CALLRET RELFRE		;RELEASE THE BLOCK

	SUBTTL GJINF JSYS

	XSWAPCD			;[7.1200]

.GJINF::MCENT
	CALLX (MSEC1,GTCSCD)	;[7.1200] (/T1) Get connected str code,,dir
	MOVE T2,T1		;RETURN CONNECTED STR/DIR NUMBER
	MOVE T3,JOBNO
	HRRZ T1,JOBDIR(T3)
	SKIPE T1		;IF NOT LOGGED IN, RETURN 0
	HRLI T1,USRLH		;TURN THIS INTO A 36 BIT USER NUMBER
	MOVE T4,CTRLTT
	MOVE T3,GBLJNO		;RETURN GLOBAL JOB NUMBER FOR OURSELF

;[7.1200] Note to users of MR1-MR4: this code is now XSWAPCD!

MR4:	UMOVEM T4,T4		;[7.1200] Return 1, 2, 3, 4 to user
MR3:	UMOVEM T3,T3		;[7.1200] Return 1, 2, 3 to user
MR2:	UMOVEM T2,T2		;[7.1200] Return 1 and 2 to user
MR1:	UMOVEM T1,T1		;[7.1200] Return 1 to user
	JRST MRETN
	SUBTTL TIME/RUNTM JSYSes

	XSWAPCD			;[7.1200]

;[7.1200] Return system uptime
;Returns with
;	1/ time in milliseconds
;	2/ ^D1000 (divisor for convertion to seconds)

.TIME::	MCENT
	MOVE 1,TODCLK		;TIME SINCE SYSTEM STARTED
	MOVEI 2,^D1000		;DIVISOR FOR SECONDS
	JRST MR2		;RETURN 2 AC'S

;[7.1200] Return runtime of fork or job
;Call with 1/ process handle
;Returns with
;	1/ runtime in milliseconds
;	2/ ^D1000 (divisor)
;	3/ console time in milliseconds

.RUNTM::MCENT
	NOSKED
	CALLX (MSEC1,UCLOCK)	;[7.1200] (/) Update clocks
	OKSKED
	CALLX (MSEC1,FLOCK)	;[7.1200] (/) Lock the fork structure
	XCTU [HRRZ 1,1]		;FORK HANDLE
	CAIN 1,-5		;WHOLE JOB?
	JRST RUNTM1		;YES
	CALLX (MSEC1,SETJFK)	;[7.1200] (T1/T1) Get fork handle to JRFN
	CALLX (MSEC1,SETLF1)	;[7.1200] (T1/T1) Map PSB of fork, offset in T1
	MOVE 1,FKRT(1)		;FORK RUN TIME FROM PSB
	JRST RUNTM2

RUNTM1:	NOINT
	MOVE 1,JOBNO
	MOVE 1,JOBRT(1)
RUNTM2:	MOVE 3,TODCLK		;CURRENT TIME
	SUB 3,CONSTO		;LESS TIME ON, FOR CONSOLE TIME USED
	MOVEI 2,^D1000		;MILLISECONDS
RETA3:	UMOVEM 1,1		;RETURN VALUES IN 1,2,3
	UMOVEM 2,2
	UMOVEM 3,3
	XJRST [MSEC1,,CLFRET]	;[7.1200] Clear mapped fork stuff and return
	SUBTTL GTRPI JSYS

;[7.1200] Return paging trap information
;Call with 1/ process handle
;Returns +1 with
;	1/ number pager traps since process started
;	2/ number of page faults since process started
;	3/ time in milliseconds spend in page routines since process started

.GTRPI::MCENT
	CALLX (MSEC1,FLOCK)	;[7.1200] (/) Lock the fork structure
	CALLX (MSEC1,SETLFK)	;[7.1200] (T1/T1) Get the fork mapped
	MOVE 2,USWPCT(1)
	MOVE 3,PTTIM(1)
	IDIVI 3,^D100		;RETURN MILLISEC, NOT HPTIM UNITS
	MOVE 1,UTRPCT(1)
	JRST RETA3
	SUBTTL GTDAL JSYS

	XSWAPCD			;[7.1200] 

;GET DIRECTORY ALLOCATION
;ACCEPTS IN 1/	DIR # OR -1 FOR CONNECTED DIR
;	GTDAL
;RETURNS +1:	1/	LOGGED IN QUOTA
;		2/	CURRENT ALLOCATION
;		3/	LOGGED OUT QUOTA

.GTDAL::MCENT
	UMOVE T1,1		;GET DIR #
	CAMN T1,[-1]		;[7.1063]-1 MEANS CONNECTED DIRECTORY
	CALLX (MSEC1,GTCSCD)	;[7.1200] (/T1) Get connected str code,,dir
	CALL <XENT IGTDAL>	;[7.1200] Use internal routine
	 ITERR()		;FAILED
	JRST MR3		;RETURN 1, 2 AND 3

;[7.***] Internal GTDAL.
;Call with T1/ directory
;Returns +1 if failed, 1/ error
;Returns +2 if ok
;	1/ working storage limit
;	2/ current allocation
;	3/ permanent storage limit

XNENT	(IGTDAL,G)		;[7.1200] IGTDAL:: and XIGTDA::
	STKVAR <IGTDN>		;[7.1200] Place to store str code,,directory
	MOVEM T1,IGTDN		;SAVE DIR #
	LDB T1,[POINT 6,T1,17]	;[7.1063]Get structure number
	CALLX (MSEC1,CKSTOF)	;[7.1200][7.1063](T1/T1) Structure offline?
	 RETBAD ()		;[7.1063]Return "Structure is offline"
	MOVE T1,IGTDN		;[7.1063]Restore T1
	CALLX (MSEC1,SETDIR)	;[7.1200] (T1/) Map the directory in, go NOINT
	 RETBAD ()		;FAILED
	HRRZ T1,IGTDN		;DIRECTORY NUMBER
	LOAD T2,CURSTR		;STRUCTURE NUMBER
	CALLX (MSEC1,GETCAL)	;[7.1200] (T1,T2/T1) Get allocated pages
	 JRST [	MOVE T3,DIRORA	;DIR NOT OPENED
		LOAD T1,DRLIQ,(T3) ;LOGGED IN QUOTA
		LOAD T2,DRDCA,(T3) ;CURRENT ALLOCATION
		LOAD T3,DRLOQ,(T3) ;LOGGED OUT QUOTA
		JRST IGTDX]	;EXIT
	MOVE T3,DIRORA		;GET BASE ADR OF MAPPED DIR
	MOVN T2,T1		;NEGATE PAGES LEFT
	LOAD T1,DRLIQ,(T3)	;GET LOGGED IN QUOTA
	ADD T2,T1		;ACTUAL USED
	LOAD T3,DRLOQ,(T3)	;GET LOGGED OUT QUOTA
IGTDX:	CALLX (MSEC1,USTDIR)	;[7.1200] Unlock the directory, go OKINT
	RETSKP			;GOOD RETURN
	SUBTTL HPTIM JSYS

;HIGH PRECISION TIME JSYS
;MADE RESIDENT FOR SPEED

	RESCD

.HPTIM::MCENT
	CAIL 1,0		;CHECK RANGE OF ARG
	CAIL 1,NHPTIM
	RETERR(HPTX1)		;UNDEFINED CLOCK
	JRST HPTTAB(1)

HPTTAB:	JRST HPT0		;ELAPSED TIME
	JRST HPT1		;FORK RUNTIME
NHPTIM==.-HPTTAB

HPT0:	NOSKED
	JSP 4,MTIME		;READ TODCLK IN 1E-5 SECOND UNITS
	OKSKED
	UMOVEM 1,1
	SMRETN

HPT1:	NOSKED
	CALL UCLOCK		;UPDATE USER RUNTIMES
	OKSKED
	MOVE 1,FKRT		;GET MILLISECOND PART
	IMULI 1,NTMS		;CONVERT TO HP UNITS
	ADD 1,RUNT2		;INCLUDE FRACTION OF MILLISECOND
	UMOVEM 1,1
	SMRETN

	SUBTTL SYSGT JSYS

	XSWAPCD			;[7.1200] 

;GET NUMBER OF TABLE AND FIRST WORD GIVEN SIXBIT SYMBOL
; 1/ SIXBIT 'TABLENAME'
;	SYSGT
; RETURN +1 ALWAYS,
;  1/ -LENGTH,,TABLENUMBER  OR 0

.SYSGT::MCENT
	MOVSI 4,-GTBSIZ
	CAMN 1,SYMTAB(4)
	JRST SYSGT1
	AOBJN 4,.-2
	XCTU [SETZM 2]		;NOT FOUND RETURN 0
	JRST MRETN

SYSGT1:	HLRZ 2,GTTSZ(4)		;SIZE
	MOVN 2,2		;NEGATE IT
	HRLI 4,0(2)		;COMBINE WITH TABLE NUMBER
	UMOVEM 4,2		;GIVE TO USER
	HRRZ T3,T4		;GET TABLE NUMBER
	SETZ T2,		;GET OFFSET ZERO
	XCT GTGET(T3)		;GO GET THE FIRST ENTRY
	JRST MR1		;[7.1200] Return AC1 to user and MRETN
	SUBTTL GETAB JSYS

	XSWAPCD			;[7.1200] 

;GET TABLE ENTRY
; 1/ INDEX,,TABLENUMBER
;	GETAB
; RETURN +1: ERROR
; RETURN +2: 1/ DATA

.GETAB::MCENT
	MOVSI 2,(1B1)
	TDNN 2,CAPMSK		;GETAB CAPABILITY EXISTS?
	RETERR(GTABX3)		;NO
	HLRZ 2,1		;INDEX OR -1
	MOVEI 3,0(1)		;TABLE NUMBER
	CAIL 3,GTBSIZ		;LEGAL NUMBER?
	RETERR(GTABX1)		;NO
	HLRZ 1,GTTSZ(3)		;GET SIZE OF TABLE
	CAIN 2,-1		;INDEX OF -1?
	JRST RETN1		;YES, RETURN NEG OF TABLE SIZE
	CAIL 2,0(1)		;INDEX WITHIN BOUNDS?
	RETERR(GTABX2)
	XCT GTGET(T3)		;GET WORD
	UMOVEM 1,1		;RETURN IT TO USER
	SMRETN

RETN1:	XCTU [MOVNM 1,1]	;RETURN NEG OF LENGTH
	SMRETN

;[7.1200]
;                              Tables for GETAB

;All tables defined with following macro which takes name of another macro to
;call for each table. Table indices are defined in MONSYM, order and place must
;be preserved if tables are added or deleted.  Place may be held by call with
;no args.

;The argument to GTABS is a macro to be called for each table.  Five arguments
;for each XXX entry in GTABS are given: SIXBIT table name, monitor location,
;length, routine to call to get information, symbolic value for table number
;(from MONSYM).

;Note that the job tables are accessed by job index, which must be translated
;from the user-specified global job number by calling GL2LCL in CFSSRV.
;Therefore, the 'length' or maximum legal value for a user-specified global job
;number is the highest legal global job number, MXGLBS, and not the maximum
;local job index, NJOBS.

;Four tables are defined starting on the next page.
;	SYMTAB holds the SIXBIT name of the table for SYSGT.
;	GTTAB is a table of the addresses of the beginning of the GETAB table.
;	GTTSZ is the "size,,0" of each defined table.
;	GTGET is a table that is XCTed to get the data retrieved, 
;	 routine is called with the table index in T2, table number in T3, 
;	 and the code should return the information in T1.  This routine 
;	 must be in XCDSEC or you should specify "<@[MSEC1,,routine]>".

DEFINE GTABS (XXX)<
	XXX JOBTTY,JOBPT,MXGLBS,GTJOB
	XXX JOBRT,JOBRT,MXGLBS,GTJOB
	XXX TICKPS,[^D1000],1
	XXX				;;FORMERLY JOBDIR
	XXX TTYJOB,0,NLINES,TTY2GL
	XXX NCPGS,TOTRC,1
	XXX DEVNAM,DEVNAM,NDEV
	XXX DEVCHR,DEVCHR,NDEV
	XXX DEVUNT,DEVUNT,NDEV,UNT2GL
	XXX			;;[7.1117] Formerly DSKERR,DSKRCE,NDSKEW
	XXX			;;[7.1117] Formerly DRMERR,DRMCFE,NDRMEW
	XXX SYSVER,SVN,NSVNT
	XXX SYSTAT,SKDTM0,NSTAT
	XXX QTIMES,QSUM,NQUEUE
	XXX JOBNAM,JOBNAM,MXGLBS,GTJOB
	XXX SNAMES,SNAMES,NNAMES
	XXX STIMES,STIMES,NNAMES
	XXX SPFLTS,SPFLTS,NNAMES
	XXX SSIZE,SSIZE,NNAMES
	XXX SNBLKS,SNBLKS,NNAMES
	XXX DBUGSW,DBUGSW,2
	XXX LOGDES,LOGDES,2
	XXX PTYPAR,0,1,<@[MSEC1,,GTBPTY]> ;;[7.1200] 
	XXX SYMTAB,SYMTAB,GTBSIZ
	XXX DWNTIM,HSYST1,NHSYST
	XXX JOBPNM,JOBPNM,MXGLBS,GTJOB
	XXX BLDTD,SYSTAD,1
	XXX				;;FORMERLY LSTDRN
	XXX APRID,APRSER,1
	XXX HQLAV,HQLAV,NRJAVS
	XXX LQLAV,LQLAV,NRJAVS
	XXX NETRDY,0,10,<@[MSEC1,,GNTRDY]> 	;;[7.1200] 
	XXX 				;;FORMERLY IMPHRT
	XXX 				;;FORMERLY HSTSTS
	XXX 				;;FORMERLY HSTNAM
	XXX 				;;FORMERLY HOSTN
	XXX 				;;FORMERLY NETLSK
	XXX 				;;FORMERLY GNTFSK
	XXX 				;;FORMERLY NETAWD
	XXX 				;;FORMERLY NETBAL
	XXX 				;;FORMERLY NETSTS
	XXX 				;;FORMERLY NETBUF
	XXX 				;;FORMERLY NETBTC
	XXX 				;;FORMERLY IMPLT1
	XXX 				;;FORMERLY IMPLT2
	XXX 				;;FORMERLY IMPLT3
	XXX 				;;FORMERLY IMPLT4
	XXX LHOSTN,NOHOST,2		;;ARPA HOST NUMBER, NVT COUNTER
	XXX JBONT,JOBONT,MXGLBS,GTJOB	;;OWNING JOB
	XXX NSWPGS,NSWPGS,1		;;DEFAULT SWAPPING PAGES
	XXX SCOUNT,SCOUNT,NNAMES	;;COUNT OF SETSN'S S FOR SUBSYSTEM
	XXX MONVER,137,1		;;MONITOR VERSION NUMBER
	XXX CISTAT,CIPKSN,NCSTAT	;;[7211] CI STATISTICS
   >

;ASSEMBLE SYMBOL TABLE

DEFINE SYMT (NAM,LOC,SIZ,ROUT,VALUE)<
   IFB <NAM>,<0>		;;LEAVE 0 IF PLACE RESERVED
   IFNB <NAM>,<
      IFB <VALUE>,<		;;IF VALUE WAS NOT SPECIFIED
	..X==.'NAM		;;GET NAME FROM MONSYM
.'NAM::!SIXBIT /NAM/>		;;CHECK TABLE INDEX, ASSEMBLE SIXBIT
      IFNB <VALUE>,<		;;IF VALUE WAS SPECIFIED
	..X==VALUE		;;GET NAME FROM MONSYM
VALUE::!SIXBIT /NAM/>>>		;;CHECK TABLE INDEX, ASSEMBLE SIXBIT

SYMTAB::!PHASE 0			;;MAKE TAGS BE RELATIVE TO 0
	GTABS SYMT		;;ASSEMBLE SYMTAB, CHECK INDEX MNEMONICS
GTBSIZ::DEPHASE

;ASSEMBLE POINTERS AND SIZES

DEFINE LOCT (NAM,LOC,SIZ,ROUT,VALUE)<
   IFB <NAM>,<0>		;;LEAVE 0 IF PLACE RESERVED
   IFNB <NAM>,<
	EXP LOC>>		;;30-BIT ADDRESS HERE

GTTAB::	GTABS LOCT

DEFINE SIZT (NAM,LOC,SIZ,ROUT,VALUE)<
   IFB <NAM>,<0>		;;LEAVE 0 IF PLACE RESERVED
   IFNB <NAM>,<
	XWD SIZ,0>>

GTTSZ::	GTABS SIZT

;DEFINE PROCESSING ROUTINE

DEFINE ACTR (NAM,LOC,SIZ,ROUT,VALUE)<
   IFB <NAM>, <SETZM T1>	;;NULL TABLE GIVES NULL ANSWER
   IFNB <NAM>,< IFB <ROUT>, <CALL GTGETR> ;;DFAULT PROCESSOR
   IFNB <ROUT>, <CALL ROUT> 	;;DO SPECIFIED PROCESS
        >
   >

GTGET:	GTABS ACTR		;DEFINE PROCESSING TABLES


;GETAB Job table access routine, used to translate user-specified Global job
;number into local job table index before looking up requested data in GTGETR
;below.
;[7.1200] Call with T2/ global Job number, T3/ table number

GTJOB:	MOVE T1,T2		;PUT JOB NUMBER WHERE IT'S EXPECTED
	CALLX (MSEC1,GL2LCL)	;[7.1200] (T1/T1) Translate it to local job
	 JRST RETO		;[7.1200] Return -1 as documented
	MOVE T2,T1		;PUT JOB INDEX WHERE IT'S EXPECTED
				;[7.1200] Fall through to GTGETR

;GENERAL GETTAB ROUTINE.
;	3/ TABLE NUMBER
;	2/ TABLE OFFSET
;RETURNS: +1 WITH T1/ ANSWER

GTGETR:	ADD T2,GTTAB(T3)	;GET TABLE BASE
	MOVE T1,0(T2)		;FETCH TABLE ENTRY
	RET			;AND DONE

;GET THE GLOBAL JOB NUMBER FOR JOB CONTROLLING TTY NUMBER GIVEN
;	RETURNS +1, ALWAYS, WITH
;	T2/ GLOBAL JOB NUMBER,,WAITING FORK
;		OR
;	T1/ -1		(NO CONTROLLING JOB)
;		OR
;	T1/ -2,,-1	(NOT INITIALIZED YET)

TTY2GL:	CALLX (MSEC1,GTBTTF)	;[7.1200] (T2/T1) Call TTYSRV to get job index
	JUMPL T1,R		;[7.1200] Return now if not there (yet)
	MOVE T2,T1		;SAVE REQUESTED DATA
	HLRZ T1,T1		;GET JOB NUMBER FROM LH
	CALLX (MSEC1,LCL2GL)	;[7.1200] (T1/T1) Convert to global job number
	 SETOM T1		;JOB HAS NO GLOBAL JOB NUMBER YET.
	MOVSI T1,(T1)		;PUT GLOBAL JOB # IN LH
	HRR T1,T2		;GET WAITING FORK INDEX BACK.
	RET			;AND THAT'S IT.

;GET THE GLOBAL JOB NUMBER OF THE OWNER OF A DEVICE AND RETURN IT ALONG
;WITH THE DEVICE'S UNIT NUMBER (FROM DEVUNT)
; RETURNS +1 ALWAYS WITH
;	T1/	GLOBAL JOB NUMBER (OR -1 OR -2),,DEVICE UNIT NUMBER

UNT2GL:	SKIPG T3,DEVUNT(T2)	;JOB NUMBER IN LH?
	IFSKP.			;IF YES, MUST TRANSLATE
	  HLRZ T1,T3		;GET THE LOCAL INDEX
	  CALLX (MSEC1,LCL2GL)	;[7.1200] (T1/T1) Get the global job number
	   SETO T1,		;SHOULDN'T HAPPEN, RETURN -1
	  HRL T3,T1		;CONSTRUCT NEW DEVUNT FOR USER
	ENDIF.
	MOVE T1,T3		;PUT IT WHERE USER EXPECTS IT
	RET			;DONE
	SUBTTL SETSN JSYS

	XSWAPCD			;[7.1200] 

;SUBSYSTEM STATISTICS LOGIC
; 1/ SIXBIT NAME OF SYSTEM PROGRAM BEING RUN OR (PRIV)
; 2/ SIXBIT NAME OF PROGRAM
;	SETSN
; RETURN +1: ALWAYS, NAME SET IN STATISTICS TABLE

.SETSN::MCENT
	NOINT
	MOVE 3,JOBNO
	MOVEM 2,JOBPNM(3)	;SET JOB PROGRAM NAME
	AOSE SNMLCK		;LOCK TABLE
	CBLK1			;OR WAIT TILL LOCKABLE
	MOVM T3,SNMPT		;COUNT OF ENTRIES NOW
      DO.
	SOJL T3,ENDLP.		;SCAN BACKWARDS, JUMP IF DONE
	CAMN 1,@[EP. SNAMES(3)]	;DESIRED NAME?
	JRST SNM1		;YES
	JRST TOP.
      ENDDO.
	MOVM T3,SNMPT		;[7.1200] Name not found, get entries in table
	CAIL T3,NNAMES-1	;[7.1200] Table is now full?
	IFSKP.			;[7.1200] Nope, new name found
	  SETZM @[EP. SCOUNT(3)] ;[7.1200] Zero the count for new name
	  SOS SNMPT		;[7.1200] Update count
	ELSE.			;[7.1200] Otherwise table is full
	  MOVE T1,[SIXBIT /.OTHER/] ;[7.1200] Use catch all name
	ENDIF.			;[7.1200] 
	MOVEM 1,@[EP. SNAMES(3)] ;ADD NAME TO TABLE
SNM1:	MOVE 2,JOBNO
	HRRM 3,JOBNAM(2)	;PUT INDEX IN JOB TABLE
	AOS @[EP. SCOUNT(3)]	;BUMP THE SETSN COUNT
	SETOM SNMLCK		;[7.1200] Unlock table
	OKINT
	SMRETN

NR SNMPT,1			;NEG COUNT OF ENTRIES IN SNAMES
NR SNMLCK,1			;LOCK FOR SNAMES TABLE
	SUBTTL SETNM/GETNM JSYSes

	XSWAPCD			;[7.1200] 

;PROGRAM NAME LOGIC

;SET NAME
; 1/ SIXBIT NAME OF PROGRAM
;	SETNM
; RETURN +1: ALWAYS, NAME SET AS PROGRAM NAME FOR JOB

.SETNM::MCENT
	MOVE 3,JOBNO		;GET THIS JOB NUMBER
	MOVEM 1,JOBPNM(3)	;SET THE NAME
	JRST MRETN

;GET NAME
;	GETNM
; RETURN +1: ALWAYS, 1/ SIXBIT NAME OF PROGRAM

.GETNM::MCENT
	MOVE 1,JOBNO
	MOVE 1,JOBPNM(1)
	JRST MR1		;RETURN 1 AC
	SUBTTL GETJI JSYS

	XSWAPCD			;[7.1200]

;GET JOB INFORMATION
; 1/ JOB #, OR -1 FOR SELF, OR TTY # + 400000
; 2/ -N,,USER ADR
; 3/ FIRST ENTRY DESIRED
;	GETJI
; RETURN +1: FAILURE
; RETURN +2: SUCCESS, ENTRIES STORED IN USER ARRAY
;REQUIRES GETAB CAPABILITY IF JOB OTHER THAN SELF

.GETJI::MCENT
	UMOVE P2,3		;GET NUMBER OF FIRST ENTRY DESIRED
	HRL P2,P2		;DUPLICATE IN BOTH HAVLES
	JUMPL P2,[RETERR (GTJIX1)] ;INSURE NOT NEGATIVE
	ADD P2,[-NGTJIT,,0]	;SETUP AOBJN PTR TO FIRST ENTRY
	JUMPGE P2,[RETERR (GTJIX1)] ;ALREADY BEYOND END OF TABLE
	UMOVE P3,2		;GET USER 'S ADR POINTER
	CAME T1,[-1]		;[7.1200] Self?
	IFSKP.			;[7.1200] Yes, -1 was specified
	  MOVE T1,JOBNO		;[7.1200] So get our own index
	  JRST GETJI5		;[7.1200] and skip capability check
	ENDIF.			;
	MOVX T2,SC%GTB
	TDNN T2,CAPMSK		;HAS GETAB CAPABILITY?
	RETERR (GTABX3)		;NO
	TRZN T1,400000		;[7.1200] TTY designator?
	IFSKP.			;[7.1200] Yes, TTY was specified
	  CAIL T1,0		;YES, LEGAL LINE NUMBER	?
	  CAIL T1,NLINES
	   RETERR (GTJIX2)	;NO
	  MOVE T2,T1		;T2/ LINE NUMBER
	  CALLX (MSEC1,GTCJOB)	;[7.1200] (T2/T3) Get owning job number
  	   JRST GETJI6		;[7.1200] Jump if not active
	  CAIN T3,-1		;IS THERE AN OWNING JOB?
	  JRST GETJI6		;NO.
	  MOVE T2,T3		;YES. PRESERVE JOB NUMBER
	  HLRZ T3,JOBPT(T2) 	;GET CONTROLLING TTY FOR JOB
	  CAME T3,T1		;SAME AS GIVEN TTY?
	  JRST GETJI1		;NO, TTY IS ASSIGNED NOT CONTROLLING
	  MOVE T1,T2		;SETUP JOB INDEX
	ELSE.			;OTHERWISE, USER SPECIFIED A JOB NUMBER
	  CALLX (MSEC1,GL2LCL)	;[7.1200] (T1/T1) Convert it into a local job
	   RETERR()		;CFSSRV WILL RETURN THE RIGHT STUFF
	ENDIF.			;FALL THROUGH

; T1/ Local index of job requested

GETJI5:	NOSKED			;DON'T ALLOW JOB TO LOG OUT
	SKIPGE JOBRT(T1)	;JOB EXISTS?
	RETERR (GTJIX4,<OKSKED>) ;NO. GIVE APPROPRIATE ERROR
	MOVEM 1,P1		;SAVE JOB NUMBER
	CALLX (MSEC1,SETJSB)	;[7.1200] (T1/T1) Map in JSB of object job
	OKSKED			;OK TO ALLOW SCHEDULING. JOB CAN'T LOGOUT
				; SINCE ITS JSB IS MAPPED
	MOVEM T1,P4		;SAVE JSB OFFSET
GETJI2:	XCT GETJIT(P2)		;GET ITEM
	 UMOVEM 1,0(P3)		;GIVE IT TO USER (ROUTINES THAT SKIP HAVE ALREADY DONE THIS)
	AOBJP P3,GETJI3		;COUNT USER'S COUNT AND ADR
	AOBJN P2,GETJI2		;COUNT OUR COUNT AND ADR
GETJI3:	CALLX (MSEC1,CLRJSB)	;[7.1200] (/) Unmap JSB of object job
GETJIX:	UMOVEM P3,2		;UPDATE USERS PTR
	SMRETN


;HERE IF TTY GIVEN AND NO CONTROLLING JOB
;GETJI6 - NO JOB OWNS THIS TERMINAL; GETJI1 - A JOB OWNS THIS TERMINAL
;BUT IT IS NOT THE JOB'S CONTROLLING TERMINAL

GETJI6:	SKIPA T2,[-1]		;[7.1200] Indicate no owning job
GETJI1:	TLO 2,(1B1)		;SAY ASSIGNED
GETJI4:	XCTU [SKIPE 3]		;DOES USER WANT FIRST ENTRY?
	JRST GETJIX		;NO, NOTHING TO DO
	SKIPG T1,T2		;[7.1200] Skip if it's a job index
	IFSKP.			;[7.1200] It's a job index
	  HRRZ T1,T2		;[7.1200] Get Rh only (local job index)
	  CALLX (MSEC1,LCL2GL)	;[7.1200] (T1/T1) Convert index to global job
	   SETOB T1,T2		;[7.1200] No global job number yet
	  HLL T1,T2		;[7.1200] Get back the 'assigned' flag, if any
	ENDIF.			;THAT'S ALL
	UMOVEM T1,0(P3)		;YES, STORE IT
	AOBJN P3,.+1		;UPDATE HIS POINTER
	JRST GETJIX		;RETURN

;TABLE OF GETJI ITEMS - WORD IS EXECUTED TO GET ITEM IN AC1

GETJIT:	MOVE T1,GBLJNO(P4)	;User's Global Job Number
	HLRE 1,JOBPT(P1)	;TTY NUMBER OR -1 IF DETACHED
	CALL GETSN5		;GET LOGIN DIRECTORY NUMBER
	CALL GETSN4		;GET CONNECTED STRUCTURE,,DIRECTORY
	CALL GETSN1		;SUBSYSTEM NAME
	MOVE 1,JOBPNM(P1)	;PROGRAM NAME
	MOVE 1,JOBRT(P1)	;RUN TIME
	CALL GETSN3		;JOB NUMBER OF OWNER OF PTY IF ANY
	CALL GETRTL		;GET RUNTIME LIMIT OF JOB
	CALL GETBB		;GET BATCH BIT
	CALL GETJID		;GET DENSITY
	LOAD T1,JSMTP,(P4)	;GET MAGTAPE PARITY DEFAULT
	CALL GETJIM		;GET MAGTAPE DATA MODE
	CALL GETJRS		;GET MAGTAPE RECORD SIZE
	LOAD T1,JSDFS,(P4)	;GET DEFERRED SPOOLING BIT
	CALL GETSN6		;GET THE LOGGED IN DIRECTORY NUMBER
	CALL GETJSR		;GET SESSION REMARK
	MOVE T1,LSTLGN(P4)	;PICK UP LAST LOGIN D&T
	MOVE T1,JSSRTM(P4)	;(.JISRT) Get session start runtime
	MOVE T1,JSSCTM(P4)	;(.JISCT) Get SESsion start console time
	CALL GETT20		;GET TOPS20 COMMAND LEVEL FLAG
	MOVE T1,SRTTIM(P4)	;GET TIME JOB WAS INITIALIZED
	MOVE T1,BATSTF(P4)	;GET BATCH STREAM AND FLAGS WORD
	CALL GETLL		;GET LOGICAL LOCATION
	MOVE T1,P1		;GET LOCAL JOB INDEX
	MOVE T1,JBBSEQ(P4)	;[7259]Get Batch Sequence number
	MOVE T1,JBBNAM(P4)	;[7259]Get Batch Job name
	MOVE T1,BATRID(P4)	;[7259]Get Batch request ID
NGTJIT==.-GETJIT

;ACTION ROUTINES FOR ITEMS NOT AVAILABLE IN SINGLE MOVE

;GET CONNECTED STRUCTURE,,DIRECTORY

GETSN4:	MOVE T1,P4		;T1/OFFSET FOR ADDRESSING JSB
	XJRST [MSEC1,,GTOJCD]	;[7.1200] (T1/T1) Get str code,,directory

;GET LOGGED DIR NUMBER

GETSN5:	HRRZ T1,JOBDIR(P1)	;GET DIR NUMBER
	SKIPE T1		;IF NOT LOGGED IN, RETURN 0
	HRLI T1,USRLH		;MAKE IT BE A 36 BIT USER NUMBER
	RET

;GET -1 OR 0 FOR TOPS20 COMMAND LEVEL OR USER LEVEL

GETT20:	LOAD T1,JBT20,(P4)	;GET TOPS20 BIT
	MOVN T1,T1		;[7.1200] If bit on return -1, bit off return 0
	RET

;GET THE LOGGED IN DIRECTORY NUMBER

GETSN6:	MOVE T1,LGSIDX		;[7.1112]Get number of Login Structure
	CALLX (MSEC1,STRCNV)	;[7.1200] (T1/T1) Convert it
	 RETERR (,<CALLX (MSEC1,CLRJSB)>) ;[7.1200] Can't convert it
	HRLZS T1		;GET UNIQUE CODE IN THE LEFT HALF
	HRR T1,JOBDIR(P1)	;GET THE DIRECTORY NUMBER
	RET			;AND RETURN

;GET SUBSYSTEM NAME

GETSN1:	HRRZ 1,JOBNAM(P1)	;GET STATISTICS INDEX
	MOVE 1,@[EP. SNAMES(1)]	;GET NAME
	RET

;GET JOB NUMBER OF OWNER OF PTY

GETSN3:	HLRE 1,JOBPT(P1)	;GET CONTROLLING TTY
	JUMPL 1,RETO		;RETURN -1 IF DETACHED
	CALLX (MSEC1,PTYGFK)	;[7.1200] (T1/T1) Get fork which owns PTY
	 JRST RETO		;NO PTY, RETURN -1
	MOVEM T1,Q3		;[7.1200] Save fork that owns PTY
	LOAD T1,FKJO%,(Q3)	;[7.1200] Get job that owns fork
	CALLX (MSEC1,LCL2GL)	;[7.1200] (T1/T1) Convert local to global job
	 RETERR (,<CALLX (MSEC1,CLRJSB)>) ;[7.1200] No such job/invalid job
	RET

;GET BATCH BIT

GETBB:	HLRE T1,JOBPT(P1)	;GET CONTROLING TTY
	JUMPL T1,RETZ		;IF NONE, JOB NOT CONTROLLED BY BATCH
	CALLX (MSEC1,PTYGBB)	;[7.1200] (T1/T1) Get batch bit
	 JRST RETZ		;NOT A PTY
	RET			;ANSWER IS IN T1

;GET MAGTAPE DENSITY

GETJID:	LOAD T1,JSMTD,(P4)	;GET DEFAULT DENSITY
	SKIPN T1		;USING SYSTEM DEFAULT?
	MOVEI T1,MTDFDN		;YES
	RET

;GET MAGTAPE DATA MODE

GETJIM:	LOAD T1,JSMTM,(P4)	;GET DEFAULT DATA MODE
	SKIPN T1		;USING SYSTEM DEFAULT
	MOVEI T1,MTDFDM		;YES
	RET

;GET MAGTAPE RECORD SIZE

GETJRS:	LOAD T1,JSMTR,(P4)	;GET RECORD SIZE
	SKIPN T1		;USING SYSTEM DEFAULT?
	MOVEI T1,MTDFRS		;YES
	RET

;GET RUNTIME LIMIT FOR THIS JOB

GETRTL::LOAD T1,JOBRTP,(P1)	;[7.1076] GET POINTER TO RUNTIME LIMIT BLK
	JUMPE T1,R		;WAS NONE
	LOAD T1,TIMTIM,(T1)	;GET ACTUAL LIMIT
	RET

;GET SESSION REMARK

GETJSR:	MOVEI T2,JSSRM(P4)	;ADDRESS OF REMARK IN JSB
GU1:	UMOVE T1,0(P3)		;PLACE WHERE USER WANTS REMARK PUT
	HRRZ T3,P3		;GET USER ADDRESS FOR UPDATED POINTER
	CALLX (MSEC1,CPYTU1)	;[7.1200] (T1,T2,T3/) Copy remark to user space
	RETSKP			;SKIP SO POINTER DOESN'T GET UPDATED TWICE!

;GET LOGICAL LOCATION

GETLL:	MOVEI B,LLSR-1(P4)	;ADDRESS OF LOCATION STRING (MINUS ONE FOR CPYTU1)
	CALLRET GU1		;USE STANDARD MAGIC FOR FINISHING UP
	SUBTTL SWTCH/LITES/USRIO JSYSes

	XSWAPCD			;[7.1200]

;LIGHTS, SWITCHES, AND OTHER MAINTENANCE STUFF

.SWTCH:: MCENT
	MOVE 2,CAPENB
	TXNN 2,SC%WHL+SC%OPR+SC%MNT ;SUFFICIENT CAPABILITIES?
	JRST CAPXR		;NO
	SETZ T1,		;INIT ANSWER
	UMOVEM 1,1
	SMRETN

.LITES::MCENT
	MOVE 2,CAPENB
	TRNN 2,SC%WHL+SC%OPR+SC%MNT ;REQUIRES STATUS
	JRST CAPXR
	SMRETN

.USRIO::MCENT
	MOVEI 1,SC%WHL+SC%OPR+SC%MNT
	TDNN 1,CAPENB		;REQUIRES STATUS
CAPXR:	RETERR(CAPX2)		;RETURN BAD, USER LACKS CAPABILITIES
	MOVSI 1,(1B6)		;USER IO BIT
	IORM 1,0(P)		;PUT IT ON
	SMRETN
	SUBTTL PEEK JSYS

	XSWAPCD			;[7.1200] 

;PEEK - AC1:  N,,MONLOC
;       AC2:     USRLOC

.PEEK::	MCENT
	MOVEI 3,SC%WHL+SC%OPR+SC%MNT
	TDNN 3,CAPENB		;HAS NECESSARY CAPS?
	RETERR(CAPX2)		;NO
	MOVSI 5,0(1)		;SETUP BLT ARGS - FROM
	HRRI 5,0(2)		; .. TO
	MOVEI 6,0(2)
	HLRZ 3,1		;COUNT
	HRRZ T4,T1		; FIND MONITOR LIMIT
	ADD T4,T3
	ADDI 6,-1(3)		; .. TO LIMIT

;CHECK ALL PAGES OF SOURCE BLOCK FOR PROPER ACCESS

	MOVEI 1,0(1)		;GET MONITOR ADDRESS
PEEK1:	PUSH P,1
	MRPAC			;GET ACCESS OF MONITOR PAGE
	TLNN T1,-1		;LEGAL RANGE? ** TO BE CHANGED FOR XADR **
	TLNN 2,(PA%RD)		;READABLE?
	RETERR(PEEKX2)		;NO
	POP P,1
	IORI 1,777		;BUMP ADDRESS TO NEXT PAGE
	ADDI 1,1
	CAMGE 1,T4		;CHECKED ALL PAGES?
	JRST PEEK1		;NO, GO CHECK NEXT ONE
	UMOVE T3,T2		;GET TO ADDRESS FROM USER
	UMOVE T2,T1		;GET FROM ADDRESS AGAIN
	HLRZ T1,T2		;FIND SIZE
	HRLI T2,MSEC1		;SECTION 1 IN MONITOR
	CALL BLTMU1		;TRANSFER FROM MONITOR TO USER
	SMRETN
	SUBTTL XPEEK% JSYS

	XSWAPCD			;[7.1200]

; XPEEK% JSYS
;
;	AC1:	ADDRESS OF ARGUMENT BLOCK

.XPEEK::MCENT			;ENTER MONITOR CONTEXT
	UMOVE T2,1		;GET ADDRESS OF ARGUMENT BLOCK FROM USER
	UMOVE T1,.XPFNC(T2)	;GET FUNCTION CODE FROM USER
	CAILE T1,0		;FUNCTION CODE WITHIN
	CAILE T1,XPTLEN		;[7.1200] valid range?
	ITERR (ARGX02)		;NO, RETURN "INVALID FUNCTION" ERROR
	CALL @XPKTAB-1(T1)	;[7.1200] Dispatch to routine
	 ITERR ()		;FAILED. RETURN ERROR CODE
	MRETNG			;SUCCESS. DONE

; DISPATCH TABLE FOR XPEEK FUNCTIONS

XPKTAB:	XADDR. (XPPEK)		;[7.1200] (1) Extended peek function

XPTLEN==.-XPKTAB



; XPPEEK FUNCTION.
;
; ARGUMENT BLOCK:
;
;	WORD	DESCRIPTION
;
;	 0	LENGTH OF ARGUMENT BLOCK
;	 1	FUNCTION CODE - .XPPEK
;	 2	NUMBER OF WORDS TO TRANSFER
;	 3	NUMBER OF WORDS TRANSFERRED
;	 4	ADDRESS OF FIRST LOCATION IN MONITOR
;	 5	ADDRESS IN USER SPACE TO TRANSFER TO

XPPEK:	STKVAR <COUNT,MONLOC>
	MOVE Q1,T2		;SAVE ADDRESS OF USER BLOCK
	MOVEI T4,SC%WHL+SC%OPR+SC%MNT
	TDNN T4,CAPENB		;HAS NECESSARY CAPS?
	ITERR(CAPX2)		;NO
	UMOVE T1,.XPABL(Q1)	;GET LENGTH OF ARGUMENT BLOCK
	CAIGE T1,.XPLEN		;LONG ENOUGH?
	ITERR (ARGX04)		;NO. COMPLAIN
	UMOVE T1,.XPCN1(Q1)	;GET WORD COUNT FROM USER
	HRRZM T1,COUNT
	UMOVE T1,.XPMAD(Q1)	;GET MONITOR ADDRESS FROM USER
	HLRZ T2,T1		;GET MONITOR SECTION
	SKIPN T2		;SECTION GIVEN?
	HRLI T1,MSEC1		;NO. USE SECTION 1 IN MONITOR
	MOVEM T1,MONLOC		;SAVE THE MONITOR LOCATION
	MOVE T4,T1
	ADD T4,COUNT		;FIND MONITOR LIMIT

;CHECK ALL PAGES OF SOURCE BLOCK FOR PROPER ACCESS

XPEEK1:	PUSH P,T1		;SAVE MONITOR ADDRESS
	MRPAC			;GET ACCESS OF MONITOR PAGE
	TLNN T2,(PA%RD)		;READABLE?
	RETERR(PEEKX2)		;NO
	POP P,T1		;RESTORE ADDRESS
	IORI T1,777		;BUMP ADDRESS TO NEXT PAGE
	ADDI T1,1
	CAMGE T1,T4		;CHECKED ALL PAGES?
	JRST XPEEK1		;NO, GO CHECK NEXT ONE
	UMOVE T3,.XPUAD(Q1)	;GET USER ADDRESS FROM USER
	MOVE T2,MONLOC		;GET MONITOR ADDRESS AGAIN
	MOVE T1,COUNT		;GET COUNT FROM USER
	CALL BLTMU1		;TRANSFER FROM MONITOR TO USER
	SUB T2,MONLOC		;GET NUMBER OF WORDS TRANSFERRED
	UMOVEM T2,.XPCN2(Q1)	;RETURN COUNTS
	RETSKP			;DONE. SUCCESS

	SUBTTL CRJOB JSYS

;CRJOB -- CREATE A JOB OTHER THAN THIS ONE

;CALL:	1		;FLAG BITS
;	2		;POINTER TO ARGUMENT BLOCK
;	CRJOB
;RETURNS:
;	+1		;ERROR
;	+2		;SUCCESS
;	IN 1		;JOB NUMBER OF NEWLY CREATED JOB
;
;FLAGS IN AC1:
;B0	CJ%LOG		;ON - TRY TO LOG THE NEW JOB IN
;			;OFF - CREATE AN UN-LOGGED-IN JOB
;B1	CJ%NAM		;ON - USE NAME AND PASSWORD IN ARG BLOCK
;			;OFF - LOG IN AS SAME USER AS EXECUTOR OF CRJOB
;B2-3	CJ%ACT		;ACCOUNT FIELD. 0 - USE CURRENT ACCOUNT
;			;1 - USE ACCOUNT SUPPLIED IN ARG BLOCK
;			;2 - USE DEFAULT ACCOUNT OF NEW JOB'S USER
;B4	CJ%ETF		;ON - PUT EXEC IN TOP FORK OF NEW JOB
;			;OFF - FILE REQUESTED BY B5 IS IN TOP FORK
;B5	CJ%FIL		;ON - FILENAME IN ARG BLOCK SHOULD BE GET'ED
;			;OFF - JUST AN EXEC. NO FILE.
;B6	CJ%ACS		;ON - IF B5 IS ON, PUT AC'S FROM ARG INTO FORK
;			;     WHICH HAS THE FILE GET'ED INTO IT
;B7	CJ%OWN		;ON - MAINTAIN OWNERSHIP OF THE NEW JOB
;			;OFF - DISOWN THE NEW JOB
;B8	CJ%WTA		;ON - WAIT TILL ATTACHED BEFORE RUNNING NEW JOB
;B9	CJ%NPW		;ON - NO PASSWORD CHECK IN NEW JOB LOGIN
;			;     (REQUIRES WHEEL/OPER, OR B1 OFF)
;B10	CJ%NUD		;ON - NO UPDATE OF LAST-LOGIN DATE.
;B11	CJ%SPJ		;ON - DO SPJFN WITH ARG IN ARG BLOCK
;B12	CJ%CAP		;ON - SET NEW JOB'S CAPMSK RH TO MY CURRENT
;			;     CAPENB RH, UNTIL IT LOGS IN.
;B13	CJ%CAM		;CAPABILITY MASK AFTER LOGIN
;B14	CJ%SLO		;SIGNAL THE SUPPLIED PID AT LOGOUT TIME
;B17	CJ%DSN		;ON - DISOWN EXISTING JOB (IF IT'S MINE), JOB
;			;     NUMBER IS IN AC 3
;IN PARAMETER BLOCK:
;WD0	.CJNAM		;STRING POINTER TO NAME FOR LOGIN
;WD1	.CJPSW		;STRING POINTER TO PASSWORD FOR LOGIN
;WD2	.CJACT		;ACCOUNT DESIGNATOR/STRING POINTER FOR LOGIN
;WD3	.CJFIL		;STRING POINTER TO FILENAME TO GET
;WD4	.CJSFV		;SFRKV OFFSET TO START FILE
;WD5	.CJTTY		;TTY DESIGNATOR, OR NULL DESIGNATOR, FOR CTTY
;WD6	.CJTIM		;TIME LIMIT (NOT IMPLEMENTED)
;WD7	.CJACS		;POINTER TO 16 WORDS OF AC'S FOR FORK
;WD8	.CJEXF		;EXEC FLAGS, FOR AC1 OF STARTED EXEC
;WD9	.CJPRI		;PRIMARY JFN'S FOR SPJFN IN NEW JOB
;WD10	.CJCPU		;CPU LIMIT (ZERO MEANS NONE)
;WD11	.CJCAM		;CAPABILITY MASK
;WD12	.CJSLO		;PID TO SEND LOGOUT MSG TO

	SWAPCD			;[7.1200]
.CRJOB::MCENT			;CREATE JOB JSYS
	GTOKM (.GOCJB,,[RETERR ()])	;GETOK FOR .CRJOB AND ITRAP IF ERROR
CRJOB1:	NOINT			;PROTECT THE CRJLCK RESOURCE
	LOCK (CRJLCK,<JRST CRJLKF>)
	SETZM CRJANS		;CLEAR THE RESULT COMMUNICATION WD
	MOVE T1,GBLJNO		;GET MY JOB NUMBER
	MOVEM T1,CRJONJ		;FOR CREATEE TO SEE
	MOVE T1,CAPENB		;AND MY CAPS
	MOVEM T1,CRJOJC		; ..
	UMOVE Q1,1		;FLAGS FROM CALLER
	MOVEM Q1,CRJAC1		;STORE THEM FOR NEW JOB
	TXNE Q1,CJ%DSN		;REQUEST TO DISOWN A JOB?
	JRST CRJDSN		;YES.
	TXNN T1,SC%WHL+SC%OPR	;IS THIS A PRIVILEGED JOB?
	TXNE Q1,CJ%LOG+CJ%ETF	;NO. MUST HAVE EXEC IN TOP FK, OR LOGIN
	SKIPA			;OK.
	JRST CRJILG		;NO GOOD. GIVE ILLEG COMBINATION ERROR.
	UMOVE Q2,2		;OK, GET POINTER TO ARG BLOCK
	SETOM CRJTTY		;ASSUME DETACHED NEW JOB
	UMOVE T1,.CJTTY(Q2)	;GET THE TTY DESIGNATOR
	CAIN T1,.NULIO		;NUL DESIGNATOR?
	JRST CRJB1A		;YES. OK.
	CAIL T1,400000		;NO, SEE IF IT'S A VALID TTY
	CAIL T1,400000+NLINES	; ..
	JRST CRJTTX		;NOT A LEGAL TTY NUMBER
	MOVE T2,T1		;GET TTY DESIGNATOR IN T2
	SUBI T2,400000		;TTY NUMBER IS A REAL TTY.
	MOVEM T2,CRJTTY		;Save it
	NOSKED			;CHECK TO SEE IF IT'S AVAILABLE.
	CALL GTCJOB		;STABLE STATE OF TTFORK...
	 JRST CRJOTX		;TTY NOT ASSIGNED
	CAMN T3,JOBNO		;IS THE TTY ASSIGNED TO ME?
	CAMN T2,CTRLTT		;AND NOT MY CONTROLLING TERMINAL?
CRJOTX:	JRST [	OKSKED		;NOT A VALID TTY FOR THIS USE
		JRST CRJTTX]	;FAIL.
	PUSHJ P,CHKDEV		;SEE IF IT'S ASSIGNED TO ME
	  JRST CRJOTX		;IT'S NOT.
	TXNN T3,DV%ASN		;ASSIGNED?
	JRST CRJOTX		;NO.
	UMOVE Q1,T1		;RESTORE AC'S CLOBBERED ABOVE
	UMOVE Q2,T2
	OKSKED			;LET TTFORK CHANGE NOW

;CRJOB...

	MOVE T1,CRJTTY		;Get back TTY designator
	TRO T1,400000		;AND NOW RELEASE IT FROM THIS JOB
	RELD
	 JFCL

CRJB1A:	JE CJ%LOG,Q1,CRJOB4	;JUMP IF NOT LOGGING IN
	TXNN Q1,CJ%NAM		;USING SUPPLIED PASSWORD AND NAME?
	JRST CRJOB2		;NO, USE MINE.
	UMOVE T2,.CJNAM(Q2)	;GET THE SUPPLIED NAME STRING
	MOVEI T1,CRJUSR-1	;WHERE TO PUT THE TEXT
	PUSHJ P,CPYFU1		;COPY THE STRING
	 JRST CRJCPX		;FAILED?
	UMOVE T2,.CJPSW(Q2)	;COPY THE PASSWORD
	MOVEI T1,CRJPSW-1	;TO HERE
	PUSHJ P,CPYFU1		; ..
	 JRST CRJCPX		;CAN'T?
	JRST CRJOB4		;OK, HAVE NAME AND PASSWORD NOW

;HERE'S THE FAIL PATH ON THE LOCK MACRO ABOVE.
CRJLKF:	OKINT
	MOVEI T1,CRJLCK		;WAIT, INTERRUPTABLE, FOR THE LOCK
	PUSHJ P,DISL
	JRST CRJOB1		;AND GO GRAB IT NOW.

;HERE TO COPY MY OWN NAME AND PASSWORD FOR NEW JOB. ACTUALLY,
; JUST PUT MY NAME IN, AND CAUSE LOGIN TO NOT CHECK PASSWORD.
CRJOB2:	HRRZ T2,JOBNO		;THIS JOB NUMBER
	HRRZ T2,JOBDIR(T2)	;HERE IS MY LOGGED IN USER NUMBER
	HRLI T2,USRLH		;MAKE A USER NUMBER
	HRROI T1,CRJUSR		;PUT THE NAMESTRING HERE
	DIRST			;CONVERT TO STRING
	 JRST CRJXXX		;FAILED
	MOVX T1,CJ%NPW		;SET THE BIT SO THAT LOGIN
	IORM T1,CRJAC1		; WILL NOT CHECK PASSWORD
;FALL THRU TO ACCOUNT HANDLING

;FALLS THRU FROM ABOVE

;NOW GET THE ACCOUNT FOR NEW JOB
CRJOB4:	SETZM CRJACT		;DEFENSIVE CHECKS ON ACCOUNT.
	LOAD T1,CJ%ACT,Q1	;SEE WHERE TO GET ACCOUNT FROM
	TRNE T1,.CJUDA		;WANT DEFAULT ACCOUNT?
	JRST CRJB5Z		;YES. NOTHING TO SET UP.
	TRNE T1,.CJUAA		;NO, MINE, OR SUPPLIED?
	JRST CRJOB5		;SUPPLIED.
;GET STRING ACCOUNT FOR CURRENT JOB
CRJB4A:	MOVE T1,[XWD ACCTSR,CRJACT+1]
	BLT T1,CRJACT+10	;COPY THE ACCOUNT STRING
	JRST CRJB5S		;DONE WITH THE ACCOUNT

;HERE IF ACCOUNT WAS SUPPLIED IN ARG BLOCK.
CRJOB5:	UMOVE T2,.CJACT(Q2)	;GET ACCT NUMBER/POINTER FROM BLOCK
	MOVE T1,T2		;SEE IF NUMERIC OR STRING
	TLC T1,(5B2)		; ..
	TLNE T1,(7B2)		; ..
	JRST CRJB5A		;STRING.
	MOVEM T2,CRJACT		;NUMERIC.
	JRST CRJB5Z		;DONE WITH ACCOUNT

	MOVE T1,T2		;GET THE ACCOUNT POINTER
	CALL PTRCHK		;CHECK THE POINTER
	 JRST CRJCPX		;BAD POINTER
CRJB5A:
	MOVEI T1,CRJACT		;COPY STRING TO HERE + 1
	PUSHJ P,CPYFU1		; ..
	 JRST CRJCPX		;CAN'T COPY IT?
CRJB5S:	MOVE T1,[000700,,CRJACT] ;MUST BE POSITIVE NUMBER
	MOVEM T1,CRJACT		;POINTER TO THE ACCOUNT
CRJB5Z:	JRST CRJB5I		;DONE WITH ACCOUNT. GO LOOK FOR INFERIOR

;MORE CRJOB. HERE TO DEAL WITH INFERIOR FORK
CRJB5I:	UMOVE T2,.CJEXF(Q2)	;GET FLAGS FOR EXEC, IN CASE NEEDED
	MOVEM T2,CRJEXF		;SAVE FOR LATER
	UMOVE T2,.CJSFV(Q2)	;START FORK VECTOR OFFSET
	HRRZM T2,CRJEVO		;SAVE THAT TOO
	UMOVE T2,.CJPRI(Q2)	;AND PRIMARY JFN'S, MAYBE NEEDED TOO
	MOVEM T2,CRJPJF		; ..
	TXNN Q1,CJ%FIL		;IS THERE A FILE TO RUN?
	JRST CRJB5Y		;NO.
	MOVEI T1,CRJFIL-1	;YES, GET ITS FILE NAME
	UMOVE T2,.CJFIL(Q2)	;FROM HERE IN ARG BLOCK
	MOVEI T3,<5*40>-1	;CHARACTERS THAT CAN FIT IN STORAGE BLK
	PUSHJ P,CPYFU2		;COPY THE STRING
	 JRST CRJCPX		;CAN'T?
	TXNN Q1,CJ%ACS		;WANT THE AC'S SET UP?
	JRST CRJB5C		;NO
	MOVEI T1,20		; Length of AC block
	UMOVE T2,.CJACS(Q2)	;YES. GET THE POINTER TO THEM
	XMOVEI T3,CRJFAC	; Place to store user's
	CALL BLTUM1		;COPY AC'S, ADDING PCS IF NECESSARY
CRJB5C:
CRJB5Y:	;END OF CODE DEALING WITH THE INFERIOR FORK TO RUN
	UMOVE T2,.CJCAM(Q2)	;CAPABILITIES MASK FOR LOGIN
	TXNN Q1,CJ%CAM		;SUPPLIED?
	SETO T2,0		;NO, ASSUME ALL BITS ALLOWED
	MOVEM T2,CRJCAM		;SAVE TO MASK AT LOGIN TIME
	UMOVE T2,.CJSLO(Q2)	;A PID TO SIGNAL AT LOGOUT TIME
	TXNN Q1,CJ%SLO		;UNLESS NOT TO USE ONE
	MOVEI T2,0		;IN WHICH CASE, USE ZERO
	MOVEM T2,CRJSLO		;SAVE IT
	UMOVE T2,.CJCPU(Q2)	;CPU LIMIT TO APPLY (ZERO IF NONE)
	MOVEM T2,CRJCPU		; ..
;FALL THRU

;FALLS THRU FROM ABOVE
;HERE TO ACTUALLY PUT IN THE REQUEST FOR SCHEDULER TO START THE JOB
	MOVSI T1,-2		;FLAG OF -2 FOR JOBSRT MEANS CRJOB
	HRRI T1,JOBSRT		;AND SCHED LEVEL CODE ADDR
	CALL SCDRQ7		;REQUEST IT.
	MOVEI T1,CRJANS		;NOW WAIT FOR AN ANSWER.
	CALL DISN		; ..
	MOVE T1,CRJANS		;WHAT HAPPENED?
	JUMPGE T1,CRJXXX	;IF PLUS, IT FAILED.
	HLRZ T1,CRJONJ		;IT SUCCEEDED. GET THE JOB NUMBER
	UMOVEM T1,1		;RETURN IT TO THE CALLER.
CRJXIT:	UNLOCK CRJLCK		;RELEASE THE STORAGE LOCK
	SMRETN			;SUCCESS RETURN.

CRJDSN:	UMOVE T1,3		;GET JOB NUMBER TO DISOWN
	CALL GL2LCL		;TRANSLATE GLOBAL JOB NUMBER TO LOCAL INDEX
	 JRST CRJILG		;ILLEGAL ARG FAILURE
	NOSKED			;FREEZE THE OWNERSHIP TABLE
	HRRZ T2,JOBONT(T1)	;GET THE JOB'S OWNER
	CAMN T2,GBLJNO		;IS IT ME?
	 SETOM JOBONT(T1)	;YES. I GIVE IT UP.
	OKSKED			;FREE THE TABLE
	CAME T2,GBLJNO		;WAS IT OK?
	 JRST CRJILG		;NO. FAIL.
	JRST CRJXIT		;YES. GIVE SUCCESS RETURN.

CRJCPX:				;COPY OF USER STUFF FAILED
CRJILG:	MOVEI T1,CRJBX1		;ILLEGAL PARAMETER OR BIT COMBINATION
	JRST CRJXXX
CRJTTX:	MOVEI T1,CRJBX4		;BAD TTY REQUESTED
CRJXXX:	UNLOCK CRJLCK		;FREE THE STORAGE BLOCK
	OKINT
	JRST MRETNE		;RETURN FAIL, ERROR NUMBER IN 1
	SUBTTL LOGIN JSYS

	SWAPCD			;[7.1200]
; Login
;ACCEPTS:
;	T1/USER NUMBER
;	T2/POINTER TO PASSWORD STRING
;	T3/5B2+ACCOUNT NUMBER
;		OR
;	   POINTER TO ACCOUNT STRING

;	LOGIN

;RETURNS +1: FAILURE
;		T1/ERROR CODE
;	 +2: SUCCESS
;		T1/DATE AND TIME OF LAST LOGIN
;		T2/UPDATED STRING POINTER
;		T3/UPDATED STRING POINTER (IF APPLICABLE)



.LOGIN::MCENT
	STKVAR <LOGUSR>		;ALLOCATE STORAGE FOR USER NUMBER
	MOVEM T1,LOGUSR		;REMEMBER USER NUMBER
	GTOKM (.GOLOG,<T1>,[RETERR ()])	;GETOK AND RETERR IF ILLEGAL
	MOVE A,JOBNO
	MOVEI B,777777
	TDNE B,JOBDIR(A)	; Is this job currently logged in?
	RETERR(LGINX5)
	;SKIPN FREJOB		;ANY JOB SLOTS LEFT (1 NEEDED FOR ATTACH'ES)
	;RETERR (LGINX6)		;NO, DO NOT ALLOW LOGINS.
	MOVE A,LOGUSR		;SET UP USER NUMBER
	CALL CNVDIR		;CONVERT THIS NUMBER TO A DIRECTORY #
	MOVEM A,P1		;SAVE (STRUCTURE UNIQUE CODE,,DIRECTORY NUMBER)
	CALL SETDIR		; MAP IN THIS DIRECTORY AND GO NOINT
	 RETERR(LGINX3)
	MOVE Q1,DIRORA		; GET BASE ADR OF MAPPED DIR
	LOAD B,DRMOD,(Q1)	; GET MODE BITS
	MOVEM B,MODES
	TXNE B,MD%FO		;FILES ONLY DIRECTORY?
	RETERR(LGINX2,<ULKDIR>)	;CAN'T LOGIN TO FILES-ONLY DIRECTORY

;PASSWORD IS NOT REQUIRED IF CONTROLLING TTY IS A PTY AND EITHER:
; 1. THIS JOB BEING LOGGED IN AS SAME USER, OR
; 2. USER IS A SC%WHL OR SC%OPR
;CHECK FOR THESE CONDITIONS

	MOVE A,CTRLTT		;CTRL TTY OF THIS JOB
	CALL PTGETJ		;GET JOB NO. OF JOB OWNING PTY OR -1
	MOVE B,A
	JUMPL B,LOGI2		;JUMP IF NOT A PTY
	HRRZ D,JOBDIR(B)	;GET "WHO" OF CONTROLLING JOB
	HRRZ C,LOGUSR		;GET "WHO" IS TRYING TO LOGIN HERE
	CAMN C,D		;SAME?
	JRST LOGI1		;YES, NO PASSWORD CHECK
	MOVE A,B		;CONTROLLING JOB NUMBER FOR CALL
	CALL GJCAPS		;GET CAPABILITIES OF CONTROLLING JOB
	MOVE B,A
	TXNE B,SC%WHL+SC%OPR	;CONTROLLING JOB HAS CAPABILITIES?
	JRST LOGI1		;YES, NO PASSWORD CHECK
;ALSO BYPASS PASSWORD CHECK IF IN THE MIDST OF CRJOB AND THE
;CREATOR OF THIS JOB ASKED FOR PASSWORD TO BE BYPASSED AND THE
;CREATOR WAS AN ENABLED WHEEL/OPERATOR.
LOGI2:	SKIPE T2,CRJFLG	;IS THIS A CRJOB INTERNAL LOGIN?
	TRNN T2,1		;YES. REQUESTED TO BYPASS PSWD CHK?
	SKIPA			;NO. SO CHECK IT.
	JRST LOGI1		;YES. BYPASS CHECKING PASSWORD.
CHKPVL:	CALL CHKPSW
	 JRST LOGI3		;INCORRECT PASSWORD
	; ..

	; ..
LOGI1:	SETZM D			;ASSUME WE HAVE AN ACCOUNT STRING
	XCTU [SKIPN A,3]	;GET ACCOUNT STRING
	MOVEI D,1		;NONE THERE
	MOVE B,LOGUSR		;GET USER NUMBER
	XCT [	CALL SETACT
		CALL SETACL](D) ;EXECUTE PROPER ROUTINE
	 RETERR (,<ULKDIR>)	;UNLOCK DIR
	CALL CPYUGP		;GET A COPY OF USER GROUPS INTO JSB
	 MOVEI A,0		;NO GROUPS FOR THIS USER
	MOVEM A,Q2		;SAVE POINTER
	LOCK JSSTLK		;LOCK JSB STRUCTURE DATA
	HLRZ A,P1		;GET UNIQUE CODE FOR STRUCTURE
	CALL GTSTOF		;GET OFFSET IN JSB FOR THIS STRUCTURE
	 JRST [	UNLOCK JSSTLK	;NO SPACE. UNLOCK JSB STRUCTURE DATA
		CALL USTDIR	;UNLOCK DIRECTORY AND STRUCTURE LOCKED
		RETERR]		; BY SETDIR AND GO OKINT
	STOR Q2,JSGRP,(B)	;SAVE POINTER TO GROUPS
	HRRZ A,P1		;GET DIRECTORY NUMBER ON PS
	STOR A,JSADN,(B)	;INDICATE USER HAS ACCESSED THIS DIRECTORY
	UNLOCK JSSTLK		;UNLOCK THE JSB STRUCTURE DATA
	CALL LGTAD		;DO LOCAL GTAD
	LOAD T2,DRDAT,(Q1)	;PICK UP LAST LOGIN D&T
	MOVEM T2,LSTLGN		;SAVE IT FOR GETJI
	JUMPL A,LOGI4		;DONT SET LOGIN TIME IF DAYTIME NOT SET
;DO NOT UPDATE LAST-LOGIN DATE IF REQUESTOR OF A PRIVILEGED CRJOB
;SAID NOT TO. THIS IS FOR SERVER LOGINS, SUCH AS FILE TRANSFER.
	SKIPE T3,CRJFLG		;IS IT A CRJOB?
	TRNN T3,2		;YES. NO-UPDATE BIT ON?
	SKIPA			;NO, SO UPDATE AS NORMAL
	JRST LOGI4		;YES. BYPASS THE UPDATE.
	STOR A,DRDAT,(Q1)	;UPDATE TIME

LOGI4:	UMOVEM B,1		;GIVE USER TIME OF LAST LOGIN
	HRRZ T1,LOGUSR		;[7.1051] Get the user number
	CAMN T1,JOBDIR		;[7.1051] Does it match job 0 (OPERATOR)?
	SKIPA T1,[1,,0]		;[7.1051] Yes, add one to left half
	MOVEI T1,1		;[7.1051] No, add one to right half
	ADDM T1,WHOJOB		;[7.1051] Count this job as logged in
	MOVE A,JOBNO		;GET THIS JOB'S NUMBER
	MOVE B,LOGUSR		;GET BACK USER NUMBER
	HRRZM B,JOBDIR(A)	;SAVE AS LOGGED IN DIRECTORY
	MOVE A,LGSIDX		;[7.1112]Get number of Login Structure
	MOVE A,STRTAB(A)	;[7.1112]Get SDB address
	LOAD A,STRUC,(A)	;GET ITS UNIQUE STRUCTURE CODE
	STOR A,JSUC		;SAVE AS CONNECTED STRUCTURE CODE
	STOR B,JSDIR		;MAKE THIS THE CONNECTED DIRECTORY
	CALL CPYCDN		;COPY THE CONNECTED DIR NAME TO JSB
	MOVE B,DIRORA		;POINTER TO DIRECTORY
	OPSTR <ADD B,>,DRNAM,(B) ;GET PNTR TO NAME STRING
				;COPY NAME STRING TO
	MOVEI C,USRNAM+1	; JSB STORAGE
	LOAD A,NMLEN,(B)	;GET NUMBER OF WORDS IN STRING
	AOS B			;UPDATE POINTER TO STRING
	HRRZM A,USRNAM		;SAVE LENGTH OF STRING
	SOS A			;COPY ALL BUT THE HEADER WORD
	CALL XBLTA		;COPY STRING
	REPEAT 0,<
	CALL TTWHOK		;IS IT OK TO BE A WHEEL ON THIS TTY?
	 JRST [	MOVEI T2,0	;NO. SO CLEAR RH CAPS.
		JRST LOGI1A]	; ..
	>
	LOAD T2,DRPRV,(Q1)	;GET PRIVILEGE BITS

LOGI1A:	HRRM T2,CAPMSK		;SETUP RH CAPS - LH SETUP AT JBFINI
	NOINT			;NEGATE THE OKINT ULKDIR WILL DO
	ULKDIR			;UNLOCK DIRECTORY
	MOVEI T1,SPIDTB+.SPQSR	;PID OF QUASAR
	CALL LOGIMS		; SEND A LOGIN MESSAGE TO QUASAR
	 JFCL			; NO QUASAR
	CALL SKDLOG		;GET CLASS ASSIGNMENT IF NECESSARY
	MOVE A,TODCLK		;UPTIME
	MOVEM A,CONSTO
	CALL LGTAD		;[7456] (/T1,T2) Get the current date time
	MOVEM A,JSSCTI		;[7456] Save session start time
	CALL LOGONM		;TYPE LOGON MESSAGE AND DO USAGE% FOR LOGIN
	MOVE T2,CTRLTT		;GET CONTROLLING TERMINAL LINE NUMBER
	MOVEI T3,.MOSMY		;ACCEPT SYSTEM MESSAGE CODE
	SKIPL T2		;SKIP IF DETACHED...
	CALL TTSNTS		;SET TERMINAL TO ACCEPT SYSTEM MESSAGES
BP$020:				;(MOVE A,JOBNO): BREAKPOINT FOR CREATE MAIN FORK
				;ASSUMES FORKX HAS FORK INDEX, GETS JOB INDEX FORM FKJOB(FORKINDEX)
	MOVE A,JOBNO
	SETZM JOBRT(A)
	SETZM CAPENB
	OKINT			;FINALLY ALLOW INTERRUPTIONS
	SMRETN

;HERE IF INCORRECT PASSWORD
LOGI3:	ULKDIR
	SKIPN A			;APPLY PENALTY ONLY IF NECESSARY
	CALL PASPEN
	RETERR(LGINX4)
	SUBTTL DTACH JSYS

	SWAPCD			;[7.1200]

;DETACH FROM CONTROLLING TTY

.DTACH::MCENT
	SKIPGE T1,CTRLTT	;GET CONTROLLING TERMINAL
	MRETNG			;NONE, ASSUME OK
	CALL PTYGBB		;ARE WE CONTROLLED BY BATCH?
	IFSKP.
	ANDL. T1
	  MOVX T1,SC%WHL!SC%OPR ;IF CONTROLLED BY BATCH,
	  TDNN T1,CAPENB	;MUST HAVE WHEEL OR OPR
	  ITERR (CAPX1)	;NOT ENOUGH PRIVILEGES
	ENDIF.
	MOVX T1,.CTTRM		;FINISH OUTPUT ON CONTROLLING TERMINAL
	DOBE			; BECAUSE TTYDAS WILL RELEASE BUFFERS
	 ERJMP	.+1		;IGNORE ERRORS
	CALL LDTACH		;[7456] Do the work
	MRETNG			;AND ALL DONE

;DTACH CALLED INTERNALLY

LDTACH:	STKVAR <LDTALN,TSTRTN>	;Detach Line Number, Test Routine Address
LDTAC2:	SKIPGE T2,CTRLTT	;DOES JOB HAVE A CONTROLLING TERMINAL?
	RET			;NO. DON'T DO ANYTHING
	MOVEM T2,LDTALN		;[7.1022] Save cont terminal number now
	CALL DETSES		;[7456] Write session record for this job
	CALL BLINKS		;[7.1230] () Break links and so on
	CALL LCKDVL		;LOCK DEVICE LOCK, NO NOINT
	SKIPL T2,CTRLTT		;[7456] Get controlling TTY
	IFSKP.			;[7456] It is gone now
	  UNLOKK DEVLKK		;NOT THERE, RELEASE DEVLKK
	  MOVEM T1,TSTRTN	;SAVE TEST ROUTINE ADDR
	  MOVE T2,LDTALN	;MIGHT BE DYNAMIC DATA LOCKED BY SOME JSYS
	  MOVEI T3,"C"-100	;SO GIVE JOB A ^C AND HOPE
	  CALL TTPSRQ		;WONT HELP IF TRAPPING ^C
	  MOVE T1,TSTRTN	;PUT ADDRESS BACK
	  OKINT			;GO OKINT AND
	  RET 			;RETURN
	ENDIF.			;HERE WHEN CTRLTT IS STILL THERE
	CALL STADYN		;POINT TO DYNAMIC DATA
	 JRST LDTAC3		;NOT ACTIVE. SHOULDN'T HAPPEN
	CALL TTFWAK		;WAKE UP PROCESS IN INPUT WAIT ON THIS LINE
	MOVE T2,LDTALN		;T2/ LINE NUMBER
	CALL TTYDAS		;DEASSIGN DYNAMIC DATA
	 JRST [	UNLOKK DEVLKK	;FAILED - UNLOCK DEVICE LOCK
		OKINT		;LCKDVL WENT NOINT
		TXZN T1,1B0	;ERROR OR WAIT?
		RET		;ERROR. CURRENTLY NO WAY TO HANDLE THIS
		HRL T1,LDTALN	;T1/(LINE NUMBER,,ADDRESS OF TEST ROUTINE)
		MDISMS		;WAIT UNTIL DEALLOCATION IS POSSIBLE
		JRST LDTAC2]	;TRY AGAIN

LDTAC3:	SETOM CTRLTT		;INDICATE JOB DOESN'T HAVE CONTROLLING TERMINAL
	MOVE T1,JOBNO
	HRROS JOBPT(T1)
	UNLOKK DEVLKK		;UNLOCK DEVICE LOCK
	OKINT
	RET

;LDET2 - DETACH JOB FROM TERMINAL WITHOUT DEALLOCATING TERMINAL DATA

;RETURNS +1: ALWAYS

;PRESERVES T2

LDET2:	STKVAR<LDETSV>
	CALL DETSES		;[7456] Write a session record for this job
	CALL BLINKS		;[7.1230] () Break links and advice
	CALL UNPAGE		;CLEAR PAGING
	MOVE 2,CTRLTT		;T2/ CONTROLLING TERMINAL NUMBER
	MOVEM T2,LDETSV		;SAVE IT
	SETOM CTRLTT		;INDICATE NO CONTROLLING TERMINAL
	MOVE T1,JOBNO		;GET JOB NUMBER
	HRROS JOBPT(T1)		;INDICATE NO CONTROLLING TERMINAL
	MOVE T2,LDETSV		;T2/ LINE NUMBER
	CALL LCKTTY		;POINT TO DYNAMIC DATA
	 SKIPA			;NOT ACTIVE
	CALL TTFWAK		;WAKE FORK IN INPUT WAIT ON THIS LINE
	CALL ULKTTY		;ALLOW DEALLOCATION
	MOVE T2,LDETSV		;RESTORE LINE NUMBER
	RET

;ROUTINE TO TURN OFF PAGE MODE FOR CONTROLLING TERMINAL.
;CLOBBERS A AND B

UNPAGE:	MOVEI A,.PRIOU		;THE CONTROLLING TERMINAL
	MOVEI B,.MOXOF		;CLEAR PAUSE ON END
	SETZM C
	MTOPR			;DO IT
	 ERJMP	.+1		;ignore errors
	RET			;AND DONE

;PROCEDURE TO HANDLE DATASET CARRIER OFF OR PTY CLOSED.
;DETACH JOB IMMEDIATELY, LOGOUT AFTER 5 MINUTES IF NOT REATTACHED.
;INVOKED ON REQUEST BY PSI SERVICE

JOBCOF::SKIPGE SLOWF		;IN JSYS CONTEXT?
	JRST [	MCENTR		;NO, GET THERE - FFL and FPC setup by PSI
		PUSH P,[IFIW!MRETN]	;SETUP RETURN
		JRST .+1]
	SAVEAC <CX>		;SAVE CX BEFORE ACSAV SMASHES IT
	ACSAV
	STKVAR <CFFFL,CFFPC>
	MOVE T1,FFL		;GET CONTENTS OF FFL
	MOVEM T1,CFFFL		;SAVE IT
	MOVE T1,FPC		;GET CONTENTS OF FPC
	MOVEM T1,CFFPC		;SAVE IT
	MOVE 1,JOBNO
	SKIPGE B,CTRLTT		;HAVE A CONTROLLING TTY?
	JRST JOBCF1		;NO
	CALL GTCJOB		;GET ITS OWNING JOB
	 JRST JOBCF2		;NONE. GO ON
	CAIN C,0(A)		;SAME AS THIS ONE?
	JRST JOBCF1		;YES. GO ON
JOBCF2:	SETOM CTRLTT		;NO. CLEAR THIS ASSIGNMENT
	MOVE T1,JOBNO
	HRROS JOBPT(T1)		;ALSO CLEAR CONTROLLING TTY HERE
JOBCF1:	CALL LDTACH		;DO LOCAL DETACH
	MOVE T1,JOBNO
	HRRZ 1,JOBDIR(1)	;SEE IF NOW LOGGED IN
	IFE. T1
	  MOVX T1,USRCTX	;NO, RESET STACK AND LOGOUT
	  MOVEM T1,FFL
	  SETZM FPC
	  JRST FLOGO
	ENDIF.
	MOVE T1,BITS+.TICRF	;CHECK TO SEE WHAT THE TOP FORK THINKS
	TDNE T1,TTSPSI		; OF TAKING A CARRIER OFF INTERUPT
	 JRST JOBCF3		;IT THINKS SO, SO LET IT TRY
	CALL FFORKI		;INDIRECTLY FREEZE ALL INFERIORS

JOBCF0:	MOVE T1,COFTIM		;[7160] SETUP TO WAIT
	CALL SETBKT		;COMPUTE BLOCKT DATA
	HRRI 1,COFTST		;SETUP SPECIAL TEST
	MOVSI T2,FHV1		;LOW BLOCK PRIORITY
	HDISMS
	MOVE 1,JOBNO		;SEE IF NOW ATTACHED
	SKIPL JOBPT(1)
	IFSKP.
	  MOVE T1,JOBNO		;[7160] NO, CHECK WITH ACJ
	  HRRZ T1,JOBDIR(T1)	;[7160] DIRECTORY
	  JUMPE T1,FLOGO1	;[7160] DON'T CHECK IF NOT LOGGED IN
	  HRLI T1,USRLH		;[7160]
	  CALL CNVDIR		;[7160] GET THE NUMBER OF THAT DIRECTORY
	  GTDAL			;[7160] GET THE ALLOCATION
	   ERJMP FLOGO1		;[7160] DON'T TRY ACJ IF THERE IS AN ERROR
	  SETOM T1		;[7160] FAKE LOGOUT WITH -1 AS ARGUMENT
	  GTOKM (.GOLGO,<T2,T3,T1>,JOBCF0) ;[7160] ASK ACJ, IF NO WAIT AGAIN
	  MOVX T1,USRCTX	;[7160] ACJ SAID YES...
	  MOVEM T1,FFL		;[7160] RESET STACK, INIT JSYS CONTEXT
	  SETZM FPC		;[7160]
	  MCENTR		;[7160]
	  JRST FLOGO1		;[7160] AND LOGOUT THE JOB
	ENDIF.
	NOINT			;KEEP CONTROL
	HLRZ T2,JOBPT(T1)	;GET CONTROLLING TTY
	MOVEI T3,.TICCC		;[7160] FAKE A CONTROL-C
	CALL TTPSRQ		;""
	CALL RFORKI		;RESUME ALL INDIRECTLY FROZEN INFERIORS
	OKINT			;ALLOW INTS AGAIN
JOBCF3:
	MOVE T1,CFFFL		;GET OLD FFL
	MOVEM T1,FFL		;RESTORE IT
	MOVE T1,CFFPC		;GET OLD FPC
	MOVEM T1,FPC		;RESTORE IT AS WE MAY HAVE DONE SOME OTHER JSYS
	RET

;SCHEDULER TEST FOR ABOVE. WAITS UNTIL JOB ATTACHED OR SPECIFIED TIME
;ELAPSED

	RESCD

COFTST:	LOAD T2,FKJO%,(Q3)	;[7.1200] Get job that owns fork
	SKIPL JOBPT(2)		;NOW ATTACHED?
	JRST 1(4)		;YES, WAKEUP
	JRST BLOCKT		;NO, GO TEST TIME

	SWAPCD
	SUBTTL ATACH JSYS

;ATTACH JOB TO TTY

;ACCEPTS:
;	T1/ FLAGS,,JOB NUMBER TO ATTACH TO
;	T2/ USER NUMBER OF JOB IN AC 1
;	T3/ POINTER TO PASSWORD STRING
;	T4/ DESIGNATOR FOR TERMINAL TO BE USED IF AT%TRM FUNCTION OF 1
;	    IS ON.

;	ATACH

;RETURN +1: FAILURE, ERROR CODE IN 1
;RETURN +2: SUCESS.

.ATACH::MCENT
	SAVEAC <Q1,Q2,Q3>	;[7.1200] Define all Q's to use as work regs
	STKVAR <ATACJN,ATACDR,ATACLN,ATACUN>
	MOVEM T2,ATACUN		;STASH THE USER NUMBER
	UMOVE Q1,1		;BITS MODIFYING THE ATACH
	TXNE Q1,AT%TRM		;PROXY ATTACH
	JRST ATACH1		;YES.  DO NOT CARE ABOUT USER NUMBER
	HLRZ T3,T2		;GET UNIQUE CODE OF USER NUMBER
	CAIE T3,USRLH		;IS THIS A LEGAL USER NUMBER?
	RETERR (ATACX3)		;NO, GIVE ERROR RETURN
ATACH1:	MOVEI T1,0(T1)		;GET OBJECT JOB NUMBER
	JUMPE T1,[RETERR (ATACX1)] ;CAN'T ATTACH TO JOB 0
	CALL GL2LCL		;TRANSLATE GLOBAL JOB NUMBER TO LOCAL INDEX
	 RETERR()		;LET CFS REPORT THE ERROR
	MOVEM T1,ATACJN		;SAVE JOB NUMBER TO ATTACH TO
;	CAIGE T1,NJOBS		;REASONABLE JOB NUMBER? - GL2LCL CHECKS THIS
	SKIPGE JOBRT(T1)	;AND JOB EXISTS?
ATACH5:	RETERR(ATACX1)		;NO

	TXNN Q1,AT%TRM		;PROXY ATTACH
	IFNSK.			;IF NOT
	 CAMN T1,JOBNO		;TRYING TO DO HIS JOB?
	 RETERR (ATACX2)	;YES. ERROR
	ELSE.
	 UMOVE Q3,4		;[7.1200] Get tty number to ATACH the job to
	 ANDI Q3,377777		;[7.1200] Just line number part
	 SKIPG Q3		;[7.1200] Valid TTY number?
	 RETERR (ATACX7)	;NO, FAIL
	 CAIL Q3,NLINES		;[7.1200] Existant line?
	 RETERR (ATACX1)	;NO. FAIL.
	ENDIF.
	HRRZ T3,JOBDIR(T1)	;DIRECTORY OF  OTHER JOB
	MOVEM T3,ATACDR		;SAVE DIRECTORY NO. FOR FACT FILE
	CAIE T3,0(T2)		;SAME AS SPECIFIED?
	RETERR(ATACX3)		;NO
	SKIPL T1,CTRLTT		;GET CONTROLLING TERMINAL
	CALL PTYGBB		;ARE WE CONTROLLED BY BATCH?
	 SKIPA			;NO, CONTINUE
	JUMPL T1,[MOVX T1,SC%WHL!SC%OPR  ;IF CONTROLLED BY BATCH,
		TDNN T1,CAPENB	;MUST HAVE WHEEL OR OPR
		RETERR(CAPX1)	;NOT ENOUGH PRIVILEGES
		JRST .+1]	;OK, CONTINUE
	; ..

	; ..
;SEE IF USER CAN LEGALLY ATTACH OTHER JOB.  ATTACH IS LEGAL IF
;BOTH JOBS ARE SAME USER, IF THIS USER IS SC%WHL, OR IF
;USER GIVES PROPER PASSWORD
;ALSO, ATACH IS LEGAL IF JOB BEING ATTACHED IS OWNED BY THE
;SAME USER AS THE OWNER OF THE PTY CONTROLLING THE JOB DOING THE
;ATACH AND THE JOB DOING THE ATACH IS NOT YET LOGGED IN.
;ALSO, IF OWNER OF PTY IS AN ENABLED WHEEL OR OPR, JOB
;ON PTY MAY ALWAYS DO ATACH.
;ALSO, LEGAL IF OBJECT JOB IS OWNED BY ATACH-ER, DUE TO CRJOB.
;IN ADDITION, ATTACHING TO A JOB CONTROLLED BY BATCH IS ILLEGAL
;WITHOUT BEING LOGGED-IN WITH WHEEL OR OPR PRIVS ENABLED.

	HRRZ T1,Q1		;Get object Global job number
	MOVX T2,<-1,,T4>	;GETJI ARGUMENT POINTER
	MOVX T3,.JIBAT		;SEE IF UNDER CONTROL OF BATCH
	GETJI			;GET THE INFORMATION
	 SETZ T4,		;CONTINUE, CATCH THIS LATER
	JUMPL T4,[MOVE T2,JOBNO	;BATCH JOB.  USER MUST BE LOGGED-IN
		MOVX T1,SC%WHL!SC%OPR ; WITH WHEEL OR OPR ENABLED
		SKIPE JOBDIR(T2) ;TEST LOGIN
		TDNN T1,CAPENB	;IS LOGGED-IN, TEST CAPS
		 RETERR (CAPX1)	;NOT GOOD ENOUGH
		JRST .+1]	;OK, CONTINUE IN-LINE
	TXNE Q1,AT%NAT		;DOING ATACH OR UNATTACH?
	IFSKP.			;IF ATTACH
	 HRRZ T4,CTRLTT		;ASSUME THIS IS THE TTY #
	 TXNE Q1,AT%TRM		;IS IT A PROXY?
	 MOVE T4,Q3		;[7.1200] Yep
	 HRRZ T3,Q1		;Get global job number
	 GTOKM (.GOATJ,<T3,T4>,[RETERR()]) ;LET ACJ SNIFF THIS
	ENDIF.

	MOVE T3,ATACDR		;REFETCH OTHER USER NUMBER
	MOVE T2,JOBNO		;GET THIS JOB NUMBER
	HRRZ T2,JOBDIR(T2)	;GET USER NUMBER FOR THIS JOB
	CAMN T2,T3		;SAME AS OTHER JOB?
	JRST ATACH3		;YES, NO FURTHER LEGALITY CHECKS
	JUMPN T2,ATACH6		;PTY OWNER IS IRRELEVANT IF NOT LOGGED IN
	MOVE T1,CTRLTT		;SEE IF I AM ON A PTY
	JUMPL T1,ATACH6		;JUMP IF NO CONTROLLING TTY
	CALL PTGETJ		;GET CONROLLING JOB # OR -1
	JUMPL T1,ATACH6		;NON-PTY DOING THE ATACH IF -1
	HRRZ T4,JOBDIR(T1)	;T4 GETS OWNER OF PTY
	XCTU [HRRZ T3,T2]	;GET OWNER OF JOB BEING ATACHED
	CAMN T3,T4		;THE SAME?
	JRST ATACH3		;YES, SO NO PASSWORD NEEDED
	CALL GJCAPS		;GET CAPABILITIES OF OWNER OF PTY
	TXNE T1,SC%WHL+SC%OPR	;PRIVILEGED?
	JRST ATACH3		;YES, SO NO PASSWORD NEEDED
ATACH6:	MOVE T3,ATACDR		;GET DIR NUMBER
	MOVEI T1,SC%WHL+SC%OPR
	TDNE T1,CAPENB		;THIS USER HAS CAPS?
	JRST ATACH3		;YES, NO FURTHER CHECKS
	MOVE T1,ATACJN		;SEE IF I OWN THE JOB
	HRRZ T1,JOBONT(T1)	;OWNER FIELD
	CAMN T1,GBLJNO		;IS IT ME?
	JRST ATACH3		;YES, THEN IT'S LEGAL.
	UMOVE T1,2		;GET USER NUMBER FOR PASSWORD CHECK
	CALL CNVDIR		;GET USER'S LOGGED-IN DIRECTORY NUMBER
	UMOVE T2,T3		;GET PTR TO PASSWORD STRING
	TRNE T3,-1		;FAIL IF JOB NOT LOGGED IN
	CALL PASSWC		;PROPER PASSWORD?
	 JRST [ SKIPN T1	;NO, NEED TO SLEEP?
		CALL PASPEN	;YES
		RETERR(ATACX4)]	;NOW BOMB OUT

;USER HAS PROVEN RIGHT TO DO THIS. THE FOLLOWING DATA IS AVAILABLE:
;	JOBNO/ JOB NUMBER OF CALLER OF JSYS
;	CTRLTT/ TERMINAL AT WHICH CALLER IS RUNNING
;	ATACJN/ JOB NUMBER TO BE ATTACHED TO THIS TERMINAL

;USER WANTS TO ASSOCIATE THE JOB IN ATACJN WITH THE TERMINAL IN CTRLTT
;IF THE JOB IS CURRENTLY ATTACHED, IT MUST BE DETACHED FIRST

ATACH3:	TXNE Q1,AT%TRM+AT%NAT	;IS MY TTY TO BE USED?
	JRST ATACH9		;NOT BY DEFAULT, ANYWAY.
	SKIPGE Q3,CTRLTT	;[7.1200] Yes. Get my TTY
	RETERR ATACX2		;I DON'T HAVE ONE. FAIL.
ATACH9:	TXNN Q1,AT%TRM		;USING A DIFFERENT LINE?
	JRST ATACHB		;NO
	HRRZ T2,Q3		;YES, BETTER ASSIGN SOME DYNAMIC DATA
	NOSKED			;PREVENT STATE CHANGES
	CALL GTCJOB		;GET CONTROLLING JOB
	IFSKP.			;IF ACTIVE
	 CAIE T3,777777		;UNASSIGNED?
	 CAMN T3,JOBNO		;THIS JOB?
	 SKIPA			;UNASSIGNED OR ASSIGNED TO THIS JOB
	 RETERR (DEVX2,<OKSKED>)
	ENDIF.
	CALL TTYASC		;ASSIGN AS CONSOLE
	 RETERR(,<OKSKED>)
	OKSKED
ATACHB:	MOVE T1,ATACJN		;GET BACK OBJECT JOB NUMBER
	CALL MAPJSB		;SETUP OTHER JOB'S JSB
	 RETERR(ARGX08)		;NO SUCH JOB
	MOVEI Q2,0(T1)		;SAVE OFFSET FOR OTHER JOB'S JSB
	MOVE T2,ATACJN		;[7456] Load the other job's local job number 
	CALL DETREC		;[7456] (T1,T2/) Write sess rec for other job
	SKIPGE T2,CTRLTT(Q2)	;OTHER JOB NOW ATTACHED?
	JRST ATACH2		;NO. DON'T DETACH IT

;OBJECT JOB IS ATTACHED. DETACH IT FROM ITS CURRENT CONTROLLING
;TERMINAL AND DEALLOCATE THAT TERMINAL'S DATA

	MOVEM T2,ATACLN		;SAVE ITS CONTROLLING TERMINAL
	CALL LCKDVL		;LOCK DEVICE LOCK, GO NOINT
	NOSKED			;MUST DETACH IT FIRST
	CALL STADYN		;POINT TO DYNAMIC DATA
	 JRST ATACH7  		;NOT ACTIVE. DON'T DEASSIGN IT
	CALL TTFWAK		;WAKE FORK IN INPUT WAIT ON THIS LINE
	MOVE T2,ATACLN		;T2/ LINE NUMBER
	CALL TTYDAS		;DEASSIGN THE LINE
	 JRST [	PUSH P,T1	;SAVE THE ERROR CODE
		OKSKED
		CALL CLRLFK	;UNMAP THE JSB
		UNLOKK DEVLKK	;UNLOCK DEVICE LOCK
		OKINT		;LCKDVL WENT NOINT
		POP P,T1	;GET THE CODE BACK
		TXZN T1,1B0	;NEED TO WAIT?
		RETERR		;NO. RETURN FAILURE
		HRL T1,ATACLN	;T1/(LINE NUMBER,,ADDRESS OF TEST ROUTINE)
		MDISMS		;WAIT UNTIL DEALLOCATION IS POSSIBLE
		JRST ATACH3]	;TRY AGAIN
ATACH7:	SETOM CTRLTT(Q2)	;INDICATE JOB HAS NO CONTROLLING TERMINAL
	MOVE T1,ATACJN		;GET OBJECT JOB NUMBER
	HRROS JOBPT(T1)		;NO CONTROLLING TERMINAL AGAIN
	OKSKED
	UNLOKK DEVLKK		;UNLOCK DEVICE LOCK
	OKINT			;LCKDVL WENT NOINT
	MOVE T2,ATACLN		;T2/ LINE NUMBER OF DETACHED JOB
	MOVE T3,JOBNO		;GET THIS JOB NUMBER
	HRRZ T3,JOBDIR(T3)	;GET USER NUMBER FOR THIS JOB
	HRLI T3,USRLH		;MAKE IT BE A USER NUMBER
	MOVE T4,CTRLTT		;AND TTY # OF DETACHER
	HRRZ T1,Q1		;Get the global job number of object
	CALL DETMS1		;TELL JOB IT'S BEING DETACHED
	; ..

;OBJECT JOB HAS BEEN DETACHED. DETACH CALLER FROM CONTROLLING TERMINAL
;AND ATTACH OBJECT JOB TO THAT TERMINAL. DON'T DEALLOCATE THE DYNAMIC
;DATA FOR THE TERMINAL

	;..
ATACH2:	TXNE Q1,AT%NAT		;REQUESTED NO ATTACH?
	JRST ATACH4		;YES
	MOVEM Q3,ATACLN		;[7.1200] No, make sure line right
	MOVE T2,Q3		;[7.1200] Prepare for LDET2
	NOINT			; ..
	CAMN Q3,CTRLTT		;[7.1200] Need to give away my terminal?
	CALL LDET2		;YES, DETACH THIS JOB BUT KEEP DYNAMIC DATA
	NOSKED

;ASSIGN OBJECT JOB TO CORRECT TERMINAL

	MOVE T4,ATACJN		;GET OBJECT JOB
	MOVEM Q3,CTRLTT(Q2)	;[7.1200] Set CTRLTT in dest job
	HRLM Q3,JOBPT(T4)	;[7.1200] 
	MOVEI T1,.TTDES(Q3)	;[7.1200] T1/ Device Designator for terminal
	CALL CHKDES 		;GET INDEX TO DEVICE TABLES
	 BUG.(HLT,TTBAD1,JSYSM,SOFT,<Bad device designator for terminal at ATACH2>,,<

Cause:	The call to CHKDES failed.  This should not happen, since the terminal
	number involved comes from Q3, which is either the number of terminal
	controlling the job, or a user-supplied terminal number from the user's
	AC4.  If a user-supplied number is being used, it was range-checked by
	comparing it to NLINES.  If it is the number of the controlling
	terminal, the job was already verified to be attached somewhere, so
	this BUGHLT should not occur.
>)
	MOVE T1,ATACJN		;GET OTHER JOB NUMBER
	HRLM T1,DEVUNT(T2)	;INDICATE OTHER JOB OWNS THE TERMINAL
	MOVE T2,ATACLN		;T2/ TERMINAL NUMBER
	MOVE T1,TTSPSI(Q2)	;T1/ INTERRUPT WORD FOR OTHER JOB
	MOVE T3,TTSDPS(Q2)	;T3/ DEFERRED INTERRUPT WORD FOR OTHER JOB
	CALL TTSINT		;SET INTERRUPT WORDS FOR THIS TERMINAL
	MOVE T1,ATACJN		;T1/ OTHER JOB
	CALL STCJOB		;SET THIS AS CONTROLLING THE TERMINAL
	OKSKED
	OKINT
	CALL CLRLFK		;CLEAR MAPPING OF JSB
	HRRZ T1,Q1		;Get the global job number of object
	MOVE T2,ATACLN		;SET UP JOB/LINE INFO
	CALL ATAMSG		;DO LOGGING STUFF
	MOVE T1,JOBNO
	HRRE T1,JOBDIR(T1)
	JUMPE T1,LOGO		;VANISH IF NOT LOGGED IN
	SMRETN

;HERE IF CALLER REQUESTED "NO ATTACH", I.E. DETACHING REMOTE JOB

ATACH4:	CALL CLRLFK		;CLEAR MAPPING OF JSB
	HRRZ T1,Q1		;Get the global job number of object
	MOVE T2,ATACLN		; AND LINE #
	CALL DETMS0		;DO LOG MSG AND FACT FILE ENTRY
	SMRETN

	ENDSV.			;END STKVAR
	SUBTTL LGOUT JSYS
;LOGOUT

.LGOUT::MCENT
	CAME 1,[-1]		;SELF?
	JRST ELOGO		;NO

;Here if logging out my own job

	MOVSI 1,(SC%LOG)
	TDNN 1,CAPMSK		;LOG PERMITTED?
	RETERR (LOUTX4)		;NO, ERROR RETURN
	SETONE JSELO		;FLAG THAT JOB EXECUTED ITS OWN LGOUT
LOGO::	SE1ENT			;[7.1200] Get to section 1
	MOVE T1,JOBNO		;GET CORRECT JOB NUMBER
	CALL LGOGOK		;CHECK TO SEE IF LOGO LEGAL
	SKIPN FORKN		;TOP FORK?
	JRST FLOGO1		;YES
	NOINT
	HLRZ 1,FORKN		;NO, GET ITS NUMBER
	HRRZ 2,SYSFK(1)
	NOSKED
	SETONE <FKPS0,FKILO>,(T2) ;REQUEST LOGOUT INTERRUPT
	CALL PSIR4
	OKSKED
	OKINT
	JRST WAIT1		;WAIT FOR TOP FORK TO KILL THE JOB
	SUBTTL LGOUT JSYS -- Logout Another Job

;THE FOLLOWING IMPLEMENTS LOGOUT OF A JOB OTHER THAN SELF.
;LEGAL IF USER IS SC%WHL OR SC%OPR, OR IF OTHER JOB IS SAME USER

ELOGO:	MOVE T2,GBLJNO		;GIVEN JOB NUMBER TO LOGOUT
	CAIN T2,0(T1)		;SELF?
	RETERR(LOUTX1)		;YES, CAN'T SAY IT THAT WAY
	JUMPE T1,[RETERR (LOUTX5)] ;CANNOT LOGOUT JOB 0
	CALL GL2LCL		;CONVERT GLOBAL JOB NUMBER TO LOCAL INDEX
	 RETERR(LOUTX2)		;ILLEGAL JOB NUMBER
	MOVE P1,T1		; preserve target job index
	CALL LGOGOK		;GETOK CHECK
	NOSKED			; prevent races
	SKIPGE JOBRT(P1)	;EXISTS?
	RETERR(LOUTX2,OKSKED)	; no, fail
	MOVE T1,P1		; target job index
	CALL SETJSB		; map its JSB
	MOVE P2,T1		; preserve JSB address
	HRRZ T3,JOBDIR(P1)	;LOGIN DIRECTORY OF OBJECT JOB
	MOVE T1,JOBNO		; our job number
	XOR T3,JOBDIR(T1)	; our directory number
	TRNN T3,-1		;SAME AS THIS JOB?
	JRST ELOGO1		;YES, THAT'S OK
	HLRE T1,JOBPT(P1)	;GET TTY OF THE JOB BEING LOGGED OUT
	JUMPL T1,ELOGO3		;JUMP IF DETACHED
	CALL PTGETJ		;GET CONTROLLING JOB # IF TTY IS A PTY
	JUMPL T1,ELOGO3		;JUMP IF NOT A PTY JOB
	CAMN T1,JOBNO		;JOB BEING CONTROLLED BY JOB DOING THE LGOUT
	JRST ELOGO1		;YES, SO DO IT
ELOGO3:	HRRZ T3,JOBONT(P1)	;DO I OWN THAT JOB IN CRJOB SENSE?
	CAMN T3,GBLJNO		;JOBONT contains global job numbers
	JRST ELOGO1		;YES. OK TO LOG IT OUT.
	MOVEI T3,SC%WHL+SC%OPR	;OTHERWISE MUST BE SC%WHL
	TDNN T3,CAPENB
	JRST [	CALL CLRJSB		; unmap the JSB
		RETERR(LOUTX3,OKSKED)]	; quit

;Here when we are certain that it is OK to murder the target job

ELOGO1:	SETOM JOBONT(P1)	;MAKE IT UNOWNED SO IT CAN LOG OUT
	SETONE JSOLO,(P2)	;FLAG IN IT THAT SOMEONE LGOUT'ED IT
	MOVE T1,JOBNO		;AND WHO IT WAS
	MOVEM T1,JSLOJB(P2)	; ..
	MOVE T1,P1		; target job number
	CALL ELOGOO		;[7.1260] (T1/) Set PSI to logout target job
	SKIPGE T2,CTRLTT(P2)	;[7.1260] Does job have a controlling terminal?
	IFSKP.			;[7.1260] Yes, we need to clear output buffers
	  CALL LCKTTY		;[7.1260] (T2/T2) Prevent deallocation
	   CAIA			;[7.1260] Couldn't lock, skip over buffer clear
	  CALL TTCOBF		;[7.1260] (T2/) Clear output buffers
	  CALL ULKTTY		;[7.1260] (T2/) Counteract the LCKTTY
	ENDIF.			;[7.1260] 
	CALL CLRJSB		;[7.1260] () Let go of the JSB
	OKSKED
	SMRETN			;AND DONE
	SUBTTL LGOUT JSYS -- Set PSI to Logout Another Job

;ROUTINE CALLED TO LOGOUT ANOTHER JOB.
;ACCEPTS:	A/ JOB NUMBER
;RETURNS:	+1 WITH LOGOUT REQUESTED

	RESCD			;MUST BE RESIDENT AS CALLED BY SCHEDULER

ELOGOO::NOSKD1			; prevent races
	SKIPGE JOBRT(T1)	; job exist?
	JRST [	OKSKD1		; no, fail
		RET]		;  ..
	HRRZ 2,JOBPT(1)		;TOP FORK OF OBJECT JOB
	SETONE <FKPS0,FKILO>,(T2) ;REQUEST LOGOUT INTERRUPT
	CALL PSIR4
	OKSKD1			;ALLOWING SCHEDULING AGAIN
	RET			;AND DONE

	SWAPCD
	SUBTTL LGOUT JSYS -- Perform Logout

;THE FOLLOWING IS RUN IN THE TOP FORK OF A JOB TO RESPOND TO
;A LOGOUT REQUEST FROM ANOTHER JOB.
;HERE FROM PSI SERVICE DEBREAK.  FFL AND FPC SETUP.

FLOGO::	MCENTR			;SIMULATE ENTRY FROM USER

;THE FOLLOWING CODE DOES THE ACTUAL LOGOUT.  IT RUNS ONLY IN
;THE TOP FORK OF THE JOB BEING LOGGED OUT

FLOGO1::MOVX 1,LOGIOB		;[7.1200] Say job destruction in progress
	IORM 1,JOBBIT

	MOVE T1,JOBNO		;GET OUR JOB NUMBER
	HLRZ T1,JOBPT(T1)	;GET A POSSIBLE CRJOB INDICATOR
	CAIE T1,-2		;IS THIS THE OBJECT OF A CRJOB?
	SKIPGE CRJFLG		;NO, TRY DIFFERENT TEST
	 SETOM CRJANS		;YES, FORCE EXECUTOR OF CRJOB JSYS TO WAKE UP.

	MOVEI 1,400000
	SETO 2,
	DIC			;DEACTIVATE INTERRUPTS AND KEYS
	CALL DTIALL
	CALL NETLGO		;RELEASE ANY JOB-WIDE NETWORK RESOURCES
	CALL INTLGO		;RELEASE ANY JOB WIDE INTERNET RESOURCES
	CALL DAPLGO		;RELEASE ANY JOB-WIDE DAP% RESOURCES
	MOVE T1,FORKX		;GET FORK NUMBER OF TOP FORK
	CALL SCSLGO		;RELEASE ANY SCS% RESOURCES OWNED BY TOP FORK
	MOVEI T1,-4
	KFORK			;DELETE FORKS
	MOVE T1,JOBNO		;MARK THAT I AM NO LONGER OWNED
	SETOM JOBONT(T1)	; ..
	MOVSI T3,-NJOBS		;LOG OUT ANY JOBS WHICH I OWN
SJLGO1:	HRRZ T2,JOBONT(3)	;DO I OWN THIS ONE?
	CAME T2,GBLJNO		; ..
	 JRST SJLGO2		;NO.
	SETOM JOBONT(T3)	;MAKE IT UNOWNED, SO IT FINISHES
	MOVEI T1,0(T3)		;YES. LOG IT OUT.
	CALL LCL2GL		;Convert his index into a global job number
	 JRST SJLGO2		;and go back to the loop
	LGOUT
	 JFCL			;SHOULD HAVE WORKED.
SJLGO2:	AOBJN T3,SJLGO1		;SEE IF I OWN ANY MORE JOBS

SJLGO4:	SETO T1,		;CLEAR USER MAP OF TOP FORK
	MOVSI 2,<.FHSLF!FH%EPN>	;THIS FORK
	MOVE 3,[PM%CNT!PM%EPN!<1000>B35] ;REQUEST 1000 PAGES
	PMAP
	 ERJMP .+1
	MOVE Q3,FORKX		;[7.1200] 
	RESET			;CLEAN UP JSB STACK
	LOAD T1,FKJS%,(Q3)	;[7.1200] Get JSB
	CALL WTSPT		;WAIT FOR SHR CNT OF 1
	SKIPL CTRLTT
	RESET			;RESET TTY MODES, ETC.
	CALL UNPAGE		;CLEAR PAGE MODE
	MOVE T1,FORKX		;THIS FORK...
	CALL ENQFKR		;RELEASE ANY ENQ LOCKS OWNED BY THIS JOB
	MOVE 1,[CZ%ARJ+CZ%ABT+400000] ;WAIT+FLUSH NONX + THIS FORK
	CLZFF
IFE FTNSPSRV,<
	CALL SCLGOU        	;CLEAN UP DECNET SJB, PORT TABLE, AND SAB
	CALL LLMRJB		;[7173] ~6.0 Release LLMOP Request Blocks for this job
>
	MOVE 1,FORKX		;NOW KILL PIDS OF THIS FORK
	CALL PIDKFK		; INCLUDING JOB WIDE PIDS
	CALL CLKREL		;RELEASE TIMER BLOCKS
	MOVE T1,JOBNO		;[7.1006] Load this job's local job number
	SKIPE T1,JOBDIR(T1)	;[7.1006] Is this job logged in?
	IFSKP.			;[7.1006] If job is not logged in
	  CALL SESRES		;[7.1006] Compute times for LOGUSD
	  JRST LOG1		;[7.1006] Don't do expunge or accounting
	ENDIF.			;[7.1006] Otherwise do the expunge/accounting
	HRLI T1,USRLH		;GET USER NUMBER
	CALL CNVDIR		;CONVERT IT TO A DIRECTORY NUMBER
	MOVE T2,T1		;SET UP FOR DELDF
	MOVX T1,DD%DTF		;DELETE TEMPORARY FILES
	PUSH P,T2		;SAVE DIR NUMBER
	DELDF			;EXPUNGE LOGIN DIR
	 ERJMP .+1		;DONT STOP ON ERRORS
	CALL GTCSCD		;GET CONNECTED STRUCTURE,,DIRECTORY
	POP P,T3		;GET BACK DIR # FROM LAST DELDF
	CAMN T1,T3		;ARE THEY THE SAME?
	JRST LOG0		;YES, DO NO EXPUNGE AGAIN
	MOVE T2,T1		;GET DIR NUMBER INTO 2
	MOVX T1,DD%DTF		;DELETE TEMPORARY FILES
	DELDF			;EXPUNGE CONNECTED DIR
	 ERJMP .+1		;DONT STOP ON ERRORS

;[7.1260] Here after expunge to decrement mount counts then write usage info

LOG0:	CALL LOGSTR		;GO DECREMENT MOUNT COUNT FOR ALL STR'S
				; THIS JOB HAS MOUNTED
	MOVNI 1,1		;NOW RELEASE ALL ASSIGNED DEVICES
	RELD
	 JFCL
	CALL SESRES		;[7456] Reset this job's session
	MOVE T1,LOGDES		;[7456] Load the logging designator
	CALL LOGTOT		;SUMMARY TO LOG TTY
	CALL LOGTUS		;Perform USAGE for logout

;[7.1260] Here after accounting and expunge has been done to print logout mess.

LOG1:	HRRE 1,CTRLTT
	JUMPL 1,LOG2		;CONTROL TTY?
	MOVEI 1,400000(1)	;YES, PRINT LOGOUT MESSAGE
	RFMOD			;TURN OFF PAGE MODE
	 ERJMP .+1		;ignore errors
	TXZ 2,TT%PGM		;TO ALLOW THE MESSAGE TO COME OUT
	STPAR
	 ERJMP .+1		;ignore errors
	CALL LOGTOT		;[7.1230] (T1/) Spit out the logout message
	SKIPGE CTRLTT		;[7.1230] Is job detached?
	JRST LOG2		;[7.1230] Yes, no terminal to mess with
	CALL BLINKS		;[7.1230] () Break links and advice

;[7.1260] Wait for logout message to complete, time out if it takes too long

	MOVEI T4,^D15		;WAIT FOR 15 SECONDS MAX
LOG21:	HRRE T1,CTRLTT		;GET TTY #
	JUMPL T1,LOG2		;NONE
	MOVEI T1,.TTDES(T1)	;[7.1230] Get designator
	SOBE			;LOGOUT MESSAGE COMPLETE?
	IFNSK.
	  MOVEI T1,^D1000	;NO, WAIT A SECOND
	  DISMS
	  SOJG T4,LOG21		;TRY AGAIN OR GIVE UP
	ENDIF.
	SKIPGE T1,CTRLTT	;[7.1260] Any controlling terminal here
	JRST LOG2		;[7.1260] Nope
	TXO T1,.TTDES		;[7.1260] Make a terminal designator for it
	CFOBF%			;[7.1260] Flush output buffer for good measure
	 ERJMP .+1		;[7.1260] Ignore errors

;[7.1260] Here to hang up connection depending on variables set by x-SETSPD.

	SKIPGE T2,CTRLTT	;[7.1260] Controlling terminal?
	JRST LOG2		;[7.1260] Detached, don't try to hang up line
	MOVE T1,JOBNO		;[7.1260] Get local job number
	SKIPE JOBDIR(T1)	;[7.1260] Job logged in?
	IFSKP.			;[7.1260] Nope, job is not logged in
	  SKIPE HNGU0F		;[7.1260] Hangup if not logged in?
	  CALL TTHNGU		;[7.1260] (T2/) Hangup line
	ELSE.			;[7.1260] Yes, job is logged in
	  SKIPE HNGU1F		;[7.1260] Hangup if not logged in?
	  CALL TTHNGU		;[7.1260] (T2/) Hangup line
	ENDIF.			;[7.1260]

;[7.1051] Here after job's logout message printed and line is hung up,
;[7.1051] or the job is detached.

LOG2:	MOVEI T1,SPIDTB+.SPQSR	;GET PID ADDRESS
	SKIPE SPIDTB+.SPQSR	;IS QUASAR RUNNING?
	CALL LOGOMS		;YES, SEND IT A MESSAGE
	 JFCL
	MOVEI T1,SPIDTB+.SPOPR	;GET ORION PID ADDRESS
	SKIPE SPIDTB+.SPOPR	;RUNNING?
	CALL LOGOMS		;YES, SEND IT A MESSAGE
	 JFCL
	SKIPE T1,JSLOPD		;IS THERE A PID IN JSB FOR LGOUT MSG?
	CALL KJOMO		;[7.1034](T1/) Send LOGOUT message to creator
	 JFCL

;[7.1051] If this is the lowest job on the system, get next highest or 0

LOG3:	MOVE T2,GBLJNO		;[7.1051] Get global job number
	HLRZ T1,ACTJOB		;[7.1051] Get lowest job number
	CAMLE T2,T1		;[7.1051] Skip if this is lowest job
	JRST LOG4		;[7.1051] Not the lowest job
LOG3A:	AOS T1,T2		;[7.1051] Get the next highest job
	CAILE T1,MXGLBS		;[7.1051] Have we hit the top?
	SETZ T1,		;[7.1051] Yes, get job number 0
	CALL GL2LCL		;[7.1051] (T1/T1) Is this a job number?
	 JRST LOG3A		;[7.1051] Loop more if error
	HRLM T2,ACTJOB		;[7.1051] Store this job or 0 as the lowest
	MOVE T2,GBLJNO		;[7.1051] Load the global job number

;[7.1051] If this is the highest job on the system, get next lowest or 0

LOG4:	HRRZ T1,ACTJOB		;[7.1051] Get highest job number
	CAMGE T2,T1		;[7.1051] Skip if this is the highest
	JRST LOG5		;[7.1051] Nope, continue below
LOG4A:	SOS T1,T2		;[7.1051] Get the next lower job or 0
	CALL GL2LCL		;[7.1051] (T1/T1) Is this a job number?
	 JRST LOG4A		;[7.1051] Loop more if error
	HRRM T2,ACTJOB		;[7.1051] Store this job or 0 as the lowest

;[7.1051] Give this global job number back to CFS, then count down the number
;[7.1051] of operator or non-operator jobs.

LOG5:	MOVE T1,GBLJNO		;[7.1051] Get our global job number
	CALL JBAVAL		;[7.1051](T1/) Tell CFS to release it
	MOVE T2,JOBNO		;[7.1051] Get my job number
	SKIPN T2,JOBDIR(T2)	;[7.1051] Get my user number
	JRST HLTJB		;[7.1051] Don't count down if not logged in
	CAMN T2,JOBDIR		;[7.1051] Is it the operator?
	SKIPA T2,[-1,,0]	;[7.1051] Yes, it is it an operator
	MOVNI T2,1		;[7.1051] No, it is a user
	ADDM T2,WHOJOB		;[7.1051] Count down this job
	JRST HLTJB		;[7.1051] Flush this job
	SUBTTL LGOUT JSYS -- Perform GETOK for LGOUT

LGOGOK:	SAVET
	HRRZ T1,JOBDIR(T1)	;DIRECTORY
	JUMPE T1,R		;QUIT NOT LOGGED IN
	HRLI T1,USRLH
	CALL CNVDIR		;GET DIRECTORY NUMBER
	GTDAL			;GET ALLOCATION
	ERJMP R			;QUIT SOME ERROR
	UMOVE T1,T1		;GET ORIG ARGUMENT
	GTOKM (.GOLGO,<T2,T3,T1>,[RETERR ()]) ;[7414] Ask permission and deny if necessary
	RET			;RETURN TO CALLER
	SUBTTL LGOUT JSYS -- Decrement Mount Counts

;LOGSTR - ROUTINE TO DECREMENT MOUNT COUNT FOR ALL STRUCTURES THIS
;	  JOB HAS MOUNTED.
;
;CALL:		CALL LOGSTR
;RETURNS: +1 ALWAYS

LOGSTR:	SAVEP
	LOCK JSSTLK		;LOCK THE JSB STRUCTURE INFO DATA
	MOVSI P1,-STRN		;SET UP TO LOOP OVER STR INFO BLOCKS IN JSB
	MOVEI P2,JSSTRT		;GET ADDRESS OF FIRST BLOCK TO LOOK AT

LGST10:	JE <JSMCI,JSXCL>,(P2),LGST20 ;IF THIS JOB DIDN'T MOUNT THIS STR, CHECK NEXT
	LOAD T1,JSSTN,(P2)	;GET UNIQUE CODE FOR THIS STRUCTURE
	CALL CNVSTR		;GET STRUCTURE # AND LOCK THE STRUCTURE
	 JRST LGST20		;FAILED, MUST ALREADY BE DISMOUNTED, GO ON
	MOVEM T1,P3		;SAVE STRUCTURE NUMBER
	JN JSXCL,(P2),[	MOVX T1,D1%INI ;IF MOUNTED EXCLUSIVELY BY THIS JOB,
			ANDCAM T1,DEVCH1+DVXST0(P3) ; MAKE STR GENERALLY AVAILABLE
			JRST .+1]
	JE JSMCI,(P2),LGST15	;IF MOUNT COUNT NOT INCREMENTED, GO UNLOCK STR
	MOVE T1,P3		;GET STRUCTURE NUMBER AGAIN
	MOVE T2,P2		;GET ADDRESS OF STR INFO BLOCK IN JSB
	MOVE T3,JOBNO		;GET JOB NUMBER
	CALL DECMNT		;GO DECREMENT THE MOUNT COUNT FOR THIS STR
	 JFCL			;IGNORE FAILURE, GO ON
LGST15:	MOVE T1,P3		;RESTORE STRUCTURE NUMBER
	CALL ULKSTR		;UNLOCK THE STRUCTURE NOW
LGST20:	ADDI P2,JSSTMX		;GET ADDRESS OF NEXT STR INFO BLOCK IN JSB
	AOBJN P1,LGST10		;GO CHECK NEXT STR INFO BLOCK

	UNLOCK JSSTLK		;DONE, UNLOCK THE JSB STR INFO LOCK
	RET			;RETURN
	SUBTTL Session Logging Functions

;LOGGING FUNCTIONS

;[7456] LOGTOT - Type logout message
;[7456]
;[7456] Call with: T1/ destination designator
;[7456] Returns: +1 always
;[7456] Clobbers: T2

LOGTOT::SKIPE T2,JSLOJB		;Did someone else log out this job?
	CALL LOGTOK		;(T1/T1) Yes - inform the victim
	HRROI T2,[ASCIZ /Killed/] ;Load the usual identification string
	CALLRET LOGUSD		;(T1,T2/T1) Log job and time used info,
				; and return from LOGTOT

;[7456] LOGTOK - Subroutine to tell a victim who logged out his job
;[7456]
;[7456] Call with:
;[7456] 	T1/ destination designator
;[7456]		T2/ murdering job
;[7456] Returns: +1 always
;[7456] Clobbers: T2, T3

LOGTOK:	CALL LOGDOB		;(T1/T1) Check designator and do a DOBE
	 RET			;Return now if output discarded
	STKVAR <MURDER>		;Place to save the job's murderer
	MOVEM T2,MURDER		;Save job number of murderer
	HRROI T2,[ASCIZ /Killed by /] ;Load the string identifying murderer
	CALL LOGMES		;(T1,T2/T1) Print that
	MOVE T2,MURDER		;Get killer's job number back
	SKIPN T2,JOBDIR(T2)	;[7.1006] Load the killer's user number
	JRST LOGTK1		;[7.1006] Don't try DIRST if not logged in
	HRLI T2,USRLH		;Else make that into a user number 
	DIRST			;Output the username to the destination
	 ERJMPS LOGTK1		;Ignore error, preserve pointer in T1
LOGTK1:	MOVE T2,MURDER		;Reload the murdering job
	HLRE T2,JOBPT(T2)	;Get controlling terminal of that job
	JUMPL T2,LOGTK2		;If job is detached then don't say anything
	MOVEM T2,MURDER		;Save murdering terminal number
	HRROI T2,[ASCIZ /, TTY /] ;Load the usual identification string
	CALL LOGMES		;(T1,T2/T1) Output that to the terminal
	MOVE T2,MURDER		;Get terminal number of the killer again
	MOVEI T3,^D8		;Load the octal radix we desire
	CALL LGNOUT		;(T1,T2,T3/T1) Output that octal number
LOGTK2:	CALLRET	LOGCR		;(T1/T1) Output a CRLF and return

;Perform USAGE for logout, called from LOG0
;Returns +1: always
;Clobbers: T1, T2

LOGTUS:	MOVEI T1,.USLGO		;LOGOUT FUNCTION
	MOVEI T2,LOGLST
	USAGE			;USAGE JSYS
	 ERJMP XUSAGE		;REPORT FAILURE
	RET			;Return from LOGTUS

;[7456] LOGONM - Called from .LOGIN, does login USAGE function, prints message
;[7456]
;[7456] Returns: +1 always
;[7456] Clobbers: T1, T2

LOGONM::MOVE T1,LOGDES		;Load the logging designator
	CALL LOGDOB		;(T1/T1) Check designator and do a DOBE
	 JRST LOGON1		;Just do the USAGE if output discarded
	HRROI T2,[ASCIZ /Login/] ;Load the string identifying login being done
	CALL LOGMES		;(T1,T2/T1) And output that to logging terminal
	CALL LOGJOB		;(T1/T1) Print it as usual
	CALL LOGCR		;(T1/T1) and finish it with a CRLF
LOGON1:	MOVEI T1,.USLGI		;Load the login function for USAGE
	MOVEI T2,LOGLST		;Point to the usual parameter list
	USAGE			;Set up the checkpoint file and so on
	 ERJMP XUSAGE		;Report USAGE failure and return
	RET			;Return to caller

;[7456] XUSAGE - A small routine to output UXXFAI BUGCHK

XUSAGE:	BUG.(CHK,UXXFAI,JSYSM,HARD,<USAGE JSYS failure>,,<

Cause:	The monitor attempted to perform a USAGE% call to log either a
	login, logout, or session entry and it failed. There is no
	reasonable explanation for the failure of this JSYS call.
>)
	RET			;CONTINUE

;PARAMETER BLOCK FOR LOGIN/LOGOUT/SESSION CHANGE CALLS

;[7456] LOGLST - List of entries for session records, most items are defaulted

LOGLST:	USENT. (.UTSEN,1,1)	;Session entry type
	USTAD. (JSSCTI)		;Date-time of this entry
	USACT. (<-1,,ACCTSR>)	;[7.1006] Account
	USCOM. (<-1,,JSSRM+1>)	;Session remark
	USRTM. (JBRUNT)		;Run time
	USCCT. (CONCON)		;Console connect time
	USSST. (CTIMON)		;Session start date/time
	USBJN. (JBBNAM)		;Batch job name
	USBSN. (JBBSEQ)		;Batch seq number
	USBRI. (BATRID)		;Batch request ID
	USPNM. (<SIXBIT "MONITR">,US%IMM) ;Program name is MONITR
	USPVR. ([EXP SVNM])	;Program version is monitor version
	0			;End of list

;[7456] LOGLSD - List of entries written to usage file for detached jobs
;[7456] NOTE: if SETJSB (FORK.MAC) maps the JSB into anywhere but FPG1A,
;[7456]       then the computation used below for LSD must be changed.

	LSD==JSBPGA-FPG1A	;Offset to other PSB
LOGLSD:	USENT. (.UTSEN,1,1)	;Session entry type
	USTAD. (JSSCTI-LSD)	;Date-time of this entry
	USJNO. (P2)		;Global job number 
	USNM2. (<-1,,USRNAM-LSD+1>) ;[7.1006] User name
	USACT. (<-1,,ACCTSR-LSD>) ;Account
	USCOM. (<-1,,JSSRM-LSD+1>) ;Session remark
	USLNO. (CTRLTT-LSD)	;Terminal number
	USNOD. (P3)		;Location
	USRTM. (JBRUNT-LSD)	;Run time
	USCCT. (CONCON-LSD)	;Console connect time
	USSST. (CTIMON-LSD)	;Session start date/time
	USBJN. (JBBNAM-LSD)	;Batch job name
	USBSN. (JBBSEQ-LSD)	;Batch seq number
	USBRI. (BATRID-LSD)	;Batch request ID
	USJTY. (P4)		;Batch or timesharing flag
	USPNM. (<SIXBIT "MONITR">,US%IMM)
	USPVR. ([EXP SVNM])	;Monitor name and version
	0			;End of list


;[7456] DETSES - Call here before job detached or account number changed to 
;[7456]          output a little message and write accounting information using
;[7456]		 using USAGE JSYS.  Resets session information in JSB.
;[7456] Returns: +1 always

DETSES:	SAVET			;Save the temps
	HRROI T2,[ASCIZ/Detached/] ;Load message to type
	JRST LOGCJ1		;Enter common code below

;[7456] LOGCJM - Call before changing account or session remark for a job.
;[7456]		 Resets session information in JSB
;[7456] Returns: +1 always

LOGCJM::SAVET			;Save the temps
	HRROI T2,[ASCIZ /Changed/] ;Load message for account change
LOGCJ1:	MOVE T1,JOBNO		;[7.1006] Load the internal job number
	SKIPN JOBDIR(T1)	;[7.1006] Accounting for this job?
	RET			;[7.1006] Not for not logged in jobs
	CALL SESRES		;[7.1006] (/) Reset this job's session info
	MOVE T1,LOGDES		;Load the logging designator
	CALL LOGUSD		;(T1,T2/) No, log job number and time
	MOVEI T1,.USSEN		;Load the session entry code
	MOVEI T2,LOGLST		;Point to the argument block
	USAGE			;(T1,T2/) Make the accounting entry
	 ERJMP XUSAGE		;Report USAGE failure and return
	RET			;Return from LOGCJM

;[7.1272] DETREC - Routine to write session entry for a job possibly my own
;[7.1272]
;[7.1272] Call with: JSB of other job already mapped into FPG1A if not my job
;[7.1272]	T1/ offset to the other jobs JSB (or 0 if current job)
;[7456]		T2/ local job number
;[7456] Returns: +1 always

DETREC:	JUMPE T1,DETSES		;[7.1272] If called for this job use DETSES
	SKIPN JOBDIR(T2)	;[7.1006] Is this job logged in?
	RET			;[7.1006] Not logged in so no accounting
	SAVEP			;Save us P1-P4 for use
	SAVET			;Be nice and save the temps too
	DMOVE P1,T1		;Save the JSB offset and local job number
	CALL SESRE1		;(T1,T2) Compute session stats for other job
	MOVE T1,LOGDES		;Load the log designator
	HRROI T2,[ASCIZ/Checkpointing/] ;Load the labelling string for LOGUS1
	CALL LOGUS1		;(T1,T2,P1,P2/) Output job information
	MOVE T1,P2		;Get the local job number back
	CALL LCL2GL		;(T1/T1) Get the global job number 
	 SETZ T1,		;Shouldn't return an error here
	MOVE P2,T1		;Copy the global job number here for USAGE
	MOVX T1,OB%BSS		;Get batch stream set flag
	TDNN T1,BATSTF(P1)	;Is this a batch job?
	TDZA P4,P4		;No it is not
	SETO P4,		;Yes it is
	HRROI T1,LLSR-1(P1)	;Point to job's location
	CALL ASCSIX		;(T1/T1) Convert to SIXBIT
	 TDZA P3,P3		;If error, use zero
	MOVE P3,T1		;Copy sixbit to P3
	MOVEI T1,.USSEN		;Write session entry record function
	MOVEI T2,LOGLSD		;Point to the argument block
	USAGE			;(T1,T2/) Write the usage record
	 ERJMP XUSAGE		;BUGCHK if it was owie and return
	RET			;Return to caller of DETREC

;[7456] LOGUSD - Print job number, username, terminal, time used
;[7456]
;[7456] Call with:
;[7456]		T1/ destination designator for output
;[7456]         T2/ pointer to ASCIZ message type
;[7456] Returns: +1 always
;[7456] Clobbers: T2

LOGUSD:	SAVEP			;Save two ACs for our use today
	SETZ P1,		;Clear offset to JSB
	MOVE P2,JOBNO		;Load the local job number

LOGUS1:	CALL LOGDOB		;(T1/T1) Check designator and do a DOBE
	 RET			;Return now if output discarded

	CALL LOGMES		;(T1,T2/T1) Print message type
	MOVE T2,CTRLTT(P1)	;Get controlling terminal number
	CALL LOGJO1		;(T1,T2,P1,P2/T1) Type job and terminal info

	HRROI T2,[ASCIZ /,  Used /] ;Begin to output the
	CALL LOGMES		;(T1,T2/)  run time used message
	MOVE T2,JSSRTM(P1)	;[7.1006] Load the session run time
	CALL LOGTIM		;(T1,T2/) Print run time

	HRROI T2,[ASCIZ / in /]	;Point the console connect time next
	CALL LOGMES		;(T1,T2/) Output to terminal
	MOVE T2,JSSCTM(P1)	;Load the console connect time
	CALL LOGTIM		;Print console connect time

	MOVE T2,CONCON(P1)	;Load console connect time
	MOVE T3,JBRUNT(P1)	;Load the run time 
	CAMN T3,JSSRTM(P1)	;Is the run time equal to the session run time
	CAME T2,JSSCTM(P1)	; and connect time equal to session connect?
	IFNSK.			;If the connect or run time don't match
	 HRROI T2,[ASCIZ /,
  Used this session /]		;Output the session runtime
	 CALL LOGMES		;(T1,T2/)
	 MOVE T2,JBRUNT(P1)	;Get session time
	 CALL LOGTIM		;Print it
	 HRROI T2,[ASCIZ / in /] ;Output the console connect time
	 CALL LOGMES		;(T1,T2/)
	 MOVE T2,CONCON(P1)	;Get console time this session
	 CALL LOGTIM		;Print it
	ENDIF.
	CALLRET LOGCR		;Finish with CRLF

;[7456] SESRES - Does session time calculations.
;[7456] Call at SESRES to do session time calculations for current job
;[7456]
;[7456] Call at SESRE1 with
;[7456]		T1/ JSB offset (or zero for current job)
;[7456]		T2/ local job number
;[7456] Returns: +1 always

SESRES:	SAVET			;Save T1-T4 for our use today
	MOVE T2,JOBNO		;Load this job's local job number
	TDZA T1,T1		;Set offset to zero for this job
SESRE1:	SAVET			;Enter here T1/JSB offset and T2/local job num
	MOVE T3,T1		;Copy the JSB offset to T3
	MOVE T1,JOBRT(T2)	;Get runtime of job
	SUB T1,JSSRTM(T3)	;Compute session runtime
	MOVEM T1,JBRUNT(T3)	;Save for USAGE
	ADDM T1,JSSRTM(T3)	;Begin a new runtime session
	MOVE T1,TODCLK		;Get current uptime
	SUB T1,CONSTO(T3)	;Compute console time logged in
	SUB T1,JSSCTM(T3)	;Compute console time this session
	MOVEM T1,CONCON(T3)	;Save console time for USAGE
	ADDM T1,JSSCTM(T3)	;Begin a new connect time session
	MOVE T1,JSSCTI(T3)	;Load the session start time
	MOVEM T1,CTIMON(T3)	;Save time session started for USAGE
	CALL LGTAD		;(/T1,T2) Get the current time
	MOVEM T1,JSSCTI(T3)	;Store this session's start time
	RET			;Return from SESRES

;[7456] LOGTIM - routine to print time from milliseconds in T2
;[7456]
;[7456] Call with:
;[7456] 	T1/ output designator
;[7456]		T2/ time in milliseconds
;[7456] Returns: +1 always
;[7456] Clobbers: T2, T3

LOGTIM:	IDIVI 2,^D1000		;[7456] milliseconds in T2 to seconds in T2
	IDIVI 2,^D60		;PEEL OFF SECONDS
	PUSH P,3
	IDIVI 2,^D60		;PEEL OFF MINUTES
	PUSH P,3
	CALL LOGNUM		;PRINT HOURS
	MOVEI 2,":"
	BOUT
	 ERJMP .+1		;NOTHING ELSE TO DO
	POP P,2
	CALL LOG2NM		;PRINT MINUTES
	MOVEI 2,":"
	BOUT
	 ERJMP .+1		;NOTHING ELSE TO DO
	POP P,2
	CALL LOG2NM		;PRINT SECONDS
	RET

;ATACH AND DETACH MESSAGES

;[7456] DETMS0 - called when a job is detached to type info on logging terminal
;[7456]
;[7456] Call with:
;[7456] 	T1/ global job number
;[7456]		T2/ line number
;[7456] Returns: +1 always
;[7456] Clobbers: T1, T2, T3

DETMS0:	ASUBR <ATAJN,ATALN>	;JOB # , LINE #
	MOVE T1,LOGDES		;Load the logging designator
	CALL LOGDOB		;(T1/T1) Check designator and do a DOBE
	 RET			;Return now if output discarded
	HRROI T2,[ASCIZ /Detached job /] ;Load the "I was detached" code
	CALL LOGMES		;(T1,T2/T1) Output the message
	MOVE T2,ATAJN		;Get the detached job's global job number
	CALL LOGNUM		;Print that next
	HRROI T2,[ASCIZ / from TTY /] ;Load the remainder of the message
	JRST ATAMS3		; and join the code below

;[7456] ATAMSG - print a message on logging terminal when a job is attached
;[7456]
;[7456] Call with:
;[7456] 	T1/ global job number
;[7456]		T2/ line number
;[7456] Returns: +1 always
;[7456] Clobbers: T1, T2, T3

ATAMSG:	ASUBR <ATAJN,ATALN>	;Place to save job #, line #
	MOVE T1,LOGDES		;Load the logging designator
	CALL LOGDOB		;(T1/T1) Check designator and do a DOBE
	 RET			;Return now if output discarded
	HRROI T2,[ASCIZ /Attached job /] ;Load the message to print
	CALL LOGMES		;(T1,T2/T1) Print that on logging terminal
	MOVE T2,ATAJN		;Get the global job number attaching
	CALL LOGNUM		;(T1,T2/T1) Print it
	HRROI T2,[ASCIZ / to TTY /] ;Load a label for the terminal number
ATAMS3:	CALL LOGMES		;(T1,T2/T1) Print that the logging terminal
	MOVE T2,ATALN		;Load the line number attached from or to
	MOVEI T3,^D8		;Load octal radix for terminal numbers
	CALL LGNOUT		;(T1,T2,T3/T1) Output the terminal number
	CALL LOGJO2		;(T1/T1) Print and store the time of day TOD
	CALLRET LOGCR		;(T1/T1) End with CRLF

;[7456] LOGJOB - outputs the message you see when you logout
;[7456] LOGJO1 - output that message for another job
;[7456]
;[7456] Call with:
;[7456]		T1/ Output designator
;[7456]		P1/ JSB offset (LOGJO1 only)
;[7456]		P2/ Local job number (LOGJO1 only)
;[7456]	Returns: +1 always

LOGJOB:	SAVEP			;Save the ACs for JSB offset and job
	SETZ P1,		;Clear the offset to the JSB
	MOVE P2,JOBNO		;Load my locak job number
LOGJO1:	HRROI T2,[ASCIZ / Job /] ;Load the job indentifier
	CALL LOGMES		;(T1,T2/T1) Print it
	MOVE T2,GBLJNO(P1)	;Load the global job number
	CALL LOGNUM		;(T1,T2/T1) Print it
	SKIPN JOBDIR(P2)	;Is the job logged in?
	IFSKP.			;Yes it is
	  HRROI T2,[ASCIZ /, User /] ;Point to seperator string
	  CALL LOGMES		;(T1,T2/T1) Print it
	  HRRZ T2,JOBDIR(P2)	;Get the directory logged in to
	  HRLI T2,USRLH		;Turn it into a 36 bit user number
	  DIRST			;Output that user name
	   ERJMPS .+1		;Ignore error and preserve T1
	  HRROI T2,[ASCIZ /, Account /] ;Point to next seperator string
	  CALL LOGMES		;(T1,T2/T1) Print it
	  HRROI T2,ACCTSR(P1)	;Point to the account string
	  CALL LOGMES		;(T1,T2/T1) Print it
	ENDIF.			;End of case of logged in job
	SKIPL CTRLTT(P1)	;Skip if detached
	IFSKP.			;If detached
	  HRROI T2,[ASCIZ /, Detached/] ;Point to detached string
	  CALL LOGMES		;(T1,T2/T1) Print it
	ELSE.			;If not detached
	  HRROI T2,[ASCIZ /, TTY /] ;Point t terminal
	  CALL LOGMES		;(T1,T2/T1) Print it
	  MOVE T2,CTRLTT(P1)	;Load the line number
	  MOVEI T3,^D8		;Print tty number in octal
	  CALL LGNOUT		;(T1,T2,T3/T1) Print it
	ENDIF.

LOGJO2:	HRROI T2,[ASCIZ /,
  at /]				;Here to add a crlf and the current date time
	CALL LOGMES		;(T1,T2/T1)
	PUSH P,T1		;Save the output designator
	CALL LGTAD		;(/T1,T2) Do local GTAD into T1 (T2 smashed)
	MOVE T2,T1		;Copy the current universal date time over
	POP P,T1		;Restore destination designator
	SETZ T3,		;Output format is standard date and time
	ODTIM			;Format and output date and time
	 ERNOP.			;Ignore errors
	RET			;Return from LOGJOB

;[7456] LOGDOB - call to do a DOBE before printing logging messages
;[7456]
;[7456] Call with:
;[7456]		T1/ designator (usually from LOGDES)
;[7456] Returns: +1 if .NULIO was the designator
;[7.1107]        +2 if .NULIO wasn't the designator (DOBE done if T1/LOGDES)

LOGDOB:	CAIN T1,.NULIO		;Are we just dropping this on the floor?
	RET			;Yes, return now, don't be a slow no-op
	CAMN T1,LOGDES		;[7.1107] Are we logging?
	DOBE%			;[7.1107] Yes, dismiss until empty
	 ERNOP.			;Ignore any error
	RETSKP			;Skip return

;[7.1107] Update comment for LOGMES/LOGCR
;LOGMES - Tiny routine to do a SOUT%
;LOGCR  - Tiny routine to do a SOUT% of a CRLF
;
;Call with:
;	T1/ designator (usually from LOGDES or .PRIOU)
;	T2/ Pointer to ASCIZ string (LOGMES only)
;
;Returns +1 always, T3 zeroed, errors ignored

LOGCR:	HRROI T2,CRLF		;[7.1119] Point to crlf, fall thru
LOGMES:	SETZ T3,		;[7.1107] Here to output any string
	SOUT
	 ERJMP .+1
	RET

;[7.1107] Update comments
;LOGNUM - Tiny routine to do a NOUT of a decimal number
;LOG2NM - Tiny routine to do a NOUT (two decimal digits output)
;LGNOUT - Tiny routine to do a NOUT (radix furnished)
;Call with:
;	T1/ designator (usually from LOGDES or .PRIOU)
;	T2/ number to print
;	T3/ radix (LGNOUT only)
;Returns +1 always

LOG2NM:	SKIPA 3,[EXP NO%LFL!NO%ZRO+^D2B17+^D10] ;Decimal, two digits
LOGNUM:	MOVEI 3,^D10		;DECIMAL FOR TIMES, ETC.
LGNOUT:	NOUT
	 ERJMP .+1
	RET

;PRINTS   [JOB N DETACHED BY NAME] TO TTY OF JOB BEING ATTACHED
; OR UNATTACHED.
;ACCEPTS:	1/JOB # OF JOB BEING UNATTACHED
;		2/LINE # OF JOB BEING UNATTACHED
;		3/DIR # OF USER UNATTACHING THE JOB
;		4/TTY # OF USER UNATTACHING THE JOB

DETMS1:	TRVAR <<MSGBUF,25>,JOB,LINE,DIRN,DTTYN,TMPPTR>
	MOVEM 1,JOB		;SAVE INPUTS
	MOVEM 2,LINE
	MOVEM 3,DIRN
	MOVEM 4,DTTYN		;SAVE TTY # OF DETACHER
	HRROI 1,MSGBUF		;START FILLING BUFFER
	CALL LOGCR		;CRLF
	HRROI 2,[ASCIZ/[Job /]
	CALL LOGMES
	HRRZ 2,JOB		;JOB # TO BE PRINTED
	CALL LOGNUM
	HRROI 2,[ASCIZ/ detached by /]
	CALL LOGMES
	MOVE 2,DIRN
	MOVEM 1,TMPPTR		;SAVE PLACE IN BUFFER IN CASE DIRST FAILS
	DIRST			;GET USER WHO'S UNATTACHING THE JOB
	ERJMP DIRFIX
DETMS2:	SKIPGE DTTYN		;IS DETACHER ON A TTY?
	JRST DETMS3		;NO
	HRROI 2,[ASCIZ/ on terminal /]
	CALL LOGMES
	MOVE 2,DTTYN		;Get the TTY number
	MOVEI 3,10		;OCTAL NUMBER
	CALL LGNOUT
DETMS3:	HRROI 2,[ASCIZ/]/]
	CALL LOGMES
	CALL LOGCR		;CLOSE WITH CRLF
	MOVEI 1,.TTDES		;MAKE A TTY DESIGNATOR
	ADD 1,LINE		;TTY LINE NUMBER
	HRROI 2,MSGBUF		;POINT TO NOW-COMPLETED MESSAGE
	TTMSG			;SEND IT OUT
	 ERJMP .+1
	RET

;UNATTACHER NOT LOGGED IN

DIRFIX:	MOVE 1,TMPPTR		;RESTORE BUFFER POINTER
	HRROI 2,[ASCIZ/user/]
	CALL LOGMES		;PLACE PSEUDO-NAME IN BUFFER
	JRST DETMS2		;FINISH ASSEMBLING THE MESSAGE
	SUBTTL Routine To Break Links

;[7.1230] Call this routine to break links from the current terminal.  Resets
;terminal to allow links and refuse advice (except on CTY where it is refuse
;advice and links).  Called when detaching or logging out from JSYSM and when a
;job is created by MEXEC.  This routine also resets the CTY's terminal type to
;that contained in CTYTY if SAVTRE is nonzero.

;Call with CTRLTT/ terminal number to reset.
;Returns +1 always with all links broken and terminal reset.

BLINKS::SAVEAC <T1,T2>		;Save a couple of ACs
	MOVX T1,TL%CRO!TL%COR!TL%SAB!TL%ABS!TL%STA!TL%OBJ ;acc links ref advice
	SKIPGE T2,CTRLTT	;Get TTY number
	 RET			;Return now if detached
	CAMN T2,CTYLNO		;Is it the CTY?
	MOVX T1,TL%CRO!TL%COR!TL%SAB!TL%STA!TL%OBJ ;Yes, ref advice and links
	MOVEI T2,-1		;All remote links to be cleared
	TLINK			;Break links, set advice and links bits
	 ERJMP .+1		;Ignore any error
	MOVE T2,CTRLTT		;Load the controlling terminal number
	SKIPE SAVTRE		;Saving trees 
	CAME T2,CTYLNO		; on the CTY today?
	RET			;No, return as our work is done
	MOVE T2,CTYTY		;Yes, saving trees and its the CTY
	MOVEI T1,.PRIOU		;Load primary terminal designator (CTY)
	STTYP			;Set the CTY's terminal type
	 ERJMP .+1		;Ignore someone putting trash in CTYTY
	RET			;Return now
	SUBTTL USAGE JSYS

	SWAPCD			;[7.1200]

;USAGE JSYS
;	1/ FLAGS,,FUNCTION
;	2/ ADDRS OF PARAMETERS

.USAGE::
	HRRZ T3,T1		;Get function
	CAIE T3,.USSAS		;Set or
	CAIN T3,.USRAS		; read accounting shifts?
	JRST USG001		;Yes-- OK if USAGE not enabled
	MOVE T3,FACTSW		;SEE IF ENABLED
	TXNN T3,SF%USG		;???
	JRST MRETN		;NO - JUST RETURN
USG001:	HRRZ T3,T1		;GET FUNCTION
	CAILE T3,MXUFN		;VALID?
	ITERR (ARGX02)
	CALL @UFCNTB(T3)	;DISPATCH
	 ITERR ()		;RETURN ERROR
	JRST MRETN		;RETURN

;USAGE FUNCTION TABLE

UFCNTB:	DTBDSP (UFNENT)		; 0 - MAKE ENTRY
	DTBDSP (UFNCLS)		; 1 - CLOSE OUT FILE
	DTBDSP (UFNCKP)		; 2 - PERFORM CHECKPOINT
	DTBDSP (UFNLGI)		; 3 - LOGIN
	DTBDSP (UFNLGO)		; 4 - LOGOUT
	DTBDSP (UFNCHG)		; 5 - SESSION CHANGE
	DTBDSP (UFNCKI)		; 6 - SET CHECKPOINT INTERVAL (MINS)
	DTBDSP (UFNENA)		; 7 - ENABLE ACCOUNT VALIDATION
	DTBDSP (UFNCAS)		; 10 - Change accounting shift
	DTBDSP (UFNSAS)		; 11 - Set accounting shifts
	DTBDSP (UFNRAS)		; 12 - Read accounting shifts
   MXUFN==.-UFCNTB-1

;ROUTINE TO CHECK FOR PRIVS

USGPRV:	MOVE T2,CAPENB		;GET CAP'S
	MOVE T3,MPP		;LOOK BACK TO CALLERS PC
	MOVE T3,0(T3)		; FLAGS
	TXNE T3,UMODF		;CALLED FROM MONITOR?
	TXNE T2,SC%WHL!SC%OPR	; OR PRIV.
	RETSKP			;OK TO GO ON
	RETBAD (CAPX1)		;NEITHER - FAIL
	SUBTTL USAGE JSYS -- SYSTEM-DATA.BIN Format

;DEFINITIONS OF INTERNAL FORMAT OF SYSTEM-DATA FILE

;WORDS 0 & 1 ARE QUEUE HEADERS

DEFSTR (UHTYP,UQDAT+0,17,18)	;TYPE CODE
DEFSTR (UHLEN,UQDAT+0,35,18)	;ENTRY LENGTH
DEFSTR (UHTAD,UQDAT+1,35,36)	;ENTRY DATE/TIME
DEFSTR (UHDRV,UQDAT+2,5,6)	;DEC REVISION #
DEFSTR (UHCRV,UQDAT+2,11,6)	;CUST REVISION #
DEFSTR (UHTMT,UQDAT+2,17,6)	;TERMINAL TYPE CODE
DEFSTR (UHJNO,UQDAT+2,35,18)	;JOB #
DEFSTR (UHPNM,UQDAT+3,35,36)	;PROGRAM NAME (SIXBIT)
DEFSTR (UHPVR,UQDAT+4,35,36)	;PROGRAM VERSION NUMBER (STD FORM)
DEFSTR (UHMVR,UQDAT+5,35,36)	;MONITOR VERSION NUMBER (STD FORM)
DEFSTR (UHJTS,UQDAT+6,0,1)	;BATCH := 1 , T/S := 0
DEFSTR (UHULN,UQDAT+6,5,5)	;USER NAME STRING LEN
DEFSTR (UHSL1,UQDAT+6,11,6)	;STRING LENGTH #1 (ACCOUNT)
DEFSTR (UHSL2,UQDAT+6,17,6)	;STRING LENGTH #2 (SESSION REMARK)
DEFSTR (UHLNO,UQDAT+6,35,18)	;LINE NUMBER
DEFSTR (UHNOD,UQDAT+7,35,36)	;NODE NAME (SIXBIT)

UHNAM==UQDAT+10			;LOC OF FIRST WORD OF USER NAME
UHMIN==UQDAT+20			;MINIMUM ENTRY SIZE (FOR ASGSWP)

USQMAX==^D20			;MAX USAGE QUEUE LENGTH
	SUBTTL USAGE JSYS -- Record Definitions

;RECORD LENGTH TABLE

RECLTB:	0			;0 - ILLEGAL
	MOVEI T1,UHMIN+^D16	;1 - MONITOR RESTART
	MOVEI T1,UHMIN+^D22	;2 - SESSION RECORD
	0			;3 - ILLEGAL
	0			;4 - ILLEGAL
	MOVEI T1,UHMIN+^D2	;5 - DATE/TIME CHANGE
	0			;6 - BATCH PROCESSOR
	MOVEI T1,UHMIN+^D27	;7 - INPUT SPOOLER
	MOVEI T1,UHMIN+^D30	;8 - OUTPUT SPOOLER
	CALL UGETDL		;9 - DISK STORAGE USAGE
	0			;10 - DISK SPINDLE USAGE
	MOVEI T1,UHMIN+^D29	;11 - STRUCTURE MOUNT
	MOVEI T1,UHMIN+^D35	;12 - MAGTAPE MOUNT
	0			;13 - DECTAPE MOUNT (TOPS10)
	0			;14 - FILE COMMAND (TOPS10)
	MOVEI T1,UHMIN+^D29	;15 - FILE RETRIEVED
	MOVEI T1,UHMIN+^D29	;16 - FILE ARCHIVED
	MOVEI T1,UHMIN+^D29	;17 - FILE MIGRATED
	MOVEI T1,UHMIN+^D29	;18 - FILE COLLECTED
MXRCTP==.-RECLTB-1

;FORMAT TABLE INDEXED BY RECORD TYPE

UFNFRM:	0			;0 - ILLEGAL
	-UFRSTL,,UFRSTT		;1 - RESTART RECORD
	-UFLOGL,,UFLOGT		;2 - SESSION RECORD
	0			;3 - ILLEGAL
	0			;4 - ILLEGAL
	-UFTADL,,UFTADT		;5 - DATA/TIME CHANGE
	0			;6 - BATCH PROCESSOR
	-UFINPL,,UFINPT		;7 - INPUT SPOOLER
	-UFOUTL,,UFOUTT		;8 - OUTPUT SPOOLER
	-UFDSKL,,UFDSKT		;9 - DISK STORAGE USAGE
	0			;10 - DISK SPINDLE USAGE
	-UFSTRL,,UFSTRM		;11 - STRUCTURE MOUNT
	-UFMTAL,,UFMTAM		;12 - MAGTAPE MOUNT
	0			;13 - DECTAPE MOUNT (TOPS10)
	0			;14 - FILE COMMAND (TOPS10)
	-UFRETL,,UFRETT		;15 - FILE RETRIEVE
	-UFRETL,,UFRETT		;16 - FILE ARCHIVED
	-UFRETL,,UFRETT		;17 - FILE MIGRATED
	-UFRETL,,UFRETT		;18 - FILE COLLECTED
;TABLE FOR DATE/TIME CHANGE FORM

UFTADT:	[-1],,.USDTL		;DATE/TIME BEFORE CHANGE (MANDATORY)
UFTADL==.-UFTADT

;TABLE FOR SYSTEM RESTART FORM

UFRSTT:	[0,,SVN],,.USSNM	;SYSTEM NAME
	[EXP SVNM],,.USMVR	;MONITOR VERSION NUMBER
	SYSTAD,,.USMBD		;MONITOR BUILD DATE/TIME
	USGMUP,,.USMUP		; MONITOR UPTIME (IN SECONDS)
	APRSER,,.USCP0		;SERIAL NUMBER (CPU0)
	[-1],,.USLCK		;DATE/TIME LAST CHECKPOINT (MAND.)
UFRSTL==.-UFRSTT

;TABLE OF SESSION RECORD ITEMS

UFLOGT:	[0,,ACCTSR],,.USACT	;ACCOUNT STRING
	[0,,JSSRM+1],,.USCOM	;SESSION REMARK
	CTIMON,,.USSST		;SESSION START TIME
	CONCON,,.USCCT		;CONSOLE CONNECT TIME
	JBRUNT,,.USRTM		;RUNTIME
	JBBNAM,,.USBJN		;BATCH JOB NAME
	JBBSEQ,,.USBSN		;BATCH SEQUENCE NUMBER
	BATRID,,.USBRI		;[7259]Batch request id
UFLOGL==.-UFLOGT		;LENGTH OF TABLE

CKOFF==:-UFLOGL+2		;OFFSET FROM END OF DATA FOR
				;BEGINNING OF CHECKPOINT DATA
CKITMS==:3			;NUMBER OF CHECKPOINT ITEMS

;TABLE FOR DISK USAGE STATISTICS

UFDSKT:	[-1],,.USSTR		;STRUCTURE NAME
	[-1],,.USDIR		;DIRECTORY NAME
	[-1],,.USNRF		;NUMBER OF ACCOUNTS
	[-1],,.USTAL		;[7347]Total allocated pages
	[-1],,.USTUS		;TOTAL SPACE USED
	[-1],,.USTNF		;TOTAL NUMBER OF FILES
	[-1],,.USLIQ		;LOGGED IN QUOTA
	[-1],,.USLOQ		;LOGGED OUT QUOTA
	[-1],,.USLLI		;DATE/TIME LAST LOGIN
	[-1],,.USDSX		;STRUCTURE/DIRECTORY INFO WORD (SPECIAL)
	[-1],,.USDST		;DISK STATISTICS TABLE
UFDSKL==.-UFDSKT
;TABLE FOR INPUT SPOOLER RECORD (NO DEFAULTS)

UFINPT:	[-1],,.USACT		;ACCOUNT STRING
	[-1],,.USTXT		;SYSTEM/OPERATOR TEXT
	[-1],,.USSRT		;SPOOLER RUNTIME
	[-1],,.USSDR		;DISK READS
	[-1],,.USSDW		;DISK WRITES
	[-1],,.USJNM		;JOB NAME
	[-1],,.USQNM		;QUEUE NAME
	[-1],,.USSDV		;ACTUAL INPUT DEVICE
	[-1],,.USSSN		;SEQUENCE NUMBER
	[-1],,.USSUN		;SPOOLER UNITS (CARDS)
	[-1],,.USCRT		;DATE/TIME OF REQUEST
	[-1],,.USDSP		;DISPOSITION
	[-1],,.USPRI		;PRIORITY
UFINPL==.-UFINPT

;TABLE FOR OUTPUT SPOOLER RECORD (NO DEFAULTS)

UFOUTT:	[-1],,.USACT		;ACCOUNT STRING
	[-1],,.USTXT		;SYSTEM/OPERATOR TEXT
	[-1],,.USSRT		;SPOOLER RUNTIME
	[-1],,.USSDR		;DISK READS
	[-1],,.USSDW		;DISK WRITES
	[-1],,.USJNM		;JOB NAME
	[-1],,.USQNM		;QUEUE NAME
	[-1],,.USSDV		;ACTUAL OUTPUT DEVICE
	[-1],,.USSSN		;SEQUENCE NUMBER
	[-1],,.USSUN		;SPOOLER UNITS (OUTPUT)
	[-1],,.USCRT		;DATE/TIME OF REQUEST
	[-1],,.USDSP		;DISPOSITION
	[-1],,.USPRI		;PRIORITY
	[-1],,.USSNF		;NUMBER OF FILES PROCESSED
	[-1],,.USSCD		;SCHEDULED DATE/TIME
	[-1],,.USFRM		;FORMS TYPE
UFOUTL==.-UFOUTT

;TABLE FOR STRUCTURE MOUNT RECORD (NO DEFAULTS)

UFSTRM:	[-1],,.USACT		;ACCOUNT STRING
	[-1],,.USTXT		;SYSTEM/OPERATOR TEXT
	[-1],,.USSSI		;STRUCTURE ID
	[-1],,.USSTP		;STRUCTURE TYPE CODE
	[-1],,.USTNP		;TOTAL NUMBER OF PACKS
	[-1],,.USKTP		;CONTROLLER TYPE
	[-1],,.USDTP		;DEVICE TYPE
	[-1],,.USDSP		;DISPOSITION
	[-1],,.USCRT		;DATE/TIME OF REQUEST
	[-1],,.USSCD		;SCHEDULED DATE/TIME
	[-1],,.USSRV		;SERVICED DATE/TIME
	[-1],,.USMCT		;MOUNT COUNT BEFORE MOUNT
	[-1],,.USDCT		;MOUNT COUNT AFTER DISMOUNT
	[-1],,.USATP		;ACCESS TYPE
	[-1],,.USEUT		;ELASPED USE TIME
UFSTRL==.-UFSTRM
;TABLE FOR MAGTAPE MOUNT RECORD (NO DEFAULTS)

UFMTAM:	[-1],,.USACT		;ACCOUNT STRING
	[-1],,.USTXT		;SYSTEM/OPERATOR TEXT
	[-1],,.USVID		;VOLUME IDENTIFIER
	[-1],,.USVSN		;VISUAL SERIAL NUMBER
	[-1],,.USMRF		;THOUSANDS OF FRAMES READ
	[-1],,.USMWF		;THOUSANDS OF FRAMES WRITTEN
	[-1],,.USDSP		;DISPOSITION
	[-1],,.USCRT		;DATE/TIME OF REQUEST CREATION
	[-1],,.USSCD		;SCHEDULED DATE/TIME
	[-1],,.USSRV		;SERVICED DATE/TIME
	[-1],,.USKTP		;TYPE OF CONTROLLER
	[-1],,.USMLT		;LABEL TYPE
	[-1],,.USMLS		;LABEL STATE
	[-1],,.USMRD		;NUMBER OF PHYSICAL RECORDS READ
	[-1],,.USMWR		;NUMBER OF PHYSICAL RECORDS WRITTEN
	[-1],,.USFSI		;FILE SET IDENTIFIER
	[-1],,.USSRE		;NUMBER OF SOFT READ ERRORS
	[-1],,.USSWE		;NUMBER OF SOFT WRITE ERRORS
	[-1],,.USHRE		;NUMBER OF HARD READ ERRORS
	[-1],,.USHWE		;NUMBER OF HARD WRITE ERRORS
	[-1],,.USEUT		;ELAPSED USE TIME
UFMTAL==.-UFMTAM

;Table for file retrieve (no defaults)

UFRETT:	[-1],,.USACT		; Account of file or retrieve requestor
	[-1],,.USDIR		; Directory of file
	[-1],,.USSSI		; SIXBIT STRUCTURE ID
	[-1],,.USUSG		; # pages involved
	[-1],,.USTP1		; Tape 1 ID
	[-1],,.USTS1		; Saveset # for tape 1
	[-1],,.USTF1		; Tape file # for tape 1
	[-1],,.USTP2		; Tape 2 ID
	[-1],,.USTS2		; Saveset for tape 2
	[-1],,.USTF2		; Tape file # for tape 2
	[-1],,.USRSN		; Reason file moved offline
UFRETL==.-UFRETT
	SUBTTL USAGE JSYS -- Functions Performed by Job 0 Fork

;PASS SPECIAL FUNCTION TO JOB 0 AND WAIT

UFNCAS:				;Change accounting shift
UFNCLS:				;Close checkpoint file
UFNCKP:				;Checkpoint all jobs
	CALL USGPRV		;VALIDATE PRIVS
	 RETBAD ()
UFNCK1:	NOINT			;BEST TO BE NOINT
	MOVEI T1,2		;GET 2 WORDS
	CALL ASGSWP		;FROM SWAPPABLE FREE SPACE
	 JRST [	CALL ASGWAT	;WAIT FOR STORAGE
		JRST UFNCK1]	;TRY AGAIN
	XCTU [HRRZ T2,1]	;RE-FETCH USER FUNCTION
	STOR T2,UQFCN,(T1)	;SAVE IN BLOCK
	LOCK (USGLOK)		;WANT DATA BASE LOCKED FOR THIS FCN
	CALL ONUSQ		;QUEUE UP MESSAGE
	OKINT
	AOS JB0FLG		;POKE JOB 0 FOR THESE
	MOVEI T1,USGWAT		;WAIT TILL FUNCTION DONE!
	MDISMS			;DISMISS
	RETSKP			;GOOD RETURN

;RESIDENT SCHEDULAR TEST TO WAIT FOR JOB 0 TO DO FUNCTION

	RESCD

USGWAT:	SKIPL USGLOK		;UNLOCKED?
	JRST 0(4)		;NO - WAIT SOME MORE
	JRST 1(4)		;YES - WAKEUP

	SWAPCD
	SUBTTL USAGE JSYS -- Set Checkpoint Interval

;ROUTINE TO SET CHECKPOINT INTERVAL

UFNCKI:	CALL USGPRV		;CHECK PRIVS
	 RETBAD ()
	UMOVE T1,2		;GET USER ARGUMENT
	IMULI T1,^D60000	;CONVERT TO MS
	MOVEM T1,CKPINV		;SET INTERVAL
	RETSKP			;GOOD RETURN
	SUBTTL USAGE JSYS -- Make Usage or Session Entry

;WRITE ENTRY INTO USAGE FILE

UFNENT:	CALL UFNINI		;BUILD HEADER
	 RETBAD ()		;ERROR
	LOAD T1,UHTYP,(Q1)	;GET ENTRY TYPE CODE
UFNEN0:	CAIL T1,.UTUSR		;USER-DEFINED ENTRY TYPE?
	 JRST [	CALL UFNFAR		;YES-- FILL ARBITRARY RECORD BLOCK
		 JRST UFNINX		;ERROR-- RETURN TO USER
		JRST UFNEN1]		;ENTRY ALL FINISHED-- PUT ON QUEUE
	MOVE T1,UFNFRM(T1)	;GET FORM POINTER
	CALL UFNFIL		;FILL IN FORM
	 JRST UFNINX		;MISSING ITEM
UFNEN1:	MOVE T1,Q1		;POINT TO RECORD FOR QUEUE
	CALL ONUSQ		;ENQUE MESSAGE
	OKINT			;DONE
	RETSKP			;...

;COMMON ROUTINE TO HANDLE ALL JOB LOGGING

UFNLGI:
UFNLGO:
UFNCHG:	SKIPN JOBNO		;IGNORE FOR JOB 0
	RETSKP
	CALL UFNINI		;INIT BLOCK
	 RETBAD ()		;PASS ERROR UP
	MOVEI T1,.UTSEN		;SESSION ENTRY TYPE CODE
	CALLRET UFNEN0		;FILL IN REMAINDER AND QUEUE IT
	SUBTTL USAGE JSYS -- Fill Record From Table

;ROUTINE TO FILL RECORD FROM TABLE SPECIFIED
;CALL:	T1/ -LEN,,TABLE-BEG
;	Q1/ POINTER TO BEGINNING OF BUFFER
;	Q2/ POINTER TO USER'S RECORD DESCRIPTOR BLOCK
;	Q3/ POINTER TO FIRST FREE DATA ITEM
;
;COPY DATA INTO BUFFER AND UPDATE HEADER TO SHOW LENGTH
;RETURN WITH Q3 UPDATED TO END OF BLOCK

UFNFIL:	TRVAR <UFCHI,STRLX>
	SETOM STRLX		;INIT INDEX
	MOVE T4,T1		;COPY TO T4
UFNFL1:	MOVEM T4,UFCHI		;SAVE INDEX
	HRRZ T1,0(T4)		;FETCH ITEM CODE
	HLRZ T2,0(T4)		;ADDRS OF DEFAULT ITEM
	MOVE T2,0(T2)		;SETUP DEFAULT
	CALL UFWFET		;GET WORD
	 RETBAD ()		;PASS UP ERROR
	LDB T3,[POINTR (T1,US%TYP)] ;GET DATA TYPE
	CAILE T3,MXUITP		;MAX USAGE ITEM TYPE?
	RETBAD (USGX03)		;ILLEGAL USAGE ITEM TYPE
	CALL @UTYPTB(T3)	;FILL IN DATA ITEM
	 RETBAD ()		;PASS ERROR UP
	MOVE T4,UFCHI		;RESTORE INDEX
	AOBJN T4,UFNFL1		;LOOP TILL ALL DONE

;HERE WHEN ALL DONE FILLING THE ENTRY

UFNFIE:	MOVE T1,Q3		;COPY POINTER
	SUBI T1,1(Q1)		;ACTUAL DATA LENGTH
	STOR T1,UHLEN,(Q1)	;STORE IN RECORD
	MOVE T1,UQDAT(Q1)	;COPY HEADER
	MOVEM T1,0(Q3)		;TO LAST WORD
	RETSKP

;STRING LENGTH TABLE

STRLNT:	STOR T2,UHSL1,(Q1)	;STORE IN STRING LEN #1
	STOR T2,UHSL2,(Q1)	;STORE IN STRING LEN #2

;USAGE ITEM TYPE TABLE

UTYPTB:	DTBDSP (UFLASC)		;0 - STRING
	DTBDSP (UFLSIX)		;1 - SIXBIT WORD
	DTBDSP (UFLOCT)		;2 - OCTAL WORD
	DTBDSP (UFLDEC)		;3 - DECIMAL WORD
	DTBDSP (UFLDAT)		;4 - DATE/TIME WORD
	DTBDSP (UFLTAB)		;5 - TABLE (SPECIAL)
	DTBDSP (UFLVER)		;6 - VERSION NUMBER
	DTBSKP			;7 - SPACE FILL (SKIP)
   MXUITP==.-UTYPTB-1

;ROUTINE TO STORE FULL WORDS
;T2 / DATA WORD

UFLVER:
UFLOCT:
UFLDEC:
UFLDAT:	MOVEM T2,0(Q3)		;SAVE WORD IN BUFFER
	AOJA Q3,RSKP		;ADVANCE POINTER AND RETURN

;ROUTINE TO STORE STRING
;T2 / STRING POINTER

UFLASC:	TLCE T2,-1		;CHECK FOR 0,,ADDRS
	TLC T2,-1		;NO - MUST BE BPNTR
	CALL UFCPY0		;COPY STRING INTO BLOCK
	 RET
	AOS T1,STRLX		;STEP INDEX
	XCT STRLNT(T1)		;STORE LENGTH
	RETSKP			;GOOD RETURN

;ROUTINE TO FILL IN TABLE INFO
;T2 / TABLE BASE ADDRS

UFLTAB:	SAVEAC <Q1,Q2>		;SAVE Q1,Q2
	STKVAR <TBLCNT,TBLSTO>
	MOVE Q2,T2		;SAVE BASE ADDRS
	UMOVE T1,0(Q2)		;FETCH TABLE HEADER
	HRRZ T2,T1		;GET LENGTH OF ADDITIONAL ITEMS
	MOVNM T2,TBLCNT		;SAVE NEG COUNT
	HLRZ Q1,T1		;GET LENGTH OF TABLE

UFLTB1:	MOVEM Q3,TBLSTO		;SAVE ADDRS OF STRING LENGTH
	AOS Q3			;STEP TO NEXT LOC
	UMOVE T3,1(Q2)		;FETCH WORD FROM TABLE
	HRRZ T2,T3		;ADDRESS OF DATA ITEMS
	HRL T2,TBLCNT		;FORM -N,,ADDRS
UFLTB2:	UMOVE T1,0(T2)		;GET ITEM
	MOVEM T1,0(Q3)		;STORE IN BUFFER
	AOS Q3			;ADVANCE TO NEXT LOC
	AOBJN T2,UFLTB2		;LOOP OVER ALL ITEMS
	HLRO T2,T3		;GET POINTER TO STRING
	CALL UFCPY0		;COPY TO BUFFER
	 JFCL
	HRRZM T2,@TBLSTO	;STASH LENGTH
	AOS Q2			;STEP TO NEXT LOC
	SOJG Q1,UFLTB1		;LOOP OVER TABLE
	RETSKP			;DONE

;ROUTINE TO GET SIXBIT ARGUMENT, MAY BE POINTER TO AN ASCIZ STRING

UFLSIX:	HLRZ T1,T2		;CHECK FOR POINTER
	CAIE T1,-1
	CAIN T1,(POINT 7,,)
	JRST UFLSX0		;STRING - COPY IT FIRST
UFLSXX:	MOVEM T2,0(Q3)		;STORE WORD
	AOJA Q3,RSKP		;AND GIVE GOOD RETURN

;ASCIZ STRING POINTER - CONVERT TO SIXBIT

UFLSX0:	STKVAR <SIXBP>
	MOVE T1,T2		;COPY POINTER
	HRLI T1,(POINT 7,,)
	MOVEI T4,6		;MAX 6 CHARS
	SETZ T2,		;CLEAR ANSWER
	MOVE T3,[POINT 6,T2]
	MOVEM T3,SIXBP		;INIT OUTPUT BP
UFLSX1:	XCTBU [ILDB T3,T1]	;FETCH A CHAR
	JUMPE T3,UFLSXX		;DONE IF NULL
	SUBI T3,40		;CONVERT TO SIXBIT
	IDPB T3,SIXBP		;SAVE IN RESULT
	SOJG T4,UFLSX1		;LOOP TILL DONE
	JRST UFLSXX		;STORE RESULT
	SUBTTL USAGE JSYS -- Fill Arbitrary Record

; UFNFAR -- FILL ARBITRARY RECORD FOR USER ENTRY TYPE
;
; CALL:
;	Q1/ POINTER TO BEGINNING OF BUFFER
;	Q2/ POINTER TO USER'S RECORD DESCRIPTOR BLOCK
;	Q3/ POINTER TO FIRST FREE DATA ITEM
;
; RETURNS:
;	+1:	ERROR, CODE IN T1
;	+2:	SUCCESS, ENTRY READY TO PUT ON QUEUE
;
; DESTROYS T1-T4, Q3

UFNFAR:	CALL UFNFNA		;FIND THE "ARBITRARY RECORD TYPE" ITEM
				; RETURNS USER ADDRESS IN T3

;FORM AOBJN POINTER TO REMAINING DATA BLOCK IN Q3

	LOAD T1,UQLEN,(Q1)	;GET LENGTH OF DATA BLOCK
	ADD T1,Q1		;FIND END OF BLOCK
	SUBM Q3,T1		;GET -VE WORDS LEFT TO FILL IN T1
	HRL Q3,T1		;FORM AOBJN POINTER IN Q3

;LOOP THROUGH THE USER'S RECORD DESCRIPTOR BLOCK (T3) FOR ALL ITEMS
; AND STORE THEM IN DATA BLOCK (Q3)

UFNFA1:	UMOVE T1,0(T3)		;GET ITEM TYPE WORD
	JUMPE T1,UFNFIE		;END-- ALL DONE, COMPUTE LENGTH AND RETURN +2 FROM UFNFAR
	JUMPGE Q3,[RETBAD (ARGX05)] ;IF NO ROOM-- RDB MUST HAVE GROWN!!
	MOVEM T1,0(Q3)		;STORE THE ITEM TYPE WORD IN THE DATA BLOCK
	AOBJN Q3,.+1		;COUNT THAT WORD IN DATA BLOCK
	ADDI T3,2		;POINT TO NEXT USER ENTRY NOW

	LDB T4,[POINTR (T1,US%TYP)] ;EXTRACT ITEM TYPE
	CAIN T4,.USSPC		;SPACE FILL?
	 JRST UFNFA1		;YES-- NO DATA FOR THIS
	UMOVE T2,-1(T3)		;GET USER'S DATA WORD OR POINTER
	CAMN T2,[EXP -1]	;USER WANT DEFAULT VALUE FOR THIS ITEM?
	 RETBAD (USGX03)	;YES-- THERE ARE NO DEFAULTS IN ARBITRARY ENTRIES
	CAIN T4,.USASC		;ASCII STRING?
	 JRST UFNFA5		;YES-- MUST COPY WHOLE STRING

;ALL OTHER DATA TYPES ARE EXACTLY ONE WORD-- GET THE WORD AND PUT IT AWAY

	TXNE T1,US%IMM		;IMMEDIATE MODE DATA ITEM?
	 JRST UFNFA3		;YES-- WE HAVE THE DATA ITEM IN T2
	MOVX T2,<MOVE T2,@0>	;NO-- MUST PERFORM INDIRECT FETCH
	HRRI T2,-1(T3)		; VIA THE USER'S DATA WORD POINTER
	XCTUU T2		;FETCH USER'S DATA WORD TO T2

UFNFA3:	JUMPGE Q3,[RETBAD (ARGX05)] ;IF NO ROOM-- RDB MUST HAVE GROWN!!
	MOVEM T2,0(Q3)		;STORE THE USER'S DATA WORD IN DATA BLOCK
	AOBJN Q3,.+1		;COUNT THAT WORD IN DATA BLOCK
	JRST UFNFA1		;LOOP FOR ALL ITEMS

;ASCII STRING ITEM-- COPY THE ENTIRE STRING TO THE DATA BLOCK

UFNFA5:	LDB T1,[POINTR (T1,US%LEN)] ;GET LENGTH OF STRING IN BYTES
	ADDI T1,4		;ROUND UP
	IDIVI T1,5		; TO FULL WORDS
	UMOVE T2,-1(T3)		;GET ADDRESS OF STRING
UFNFA6:	JUMPLE T1,UFNFA1	;DONE IF NO MORE USER WORDS LEFT, GET NEXT ITEM
	UMOVE T4,0(T2)		;GET WORD FROM USER'S STRING
	ADDI T2,1		;BUMP USER STRING ADDRESS
	JUMPGE Q3,[RETBAD (ARGX05)] ;IF NO ROOM-- RDB MUST HAVE GROWN!!
	MOVEM T4,0(Q3)		;STORE IT IN DATA BLOCK
	AOBJN Q3,.+1		;COUNT THAT WORD IN DATA BLOCK
	SOJA T1,UFNFA6		;COUNT DOWN WORD COUNT, LOOP FOR ENTIRE STRING
	SUBTTL USAGE JSYS -- Fill In Usage Entry Header

;ROUTINE TO SETUP BLOCK OF STORAGE AND FILL IN HEADER INFO
;RETURNS: +1 ERROR CODE IN T1
;	  +2 NOINT
;	Q1/	STORAGE BLOCK FROM ASGSWP
;	Q2/	POINTER TO USER'S ARGLST
;	Q3/	POINTER TO FIRST FREE WORD IN BLOCK

UFNINI:	CALL USGPRV		;CHECK PRIVS
	 RETBAD ()
UFNIN0:	UMOVE Q2,2		;GET CALLER ARGS
	XCTU [HRRZ T2,0(Q2)]	;GET RECORD TYPE CODE
	CAIG T2,MXRCTP		;VALIDATE
	SKIPN T1,RECLTB(T2)	;SKIP IF VALID TYPE CODE
	 JRST [	CAIL T2,.UTUSR		;MAYBE IT'S A USER ENTRY 5000-9999
		CAILE T2,^D9999		; . . ?
		 RETBAD (USGX01)	;NO-- REALLY INVALID ENTRY TYPE
		CALL UFNINS		;USER ENTRY TYPE-- COMPUTE LENGTH
		JRST UFNI01]		;LENGTH OF USER ENTRY NOW IN T1
	XCT T1			;RETURNS LENGTH IN T1
UFNI01:	NOINT			;BEST BE NOINT
	MOVE T2,USQCNT		;SEE IF OVER QUEUE QUOTA
	CAIGE T2,USQMAX		;...
	CALL ASGSWP		;ALLOCATE STORAGE
	 JRST [	CALL ASGWAT	;WAIT FOR SOME
		JRST UFNIN0]	;START OVER
	MOVE Q1,T1		;SAVE POINTER TO BLOCK
	XCTU [HRRZ T1,1]	;GET USER FUNCTION AGAIN
	STOR T1,UQFCN,(Q1)	;STORE IN QUEUE HEADER
	UMOVE T2,0(Q2)		;GET ARG HEADER
	STOR T2,UHTYP,(Q1)	;STORE TYPE IN BLOCK
	LDB T1,[POINT 9,T2,8]	;GET DEC REV
	STOR T1,UHDRV,(Q1)
	LDB T1,[POINT 9,T2,17]	;GET CUST REV
	STOR T1,UHCRV,(Q1)

	CALL LGTAD		;[7456] (/T1,T2) Get universal date-time
	MOVE T2,T1		;[7456] Move the default for UHTAD to 
	MOVEI T1,.USTAD		;[7456] Load the creation time code
	CALL UFWFEI		;[7456] (T1,T2/T1,T2) is there one?
	 JRST UFNINX		;[7456] Report an error
	STOR T2,UHTAD,(Q1)	;[7456] Save the date-time for this entry

	MOVEI T1,.USJNO		;[7456] Load the job code
	MOVE T2,GBLJNO		;[7456] Load my global job number
	CALL UFWFEI		;[7456] (T1,T2/T1,T2) Fetch that item
	 JRST UFNINX		;[7456] Error exit
	STOR T2,UHJNO,(Q1)	;[7456] Store user's arg or our job number
	MOVE T1,T2		;[7456] Load global job number
	LOAD T2,UQFCN,(Q1)	;[7.1279] Load the entry type
	CAIN T2,.USENT		;[7.1279] Need to validate the job number?
	IFSKP.			;[7.1279] Yes, in fact we do
	  CALL GL2LCL		;[7.1279][7456] (T1/T1) Get local job number
	   JRST UFNINX		;[7.1279][7.1049] Return error code from GL2LCL
	  STOR T1,UQLJI,(Q1)	;[7.1279][7456] Save it in the Queue Header
	ENDIF.			;[7.1279]

	MOVE T1,[EXP SVNM]	;[7456] Load the monitor version number
	STOR T1,UHMVR,(Q1)	;[7456] Store it in the proper place

	MOVEI T1,.USLNO		;[7456] Load the line number code
	SKIPGE T2,CTRLTT	;[7.1049] Load line number, skip if not det
	MOVX T2,-2		;[7.1049] -1 is detached, change it to -2
	CALL UFWFEI		;[7456] (T1,T2/T1,T2) Fetch that item
	 JRST UFNINX		;[7456] Error exit
	SKIPGE T2		;[7.1049] Was the job detached?
	SETO T2,		;[7.1049] Yes, make sure line number is -1
	STOR T2,UHLNO,(Q1)	;[7456] Save the terminal line number
	SKIPL T1,T2		;[7456] Skip if detached, copy line no to T1
	IFSKP.			;[7456] If it was detached
	  MOVEI Q3,'D'		;[7456] Indicate its a detached job
	  MOVX T1,OB%BSS	;[7456] Load the batch stream set flag
	  TDNN T1,BATSTF	;[7456] Was it a batch job that got detached?
	  TDZA T1,T1		;[7456] No, just a random job
	  SETO T1,		;[7456] Yes, it is a detached batch job
	ELSE.			;[7456] So the job wasn't detached
	  CAIL T2,0		;[7.1049] Is the line number in
	  CAIL T2,NLINES	;[7.1049]  the legal range (0 to NLINES-1)?
	  JRST UFNITN		;[7.1049] No, give the user an error
	  MOVEI Q3,'U'		;[7.1049] Q3 holds type code, default 'U'
	  CAMN T2,CTYLNO	;[7456] Is it the CTY?
	  MOVEI Q3,'C'		;[7456] Yes it is
	  CAMGE T2,CTYLNO	;[7456] Is it a real TTY?
	  MOVEI Q3,'T'		;[7456] Yes, its a real TTY
	  CALL PTYGBB		;[7456] (T1/T1) See if it is a PTY
	   TDZA T1,T1		;[7456] It is not a PTY, not batch either
	  MOVEI Q3,'P'		;[7456] Say its a PTY, T1 holds batch/ts flag
	ENDIF.			;[7456] Now Q3 has type code, T1 has batch flag
	STOR Q3,UHTMT,(Q1)	;[7456] Store terminal type code
	MOVE T2,T1		;[7456] Copy the batch/ts flag out to T2
	MOVEI T1,.USJTY		;[7456] Load the batch/timesharing flag code
	CALL UFWFEI		;[7456] (T1,T2/T1,T2) Fetch that item
	 JRST UFNINX		;[7456] Error exit
	STOR T2,UHJTS,(Q1)	;[7456] Store batch/ts flag

UFNIN1:	HRROI T1,LLSR-1		;[7456] Point to node name
	CALL ASCSIX		;[7456] (T1/T1) Convert to SIXBIT in T1
	 SETZM T1		;[7456] If invalid, just blank it
	MOVE T2,T1		;[7456] Copy default argument to T2
	MOVEI T1,.USNOD		;[7456] Load the node type code
	CALL UFWFEI		;[7456] (T1,T2/T1,T2) Fetch that item
	 JRST UFNINX		;[7456] Error exit
	STOR T2,UHNOD,(Q1)	;[7456] Save the job's logical location
	MOVEI T1,.USPNM		;[7456] Load code for calling program name
	MOVE T2,JOBNO		;[7456] Default it to 
	MOVE T2,JOBPNM(T2)	;[7456]  this job's system name
	CALL UFWFEI		;[7456] (T1,T2/T1,T2) Fetch any program name
	 JRST UFNINX		;[7456] Error exit
	STOR T2,UHPNM,(Q1)	;[7456] Store the program name
	MOVEI T1,.USPVR		;[7456] Load code for program version
	MOVEI T2,0		;[7456] The default is a zero version
	CALL UFWFEI		;[7456] (T1,T2/T1,T2) Fetch any supplied 
	 JRST UFNINX		;[7456] Error exit
	STOR T2,UHPVR,(Q1)	;[7456] Store the program version
	MOVEI T1,.USNM2		;[7456] Load code for the user name
	MOVEI T2,USRNAM+1	;[7456] The default is my user name
	MOVEI Q3,UHNAM(Q1)	;[7456] Point to name string address
	CALL UFCPYU		;[7456] (T1,T2,Q3/T1,T2,Q3) Copy the username
	IFNSK.			;[7456] If no skip then error occured, check it
	  CAIE T1,USGX02	;[7456] Is the error that the item is not there
	  JRST UFNINX		;[7456] Yes, take the error exit
	  CALL UFCPY0		;[7456] (T2,Q3/T2,Q3) Use the default
	   JFCL			;[7456] Error won't happen
	ENDIF.			;[7456] String copied, length is in T2
	STOR T2,UHULN,(Q1)	;[7456] Store length of the username string
	RETSKP			;RETURN

;[7456] UFWFEI - Routine to call UFWFET to get an argument.  Can be used to
;[7456] default an item if an item is not found in the user's argument list.
;[7456] This routine is used when it is not an error to not have the data
;[7456] specified in your argument list (e.g. header and job information).
;[7456] 
;[7456] Call with:
;[7456]		T1/ item type code
;[7456]         T2/ default item
;[7456] 	CALL UFWFEI
;[7456] Returns +1 if error returned by UFWFET is not USGX02
;[7456] Returns +2 if item fetched from user, or error is USGX02
;[7456]		T2/ data (defaulted or from user)

UFWFEI:	CALL UFWFET		;[7456] (T1,T2/T1,T2) Fetch the item desired
	 CAIN T1,USGX02		;[7456] Default item not supplied?
	RETSKP			;[7456] Return OK
	RET			;[7456] Error return

;ERROR EXIT WITH OKINT (CODE IN T1)

UFNITN:	MOVEI T1,USGX04		;[7.1049] Load "Invalid terminal line number"
UFNINX:	PUSH P,T1		;SAVE CODE
	MOVE T1,Q1		;POINT TO BLOCK
	LOAD T2,UQLEN,(T1)	;SETUP SIZE
	CALL RELSWP		;RELEASE SPACE
	OKINT			;ALLOW INTS
	POP P,T1		;RESTORE CODE
	RETBAD ()
	SUBTTL USAGE JSYS -- Compute Length of User Entry

; UFNINS -- COMPUTE DATA BLOCK LENGTH FOR ARBITRARY USER ENTRIES 5000-9999
;
; CALL:
;	Q2/	POINTER TO USER'S RECORD DESCRIPTOR BLOCK
;
; RETURNS:
;   +1:	ALWAYS
;	T1/	SIZE OF DATA BLOCK NEEDED (FOR ASGSWP)
;
; DESTROYS T1-T4

UFNINS:	CALL UFNFNA		;FIND FIRST ARBITRARY RECORD ITEM, USER ADDRESS IN T3
	MOVX T4,UHMIN+1		;START COUNT WITH REQUIRED PART OF DATA BLOCK

;LOOP THROUGH USER'S RECORD DESCRIPTOR BLOCK AND COUNT THE SIZE OF EACH ENTRY IN T4

UFNIS1:	UMOVE T1,0(T3)		;GET ITEM TYPE CODE WORD
	JUMPE T1,UFNIS9		;ZERO MEANS END-- COMPUTE SIZE AND RETURN
	ADDI T4,1		;COUNT THE ITEM TYPE WORD
	ADDI T3,2		;STEP TO NEXT USER ITEM NOW

	LDB T2,[POINTR (T1,US%TYP)] ;GET ITEM DATA TYPE
	CAIN T2,.USSPC		;SPACE FILL?
	 JRST UFNIS1		;YES-- NO DATA WORD FOR THIS
	CAIE T2,.USASC		;ASCII STRING?
	 AOJA T4,UFNIS1		;NO-- DATA IS EXACTLY ONE WORD, SO COUNT AND GET NEXT ITEM

;ASCII STRING-- SIZE IN WORDS IS ( <LENGTH IN BYTES> + 4 ) / 5

	LDB T1,[POINTR (T1,US%LEN)] ;GET LENGTH IN BYTES
	ADDI T1,4		;ROUND UP
	IDIVI T1,5		; TO FULL WORDS
	ADD T4,T1		;COUNT THE STRING LENGTH
	JRST UFNIS1		;LOOP FOR NEXT ITEM

;END OF BLOCK-- RETURN LENGTH IN T1

UFNIS9:	MOVE T1,T4		;COPY LENGTH
	RET			;RETURN +1 FROM UFNINS

; UFNFNA -- FIND FIRST ARBITRARY RECORD ENTRY
; CALL:	Q2/	POINTER TO USER RECORD DESCRIPTOR BLOCK
; RETURNS:
;  +1:	T3/	POINTER TO USER'S ARBITRARY RECORD DESCRIPTOR
; DESTROYS T1-T4

UFNFNA:	MOVE T3,Q2		;COPY BEGINNING OF USER REC DESC BLK
UFNFN1:	UMOVE T1,1(T3)		;GET AN ITEM CODE WORD--SKIP HEADER
	JUMPE T1,UFNFN9		;ZERO IS END-- RETURN NOW
	LDB T2,[POINTR (T1,US%COD)] ;GET ITEM CODE
	CAIE T2,.USUAR		;ARBITRARY RECORD DELIMITER?
	 JRST [	ADDI T3,2		;NO-- BUMP TO NEXT ITEM
		JRST UFNFN1]		; AND GO ON LOOKING
UFNFN9:	AOJA T3,R		;YES-- RETURN CORRECT POINTER FROM UFNFNA
	SUBTTL USAGE JSYS -- Copy String to Usage Block

;ROUTINE TO COPY STRING ARGUMENT INTO USAGE BLOCK
; CALL:	T1/	ITEM CODE
;	T2/	DEFAULT STRING PNTR
;	Q3/	DEST ADDRS
;
;RETURN +1	ERROR
;	+2	LENGTH IN T2, UPDATED ADDRS IN Q3

UFCPYU:	CALL UFWFET		;GET WORD (SHOULD BE POINTER)
	 RETBAD ()		;PASS ERROR UP
UFCPY0:	MOVEI T1,-1(Q3)		;POINT TO DESTINATION ADDRS
	TLNN T2,-1		;MAYBE 0,,ADDRS
	JRST UFCPY2		;YES - STRING IN MONITOR SPACE
	CALL CPYFU1		;COPY STRING FROM USER SPACE
	 JFCL			;CANT HAPPEN
UFCPYX:	IBP T2			;ADVANCE TO NULL
	MOVEI T1,1(T2)		;POINT TO WORD AFTER STRING
	SUBI T2,-1(Q3)		;NUMBER OF FULL WORDS
	MOVE Q3,T1		;RETURN UPDATED POINTER IN Q3
	RETSKP			;GOOD RETURN

UFCPY2:	HRLI T1,(<POINT 7,,35>)	;DESTINATION BP
	HRLI T2,(<POINT 7,,>)	;SOURCE BP
	SETZ T3,		;TERMINATE ON NULL
	SOUT			;COPY STRING
	MOVE T2,T1		;RETURN UPDATED STRING IN T2
	JRST UFCPYX		;COMMON EXIT
	SUBTTL USAGE JSYS -- Get Length of Disk Usage Block

;ROUTINE TO FETCH LENGTH OF DISK USAGE BLOCK

UGETDL:	MOVEI T1,.USDST		;LOOK FOR THIS ITEM TYPE
	SETO T2,		;NO DEFAULT
	CALL UFWFET		;...
	 JRST [	MOVEI T1,UHMIN+^D24
		RET]		;RETURN DEFAULT
	UMOVE T3,0(T2)		;FETCH TABLE HEADER
	HRRZ T1,T3		;NUMBER OF DATA ITEMS PER ENTRY
	ADDI T1,MAXLW+1		; PLUS MAX STRING LENGTH+1
	HLRZS T3		;NUMBER OF TABLE ENTRIES
	IMUL T1,T3		;TOTAL ITEMS (MAX STORAGE)
	ADDI T1,UHMIN+^D24	; PLUS FIXED AMOUNT
	RET			;RETURN
	SUBTTL USAGE JSYS -- Find and Fetch Entry In Caller's List

;ROUTINE TO FIND ENTRY IN CALLER'S LIST
;   T1/ DESIRED ARG TYPE CODE
;RETURNS:  T1/ ITEM DESC
;	   T2/ DATA ENTRY
;	   T3/ POINTER TO ENTRY

USFFND:	MOVE T3,Q2		;COPY ARG BLOCK ADDRS
	MOVE T4,T1		;COPY ARG TO T4
USFFN1:	UMOVE T1,1(T3)		;FETCH ARG
	JUMPE T1,[RETBAD (USGX02)] ;NOT FOUND
	ADDI T3,2		;POINT TO DATUM
	LDB T2,[POINTR (T1,US%COD)] ;GET ITEM CODE
	CAME T2,T4		;CHECK MATCH
	JRST USFFN1		;NO - LOOP
 	UMOVE T2,0(T3)		;RETURN 2ND WORD
	CAMN T2,[-1]		;-1 GIVEN
	TXO T1,US%IMM		;YES - SET IMMED FLAG
	RETSKP			;GOOD RETURN

;ROUTINE TO FETCH WORD ITEM FROM ARGLIST (RETURN IN T2)
; CALL:	T1/ ITEM CODE
;	T2/ DEFAULT VALUE

UFWFET:	STKVAR <DFLT>
	MOVEM T2,DFLT		;SAVE DEFAULT VALUE
	CALL USFFND		;FIND ITEM
	 RETBAD (,<MOVE T2,DFLT>)
	LDB T4,[POINTR (T1,US%TYP)]
	CAMN T2,[-1]		;[7456] Default this field?
	JRST UFWFT1		;[7456] Yes
	TXNN T1,US%IMM		;IMMEDIATE CODE?
	CAIN T4,.USASC		;STRING TYPE?
	RETSKP			;[7456] Yes, just return
	HRLI T3,(<MOVE T2,@0>)	;NO - FORM INDIRECT FETCH
	XCTUU T3		; GET ACTUAL VALUE
	RETSKP			;[7456] Return with word in T2
UFWFT1:	MOVE T2,DFLT		;[7456] Get the default value passed to us
	CAMN T2,[-1]		;DEFAULT ALLOWED?
	RETBAD (USGX03)		;NO RETURN ERROR
	RETSKP			;RETURN
	SUBTTL USAGE JSYS -- Wait For Free Space

;ROUTINE TO WAIT A BIT FOR FREE STORAGE

ASGWAT:	OKINT			;ALLOW INTS
	AOS JB0FLG		;POKE JOB 0
	MOVEI T1,^D1000		;WAIT 1 SEC
	DISMS
	RET			;RETURN
	SUBTTL USAGE JSYS -- Get/Put Message on Job 0 Queue

;ROUTINE TO QUEUE UP MESSAGE FOR JOB 0
; T1/ ADDRS OF MESSAGE

ONUSQ:	NOSKED			;PREVENT RACES
	AOS USQCNT		;INCREMENT
	SETZRO UQLNK,(T1)	;MARK END OF QUEUE
	MOVE T2,USGEND		;GET END POINTER
	STOR T1,UQLNK,(T2)	;STORE LINK TO NEXT ITEM
	MOVEM T1,USGEND		;NEW POINTER
	OKSKED
	RET			;RETURN

;ROUTINE TO REMOVE TOP ITEM FROM Q

OFFUSQ::NOINT			;BE NOINT FOR RELFRE
	NOSKED			;INTERLOCK
	SOS USQCNT		;DECREMENT
	SKIPN T1,USGBEG		;ANYTHING ON QUEUE?
	 JRST [	OKSKED			;NO--
		OKINT
		RET]			; JUST RETURN
	LOAD T2,UQLNK,(T1)	;GET POINTER TO NEXT
	MOVEM T2,USGBEG		;STORE NEW HEAD
	JUMPN T2,OFFUS1		;JUMP IF MORE ON LIST
	MOVEI T2,USGBEG-1	;RESET END
	MOVEM T2,USGEND		; ...
OFFUS1:	OKSKED			;ALLOW SCHED
	LOAD T2,UQLEN,(T1)	;GET LENGTH
	CALL RELSWP		;RELEASE BLOCK AND RETURN
	OKINT
	RET
	SUBTTL USAGE JSYS -- Enable Account Validation

;JACKET ROUTINE TO ENABLE ACCOUNT VALIDATION

UFNENA:	MOVE T1,CAPENB		;GET ENABLED CAPABILITIES
	TXNN T1,SC%WHL!SC%OPR	;WHOPER DOING THIS?
	ITERR (CAPX1)		;NO, RETURN ERROR
	CALL ENACT		;GO DO THE WORK
	 RETBAD ()
	RETSKP			;GIVE SUCCESSFUL RETURN

; ENABLE ACCOUNT VALIDATION
; RETURNS: +1	ERROR, ERROR CODE IN AC1
;	   +2	SUCCESS

ENACT::	STKVAR <<ENFDB,11>,ENJFN> ;[7.1010]
	LOCK ACTLCK
	MOVE T1,ACTOFN		;ACCOUNT DATA BASE OFN
	CAMN T1,[-1]		;IS AN OFN ASSIGNED YET?
	JRST ENAC0		;NO, JUST CONTINUE
	SETZ T1,		;UNMAP PAGE WITH HASH TABLE
	HRRZI T2,HSHPG
	CALL SETMPG
	SETZ T1,		;UNMAP ACCOUNT WINDOW PAGE
	HRRZI T2,ACTPG
	CALL SETMPG
	SETOM ACTPGN		;NO ACCT WINDOW PAGE MAPPED IN NOW
	MOVE T1,ACTOFN
	CALL RELOFN		;RELEASE THE OFN
	CAMGE T1,[-1]		;IS THE FILE COMPLETELY CLOSED?
	RETBAD (ENACX1,<UNLOCK ACTLCK>)	;NO, ERROR
	SETOM ACTOFN		;NOW WE HAVE NO OFN FOR ACCT DATA BASE

ENAC0:	MOVX T1,GJ%OLD+GJ%SHT+.GJDEF
	HRROI T2,[ASCIZ/BS:<SYSTEM>ACCOUNTS-TABLE.BIN/]	;[7.1112]
	GTJFN			;GET JFN FOR MOST RECENT DATA BASE
	 RETBAD (ENACX2,<UNLOCK ACTLCK>)
	MOVEM T1,ENJFN		;SAVE JFN FOR NOW
	MOVX T2,<11,,.FBCTL>	;[7.1010]GET FDB STATUS WORD AND XB DISK ADDRESS
	MOVEI T3,ENFDB		;PLACE TO PUT FDB INFO
	GTFDB
	 ERJMP ENACX		;CATCH ANY ERRORS
	MOVE T1,ENFDB		;EXAMINE FILE STATUS
	TXNE T1,FB%LNG		;IS IT A LONG FILE?
	RETBAD (ENACX3,<UNLOCK ACTLCK>)
	MOVEI T1,ENFDB		;[7.1010]ADDRESS OF GTFDB BLOCK
	HRRZ T1,10(T1)		;[7.1010]GET FILE PAGE SIZE
	SKIPG T1		;[7.1010]MUST BE LARGER THAN ZERO
	RETBAD (ENACX5,<UNLOCK ACTLCK>)	;[7.1010] OR IT'S AN ERROR
	MOVEI T1,ENFDB
	MOVE T1,2(T1)		;GET XB DISK ADDRESS
	MOVEI T2,PSNUM		;AND STRUCTURE # OF PS:
	CALL ASSOFN		;GET AN OFN FOR THE DATA BASE
	 RETBAD (ENACX4,<UNLOCK ACTLCK>)
	MOVEM T1,ACTOFN		;SAVE THE NEW OFN
	HRLZS T1		;OFN,, PAGE ZERO
	MOVX T2,PM%RD		;READ ACCESS TO THE HASH PAGE
	HRRI T2,HSHPG
	CALL SETMPG		;MAP IN THE HASH TABLE AT HSHPG
	MOVE T1,ENJFN		;GET JFN FOR FILE
	RLJFN			;RELEASE IT
	 RETBAD ( ,<UNLOCK ACTLCK>)
	SETOM ACTPGN		;NO ACCT WINDOW PAGE MAPPED IN NOW
	SETOM AVALON		;ACCOUNT VALIDATION NOW TURNED ON
	UNLOCK ACTLCK		;ALL DONE FIDDLING WITH THESE PAGES NOW
	RETSKP			;GIVE GOOD RETURN

ENACX:	RETBAD ( ,<UNLOCK ACTLCK>)
	SUBTTL USAGE JSYS -- Set/Read Accounting Shift Change

;Set/read automatic accounting shift change table functions
;
; User args:
;	AC2/	Table address
;
; Table format:
;	XWD actual number of entries, maximum number of entries
;	<table entry>
;	. . .
;	<table entry>
;
; Table entry format:
;	LH:  Days-of-week entry is applicable, bit n on means
;		day-of-week n (0=Monday)
;	RH:  Time in seconds since midnight when shift change should occur

MAXASC==^D100			;Maximum number of entries in table

;Set table

UFNSAS:	CALL USGPRV		;Check priviledges
	 RETBAD ()		;No luck
	UMOVE T2,2		;Get table address
	XCTU [HLRZ Q1,0(T2)]	;Get actual number of enties from table header
	CAILE Q1,MAXASC		;Reasonable table size?
	 RETBAD (ARGX04)	;No-- agument block too long

;Get non-resident dynamic storage for the new table

	NOINT			;DON'T ALLOW ^C WHILE FREE SPACE NOT SIGNED OUT
	JUMPE Q1,UFNSA2		;If table is zero length, just remove old one
	MOVEI T1,1(Q1)		;Get size of table + 1 (for size word)
	CALL ASGSWP		;Get storage
	 RETBAD ()		;None available-- return error

;Form AOBJN pointer to new table in Q1

	MOVEI T3,1(T1)		;Get address + 1 in T3 (for BLT)
	MOVE T1,Q1		;Get length (for BLT)
	MOVN Q1,Q1		;Get -ve size
	HRLZ Q1,Q1		; to LH
	HRR Q1,T3		;Form AOBJN pointer

;Copy user's table into monitor space

	UMOVE T2,2		;Get table address
	ADDI T2,1		;Skip header word
	CALL BLTUM1		;Copy table from monitor space

;Set new table, remove old one if any

UFNSA2:	LOCK ASCLOK		;Lock database and pointer
	EXCH Q1,ASCPTR		;Store new pointer, get old one
	UNLOCK ASCLOK		;Unlock database
	JUMPE Q1,UFNSA8		;All done if no old table
	MOVEI T1,-1(Q1)		;Get address of size word
	MOVE T2,0(T1)		;Get size of block from size word
	CALL RELSWP		;Return the block to free pool

UFNSA8:	OKINT
	CALL NXTASC		;Compute next accounting shift change
	RETSKP			;Return successful from UFNSAS


;Read table

UFNRAS:	CALL USGPRV		;Check for privilged user
	 RETBAD ()		;No luck
	LOCK ASCLOK		;Lock database and pointer
	HLRE T1,ASCPTR		;Get -ve length of table
	MOVN T1,T1		;Compute number of entires
	UMOVE T3,2		;Get user table address
	XCTU [HRRZ T2,0(T3)]	;Get max size of user table
	CAMGE T2,T1		;Will monitor table fit in user table?
	 JRST [	UNLOCK ASCLOK
		RETBAD (ARGX05)] ;No-- Argument block too small
	XCTU [HRLM T1,0(T3)]	;Yes-- store size of actual table
	HRRZ T2,ASCPTR		;Get monitor's table address
	ADDI T3,1		;Skip header word in user table
	SKIPE T1		;Any data to move?
	 CALL BLTMU1		;Yes-- copy monitor table to user space
	UNLOCK ASCLOK		;Unlock database
	RETSKP			;Return successful from UFNRAS
	SUBTTL Usage Support Routines -- Initialization

;USAGE UTILITIES FOR JOB 0

;USAGE VARIABLES

NR CKPGID,1			;PAGE IDENT OF CURRENT MAPPED PAGE UN CHECKPOINY FILE

;INIT USAGE DATA BASE

USGINI::SAVEAC <Q1,Q2,Q3>	;[7.1200] Preserve all temp work regs
	STKVAR <CKPNJ,CKIDNT>
	SETOM USGLOK		;CLEAR LOCKS
	SETZM USQCNT		;EMPTY QUEUE
	SETZM USGBEG		;INIT QUEUE
	MOVEI T1,USGBEG-1
	MOVEM T1,USGEND		;TO BE EMPTY
	SETZM USGEOF		;INIT EOF POINTER
	SETZM CKPJFN		;NO JFN'S YET
	SETZM USGJFN		;...
	SETZM CKPGID		;NO PAGE MAPPED
	MOVE T1,TODCLK		;SETUP FIRST CHECKPOINT INTERVAL
	ADD T1,CKPINV
	MOVEM T1,CKPTIM		;TIME FOR FIRST CHECKPOINT
	MOVX T1,SF%CDE		;FILE SYSTEM OK?
	TDNE T1,FACTSW
	JRST [	TMSG <? System accounting will not be done due to file system errors
>
		RET]
USGIN1:	HRROI T2,USGFIL		;FILESPEC FOR USAGE FILE
	CALL USGOPN		;OPEN FILE
	 JRST [	CALL CRUSGF	;NONE - CREATE USAGE FILE
		 BUG.(HLT,UXXCRE,JSYSM,SOFT,<Cannot create usage file>,,<

Cause:	If the GTJFN (GJ%PHY,GJ%OLD) or the OPENF (OF%RD, OF%WR, OF%RTD) on the
	checkpoint file ACCOUNT:CHECKPOINT.BIN.1 fails, then another GTJFN
	(GJ%FOU) and OPENF (OF%WR) is attempted in order to create a new
	checkpoint file.  If the second try GTJFN and OPENF fail, the UXXCRE
	BUGHLT occcurs.

Action:	Analyze the error code from the failing JSYS, and use EDDT to patch the
	system so that you can fix the checkpoint file so that the error does
	not happen.
>)				;[7.1279]
		JRST USGIN1]	;TRY AGAIN

	MOVEM T1,USGJFN		;STORE JFN
	TXO T1,CO%NRJ		;RETAIN JFN
	CLOSF			;THIS SHOULD CORRECT PAGE COUNT
	 JFCL			;SHOULDN'T HAPPEN
	MOVX T2,44B5+OF%RD!OF%WR!OF%RTD
	MOVE T1,USGJFN		;FETCH JFN
	OPENF			;OPEN FOR REAL NOW
	 BUG.(HLT,UXXOPN,JSYSM,SOFT,<Unable to open usage file>,,<

Cause:	USGINI invoked OPENF (OF%RD, OF%WR, OF%RTD), which failed to open the
	USAGE file ACCOUNT:SYSTEM-DATA.BIN.

Action:	Use EDDT to bring the system up without accounting and repair the
	problem.
>)				;[7.1279]
	HRRZ T1,T1		;GET RID OF OPEN FLAGS
	FFFFP			;FIND-FIRST-FREE-FILE PAGE
	HRRZ Q1,T1		;SAVE PAGE NUMBER
	MOVE T1,USGJFN		;JFN AGAIN
	MOVE T2,[1,,.FBBYV]	;GET PAGE COUNT
	MOVEI T3,T4		; INTO T4
	GTFDB
	HRRZS T4		;PAGE # ONLY
	CAME Q1,T4		;CORRECT NUMBER
	BUG.(INF,USGHOL,JSYSM,HARD,<Lost page(s) in usage file>,,<

Cause:	This BUGINF indicates that the first free page in the USAGE file as
	reported by FFFFP% is not the last page in the file.  This means
	that the file has holes in it, or lost pages.

Action:	The USAGE file ACCOUNT:SYSTEM-DATA.BIN should be repaired or deleted.
>,,<DB%NND>)			;[7.1279][7.1210] 
	JUMPE Q1,USGIN4		;EMPTY FILE IF 0
USGIN2:	SETZ Q2,		;INIT TO WORD 0
	JUMPL Q1,USGIN3		;MUST BE EMPTY IF NONE LEFT
	SOS T1,Q1		;WANT LAST PAGE
	HRL T1,USGJFN		; FROM USAGE FILE
	MOVX T2,PM%RD		;READ ONLY
	CALL USGMAP		;MAP PAGE
	MOVEI Q2,777		;SCAN BACK FROM END OF PAGE
	SKIPN T1,FPG0A(Q2)	; FOR FIRST NON-ZERO WORD
	SOJGE Q2,.-1		;...
	AOJE Q2,[SOJA Q1,USGIN2] ;PAGE WAS ALL ZEROS
				;ADJUST COUNT TO FIRST AVAIL WORD
	;..
	;..
USGIN3:	IMULI Q1,PGSIZ		;CALC EOF POINTER
	ADD Q1,Q2
USGIN4:	MOVEM Q1,USGEOF		;SETUP LOC

;CHECKPOINT INIT

USGIN5:	HRROI T2,CKPFIL		;FILE NAME FOR CHECKPOINT
	CALL USGOPN		;OPEN IT
	 JRST [	CALL CRCKPT	;NON-EX CREATE NEW ONE
		 BUG.(HLT,UXXCKP,JSYSM,SOFT,<Couldn't create checkpoint file>,,<

Cause:	The file ACCOUNT:CHECKPOINT.BIN.1 could not be referenced for one
	reason or another.  The code first attempts a GTJFN (GJ%PHY, GJ%OLD)
	and an OPENF (OF%RD, OF%WR, OF%RTD), one of which must fail for UXXCKP
	to be a possibility.

	After the above GTJFN or OPENF has failed, then a GTJFN (GJ%PHY,
	GJ%NEW) is attempted.  If this succeeds, then UXXCKP will occur if a
	failure happens on one of the following: the subsequent OPENF
	(OF%WR,OF%RD), the call to ASGSWP to allocate CKPSIZ words, or the SOUT
	writing CKPSIZ words to the checkpoint file.

	If the GTJFN (GJ%PHY, GJ%NEW) fails, then another GTJFN (GJ%PHY,
	GJ%DEL) is attempted, and its failure will cause UXXCKP.  If this GTJFN
	succeeds, however, then a CHFDB (turning off FB%DEL to undelete the
	file) is done, and its failure will also cause UXXCKP.

Action:	Use EDDT to patch the system so that you can bring up the system
	without the checkpoint file being referenced.  Then get the checkpoint
	file into a state such that none of the above failures will occur.
>)				;[7.1279]
		JRST USGIN5]
	MOVEM T1,CKPJFN		;SAVE JFN
	HRLZS T1		;START AT PAGE 0
	MOVEM T1,CKIDNT		;SAVE IDENT
	MOVX T2,PM%RD
	CALL USGMAP		;MAP PAGE

	MOVE Q1,FPG0A+1		;GET # OF JOBS IN FILE
	ERJMP CKPBAD		;IF NON-EX PAGE, FILE IS BAD
	MOVE T1,FPG0A+3		;SIZE OF CHECKPOINT RECORD
	CAIN T1,CKPSIZ		;BETTER BE SAME
	CAIGE Q1,NJOBS		;.GE. MAX JOBS IN MONITOR
CKPBAD:	JRST [	BUG.(INF,UXXFIT,JSYSM,HARD,<Checkpoint file not in correct format for this system, rebuilding>,,<

Cause:	The ACCOUNT:CHECKPOINT.BIN file is not in the correct format for this
	monitor's configuration.  This can occur if the value of NJOBS has
	changed from the previous monitor or if the size of the checkpoint
	records has changed.  This BUGCHK can be expected if the monitor
	version has changed or a monitor with a different configuration has
	been loaded.

Action:	TOPS-20 will rebuild the checkpoint file, no further action is needed.
>,,<DB%NND>)			;[7.1279][7.1210] 
		CALL UNMAPC
		MOVE T1,CKPJFN	;CLOSE AND DELETE (EXPUNGE)
		TXO T1,CO%NRJ
		CLOSF
		 JFCL
		MOVE T1,CKPJFN
		TXO T1,DF%EXP
		DELF
		 JFCL
		SETZM CKPJFN
		JRST USGIN5]	;START OVER FOR CHECKPOINT
	MOVEM Q1,CKPNJ		;SAVE NUMBER OF JOBS IN FILE
	MOVE T1,FPG0A+2		;GET DATE/TIME OF LAST CHECKPOINT
	MOVEM T1,CKPDTL		;SAVE
	SKIPN USGEOF		;USAGE FILE EMPTY?
	JRST USGI6B		;YES - SKIP THIS
	HRLZ T1,CKPJFN		;START AT PAGE 0 AGAIN
USGIN6:	MOVEI Q2,PGSIZ/CKPSIZ	;NUMBER OF JOBS/PAGE
	SETZ Q3,		;[7.1200] Init offset
	MOVX T2,PM%RD
	MOVEM T1,CKIDNT		;SAVE IDENT
	CALL USGMAP
	SKIP FPG0A		;TEST PAGE FOR GOODNESS
	ERJMP CKPBAD		;NOT GOOD IF INTERRUPT TAKES
USGI6A:	SKIPLE T4,FPG0A(Q3)	;[7.1200]  .GT. 0 means write in progress
	MOVEM T4,USGEOF		;THIS IS ACTUAL USGEOF
	ADDI Q3,CKPSIZ		;[7.1200] Step to next entry
	SOJLE Q1,USGI6B		;MORE JOBS TO DO?
	SOJG Q2,USGI6A		;YES - MORE IN THIS PAGE?
	MOVE T1,CKIDNT		;RESTORE LAST PAGE MAPPED
	AOJA T1,USGIN6		;STEP TO NEXT PAGE

USGI6B:	CALL UNMAPC		;UNMAP CHECKPOINT PAGE; THIS IS THE LAST TIME
				; WE WILL BE USING ONLY READ ACCESS
	MOVE T1,USGJFN		;GET USAGE FILE JFN
	MOVE T2,USGEOF		;CURRENT EOF
	SFPTR			;SET TO START WRITTING HERE
	 JFCL			;IGNORE ERRORS
	MOVX T1,SF%USG		;TURN ON USAGE JSYS
	IORM T1,FACTSW		;...

	MOVE T1,TODCLK		; GET MONITOR UPTIME IN MSEC
	IDIVI T1,^D1000		; MAKE IT SECONDS
	MOVEM T1,USGMUP		; AND STORE IT WHERE RESTART LIST KNOWS
	MOVE T1,TODCLK		; GET MONITOR UPTIME IN MSEC
	IDIVI T1,^D1000		; MAKE IT SECONDS
	MOVEM T1,USGMUP		; AND STORE IT WHERE RESTART LIST KNOWS
				;WRITE RESTART RECORD NOW
	MOVEI T1,.USENT		;GENERATE ENTRY
	MOVEI T2,RSTLST		;POINT TO RESTART LIST
	USAGE			;THIS WILL MAKE A RECORD ON USQ
	CALL USGMES		;IMMEDIATELY WRITE INTO FILE
	MOVEI Q1,1		;MERGE CHECKPOINT FILE
	SOS CKPNJ		; FOR JOBS 1 THRU NJOBS-1
	CALL LGTAD		;GET DATE/TIME
	MOVE Q2,T1		;SAVE IN Q2
USGIN7:	MOVE T1,Q1		;JOB #
	CALL USGSPG		;SET PAGE FOR THIS JOB
	SKIPGE 0(T4)		;IS ENTRY ACTIVE?
	JRST USGIN8		;NO, GET NEXT ENTRY
	MOVEI T2,.UTCKP		;RECORD TYPE FOR CHECKPOINT MERGE
	HRLM T2,1(T4)		;STORE IN HEADER
	HRRZ T3,1(T4)		;GET RECORD LENGTH
	CAIL T3,CKPSIZ		;IS LENGTH LESS THAN MAX SIZE?
	JRST [	BUG.(CHK,CKPLEN,JSYSM,HARD,<USGINI - Illegal checkpoint entry length>,,<

Cause:	While executing USGINI, an active checkpoint entry was found with an
	illegal length.  This could be caused by a trashed checkpoint file.

Action:	Delete ACCOUNT:CHECKPOINT.BIN and reload system.
>)				;[7.1279]
		JRST USGIN8]	;AND IGNORE ENTRY
	ADD T3,T4		;ADD IN BASE
	HRLM T2,0(T3)		;STORE TYPE IN TRAILER ALSO
	MOVEM Q2,2(T4)		;SET ENTRY DATE/TIME TO NOW.
	CALL USGUP0		;UPDATE FOR THIS JOB
USGIN8:	CAMGE Q1,CKPNJ		;DONE?
	AOJA Q1,USGIN7		;NO - INCR AND PROCEDE
	CALL UNMAPC		;UNMAP CHECKPOINT PAGE
	CALLRET NXTASC		;Find next acct shift change time
				; and return from USGINI

;Initialize accounting shift change stuff
;Must be done before SETSPD is run!!!

ASCINI::SETZM ASCPTR		;[7.1200] No accounting shift changes yet
	SETZM ASCTIM		; and no time set for next one
	SETOM ASCLOK		;Leave ASCPTR lock unlocked
	RET			;Return from ASCINI

;RESTART ENTRY DATA LIST

RSTLST:	USENT. (.UTRST,1,1)	;RESTART RECORD TYPE
	USSNM. (<-1,,SVN>)	;SYSTEM NAME STRING
	USMVR. ([EXP SVNM])	;SYSTEM VERSION NUMBER
	USPNM. (<SIXBIT "MONITR">,US%IMM)
	USPVR. ([EXP SVNM])	;MONITOR NAME/VERSION FOR USAGE
	USMBD. (SYSTAD)		;MONITOR BUILD DATE/TIME
	USMUP. (USGMUP)		; MONITOR UPTIME SINCE LAST RELOAD
	USLCK. (CKPDTL)		;DATE/TIME OF LAST CHECKPOINT
	USMUP. (USGMUP)		; MONITOR UPTIME SINCE LAST RELOAD
	USCP0. (APRSER)		;APR SERIAL NUMBER
	0			;END OF LIST

;ROUTINE TO OPEN A FILE FOR READ/WRITE

USGOPN:	MOVX T1,GJ%SHT!GJ%PHY!GJ%OLD!GJ%ACC
	GTJFN
	 RET			;NON-EX RETURN
	MOVX T2,44B5+OF%RD!OF%WR!OF%RTD
	OPENF			;OPEN FILE
	 RET			;FAILURE
	RETSKP			;OK - RETURN

;ROUTINE TO CREATE USAGE FILE

CRUSGF:	MOVX T1,GJ%SHT!GJ%PHY!GJ%FOU
	HRROI T2,USGFIL
	GTJFN
	 RET			;ERROR
	MOVX T2,44B5+OF%WR	;WRITE FIRST
	OPENF
	 RET			;FAILURE
	CALL USGNOD		;SET NO-DUMP
	HRLI T1,.FBBYV		;CHANGE THIS WORD
	TXO T1,CF%NUD
	MOVX T2,FB%RET		;RETENTION COUNT
	MOVEI T3,0		; TO BE 0
	CHFDB
	HRRZS T1		;JFN ONLY AGAIN
	CLOSF			;FIX ON DISK
	 JFCL
	RETSKP			;GOOD RETURN
	SUBTTL Usage Support Routines -- Checkpoint File

;ROUTINE TO COPY CHECKPOINT ENTRY TO USAGE FILE
; T1/ PAGE IDENT
; T4/ ENTRY ADDRESS

USGUP0:	CALL USGUPS		;Perform file update
	SETOM 0(T4)		;SET ENTRY FREE
	RET			;RETURN FROM USGUP0

; Subroutine to copy current checkpoint entry into USAGE file entry

USGUPS:	SKIPGE 0(T4)		;ENTRY ACTIVE?
	 RET			;NO - NOTHING TO DO
	MOVE T1,USGEOF		;GET CURRENT EOF
	MOVEM T1,0(T4)		;SAVE IN CHECKPOINT
	MOVE T1,USGJFN		;JFN FOR USAGE FILE
	MOVEI T2,1(T4)		;ADDRS OF DATA
	HRLI T2,(POINT 36,,)	;FORM BP
	HRRZ T3,0(T2)		;GET LENGTH OF ITEM
	ADDM T3,USGEOF		;UPDATE USAGE EOF POINTER
	MOVNS T3		;MAKE NEGATIVE
	SOUT			;DUMP INTO FILE
	 ERJMP [CALL USGIOE	;REPORT IO ERROR
		JRST .+1]
	MOVE T1,USGEOF		;CALC PAGE JUST WRITTEN
	LSH T1,-PGSFT
	HRL T1,USGJFN		;FORM IDENT
	MOVEI T2,1		;DO ONE PAGE
	UFPGS			;UPDATE FILE PAGE
	 ERJMP USGIOE		;[7456] Report IO error and return
	RET			;Return from USGUPS

;IO ERROR IN USAGE FILE

USGIOE:	MOVE T1,USGEOF		;REPORT BAD PAGE
	LSH T1,-PGSFT
	BUG.(CHK,UXXWER,JSYSM,HARD,<Write error in usage file>,<<T1,PAGE>>,<

Cause:	A SOUT or UFPGS error occurred while trying to write to the USAGE file
	ACCOUNT:SYSTEM-DATA.BIN. This indicates that there is a hard error in
	the file.

Action:	The USAGE file ACCOUNT:SYSTEM-DATA.BIN must be repaired or deleted.

Data:	PAGE - Page number in USAGE file
>,,<DB%NND>)			;[7.1279][7.1210] 
	RET			;CONTINUE

;ROUTINE TO CREATE A CHECKPOINT FILE

CRCKPT:	STKVAR <SCKJFN>
	HRROI T2,CKPFIL
	MOVX T1,GJ%SHT!GJ%PHY!GJ%NEW ;NEW ONLY
	GTJFN
	 ERJMP [MOVX T1,GJ%SHT!GJ%PHY!GJ%DEL	;HANDLE CASE OF THE
		HRROI T2,CKPFIL	; DELETED BUT NOT EXPUNGED FILE
		GTJFN		; TO PREVENT UXXCKP BUGHLTS
		 ERJMP R	;NOT THAT CASE
		HRLI T1,.FBCTL	;WORD IN FDB TO CHANGE
		MOVX T2,FB%DEL	;TO UNDELETE FILE
		SETZM T3	;CLEAR DELETED BIT
		CHFDB		;DO IT
		 ERJMP R	;FAILURE
		HRRZS T1	;CLEAR STUFF FROM LEFT HALF
		JRST .+1]	;AND CONTINUE
	MOVEM T1,SCKJFN		;SAVE FOR LATER
	MOVX T2,44B5+OF%WR!OF%RD ;READ/WRITE
	OPENF
	 RET			;FAILURE
	CALL USGNOD		;SET NO-DUMP
	NOINT			;APPEASE FREE SPACE ROUTINES
	MOVEI T1,CKPSIZ		;ALLOCATE BUFFER
	CALL ASGSWP		; FOR CHECKPOINT RECORD
	 RETBAD (,OKINT)	;NONE TO BE HAD
	MOVE Q2,T1		;SAVE BASE ADDRS
	MOVEI Q1,NJOBS		;INIT FOR NUMBER OF JOBS
	SETOM 0(Q2)		;-1 SHOWS FREE ENTRY
	MOVEM Q1,1(Q2)		;STORE # OF JOBS IN JOB 0
	CALL LGTAD
	MOVEM T1,2(Q2)		;DATE/TIME OF LAST CHECKPOINT
	MOVEI T1,CKPSIZ		;SIZE OF CHECKPOINT RECORD
	MOVEM T1,3(Q2)
	MOVE T1,SCKJFN		;GET JFN
	HRLI Q2,(POINT 36,,)	;FORM BP
CRCKP1:	MOVE T2,Q2		;COPY BP
	MOVNI T3,CKPSIZ		;SIZE OF ENTRY
	SOUT			;WRITE IT
	 ERJMP [OKINT		;UNDO NOINT
		RETBAD ()]	;AND GIVE ERROR
	SOJG Q1,CRCKP1		;LOOP OVER ALL JOBS
	CLOSF			;CLOSE FILE
	 JFCL
	HRRZ T1,Q2		;ADDRS OF TEMP BLOCK
	MOVEI T2,CKPSIZ		; ITS SIZE
	CALL RELSWP		;RELEASE STORAGE
	OKINT			;UNDO NOINT
	RETSKP			;GOOD RETURN

;ROUTINE TO UPDATE CHECKPOINT PAGE AND UNMAP IT

UNMAPC:	MOVEI T2,1		;1 PAGES
	SKIPE T1,CKPGID		;PAGE IDENT OF LAST PAGE MAPPED
	UFPGS			;UPDATE ON DISK
	 JFCL			;WE TRIED
	SETZB T1,CKPGID		;UNMAP PAGE, MARK NO PAGE MAPPED
	MOVEI T2,FPG0A
	CALLRET SETMPG		;...


;ROUTINE TO SET (MAP) CHECKPOINT FILE PAGE FOR JOB N
; T1/ JOB #
;RETURNS:	T4/ ENTRY ADDRESS
;		T1/ PAGE IDENT

USGSPG:	IMULI T1,CKPSIZ		;CALC CHECKPOINT LOC
	IDIVI T1,PGSIZ		;T1 := PAGE , T2 := LINE
	PUSH P,T2		;SAVE LINE
	HRL T1,CKPJFN		;FORM JFN,,PN
	MOVX T2,PM%RD!PM%WR	;READ/WRITE
	CALL USGMAP
	POP P,T4		;RESTORE OFFSET
	ADDI T4,FPG0A		;ADD IN BASE
	RET			; AND RETURN

;ROUTINE TO SET FB%NOD (NODUMP) FOR FILE JFN IN T1

USGNOD:	HRLI T1,.FBCTL		;SAY WORD 1
	TXO T1,CF%NUD		;NO UPDATE DIRECTORY
	MOVX T2,FB%NOD		;SET BIT AND MASK
	MOVX T3,FB%NOD
	CHFDB			;WRITE INTO FDB
	HRRZS T1		;RETURN JFN INTACT
	RET

;ROUTINE TO MAP A PAGE OF A FILE INTO FPG0
;CALL: T1/ JFN,,PAGE#
;      T2/ ACCESS BITS

USGMAP:	CAMN A,CKPGID		;IS THIS PAGE ALREADY MAPPED?
	 RET			;YES-- RETURN NOW FROM USGMAP
	PUSH P,T2		;SAVE ACCESS INFO
	PUSH P,T1		;SAVE PAGE ID
	MOVEI T2,1		;ONE PAGE TO UPDATE
	SKIPE T1,CKPGID		;GET CURRENT PAGE THAT'S MAPPED
	UFPGS			;UPDATE IT
	 JFCL			;WE TRIED
	POP P,T1		;RESTORE PAGE IDENT
	MOVEM T1,CKPGID		;REMEMBER NEW PAGE IDENT
	CALL JFNOFN		;CONVERT TO OFN,,PN
	 BUG.(HLT,UXXMAP,JSYSM,SOFT,<USGMAP - Call to JFNOFN failed>,,<

Cause:	USGMAP wants to map a page of a file into FPG0 via SETMPG.
	It calls JFNOFN to convert the JFN.PN atom to OFN.PN, which SETMPG
	wants.  If JFNOFN fails, this BUGHLT occurs.  Some reasons that JFNOFN
	will fail are: JFN is not associated with a disk file; JFN is not open;
	attempt to create a new page table for a file that is not open for
	writing; attempt to create a new page table for a directory file;
	attempt to create a new page table for which there is no room on disk.
>)
	POP P,T2		;RESTORE ACCESS INFO
	HRRI T2,FPG0A		;ADDRS TO MAP PAGE
	CALLRET SETMPG		;MAP THE PAGE
	SUBTTL Usage Support Routines -- Queued Message Handler

;USAGE QUEUED MESSAGE HANDLER

USGMES::SAVEAC <Q1,Q2,Q3>	;[7.1200] Save regs
USGMS0:	SKIPN Q1,USGBEG		;ANYTHING ON QUEUE?
	RET			;NO - DONE
	LOAD T1,UQFCN,(Q1)	;GET FCN CODE
	CAILE T1,USGLGL		;CHECK VALID
USGBFC:	BUG.(HLT,UXXILL,JSYSM,SOFT,<USGMES - Illegal function code>,,<

Cause:	The USAGE JSYS causes entries in the usage queue.  Each
	entry has a dispatch offset which is used by USGMES as an index into
	a vector for calling the appropriate support routine.

	If the dispatch offset is too large, this BUGHLT occurs.  Since the
	monitor itself is creating the entries in the queue, such a mismatch
	should never occur.
>)
	CALL @USGREQ(T1)	;DISPATCH
	CALL OFFUSQ		;REMOVE FROM QUEUE
	JRST USGMS0		;LOOP TILL DONE

;DISPATCH TABLE

USGREQ:	DTBDSP (USGENT)		;0 - WRITE ENTRY INTO FILE
	DTBDSP (USGCLS)		;1 - CLOSE OUT FILE
	DTBDSP (USGCKU)		;2 - CHECKUOINT
	DTBDSP (USGLGI)		;3 - LOGIN
	DTBDSP (USGLGO)		;4 - LOGOUT
	DTBDSP (USGSEN)		;5 - SESSION ENTRY
	DTBDSP (USGBFC)		;6 - ILLEGAL
	DTBDSP (USGBFC)		;7 - ILLEGAL
	DTBDSP (USGASU)		;10 - Accounting shift change
   USGLGL==.-USGREQ-1
	SUBTTL Usage Support Routines -- Checkpoint/Shift Change Timing

;JOB 0 ROUTINE TO PERFORM CHECKPOINT TIMING

CHKCKP::MOVE T1,TODCLK		;[7.1200] Current time
	CAMGE T1,CKPTIM		;TIME FOR CHECKPOINT?
	RET			;NO - RETURN
	SAVEAC <Q1,Q2,Q3>	;[7.1200] Save regs
	MOVE T1,FACTSW		;CHECK IF ACCOUNTING
	TXNE T1,SF%USG		;???
	CALL USGCKP		;YES - CHECKPOINT ALL JOBS
	MOVE T1,TODCLK		;RESET NEXT TIME
	ADD T1,CKPINV		;ADD INTERVAL
	MOVEM T1,CKPTIM		;SAVE NEW TIME
	RET			;RETURN


;Job 0 routine to perform automatic accounting shift change

CHKASC::SKIPE T1,ASCTIM		;[7.1200] Get next accounting shift change time
	CAMLE T1,TODCLK		;Time for change yet?
	 RET			;Not yet.
	SAVEAC <Q1,Q2,Q3>	;[7.1200] Need all the Q's for this...
	MOVE T1,FACTSW		;Get current state bits
	TXNE T1,SF%USG		;Doing accounting today?
	 CALL USGASC		;Yes-- perform accounting shift change
;	CALLRET NXTASC		;Compute next time for change and return from CHKASC
; NXTASC - Compute next accounting shift change time
;
; Register usage in this routine:
; T1/	Current DOW/time table entry
; T2/	Time selected from table (-1 if none found yet)
; T3/	Bit for current DOW (day-of-week) being tested
; T4/	Current pointer to DOW/time table
; Q1/	Bit for DOW of today
; Q2/	Current time in seconds since midnight of the day being tested
;	(will be negative if other than today)

; DOW/time table entry format:
; LH:	Bit n on means that this entry valid on day-of-week (DOW) n
;	(0=Monday)
; RH:	Time-of-day when shift will occur on selected DOWs, in
;	seconds since midnight.

NXTASC::
	SAVEAC <Q1,Q2,Q3>	;[7.1200] Need all the Q's
	LOCK ASCLOK		;Lock time table database

	MOVX T2,-1		;Use current date/time
	MOVX T4,0		;No options
	ODCNV			;Get time, day-of-week, etc.
	 ERJMP NXTAS7		;No date/time-- set next time to never
	HRRZ Q2,T4		;Save the seconds since midnight now
	MOVX Q1,1B0		;Get first bit for Monday
	MOVNI T1,(T3)		;Get -ve day of week (0=Monday)
	LSH Q1,(T1)		;Get bit for this day of week in Q1
	MOVE T3,Q1		;Start testing at today's DOW

	MOVX T2,^D<24*60*60>	;Indicate no time found yet

; Loop through table, once for each DOW in the future, until
;  next accounting shift change time is found

NXTAS1:	SKIPN T4,ASCPTR		;Get AOBJN pointer to DOW/time table
	 JRST NXTAS7		;No table-- set next time to infinity

; Loop through table for this DOW to see if any changes this day

NXTAS2:	MOVE T1,(T4)		;Get entry from table
	TDNN T1,T3		;Entry in effect this DOW?
	 JRST NXTAS3		;No-- skip it
	CAIGE Q2,(T1)		;Has the time for this change already past?
	CAIG T2,(T1)		; or have we already found an earlier time?
	 JRST NXTAS3		;Yes to either question-- skip entry
	HRRZ T2,T1		;Found a reasonable time-- remember it

NXTAS3:	AOBJN T4,NXTAS2		;Loop through whole table

	CAIGE T2,^D<24*60*60>	;Find a valid entry?
	 JRST NXTAS8		;Yes-- go compute time from now

; No time found this DOW-- step to next day in future and search table again

	TDNE T3,Q1		;Back to today?
	 JUMPL Q2,NXTAS7	;Yes-- give up if not first time
	SUBI Q2,^D<24*60*60>	;Step current time back another day
	LSH T3,-1		;Shift to next DOW
	TXNE T3,1B7		;Beyond Sunday?
	 MOVX T3,1B0		;Yes-- reset back to Monday
	JRST NXTAS1		;Keep searching table

; No table or no entries with any DOW's-- set next time to infinity

NXTAS7:	SETZ T2,		;Indicate no time set
	JRST NXTAS9		;Store and return

; Found next applicable table entry-- find out when the change should occur

NXTAS8:	SUB T2,Q2		;Compute seconds from now till
				; when entry time will occur
	IMULI T2,^D1000		;Convert to TODCLK units of MS
	ADD T2,TODCLK		;Compute TODCLK time when we will change

NXTAS9:	MOVEM T2,ASCTIM		;Save next change time
	UNLOCK ASCLOK		;Unlock ASCPTR database
	RET			;Return from NXTASC
	SUBTTL Usage Support Routines -- Write Usage File

;WRITE ENTRY INTO FILE FROM QUEUE

USGENT:	MOVE T1,USGJFN		;GET JFN
	MOVEI T2,UQDAT(Q1)	;POINT TO DATA
	HRLI T2,(POINT 36,,)	;FORM BP
	HRRZ T3,UQDAT(Q1)	;GET LENGTH OF ITEM
	ADDM T3,USGEOF		;UPDATE EOF POINTER
	MOVNS T3		;NEGATE
	SOUT			;WRITE IN FILE
	 ERJMP [CALL USGIOE	;REPORT ERROR
		JRST .+1]
	MOVE T1,USGEOF		;CALC PAGE JUST WRITTEN
	LSH T1,-PGSFT
	HRL T1,USGJFN		;FORM IDENT
	MOVEI T2,1		;DO ONE PAGE
	UFPGS			;UPDATE FILE PAGE
	 ERJMP USGIOE		;OH WELL...
	RET			;DONE

;CLOSE OUT CURRENT FILE AND START A NEW ONE

USGCLS:	STKVAR <NJFN>
	CALL CRUSGF		;CREATE A NEW FILE
	 JRST [	BUG.(CHK,UXXCL1,JSYSM,HARD,<Unable to create new usage file>,<<T1,ERRCOD>>,<

Cause:	The USAGE file ACCOUNT:SYSTEM-DATA.BIN could not be created. This error
	will occur if a JFN cannot be obtained on the file or if it cannot be
	opened.

Data:	ERRCOD - JSYS error code
>,,<DB%NND>)			;[7.1279][7.1210] 
		RET]		;JUST EXIT - NOTHING DONE
	HRROI T2,USGFIL		;NOW OPEN IT
	CALL USGOPN
	 JRST [	BUG.(CHK,UXXCL2,JSYSM,HARD,<Unable to open new usage file>,<<T1,ERRCOD>>,<

Cause:	This bug indicates that the USAGE file ACCOUNT:SYSTEM-DATA.BIN could
	not be opened.  This will occur if a JFN cannot be obtained on the file
	or if the file cannot be opened.

Data:	ERRCOD - JSYS error code
>,,<DB%NND>)			;[7.1279][7.1210] 
		RET]		;TOUGH AGAIN
	MOVEM T1,NJFN		;SAVE NEW JFN
	MOVE T1,USGJFN		;GET CURRENT JFN
	HRLI T1,.FBCTL		;THIS WORD
	TXO T1,CF%NUD		;DONT UPDATE DIR
	MOVX T2,FB%NOD		;SET TO CLEAR THIS BIT
	SETZ T3,		; TO ALLOW FILE TO DUMP
	CHFDB
	 ERJMP .+1		;WE TRIED
	HRRZS T1		;RESTORE JFN
	CLOSF			;CLOSE OUT FILE
	 BUG.(CHK,UXXCL3,JSYSM,HARD,<Unable to close usage file>,,<

Cause:	This bug indicates that TOPS-20 could not CLOSF the USAGE file
	ACCOUNT:SYSTEM-DATA.BIN.  This bug is highly unlikely unless the JFN
	has been lost.

Data:	ERRCOD - JSYS error code
>,,<DB%NND>)			;[7.1279][7.1210] 
	SETZM USGEOF		;SETUP FOR NEW FILE
	MOVE T1,NJFN
	MOVEM T1,USGJFN		;NOW HAVE NEW FILE TO USE
	UNLOCK (USGLOK)		;UNLOCK WAITER
	RET			;RETURN
	SUBTTL Usage Support Routines -- Update Checkpoint File

;ROUTINE TO SET CHECKPOINT FROM QUEUE
;RETURNS: Q2/ PAGE IDENT

UCKSET:	LOAD T1,UQLJI,(Q1)	;Get Local job index from USAGE header
	CALL USGSPG		;SET CHECKPOINT PAGE
	MOVE Q2,T1		;SAVE IDENT
	MOVEI T1,2(T4)		;SET FROM,,TO FOR CLEAR
	HRLI T1,1(T4)		;...
	SETZM 1(T4)		;ZERO FIRST WORD
	BLT T1,CKPSIZ-1(T4)	;CLEAR
	MOVEI T1,1(T4)		;POINT TO DESTINATION
	HRLI T1,UQDAT(Q1)	; LHS := DATA
	HRRZ T2,UQDAT(Q1)	;GET LENGTH
	ADD T2,T4		;LAST WORD OF XFER
	BLT T1,0(T2)		;MOVE DATA
	SETZM 0(T4)		;MARK ITEM INUSE
	RET			;RETURN DONE

;HANDLE USAGE LOGIN

USGLGI:	CALL UCKSET		;COPY DATA TO CHECKPOINT
	CALLRET UNMAPC		;EXIT AND UNMAP PAGE

;HANDLE USAGE LOGOUT

USGLGO:	CALL UCKSET		;COPY DATA TO CHECKPOINT
	MOVE T1,Q2		;SETUP IDENT
	CALL USGUP0		;UPDATE USAGE FILE (CLEAR CKPT)
	CALLRET UNMAPC		;EXIT AND UNMAP PAGE

;[7456] USGSEN - Handle session end: copy the queued information to the
;[7456] checkpoint area, write the queued info to the usage file, then reset
;[7456] the connect time, run time, and session begin time in the checkpoint
;[7456] file.
;[7456] Call with:
;[7456] 	Q1/ pointer to queued USAGE information
;[7456] Returns: +1 always
;[7456] Clobbers: T1, T2, T4

USGSEN:	CALL UCKSET		;(Q1/T4) Copy queue info to checkpoint record
	CALL USGUP0		;(T4/) Merge queued info into usage file
	HRRZ T1,1(T4)		;Load length of checkpointed information
	ADDI T1,CKOFF(T4)	;Compute beginning of stored session data
	SETZM 1(T1)		;Zero the console connect time
	SETZM 2(T1)		;Zero the run time
	MOVE T2,UQDAT+1(Q1)	;Get end time of the last session
	MOVEM T2,0(T1)		;Stash as new session start time
	CALLRET UNMAPC		;Unmap checkpoint page and return
;ROUTINE TO UPDATE CHECKPOINT ENTRY FOR A SINGLE JOB
; T1/ JOB NUMBER

CPOINT:	SETZM ASCFLG		;Don't perform accounting shift change
CPONT0:	SAVEAC <Q1,Q2,Q3>	;[7.1200] Save regs
	STKVAR <PGID,CPAD,CPIP>	;Page ident, chekpoint address,
				; checkpoint item AOBJN pointer
	MOVE Q1,T1		;SAVE JOB # IN Q1
	CALL USGSPG		;SET CHECKPOINT PAGE
	MOVEM T1,PGID		;Save checkpoint page address in PGID
	MOVEM T4,CPAD		;Save address within page in CPAD
	HRRZ Q3,1(T4)		;[7.1200] Get length of entry
	ADDI Q3,CKOFF(T4)	;[7.1200] Point to checkpoint data
	HRLI Q3,-CKITMS		;[7.1200] Form AOBJN pointer
	MOVEM Q3,CPIP		;[7.1200] Save checkpoint item pointer
	CALL LGTAD		;GET CURRENT DATE/TIME
	MOVEM T1,2(T4)		; INTO CHECKPOINT RECORD
	MOVE T1,Q1		;JOB #
	NOSKED			;DO THIS NOSKED
	SKIPN JOBDIR(T1)	;JOB LOGGED IN?
	JRST [	OKSKED		;NO - JUST RETURN
		JRST CPNT3]
	CALL SETJSB		;MAP JSB FOR JOB
	OKSKED			;JOB IS NOW FIXED IN MY MAP
	MOVE T3,T1		;SAVE PNTR IN T3
	MOVEI Q2,0		;INIT INDEX TO 0

; *** NOTE *** WITH FIXES TO SESSION START TIME, IT MAY NOT BE NECESSARY
; TO RESET THE SESSION START TIME ALL THE TIME. IF YOU CAN PROVE IT ...

CPNT1:	XCT CPTBL(Q2)		;FETCH WORD
	MOVEM T1,0(Q3)		;[7.1200] Store it
	AOS Q2			;STEP TO NEXT TABLE ENTRY
	AOBJN Q3,CPNT1		;[7.1200] Loop for all entries

	SKIPN ASCFLG		;This accounting shift change also?
	 JRST CPNT2		;No-- go on

; Accounting shift change-- update USAGE file

	MOVE T1,PGID		;Get page ident
	MOVE T4,CPAD		;Address within page
	PUSH P,T3		;Save JSB pointer
	CALL USGUPS		;Make new USAGE entry
	SETZM 0(T4)		;Indicate checkpoint entry still in use
	POP P,T3		;Restore JSB pointer

; Reset job statistics and set new checkpoint entry

	MOVE Q3,CPIP		;[7.1200] Get checkpoint item pointer
	MOVEI Q2,0		;INIT INDEX TO 0
CPNT11:	MOVE T1,0(Q3)		;[7.1200] Get old value
	XCT SETBL(Q2)		;Reset current value of data item
	XCT CPTBL(Q2)		;Get new value of data item
	MOVEM T1,0(Q3)		;[7.1200] Store it
	AOS Q2			;STEP TO NEXT TABLE ENTRY
	AOBJN Q3,CPNT11		;[7.1200] Loop for all entries in table

CPNT2:	CALL CLRJSB		;UNMAP JSB
CPNT3:	RET			;RETURN FROM CPOINT

;CHECKPOINT DATA TABLE

CPTBL:	MOVE T1,JSSCTI(T3)	;[7456] (0) Session start time
	CALL CPGCON		;(1) GET CONNECT TIME
	CALL CPGRTM		;(2) JOB RUN TIME

;Checkpoint data routines

CPGCON:	MOVE T1,TODCLK		;CURRENT DATE/TIME
	SUB T1,CONSTO(T3)	; LESS START TIME
	SUB T1,JSSCTM(T3)	; from start of session
	RET			;GIVES CONNECT TIME

CPGRTM:	MOVE T1,JOBRT(Q1)	;Get job runtime
	SUB T1,JSSRTM(T3)	; from start of session
	RET			;Return from CPGRTM

;Session End data table

SETBL:	CALL SESCTI		;(0) Date/time of session start
	ADDM T1,JSSCTM(T3)	;(1) Console time start of session
	ADDM T1,JSSRTM(T3)	;(2) Runtime start of session

;Session End data routines

SESCTI:	CALL LGTAD		;Get current date/time
	MOVEM T1,JSSCTI(T3)	;[7456] Set start of new session
	RET			;Return from SESCTI


;PERFORM CHECKPOINT OVER ALL JOBS

USGCKU:	CALL USGCKP		;DO WORK
	JRST USGULR		;Unlock waiter and return

;Perform accounting shift change

USGASU:	CALL USGASC		;Do work
USGULR:	UNLOCK (USGLOK)		;UNLOCK WAITER
	RET			;RETURN

;Internal routine to perform checkpoint of all jobs
; or accounting shift change

USGCKP:	SETZM ASCFLG		;Note not accounting shift change
	JRST USGC00		;Continue

USGASC:	SETOM ASCFLG		;Note accounting shift change
USGC00:	MOVEI Q1,NJOBS-1	;MAX JOBS TO DO

; Loop over all active jobs

USGCK0:	SKIPN JOBDIR(Q1)	;JOB EXIST AND IS LOGGED IN?
	JRST USGCK1		;NO - STEP TO NEXT
	MOVE T1,Q1		;COPY JOB #
	CALL CPONT0		;CHECKPOINT ONE JOB
USGCK1:	SOJG Q1,USGCK0		;LOOP OVER ALL
	MOVEI T1,0		;MAP JOB 0 ENTRY
	CALL USGSPG		;...
	MOVE Q1,T4		;POINTER TO ENTRY
	MOVE Q2,T1		;PAGE IDENT
	CALL LGTAD		;GET CURRENT DATE/TIME
	MOVEM T1,2(Q1)		;UPDATE DATE/TIME OF CKPOINT
	MOVE T1,Q2		;UNMAP PAGE
	CALLRET UNMAPC		; AND EXIT
	SUBTTL End of JSYSM

	RESCD

	TNXEND
	END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      